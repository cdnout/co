var singleSpa=Object.freeze({__proto__:null,get start(){return start},get ensureJQuerySupport(){return ensureJQuerySupport},get setBootstrapMaxTime(){return setBootstrapMaxTime},get setMountMaxTime(){return setMountMaxTime},get setUnmountMaxTime(){return setUnmountMaxTime},get setUnloadMaxTime(){return setUnloadMaxTime},get registerApplication(){return registerApplication},get unregisterApplication(){return unregisterApplication},get getMountedApps(){return getMountedApps},get getAppStatus(){return getAppStatus},get unloadApplication(){return unloadApplication},get checkActivityFunctions(){return checkActivityFunctions},get getAppNames(){return getAppNames},get pathToActiveWhen(){return pathToActiveWhen},get navigateToUrl(){return navigateToUrl},get triggerAppChange(){return triggerAppChange},get addErrorHandler(){return addErrorHandler},get removeErrorHandler(){return removeErrorHandler},get mountRootParcel(){return mountRootParcel},get NOT_LOADED(){return NOT_LOADED},get LOADING_SOURCE_CODE(){return LOADING_SOURCE_CODE},get NOT_BOOTSTRAPPED(){return NOT_BOOTSTRAPPED},get BOOTSTRAPPING(){return BOOTSTRAPPING},get NOT_MOUNTED(){return NOT_MOUNTED},get MOUNTING(){return MOUNTING},get UPDATING(){return UPDATING},get LOAD_ERROR(){return LOAD_ERROR},get MOUNTED(){return MOUNTED},get UNMOUNTING(){return UNMOUNTING},get SKIP_BECAUSE_BROKEN(){return SKIP_BECAUSE_BROKEN}}),commonjsGlobal="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{},NativeCustomEvent=commonjsGlobal.CustomEvent;function useNative(){try{var e=new NativeCustomEvent("cat",{detail:{foo:"bar"}});return"cat"===e.type&&"bar"===e.detail.foo}catch(e){}return!1}var customEvent=useNative()?NativeCustomEvent:"undefined"!=typeof document&&"function"==typeof document.createEvent?function(e,t){var n=document.createEvent("CustomEvent");return t?n.initCustomEvent(e,t.bubbles,t.cancelable,t.detail):n.initCustomEvent(e,!1,!1,void 0),n}:function(e,t){var n=document.createEventObject();return n.type=e,t?(n.bubbles=Boolean(t.bubbles),n.cancelable=Boolean(t.cancelable),n.detail=t.detail):(n.bubbles=!1,n.cancelable=!1,n.detail=void 0),n};let errorHandlers=[];function handleAppError(e,t,n){const r=transformErr(e,t,n);errorHandlers.length?errorHandlers.forEach(e=>e(r)):setTimeout(()=>{throw r})}function addErrorHandler(e){if("function"!=typeof e)throw Error(formatErrorMessage(28,"a single-spa error handler must be a function"));errorHandlers.push(e)}function removeErrorHandler(e){if("function"!=typeof e)throw Error(formatErrorMessage(29,"a single-spa error handler must be a function"));let t=!1;return errorHandlers=errorHandlers.filter(n=>{const r=n===e;return t=t||r,!r}),t}function formatErrorMessage(e,t,...n){return`single-spa minified message #${e}: ${t?t+" ":""}See https://single-spa.js.org/error/?code=${e}${n.length?`&arg=${n.join("&arg=")}`:""}`}function transformErr(e,t,n){const r=`${objectType(t)} '${toName(t)}' died in status ${t.status}: `;let o;if(e instanceof Error){try{e.message=r+e.message}catch(e){}o=e}else{console.warn(formatErrorMessage(30,`While ${t.status}, '${toName(t)}' rejected its lifecycle function promise with a non-Error. This will cause stack traces to not be accurate.`,t.status,toName(t)));try{o=Error(r+JSON.stringify(e))}catch(t){o=e}}return o.appOrParcelName=toName(t),t.status=n,o}const NOT_LOADED="NOT_LOADED",LOADING_SOURCE_CODE="LOADING_SOURCE_CODE",NOT_BOOTSTRAPPED="NOT_BOOTSTRAPPED",BOOTSTRAPPING="BOOTSTRAPPING",NOT_MOUNTED="NOT_MOUNTED",MOUNTING="MOUNTING",MOUNTED="MOUNTED",UPDATING="UPDATING",UNMOUNTING="UNMOUNTING",UNLOADING="UNLOADING",LOAD_ERROR="LOAD_ERROR",SKIP_BECAUSE_BROKEN="SKIP_BECAUSE_BROKEN";function isActive(e){return e.status===MOUNTED}function shouldBeActive(e){try{return e.activeWhen(window.location)}catch(t){return handleAppError(t,e,SKIP_BECAUSE_BROKEN),!1}}function toName(e){return e.name}function isParcel(e){return Boolean(e.unmountThisParcel)}function objectType(e){return isParcel(e)?"parcel":"application"}function assign(){for(let e=arguments.length-1;e>0;e--)for(let t in arguments[e])"__proto__"!==t&&(arguments[e-1][t]=arguments[e][t]);return arguments[0]}function find(e,t){for(let n=0;n<e.length;n++)if(t(e[n]))return e[n];return null}function validLifecycleFn(e){return e&&("function"==typeof e||(t=e,Array.isArray(t)&&!find(t,e=>"function"!=typeof e)));var t}function flattenFnArray(e,t){let n=e[t]||[];0===(n=Array.isArray(n)?n:[n]).length&&(n=[()=>Promise.resolve()]);const r=objectType(e),o=toName(e);return function(e){return n.reduce((n,a,i)=>n.then(()=>{const n=a(e);return smellsLikeAPromise(n)?n:Promise.reject(formatErrorMessage(15,`Within ${r} ${o}, the lifecycle function ${t} at array index ${i} did not return a promise`,r,o,t,i))}),Promise.resolve())}}function smellsLikeAPromise(e){return e&&"function"==typeof e.then&&"function"==typeof e.catch}function toBootstrapPromise(e,t){return Promise.resolve().then(()=>e.status!==NOT_BOOTSTRAPPED?e:(e.status=BOOTSTRAPPING,e.bootstrap?reasonableTime(e,"bootstrap").then(n).catch(n=>{if(t)throw transformErr(n,e,SKIP_BECAUSE_BROKEN);return handleAppError(n,e,SKIP_BECAUSE_BROKEN),e}):Promise.resolve().then(n)));function n(){return e.status=NOT_MOUNTED,e}}function toUnmountPromise(e,t){return Promise.resolve().then(()=>{if(e.status!==MOUNTED)return e;e.status=UNMOUNTING;const n=Object.keys(e.parcels).map(t=>e.parcels[t].unmountThisParcel());return Promise.all(n).then(r,n=>r().then(()=>{const r=Error(n.message);if(t)throw transformErr(r,e,SKIP_BECAUSE_BROKEN);handleAppError(r,e,SKIP_BECAUSE_BROKEN)})).then(()=>e);function r(){return reasonableTime(e,"unmount").then(()=>{e.status=NOT_MOUNTED}).catch(n=>{if(t)throw transformErr(n,e,SKIP_BECAUSE_BROKEN);handleAppError(n,e,SKIP_BECAUSE_BROKEN)})}})}let beforeFirstMountFired=!1,firstMountFired=!1;function toMountPromise(e,t){return Promise.resolve().then(()=>e.status!==NOT_MOUNTED?e:(beforeFirstMountFired||(window.dispatchEvent(new customEvent("single-spa:before-first-mount")),beforeFirstMountFired=!0),reasonableTime(e,"mount").then(()=>(e.status=MOUNTED,firstMountFired||(window.dispatchEvent(new customEvent("single-spa:first-mount")),firstMountFired=!0),e)).catch(n=>{return e.status=MOUNTED,toUnmountPromise(e,!0).then(r,r);function r(){if(t)throw transformErr(n,e,SKIP_BECAUSE_BROKEN);return handleAppError(n,e,SKIP_BECAUSE_BROKEN),e}})))}function toUpdatePromise(e){return Promise.resolve().then(()=>{if(e.status!==MOUNTED)throw Error(formatErrorMessage(32,`Cannot update parcel '${toName(e)}' because it is not mounted`,toName(e)));return e.status=UPDATING,reasonableTime(e,"update").then(()=>(e.status=MOUNTED,e)).catch(t=>{throw transformErr(t,e,SKIP_BECAUSE_BROKEN)})})}let parcelCount=0;const rootParcels={parcels:{}};function mountRootParcel(){return mountParcel.apply(rootParcels,arguments)}function mountParcel(e,t){const n=this;if(!e||"object"!=typeof e&&"function"!=typeof e)throw Error(formatErrorMessage(2,"Cannot mount parcel without a config object or config loading function"));if(e.name&&"string"!=typeof e.name)throw Error(formatErrorMessage(3,`Parcel name must be a string, if provided. Was given ${typeof e.name}`,typeof e.name));if("object"!=typeof t)throw Error(formatErrorMessage(4,`Parcel ${name} has invalid customProps -- must be an object but was given ${typeof t}`,name,typeof t));if(!t.domElement)throw Error(formatErrorMessage(5,`Parcel ${name} cannot be mounted without a domElement provided as a prop`,name));const r=parcelCount++,o="function"==typeof e,a=o?e:()=>Promise.resolve(e),i={id:r,parcels:{},status:o?LOADING_SOURCE_CODE:NOT_BOOTSTRAPPED,customProps:t,parentName:toName(n),unmountThisParcel:()=>p.then(()=>{if(i.status!==MOUNTED)throw Error(formatErrorMessage(6,`Cannot unmount parcel '${name}' -- it is in a ${i.status} status`,name,i.status));return toUnmountPromise(i,!0)}).then(e=>(i.parentName&&delete n.parcels[i.id],e)).then(e=>(c(e),e)).catch(e=>{throw i.status=SKIP_BECAUSE_BROKEN,m(e),e})};let s;n.parcels[r]=i;let u=a();if(!u||"function"!=typeof u.then)throw Error(formatErrorMessage(7,"When mounting a parcel, the config loading function must return a promise that resolves with the parcel config"));const l=(u=u.then(e=>{if(!e)throw Error(formatErrorMessage(8,"When mounting a parcel, the config loading function returned a promise that did not resolve with a parcel config"));const t=e.name||`parcel-${r}`;if(Object.prototype.hasOwnProperty.call(e,"bootstrap")&&!validLifecycleFn(e.bootstrap))throw Error(formatErrorMessage(9,`Parcel ${t} provided an invalid bootstrap function`,t));if(!validLifecycleFn(e.mount))throw Error(formatErrorMessage(10,`Parcel ${t} must have a valid mount function`,t));if(!validLifecycleFn(e.unmount))throw Error(formatErrorMessage(11,`Parcel ${t} must have a valid unmount function`,t));if(e.update&&!validLifecycleFn(e.update))throw Error(formatErrorMessage(12,`Parcel ${t} provided an invalid update function`,t));const n=flattenFnArray(e,"bootstrap"),o=flattenFnArray(e,"mount"),a=flattenFnArray(e,"unmount");i.status=NOT_BOOTSTRAPPED,i.name=t,i.bootstrap=n,i.mount=o,i.unmount=a,i.timeouts=ensureValidAppTimeouts(e.timeouts),e.update&&(i.update=flattenFnArray(e,"update"),s.update=function(e){return i.customProps=e,promiseWithoutReturnValue(toUpdatePromise(i))})})).then(()=>toBootstrapPromise(i,!0)),p=l.then(()=>toMountPromise(i,!0));let c,m;const f=new Promise((e,t)=>{c=e,m=t});return s={mount:()=>promiseWithoutReturnValue(Promise.resolve().then(()=>{if(i.status!==NOT_MOUNTED)throw Error(formatErrorMessage(13,`Cannot mount parcel '${name}' -- it is in a ${i.status} status`,name,i.status));return n.parcels[r]=i,toMountPromise(i)})),unmount:()=>promiseWithoutReturnValue(i.unmountThisParcel()),getStatus:()=>i.status,loadPromise:promiseWithoutReturnValue(u),bootstrapPromise:promiseWithoutReturnValue(l),mountPromise:promiseWithoutReturnValue(p),unmountPromise:promiseWithoutReturnValue(f)}}function promiseWithoutReturnValue(e){return e.then(()=>null)}function getProps(e){const t=toName(e);let n="function"==typeof e.customProps?e.customProps(t,window.location):e.customProps;("object"!=typeof n||null===n||Array.isArray(n))&&(n={},console.warn(formatErrorMessage(40,`single-spa: ${t}'s customProps function must return an object. Received ${n}`),t,n));const r=assign({},n,{name:t,mountParcel:mountParcel.bind(e),singleSpa:singleSpa});return isParcel(e)&&(r.unmountSelf=e.unmountThisParcel),r}const defaultWarningMillis=1e3,globalTimeoutConfig={bootstrap:{millis:4e3,dieOnTimeout:!1,warningMillis:defaultWarningMillis},mount:{millis:3e3,dieOnTimeout:!1,warningMillis:defaultWarningMillis},unmount:{millis:3e3,dieOnTimeout:!1,warningMillis:defaultWarningMillis},unload:{millis:3e3,dieOnTimeout:!1,warningMillis:defaultWarningMillis},update:{millis:3e3,dieOnTimeout:!1,warningMillis:defaultWarningMillis}};function setBootstrapMaxTime(e,t,n){if("number"!=typeof e||e<=0)throw Error(formatErrorMessage(16,"bootstrap max time must be a positive integer number of milliseconds"));globalTimeoutConfig.bootstrap={millis:e,dieOnTimeout:t,warningMillis:n||defaultWarningMillis}}function setMountMaxTime(e,t,n){if("number"!=typeof e||e<=0)throw Error(formatErrorMessage(17,"mount max time must be a positive integer number of milliseconds"));globalTimeoutConfig.mount={millis:e,dieOnTimeout:t,warningMillis:n||defaultWarningMillis}}function setUnmountMaxTime(e,t,n){if("number"!=typeof e||e<=0)throw Error(formatErrorMessage(18,"unmount max time must be a positive integer number of milliseconds"));globalTimeoutConfig.unmount={millis:e,dieOnTimeout:t,warningMillis:n||defaultWarningMillis}}function setUnloadMaxTime(e,t,n){if("number"!=typeof e||e<=0)throw Error(formatErrorMessage(19,"unload max time must be a positive integer number of milliseconds"));globalTimeoutConfig.unload={millis:e,dieOnTimeout:t,warningMillis:n||defaultWarningMillis}}function reasonableTime(e,t){const n=e.timeouts[t],r=n.warningMillis,o=objectType(e);return new Promise((a,i)=>{let s=!1,u=!1;e[t](getProps(e)).then(e=>{s=!0,a(e)}).catch(e=>{s=!0,i(e)}),setTimeout(()=>p(1),r),setTimeout(()=>p(!0),n.millis);const l=formatErrorMessage(31,`Lifecycle function ${t} for ${o} ${toName(e)} lifecycle did not resolve or reject for ${n.millis} ms.`,t,o,toName(e),n.millis);function p(e){if(!s)if(!0===e)u=!0,n.dieOnTimeout?i(Error(l)):console.error(l);else if(!u){const t=e,o=t*r;console.warn(l),o+r<n.millis&&setTimeout(()=>p(t+1),r)}}})}function ensureValidAppTimeouts(e){const t={};for(let n in globalTimeoutConfig)t[n]=assign({},globalTimeoutConfig[n],e&&e[n]||{});return t}function toLoadPromise(e){return Promise.resolve().then(()=>{if(e.loadPromise)return e.loadPromise;if(e.status!==NOT_LOADED&&e.status!==LOAD_ERROR)return e;let t,n;return e.status=LOADING_SOURCE_CODE,e.loadPromise=Promise.resolve().then(()=>{const r=e.loadApp(getProps(e));if(!smellsLikeAPromise(r))throw n=!0,Error(formatErrorMessage(33,`single-spa loading function did not return a promise. Check the second argument to registerApplication('${toName(e)}', loadingFunction, activityFunction)`,toName(e)));return r.then(n=>{let r,o;e.loadErrorTime=null,"object"!=typeof(t=n)&&(o=34,r="does not export anything"),Object.prototype.hasOwnProperty.call(t,"bootstrap")&&!validLifecycleFn(t.bootstrap)&&(o=35,r="does not export a valid bootstrap function or array of functions"),validLifecycleFn(t.mount)||(o=36,r="does not export a mount function or array of functions"),validLifecycleFn(t.unmount)||(o=37,r="does not export a unmount function or array of functions");const a=objectType(t);if(o){let n;try{n=JSON.stringify(t)}catch(e){}return console.error(formatErrorMessage(o,`The loading function for single-spa ${a} '${toName(e)}' resolved with the following, which does not have bootstrap, mount, and unmount functions`,a,toName(e),n),t),handleAppError(r,e,SKIP_BECAUSE_BROKEN),e}return t.devtools&&t.devtools.overlays&&(e.devtools.overlays=assign({},e.devtools.overlays,t.devtools.overlays)),e.status=NOT_BOOTSTRAPPED,e.bootstrap=flattenFnArray(t,"bootstrap"),e.mount=flattenFnArray(t,"mount"),e.unmount=flattenFnArray(t,"unmount"),e.unload=flattenFnArray(t,"unload"),e.timeouts=ensureValidAppTimeouts(t.timeouts),delete e.loadPromise,e})}).catch(t=>{let r;return delete e.loadPromise,n?r=SKIP_BECAUSE_BROKEN:(r=LOAD_ERROR,e.loadErrorTime=(new Date).getTime()),handleAppError(t,e,r),e})})}const isInBrowser="undefined"!=typeof window,capturedEventListeners={hashchange:[],popstate:[]},routingEventsListeningTo=["hashchange","popstate"];function navigateToUrl(e){let t;if("string"==typeof e)t=e;else if(this&&this.href)t=this.href;else{if(!(e&&e.currentTarget&&e.currentTarget.href&&e.preventDefault))throw Error(formatErrorMessage(14,"singleSpaNavigate/navigateToUrl must be either called with a string url, with an <a> tag as its context, or with an event whose currentTarget is an <a> tag"));t=e.currentTarget.href,e.preventDefault()}const n=parseUri(window.location.href),r=parseUri(t);0===t.indexOf("#")?window.location.hash=r.hash:n.host!==r.host&&r.host?window.location.href=t:r.pathname===n.pathname&&r.search===n.search?window.location.hash=r.hash:window.history.pushState(null,null,t)}function callCapturedEventListeners(e){if(e){const t=e[0].type;routingEventsListeningTo.indexOf(t)>=0&&capturedEventListeners[t].forEach(t=>{try{t.apply(this,e)}catch(e){setTimeout(()=>{throw e})}})}}let urlRerouteOnly;function setUrlRerouteOnly(e){urlRerouteOnly=e}function urlReroute(){reroute([],arguments)}function patchedUpdateState(e,t){return function(){const n=window.location.href,r=e.apply(this,arguments),o=window.location.href;return urlRerouteOnly&&n===o||(isStarted()?window.dispatchEvent(createPopStateEvent(window.history.state,t)):reroute([])),r}}function createPopStateEvent(e,t){let n;try{n=new PopStateEvent("popstate",{state:e})}catch(t){(n=document.createEvent("PopStateEvent")).initPopStateEvent("popstate",!1,!1,e)}return n.singleSpa=!0,n.singleSpaTrigger=t,n}if(isInBrowser){window.addEventListener("hashchange",urlReroute),window.addEventListener("popstate",urlReroute);const e=window.addEventListener,t=window.removeEventListener;window.addEventListener=function(t,n){if(!("function"==typeof n&&routingEventsListeningTo.indexOf(t)>=0)||find(capturedEventListeners[t],e=>e===n))return e.apply(this,arguments);capturedEventListeners[t].push(n)},window.removeEventListener=function(e,n){if(!("function"==typeof n&&routingEventsListeningTo.indexOf(e)>=0))return t.apply(this,arguments);capturedEventListeners[e]=capturedEventListeners[e].filter(e=>e!==n)},window.history.pushState=patchedUpdateState(window.history.pushState,"pushState"),window.history.replaceState=patchedUpdateState(window.history.replaceState,"replaceState"),window.singleSpaNavigate?console.warn(formatErrorMessage(41,"single-spa has been loaded twice on the page. This can result in unexpected behavior.")):window.singleSpaNavigate=navigateToUrl}function parseUri(e){const t=document.createElement("a");return t.href=e,t}let hasInitialized=!1;function ensureJQuerySupport(e=window.jQuery){if(e||window.$&&window.$.fn&&window.$.fn.jquery&&(e=window.$),e&&!hasInitialized){const t=e.fn.on,n=e.fn.off;e.fn.on=function(e,n){return captureRoutingEvents.call(this,t,window.addEventListener,e,n,arguments)},e.fn.off=function(e,t){return captureRoutingEvents.call(this,n,window.removeEventListener,e,t,arguments)},hasInitialized=!0}}function captureRoutingEvents(e,t,n,r,o){if("string"!=typeof n)return e.apply(this,o);return n.split(/\s+/).forEach(e=>{routingEventsListeningTo.indexOf(e)>=0&&(t(e,r),n=n.replace(e,""))}),""===n.trim()?this:e.apply(this,o)}const appsToUnload={};function toUnloadPromise(e){return Promise.resolve().then(()=>{const t=appsToUnload[toName(e)];return t?e.status===NOT_LOADED?(finishUnloadingApp(e,t),e):e.status===UNLOADING?t.promise.then(()=>e):e.status!==NOT_MOUNTED?e:(e.status=UNLOADING,reasonableTime(e,"unload").then(()=>(finishUnloadingApp(e,t),e)).catch(n=>(errorUnloadingApp(e,t,n),e))):e})}function finishUnloadingApp(e,t){delete appsToUnload[toName(e)],delete e.bootstrap,delete e.mount,delete e.unmount,delete e.unload,e.status=NOT_LOADED,t.resolve()}function errorUnloadingApp(e,t,n){delete appsToUnload[toName(e)],delete e.bootstrap,delete e.mount,delete e.unmount,delete e.unload,handleAppError(n,e,SKIP_BECAUSE_BROKEN),t.reject(n)}function addAppToUnload(e,t,n,r){appsToUnload[toName(e)]={app:e,resolve:n,reject:r},Object.defineProperty(appsToUnload[toName(e)],"promise",{get:t})}function getAppUnloadInfo(e){return appsToUnload[e]}const apps=[];function getAppChanges(){const e=[],t=[],n=[],r=[],o=(new Date).getTime();return apps.forEach(a=>{const i=a.status!==SKIP_BECAUSE_BROKEN&&shouldBeActive(a);switch(a.status){case LOAD_ERROR:i&&o-a.loadErrorTime>=200&&n.push(a);break;case NOT_LOADED:case LOADING_SOURCE_CODE:i&&n.push(a);break;case NOT_BOOTSTRAPPED:case NOT_MOUNTED:!i&&getAppUnloadInfo(toName(a))?e.push(a):i&&r.push(a);break;case MOUNTED:i||t.push(a)}}),{appsToUnload:e,appsToUnmount:t,appsToLoad:n,appsToMount:r}}function getMountedApps(){return apps.filter(isActive).map(toName)}function getAppNames(){return apps.map(toName)}function getRawAppData(){return[...apps]}function getAppStatus(e){const t=find(apps,t=>toName(t)===e);return t?t.status:null}function registerApplication(e,t,n,r){const o=sanitizeArguments(e,t,n,r);if(-1!==getAppNames().indexOf(o.name))throw Error(formatErrorMessage(21,`There is already an app registered with name ${o.name}`,o.name));apps.push(assign({loadErrorTime:null,status:NOT_LOADED,parcels:{},devtools:{overlays:{options:{},selectors:[]}}},o)),isInBrowser&&(ensureJQuerySupport(),reroute())}function checkActivityFunctions(e=window.location){return apps.filter(t=>t.activeWhen(e)).map(toName)}function unregisterApplication(e){if(0===apps.filter(t=>toName(t)===e).length)throw Error(formatErrorMessage(25,`Cannot unregister application '${e}' because no such application has been registered`,e));return unloadApplication(e).then(()=>{const t=apps.map(toName).indexOf(e);apps.splice(t,1)})}function unloadApplication(e,t={waitForUnmount:!1}){if("string"!=typeof e)throw Error(formatErrorMessage(26,"unloadApplication requires a string 'appName'"));const n=find(apps,t=>toName(t)===e);if(!n)throw Error(formatErrorMessage(27,`Could not unload application '${e}' because no such application has been registered`,e));const r=getAppUnloadInfo(toName(n));if(t&&t.waitForUnmount){if(r)return r.promise;{const e=new Promise((t,r)=>{addAppToUnload(n,()=>e,t,r)});return e}}{let e;return r?(e=r.promise,immediatelyUnloadApp(n,r.resolve,r.reject)):e=new Promise((t,r)=>{addAppToUnload(n,()=>e,t,r),immediatelyUnloadApp(n,t,r)}),e}}function immediatelyUnloadApp(e,t,n){toUnmountPromise(e).then(toUnloadPromise).then(()=>{t(),setTimeout(()=>{reroute()})}).catch(n)}function validateRegisterWithArguments(e,t,n,r){if("string"!=typeof e||0===e.length)throw Error(formatErrorMessage(20,"The 1st argument to registerApplication must be a non-empty string 'appName'"));if(!t)throw Error(formatErrorMessage(23,"The 2nd argument to registerApplication must be an application or loading application function"));if("function"!=typeof n)throw Error(formatErrorMessage(24,"The 3rd argument to registerApplication must be an activeWhen function"));if(!validCustomProps(r))throw Error(formatErrorMessage(22,"The optional 4th argument is a customProps and must be an object"))}function validateRegisterWithConfig(e){if(Array.isArray(e)||null===e)throw Error(formatErrorMessage(39,"Configuration object can't be an Array or null!"));const t=["name","app","activeWhen","customProps"],n=Object.keys(e).reduce((e,n)=>t.indexOf(n)>=0?e:e.concat(n),[]);if(0!==n.length)throw Error(formatErrorMessage(38,`The configuration object accepts only: ${t.join(", ")}. Invalid keys: ${n.join(", ")}.`,t.join(", "),n.join(", ")));if("string"!=typeof e.name||0===e.name.length)throw Error(formatErrorMessage(20,"The config.name on registerApplication must be a non-empty string"));if("object"!=typeof e.app&&"function"!=typeof e.app)throw Error(formatErrorMessage(20,"The config.app on registerApplication must be an application or a loading function"));const r=e=>"string"==typeof e||"function"==typeof e;if(!(r(e.activeWhen)||Array.isArray(e.activeWhen)&&e.activeWhen.every(r)))throw Error(formatErrorMessage(24,"The config.activeWhen on registerApplication must be a string, function or an array with both"));if(!validCustomProps(e.customProps))throw Error(formatErrorMessage(22,"The optional config.customProps must be an object"))}function validCustomProps(e){return!e||"function"==typeof e||"object"==typeof e&&null!==e&&!Array.isArray(e)}function sanitizeArguments(e,t,n,r){const o={name:null,loadApp:null,activeWhen:null,customProps:null};return"object"==typeof e?(validateRegisterWithConfig(e),o.name=e.name,o.loadApp=e.app,o.activeWhen=e.activeWhen,o.customProps=e.customProps):(validateRegisterWithArguments(e,t,n,r),o.name=e,o.loadApp=t,o.activeWhen=n,o.customProps=r),o.loadApp=sanitizeLoadApp(o.loadApp),o.customProps=sanitizeCustomProps(o.customProps),o.activeWhen=sanitizeActiveWhen(o.activeWhen),o}function sanitizeLoadApp(e){return"function"!=typeof e?()=>Promise.resolve(e):e}function sanitizeCustomProps(e){return e||{}}function sanitizeActiveWhen(e){let t=Array.isArray(e)?e:[e];return t=t.map(e=>"function"==typeof e?e:pathToActiveWhen(e)),e=>t.some(t=>t(e))}function pathToActiveWhen(e,t){const n=toDynamicPathValidatorRegex(e,t);return e=>{const t=e.href.replace(e.origin,"").replace(e.search,"").split("?")[0];return n.test(t)}}function toDynamicPathValidatorRegex(e,t){let n=0,r=!1,o="^";"/"!==e[0]&&(e="/"+e);for(let t=0;t<e.length;t++){const n=e[t];(!r&&":"===n||r&&"/"===n)&&a(t)}return a(e.length),new RegExp(o,"i");function a(a){const i=e.slice(n,a).replace(/[|\\{}()[\]^$+*?.]/g,"\\$&");if(o+=r?"[^/]+/?":i,a===e.length)if(r)t&&(o+="$");else{const e=t?"":".*";o="/"===o.charAt(o.length-1)?`${o}${e}$`:`${o}(/${e})?(#.*)?$`}r=!r,n=a}}let appChangeUnderway=!1,peopleWaitingOnAppChange=[],currentUrl=isInBrowser&&window.location.href;function triggerAppChange(){return reroute()}function reroute(e=[],t){if(appChangeUnderway)return new Promise((e,n)=>{peopleWaitingOnAppChange.push({resolve:e,reject:n,eventArguments:t})});const{appsToUnload:n,appsToUnmount:r,appsToLoad:o,appsToMount:a}=getAppChanges();let i,s=!1,u=currentUrl,l=currentUrl=window.location.href;return isStarted()?(appChangeUnderway=!0,i=n.concat(o,r,a),Promise.resolve().then(()=>{if(window.dispatchEvent(new customEvent(0===i.length?"single-spa:before-no-app-change":"single-spa:before-app-change",f(!0))),window.dispatchEvent(new customEvent("single-spa:before-routing-event",f(!0,{cancelNavigation:p}))),s)return window.dispatchEvent(new customEvent("single-spa:before-mount-routing-event",f(!0))),c(),void navigateToUrl(u);const t=n.map(toUnloadPromise),l=r.map(toUnmountPromise).map(e=>e.then(toUnloadPromise)),d=l.concat(t),h=Promise.all(d);h.then(()=>{window.dispatchEvent(new customEvent("single-spa:before-mount-routing-event",f(!0)))});const g=o.map(e=>toLoadPromise(e).then(e=>tryToBootstrapAndMount(e,h))),E=a.filter(e=>o.indexOf(e)<0).map(e=>tryToBootstrapAndMount(e,h));return h.catch(e=>{throw m(),e}).then(()=>(m(),Promise.all(g.concat(E)).catch(t=>{throw e.forEach(e=>e.reject(t)),t}).then(c)))})):(i=o,Promise.resolve().then(()=>{const e=o.map(toLoadPromise);return Promise.all(e).then(m).then(()=>[]).catch(e=>{throw m(),e})}));function p(){s=!0}function c(){const t=getMountedApps();e.forEach(e=>e.resolve(t));try{const e=0===i.length?"single-spa:no-app-change":"single-spa:app-change";window.dispatchEvent(new customEvent(e,f())),window.dispatchEvent(new customEvent("single-spa:routing-event",f()))}catch(e){setTimeout(()=>{throw e})}if(appChangeUnderway=!1,peopleWaitingOnAppChange.length>0){const e=peopleWaitingOnAppChange;peopleWaitingOnAppChange=[],reroute(e)}return t}function m(){e.forEach(e=>{callCapturedEventListeners(e.eventArguments)}),callCapturedEventListeners(t)}function f(e=!1,p){const c={},m={[MOUNTED]:[],[NOT_MOUNTED]:[],[NOT_LOADED]:[],[SKIP_BECAUSE_BROKEN]:[]};e?(o.concat(a).forEach((e,t)=>{d(e,MOUNTED)}),n.forEach(e=>{d(e,NOT_LOADED)}),r.forEach(e=>{d(e,NOT_MOUNTED)})):i.forEach(e=>{d(e)});const f={detail:{newAppStatuses:c,appsByNewStatus:m,totalAppChanges:i.length,originalEvent:null==t?void 0:t[0],oldUrl:u,newUrl:l,navigationIsCanceled:s}};return p&&assign(f.detail,p),f;function d(e,t){const n=toName(e);t=t||getAppStatus(n),c[n]=t,(m[t]=m[t]||[]).push(n)}}}function tryToBootstrapAndMount(e,t){return shouldBeActive(e)?toBootstrapPromise(e).then(e=>t.then(()=>shouldBeActive(e)?toMountPromise(e):e)):t.then(()=>e)}let started=!1;function start(e){started=!0,e&&e.urlRerouteOnly&&setUrlRerouteOnly(e.urlRerouteOnly),isInBrowser&&reroute()}function isStarted(){return started}isInBrowser&&setTimeout(()=>{started||console.warn(formatErrorMessage(1,"singleSpa.start() has not been called, 5000ms after single-spa was loaded. Before start() is called, apps can be declared and loaded, but not bootstrapped or mounted."))},5e3);var devtools={getRawAppData:getRawAppData,reroute:reroute,NOT_LOADED:NOT_LOADED,toLoadPromise:toLoadPromise,toBootstrapPromise:toBootstrapPromise,unregisterApplication:unregisterApplication};isInBrowser&&window.__SINGLE_SPA_DEVTOOLS__&&(window.__SINGLE_SPA_DEVTOOLS__.exposedMethods=devtools);export{BOOTSTRAPPING,LOADING_SOURCE_CODE,LOAD_ERROR,MOUNTED,MOUNTING,NOT_BOOTSTRAPPED,NOT_LOADED,NOT_MOUNTED,SKIP_BECAUSE_BROKEN,UNMOUNTING,UPDATING,addErrorHandler,checkActivityFunctions,ensureJQuerySupport,getAppNames,getAppStatus,getMountedApps,mountRootParcel,navigateToUrl,pathToActiveWhen,registerApplication,removeErrorHandler,setBootstrapMaxTime,setMountMaxTime,setUnloadMaxTime,setUnmountMaxTime,start,triggerAppChange,unloadApplication,unregisterApplication};