define(["./defaultValue-81eec7ed","./Matrix2-37e55508","./ArcType-fc72c06c","./arrayRemoveDuplicates-dc2f4046","./Transforms-dca21951","./Color-1ca27bfa","./ComponentDatatype-a15c9a19","./RuntimeError-8952249c","./GeometryAttribute-cc3a5bc9","./GeometryAttributes-32b29525","./IndexDatatype-f1dcdf35","./PolylinePipeline-21ef0cd0","./VertexFormat-a0b706b0","./_commonjsHelpers-3aae1032-26891ab7","./combine-3c023bda","./WebGLConstants-508b9636","./EllipsoidGeodesic-cc3bace8","./EllipsoidRhumbLine-125a8b72","./IntersectionTests-ee135b8e","./Plane-6ee42cab"],function(V,L,F,e,G,O,R,t,I,S,B,U,y,o,r,a,n,i,l,s){"use strict";const N=[];function m(e){var t=(e=V.defaultValue(e,V.defaultValue.EMPTY_OBJECT)).positions,o=e.colors,r=V.defaultValue(e.width,1),a=V.defaultValue(e.colorsPerVertex,!1);this._positions=t,this._colors=o,this._width=r,this._colorsPerVertex=a,this._vertexFormat=y.VertexFormat.clone(V.defaultValue(e.vertexFormat,y.VertexFormat.DEFAULT)),this._arcType=V.defaultValue(e.arcType,F.ArcType.GEODESIC),this._granularity=V.defaultValue(e.granularity,R.CesiumMath.RADIANS_PER_DEGREE),this._ellipsoid=L.Ellipsoid.clone(V.defaultValue(e.ellipsoid,L.Ellipsoid.WGS84)),this._workerName="createPolylineGeometry";t=1+t.length*L.Cartesian3.packedLength;t+=V.defined(o)?1+o.length*O.Color.packedLength:1,this.packedLength=t+L.Ellipsoid.packedLength+y.VertexFormat.packedLength+4}m.pack=function(e,t,o){let r;o=V.defaultValue(o,0);var a=e._positions;let n=a.length;for(t[o++]=n,r=0;r<n;++r,o+=L.Cartesian3.packedLength)L.Cartesian3.pack(a[r],t,o);var i=e._colors;for(n=V.defined(i)?i.length:0,t[o++]=n,r=0;r<n;++r,o+=O.Color.packedLength)O.Color.pack(i[r],t,o);return L.Ellipsoid.pack(e._ellipsoid,t,o),o+=L.Ellipsoid.packedLength,y.VertexFormat.pack(e._vertexFormat,t,o),o+=y.VertexFormat.packedLength,t[o++]=e._width,t[o++]=e._colorsPerVertex?1:0,t[o++]=e._arcType,t[o]=e._granularity,t};const f=L.Ellipsoid.clone(L.Ellipsoid.UNIT_SPHERE),h=new y.VertexFormat,C={positions:void 0,colors:void 0,ellipsoid:f,vertexFormat:h,width:void 0,colorsPerVertex:void 0,arcType:void 0,granularity:void 0};m.unpack=function(e,t,o){let r;t=V.defaultValue(t,0);let a=e[t++];const n=new Array(a);for(r=0;r<a;++r,t+=L.Cartesian3.packedLength)n[r]=L.Cartesian3.unpack(e,t);a=e[t++];const i=0<a?new Array(a):void 0;for(r=0;r<a;++r,t+=O.Color.packedLength)i[r]=O.Color.unpack(e,t);var l=L.Ellipsoid.unpack(e,t,f);t+=L.Ellipsoid.packedLength;var s=y.VertexFormat.unpack(e,t,h);t+=y.VertexFormat.packedLength;var c=e[t++],p=1===e[t++],d=e[t++],u=e[t];return V.defined(o)?(o._positions=n,o._colors=i,o._ellipsoid=L.Ellipsoid.clone(l,o._ellipsoid),o._vertexFormat=y.VertexFormat.clone(s,o._vertexFormat),o._width=c,o._colorsPerVertex=p,o._arcType=d,o._granularity=u,o):(C.positions=n,C.colors=i,C.width=c,C.colorsPerVertex=p,C.arcType=d,C.granularity=u,new m(C))};const M=new L.Cartesian3,H=new L.Cartesian3,W=new L.Cartesian3,Y=new L.Cartesian3;return m.createGeometry=function(l){var s=l._width,c=l._vertexFormat;let p=l._colors;const d=l._colorsPerVertex,u=l._arcType,y=l._granularity,m=l._ellipsoid;let f,h,C;const a=[];let g=e.arrayRemoveDuplicates(l._positions,L.Cartesian3.equalsEpsilon,!1,a);if(V.defined(p)&&0<a.length){let o=0,r=a[0];p=p.filter(function(e,t){return!(d?t===r||0===t&&1===r:t+1===r)||(o++,r=a[o],!1)})}let _=g.length;if(!(_<2||s<=0)){if(u===F.ArcType.GEODESIC||u===F.ArcType.RHUMB){let o,r;r=u===F.ArcType.GEODESIC?(o=R.CesiumMath.chordLength(y,m.maximumRadius),U.PolylinePipeline.numberOfPoints):(o=y,U.PolylinePipeline.numberOfPointsRhumbLine);const G=U.PolylinePipeline.extractHeights(g,m);if(V.defined(p)){let e=1;for(f=0;f<_-1;++f)e+=r(g[f],g[f+1],o);const F=new Array(e);let t=0;for(f=0;f<_-1;++f){const R=g[f],l=g[f+1],I=p[f],S=r(R,l,o);if(d&&f<e){const V=function(e,t,o){const r=N;let a;r.length=o;var n=e.red,i=e.green,l=e.blue,s=e.alpha,c=t.red,p=t.green,d=t.blue,u=t.alpha;if(O.Color.equals(e,t)){for(a=0;a<o;a++)r[a]=O.Color.clone(e);return r}var y=(c-n)/o,m=(p-i)/o,f=(d-l)/o,h=(u-s)/o;for(a=0;a<o;a++)r[a]=new O.Color(n+a*y,i+a*m,l+a*f,s+a*h);return r}(I,p[f+1],S),L=V.length;for(h=0;h<L;++h)F[t++]=V[h]}else for(h=0;h<S;++h)F[t++]=O.Color.clone(I)}F[t]=O.Color.clone(p[p.length-1]),p=F,N.length=0}g=u===F.ArcType.GEODESIC?U.PolylinePipeline.generateCartesianArc({positions:g,minDistance:o,ellipsoid:m,height:G}):U.PolylinePipeline.generateCartesianRhumbArc({positions:g,granularity:o,ellipsoid:m,height:G})}_=g.length;const A=4*_-4,E=new Float64Array(3*A),v=new Float64Array(3*A),P=new Float64Array(3*A),w=new Float32Array(2*A),x=c.st?new Float32Array(2*A):void 0,T=V.defined(p)?new Uint8Array(4*A):void 0;let o,r=0,a=0,n=0,i=0;for(h=0;h<_;++h){let e,t;0===h?(o=M,L.Cartesian3.subtract(g[0],g[1],o),L.Cartesian3.add(g[0],o,o)):o=g[h-1],L.Cartesian3.clone(o,W),L.Cartesian3.clone(g[h],H),h===_-1?(o=M,L.Cartesian3.subtract(g[_-1],g[_-2],o),L.Cartesian3.add(g[_-1],o,o)):o=g[h+1],L.Cartesian3.clone(o,Y),V.defined(T)&&(e=0===h||d?p[h]:p[h-1],h!==_-1&&(t=p[h]));const G=h===_-1?2:4;for(C=0===h?2:0;C<G;++C){L.Cartesian3.pack(H,E,r),L.Cartesian3.pack(W,v,r),L.Cartesian3.pack(Y,P,r),r+=3;const G=C-2<0?-1:1;if(w[a++]=C%2*2-1,w[a++]=G*s,c.st&&(x[n++]=h/(_-1),x[n++]=Math.max(w[a-2],0)),V.defined(T)){const V=C<2?e:t;T[i++]=O.Color.floatToByte(V.red),T[i++]=O.Color.floatToByte(V.green),T[i++]=O.Color.floatToByte(V.blue),T[i++]=O.Color.floatToByte(V.alpha)}}}const D=new S.GeometryAttributes;D.position=new I.GeometryAttribute({componentDatatype:R.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:E}),D.prevPosition=new I.GeometryAttribute({componentDatatype:R.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:v}),D.nextPosition=new I.GeometryAttribute({componentDatatype:R.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:P}),D.expandAndWidth=new I.GeometryAttribute({componentDatatype:R.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:w}),c.st&&(D.st=new I.GeometryAttribute({componentDatatype:R.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:x})),V.defined(T)&&(D.color=new I.GeometryAttribute({componentDatatype:R.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:4,values:T,normalize:!0}));const k=B.IndexDatatype.createTypedArray(A,6*_-6);let e=0,t=0;var b=_-1;for(h=0;h<b;++h)k[t++]=e,k[t++]=e+2,k[t++]=e+1,k[t++]=e+1,k[t++]=e+2,k[t++]=e+3,e+=4;return new I.Geometry({attributes:D,indices:k,primitiveType:I.PrimitiveType.TRIANGLES,boundingSphere:G.BoundingSphere.fromPoints(g),geometryType:I.GeometryType.POLYLINES})}},function(e,t){return(e=V.defined(t)?m.unpack(e,t):e)._ellipsoid=L.Ellipsoid.clone(e._ellipsoid),m.createGeometry(e)}});