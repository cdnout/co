define(["exports","./GeometryOffsetAttribute-8c5e10db","./Transforms-dca21951","./Matrix2-37e55508","./ComponentDatatype-a15c9a19","./defaultValue-81eec7ed","./RuntimeError-8952249c","./GeometryAttribute-cc3a5bc9","./GeometryAttributes-32b29525","./IndexDatatype-f1dcdf35","./VertexFormat-a0b706b0"],function(t,Q,$,tt,et,at,e,it,nt,rt,f){"use strict";const ot=new tt.Cartesian3,mt=new tt.Cartesian3,st=new tt.Cartesian3,ut=new tt.Cartesian3,lt=new tt.Cartesian3,l=new tt.Cartesian3(1,1,1),ct=Math.cos,ft=Math.sin;function d(t){t=at.defaultValue(t,at.defaultValue.EMPTY_OBJECT);var e=at.defaultValue(t.radii,l),a=at.defaultValue(t.innerRadii,e),i=at.defaultValue(t.minimumClock,0),n=at.defaultValue(t.maximumClock,et.CesiumMath.TWO_PI),r=at.defaultValue(t.minimumCone,0),o=at.defaultValue(t.maximumCone,et.CesiumMath.PI),m=Math.round(at.defaultValue(t.stackPartitions,64)),s=Math.round(at.defaultValue(t.slicePartitions,64)),u=at.defaultValue(t.vertexFormat,f.VertexFormat.DEFAULT);this._radii=tt.Cartesian3.clone(e),this._innerRadii=tt.Cartesian3.clone(a),this._minimumClock=i,this._maximumClock=n,this._minimumCone=r,this._maximumCone=o,this._stackPartitions=m,this._slicePartitions=s,this._vertexFormat=f.VertexFormat.clone(u),this._offsetAttribute=t.offsetAttribute,this._workerName="createEllipsoidGeometry"}d.packedLength=2*tt.Cartesian3.packedLength+f.VertexFormat.packedLength+7,d.pack=function(t,e,a){return a=at.defaultValue(a,0),tt.Cartesian3.pack(t._radii,e,a),a+=tt.Cartesian3.packedLength,tt.Cartesian3.pack(t._innerRadii,e,a),a+=tt.Cartesian3.packedLength,f.VertexFormat.pack(t._vertexFormat,e,a),a+=f.VertexFormat.packedLength,e[a++]=t._minimumClock,e[a++]=t._maximumClock,e[a++]=t._minimumCone,e[a++]=t._maximumCone,e[a++]=t._stackPartitions,e[a++]=t._slicePartitions,e[a]=at.defaultValue(t._offsetAttribute,-1),e};const C=new tt.Cartesian3,p=new tt.Cartesian3,y=new f.VertexFormat,_={radii:C,innerRadii:p,vertexFormat:y,minimumClock:void 0,maximumClock:void 0,minimumCone:void 0,maximumCone:void 0,stackPartitions:void 0,slicePartitions:void 0,offsetAttribute:void 0};let a;d.unpack=function(t,e,a){e=at.defaultValue(e,0);var i=tt.Cartesian3.unpack(t,e,C);e+=tt.Cartesian3.packedLength;var n=tt.Cartesian3.unpack(t,e,p);e+=tt.Cartesian3.packedLength;var r=f.VertexFormat.unpack(t,e,y);e+=f.VertexFormat.packedLength;var o=t[e++],m=t[e++],s=t[e++],u=t[e++],l=t[e++],c=t[e++],e=t[e];return at.defined(a)?(a._radii=tt.Cartesian3.clone(i,a._radii),a._innerRadii=tt.Cartesian3.clone(n,a._innerRadii),a._vertexFormat=f.VertexFormat.clone(r,a._vertexFormat),a._minimumClock=o,a._maximumClock=m,a._minimumCone=s,a._maximumCone=u,a._stackPartitions=l,a._slicePartitions=c,a._offsetAttribute=-1===e?void 0:e,a):(_.minimumClock=o,_.maximumClock=m,_.minimumCone=s,_.maximumCone=u,_.stackPartitions=l,_.slicePartitions=c,_.offsetAttribute=-1===e?void 0:e,new d(_))},d.createGeometry=function(A){var b=A._radii;if(!(b.x<=0||b.y<=0||b.z<=0)){var v=A._innerRadii;if(!(v.x<=0||v.y<=0||v.z<=0)){var k=A._minimumClock,w=A._maximumClock,F=A._minimumCone,P=A._maximumCone,g=A._vertexFormat;let a,t,e=A._slicePartitions+1,i=A._stackPartitions+1;e=Math.round(e*Math.abs(w-k)/et.CesiumMath.TWO_PI),i=Math.round(i*Math.abs(P-F)/et.CesiumMath.PI),e<2&&(e=2),i<2&&(i=2);let n=0;const O=[F],I=[k];for(a=0;a<i;a++)O.push(F+a*(P-F)/(i-1));for(O.push(P),t=0;t<e;t++)I.push(k+t*(w-k)/(e-1));I.push(w);var V=O.length,M=I.length;let r=0,o=1;var T=v.x!==b.x||v.y!==b.y||v.z!==b.z;let m=!1,s=!1,u=!1;T&&(o=2,0<F&&(m=!0,r+=e-1),P<Math.PI&&(s=!0,r+=e-1),(w-k)%et.CesiumMath.TWO_PI?(u=!0,r+=2*(i-1)+1):r+=1);const E=M*V*o,z=new Float64Array(3*E),N=Q.arrayFill(new Array(E),!1),R=Q.arrayFill(new Array(E),!1),U=e*i*o,S=6*(U+r+1-(e+i)*o),B=rt.IndexDatatype.createTypedArray(U,S),W=g.normal?new Float32Array(3*E):void 0,Y=g.tangent?new Float32Array(3*E):void 0,J=g.bitangent?new Float32Array(3*E):void 0,X=g.st?new Float32Array(2*E):void 0,Z=new Array(V),j=new Array(V);for(a=0;a<V;a++)Z[a]=ft(O[a]),j[a]=ct(O[a]);const q=new Array(M),H=new Array(M);for(t=0;t<M;t++)H[t]=ct(I[t]),q[t]=ft(I[t]);for(a=0;a<V;a++)for(t=0;t<M;t++)z[n++]=b.x*Z[a]*H[t],z[n++]=b.y*Z[a]*q[t],z[n++]=b.z*j[a];let l,c,f,d,C=E/2;if(T)for(a=0;a<V;a++)for(t=0;t<M;t++)z[n++]=v.x*Z[a]*H[t],z[n++]=v.y*Z[a]*q[t],z[n++]=v.z*j[a],N[C]=!0,0<a&&a!==V-1&&0!==t&&t!==M-1&&(R[C]=!0),C++;for(n=0,a=1;a<V-2;a++)for(l=a*M,c=(a+1)*M,t=1;t<M-2;t++)B[n++]=c+t,B[n++]=c+t+1,B[n++]=l+t+1,B[n++]=c+t,B[n++]=l+t+1,B[n++]=l+t;if(T){const A=V*M;for(a=1;a<V-2;a++)for(l=A+a*M,c=A+(a+1)*M,t=1;t<M-2;t++)B[n++]=c+t,B[n++]=l+t,B[n++]=l+t+1,B[n++]=c+t,B[n++]=l+t+1,B[n++]=c+t+1}if(T){if(m)for(d=V*M,a=1;a<M-2;a++)B[n++]=a,B[n++]=a+1,B[n++]=d+a+1,B[n++]=a,B[n++]=d+a+1,B[n++]=d+a;if(s)for(f=V*M-M,d=V*M*o-M,a=1;a<M-2;a++)B[n++]=f+a+1,B[n++]=f+a,B[n++]=d+a,B[n++]=f+a+1,B[n++]=d+a,B[n++]=d+a+1}if(u){for(a=1;a<V-2;a++)d=M*V+M*a,f=M*a,B[n++]=d,B[n++]=f+M,B[n++]=f,B[n++]=d,B[n++]=d+M,B[n++]=f+M;for(a=1;a<V-2;a++)d=M*V+M*(a+1)-1,f=M*(a+1)-1,B[n++]=f+M,B[n++]=d,B[n++]=f,B[n++]=f+M,B[n++]=d+M,B[n++]=d}const K=new nt.GeometryAttributes;g.position&&(K.position=new it.GeometryAttribute({componentDatatype:et.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:z}));let p=0,y=0,_=0,h=0;var D=E/2;let x;var G=tt.Ellipsoid.fromCartesian3(b),L=tt.Ellipsoid.fromCartesian3(v);if(g.st||g.normal||g.tangent||g.bitangent){for(a=0;a<E;a++){x=N[a]?L:G;const A=tt.Cartesian3.fromArray(z,3*a,ot),Q=x.geodeticSurfaceNormal(A,mt);if(R[a]&&tt.Cartesian3.negate(Q,Q),g.st){const A=tt.Cartesian2.negate(Q,lt);X[p++]=Math.atan2(A.y,A.x)/et.CesiumMath.TWO_PI+.5,X[p++]=Math.asin(Q.z)/Math.PI+.5}if(g.normal&&(W[y++]=Q.x,W[y++]=Q.y,W[y++]=Q.z),g.tangent||g.bitangent){const A=st;let t,e=0;if(N[a]&&(e=D),t=!m&&a>=e&&a<e+2*M?tt.Cartesian3.UNIT_X:tt.Cartesian3.UNIT_Z,tt.Cartesian3.cross(t,Q,A),tt.Cartesian3.normalize(A,A),g.tangent&&(Y[_++]=A.x,Y[_++]=A.y,Y[_++]=A.z),g.bitangent){const $=tt.Cartesian3.cross(Q,A,ut);tt.Cartesian3.normalize($,$),J[h++]=$.x,J[h++]=$.y,J[h++]=$.z}}}g.st&&(K.st=new it.GeometryAttribute({componentDatatype:et.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:X})),g.normal&&(K.normal=new it.GeometryAttribute({componentDatatype:et.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:W})),g.tangent&&(K.tangent=new it.GeometryAttribute({componentDatatype:et.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:Y})),g.bitangent&&(K.bitangent=new it.GeometryAttribute({componentDatatype:et.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:J}))}if(at.defined(A._offsetAttribute)){const $=z.length,tt=new Uint8Array($/3),at=A._offsetAttribute===Q.GeometryOffsetAttribute.NONE?0:1;Q.arrayFill(tt,at),K.applyOffset=new it.GeometryAttribute({componentDatatype:et.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:tt})}return new it.Geometry({attributes:K,indices:B,primitiveType:it.PrimitiveType.TRIANGLES,boundingSphere:$.BoundingSphere.fromEllipsoid(G),offsetAttribute:A._offsetAttribute})}}},d.getUnitEllipsoid=function(){return at.defined(a)||(a=d.createGeometry(new d({radii:new tt.Cartesian3(1,1,1),vertexFormat:f.VertexFormat.POSITION_ONLY}))),a},t.EllipsoidGeometry=d});