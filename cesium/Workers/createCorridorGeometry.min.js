define(["./GeometryOffsetAttribute-8c5e10db","./arrayRemoveDuplicates-dc2f4046","./Transforms-dca21951","./Matrix2-37e55508","./RuntimeError-8952249c","./ComponentDatatype-a15c9a19","./PolylineVolumeGeometryLibrary-996c2dbb","./CorridorGeometryLibrary-6c371153","./defaultValue-81eec7ed","./GeometryAttribute-cc3a5bc9","./GeometryAttributes-32b29525","./IndexDatatype-f1dcdf35","./PolygonPipeline-b6cd7820","./VertexFormat-a0b706b0","./_commonjsHelpers-3aae1032-26891ab7","./combine-3c023bda","./WebGLConstants-508b9636","./EllipsoidTangentPlane-06e319ef","./AxisAlignedBoundingBox-0ddf9b79","./IntersectionTests-ee135b8e","./Plane-6ee42cab","./PolylinePipeline-21ef0cd0","./EllipsoidGeodesic-cc3bace8","./EllipsoidRhumbLine-125a8b72"],function(_,m,u,k,t,H,c,z,B,U,Y,W,w,T,e,r,a,i,o,n,s,l,d,y){"use strict";const q=new k.Cartesian3,j=new k.Cartesian3,J=new k.Cartesian3,K=new k.Cartesian3,G=new k.Cartesian3,Q=new k.Cartesian3,X=new k.Cartesian3,Z=new k.Cartesian3;function f(e,r){for(let t=0;t<e.length;t++)e[t]=r.scaleToGeodeticSurface(e[t],e[t]);return e}function $(t,e,r,a,i,o){var n=t.normals,s=t.tangents,l=t.bitangents,t=k.Cartesian3.normalize(k.Cartesian3.cross(r,e,X),X);o.normal&&z.CorridorGeometryLibrary.addAttribute(n,e,a,i),o.tangent&&z.CorridorGeometryLibrary.addAttribute(s,t,a,i),o.bitangent&&z.CorridorGeometryLibrary.addAttribute(l,r,a,i)}function E(t,n,s){const l=t.positions,d=t.corners,e=t.endPositions,u=t.lefts,m=t.normals,i=new Y.GeometryAttributes;let c,y,f,o=0,p=0,r=0;for(y=0;y<l.length;y+=2)f=l[y].length-3,o+=f,r+=2*f,p+=l[y+1].length-3;for(o+=3,p+=3,y=0;y<d.length;y++){c=d[y];const R=d[y].leftPositions;B.defined(R)?(f=R.length,o+=f):(f=d[y].rightPositions.length,p+=f),r+=f}t=B.defined(e);let g;t&&(g=e[0].length-3,o+=g,p+=g,g/=3,r+=6*g);const h=o+p,b=new Float64Array(h),C={normals:n.normal?new Float32Array(h):void 0,tangents:n.tangent?new Float32Array(h):void 0,bitangents:n.bitangent?new Float32Array(h):void 0};let A,v,_,w,a,T,G=0,E=h-1,V=q,x=j;const F=g/2,L=W.IndexDatatype.createTypedArray(h/3,r);let P=0;if(t){T=J,a=K;const R=e[0];for(V=k.Cartesian3.fromArray(m,0,V),x=k.Cartesian3.fromArray(u,0,x),y=0;y<F;y++)T=k.Cartesian3.fromArray(R,3*(F-1-y),T),a=k.Cartesian3.fromArray(R,3*(F+y),a),z.CorridorGeometryLibrary.addAttribute(b,a,G),z.CorridorGeometryLibrary.addAttribute(b,T,void 0,E),$(C,V,x,G,E,n),v=G/3,w=v+1,A=(E-2)/3,_=A-1,L[P++]=A,L[P++]=v,L[P++]=_,L[P++]=_,L[P++]=v,L[P++]=w,G+=3,E-=3}let N,D,M=0,O=0,I=l[M++],S=l[M++];for(b.set(I,G),b.set(S,E-S.length+1),x=k.Cartesian3.fromArray(u,O,x),f=S.length-3,y=0;y<f;y+=3)N=s.geodeticSurfaceNormal(k.Cartesian3.fromArray(I,y,X),X),D=s.geodeticSurfaceNormal(k.Cartesian3.fromArray(S,f-y,Z),Z),V=k.Cartesian3.normalize(k.Cartesian3.add(N,D,V),V),$(C,V,x,G,E,n),v=G/3,w=v+1,A=(E-2)/3,_=A-1,L[P++]=A,L[P++]=v,L[P++]=_,L[P++]=_,L[P++]=v,L[P++]=w,G+=3,E-=3;for(N=s.geodeticSurfaceNormal(k.Cartesian3.fromArray(I,f,X),X),D=s.geodeticSurfaceNormal(k.Cartesian3.fromArray(S,f,Z),Z),V=k.Cartesian3.normalize(k.Cartesian3.add(N,D,V),V),O+=3,y=0;y<d.length;y++){let t;c=d[y];const H=c.leftPositions,U=c.rightPositions;let e,r,a=Q,i=J,o=K;if(V=k.Cartesian3.fromArray(m,O,V),B.defined(H)){for($(C,V,x,void 0,E,n),E-=3,e=w,r=_,t=0;t<H.length/3;t++)a=k.Cartesian3.fromArray(H,3*t,a),L[P++]=e,L[P++]=r-t-1,L[P++]=r-t,z.CorridorGeometryLibrary.addAttribute(b,a,void 0,E),i=k.Cartesian3.fromArray(b,3*(r-t-1),i),o=k.Cartesian3.fromArray(b,3*e,o),x=k.Cartesian3.normalize(k.Cartesian3.subtract(i,o,x),x),$(C,V,x,void 0,E,n),E-=3;a=k.Cartesian3.fromArray(b,3*e,a),i=k.Cartesian3.subtract(k.Cartesian3.fromArray(b,3*r,i),a,i),o=k.Cartesian3.subtract(k.Cartesian3.fromArray(b,3*(r-t),o),a,o),x=k.Cartesian3.normalize(k.Cartesian3.add(i,o,x),x),$(C,V,x,G,void 0,n),G+=3}else{for($(C,V,x,G,void 0,n),G+=3,e=_,r=w,t=0;t<U.length/3;t++)a=k.Cartesian3.fromArray(U,3*t,a),L[P++]=e,L[P++]=r+t,L[P++]=r+t+1,z.CorridorGeometryLibrary.addAttribute(b,a,G),i=k.Cartesian3.fromArray(b,3*e,i),o=k.Cartesian3.fromArray(b,3*(r+t),o),x=k.Cartesian3.normalize(k.Cartesian3.subtract(i,o,x),x),$(C,V,x,G,void 0,n),G+=3;a=k.Cartesian3.fromArray(b,3*e,a),i=k.Cartesian3.subtract(k.Cartesian3.fromArray(b,3*(r+t),i),a,i),o=k.Cartesian3.subtract(k.Cartesian3.fromArray(b,3*r,o),a,o),x=k.Cartesian3.normalize(k.Cartesian3.negate(k.Cartesian3.add(o,i,x),x),x),$(C,V,x,void 0,E,n),E-=3}for(I=l[M++],S=l[M++],I.splice(0,3),S.splice(S.length-3,3),b.set(I,G),b.set(S,E-S.length+1),f=S.length-3,O+=3,x=k.Cartesian3.fromArray(u,O,x),t=0;t<S.length;t+=3)N=s.geodeticSurfaceNormal(k.Cartesian3.fromArray(I,t,X),X),D=s.geodeticSurfaceNormal(k.Cartesian3.fromArray(S,f-t,Z),Z),V=k.Cartesian3.normalize(k.Cartesian3.add(N,D,V),V),$(C,V,x,G,E,n),w=G/3,v=w-1,_=(E-2)/3,A=_+1,L[P++]=A,L[P++]=v,L[P++]=_,L[P++]=_,L[P++]=v,L[P++]=w,G+=3,E-=3;G-=3,E+=3}if(V=k.Cartesian3.fromArray(m,m.length-3,V),$(C,V,x,G,E,n),t){G+=3,E-=3,T=J,a=K;const R=e[1];for(y=0;y<F;y++)T=k.Cartesian3.fromArray(R,3*(g-y-1),T),a=k.Cartesian3.fromArray(R,3*y,a),z.CorridorGeometryLibrary.addAttribute(b,T,void 0,E),z.CorridorGeometryLibrary.addAttribute(b,a,G),$(C,V,x,G,E,n),w=G/3,v=w-1,_=(E-2)/3,A=_+1,L[P++]=A,L[P++]=v,L[P++]=_,L[P++]=_,L[P++]=v,L[P++]=w,G+=3,E-=3}if(i.position=new U.GeometryAttribute({componentDatatype:H.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:b}),n.st){const R=new Float32Array(h/3*2);let e,r,a=0;if(t){o/=3,p/=3;const l=Math.PI/(g+1);let t;r=1/(o-g+1),e=1/(p-g+1);const z=g/2;for(y=1+z;y<g+1;y++)t=H.CesiumMath.PI_OVER_TWO+l*y,R[a++]=e*(1+Math.cos(t)),R[a++]=.5*(1+Math.sin(t));for(y=1;y<p-g+1;y++)R[a++]=y*e,R[a++]=0;for(y=g;y>z;y--)t=H.CesiumMath.PI_OVER_TWO-y*l,R[a++]=1-e*(1+Math.cos(t)),R[a++]=.5*(1+Math.sin(t));for(y=z;0<y;y--)t=H.CesiumMath.PI_OVER_TWO-l*y,R[a++]=1-r*(1+Math.cos(t)),R[a++]=.5*(1+Math.sin(t));for(y=o-g;0<y;y--)R[a++]=y*r,R[a++]=1;for(y=1;y<1+z;y++)t=H.CesiumMath.PI_OVER_TWO+l*y,R[a++]=r*(1+Math.cos(t)),R[a++]=.5*(1+Math.sin(t))}else{for(o/=3,p/=3,r=1/(o-1),e=1/(p-1),y=0;y<p;y++)R[a++]=y*e,R[a++]=0;for(y=o;0<y;y--)R[a++]=(y-1)*r,R[a++]=1}i.st=new U.GeometryAttribute({componentDatatype:H.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:R})}return n.normal&&(i.normal=new U.GeometryAttribute({componentDatatype:H.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:C.normals})),n.tangent&&(i.tangent=new U.GeometryAttribute({componentDatatype:H.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:C.tangents})),n.bitangent&&(i.bitangent=new U.GeometryAttribute({componentDatatype:H.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:C.bitangents})),{attributes:i,indices:L}}function V(e,r,a){a[r++]=e[0],a[r++]=e[1],a[r++]=e[2];for(let t=3;t<e.length;t+=3){var i=e[t],o=e[t+1],n=e[t+2];a[r++]=i,a[r++]=o,a[r++]=n,a[r++]=i,a[r++]=o,a[r++]=n}return a[r++]=e[0],a[r++]=e[1],a[r++]=e[2],a}const p=new k.Cartesian3,g=new k.Cartesian3,h=new k.Cartographic;function b(t,e,r,a,i,o){var n=k.Cartesian3.subtract(e,t,p);k.Cartesian3.normalize(n,n);var s=r.geodeticSurfaceNormal(t,g),l=k.Cartesian3.cross(n,s,p);k.Cartesian3.multiplyByScalar(l,a,l);var d=i.latitude,u=i.longitude,e=o.latitude,n=o.longitude;k.Cartesian3.add(t,l,g),r.cartesianToCartographic(g,h);s=h.latitude,a=h.longitude,d=Math.min(d,s),u=Math.min(u,a),e=Math.max(e,s),n=Math.max(n,a);k.Cartesian3.subtract(t,l,g),r.cartesianToCartographic(g,h),s=h.latitude,a=h.longitude,d=Math.min(d,s),u=Math.min(u,a),e=Math.max(e,s),n=Math.max(n,a),i.latitude=d,i.longitude=u,o.latitude=e,o.longitude=n}const C=new k.Cartesian3,A=new k.Cartesian3,v=new k.Cartographic,x=new k.Cartographic;function F(t,e,r,a,i){t=f(t,e);var o=m.arrayRemoveDuplicates(t,k.Cartesian3.equalsEpsilon),n=o.length;if(n<2||r<=0)return new k.Rectangle;var s=.5*r;let l,d;if(v.latitude=Number.POSITIVE_INFINITY,v.longitude=Number.POSITIVE_INFINITY,x.latitude=Number.NEGATIVE_INFINITY,x.longitude=Number.NEGATIVE_INFINITY,a===c.CornerType.ROUNDED){const t=o[0];k.Cartesian3.subtract(t,o[1],C),k.Cartesian3.normalize(C,C),k.Cartesian3.multiplyByScalar(C,s,C),k.Cartesian3.add(t,C,A),e.cartesianToCartographic(A,h),l=h.latitude,d=h.longitude,v.latitude=Math.min(v.latitude,l),v.longitude=Math.min(v.longitude,d),x.latitude=Math.max(x.latitude,l),x.longitude=Math.max(x.longitude,d)}for(let t=0;t<n-1;++t)b(o[t],o[t+1],e,s,v,x);r=o[n-1];k.Cartesian3.subtract(r,o[n-2],C),k.Cartesian3.normalize(C,C),k.Cartesian3.multiplyByScalar(C,s,C),k.Cartesian3.add(r,C,A),b(r,A,e,s,v,x),a===c.CornerType.ROUNDED&&(e.cartesianToCartographic(A,h),l=h.latitude,d=h.longitude,v.latitude=Math.min(v.latitude,l),v.longitude=Math.min(v.longitude,d),x.latitude=Math.max(x.latitude,l),x.longitude=Math.max(x.longitude,d));const u=B.defined(i)?i:new k.Rectangle;return u.north=x.latitude,u.south=v.latitude,u.east=x.longitude,u.west=v.longitude,u}function L(t){var e=(t=B.defaultValue(t,B.defaultValue.EMPTY_OBJECT)).positions,r=t.width,a=B.defaultValue(t.height,0),i=B.defaultValue(t.extrudedHeight,a);this._positions=e,this._ellipsoid=k.Ellipsoid.clone(B.defaultValue(t.ellipsoid,k.Ellipsoid.WGS84)),this._vertexFormat=T.VertexFormat.clone(B.defaultValue(t.vertexFormat,T.VertexFormat.DEFAULT)),this._width=r,this._height=Math.max(a,i),this._extrudedHeight=Math.min(a,i),this._cornerType=B.defaultValue(t.cornerType,c.CornerType.ROUNDED),this._granularity=B.defaultValue(t.granularity,H.CesiumMath.RADIANS_PER_DEGREE),this._shadowVolume=B.defaultValue(t.shadowVolume,!1),this._workerName="createCorridorGeometry",this._offsetAttribute=t.offsetAttribute,this._rectangle=void 0,this.packedLength=1+e.length*k.Cartesian3.packedLength+k.Ellipsoid.packedLength+T.VertexFormat.packedLength+7}L.pack=function(t,e,r){r=B.defaultValue(r,0);var a=t._positions,i=a.length;e[r++]=i;for(let t=0;t<i;++t,r+=k.Cartesian3.packedLength)k.Cartesian3.pack(a[t],e,r);return k.Ellipsoid.pack(t._ellipsoid,e,r),r+=k.Ellipsoid.packedLength,T.VertexFormat.pack(t._vertexFormat,e,r),r+=T.VertexFormat.packedLength,e[r++]=t._width,e[r++]=t._height,e[r++]=t._extrudedHeight,e[r++]=t._cornerType,e[r++]=t._granularity,e[r++]=t._shadowVolume?1:0,e[r]=B.defaultValue(t._offsetAttribute,-1),e};const P=k.Ellipsoid.clone(k.Ellipsoid.UNIT_SPHERE),N=new T.VertexFormat,D={positions:void 0,ellipsoid:P,vertexFormat:N,width:void 0,height:void 0,extrudedHeight:void 0,cornerType:void 0,granularity:void 0,shadowVolume:void 0,offsetAttribute:void 0};return L.unpack=function(e,r,t){r=B.defaultValue(r,0);const a=e[r++],i=new Array(a);for(let t=0;t<a;++t,r+=k.Cartesian3.packedLength)i[t]=k.Cartesian3.unpack(e,r);var o=k.Ellipsoid.unpack(e,r,P);r+=k.Ellipsoid.packedLength;var n=T.VertexFormat.unpack(e,r,N);r+=T.VertexFormat.packedLength;var s=e[r++],l=e[r++],d=e[r++],u=e[r++],m=e[r++],c=1===e[r++],y=e[r];return B.defined(t)?(t._positions=i,t._ellipsoid=k.Ellipsoid.clone(o,t._ellipsoid),t._vertexFormat=T.VertexFormat.clone(n,t._vertexFormat),t._width=s,t._height=l,t._extrudedHeight=d,t._cornerType=u,t._granularity=m,t._shadowVolume=c,t._offsetAttribute=-1===y?void 0:y,t):(D.positions=i,D.width=s,D.height=l,D.extrudedHeight=d,D.cornerType=u,D.granularity=m,D.shadowVolume=c,D.offsetAttribute=-1===y?void 0:y,new L(D))},L.computeRectangle=function(t,e){var r=(t=B.defaultValue(t,B.defaultValue.EMPTY_OBJECT)).positions,a=t.width;return F(r,B.defaultValue(t.ellipsoid,k.Ellipsoid.WGS84),a,B.defaultValue(t.cornerType,c.CornerType.ROUNDED),e)},L.createGeometry=function(e){var r=e._positions,a=e._width,i=e._ellipsoid,r=f(r,i),r=m.arrayRemoveDuplicates(r,k.Cartesian3.equalsEpsilon);if(!(r.length<2||a<=0)){const o=e._height,n=e._extrudedHeight,s=!H.CesiumMath.equalsEpsilon(o,n,0,H.CesiumMath.EPSILON2),l=e._vertexFormat,d={ellipsoid:i,positions:r,width:a,cornerType:e._cornerType,granularity:e._granularity,saveAttributes:!0};let t;if(s)d.height=o,d.extrudedHeight=n,d.shadowVolume=e._shadowVolume,d.offsetAttribute=e._offsetAttribute,t=function(e,r){var t=new T.VertexFormat({position:r.position,normal:r.normal||r.bitangent||e.shadowVolume,tangent:r.tangent,bitangent:r.normal||r.bitangent,st:r.st}),a=e.ellipsoid,i=E(z.CorridorGeometryLibrary.computePositions(e),t,a),o=e.height,t=e.extrudedHeight;let n=i.attributes;var s=i.indices,l=(i=n.position.values).length;const d=new Float64Array(6*l);let u=new Float64Array(l);u.set(i);let m,c=new Float64Array(4*l);c=V(i=w.PolygonPipeline.scaleToGeodeticHeight(i,o,a),0,c),u=w.PolygonPipeline.scaleToGeodeticHeight(u,t,a),c=V(u,2*l,c),d.set(i),d.set(u,l),d.set(c,2*l),n.position.values=d,n=function(s,l){if(!(l.normal||l.tangent||l.bitangent||l.st))return s;const d=s.position.values;let u,m;(l.normal||l.bitangent)&&(u=s.normal.values,m=s.bitangent.values);const c=s.position.values.length/18,y=3*c,f=2*c,p=2*y;let g;if(l.normal||l.bitangent||l.tangent){const c=l.normal?new Float32Array(6*y):void 0,f=l.tangent?new Float32Array(6*y):void 0,h=l.bitangent?new Float32Array(6*y):void 0;let t=q,e=j,r=J,a=K,i=G,o=Q,n=p;for(g=0;g<y;g+=3){const s=n+p;t=k.Cartesian3.fromArray(d,g,t),e=k.Cartesian3.fromArray(d,g+y,e),r=k.Cartesian3.fromArray(d,(g+3)%y,r),e=k.Cartesian3.subtract(e,t,e),r=k.Cartesian3.subtract(r,t,r),a=k.Cartesian3.normalize(k.Cartesian3.cross(e,r,a),a),l.normal&&(z.CorridorGeometryLibrary.addAttribute(c,a,s),z.CorridorGeometryLibrary.addAttribute(c,a,s+3),z.CorridorGeometryLibrary.addAttribute(c,a,n),z.CorridorGeometryLibrary.addAttribute(c,a,n+3)),(l.tangent||l.bitangent)&&(o=k.Cartesian3.fromArray(u,g,o),l.bitangent&&(z.CorridorGeometryLibrary.addAttribute(h,o,s),z.CorridorGeometryLibrary.addAttribute(h,o,s+3),z.CorridorGeometryLibrary.addAttribute(h,o,n),z.CorridorGeometryLibrary.addAttribute(h,o,n+3)),l.tangent&&(i=k.Cartesian3.normalize(k.Cartesian3.cross(o,a,i),i),z.CorridorGeometryLibrary.addAttribute(f,i,s),z.CorridorGeometryLibrary.addAttribute(f,i,s+3),z.CorridorGeometryLibrary.addAttribute(f,i,n),z.CorridorGeometryLibrary.addAttribute(f,i,n+3))),n+=6}if(l.normal){for(c.set(u),g=0;g<y;g+=3)c[g+y]=-u[g],c[g+y+1]=-u[g+1],c[g+y+2]=-u[g+2];s.normal.values=c}else s.normal=void 0;if(l.bitangent?(h.set(m),h.set(m,y),s.bitangent.values=h):s.bitangent=void 0,l.tangent){const l=s.tangent.values;f.set(l),f.set(l,y),s.tangent.values=f}}if(l.st){const l=s.st.values,d=new Float32Array(6*f);d.set(l),d.set(l,f);let e=2*f;for(let t=0;t<2;t++){for(d[e++]=l[0],d[e++]=l[1],g=2;g<f;g+=2){const s=l[g],u=l[g+1];d[e++]=s,d[e++]=u,d[e++]=s,d[e++]=u}d[e++]=l[0],d[e++]=l[1]}s.st.values=d}return s}(n,r);var y=l/3;if(e.shadowVolume){const _=n.normal.values;l=_.length;let t=new Float32Array(6*l);for(m=0;m<l;m++)_[m]=-_[m];t.set(_,l),t=V(_,4*l,t),n.extrudeDirection=new U.GeometryAttribute({componentDatatype:H.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:t}),r.normal||(n.normal=void 0)}if(B.defined(e.offsetAttribute)){let t=new Uint8Array(6*y);if(e.offsetAttribute===_.GeometryOffsetAttribute.TOP)t=_.arrayFill(t,1,0,y),t=_.arrayFill(t,1,2*y,4*y);else{const k=e.offsetAttribute===_.GeometryOffsetAttribute.NONE?0:1;t=_.arrayFill(t,k)}n.applyOffset=new U.GeometryAttribute({componentDatatype:H.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:t})}const f=s.length,p=y+y,g=W.IndexDatatype.createTypedArray(d.length/3,2*f+3*p);g.set(s);let h,b,C,A,v=f;for(m=0;m<f;m+=3){const _=s[m],e=s[m+1],r=s[m+2];g[v++]=r+y,g[v++]=e+y,g[v++]=_+y}for(m=0;m<p;m+=2)C=(h=m+p)+1,A=(b=h+p)+1,g[v++]=h,g[v++]=b,g[v++]=C,g[v++]=C,g[v++]=b,g[v++]=A;return{attributes:n,indices:g}}(d,l);else if(t=E(z.CorridorGeometryLibrary.computePositions(d),l,i),t.attributes.position.values=w.PolygonPipeline.scaleToGeodeticHeight(t.attributes.position.values,o,i),B.defined(e._offsetAttribute)){const m=e._offsetAttribute===_.GeometryOffsetAttribute.NONE?0:1,u=t.attributes.position.values.length,k=new Uint8Array(u/3);_.arrayFill(k,m),t.attributes.applyOffset=new U.GeometryAttribute({componentDatatype:H.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:k})}a=t.attributes,i=u.BoundingSphere.fromVertices(a.position.values,void 0,3);return l.position||(t.attributes.position.values=void 0),new U.Geometry({attributes:a,indices:t.indices,primitiveType:U.PrimitiveType.TRIANGLES,boundingSphere:i,offsetAttribute:e._offsetAttribute})}},L.createShadowVolume=function(t,e,r){var a=t._granularity,i=t._ellipsoid,e=e(a,i),r=r(a,i);return new L({positions:t._positions,width:t._width,cornerType:t._cornerType,ellipsoid:i,granularity:a,extrudedHeight:e,height:r,vertexFormat:T.VertexFormat.POSITION_ONLY,shadowVolume:!0})},Object.defineProperties(L.prototype,{rectangle:{get:function(){return B.defined(this._rectangle)||(this._rectangle=F(this._positions,this._ellipsoid,this._width,this._cornerType)),this._rectangle}},textureCoordinateRotationPoints:{get:function(){return[0,0,0,1,1,0]}}}),function(t,e){return(t=B.defined(e)?L.unpack(t,e):t)._ellipsoid=k.Ellipsoid.clone(t._ellipsoid),L.createGeometry(t)}});