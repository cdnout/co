define(["exports","./GeometryOffsetAttribute-8c5e10db","./Transforms-dca21951","./Matrix2-37e55508","./ComponentDatatype-a15c9a19","./defaultValue-81eec7ed","./RuntimeError-8952249c","./EllipseGeometryLibrary-30fc3ab5","./GeometryAttribute-cc3a5bc9","./GeometryAttributes-32b29525","./IndexDatatype-f1dcdf35"],function(e,f,m,h,y,b,t,A,_,g,x){"use strict";const E=new h.Cartesian3;let l=new h.Cartesian3;const M=new m.BoundingSphere,v=new m.BoundingSphere;function p(e){var t=(e=b.defaultValue(e,b.defaultValue.EMPTY_OBJECT)).center,i=b.defaultValue(e.ellipsoid,h.Ellipsoid.WGS84),r=e.semiMajorAxis,a=e.semiMinorAxis,n=b.defaultValue(e.granularity,y.CesiumMath.RADIANS_PER_DEGREE),o=b.defaultValue(e.height,0),s=b.defaultValue(e.extrudedHeight,o);this._center=h.Cartesian3.clone(t),this._semiMajorAxis=r,this._semiMinorAxis=a,this._ellipsoid=h.Ellipsoid.clone(i),this._rotation=b.defaultValue(e.rotation,0),this._height=Math.max(s,o),this._granularity=n,this._extrudedHeight=Math.min(s,o),this._numberOfVerticalLines=Math.max(b.defaultValue(e.numberOfVerticalLines,16),0),this._offsetAttribute=e.offsetAttribute,this._workerName="createEllipseOutlineGeometry"}p.packedLength=h.Cartesian3.packedLength+h.Ellipsoid.packedLength+8,p.pack=function(e,t,i){return i=b.defaultValue(i,0),h.Cartesian3.pack(e._center,t,i),i+=h.Cartesian3.packedLength,h.Ellipsoid.pack(e._ellipsoid,t,i),i+=h.Ellipsoid.packedLength,t[i++]=e._semiMajorAxis,t[i++]=e._semiMinorAxis,t[i++]=e._rotation,t[i++]=e._height,t[i++]=e._granularity,t[i++]=e._extrudedHeight,t[i++]=e._numberOfVerticalLines,t[i]=b.defaultValue(e._offsetAttribute,-1),t};const C=new h.Cartesian3,G=new h.Ellipsoid,L={center:C,ellipsoid:G,semiMajorAxis:void 0,semiMinorAxis:void 0,rotation:void 0,height:void 0,granularity:void 0,extrudedHeight:void 0,numberOfVerticalLines:void 0,offsetAttribute:void 0};p.unpack=function(e,t,i){t=b.defaultValue(t,0);var r=h.Cartesian3.unpack(e,t,C);t+=h.Cartesian3.packedLength;var a=h.Ellipsoid.unpack(e,t,G);t+=h.Ellipsoid.packedLength;var n=e[t++],o=e[t++],s=e[t++],l=e[t++],u=e[t++],d=e[t++],c=e[t++],t=e[t];return b.defined(i)?(i._center=h.Cartesian3.clone(r,i._center),i._ellipsoid=h.Ellipsoid.clone(a,i._ellipsoid),i._semiMajorAxis=n,i._semiMinorAxis=o,i._rotation=s,i._height=l,i._granularity=u,i._extrudedHeight=d,i._numberOfVerticalLines=c,i._offsetAttribute=-1===t?void 0:t,i):(L.height=l,L.extrudedHeight=d,L.granularity=u,L.rotation=s,L.semiMajorAxis=n,L.semiMinorAxis=o,L.numberOfVerticalLines=c,L.offsetAttribute=-1===t?void 0:t,new p(L))},p.createGeometry=function(t){if(!(t._semiMajorAxis<=0||t._semiMinorAxis<=0)){var i=t._height,r=t._extrudedHeight,a=!y.CesiumMath.equalsEpsilon(i,r,0,y.CesiumMath.EPSILON2);t._center=t._ellipsoid.scaleToGeodeticSurface(t._center,t._center);const n={center:t._center,semiMajorAxis:t._semiMajorAxis,semiMinorAxis:t._semiMinorAxis,ellipsoid:t._ellipsoid,rotation:t._rotation,height:i,granularity:t._granularity,numberOfVerticalLines:t._numberOfVerticalLines};let e;if(a)n.extrudedHeight=r,n.offsetAttribute=t._offsetAttribute,e=function(t){const e=t.center,i=t.ellipsoid,r=t.semiMajorAxis;var a=h.Cartesian3.multiplyByScalar(i.geodeticSurfaceNormal(e,E),t.height,E);M.center=h.Cartesian3.add(e,a,M.center),M.radius=r,a=h.Cartesian3.multiplyByScalar(i.geodeticSurfaceNormal(e,a),t.extrudedHeight,a),v.center=h.Cartesian3.add(e,a,v.center),v.radius=r;var n=A.EllipseGeometryLibrary.computeEllipsePositions(t,!1,!0).outerPositions;const o=new g.GeometryAttributes({position:new _.GeometryAttribute({componentDatatype:y.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:A.EllipseGeometryLibrary.raisePositionsToHeight(n,t,!0)})});n=o.position.values,a=m.BoundingSphere.union(M,v);let s=n.length/3;if(b.defined(t.offsetAttribute)){let e=new Uint8Array(s);if(t.offsetAttribute===f.GeometryOffsetAttribute.TOP)e=f.arrayFill(e,1,0,s/2);else{const h=t.offsetAttribute===f.GeometryOffsetAttribute.NONE?0:1;e=f.arrayFill(e,h)}o.applyOffset=new _.GeometryAttribute({componentDatatype:y.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:e})}t=b.defaultValue(t.numberOfVerticalLines,16),t=y.CesiumMath.clamp(t,0,s/2);const l=x.IndexDatatype.createTypedArray(s,2*s+2*t);s/=2;let u,d,c=0;for(u=0;u<s;++u)l[c++]=u,l[c++]=(u+1)%s,l[c++]=u+s,l[c++]=(u+1)%s+s;if(0<t){const p=Math.min(t,s);d=Math.round(s/p);const f=Math.min(d*t,s);for(u=0;u<f;u+=d)l[c++]=u,l[c++]=u+s}return{boundingSphere:a,attributes:o,indices:l}}(n);else if(e=function(e){var t=e.center;l=h.Cartesian3.multiplyByScalar(e.ellipsoid.geodeticSurfaceNormal(t,l),e.height,l),l=h.Cartesian3.add(t,l,l);const i=new m.BoundingSphere(l,e.semiMajorAxis),r=A.EllipseGeometryLibrary.computeEllipsePositions(e,!1,!0).outerPositions,a=new g.GeometryAttributes({position:new _.GeometryAttribute({componentDatatype:y.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:A.EllipseGeometryLibrary.raisePositionsToHeight(r,e,!1)})}),n=r.length/3,o=x.IndexDatatype.createTypedArray(n,2*n);let s=0;for(let e=0;e<n;++e)o[s++]=e,o[s++]=(e+1)%n;return{boundingSphere:i,attributes:a,indices:o}}(n),b.defined(t._offsetAttribute)){const m=e.attributes.position.values.length,h=new Uint8Array(m/3),b=t._offsetAttribute===f.GeometryOffsetAttribute.NONE?0:1;f.arrayFill(h,b),e.attributes.applyOffset=new _.GeometryAttribute({componentDatatype:y.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:h})}return new _.Geometry({attributes:e.attributes,indices:e.indices,primitiveType:_.PrimitiveType.LINES,boundingSphere:e.boundingSphere,offsetAttribute:t._offsetAttribute})}},e.EllipseOutlineGeometry=p});