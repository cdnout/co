define(["exports","./Matrix2-37e55508","./ComponentDatatype-a15c9a19","./Transforms-dca21951"],function(a,A,R,y){"use strict";const t={},c=new A.Cartesian3,u=new A.Cartesian3,m=new y.Quaternion,h=new A.Matrix3;function W(a,t,e,i,r,n,s,o,l,C){t=a+t;A.Cartesian3.multiplyByScalar(i,Math.cos(t),c),A.Cartesian3.multiplyByScalar(e,Math.sin(t),u),A.Cartesian3.add(c,u,c);t=Math.cos(a);t*=t;a=Math.sin(a);a*=a;a=n/Math.sqrt(s*t+r*a)/o;return y.Quaternion.fromAxisAngle(c,a,m),A.Matrix3.fromQuaternion(m,h),A.Matrix3.multiplyByVector(h,l,C),A.Cartesian3.normalize(C,C),A.Cartesian3.multiplyByScalar(C,o,C),C}const S=new A.Cartesian3,B=new A.Cartesian3,v=new A.Cartesian3,x=new A.Cartesian3;t.raisePositionsToHeight=function(t,a,e){const i=a.ellipsoid,r=a.height,n=a.extrudedHeight,s=e?t.length/3*2:t.length/3,o=new Float64Array(3*s),l=t.length,C=e?l:0;for(let a=0;a<l;a+=3){const s=a+1,l=a+2,m=A.Cartesian3.fromArray(t,a,S);i.scaleToGeodeticSurface(m,m);var y=A.Cartesian3.clone(m,B),c=i.geodeticSurfaceNormal(m,x),u=A.Cartesian3.multiplyByScalar(c,r,v);A.Cartesian3.add(m,u,m),e&&(A.Cartesian3.multiplyByScalar(c,n,u),A.Cartesian3.add(y,u,y),o[a+C]=y.x,o[s+C]=y.y,o[l+C]=y.z),o[a]=m.x,o[s]=m.y,o[l]=m.z}return o};const Q=new A.Cartesian3,b=new A.Cartesian3,G=new A.Cartesian3;t.computeEllipsePositions=function(a,t,e){var i=a.semiMinorAxis,r=a.semiMajorAxis,n=a.rotation,s=a.center,a=8*a.granularity,o=i*i,l=r*r,C=r*i,y=A.Cartesian3.magnitude(s),c=A.Cartesian3.normalize(s,Q),u=A.Cartesian3.cross(A.Cartesian3.UNIT_Z,s,b),u=A.Cartesian3.normalize(u,u),m=A.Cartesian3.cross(c,u,G);let h=1+Math.ceil(R.CesiumMath.PI_OVER_TWO/a);var x=R.CesiumMath.PI_OVER_TWO/(h-1);let M=R.CesiumMath.PI_OVER_TWO-h*x;M<0&&(h-=Math.ceil(Math.abs(M)/x));const z=t?new Array(h*(h+2)*2*3):void 0;let f=0,_=S,d=B;a=4*h*3;let p=a-1,O=0;const w=e?new Array(a):void 0;let P,T,I,g,E;for(M=R.CesiumMath.PI_OVER_TWO,_=W(M,n,m,u,o,C,l,y,c,_),t&&(z[f++]=_.x,z[f++]=_.y,z[f++]=_.z),e&&(w[p--]=_.z,w[p--]=_.y,w[p--]=_.x),M=R.CesiumMath.PI_OVER_TWO-x,P=1;P<h+1;++P){if(_=W(M,n,m,u,o,C,l,y,c,_),d=W(Math.PI-M,n,m,u,o,C,l,y,c,d),t){for(z[f++]=_.x,z[f++]=_.y,z[f++]=_.z,I=2*P+2,T=1;T<I-1;++T)g=T/(I-1),E=A.Cartesian3.lerp(_,d,g,v),z[f++]=E.x,z[f++]=E.y,z[f++]=E.z;z[f++]=d.x,z[f++]=d.y,z[f++]=d.z}e&&(w[p--]=_.z,w[p--]=_.y,w[p--]=_.x,w[O++]=d.x,w[O++]=d.y,w[O++]=d.z),M=R.CesiumMath.PI_OVER_TWO-(P+1)*x}for(P=h;1<P;--P){if(M=R.CesiumMath.PI_OVER_TWO-(P-1)*x,_=W(-M,n,m,u,o,C,l,y,c,_),d=W(M+Math.PI,n,m,u,o,C,l,y,c,d),t){for(z[f++]=_.x,z[f++]=_.y,z[f++]=_.z,I=2*(P-1)+2,T=1;T<I-1;++T)g=T/(I-1),E=A.Cartesian3.lerp(_,d,g,v),z[f++]=E.x,z[f++]=E.y,z[f++]=E.z;z[f++]=d.x,z[f++]=d.y,z[f++]=d.z}e&&(w[p--]=_.z,w[p--]=_.y,w[p--]=_.x,w[O++]=d.x,w[O++]=d.y,w[O++]=d.z)}M=R.CesiumMath.PI_OVER_TWO,_=W(-M,n,m,u,o,C,l,y,c,_);const V={};return t&&(z[f++]=_.x,z[f++]=_.y,z[f++]=_.z,V.positions=z,V.numPts=h),e&&(w[p--]=_.z,w[p--]=_.y,w[p--]=_.x,V.outerPositions=w),V},a.EllipseGeometryLibrary=t});