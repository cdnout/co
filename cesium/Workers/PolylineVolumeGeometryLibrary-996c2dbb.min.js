define(["exports","./Matrix2-37e55508","./EllipsoidTangentPlane-06e319ef","./ComponentDatatype-a15c9a19","./PolylinePipeline-21ef0cd0","./Transforms-dca21951","./defaultValue-81eec7ed","./RuntimeError-8952249c"],function(e,O,u,V,I,m,t,a){"use strict";var N=Object.freeze({ROUNDED:0,MITERED:1,BEVELED:2});const n={};function G(e,a){t.defined(n[e])||(n[e]=!0,console.warn(t.defaultValue(a,e)))}G.geometryOutlines="Entity geometry outlines are unsupported on terrain. Outlines will be disabled. To enable outlines, disable geometry terrain clamping by explicitly setting height to 0.",G.geometryZIndex="Entity geometry with zIndex are unsupported when height or extrudedHeight are defined.  zIndex will be ignored",G.geometryHeightReference="Entity corridor, ellipse, polygon or rectangle with heightReference must also have a defined height.  heightReference will be ignored",G.geometryExtrudedHeightReference="Entity corridor, ellipse, polygon or rectangle with extrudedHeightReference must also have a defined extrudedHeight.  extrudedHeightReference will be ignored";const H=[new O.Cartesian3,new O.Cartesian3],L=new O.Cartesian3,j=new O.Cartesian3,Q=new O.Cartesian3,q=new O.Cartesian3,F=new O.Cartesian3,U=new O.Cartesian3,_=new O.Cartesian3,Z=new O.Cartesian3,W=new O.Cartesian3,Y=new O.Cartesian3,f=new O.Cartesian3,k={};let J=new O.Cartographic;function K(e,a,t,n){const r=e[0],i=e[1],s=O.Cartesian3.angleBetween(r,i),o=Math.ceil(s/n),l=new Array(o);let c;if(a===t){for(c=0;c<o;c++)l[c]=a;return l.push(t),l}var C=(t-a)/o;for(c=1;c<o;c++){const e=a+c*C;l[c]=e}return l[0]=a,l.push(t),l}const d=new O.Cartesian3,g=new O.Cartesian3,y=new O.Cartesian3(-1,0,0);let h=new O.Matrix4;const p=new O.Matrix4;let w=new O.Matrix3;const x=O.Matrix3.IDENTITY.clone(),E=new O.Cartesian3,P=new O.Cartesian4,M=new O.Cartesian3;function X(e,a,t,n,o,r,i,s){let l=E,c=P;h=m.Transforms.eastNorthUpToFixedFrame(e,o,h),l=O.Matrix4.multiplyByPointAsVector(h,y,l);e=function(e,a,t){const n=new u.EllipsoidTangentPlane(t,o),r=n.projectPointOntoPlane(O.Cartesian3.add(t,e,d),d),i=n.projectPointOntoPlane(O.Cartesian3.add(t,a,g),g),s=O.Cartesian2.angleBetween(r,i);return 0<=i.x*r.y-i.y*r.x?-s:s}(O.Cartesian3.normalize(l,l),a,e);w=O.Matrix3.fromRotationZ(e,w),M.z=r,h=O.Matrix4.multiplyTransformation(h,O.Matrix4.fromRotationTranslation(w,M,p),h);const C=x;C[0]=i;for(let e=0;e<s;e++)for(let e=0;e<t.length;e+=3)c=O.Cartesian3.fromArray(t,e,c),c=O.Matrix3.multiplyByVector(C,c,c),c=O.Matrix4.multiplyByPoint(h,c,c),n.push(c.x,c.y,c.z);return n}const l=new O.Cartesian3;function $(a,t,n,r,i,s,o){for(let e=0;e<a.length;e+=3)r=X(O.Cartesian3.fromArray(a,e,l),t,n,r,i,s[e/3],o,1);return r}function ee(a,e){const t=a.length,n=new Array(3*t);let r=0;var i=e.x+e.width/2,s=e.y+e.height/2;for(let e=0;e<t;e++)n[r++]=a[e].x-i,n[r++]=0,n[r++]=a[e].y-s;return n}const T=new m.Quaternion,b=new O.Cartesian3,B=new O.Matrix3;function ae(a,t,e,n,r,i,s,o,l,c){var C=O.Cartesian3.angleBetween(O.Cartesian3.subtract(t,a,Y),O.Cartesian3.subtract(e,a,f)),u=n===N.BEVELED?0:Math.ceil(C/V.CesiumMath.toRadians(5));let d,g,y;if(d=r?O.Matrix3.fromQuaternion(m.Quaternion.fromAxisAngle(O.Cartesian3.negate(a,Y),C/(u+1),T),B):O.Matrix3.fromQuaternion(m.Quaternion.fromAxisAngle(a,C/(u+1),T),B),t=O.Cartesian3.clone(t,b),0<u){const V=c?2:1;for(let e=0;e<u;e++)t=O.Matrix3.multiplyByVector(d,t,t),g=O.Cartesian3.subtract(t,a,Y),g=O.Cartesian3.normalize(g,g),r||(g=O.Cartesian3.negate(g,g)),y=i.scaleToGeodeticSurface(t,f),s=X(y,g,o,s,i,l,1,V)}else g=O.Cartesian3.subtract(t,a,Y),g=O.Cartesian3.normalize(g,g),r||(g=O.Cartesian3.negate(g,g)),y=i.scaleToGeodeticSurface(t,f),s=X(y,g,o,s,i,l,1,1),e=O.Cartesian3.clone(e,b),g=O.Cartesian3.subtract(e,a,Y),g=O.Cartesian3.normalize(g,g),r||(g=O.Cartesian3.negate(g,g)),y=i.scaleToGeodeticSurface(e,f),s=X(y,g,o,s,i,l,1,1);return s}k.removeDuplicatesFromShape=function(t){const n=t.length,r=[];for(let e=n-1,a=0;a<n;e=a++){const n=t[e],i=t[a];O.Cartesian2.equals(n,i)||r.push(i)}return r},k.angleIsGreaterThanPi=function(e,a,t,n){const r=new u.EllipsoidTangentPlane(t,n),i=r.projectPointOntoPlane(O.Cartesian3.add(t,e,d),d),s=r.projectPointOntoPlane(O.Cartesian3.add(t,a,g),g);return 0<=s.x*i.y-s.y*i.x};const te=new O.Cartesian3,ne=new O.Cartesian3;k.computePositions=function(a,t,n,r,i){const s=r._ellipsoid,o=function(a,t){const n=new Array(a.length);for(let e=0;e<a.length;e++){var r=a[e];J=t.cartesianToCartographic(r,J),n[e]=J.height,a[e]=t.scaleToGeodeticSurface(r,r)}return n}(a,s),l=r._granularity,c=r._cornerType,C=(i?function(a,e){const t=a.length,n=new Array(6*t);let r=0;var i=e.x+e.width/2,s=e.y+e.height/2;let o=a[0];n[r++]=o.x-i,n[r++]=0,n[r++]=o.y-s;for(let e=1;e<t;e++){o=a[e];const t=o.x-i,l=o.y-s;n[r++]=t,n[r++]=0,n[r++]=l,n[r++]=t,n[r++]=0,n[r++]=l}return o=a[0],n[r++]=o.x-i,n[r++]=0,n[r++]=o.y-s,n}:ee)(t,n),e=i?ee(t,n):void 0,u=n.height/2,d=n.width/2;let g=a.length,y=[],m=i?[]:void 0,f=L,h=j,p=Q,w=q,x=F,E=U,P=_,M=Z,T=W,b=a[0],B=a[1];w=s.geodeticSurfaceNormal(b,w),f=O.Cartesian3.subtract(B,b,f),f=O.Cartesian3.normalize(f,f),M=O.Cartesian3.cross(w,f,M),M=O.Cartesian3.normalize(M,M);let z,S,A=o[0],D=o[1];i&&(m=X(b,M,e,m,s,A+u,1,1)),T=O.Cartesian3.clone(b,T),b=B,h=O.Cartesian3.negate(f,h);for(let e=1;e<g-1;e++){const n=i?2:1;if(B=a[e+1],b.equals(B))G("Positions are too close and are considered equivalent with rounding error.");else{f=O.Cartesian3.subtract(B,b,f),f=O.Cartesian3.normalize(f,f),p=O.Cartesian3.add(f,h,p),p=O.Cartesian3.normalize(p,p),w=s.geodeticSurfaceNormal(b,w);const r=O.Cartesian3.multiplyByScalar(w,O.Cartesian3.dot(f,w),te);O.Cartesian3.subtract(f,r,r),O.Cartesian3.normalize(r,r);const L=O.Cartesian3.multiplyByScalar(w,O.Cartesian3.dot(h,w),ne);if(O.Cartesian3.subtract(h,L,L),O.Cartesian3.normalize(L,L),V.CesiumMath.equalsEpsilon(Math.abs(O.Cartesian3.dot(r,L)),1,V.CesiumMath.EPSILON7))y=X(T,M,C,y,s,A+u,1,1),T=b;else{p=O.Cartesian3.cross(p,w,p),p=O.Cartesian3.cross(w,p,p),p=O.Cartesian3.normalize(p,p);const a=1/Math.max(.25,O.Cartesian3.magnitude(O.Cartesian3.cross(p,h,Y))),t=k.angleIsGreaterThanPi(f,h,b,s);T=(t?(x=O.Cartesian3.add(b,O.Cartesian3.multiplyByScalar(p,a*d,p),x),E=O.Cartesian3.add(x,O.Cartesian3.multiplyByScalar(M,d,E),E),H[0]=O.Cartesian3.clone(T,H[0]),H[1]=O.Cartesian3.clone(E,H[1]),z=K(H,A+u,D+u,l),S=I.PolylinePipeline.generateArc({positions:H,granularity:l,ellipsoid:s}),y=$(S,M,C,y,s,z,1),M=O.Cartesian3.cross(w,f,M),M=O.Cartesian3.normalize(M,M),P=O.Cartesian3.add(x,O.Cartesian3.multiplyByScalar(M,d,P),P),c===N.ROUNDED||c===N.BEVELED?ae(x,E,P,c,t,s,y,C,D+u,i):(p=O.Cartesian3.negate(p,p),y=X(b,p,C,y,s,D+u,a,n))):(x=O.Cartesian3.add(b,O.Cartesian3.multiplyByScalar(p,a*d,p),x),E=O.Cartesian3.add(x,O.Cartesian3.multiplyByScalar(M,-d,E),E),H[0]=O.Cartesian3.clone(T,H[0]),H[1]=O.Cartesian3.clone(E,H[1]),z=K(H,A+u,D+u,l),S=I.PolylinePipeline.generateArc({positions:H,granularity:l,ellipsoid:s}),y=$(S,M,C,y,s,z,1),M=O.Cartesian3.cross(w,f,M),M=O.Cartesian3.normalize(M,M),P=O.Cartesian3.add(x,O.Cartesian3.multiplyByScalar(M,-d,P),P),c===N.ROUNDED||c===N.BEVELED?ae(x,E,P,c,t,s,y,C,D+u,i):y=X(b,p,C,y,s,D+u,a,n)),O.Cartesian3.clone(P,T)),h=O.Cartesian3.negate(f,h)}A=D,D=o[e+1],b=B}}H[0]=O.Cartesian3.clone(T,H[0]),H[1]=O.Cartesian3.clone(b,H[1]),z=K(H,A+u,D+u,l),S=I.PolylinePipeline.generateArc({positions:H,granularity:l,ellipsoid:s}),y=$(S,M,C,y,s,z,1),i&&(m=X(b,M,e,m,s,D+u,1,1)),g=y.length;const R=i?g+m.length:g,v=new Float64Array(R);return v.set(y),i&&v.set(m,g),v},e.CornerType=N,e.PolylineVolumeGeometryLibrary=k,e.oneTimeWarning=G});