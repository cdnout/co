define(["./defaultValue-81eec7ed","./Matrix2-37e55508","./ArcType-fc72c06c","./GeometryOffsetAttribute-8c5e10db","./Transforms-dca21951","./RuntimeError-8952249c","./ComponentDatatype-a15c9a19","./EllipsoidTangentPlane-06e319ef","./GeometryAttribute-cc3a5bc9","./GeometryAttributes-32b29525","./GeometryInstance-13e4ff38","./GeometryPipeline-20022973","./IndexDatatype-f1dcdf35","./PolygonGeometryLibrary-41822a76","./PolygonPipeline-b6cd7820","./_commonjsHelpers-3aae1032-26891ab7","./combine-3c023bda","./WebGLConstants-508b9636","./AxisAlignedBoundingBox-0ddf9b79","./IntersectionTests-ee135b8e","./Plane-6ee42cab","./AttributeCompression-27507afe","./EncodedCartesian3-96fdc0ef","./arrayRemoveDuplicates-dc2f4046","./EllipsoidRhumbLine-125a8b72"],function(g,d,m,h,b,e,P,E,A,_,G,L,H,T,v,t,i,r,o,n,a,l,s,y,u){"use strict";const O=[],x=[];function c(e){var t=e.polygonHierarchy,i=g.defaultValue(e.ellipsoid,d.Ellipsoid.WGS84),r=g.defaultValue(e.granularity,P.CesiumMath.RADIANS_PER_DEGREE),o=g.defaultValue(e.perPositionHeight,!1),n=o&&g.defined(e.extrudedHeight),a=g.defaultValue(e.arcType,m.ArcType.GEODESIC);let l=g.defaultValue(e.height,0),s=g.defaultValue(e.extrudedHeight,l);if(!n){const g=Math.max(l,s);s=Math.min(l,s),l=g}this._ellipsoid=d.Ellipsoid.clone(i),this._granularity=r,this._height=l,this._extrudedHeight=s,this._arcType=a,this._polygonHierarchy=t,this._perPositionHeight=o,this._perPositionHeightExtrude=n,this._offsetAttribute=e.offsetAttribute,this._workerName="createPolygonOutlineGeometry",this.packedLength=T.PolygonGeometryLibrary.computeHierarchyPackedLength(t)+d.Ellipsoid.packedLength+8}c.pack=function(e,t,i){return i=g.defaultValue(i,0),i=T.PolygonGeometryLibrary.packPolygonHierarchy(e._polygonHierarchy,t,i),d.Ellipsoid.pack(e._ellipsoid,t,i),i+=d.Ellipsoid.packedLength,t[i++]=e._height,t[i++]=e._extrudedHeight,t[i++]=e._granularity,t[i++]=e._perPositionHeightExtrude?1:0,t[i++]=e._perPositionHeight?1:0,t[i++]=e._arcType,t[i++]=g.defaultValue(e._offsetAttribute,-1),t[i]=e.packedLength,t};const f=d.Ellipsoid.clone(d.Ellipsoid.UNIT_SPHERE),C={polygonHierarchy:{}};return c.unpack=function(e,t,i){t=g.defaultValue(t,0);const r=T.PolygonGeometryLibrary.unpackPolygonHierarchy(e,t);t=r.startingIndex,delete r.startingIndex;var o=d.Ellipsoid.unpack(e,t,f);t+=d.Ellipsoid.packedLength;var n=e[t++],a=e[t++],l=e[t++],s=1===e[t++],y=1===e[t++],u=e[t++],p=e[t++],t=e[t];return(i=!g.defined(i)?new c(C):i)._polygonHierarchy=r,i._ellipsoid=d.Ellipsoid.clone(o,i._ellipsoid),i._height=n,i._extrudedHeight=a,i._granularity=l,i._perPositionHeight=y,i._perPositionHeightExtrude=s,i._arcType=u,i._offsetAttribute=-1===p?void 0:p,i.packedLength=t,i},c.fromPositions=function(e){return new c({polygonHierarchy:{positions:(e=g.defaultValue(e,g.defaultValue.EMPTY_OBJECT)).positions},height:e.height,extrudedHeight:e.extrudedHeight,ellipsoid:e.ellipsoid,granularity:e.granularity,perPositionHeight:e.perPositionHeight,arcType:e.arcType,offsetAttribute:e.offsetAttribute})},c.createGeometry=function(r){const o=r._ellipsoid,n=r._granularity,e=r._polygonHierarchy,a=r._perPositionHeight,l=r._arcType,s=T.PolygonGeometryLibrary.polygonOutlinesFromHierarchy(e,!a,o);if(0!==s.length){let t;const p=[],d=P.CesiumMath.chordLength(n,o.maximumRadius),c=r._height,f=r._extrudedHeight;let i,e;if(r._perPositionHeightExtrude||!P.CesiumMath.equalsEpsilon(c,f,0,P.CesiumMath.EPSILON2))for(e=0;e<s.length;e++){if(t=function(i,r,o,e,n){const t=E.EllipsoidTangentPlane.fromPoints(r,i).projectPointsOntoPlane(r,O);let a,l;v.PolygonPipeline.computeWindingOrder2D(t)===v.WindingOrder.CLOCKWISE&&(t.reverse(),r=r.slice().reverse());let s=r.length;const y=new Array(s);let u=0;if(e)for(a=new Float64Array(2*s*3*2),l=0;l<s;++l){y[l]=u/3;const i=r[l],m=r[(l+1)%s];a[u++]=i.x,a[u++]=i.y,a[u++]=i.z,a[u++]=m.x,a[u++]=m.y,a[u++]=m.z}else{let e=0;if(n===m.ArcType.GEODESIC)for(l=0;l<s;l++)e+=T.PolygonGeometryLibrary.subdivideLineCount(r[l],r[(l+1)%s],o);else if(n===m.ArcType.RHUMB)for(l=0;l<s;l++)e+=T.PolygonGeometryLibrary.subdivideRhumbLineCount(i,r[l],r[(l+1)%s],o);for(a=new Float64Array(3*e*2),l=0;l<s;++l){let t;y[l]=u/3,n===m.ArcType.GEODESIC?t=T.PolygonGeometryLibrary.subdivideLine(r[l],r[(l+1)%s],o,x):n===m.ArcType.RHUMB&&(t=T.PolygonGeometryLibrary.subdivideRhumbLine(i,r[l],r[(l+1)%s],o,x));const P=t.length;for(let e=0;e<P;++e)a[u++]=t[e]}}s=a.length/6;const p=y.length,d=2*(2*s+p),c=H.IndexDatatype.createTypedArray(s+p,d);for(u=0,l=0;l<s;++l)c[u++]=l,c[u++]=(l+1)%s,c[u++]=l+s,c[u++]=(l+1)%s+s;for(l=0;l<p;l++){const i=y[l];c[u++]=i,c[u++]=i+s}return new G.GeometryInstance({geometry:new A.Geometry({attributes:new _.GeometryAttributes({position:new A.GeometryAttribute({componentDatatype:P.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:a})}),indices:c,primitiveType:A.PrimitiveType.LINES})})}(o,s[e],d,a,l),t.geometry=T.PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(t.geometry,c,f,o,a),g.defined(r._offsetAttribute)){const g=t.geometry.attributes.position.values.length/3;let e=new Uint8Array(g);e=r._offsetAttribute===h.GeometryOffsetAttribute.TOP?h.arrayFill(e,1,0,g/2):(i=r._offsetAttribute===h.GeometryOffsetAttribute.NONE?0:1,h.arrayFill(e,i)),t.geometry.attributes.applyOffset=new A.GeometryAttribute({componentDatatype:P.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:e})}p.push(t)}else for(e=0;e<s.length;e++){if(t=function(i,r,o,e,n){const t=E.EllipsoidTangentPlane.fromPoints(r,i).projectPointsOntoPlane(r,O);let a,l;v.PolygonPipeline.computeWindingOrder2D(t)===v.WindingOrder.CLOCKWISE&&(t.reverse(),r=r.slice().reverse());let s=r.length,y=0;if(e)for(a=new Float64Array(2*s*3),l=0;l<s;l++){const i=r[l],m=r[(l+1)%s];a[y++]=i.x,a[y++]=i.y,a[y++]=i.z,a[y++]=m.x,a[y++]=m.y,a[y++]=m.z}else{let e=0;if(n===m.ArcType.GEODESIC)for(l=0;l<s;l++)e+=T.PolygonGeometryLibrary.subdivideLineCount(r[l],r[(l+1)%s],o);else if(n===m.ArcType.RHUMB)for(l=0;l<s;l++)e+=T.PolygonGeometryLibrary.subdivideRhumbLineCount(i,r[l],r[(l+1)%s],o);for(a=new Float64Array(3*e),l=0;l<s;l++){let t;n===m.ArcType.GEODESIC?t=T.PolygonGeometryLibrary.subdivideLine(r[l],r[(l+1)%s],o,x):n===m.ArcType.RHUMB&&(t=T.PolygonGeometryLibrary.subdivideRhumbLine(i,r[l],r[(l+1)%s],o,x));const P=t.length;for(let e=0;e<P;++e)a[y++]=t[e]}}s=a.length/3;const u=2*s,p=H.IndexDatatype.createTypedArray(s,u);for(y=0,l=0;l<s-1;l++)p[y++]=l,p[y++]=l+1;return p[y++]=s-1,p[y++]=0,new G.GeometryInstance({geometry:new A.Geometry({attributes:new _.GeometryAttributes({position:new A.GeometryAttribute({componentDatatype:P.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:a})}),indices:p,primitiveType:A.PrimitiveType.LINES})})}(o,s[e],d,a,l),t.geometry.attributes.position.values=v.PolygonPipeline.scaleToGeodeticHeight(t.geometry.attributes.position.values,c,o,!a),g.defined(r._offsetAttribute)){const g=t.geometry.attributes.position.values.length,o=new Uint8Array(g/3);i=r._offsetAttribute===h.GeometryOffsetAttribute.NONE?0:1,h.arrayFill(o,i),t.geometry.attributes.applyOffset=new A.GeometryAttribute({componentDatatype:P.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:o})}p.push(t)}var y=L.GeometryPipeline.combineInstances(p)[0],u=b.BoundingSphere.fromVertices(y.attributes.position.values);return new A.Geometry({attributes:y.attributes,indices:y.indices,primitiveType:y.primitiveType,boundingSphere:u,offsetAttribute:r._offsetAttribute})}},function(e,t){return(e=g.defined(t)?c.unpack(e,t):e)._ellipsoid=d.Ellipsoid.clone(e._ellipsoid),c.createGeometry(e)}});