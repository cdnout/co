define(["exports","./GeometryOffsetAttribute-8c5e10db","./Transforms-dca21951","./Matrix2-37e55508","./RuntimeError-8952249c","./ComponentDatatype-a15c9a19","./defaultValue-81eec7ed","./EllipseGeometryLibrary-30fc3ab5","./GeometryAttribute-cc3a5bc9","./GeometryAttributes-32b29525","./GeometryInstance-13e4ff38","./GeometryPipeline-20022973","./IndexDatatype-f1dcdf35","./VertexFormat-a0b706b0"],function(t,V,D,O,e,S,L,F,R,j,p,y,d,f){"use strict";const z=new O.Cartesian3,k=new O.Cartesian3,B=new O.Cartesian3,Y=new O.Cartesian3,H=new O.Cartesian2,U=new O.Matrix3,Q=new O.Matrix3,W=new D.Quaternion,J=new O.Cartesian3,q=new O.Cartesian3,Z=new O.Cartesian3,K=new O.Cartographic,X=new O.Cartesian3,$=new O.Cartesian2,tt=new O.Cartesian2;function A(e,r,i){const a=r.vertexFormat,t=r.center,n=r.semiMajorAxis,o=r.semiMinorAxis,s=r.ellipsoid,l=r.stRotation,u=i?e.length/3*2:e.length/3,m=r.shadowVolume,c=a.st?new Float32Array(2*u):void 0,p=a.normal?new Float32Array(3*u):void 0,y=a.tangent?new Float32Array(3*u):void 0,d=a.bitangent?new Float32Array(3*u):void 0,f=m?new Float32Array(3*u):void 0;let A=0,x=J,h=q,g=Z;const _=new D.GeographicProjection(s),b=_.project(s.cartesianToCartographic(t,K),X),C=s.scaleToGeodeticSurface(t,z);s.geodeticSurfaceNormal(C,C);let w=U,v=Q;var E;v=0!==l?(E=D.Quaternion.fromAxisAngle(C,l,W),w=O.Matrix3.fromQuaternion(E,w),E=D.Quaternion.fromAxisAngle(C,-l,W),O.Matrix3.fromQuaternion(E,v)):(w=O.Matrix3.clone(O.Matrix3.IDENTITY,w),O.Matrix3.clone(O.Matrix3.IDENTITY,v));const M=O.Cartesian2.fromElements(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,$),I=O.Cartesian2.fromElements(Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,tt);let T=e.length;var G=i?T:0,N=G/3*2;for(let t=0;t<T;t+=3){const D=t+1,r=t+2,S=O.Cartesian3.fromArray(e,t,z);if(a.st){const e=O.Matrix3.multiplyByVector(w,S,k),V=_.project(s.cartesianToCartographic(e,K),B);O.Cartesian3.subtract(V,b,V),H.x=(V.x+n)/(2*n),H.y=(V.y+o)/(2*o),M.x=Math.min(H.x,M.x),M.y=Math.min(H.y,M.y),I.x=Math.max(H.x,I.x),I.y=Math.max(H.y,I.y),i&&(c[A+N]=H.x,c[A+1+N]=H.y),c[A++]=H.x,c[A++]=H.y}(a.normal||a.tangent||a.bitangent||m)&&(x=s.geodeticSurfaceNormal(S,x),m&&(f[t+G]=-x.x,f[D+G]=-x.y,f[r+G]=-x.z),(a.normal||a.tangent||a.bitangent)&&((a.tangent||a.bitangent)&&(h=O.Cartesian3.normalize(O.Cartesian3.cross(O.Cartesian3.UNIT_Z,x,h),h),O.Matrix3.multiplyByVector(v,h,h)),a.normal&&(p[t]=x.x,p[D]=x.y,p[r]=x.z,i&&(p[t+G]=-x.x,p[D+G]=-x.y,p[r+G]=-x.z)),a.tangent&&(y[t]=h.x,y[D]=h.y,y[r]=h.z,i&&(y[t+G]=-h.x,y[D+G]=-h.y,y[r+G]=-h.z)),a.bitangent&&(g=O.Cartesian3.normalize(O.Cartesian3.cross(x,h,g),g),d[t]=g.x,d[D]=g.y,d[r]=g.z,i&&(d[t+G]=g.x,d[D+G]=g.y,d[r+G]=g.z))))}if(a.st){T=c.length;for(let t=0;t<T;t+=2)c[t]=(c[t]-M.x)/(I.x-M.x),c[t+1]=(c[t+1]-M.y)/(I.y-M.y)}const P=new j.GeometryAttributes;if(a.position){const V=F.EllipseGeometryLibrary.raisePositionsToHeight(e,r,i);P.position=new R.GeometryAttribute({componentDatatype:S.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:V})}if(a.st&&(P.st=new R.GeometryAttribute({componentDatatype:S.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:c})),a.normal&&(P.normal=new R.GeometryAttribute({componentDatatype:S.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:p})),a.tangent&&(P.tangent=new R.GeometryAttribute({componentDatatype:S.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:y})),a.bitangent&&(P.bitangent=new R.GeometryAttribute({componentDatatype:S.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:d})),m&&(P.extrudeDirection=new R.GeometryAttribute({componentDatatype:S.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:f})),i&&L.defined(r.offsetAttribute)){let t=new Uint8Array(u);if(r.offsetAttribute===V.GeometryOffsetAttribute.TOP)t=V.arrayFill(t,1,0,u/2);else{const D=r.offsetAttribute===V.GeometryOffsetAttribute.NONE?0:1;t=V.arrayFill(t,D)}P.applyOffset=new R.GeometryAttribute({componentDatatype:S.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:t})}return P}function x(t){const e=new Array(t*(t+1)*12-6);let r,i,a,n,o,s=0;for(r=0,a=1,n=0;n<3;n++)e[s++]=a++,e[s++]=r,e[s++]=a;for(n=2;n<t+1;++n){for(a=n*(n+1)-1,r=(n-1)*n-1,e[s++]=a++,e[s++]=r,e[s++]=a,i=2*n,o=0;o<i-1;++o)e[s++]=a,e[s++]=r++,e[s++]=r,e[s++]=a++,e[s++]=r,e[s++]=a;e[s++]=a++,e[s++]=r,e[s++]=a}for(i=2*t,++a,++r,n=0;n<i-1;++n)e[s++]=a,e[s++]=r++,e[s++]=r,e[s++]=a++,e[s++]=r,e[s++]=a;for(e[s++]=a,e[s++]=r++,e[s++]=r,e[s++]=a++,e[s++]=r++,e[s++]=r,++r,n=t-1;1<n;--n){for(e[s++]=r++,e[s++]=r,e[s++]=a,i=2*n,o=0;o<i-1;++o)e[s++]=a,e[s++]=r++,e[s++]=r,e[s++]=a++,e[s++]=r,e[s++]=a;e[s++]=r++,e[s++]=r++,e[s++]=a++}for(n=0;n<3;n++)e[s++]=r++,e[s++]=r,e[s++]=a;return e}let o=new O.Cartesian3;const h=new D.BoundingSphere,g=new D.BoundingSphere;function s(t,e,r,i,a,n,o){const s=F.EllipseGeometryLibrary.computeEllipsePositions({center:t,semiMajorAxis:e,semiMinorAxis:r,rotation:i,granularity:a},!1,!0).outerPositions,l=s.length/3,u=new Array(l);for(let t=0;t<l;++t)u[t]=O.Cartesian3.fromArray(s,3*t);const m=O.Rectangle.fromCartesianArray(u,n,o);return m.width>S.CesiumMath.PI&&(m.north=0<m.north?S.CesiumMath.PI_OVER_TWO-S.CesiumMath.EPSILON7:m.north,m.south=m.south<0?S.CesiumMath.EPSILON7-S.CesiumMath.PI_OVER_TWO:m.south,m.east=S.CesiumMath.PI,m.west=-S.CesiumMath.PI),m}function _(t){var e=(t=L.defaultValue(t,L.defaultValue.EMPTY_OBJECT)).center,r=L.defaultValue(t.ellipsoid,O.Ellipsoid.WGS84),i=t.semiMajorAxis,a=t.semiMinorAxis,n=L.defaultValue(t.granularity,S.CesiumMath.RADIANS_PER_DEGREE),o=L.defaultValue(t.vertexFormat,f.VertexFormat.DEFAULT),s=L.defaultValue(t.height,0),l=L.defaultValue(t.extrudedHeight,s);this._center=O.Cartesian3.clone(e),this._semiMajorAxis=i,this._semiMinorAxis=a,this._ellipsoid=O.Ellipsoid.clone(r),this._rotation=L.defaultValue(t.rotation,0),this._stRotation=L.defaultValue(t.stRotation,0),this._height=Math.max(l,s),this._granularity=n,this._vertexFormat=f.VertexFormat.clone(o),this._extrudedHeight=Math.min(l,s),this._shadowVolume=L.defaultValue(t.shadowVolume,!1),this._workerName="createEllipseGeometry",this._offsetAttribute=t.offsetAttribute,this._rectangle=void 0,this._textureCoordinateRotationPoints=void 0}_.packedLength=O.Cartesian3.packedLength+O.Ellipsoid.packedLength+f.VertexFormat.packedLength+9,_.pack=function(t,e,r){return r=L.defaultValue(r,0),O.Cartesian3.pack(t._center,e,r),r+=O.Cartesian3.packedLength,O.Ellipsoid.pack(t._ellipsoid,e,r),r+=O.Ellipsoid.packedLength,f.VertexFormat.pack(t._vertexFormat,e,r),r+=f.VertexFormat.packedLength,e[r++]=t._semiMajorAxis,e[r++]=t._semiMinorAxis,e[r++]=t._rotation,e[r++]=t._stRotation,e[r++]=t._height,e[r++]=t._granularity,e[r++]=t._extrudedHeight,e[r++]=t._shadowVolume?1:0,e[r]=L.defaultValue(t._offsetAttribute,-1),e};const b=new O.Cartesian3,C=new O.Ellipsoid,w=new f.VertexFormat,v={center:b,ellipsoid:C,vertexFormat:w,semiMajorAxis:void 0,semiMinorAxis:void 0,rotation:void 0,stRotation:void 0,height:void 0,granularity:void 0,extrudedHeight:void 0,shadowVolume:void 0,offsetAttribute:void 0};_.unpack=function(t,e,r){e=L.defaultValue(e,0);var i=O.Cartesian3.unpack(t,e,b);e+=O.Cartesian3.packedLength;var a=O.Ellipsoid.unpack(t,e,C);e+=O.Ellipsoid.packedLength;var n=f.VertexFormat.unpack(t,e,w);e+=f.VertexFormat.packedLength;var o=t[e++],s=t[e++],l=t[e++],u=t[e++],m=t[e++],c=t[e++],p=t[e++],y=1===t[e++],e=t[e];return L.defined(r)?(r._center=O.Cartesian3.clone(i,r._center),r._ellipsoid=O.Ellipsoid.clone(a,r._ellipsoid),r._vertexFormat=f.VertexFormat.clone(n,r._vertexFormat),r._semiMajorAxis=o,r._semiMinorAxis=s,r._rotation=l,r._stRotation=u,r._height=m,r._granularity=c,r._extrudedHeight=p,r._shadowVolume=y,r._offsetAttribute=-1===e?void 0:e,r):(v.height=m,v.extrudedHeight=p,v.granularity=c,v.stRotation=u,v.rotation=l,v.semiMajorAxis=o,v.semiMinorAxis=s,v.shadowVolume=y,v.offsetAttribute=-1===e?void 0:e,new _(v))},_.computeRectangle=function(t,e){var r=(t=L.defaultValue(t,L.defaultValue.EMPTY_OBJECT)).center,i=L.defaultValue(t.ellipsoid,O.Ellipsoid.WGS84),a=t.semiMajorAxis,n=t.semiMinorAxis,o=L.defaultValue(t.granularity,S.CesiumMath.RADIANS_PER_DEGREE);return s(r,a,n,L.defaultValue(t.rotation,0),o,i,e)},_.createGeometry=function(e){if(!(e._semiMajorAxis<=0||e._semiMinorAxis<=0)){const r=e._height,i=e._extrudedHeight,a=!S.CesiumMath.equalsEpsilon(r,i,0,S.CesiumMath.EPSILON2);e._center=e._ellipsoid.scaleToGeodeticSurface(e._center,e._center);const n={center:e._center,semiMajorAxis:e._semiMajorAxis,semiMinorAxis:e._semiMinorAxis,ellipsoid:e._ellipsoid,rotation:e._rotation,height:r,granularity:e._granularity,vertexFormat:e._vertexFormat,stRotation:e._stRotation};let t;if(a)n.extrudedHeight=i,n.shadowVolume=e._shadowVolume,n.offsetAttribute=e._offsetAttribute,t=function(t){const e=t.center,r=t.ellipsoid,i=t.semiMajorAxis;var a=O.Cartesian3.multiplyByScalar(r.geodeticSurfaceNormal(e,z),t.height,z);h.center=O.Cartesian3.add(e,a,h.center),h.radius=i,a=O.Cartesian3.multiplyByScalar(r.geodeticSurfaceNormal(e,a),t.extrudedHeight,a),g.center=O.Cartesian3.add(e,a,g.center),g.radius=i;var n=(s=F.EllipseGeometryLibrary.computeEllipsePositions(t,!0,!0)).positions,o=s.numPts,l=s.outerPositions,a=D.BoundingSphere.union(h,g),s=A(n,t,!0);let u=x(o);var m=u.length;u.length=2*m;var c=n.length/3;for(let t=0;t<m;t+=3)u[t+m]=u[t+2]+c,u[t+1+m]=u[t+1]+c,u[t+2+m]=u[t]+c;return n=d.IndexDatatype.createTypedArray(2*c/3,u),s=new R.Geometry({attributes:s,indices:n,primitiveType:R.PrimitiveType.TRIANGLES}),n=function(i,a){const n=a.vertexFormat,t=a.center,o=a.semiMajorAxis,s=a.semiMinorAxis,l=a.ellipsoid,u=a.height,m=a.extrudedHeight,e=a.stRotation,r=i.length/3*2,c=new Float64Array(3*r),p=n.st?new Float32Array(2*r):void 0,y=n.normal?new Float32Array(3*r):void 0,d=n.tangent?new Float32Array(3*r):void 0,f=n.bitangent?new Float32Array(3*r):void 0,A=a.shadowVolume,x=A?new Float32Array(3*r):void 0;let h=0,g=J,_=q,b=Z;const C=new D.GeographicProjection(l),w=C.project(l.cartesianToCartographic(t,K),X),v=l.scaleToGeodeticSurface(t,z);l.geodeticSurfaceNormal(v,v);const E=D.Quaternion.fromAxisAngle(v,e,W),M=O.Matrix3.fromQuaternion(E,U),I=O.Cartesian2.fromElements(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,$),T=O.Cartesian2.fromElements(Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,tt);let G=i.length;var N=G/3*2;for(let r=0;r<G;r+=3){const D=r+1,a=r+2;let t,e=O.Cartesian3.fromArray(i,r,z);if(n.st){const i=O.Matrix3.multiplyByVector(M,e,k),V=C.project(l.cartesianToCartographic(i,K),B);O.Cartesian3.subtract(V,w,V),H.x=(V.x+o)/(2*o),H.y=(V.y+s)/(2*s),I.x=Math.min(H.x,I.x),I.y=Math.min(H.y,I.y),T.x=Math.max(H.x,T.x),T.y=Math.max(H.y,T.y),p[h+N]=H.x,p[h+1+N]=H.y,p[h++]=H.x,p[h++]=H.y}e=l.scaleToGeodeticSurface(e,e),t=O.Cartesian3.clone(e,k),g=l.geodeticSurfaceNormal(e,g),A&&(x[r+G]=-g.x,x[D+G]=-g.y,x[a+G]=-g.z);var P=O.Cartesian3.multiplyByScalar(g,u,Y);if(e=O.Cartesian3.add(e,P,e),P=O.Cartesian3.multiplyByScalar(g,m,P),t=O.Cartesian3.add(t,P,t),n.position&&(c[r+G]=t.x,c[D+G]=t.y,c[a+G]=t.z,c[r]=e.x,c[D]=e.y,c[a]=e.z),n.normal||n.tangent||n.bitangent){b=O.Cartesian3.clone(g,b);const R=O.Cartesian3.fromArray(i,(r+3)%G,Y);O.Cartesian3.subtract(R,e,R);const j=O.Cartesian3.subtract(t,e,B);g=O.Cartesian3.normalize(O.Cartesian3.cross(j,R,g),g),n.normal&&(y[r]=g.x,y[D]=g.y,y[a]=g.z,y[r+G]=g.x,y[D+G]=g.y,y[a+G]=g.z),n.tangent&&(_=O.Cartesian3.normalize(O.Cartesian3.cross(b,g,_),_),d[r]=_.x,d[D]=_.y,d[a]=_.z,d[r+G]=_.x,d[r+1+G]=_.y,d[r+2+G]=_.z),n.bitangent&&(f[r]=b.x,f[D]=b.y,f[a]=b.z,f[r+G]=b.x,f[D+G]=b.y,f[a+G]=b.z)}}if(n.st){G=p.length;for(let t=0;t<G;t+=2)p[t]=(p[t]-I.x)/(T.x-I.x),p[t+1]=(p[t+1]-I.y)/(T.y-I.y)}const F=new j.GeometryAttributes;if(n.position&&(F.position=new R.GeometryAttribute({componentDatatype:S.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:c})),n.st&&(F.st=new R.GeometryAttribute({componentDatatype:S.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:p})),n.normal&&(F.normal=new R.GeometryAttribute({componentDatatype:S.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:y})),n.tangent&&(F.tangent=new R.GeometryAttribute({componentDatatype:S.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:d})),n.bitangent&&(F.bitangent=new R.GeometryAttribute({componentDatatype:S.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:f})),A&&(F.extrudeDirection=new R.GeometryAttribute({componentDatatype:S.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:x})),L.defined(a.offsetAttribute)){let t=new Uint8Array(r);if(a.offsetAttribute===V.GeometryOffsetAttribute.TOP)t=V.arrayFill(t,1,0,r/2);else{const D=a.offsetAttribute===V.GeometryOffsetAttribute.NONE?0:1;t=V.arrayFill(t,D)}F.applyOffset=new R.GeometryAttribute({componentDatatype:S.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:t})}return F}(l,t),u=function(){const e=l.length/3,r=d.IndexDatatype.createTypedArray(e,6*e);let i=0;for(let t=0;t<e;t++){var a=t,n=t+e,o=(a+1)%e,s=o+e;r[i++]=a,r[i++]=n,r[i++]=o,r[i++]=o,r[i++]=n,r[i++]=s}return r}(),t=d.IndexDatatype.createTypedArray(2*l.length/3,u),t=new R.Geometry({attributes:n,indices:t,primitiveType:R.PrimitiveType.TRIANGLES}),t=y.GeometryPipeline.combineInstances([new p.GeometryInstance({geometry:s}),new p.GeometryInstance({geometry:t})]),{boundingSphere:a,attributes:t[0].attributes,indices:t[0].indices}}(n);else if(t=function(t){var e=t.center;o=O.Cartesian3.multiplyByScalar(t.ellipsoid.geodeticSurfaceNormal(e,o),t.height,o),o=O.Cartesian3.add(e,o,o);var r=new D.BoundingSphere(o,t.semiMajorAxis),i=F.EllipseGeometryLibrary.computeEllipsePositions(t,!0,!1),e=i.positions,i=i.numPts,t=A(e,t,!1),i=x(i);return{boundingSphere:r,attributes:t,indices:i=d.IndexDatatype.createTypedArray(e.length/3,i)}}(n),L.defined(e._offsetAttribute)){const D=t.attributes.position.values.length,O=new Uint8Array(D/3),r=e._offsetAttribute===V.GeometryOffsetAttribute.NONE?0:1;V.arrayFill(O,r),t.attributes.applyOffset=new R.GeometryAttribute({componentDatatype:S.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:O})}return new R.Geometry({attributes:t.attributes,indices:t.indices,primitiveType:R.PrimitiveType.TRIANGLES,boundingSphere:t.boundingSphere,offsetAttribute:e._offsetAttribute})}},_.createShadowVolume=function(t,e,r){var i=t._granularity,a=t._ellipsoid,e=e(i,a),r=r(i,a);return new _({center:t._center,semiMajorAxis:t._semiMajorAxis,semiMinorAxis:t._semiMinorAxis,ellipsoid:a,rotation:t._rotation,stRotation:t._stRotation,granularity:i,extrudedHeight:e,height:r,vertexFormat:f.VertexFormat.POSITION_ONLY,shadowVolume:!0})},Object.defineProperties(_.prototype,{rectangle:{get:function(){return L.defined(this._rectangle)||(this._rectangle=s(this._center,this._semiMajorAxis,this._semiMinorAxis,this._rotation,this._granularity,this._ellipsoid)),this._rectangle}},textureCoordinateRotationPoints:{get:function(){return L.defined(this._textureCoordinateRotationPoints)||(this._textureCoordinateRotationPoints=function(t){var e=-t._stRotation;if(0==e)return[0,0,0,1,1,0];const r=F.EllipseGeometryLibrary.computeEllipsePositions({center:t._center,semiMajorAxis:t._semiMajorAxis,semiMinorAxis:t._semiMinorAxis,rotation:t._rotation,granularity:t._granularity},!1,!0).outerPositions,i=r.length/3,a=new Array(i);for(let t=0;t<i;++t)a[t]=O.Cartesian3.fromArray(r,3*t);var n=t._ellipsoid,t=t.rectangle;return R.Geometry._textureCoordinateRotationPoints(a,e,n,t)}(this)),this._textureCoordinateRotationPoints}}}),t.EllipseGeometry=_});