define(["./defaultValue-81eec7ed","./Matrix2-37e55508","./ArcType-fc72c06c","./GeometryOffsetAttribute-8c5e10db","./BoundingRectangle-aeed4004","./Transforms-dca21951","./RuntimeError-8952249c","./ComponentDatatype-a15c9a19","./EllipsoidGeodesic-cc3bace8","./EllipsoidTangentPlane-06e319ef","./GeometryAttribute-cc3a5bc9","./GeometryInstance-13e4ff38","./GeometryPipeline-20022973","./IndexDatatype-f1dcdf35","./PolygonGeometryLibrary-41822a76","./PolygonPipeline-b6cd7820","./VertexFormat-a0b706b0","./_commonjsHelpers-3aae1032-26891ab7","./combine-3c023bda","./WebGLConstants-508b9636","./AxisAlignedBoundingBox-0ddf9b79","./IntersectionTests-ee135b8e","./Plane-6ee42cab","./AttributeCompression-27507afe","./EncodedCartesian3-96fdc0ef","./arrayRemoveDuplicates-dc2f4046","./EllipsoidRhumbLine-125a8b72","./GeometryAttributes-32b29525"],function(O,V,u,F,e,D,t,L,p,w,N,T,I,A,v,E,f,o,r,a,i,n,s,l,c,m,y,g){"use strict";const H=new V.Cartographic,R=new V.Cartographic;const G=new e.BoundingRectangle,M=new V.Cartesian3,S=new V.Cartesian3,B=new V.Cartesian3,k=new V.Cartesian3,z=new V.Cartesian3,W=new V.Cartesian3;let Y=new V.Cartesian3,U=new V.Cartesian3,j=new V.Cartesian3;const Q=new V.Cartesian2,q=new V.Cartesian2,K=new V.Cartesian3,Z=new D.Quaternion,J=new V.Matrix3,X=new V.Matrix3;function $(m){const y=m.vertexFormat,g=m.geometry,d=m.shadowVolume,h=g.attributes.position.values;let f=h.length;var e,b=m.wall,_=m.top||b,P=m.bottom||b;if(y.st||y.normal||y.tangent||y.bitangent||d){const O=m.boundingRectangle,F=m.tangentPlane,C=m.ellipsoid,w=m.stRotation,T=m.perPositionHeight,I=Q;I.x=O.x,I.y=O.y;const A=y.st?new Float32Array(f/3*2):void 0;let t;y.normal&&(t=T&&_&&!b?g.attributes.normal.values:new Float32Array(f));const v=y.tangent?new Float32Array(f):void 0,E=y.bitangent?new Float32Array(f):void 0,G=d?new Float32Array(f):void 0;let o=0,r=0,a=S,i=B,n=k,s=!0,l=J,c=X;c=0!==w?(e=D.Quaternion.fromAxisAngle(F._plane.normal,w,Z),l=V.Matrix3.fromQuaternion(e,l),e=D.Quaternion.fromAxisAngle(F._plane.normal,-w,Z),V.Matrix3.fromQuaternion(e,c)):(l=V.Matrix3.clone(V.Matrix3.IDENTITY,l),V.Matrix3.clone(V.Matrix3.IDENTITY,c));let u=0,p=0;_&&P&&(u=f/2,p=f/3,f/=2);for(let e=0;e<f;e+=3){const g=V.Cartesian3.fromArray(h,e,K);if(y.st){var x=V.Matrix3.multiplyByVector(l,g,M),x=C.scaleToGeodeticSurface(x,x);const y=F.projectPointOntoPlane(x,q);V.Cartesian2.subtract(y,I,y);const D=L.CesiumMath.clamp(y.x/O.width,0,1),d=L.CesiumMath.clamp(y.y/O.height,0,1);P&&(A[o+p]=D,A[o+1+p]=d),_&&(A[o]=D,A[o+1]=d),o+=2}if(y.normal||y.tangent||y.bitangent||d){const O=r+1,F=r+2;if(b){if(e+3<f){const O=V.Cartesian3.fromArray(h,e+3,z);if(s){const m=V.Cartesian3.fromArray(h,e+f,W);T&&function(e,t,o,r){const a=r.cartesianToCartographic(e,H).height,i=r.cartesianToCartographic(t,R);i.height=a,r.cartographicToCartesian(i,t);const n=r.cartesianToCartographic(o,R);n.height=a-100,r.cartographicToCartesian(n,o)}(g,O,m,C),V.Cartesian3.subtract(O,g,O),V.Cartesian3.subtract(m,g,m),a=V.Cartesian3.normalize(V.Cartesian3.cross(m,O,a),a),s=!1}V.Cartesian3.equalsEpsilon(O,g,L.CesiumMath.EPSILON10)&&(s=!0)}(y.tangent||y.bitangent)&&(n=C.geodeticSurfaceNormal(g,n),y.tangent&&(i=V.Cartesian3.normalize(V.Cartesian3.cross(n,a,i),i)))}else a=C.geodeticSurfaceNormal(g,a),(y.tangent||y.bitangent)&&(T&&(Y=V.Cartesian3.fromArray(t,r,Y),U=V.Cartesian3.cross(V.Cartesian3.UNIT_Z,Y,U),U=V.Cartesian3.normalize(V.Matrix3.multiplyByVector(c,U,U),U),y.bitangent&&(j=V.Cartesian3.normalize(V.Cartesian3.cross(Y,U,j),j))),i=V.Cartesian3.cross(V.Cartesian3.UNIT_Z,a,i),i=V.Cartesian3.normalize(V.Matrix3.multiplyByVector(c,i,i),i),y.bitangent&&(n=V.Cartesian3.normalize(V.Cartesian3.cross(a,i,n),n)));y.normal&&(m.wall?(t[r+u]=a.x,t[O+u]=a.y,t[F+u]=a.z):P&&(t[r+u]=-a.x,t[O+u]=-a.y,t[F+u]=-a.z),(_&&!T||b)&&(t[r]=a.x,t[O]=a.y,t[F]=a.z)),d&&(b&&(a=C.geodeticSurfaceNormal(g,a)),G[r+u]=-a.x,G[O+u]=-a.y,G[F+u]=-a.z),y.tangent&&(m.wall?(v[r+u]=i.x,v[O+u]=i.y,v[F+u]=i.z):P&&(v[r+u]=-i.x,v[O+u]=-i.y,v[F+u]=-i.z),_&&(T?(v[r]=U.x,v[O]=U.y,v[F]=U.z):(v[r]=i.x,v[O]=i.y,v[F]=i.z))),y.bitangent&&(P&&(E[r+u]=n.x,E[O+u]=n.y,E[F+u]=n.z),_&&(T?(E[r]=j.x,E[O]=j.y,E[F]=j.z):(E[r]=n.x,E[O]=n.y,E[F]=n.z))),r+=3}}y.st&&(g.attributes.st=new N.GeometryAttribute({componentDatatype:L.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:A})),y.normal&&(g.attributes.normal=new N.GeometryAttribute({componentDatatype:L.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:t})),y.tangent&&(g.attributes.tangent=new N.GeometryAttribute({componentDatatype:L.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:v})),y.bitangent&&(g.attributes.bitangent=new N.GeometryAttribute({componentDatatype:L.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:E})),d&&(g.attributes.extrudeDirection=new N.GeometryAttribute({componentDatatype:L.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:G}))}if(m.extrude&&O.defined(m.offsetAttribute)){const O=h.length/3;let e=new Uint8Array(O);if(m.offsetAttribute===F.GeometryOffsetAttribute.TOP)_&&P||b?e=F.arrayFill(e,1,0,O/2):_&&(e=F.arrayFill(e,1));else{const O=m.offsetAttribute===F.GeometryOffsetAttribute.NONE?0:1;e=F.arrayFill(e,O)}g.attributes.applyOffset=new N.GeometryAttribute({componentDatatype:L.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:e})}return g}const d=new V.Cartographic,h=new V.Cartographic,b={westOverIDL:0,eastOverIDL:0};let _=new p.EllipsoidGeodesic;function P(t,o,e,r,a){if(a=O.defaultValue(a,new V.Rectangle),!O.defined(t)||t.length<3)return a.west=0,a.north=0,a.south=0,a.east=0,a;if(e===u.ArcType.RHUMB)return V.Rectangle.fromCartesianArray(t,o,a);_.ellipsoid.equals(o)||(_=new p.EllipsoidGeodesic(void 0,void 0,o)),a.west=Number.POSITIVE_INFINITY,a.east=Number.NEGATIVE_INFINITY,a.south=Number.POSITIVE_INFINITY,a.north=Number.NEGATIVE_INFINITY,b.westOverIDL=Number.POSITIVE_INFINITY,b.eastOverIDL=Number.NEGATIVE_INFINITY;var i=1/L.CesiumMath.chordLength(r,o.maximumRadius),n=t.length;let s,l=o.cartesianToCartographic(t[0],h),c=d;for(let e=1;e<n;e++)s=c,c=l,l=o.cartesianToCartographic(t[e],s),_.setEndPoints(c,l),C(_,i,a,b);return s=c,c=l,l=o.cartesianToCartographic(t[0],s),_.setEndPoints(c,l),C(_,i,a,b),a.east-a.west>b.eastOverIDL-b.westOverIDL&&(a.west=b.westOverIDL,a.east=b.eastOverIDL,a.east>L.CesiumMath.PI&&(a.east=a.east-L.CesiumMath.TWO_PI),a.west>L.CesiumMath.PI&&(a.west=a.west-L.CesiumMath.TWO_PI)),a}const x=new V.Cartographic;function C(t,o,r,a){const i=t.surfaceDistance,n=Math.ceil(i*o),s=0<n?i/(n-1):Number.POSITIVE_INFINITY;let l=0;for(let e=0;e<n;e++){const o=t.interpolateUsingSurfaceDistance(l,x);l+=s;const i=o.longitude,n=o.latitude;r.west=Math.min(r.west,i),r.east=Math.max(r.east,i),r.south=Math.min(r.south,n),r.north=Math.max(r.north,n);var c=0<=i?i:i+L.CesiumMath.TWO_PI;a.westOverIDL=Math.min(a.westOverIDL,c),a.eastOverIDL=Math.max(a.eastOverIDL,c)}}const ee=[];function te(e){var t=e.polygonHierarchy,o=O.defaultValue(e.vertexFormat,f.VertexFormat.DEFAULT),r=O.defaultValue(e.ellipsoid,V.Ellipsoid.WGS84),a=O.defaultValue(e.granularity,L.CesiumMath.RADIANS_PER_DEGREE),i=O.defaultValue(e.stRotation,0),n=O.defaultValue(e.perPositionHeight,!1),s=n&&O.defined(e.extrudedHeight);let l=O.defaultValue(e.height,0),c=O.defaultValue(e.extrudedHeight,l);if(!s){const O=Math.max(l,c);c=Math.min(l,c),l=O}this._vertexFormat=f.VertexFormat.clone(o),this._ellipsoid=V.Ellipsoid.clone(r),this._granularity=a,this._stRotation=i,this._height=l,this._extrudedHeight=c,this._closeTop=O.defaultValue(e.closeTop,!0),this._closeBottom=O.defaultValue(e.closeBottom,!0),this._polygonHierarchy=t,this._perPositionHeight=n,this._perPositionHeightExtrude=s,this._shadowVolume=O.defaultValue(e.shadowVolume,!1),this._workerName="createPolygonGeometry",this._offsetAttribute=e.offsetAttribute,this._arcType=O.defaultValue(e.arcType,u.ArcType.GEODESIC),this._rectangle=void 0,this._textureCoordinateRotationPoints=void 0,this.packedLength=v.PolygonGeometryLibrary.computeHierarchyPackedLength(t)+V.Ellipsoid.packedLength+f.VertexFormat.packedLength+12}te.fromPositions=function(e){return new te({polygonHierarchy:{positions:(e=O.defaultValue(e,O.defaultValue.EMPTY_OBJECT)).positions},height:e.height,extrudedHeight:e.extrudedHeight,vertexFormat:e.vertexFormat,stRotation:e.stRotation,ellipsoid:e.ellipsoid,granularity:e.granularity,perPositionHeight:e.perPositionHeight,closeTop:e.closeTop,closeBottom:e.closeBottom,offsetAttribute:e.offsetAttribute,arcType:e.arcType})},te.pack=function(e,t,o){return o=O.defaultValue(o,0),o=v.PolygonGeometryLibrary.packPolygonHierarchy(e._polygonHierarchy,t,o),V.Ellipsoid.pack(e._ellipsoid,t,o),o+=V.Ellipsoid.packedLength,f.VertexFormat.pack(e._vertexFormat,t,o),o+=f.VertexFormat.packedLength,t[o++]=e._height,t[o++]=e._extrudedHeight,t[o++]=e._granularity,t[o++]=e._stRotation,t[o++]=e._perPositionHeightExtrude?1:0,t[o++]=e._perPositionHeight?1:0,t[o++]=e._closeTop?1:0,t[o++]=e._closeBottom?1:0,t[o++]=e._shadowVolume?1:0,t[o++]=O.defaultValue(e._offsetAttribute,-1),t[o++]=e._arcType,t[o]=e.packedLength,t};const oe=V.Ellipsoid.clone(V.Ellipsoid.UNIT_SPHERE),re=new f.VertexFormat,ae={polygonHierarchy:{}};return te.unpack=function(e,t,o){t=O.defaultValue(t,0);const r=v.PolygonGeometryLibrary.unpackPolygonHierarchy(e,t);t=r.startingIndex,delete r.startingIndex;var a=V.Ellipsoid.unpack(e,t,oe);t+=V.Ellipsoid.packedLength;var i=f.VertexFormat.unpack(e,t,re);t+=f.VertexFormat.packedLength;var n=e[t++],s=e[t++],l=e[t++],c=e[t++],u=1===e[t++],p=1===e[t++],m=1===e[t++],y=1===e[t++],g=1===e[t++],d=e[t++],h=e[t++],t=e[t];return(o=!O.defined(o)?new te(ae):o)._polygonHierarchy=r,o._ellipsoid=V.Ellipsoid.clone(a,o._ellipsoid),o._vertexFormat=f.VertexFormat.clone(i,o._vertexFormat),o._height=n,o._extrudedHeight=s,o._granularity=l,o._stRotation=c,o._perPositionHeightExtrude=u,o._perPositionHeight=p,o._closeTop=m,o._closeBottom=y,o._shadowVolume=g,o._offsetAttribute=-1===d?void 0:d,o._arcType=h,o.packedLength=t,o},te.computeRectangle=function(e,t){var o=O.defaultValue(e.granularity,L.CesiumMath.RADIANS_PER_DEGREE),r=O.defaultValue(e.arcType,u.ArcType.GEODESIC),a=e.polygonHierarchy,e=O.defaultValue(e.ellipsoid,V.Ellipsoid.WGS84);return P(a.positions,e,r,o,t)},te.createGeometry=function(o){const r=o._vertexFormat,a=o._ellipsoid,i=o._granularity,e=o._stRotation,t=o._polygonHierarchy,n=o._perPositionHeight,s=o._closeTop,l=o._closeBottom,c=o._arcType;var u=t.positions;if(!(u.length<3)){const p=w.EllipsoidTangentPlane.fromPoints(u,a),m=v.PolygonGeometryLibrary.polygonsFromHierarchy(t,p.projectPointsOntoPlane.bind(p),!n,a),y=m.hierarchy,g=m.polygons;if(0!==y.length){u=y[0].outerRing;const d=v.PolygonGeometryLibrary.computeBoundingRectangle(p.plane.normal,p.projectPointOntoPlane.bind(p),u,e,G),h=[],f=o._height,b=o._extrudedHeight,_={perPositionHeight:n,vertexFormat:r,geometry:void 0,tangentPlane:p,boundingRectangle:d,ellipsoid:a,stRotation:e,bottom:!1,top:!0,wall:!1,extrude:!1,arcType:c};let t;if(o._perPositionHeightExtrude||!L.CesiumMath.equalsEpsilon(f,b,0,L.CesiumMath.EPSILON2))for(_.extrude=!0,_.top=s,_.bottom=l,_.shadowVolume=o._shadowVolume,_.offsetAttribute=o._offsetAttribute,t=0;t<g.length;t++){const O=function(o,r,a,i,n,s,l,c,u){const p={walls:[]};let m;if(s||l){const i=v.PolygonGeometryLibrary.createGeometryFromPositions(o,r,a,n,c,u),w=i.attributes.position.values,E=i.indices;let e,t;if(s&&l){const o=w.concat(w);e=o.length/3,t=A.IndexDatatype.createTypedArray(e,2*E.length),t.set(E);const r=E.length,a=e/2;for(m=0;m<r;m+=3){const o=t[m]+a,i=t[m+1]+a,n=t[m+2]+a;t[m+r]=n,t[m+1+r]=i,t[m+2+r]=o}if(i.attributes.position.values=o,n&&c.normal){const r=i.attributes.normal.values;i.attributes.normal.values=new Float32Array(o.length),i.attributes.normal.values.set(r)}i.indices=t}else if(l){for(e=w.length/3,t=A.IndexDatatype.createTypedArray(e,E.length),m=0;m<E.length;m+=3)t[m]=E[m+2],t[m+1]=E[m+1],t[m+2]=E[m];i.indices=t}p.topAndBottom=new T.GeometryInstance({geometry:i})}let e=i.outerRing,t=w.EllipsoidTangentPlane.fromPoints(e,o),y=t.projectPointsOntoPlane(e,ee),g=E.PolygonPipeline.computeWindingOrder2D(y);g===E.WindingOrder.CLOCKWISE&&(e=e.slice().reverse());var d=v.PolygonGeometryLibrary.computeWallGeometry(e,o,a,n,u);p.walls.push(new T.GeometryInstance({geometry:d}));var h=i.holes;for(m=0;m<h.length;m++){let e=h[m];t=w.EllipsoidTangentPlane.fromPoints(e,o),y=t.projectPointsOntoPlane(e,ee),E.PolygonPipeline.computeWindingOrder2D(y)===E.WindingOrder.COUNTER_CLOCKWISE&&(e=e.slice().reverse()),d=v.PolygonGeometryLibrary.computeWallGeometry(e,o,a,n,u),p.walls.push(new T.GeometryInstance({geometry:d}))}return p}(a,g[t],i,y[t],n,s,l,r,c);let e;s&&l?(e=O.topAndBottom,_.geometry=v.PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(e.geometry,f,b,a,n)):s?(e=O.topAndBottom,e.geometry.attributes.position.values=E.PolygonPipeline.scaleToGeodeticHeight(e.geometry.attributes.position.values,f,a,!n),_.geometry=e.geometry):l&&(e=O.topAndBottom,e.geometry.attributes.position.values=E.PolygonPipeline.scaleToGeodeticHeight(e.geometry.attributes.position.values,b,a,!0),_.geometry=e.geometry),(s||l)&&(_.wall=!1,e.geometry=$(_),h.push(e));const F=O.walls;_.wall=!0;for(let e=0;e<F.length;e++){const o=F[e];_.geometry=v.PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(o.geometry,f,b,a,n),o.geometry=$(_),h.push(o)}}else for(t=0;t<g.length;t++){const D=new T.GeometryInstance({geometry:v.PolygonGeometryLibrary.createGeometryFromPositions(a,g[t],i,n,r,c)});if(D.geometry.attributes.position.values=E.PolygonPipeline.scaleToGeodeticHeight(D.geometry.attributes.position.values,f,a,!n),_.geometry=D.geometry,D.geometry=$(_),O.defined(o._offsetAttribute)){const O=D.geometry.attributes.position.values.length,r=new Uint8Array(O/3),a=o._offsetAttribute===F.GeometryOffsetAttribute.NONE?0:1;F.arrayFill(r,a),D.geometry.attributes.applyOffset=new N.GeometryAttribute({componentDatatype:L.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:r})}h.push(D)}const P=I.GeometryPipeline.combineInstances(h)[0];P.attributes.position.values=new Float64Array(P.attributes.position.values),P.indices=A.IndexDatatype.createTypedArray(P.attributes.position.values.length/3,P.indices);const x=P.attributes,C=D.BoundingSphere.fromVertices(x.position.values);return r.position||delete x.position,new N.Geometry({attributes:x,indices:P.indices,primitiveType:P.primitiveType,boundingSphere:C,offsetAttribute:o._offsetAttribute})}}},te.createShadowVolume=function(e,t,o){var r=e._granularity,a=e._ellipsoid,t=t(r,a),o=o(r,a);return new te({polygonHierarchy:e._polygonHierarchy,ellipsoid:a,stRotation:e._stRotation,granularity:r,perPositionHeight:!1,extrudedHeight:t,height:o,vertexFormat:f.VertexFormat.POSITION_ONLY,shadowVolume:!0,arcType:e._arcType})},Object.defineProperties(te.prototype,{rectangle:{get:function(){if(!O.defined(this._rectangle)){const O=this._polygonHierarchy.positions;this._rectangle=P(O,this._ellipsoid,this._arcType,this._granularity)}return this._rectangle}},textureCoordinateRotationPoints:{get:function(){return O.defined(this._textureCoordinateRotationPoints)||(this._textureCoordinateRotationPoints=function(e){var t=-e._stRotation;if(0==t)return[0,0,0,1,1,0];var o=e._ellipsoid,r=e._polygonHierarchy.positions,e=e.rectangle;return N.Geometry._textureCoordinateRotationPoints(r,t,o,e)}(this)),this._textureCoordinateRotationPoints}}}),function(e,t){return(e=O.defined(t)?te.unpack(e,t):e)._ellipsoid=V.Ellipsoid.clone(e._ellipsoid),te.createGeometry(e)}});