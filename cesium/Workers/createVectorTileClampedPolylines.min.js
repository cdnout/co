define(["./AttributeCompression-27507afe","./Matrix2-37e55508","./combine-3c023bda","./IndexDatatype-f1dcdf35","./ComponentDatatype-a15c9a19","./createTaskProcessorWorker","./RuntimeError-8952249c","./defaultValue-81eec7ed","./WebGLConstants-508b9636"],function(v,H,F,O,P,t,e,a,s){"use strict";const D=32767,i=Math.cos(P.CesiumMath.toRadians(150)),S=new H.Cartographic,M=new H.Cartesian3,R=new H.Cartographic,U=new H.Cartographic;function B(t){var e=8*t,a=3*e,s=4*e;this.startEllipsoidNormals=new Float32Array(a),this.endEllipsoidNormals=new Float32Array(a),this.startPositionAndHeights=new Float32Array(s),this.startFaceNormalAndVertexCornerIds=new Float32Array(s),this.endPositionAndHeights=new Float32Array(s),this.endFaceNormalAndHalfWidths=new Float32Array(s),this.vertexBatchIds=new Uint16Array(e),this.indices=O.IndexDatatype.createTypedArray(e,36*t),this.vec3Offset=0,this.vec4Offset=0,this.batchIdOffset=0,this.indexOffset=0,this.volumeStartIndex=0}const o=new H.Cartesian3,d=new H.Cartesian3;function V(t,e,a,s,n){a=H.Cartesian3.subtract(a,e,d);let r=H.Cartesian3.subtract(e,t,o);return H.Cartesian3.normalize(a,a),H.Cartesian3.normalize(r,r),H.Cartesian3.dot(a,r)<i&&(r=H.Cartesian3.multiplyByScalar(r,-1,o)),H.Cartesian3.add(a,r,n),H.Cartesian3.equals(n,H.Cartesian3.ZERO)&&(n=H.Cartesian3.subtract(t,e)),H.Cartesian3.cross(n,s,n),H.Cartesian3.cross(s,n,n),H.Cartesian3.normalize(n,n),n}const T=[0,2,6,0,6,4,0,1,3,0,3,2,0,4,5,0,5,1,5,3,1,5,7,3,7,5,4,7,4,6,7,6,2,7,2,3],W=T.length,z=new H.Cartesian3,q=new H.Cartesian3,L=new H.Cartesian3,_=new H.Cartesian3,G=new H.Cartesian3;B.prototype.addVolume=function(t,e,a,s,n,r,i,o,d,l){var c=H.Cartesian3.add(e,d,z),f=l.geodeticSurfaceNormal(c,q),c=H.Cartesian3.add(a,d,z);const u=l.geodeticSurfaceNormal(c,_),h=V(t,e,a,f,L),C=V(s,a,e,u,G),p=this.startEllipsoidNormals,m=this.endEllipsoidNormals,b=this.startPositionAndHeights,A=this.startFaceNormalAndVertexCornerIds,w=this.endPositionAndHeights,g=this.endFaceNormalAndHalfWidths,y=this.vertexBatchIds;let N,k=this.batchIdOffset,I=this.vec3Offset,x=this.vec4Offset;for(N=0;N<8;N++)H.Cartesian3.pack(f,p,I),H.Cartesian3.pack(u,m,I),H.Cartesian3.pack(e,b,x),b[x+3]=n,H.Cartesian3.pack(a,w,x),w[x+3]=r,H.Cartesian3.pack(h,A,x),A[x+3]=N,H.Cartesian3.pack(C,g,x),g[x+3]=i,y[k++]=o,I+=3,x+=4;this.batchIdOffset=k,this.vec3Offset=I,this.vec4Offset=x;const E=this.indices,v=this.volumeStartIndex,F=this.indexOffset;for(N=0;N<W;N++)E[F+N]=T[N]+v;this.volumeStartIndex+=8,this.indexOffset+=W};const Z=new H.Rectangle,Y=new H.Ellipsoid,j=new H.Cartesian3,J=new H.Cartesian3,K=new H.Cartesian3,Q=new H.Cartesian3,X=new H.Cartesian3;return t(function(s,t){const n=new Uint16Array(s.positions),r=new Uint16Array(s.widths),e=new Uint32Array(s.counts),a=new Uint16Array(s.batchIds),i=Z,o=Y,d=j,l=new Float64Array(s.packedBuffer);var c=0,f=l[c++],u=l[c++];let h;H.Rectangle.unpack(l,2,i),c+=H.Rectangle.packedLength,H.Ellipsoid.unpack(l,c,o),c+=H.Ellipsoid.packedLength,H.Cartesian3.unpack(l,c,d);var C=n.length/3,p=n.subarray(0,C),c=n.subarray(C,2*C),m=n.subarray(2*C,3*C);v.AttributeCompression.zigZagDeltaDecode(p,c,m),function(a,s,e,n){const r=n.length,i=a.length,o=new Uint8Array(i),d=R,l=U;let c=0;for(let t=0;t<r;t++){const r=n[t];let e=r;for(let t=1;t<r;t++){const n=c+t,r=n-1;l.longitude=a[n],l.latitude=s[n],d.longitude=a[r],d.latitude=s[r],H.Cartographic.equals(l,d)&&(e--,o[r]=1)}n[t]=e,c+=r}let f=0;for(let t=0;t<i;t++)1!==o[t]&&(a[f]=a[t],s[f]=s[t],e[f]=e[t],f++)}(p,c,m,e);var b=e.length;let A=0;for(h=0;h<b;h++)A+=e[h]-1;const w=new B(A),g=function(e,a,s,n,r,i,o){const d=e.length,l=new Float64Array(3*d);for(let t=0;t<d;++t){const d=e[t],c=a[t],f=s[t],u=P.CesiumMath.lerp(n.west,n.east,d/D),h=P.CesiumMath.lerp(n.south,n.north,c/D),C=P.CesiumMath.lerp(r,i,f/D),p=H.Cartographic.fromRadians(u,h,C,S),m=o.cartographicToCartesian(p,M);H.Cartesian3.pack(m,l,3*t)}return l}(p,c,m,i,f,u,o);C=p.length;const y=new Float32Array(3*C);for(h=0;h<C;++h)y[3*h]=g[3*h]-d.x,y[3*h+1]=g[3*h+1]-d.y,y[3*h+2]=g[3*h+2]-d.z;let N=0,k=0;for(h=0;h<b;h++){const v=e[h]-1,F=.5*r[h],O=a[h],s=N;for(let a=0;a<v;a++){const n=H.Cartesian3.unpack(y,N,K),r=H.Cartesian3.unpack(y,N+3,Q);var I=m[k],x=m[k+1],I=P.CesiumMath.lerp(f,u,I/D),x=P.CesiumMath.lerp(f,u,x/D);k++;let t=J,e=X;if(0===a){const F=s+3*v,O=H.Cartesian3.unpack(y,F,J);if(H.Cartesian3.equals(O,n))H.Cartesian3.unpack(y,F-3,t);else{const v=H.Cartesian3.subtract(n,r,J);t=H.Cartesian3.add(v,n,J)}}else H.Cartesian3.unpack(y,N-3,t);if(a===v-1){const v=H.Cartesian3.unpack(y,s,X);if(H.Cartesian3.equals(v,r))H.Cartesian3.unpack(y,s+3,e);else{const v=H.Cartesian3.subtract(r,n,X);e=H.Cartesian3.add(v,r,X)}}else H.Cartesian3.unpack(y,N+6,e);w.addVolume(t,n,r,e,I,x,F,O,d,o),N+=3}N+=3,k++}p=w.indices;t.push(w.startEllipsoidNormals.buffer),t.push(w.endEllipsoidNormals.buffer),t.push(w.startPositionAndHeights.buffer),t.push(w.startFaceNormalAndVertexCornerIds.buffer),t.push(w.endPositionAndHeights.buffer),t.push(w.endFaceNormalAndHalfWidths.buffer),t.push(w.vertexBatchIds.buffer),t.push(p.buffer);let E={indexDatatype:2===p.BYTES_PER_ELEMENT?O.IndexDatatype.UNSIGNED_SHORT:O.IndexDatatype.UNSIGNED_INT,startEllipsoidNormals:w.startEllipsoidNormals.buffer,endEllipsoidNormals:w.endEllipsoidNormals.buffer,startPositionAndHeights:w.startPositionAndHeights.buffer,startFaceNormalAndVertexCornerIds:w.startFaceNormalAndVertexCornerIds.buffer,endPositionAndHeights:w.endPositionAndHeights.buffer,endFaceNormalAndHalfWidths:w.endFaceNormalAndHalfWidths.buffer,vertexBatchIds:w.vertexBatchIds.buffer,indices:p.buffer};if(s.keepDecodedPositions){const v=function(e){const a=e.length,s=new Uint32Array(a+1);let n=0;for(let t=0;t<a;++t)s[t]=n,n+=e[t];return s[a]=n,s}(e);t.push(g.buffer,v.buffer),E=F.combine(E,{decodedPositions:g.buffer,decodedPositionOffsets:v.buffer})}return E})});