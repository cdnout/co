define(["./GeometryOffsetAttribute-8c5e10db","./arrayRemoveDuplicates-dc2f4046","./Transforms-dca21951","./Matrix2-37e55508","./RuntimeError-8952249c","./ComponentDatatype-a15c9a19","./PolylineVolumeGeometryLibrary-996c2dbb","./CorridorGeometryLibrary-6c371153","./defaultValue-81eec7ed","./GeometryAttribute-cc3a5bc9","./GeometryAttributes-32b29525","./IndexDatatype-f1dcdf35","./PolygonPipeline-b6cd7820","./_commonjsHelpers-3aae1032-26891ab7","./combine-3c023bda","./WebGLConstants-508b9636","./EllipsoidTangentPlane-06e319ef","./AxisAlignedBoundingBox-0ddf9b79","./IntersectionTests-ee135b8e","./Plane-6ee42cab","./PolylinePipeline-21ef0cd0","./EllipsoidGeodesic-cc3bace8","./EllipsoidRhumbLine-125a8b72"],function(m,d,u,k,e,V,H,N,O,I,S,B,A,t,i,r,o,n,a,s,l,p,c){"use strict";const M=new k.Cartesian3,R=new k.Cartesian3,U=new k.Cartesian3;function _(e,r){const o=[],n=e.positions,a=e.corners,t=e.endPositions,i=new S.GeometryAttributes;let s,l,d,u=0,p=0,c=0;for(l=0;l<n.length;l+=2)d=n[l].length-3,u+=d,c+=d/3*4,p+=n[l+1].length-3;for(u+=3,p+=3,l=0;l<a.length;l++){s=a[l];const x=a[l].leftPositions;O.defined(x)?(d=x.length,u+=d):(d=a[l].rightPositions.length,p+=d),c+=d/3*2}e=O.defined(t);let f;e&&(f=t[0].length-3,u+=f,p+=f,f/=3,c+=4*f);const h=u+p,y=new Float64Array(h);let g,b,m,A,_,E,C=0,G=h-1;const v=f/2,T=B.IndexDatatype.createTypedArray(h/3,c+4);let P=0;if(T[P++]=C/3,T[P++]=(G-2)/3,e){o.push(C/3),E=M,_=R;const x=t[0];for(l=0;l<v;l++)E=k.Cartesian3.fromArray(x,3*(v-1-l),E),_=k.Cartesian3.fromArray(x,3*(v+l),_),N.CorridorGeometryLibrary.addAttribute(y,_,C),N.CorridorGeometryLibrary.addAttribute(y,E,void 0,G),b=C/3,A=b+1,g=(G-2)/3,m=g-1,T[P++]=g,T[P++]=m,T[P++]=b,T[P++]=A,C+=3,G-=3}let w=0,L=n[w++],D=n[w++];for(y.set(L,C),y.set(D,G-D.length+1),d=D.length-3,o.push(C/3,(G-2)/3),l=0;l<d;l+=3)b=C/3,A=b+1,g=(G-2)/3,m=g-1,T[P++]=g,T[P++]=m,T[P++]=b,T[P++]=A,C+=3,G-=3;for(l=0;l<a.length;l++){let e;s=a[l];const V=s.leftPositions,I=s.rightPositions;let t,i=U;if(O.defined(V)){for(G-=3,t=m,o.push(A),e=0;e<V.length/3;e++)i=k.Cartesian3.fromArray(V,3*e,i),T[P++]=t-e-1,T[P++]=t-e,N.CorridorGeometryLibrary.addAttribute(y,i,void 0,G),G-=3;o.push(t-Math.floor(V.length/6)),r===H.CornerType.BEVELED&&o.push((G-2)/3+1),C+=3}else{for(C+=3,t=A,o.push(m),e=0;e<I.length/3;e++)i=k.Cartesian3.fromArray(I,3*e,i),T[P++]=t+e,T[P++]=t+e+1,N.CorridorGeometryLibrary.addAttribute(y,i,C),C+=3;o.push(t+Math.floor(I.length/6)),r===H.CornerType.BEVELED&&o.push(C/3-1),G-=3}for(L=n[w++],D=n[w++],L.splice(0,3),D.splice(D.length-3,3),y.set(L,C),y.set(D,G-D.length+1),d=D.length-3,e=0;e<D.length;e+=3)A=C/3,b=A-1,m=(G-2)/3,g=m+1,T[P++]=g,T[P++]=m,T[P++]=b,T[P++]=A,C+=3,G-=3;C-=3,G+=3,o.push(C/3,(G-2)/3)}if(e){C+=3,G-=3,E=M,_=R;const x=t[1];for(l=0;l<v;l++)E=k.Cartesian3.fromArray(x,3*(f-l-1),E),_=k.Cartesian3.fromArray(x,3*l,_),N.CorridorGeometryLibrary.addAttribute(y,E,void 0,G),N.CorridorGeometryLibrary.addAttribute(y,_,C),A=C/3,b=A-1,m=(G-2)/3,g=m+1,T[P++]=g,T[P++]=m,T[P++]=b,T[P++]=A,C+=3,G-=3;o.push(C/3)}else o.push(C/3,(G-2)/3);return T[P++]=C/3,T[P++]=(G-2)/3,i.position=new I.GeometryAttribute({componentDatatype:V.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:y}),{attributes:i,indices:T,wallIndices:o}}function f(e){var t=(e=O.defaultValue(e,O.defaultValue.EMPTY_OBJECT)).positions,i=e.width,r=O.defaultValue(e.height,0),o=O.defaultValue(e.extrudedHeight,r);this._positions=t,this._ellipsoid=k.Ellipsoid.clone(O.defaultValue(e.ellipsoid,k.Ellipsoid.WGS84)),this._width=i,this._height=Math.max(r,o),this._extrudedHeight=Math.min(r,o),this._cornerType=O.defaultValue(e.cornerType,H.CornerType.ROUNDED),this._granularity=O.defaultValue(e.granularity,V.CesiumMath.RADIANS_PER_DEGREE),this._offsetAttribute=e.offsetAttribute,this._workerName="createCorridorOutlineGeometry",this.packedLength=1+t.length*k.Cartesian3.packedLength+k.Ellipsoid.packedLength+6}f.pack=function(e,t,i){i=O.defaultValue(i,0);var r=e._positions,o=r.length;t[i++]=o;for(let e=0;e<o;++e,i+=k.Cartesian3.packedLength)k.Cartesian3.pack(r[e],t,i);return k.Ellipsoid.pack(e._ellipsoid,t,i),i+=k.Ellipsoid.packedLength,t[i++]=e._width,t[i++]=e._height,t[i++]=e._extrudedHeight,t[i++]=e._cornerType,t[i++]=e._granularity,t[i]=O.defaultValue(e._offsetAttribute,-1),t};const h=k.Ellipsoid.clone(k.Ellipsoid.UNIT_SPHERE),y={positions:void 0,ellipsoid:h,width:void 0,height:void 0,extrudedHeight:void 0,cornerType:void 0,granularity:void 0,offsetAttribute:void 0};return f.unpack=function(t,i,e){i=O.defaultValue(i,0);const r=t[i++],o=new Array(r);for(let e=0;e<r;++e,i+=k.Cartesian3.packedLength)o[e]=k.Cartesian3.unpack(t,i);var n=k.Ellipsoid.unpack(t,i,h);i+=k.Ellipsoid.packedLength;var a=t[i++],s=t[i++],l=t[i++],d=t[i++],u=t[i++],p=t[i];return O.defined(e)?(e._positions=o,e._ellipsoid=k.Ellipsoid.clone(n,e._ellipsoid),e._width=a,e._height=s,e._extrudedHeight=l,e._cornerType=d,e._granularity=u,e._offsetAttribute=-1===p?void 0:p,e):(y.positions=o,y.width=a,y.height=s,y.extrudedHeight=l,y.cornerType=d,y.granularity=u,y.offsetAttribute=-1===p?void 0:p,new f(y))},f.createGeometry=function(t){var i=t._positions,r=t._width,o=t._ellipsoid,i=function(t,i){for(let e=0;e<t.length;e++)t[e]=i.scaleToGeodeticSurface(t[e],t[e]);return t}(i,o),i=d.arrayRemoveDuplicates(i,k.Cartesian3.equalsEpsilon);if(!(i.length<2||r<=0)){const n=t._height,a=t._extrudedHeight,s=!V.CesiumMath.equalsEpsilon(n,a,0,V.CesiumMath.EPSILON2),l={ellipsoid:o,positions:i,width:r,cornerType:t._cornerType,granularity:t._granularity,saveAttributes:!1};let e;if(s)l.height=n,l.extrudedHeight=a,l.offsetAttribute=t._offsetAttribute,e=function(t){const e=t.ellipsoid,i=_(N.CorridorGeometryLibrary.computePositions(t),t.cornerType),r=i.wallIndices,o=t.height,n=t.extrudedHeight,a=i.attributes,s=i.indices;let l=a.position.values,d=l.length,u=new Float64Array(d);u.set(l);const p=new Float64Array(2*d);if(l=A.PolygonPipeline.scaleToGeodeticHeight(l,o,e),u=A.PolygonPipeline.scaleToGeodeticHeight(u,n,e),p.set(l),p.set(u,d),a.position.values=p,d/=3,O.defined(t.offsetAttribute)){let e=new Uint8Array(2*d);if(t.offsetAttribute===m.GeometryOffsetAttribute.TOP)e=m.arrayFill(e,1,0,d);else{const i=t.offsetAttribute===m.GeometryOffsetAttribute.NONE?0:1;e=m.arrayFill(e,i)}a.applyOffset=new I.GeometryAttribute({componentDatatype:V.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:e})}let c;const f=s.length,h=B.IndexDatatype.createTypedArray(p.length/3,2*(f+r.length));h.set(s);let y,g,b=f;for(c=0;c<f;c+=2){const m=s[c],t=s[c+1];h[b++]=m+d,h[b++]=t+d}for(c=0;c<r.length;c++)g=(y=r[c])+d,h[b++]=y,h[b++]=g;return{attributes:a,indices:h}}(l);else if(e=_(N.CorridorGeometryLibrary.computePositions(l),l.cornerType),e.attributes.position.values=A.PolygonPipeline.scaleToGeodeticHeight(e.attributes.position.values,n,o),O.defined(t._offsetAttribute)){const d=e.attributes.position.values.length,u=new Uint8Array(d/3),k=t._offsetAttribute===m.GeometryOffsetAttribute.NONE?0:1;m.arrayFill(u,k),e.attributes.applyOffset=new I.GeometryAttribute({componentDatatype:V.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:u})}r=e.attributes,o=u.BoundingSphere.fromVertices(r.position.values,void 0,3);return new I.Geometry({attributes:r,indices:e.indices,primitiveType:I.PrimitiveType.LINES,boundingSphere:o,offsetAttribute:t._offsetAttribute})}},function(e,t){return(e=O.defined(t)?f.unpack(e,t):e)._ellipsoid=k.Ellipsoid.clone(e._ellipsoid),f.createGeometry(e)}});