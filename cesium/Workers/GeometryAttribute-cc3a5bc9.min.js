define(["exports","./Matrix2-37e55508","./RuntimeError-8952249c","./defaultValue-81eec7ed","./WebGLConstants-508b9636","./Transforms-dca21951"],function(t,A,e,n,a,P){"use strict";var r=Object.freeze({NONE:0,TRIANGLES:1,LINES:2,POLYLINES:3});const i={POINTS:a.WebGLConstants.POINTS,LINES:a.WebGLConstants.LINES,LINE_LOOP:a.WebGLConstants.LINE_LOOP,LINE_STRIP:a.WebGLConstants.LINE_STRIP,TRIANGLES:a.WebGLConstants.TRIANGLES,TRIANGLE_STRIP:a.WebGLConstants.TRIANGLE_STRIP,TRIANGLE_FAN:a.WebGLConstants.TRIANGLE_FAN,validate:function(t){return t===i.POINTS||t===i.LINES||t===i.LINE_LOOP||t===i.LINE_STRIP||t===i.TRIANGLES||t===i.TRIANGLE_STRIP||t===i.TRIANGLE_FAN}};var o=Object.freeze(i);function s(t){t=n.defaultValue(t,n.defaultValue.EMPTY_OBJECT),this.attributes=t.attributes,this.indices=t.indices,this.primitiveType=n.defaultValue(t.primitiveType,o.TRIANGLES),this.boundingSphere=t.boundingSphere,this.geometryType=n.defaultValue(t.geometryType,r.NONE),this.boundingSphereCV=t.boundingSphereCV,this.offsetAttribute=t.offsetAttribute}s.computeNumberOfVertices=function(t){let e=-1;for(const a in t.attributes)if(t.attributes.hasOwnProperty(a)&&n.defined(t.attributes[a])&&n.defined(t.attributes[a].values)){const n=t.attributes[a];e=n.values.length/n.componentsPerAttribute}return e};const S=new A.Cartographic,G=new A.Cartesian3,R=new A.Matrix4,w=[new A.Cartographic,new A.Cartographic,new A.Cartographic],O=[new A.Cartesian2,new A.Cartesian2,new A.Cartesian2],_=[new A.Cartesian2,new A.Cartesian2,new A.Cartesian2],g=new A.Cartesian3,V=new P.Quaternion,M=new A.Matrix4,v=new A.Matrix2;s._textureCoordinateRotationPoints=function(t,e,a,n){let r;const i=A.Rectangle.center(n,S),o=A.Cartographic.toCartesian(i,a,G),s=P.Transforms.eastNorthUpToFixedFrame(o,a,R),u=A.Matrix4.inverse(s,R),I=O,N=w;N[0].longitude=n.west,N[0].latitude=n.south,N[1].longitude=n.west,N[1].latitude=n.north,N[2].longitude=n.east,N[2].latitude=n.south;let l=g;for(r=0;r<3;r++)A.Cartographic.toCartesian(N[r],a,l),l=A.Matrix4.multiplyByPointAsVector(u,l,l),I[r].x=l.x,I[r].y=l.y;var c=P.Quaternion.fromAxisAngle(A.Cartesian3.UNIT_Z,-e,V),T=A.Matrix3.fromQuaternion(c,M),m=t.length;let p=Number.POSITIVE_INFINITY,y=Number.POSITIVE_INFINITY,E=Number.NEGATIVE_INFINITY,f=Number.NEGATIVE_INFINITY;for(r=0;r<m;r++)l=A.Matrix4.multiplyByPointAsVector(u,t[r],l),l=A.Matrix3.multiplyByVector(T,l,l),p=Math.min(p,l.x),y=Math.min(y,l.y),E=Math.max(E,l.x),f=Math.max(f,l.y);const L=A.Matrix2.fromRotation(e,v),b=_;b[0].x=p,b[0].y=y,b[1].x=p,b[1].y=f,b[2].x=E,b[2].y=y;var C=I[0],h=I[2].x-C.x,d=I[1].y-C.y;for(r=0;r<3;r++){const t=b[r];A.Matrix2.multiplyByVector(L,t,t),t.x=(t.x-C.x)/h,t.y=(t.y-C.y)/d}var x=b[0],n=b[1],c=b[2],e=new Array(6);return A.Cartesian2.pack(x,e),A.Cartesian2.pack(n,e,2),A.Cartesian2.pack(c,e,4),e},t.Geometry=s,t.GeometryAttribute=function(t){t=n.defaultValue(t,n.defaultValue.EMPTY_OBJECT),this.componentDatatype=t.componentDatatype,this.componentsPerAttribute=t.componentsPerAttribute,this.normalize=n.defaultValue(t.normalize,!1),this.values=t.values},t.GeometryType=r,t.PrimitiveType=o});