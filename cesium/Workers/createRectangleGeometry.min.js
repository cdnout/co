define(["./defaultValue-81eec7ed","./Matrix2-37e55508","./GeometryOffsetAttribute-8c5e10db","./Transforms-dca21951","./RuntimeError-8952249c","./ComponentDatatype-a15c9a19","./GeometryAttribute-cc3a5bc9","./GeometryAttributes-32b29525","./GeometryInstance-13e4ff38","./GeometryPipeline-20022973","./IndexDatatype-f1dcdf35","./PolygonPipeline-b6cd7820","./RectangleGeometryLibrary-97b50beb","./VertexFormat-a0b706b0","./_commonjsHelpers-3aae1032-26891ab7","./combine-3c023bda","./WebGLConstants-508b9636","./AttributeCompression-27507afe","./EncodedCartesian3-96fdc0ef","./IntersectionTests-ee135b8e","./Plane-6ee42cab","./EllipsoidRhumbLine-125a8b72"],function(Z,K,$,d,t,tt,et,n,at,nt,rt,ot,G,it,e,a,r,o,i,s,l,u){"use strict";const st=new K.Cartesian3,lt=new K.Cartesian3,ut=new K.Cartesian3,ct=new K.Cartesian3,g=new K.Rectangle,P=new K.Cartesian2,y=new d.BoundingSphere,f=new d.BoundingSphere;function mt(t,e){const a=new et.Geometry({attributes:new n.GeometryAttributes,primitiveType:et.PrimitiveType.TRIANGLES});return a.attributes.position=new et.GeometryAttribute({componentDatatype:tt.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:e.positions}),t.normal&&(a.attributes.normal=new et.GeometryAttribute({componentDatatype:tt.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:e.normals})),t.tangent&&(a.attributes.tangent=new et.GeometryAttribute({componentDatatype:tt.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:e.tangents})),t.bitangent&&(a.attributes.bitangent=new et.GeometryAttribute({componentDatatype:tt.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:e.bitangents})),a}const pt=new K.Cartesian3,dt=new K.Cartesian3;function gt(e,a){const n=e._vertexFormat,r=e._ellipsoid,t=a.height,o=a.width,i=a.northCap,s=a.southCap;let l=0,u=t,c=t,m=0;i&&(l=1,--c,m+=1),s&&(--u,--c,m+=1),m+=o*c;const p=n.position?new Float64Array(3*m):void 0,d=n.st?new Float32Array(2*m):void 0;let g=0,y=0;var f=st,h=P;let b=Number.MAX_VALUE,_=Number.MAX_VALUE,A=-Number.MAX_VALUE,x=-Number.MAX_VALUE;for(let e=l;e<u;++e)for(let t=0;t<o;++t)G.RectangleGeometryLibrary.computePosition(a,r,n.st,e,t,f,h),p[g++]=f.x,p[g++]=f.y,p[g++]=f.z,n.st&&(d[y++]=h.x,d[y++]=h.y,b=Math.min(b,h.x),_=Math.min(_,h.y),A=Math.max(A,h.x),x=Math.max(x,h.y));if(i&&(G.RectangleGeometryLibrary.computePosition(a,r,n.st,0,0,f,h),p[g++]=f.x,p[g++]=f.y,p[g++]=f.z,n.st&&(d[y++]=h.x,d[y++]=h.y,b=h.x,_=h.y,A=h.x,x=h.y)),s&&(G.RectangleGeometryLibrary.computePosition(a,r,n.st,t-1,0,f,h),p[g++]=f.x,p[g++]=f.y,p[g]=f.z,n.st&&(d[y++]=h.x,d[y]=h.y,b=Math.min(b,h.x),_=Math.min(_,h.y),A=Math.max(A,h.x),x=Math.max(x,h.y))),n.st&&(b<0||_<0||1<A||1<x))for(let t=0;t<d.length;t+=2)d[t]=(d[t]-b)/(A-b),d[t+1]=(d[t+1]-_)/(x-_);const v=function(e,a,n,r){const o=e.length,i=a.normal?new Float32Array(o):void 0,s=a.tangent?new Float32Array(o):void 0,l=a.bitangent?new Float32Array(o):void 0;let u=0;var c=ct,m=ut;let p=lt;if(a.normal||a.tangent||a.bitangent)for(let t=0;t<o;t+=3){const o=K.Cartesian3.fromArray(e,t,st),d=u+1,g=u+2;p=n.geodeticSurfaceNormal(o,p),(a.tangent||a.bitangent)&&(K.Cartesian3.cross(K.Cartesian3.UNIT_Z,p,m),K.Matrix3.multiplyByVector(r,m,m),K.Cartesian3.normalize(m,m),a.bitangent&&K.Cartesian3.normalize(K.Cartesian3.cross(p,m,c),c)),a.normal&&(i[u]=p.x,i[d]=p.y,i[g]=p.z),a.tangent&&(s[u]=m.x,s[d]=m.y,s[g]=m.z),a.bitangent&&(l[u]=c.x,l[d]=c.y,l[g]=c.z),u+=3}return mt(a,{positions:e,normals:i,tangents:s,bitangents:l})}(p,n,r,a.tangentRotationMatrix);let w=6*(o-1)*(c-1);i&&(w+=3*(o-1)),s&&(w+=3*(o-1));const C=rt.IndexDatatype.createTypedArray(m,w);let R,E=0,F=0;for(R=0;R<c-1;++R){for(let t=0;t<o-1;++t){const e=E,K=e+o,a=K+1,n=e+1;C[F++]=e,C[F++]=K,C[F++]=n,C[F++]=n,C[F++]=K,C[F++]=a,++E}++E}if(i||s){let t=m-1;const K=m-1;let e,a;if(i&&s&&(t=m-2),E=0,i)for(R=0;R<o-1;R++)e=E,a=e+1,C[F++]=t,C[F++]=e,C[F++]=a,++E;if(s)for(E=(c-1)*o,R=0;R<o-1;R++)e=E,a=e+1,C[F++]=e,C[F++]=K,C[F++]=a,++E}return v.indices=C,n.st&&(v.attributes.st=new et.GeometryAttribute({componentDatatype:tt.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:d})),v}function yt(t,e,a,n,r){return t[e++]=n[a],t[e++]=n[a+1],t[e++]=n[a+2],t[e++]=r[a],t[e++]=r[a+1],t[e]=r[a+2],t}function ft(t,e,a,n){return t[e++]=n[a],t[e++]=n[a+1],t[e++]=n[a],t[e]=n[a+1],t}const ht=new it.VertexFormat;function h(t,e){var a=t._shadowVolume,n=t._offsetAttribute,r=t._vertexFormat,o=t._extrudedHeight,i=t._surfaceHeight,s=t._ellipsoid,l=e.height,u=e.width;let c;if(a){const Z=it.VertexFormat.clone(r,ht);Z.normal=!0,t._vertexFormat=Z}const m=gt(t,e);a&&(t._vertexFormat=r);var p=ot.PolygonPipeline.scaleToGeodeticHeight(m.attributes.position.values,i,s,!1);let d=(p=new Float64Array(p)).length;const g=2*d,y=new Float64Array(g);y.set(p);var f=ot.PolygonPipeline.scaleToGeodeticHeight(m.attributes.position.values,o,s);y.set(f,d),m.attributes.position.values=y;const h=r.normal?new Float32Array(g):void 0,b=r.tangent?new Float32Array(g):void 0,_=r.bitangent?new Float32Array(g):void 0,A=r.st?new Float32Array(g/3*2):void 0;let x,v,w;if(r.normal){for(v=m.attributes.normal.values,h.set(v),c=0;c<d;c++)v[c]=-v[c];h.set(v,d),m.attributes.normal.values=h}if(a){v=m.attributes.normal.values,r.normal||(m.attributes.normal=void 0);const Z=new Float32Array(g);for(c=0;c<d;c++)v[c]=-v[c];Z.set(v,d),m.attributes.extrudeDirection=new et.GeometryAttribute({componentDatatype:tt.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:Z})}i=Z.defined(n);if(i){const Z=d/3*2;let t=new Uint8Array(Z);t=n===$.GeometryOffsetAttribute.TOP?$.arrayFill(t,1,0,Z/2):(w=n===$.GeometryOffsetAttribute.NONE?0:1,$.arrayFill(t,w)),m.attributes.applyOffset=new et.GeometryAttribute({componentDatatype:tt.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:t})}if(r.tangent){const Z=m.attributes.tangent.values;for(b.set(Z),c=0;c<d;c++)Z[c]=-Z[c];b.set(Z,d),m.attributes.tangent.values=b}if(r.bitangent){const Z=m.attributes.bitangent.values;_.set(Z),_.set(Z,d),m.attributes.bitangent.values=_}r.st&&(x=m.attributes.st.values,A.set(x),A.set(x,d/3*2),m.attributes.st.values=A);const C=m.indices,R=C.length,E=d/3,F=rt.IndexDatatype.createTypedArray(g/3,2*R);for(F.set(C),c=0;c<R;c+=3)F[c+R]=C[c+2]+E,F[c+1+R]=C[c+1]+E,F[c+2+R]=C[c]+E;m.indices=F;o=e.northCap,e=e.southCap;let G=l,P=2,V=0,L=4,D=4;o&&(--P,--G,V+=1,L-=2,--D),e&&(--P,--G,V+=1,L-=2,--D),V+=P*u+2*G-L;l=2*(V+D);let M=new Float64Array(3*l);const T=a?new Float32Array(3*l):void 0;let O=i?new Uint8Array(l):void 0,N=r.st?new Float32Array(2*l):void 0;var S=n===$.GeometryOffsetAttribute.TOP;i&&!S&&(w=n===$.GeometryOffsetAttribute.ALL?1:0,O=$.arrayFill(O,w));let I=0,k=0,H=0,z=0;var B,U,Y,q,X=u*G;let Q;for(c=0;c<X;c+=u)Q=3*c,M=yt(M,I,Q,p,f),I+=6,r.st&&(N=ft(N,k,2*c,x),k+=4),a&&(H+=3,T[H++]=v[Q],T[H++]=v[Q+1],T[H++]=v[Q+2]),S&&(O[z++]=1,z+=1);if(e){const Z=o?1+X:X;for(Q=3*Z,c=0;c<2;c++)M=yt(M,I,Q,p,f),I+=6,r.st&&(N=ft(N,k,2*Z,x),k+=4),a&&(H+=3,T[H++]=v[Q],T[H++]=v[Q+1],T[H++]=v[Q+2]),S&&(O[z++]=1,z+=1)}else for(c=X-u;c<X;c++)Q=3*c,M=yt(M,I,Q,p,f),I+=6,r.st&&(N=ft(N,k,2*c,x),k+=4),a&&(H+=3,T[H++]=v[Q],T[H++]=v[Q+1],T[H++]=v[Q+2]),S&&(O[z++]=1,z+=1);for(c=X-1;0<c;c-=u)Q=3*c,M=yt(M,I,Q,p,f),I+=6,r.st&&(N=ft(N,k,2*c,x),k+=4),a&&(H+=3,T[H++]=v[Q],T[H++]=v[Q+1],T[H++]=v[Q+2]),S&&(O[z++]=1,z+=1);if(o){const Z=X;for(Q=3*Z,c=0;c<2;c++)M=yt(M,I,Q,p,f),I+=6,r.st&&(N=ft(N,k,2*Z,x),k+=4),a&&(H+=3,T[H++]=v[Q],T[H++]=v[Q+1],T[H++]=v[Q+2]),S&&(O[z++]=1,z+=1)}else for(c=u-1;0<=c;c--)Q=3*c,M=yt(M,I,Q,p,f),I+=6,r.st&&(N=ft(N,k,2*c,x),k+=4),a&&(H+=3,T[H++]=v[Q],T[H++]=v[Q+1],T[H++]=v[Q+2]),S&&(O[z++]=1,z+=1);let W=function(e,a,n){const r=e.length,o=a.normal?new Float32Array(r):void 0,i=a.tangent?new Float32Array(r):void 0,s=a.bitangent?new Float32Array(r):void 0;let l=0,u=0,c=0,m=!0,p=ct,d=ut,g=lt;if(a.normal||a.tangent||a.bitangent)for(let t=0;t<r;t+=6){var y=K.Cartesian3.fromArray(e,t,st),f=K.Cartesian3.fromArray(e,(t+6)%r,pt);if(m){const a=K.Cartesian3.fromArray(e,(t+3)%r,dt);K.Cartesian3.subtract(f,y,f),K.Cartesian3.subtract(a,y,a),g=K.Cartesian3.normalize(K.Cartesian3.cross(a,f,g),g),m=!1}K.Cartesian3.equalsEpsilon(f,y,tt.CesiumMath.EPSILON10)&&(m=!0),(a.tangent||a.bitangent)&&(p=n.geodeticSurfaceNormal(y,p),a.tangent&&(d=K.Cartesian3.normalize(K.Cartesian3.cross(p,g,d),d))),a.normal&&(o[l++]=g.x,o[l++]=g.y,o[l++]=g.z,o[l++]=g.x,o[l++]=g.y,o[l++]=g.z),a.tangent&&(i[u++]=d.x,i[u++]=d.y,i[u++]=d.z,i[u++]=d.x,i[u++]=d.y,i[u++]=d.z),a.bitangent&&(s[c++]=p.x,s[c++]=p.y,s[c++]=p.z,s[c++]=p.x,s[c++]=p.y,s[c++]=p.z)}return mt(a,{positions:e,normals:o,tangents:i,bitangents:s})}(M,r,s);r.st&&(W.attributes.st=new et.GeometryAttribute({componentDatatype:tt.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:N})),a&&(W.attributes.extrudeDirection=new et.GeometryAttribute({componentDatatype:tt.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:T})),i&&(W.attributes.applyOffset=new et.GeometryAttribute({componentDatatype:tt.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:O}));const j=rt.IndexDatatype.createTypedArray(l,6*V);d=M.length/3;let J=0;for(c=0;c<d-1;c+=2){q=((B=c)+2)%d;const Z=K.Cartesian3.fromArray(M,3*B,pt),$=K.Cartesian3.fromArray(M,3*q,dt);K.Cartesian3.equalsEpsilon(Z,$,tt.CesiumMath.EPSILON10)||(Y=(2+(U=(B+1)%d))%d,j[J++]=B,j[J++]=U,j[J++]=q,j[J++]=q,j[J++]=U,j[J++]=Y)}return W.indices=j,W=nt.GeometryPipeline.combineInstances([new at.GeometryInstance({geometry:m}),new at.GeometryInstance({geometry:W})]),W[0]}const c=[new K.Cartesian3,new K.Cartesian3,new K.Cartesian3,new K.Cartesian3],b=new K.Cartographic,_=new K.Cartographic;function p(t,e,a,n,r){if(0===a)return K.Rectangle.clone(t,r);var o=G.RectangleGeometryLibrary.computeOptions(t,e,a,0,g,b),t=o.height,e=o.width,a=c;return G.RectangleGeometryLibrary.computePosition(o,n,!1,0,0,a[0]),G.RectangleGeometryLibrary.computePosition(o,n,!1,0,e-1,a[1]),G.RectangleGeometryLibrary.computePosition(o,n,!1,t-1,0,a[2]),G.RectangleGeometryLibrary.computePosition(o,n,!1,t-1,e-1,a[3]),K.Rectangle.fromCartesianArray(a,n,r)}function A(t){var e=(t=Z.defaultValue(t,Z.defaultValue.EMPTY_OBJECT)).rectangle,a=Z.defaultValue(t.height,0),n=Z.defaultValue(t.extrudedHeight,a);this._rectangle=K.Rectangle.clone(e),this._granularity=Z.defaultValue(t.granularity,tt.CesiumMath.RADIANS_PER_DEGREE),this._ellipsoid=K.Ellipsoid.clone(Z.defaultValue(t.ellipsoid,K.Ellipsoid.WGS84)),this._surfaceHeight=Math.max(a,n),this._rotation=Z.defaultValue(t.rotation,0),this._stRotation=Z.defaultValue(t.stRotation,0),this._vertexFormat=it.VertexFormat.clone(Z.defaultValue(t.vertexFormat,it.VertexFormat.DEFAULT)),this._extrudedHeight=Math.min(a,n),this._shadowVolume=Z.defaultValue(t.shadowVolume,!1),this._workerName="createRectangleGeometry",this._offsetAttribute=t.offsetAttribute,this._rotatedRectangle=void 0,this._textureCoordinateRotationPoints=void 0}A.packedLength=K.Rectangle.packedLength+K.Ellipsoid.packedLength+it.VertexFormat.packedLength+7,A.pack=function(t,e,a){return a=Z.defaultValue(a,0),K.Rectangle.pack(t._rectangle,e,a),a+=K.Rectangle.packedLength,K.Ellipsoid.pack(t._ellipsoid,e,a),a+=K.Ellipsoid.packedLength,it.VertexFormat.pack(t._vertexFormat,e,a),a+=it.VertexFormat.packedLength,e[a++]=t._granularity,e[a++]=t._surfaceHeight,e[a++]=t._rotation,e[a++]=t._stRotation,e[a++]=t._extrudedHeight,e[a++]=t._shadowVolume?1:0,e[a]=Z.defaultValue(t._offsetAttribute,-1),e};const x=new K.Rectangle,v=K.Ellipsoid.clone(K.Ellipsoid.UNIT_SPHERE),w={rectangle:x,ellipsoid:v,vertexFormat:ht,granularity:void 0,height:void 0,rotation:void 0,stRotation:void 0,extrudedHeight:void 0,shadowVolume:void 0,offsetAttribute:void 0};A.unpack=function(t,e,a){e=Z.defaultValue(e,0);var n=K.Rectangle.unpack(t,e,x);e+=K.Rectangle.packedLength;var r=K.Ellipsoid.unpack(t,e,v);e+=K.Ellipsoid.packedLength;var o=it.VertexFormat.unpack(t,e,ht);e+=it.VertexFormat.packedLength;var i=t[e++],s=t[e++],l=t[e++],u=t[e++],c=t[e++],m=1===t[e++],e=t[e];return Z.defined(a)?(a._rectangle=K.Rectangle.clone(n,a._rectangle),a._ellipsoid=K.Ellipsoid.clone(r,a._ellipsoid),a._vertexFormat=it.VertexFormat.clone(o,a._vertexFormat),a._granularity=i,a._surfaceHeight=s,a._rotation=l,a._stRotation=u,a._extrudedHeight=c,a._shadowVolume=m,a._offsetAttribute=-1===e?void 0:e,a):(w.granularity=i,w.height=s,w.rotation=l,w.stRotation=u,w.extrudedHeight=c,w.shadowVolume=m,w.offsetAttribute=-1===e?void 0:e,new A(w))},A.computeRectangle=function(t,e){var a=(t=Z.defaultValue(t,Z.defaultValue.EMPTY_OBJECT)).rectangle,n=Z.defaultValue(t.granularity,tt.CesiumMath.RADIANS_PER_DEGREE),r=Z.defaultValue(t.ellipsoid,K.Ellipsoid.WGS84);return p(a,n,Z.defaultValue(t.rotation,0),r,e)};const C=new K.Matrix3,R=new d.Quaternion,E=new K.Cartographic;A.createGeometry=function(n){if(!tt.CesiumMath.equalsEpsilon(n._rectangle.north,n._rectangle.south,tt.CesiumMath.EPSILON10)&&!tt.CesiumMath.equalsEpsilon(n._rectangle.east,n._rectangle.west,tt.CesiumMath.EPSILON10)){let t=n._rectangle;const s=n._ellipsoid,l=n._rotation,u=n._stRotation,c=n._vertexFormat,m=G.RectangleGeometryLibrary.computeOptions(t,n._granularity,l,u,g,b,_),p=C;if(0!==u||0!==l){const Z=K.Rectangle.center(t,E),$=s.geodeticSurfaceNormalCartographic(Z,pt);d.Quaternion.fromAxisAngle($,-u,R),K.Matrix3.fromQuaternion(R,p)}else K.Matrix3.clone(K.Matrix3.IDENTITY,p);var r=n._surfaceHeight,o=n._extrudedHeight,i=!tt.CesiumMath.equalsEpsilon(r,o,0,tt.CesiumMath.EPSILON2);let e,a;if(m.lonScalar=1/n._rectangle.width,m.latScalar=1/n._rectangle.height,m.tangentRotationMatrix=p,t=n._rectangle,i){e=h(n,m);const Z=d.BoundingSphere.fromRectangle3D(t,s,r,f),K=d.BoundingSphere.fromRectangle3D(t,s,o,y);a=d.BoundingSphere.union(Z,K)}else{if(e=gt(n,m),e.attributes.position.values=ot.PolygonPipeline.scaleToGeodeticHeight(e.attributes.position.values,r,s,!1),Z.defined(n._offsetAttribute)){const Z=e.attributes.position.values.length,K=new Uint8Array(Z/3),d=n._offsetAttribute===$.GeometryOffsetAttribute.NONE?0:1;$.arrayFill(K,d),e.attributes.applyOffset=new et.GeometryAttribute({componentDatatype:tt.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:K})}a=d.BoundingSphere.fromRectangle3D(t,s,r)}return c.position||delete e.attributes.position,new et.Geometry({attributes:e.attributes,indices:e.indices,primitiveType:e.primitiveType,boundingSphere:a,offsetAttribute:n._offsetAttribute})}},A.createShadowVolume=function(t,e,a){var n=t._granularity,r=t._ellipsoid,e=e(n,r),a=a(n,r);return new A({rectangle:t._rectangle,rotation:t._rotation,ellipsoid:r,stRotation:t._stRotation,granularity:n,extrudedHeight:a,height:e,vertexFormat:it.VertexFormat.POSITION_ONLY,shadowVolume:!0})};const F=new K.Rectangle,V=[new K.Cartesian2,new K.Cartesian2,new K.Cartesian2],L=new K.Matrix2,D=new K.Cartographic;return Object.defineProperties(A.prototype,{rectangle:{get:function(){return Z.defined(this._rotatedRectangle)||(this._rotatedRectangle=p(this._rectangle,this._granularity,this._rotation,this._ellipsoid)),this._rotatedRectangle}},textureCoordinateRotationPoints:{get:function(){return Z.defined(this._textureCoordinateRotationPoints)||(this._textureCoordinateRotationPoints=function(t){if(0===t._stRotation)return[0,0,0,1,1,0];const e=K.Rectangle.clone(t._rectangle,F),a=t._granularity,n=t._ellipsoid,r=p(e,a,t._rotation-t._stRotation,n,F),o=V;o[0].x=r.west,o[0].y=r.south,o[1].x=r.west,o[1].y=r.north,o[2].x=r.east,o[2].y=r.south;var i=t.rectangle,s=K.Matrix2.fromRotation(t._stRotation,L),l=K.Rectangle.center(i,D);for(let t=0;t<3;++t){const e=o[t];e.x-=l.longitude,e.y-=l.latitude,K.Matrix2.multiplyByVector(s,e,e),e.x+=l.longitude,e.y+=l.latitude,e.x=(e.x-i.west)/i.width,e.y=(e.y-i.south)/i.height}var u=o[0],c=o[1],m=o[2],t=new Array(6);return K.Cartesian2.pack(u,t),K.Cartesian2.pack(c,t,2),K.Cartesian2.pack(m,t,4),t}(this)),this._textureCoordinateRotationPoints}}}),function(t,e){return(t=Z.defined(e)?A.unpack(t,e):t)._ellipsoid=K.Ellipsoid.clone(t._ellipsoid),t._rectangle=K.Rectangle.clone(t._rectangle),A.createGeometry(t)}});