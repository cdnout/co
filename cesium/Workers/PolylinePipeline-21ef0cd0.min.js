define(["exports","./Matrix2-37e55508","./defaultValue-81eec7ed","./RuntimeError-8952249c","./EllipsoidGeodesic-cc3bace8","./EllipsoidRhumbLine-125a8b72","./IntersectionTests-ee135b8e","./ComponentDatatype-a15c9a19","./Plane-6ee42cab"],function(e,m,w,a,t,P,f,T,g){"use strict";const y={numberOfPoints:function(e,a,t){a=m.Cartesian3.distance(e,a);return Math.ceil(a/t)},numberOfPointsRhumbLine:function(e,a,t){a=Math.pow(e.longitude-a.longitude,2)+Math.pow(e.latitude-a.latitude,2);return Math.max(1,Math.ceil(Math.sqrt(a/(t*t))))}},i=new m.Cartographic;y.extractHeights=function(a,t){const n=a.length,r=new Array(n);for(let e=0;e<n;e++){const n=a[e];r[e]=t.cartesianToCartographic(n,i).height}return r};const C=new m.Matrix4,p=new m.Cartesian3,d=new m.Cartesian3,A=new g.Plane(m.Cartesian3.UNIT_X,0),E=new m.Cartesian3,b=new g.Plane(m.Cartesian3.UNIT_X,0),R=new m.Cartesian3,v=new m.Cartesian3,M=[];function S(e,a,t){const n=M;let r;if(n.length=e,a===t){for(r=0;r<e;r++)n[r]=a;return n}var i=(t-a)/e;for(r=0;r<e;r++){const e=a+r*i;n[r]=e}return n}const D=new m.Cartographic,x=new m.Cartographic,N=new m.Cartesian3,G=new m.Cartesian3,I=new m.Cartesian3,V=new t.EllipsoidGeodesic;let k=new P.EllipsoidRhumbLine;y.wrapLongitude=function(n,e){const r=[],i=[];if(w.defined(n)&&0<n.length){e=w.defaultValue(e,m.Matrix4.IDENTITY);var o=m.Matrix4.inverseTransformation(e,C),e=m.Matrix4.multiplyByPoint(o,m.Cartesian3.ZERO,p),s=m.Cartesian3.normalize(m.Matrix4.multiplyByPointAsVector(o,m.Cartesian3.UNIT_Y,d),d),c=g.Plane.fromPointNormal(e,s,A),o=m.Cartesian3.normalize(m.Matrix4.multiplyByPointAsVector(o,m.Cartesian3.UNIT_X,E),E),l=g.Plane.fromPointNormal(e,o,b);let a=1;r.push(m.Cartesian3.clone(n[0]));let t=r[0];var u=n.length;for(let e=1;e<u;++e){var h=n[e];if(g.Plane.getPointDistance(l,t)<0||g.Plane.getPointDistance(l,h)<0){const n=f.IntersectionTests.lineSegmentPlane(t,h,c,R);if(w.defined(n)){const w=m.Cartesian3.multiplyByScalar(s,5e-9,v);g.Plane.getPointDistance(c,t)<0&&m.Cartesian3.negate(w,w),r.push(m.Cartesian3.add(n,w,new m.Cartesian3)),i.push(a+1),m.Cartesian3.negate(w,w),r.push(m.Cartesian3.add(n,w,new m.Cartesian3)),a=1}}r.push(m.Cartesian3.clone(n[e])),a++,t=h}i.push(a)}return{positions:r,lengths:i}},y.generateArc=function(e){const a=(e=!w.defined(e)?{}:e).positions,t=a.length,n=w.defaultValue(e.ellipsoid,m.Ellipsoid.WGS84);let r=w.defaultValue(e.height,0);var i=Array.isArray(r);if(t<1)return[];if(1===t){const C=n.scaleToGeodeticSurface(a[0],G);if(r=i?r[0]:r,0!==r){const w=n.geodeticSurfaceNormal(C,N);m.Cartesian3.multiplyByScalar(w,r,w),m.Cartesian3.add(C,w,C)}return[C.x,C.y,C.z]}let o=e.minDistance;if(!w.defined(o)){const m=w.defaultValue(e.granularity,T.CesiumMath.RADIANS_PER_DEGREE);o=T.CesiumMath.chordLength(m,n.maximumRadius)}let s,c=0;for(s=0;s<t-1;s++)c+=y.numberOfPoints(a[s],a[s+1],o);var l=3*(c+1),u=new Array(l);let h=0;for(s=0;s<t-1;s++)h=function(e,a,t,n,r,i,o,s){const c=n.scaleToGeodeticSurface(e,G),l=n.scaleToGeodeticSurface(a,I),u=y.numberOfPoints(e,a,t),h=n.cartesianToCartographic(c,D),f=n.cartesianToCartographic(l,x),g=S(u,r,i);V.setEndPoints(h,f);var C=V.surfaceDistance/u;let p=s;h.height=r;var d=n.cartographicToCartesian(h,N);m.Cartesian3.pack(d,o,p),p+=3;for(let e=1;e<u;e++){const a=V.interpolateUsingSurfaceDistance(e*C,x);a.height=g[e],d=n.cartographicToCartesian(a,N),m.Cartesian3.pack(d,o,p),p+=3}return p}(a[s],a[s+1],o,n,i?r[s]:r,i?r[s+1]:r,u,h);M.length=0;const f=a[t-1],g=n.cartesianToCartographic(f,D);g.height=i?r[t-1]:r;e=n.cartographicToCartesian(g,N);return m.Cartesian3.pack(e,u,l-3),u};const L=new m.Cartographic,_=new m.Cartographic;y.generateRhumbArc=function(e){const a=(e=!w.defined(e)?{}:e).positions,t=a.length,n=w.defaultValue(e.ellipsoid,m.Ellipsoid.WGS84);let r=w.defaultValue(e.height,0);var i=Array.isArray(r);if(t<1)return[];if(1===t){const d=n.scaleToGeodeticSurface(a[0],G);if(r=i?r[0]:r,0!==r){const w=n.geodeticSurfaceNormal(d,N);m.Cartesian3.multiplyByScalar(w,r,w),m.Cartesian3.add(d,w,d)}return[d.x,d.y,d.z]}var o=w.defaultValue(e.granularity,T.CesiumMath.RADIANS_PER_DEGREE);let s,c,l=0,u=n.cartesianToCartographic(a[0],L);for(s=0;s<t-1;s++)c=n.cartesianToCartographic(a[s+1],_),l+=y.numberOfPointsRhumbLine(u,c,o),u=m.Cartographic.clone(c,L);var h=3*(l+1),f=new Array(h);let g=0;for(s=0;s<t-1;s++)g=function(e,a,t,n,r,i,o,s){const c=n.cartesianToCartographic(e,D),l=n.cartesianToCartographic(a,x),u=y.numberOfPointsRhumbLine(c,l,t);c.height=0,l.height=0;var h=S(u,r,i);k.ellipsoid.equals(n)||(k=new P.EllipsoidRhumbLine(void 0,void 0,n)),k.setEndPoints(c,l);var f=k.surfaceDistance/u;let g=s;c.height=r;var C=n.cartographicToCartesian(c,N);m.Cartesian3.pack(C,o,g),g+=3;for(let e=1;e<u;e++){const a=k.interpolateUsingSurfaceDistance(e*f,x);a.height=h[e],C=n.cartographicToCartesian(a,N),m.Cartesian3.pack(C,o,g),g+=3}return g}(a[s],a[s+1],o,n,i?r[s]:r,i?r[s+1]:r,f,g);M.length=0;const C=a[t-1],p=n.cartesianToCartographic(C,D);p.height=i?r[t-1]:r;e=n.cartographicToCartesian(p,N);return m.Cartesian3.pack(e,f,h-3),f},y.generateCartesianArc=function(e){const a=y.generateArc(e),t=a.length/3,n=new Array(t);for(let e=0;e<t;e++)n[e]=m.Cartesian3.unpack(a,3*e);return n},y.generateCartesianRhumbArc=function(e){const a=y.generateRhumbArc(e),t=a.length/3,n=new Array(t);for(let e=0;e<t;e++)n[e]=m.Cartesian3.unpack(a,3*e);return n},e.PolylinePipeline=y});