define(["./AxisAlignedBoundingBox-0ddf9b79","./Transforms-dca21951","./Matrix2-37e55508","./defaultValue-81eec7ed","./TerrainEncoding-48ceaaca","./ComponentDatatype-a15c9a19","./OrientedBoundingBox-86a6888d","./RuntimeError-8952249c","./WebMercatorProjection-2839e524","./createTaskProcessorWorker","./_commonjsHelpers-3aae1032-26891ab7","./combine-3c023bda","./AttributeCompression-27507afe","./WebGLConstants-508b9636","./EllipsoidTangentPlane-06e319ef","./IntersectionTests-ee135b8e","./Plane-6ee42cab"],function(dt,lt,gt,mt,pt,It,Et,Tt,ft,t,e,n,i,o,a,r,s){"use strict";const Ct=Uint16Array.BYTES_PER_ELEMENT,Mt=Int32Array.BYTES_PER_ELEMENT,xt=Uint32Array.BYTES_PER_ELEMENT,Nt=Float32Array.BYTES_PER_ELEMENT,bt=Float64Array.BYTES_PER_ELEMENT;function St(e,n,i){i=mt.defaultValue(i,It.CesiumMath);var o=e.length;for(let t=0;t<o;++t)if(i.equalsEpsilon(e[t],n,It.CesiumMath.EPSILON12))return t;return-1}const wt=new gt.Cartographic,Bt=new gt.Cartesian3,Pt=new gt.Cartesian3,vt=new gt.Cartesian3,At=new gt.Matrix4;function yt(e,n,i,o,a,r,s,u,c,h,d){var l=u.length;for(let t=0;t<l;++t){var g=u[t],m=g.cartographic,p=g.index,I=e.length,E=m.longitude,T=m.latitude,T=It.CesiumMath.clamp(T,-It.CesiumMath.PI_OVER_TWO,It.CesiumMath.PI_OVER_TWO),m=m.height-s.skirtHeight;s.hMin=Math.min(s.hMin,m),gt.Cartographic.fromRadians(E,T,m,wt),h&&(wt.longitude+=c),h?t===l-1?wt.latitude+=d:0===t&&(wt.latitude-=d):wt.latitude+=c;T=s.ellipsoid.cartographicToCartesian(wt);e.push(T),n.push(m),i.push(gt.Cartesian2.clone(i[p])),0<o.length&&o.push(o[p]),0<a.length&&a.push(a[p]),gt.Matrix4.multiplyByPoint(s.toENU,T,Bt);m=s.minimum,T=s.maximum;gt.Cartesian3.minimumByComponent(Bt,m,m),gt.Cartesian3.maximumByComponent(Bt,T,T);T=s.lastBorderPoint;if(mt.defined(T)){const e=T.index;r.push(e,I-1,I,I,p,e)}s.lastBorderPoint=g}}return t(function(t,e){t.ellipsoid=gt.Ellipsoid.clone(t.ellipsoid),t.rectangle=gt.Rectangle.clone(t.rectangle);var n=function(t,n,i,o,e,a,r,s,u,c,h){let d,l,g,m,p,I;I=mt.defined(o)?(d=o.west,l=o.south,g=o.east,m=o.north,p=o.width,o.height):(d=It.CesiumMath.toRadians(e.west),l=It.CesiumMath.toRadians(e.south),g=It.CesiumMath.toRadians(e.east),m=It.CesiumMath.toRadians(e.north),p=It.CesiumMath.toRadians(o.width),It.CesiumMath.toRadians(o.height));const E=[l,m],T=[d,g],f=lt.Transforms.eastNorthUpToFixedFrame(n,i),C=gt.Matrix4.inverseTransformation(f,At);let M,x;u&&(M=ft.WebMercatorProjection.geodeticLatitudeToMercatorAngle(l),x=1/(ft.WebMercatorProjection.geodeticLatitudeToMercatorAngle(m)-M));const N=1!==a,b=new DataView(t);let S=Number.POSITIVE_INFINITY,w=Number.NEGATIVE_INFINITY;const B=Pt;B.x=Number.POSITIVE_INFINITY,B.y=Number.POSITIVE_INFINITY,B.z=Number.POSITIVE_INFINITY;const P=vt;P.x=Number.NEGATIVE_INFINITY,P.y=Number.NEGATIVE_INFINITY,P.z=Number.NEGATIVE_INFINITY;let v,A,y=0,R=0,_=0;for(A=0;A<4;++A){var W=y;v=b.getUint32(W,!0),W+=xt;const lt=It.CesiumMath.toRadians(180*b.getFloat64(W,!0));W+=bt,-1===St(T,lt)&&T.push(lt);const gt=It.CesiumMath.toRadians(180*b.getFloat64(W,!0));W+=bt,-1===St(E,gt)&&E.push(gt),W+=2*bt;var F=b.getInt32(W,!0);W+=Mt,R+=F,F=b.getInt32(W,!0),_+=3*F,y+=v+xt}const O=[],V=[],Y=new Array(R),H=new Array(R),U=new Array(R),k=u?new Array(R):[],L=N?new Array(R):[],j=new Array(_),D=[],G=[],z=[],q=[];let J=0,K=0;for(y=0,A=0;A<4;++A){v=b.getUint32(y,!0),y+=xt;const dt=y,lt=It.CesiumMath.toRadians(180*b.getFloat64(y,!0));y+=bt;const mt=It.CesiumMath.toRadians(180*b.getFloat64(y,!0));y+=bt;const pt=It.CesiumMath.toRadians(180*b.getFloat64(y,!0)),Et=.5*pt;y+=bt;const ct=It.CesiumMath.toRadians(180*b.getFloat64(y,!0)),n=.5*ct;y+=bt;const o=b.getInt32(y,!0);y+=Mt;const ht=b.getInt32(y,!0);y+=Mt,y+=Mt;const a=new Array(o);for(let e=0;e<o;++e){const Tt=lt+b.getUint8(y++)*pt;wt.longitude=Tt;const o=mt+b.getUint8(y++)*ct;wt.latitude=o;let t=b.getFloat32(y,!0);if(y+=Nt,0!==t&&t<h&&(t*=-Math.pow(2,c)),t*=6371010,wt.height=t,-1!==St(T,Tt)||-1!==St(E,o)){const lt=St(O,wt,gt.Cartographic);if(-1!==lt){a[e]=V[lt];continue}O.push(gt.Cartographic.clone(wt)),V.push(J)}a[e]=J,Math.abs(Tt-d)<Et?D.push({index:J,cartographic:gt.Cartographic.clone(wt)}):Math.abs(Tt-g)<Et?z.push({index:J,cartographic:gt.Cartographic.clone(wt)}):Math.abs(o-l)<n?G.push({index:J,cartographic:gt.Cartographic.clone(wt)}):Math.abs(o-m)<n&&q.push({index:J,cartographic:gt.Cartographic.clone(wt)}),S=Math.min(t,S),w=Math.max(t,w),U[J]=t;const r=i.cartographicToCartesian(wt);if(Y[J]=r,u&&(k[J]=(ft.WebMercatorProjection.geodeticLatitudeToMercatorAngle(o)-M)*x),N){const dt=i.geodeticSurfaceNormal(r);L[J]=dt}gt.Matrix4.multiplyByPoint(C,r,Bt),gt.Cartesian3.minimumByComponent(Bt,B,B),gt.Cartesian3.maximumByComponent(Bt,P,P);var Q=(Tt-d)/(g-d),Q=It.CesiumMath.clamp(Q,0,1),X=(o-l)/(m-l),X=It.CesiumMath.clamp(X,0,1);H[J]=new gt.Cartesian2(Q,X),++J}const r=3*ht;for(let t=0;t<r;++t,++K)j[K]=a[b.getUint16(y,!0)],y+=Ct;if(v!==y-dt)throw new Tt.RuntimeError("Invalid terrain tile.")}Y.length=J,H.length=J,U.length=J,u&&(k.length=J),N&&(L.length=J);var Z=J,e=K,t={hMin:S,lastBorderPoint:void 0,skirtHeight:s,toENU:C,ellipsoid:i,minimum:B,maximum:P};D.sort(function(t,e){return e.cartographic.latitude-t.cartographic.latitude}),G.sort(function(t,e){return t.cartographic.longitude-e.cartographic.longitude}),z.sort(function(t,e){return t.cartographic.latitude-e.cartographic.latitude}),q.sort(function(t,e){return e.cartographic.longitude-t.cartographic.longitude});s=1e-5;if(yt(Y,U,H,k,L,j,t,D,-s*p,!0,-s*I),yt(Y,U,H,k,L,j,t,G,-s*I,!1),yt(Y,U,H,k,L,j,t,z,s*p,!0,s*I),yt(Y,U,H,k,L,j,t,q,s*I,!1),0<D.length&&0<q.length){const dt=D[0].index,lt=Z,gt=q[q.length-1].index,mt=Y.length-1;j.push(gt,mt,lt,lt,dt,gt)}R=Y.length;s=lt.BoundingSphere.fromPoints(Y);let $;mt.defined(o)&&($=Et.OrientedBoundingBox.fromRectangle(o,S,w,i));const tt=new pt.EllipsoidalOccluder(i).computeHorizonCullingPointPossiblyUnderEllipsoid(n,Y,S),et=new dt.AxisAlignedBoundingBox(B,P,n),nt=new pt.TerrainEncoding(n,et,t.hMin,w,f,!1,u,N,a,r),it=new Float32Array(R*nt.stride);let ot=0;for(let t=0;t<R;++t)ot=nt.encode(it,ot,Y[t],H[t],U[t],void 0,k[t],L[t]);const at=D.map(function(t){return t.index}).reverse(),rt=G.map(function(t){return t.index}).reverse(),st=z.map(function(t){return t.index}).reverse(),ut=q.map(function(t){return t.index}).reverse();return rt.unshift(st[st.length-1]),rt.push(at[0]),ut.unshift(at[at.length-1]),ut.push(st[0]),{vertices:it,indices:new Uint16Array(j),maximumHeight:w,minimumHeight:S,encoding:nt,boundingSphere3D:s,orientedBoundingBox:$,occludeePointInScaledSpace:tt,vertexCountWithoutSkirts:Z,indexCountWithoutSkirts:e,westIndicesSouthToNorth:at,southIndicesEastToWest:rt,eastIndicesNorthToSouth:st,northIndicesWestToEast:ut}}(t.buffer,t.relativeToCenter,t.ellipsoid,t.rectangle,t.nativeRectangle,t.exaggeration,t.exaggerationRelativeHeight,t.skirtHeight,t.includeWebMercatorT,t.negativeAltitudeExponentBias,t.negativeElevationThreshold),i=n.vertices;e.push(i.buffer);t=n.indices;return e.push(t.buffer),{vertices:i.buffer,indices:t.buffer,numberOfAttributes:n.encoding.stride,minimumHeight:n.minimumHeight,maximumHeight:n.maximumHeight,boundingSphere3D:n.boundingSphere3D,orientedBoundingBox:n.orientedBoundingBox,occludeePointInScaledSpace:n.occludeePointInScaledSpace,encoding:n.encoding,vertexCountWithoutSkirts:n.vertexCountWithoutSkirts,indexCountWithoutSkirts:n.indexCountWithoutSkirts,westIndicesSouthToNorth:n.westIndicesSouthToNorth,southIndicesEastToWest:n.southIndicesEastToWest,eastIndicesNorthToSouth:n.eastIndicesNorthToSouth,northIndicesWestToEast:n.northIndicesWestToEast}})});