define(["exports","./GeometryOffsetAttribute-8c5e10db","./Transforms-dca21951","./Matrix2-37e55508","./ComponentDatatype-a15c9a19","./defaultValue-81eec7ed","./RuntimeError-8952249c","./GeometryAttribute-cc3a5bc9","./GeometryAttributes-32b29525","./IndexDatatype-f1dcdf35"],function(t,O,D,I,T,z,i,L,R,N){"use strict";const f=new I.Cartesian3(1,1,1),B=Math.cos,S=Math.sin;function d(t){t=z.defaultValue(t,z.defaultValue.EMPTY_OBJECT);var i=z.defaultValue(t.radii,f),e=z.defaultValue(t.innerRadii,i),a=z.defaultValue(t.minimumClock,0),n=z.defaultValue(t.maximumClock,T.CesiumMath.TWO_PI),o=z.defaultValue(t.minimumCone,0),r=z.defaultValue(t.maximumCone,T.CesiumMath.PI),s=Math.round(z.defaultValue(t.stackPartitions,10)),m=Math.round(z.defaultValue(t.slicePartitions,8)),u=Math.round(z.defaultValue(t.subdivisions,128));this._radii=I.Cartesian3.clone(i),this._innerRadii=I.Cartesian3.clone(e),this._minimumClock=a,this._maximumClock=n,this._minimumCone=o,this._maximumCone=r,this._stackPartitions=s,this._slicePartitions=m,this._subdivisions=u,this._offsetAttribute=t.offsetAttribute,this._workerName="createEllipsoidOutlineGeometry"}d.packedLength=2*I.Cartesian3.packedLength+8,d.pack=function(t,i,e){return e=z.defaultValue(e,0),I.Cartesian3.pack(t._radii,i,e),e+=I.Cartesian3.packedLength,I.Cartesian3.pack(t._innerRadii,i,e),e+=I.Cartesian3.packedLength,i[e++]=t._minimumClock,i[e++]=t._maximumClock,i[e++]=t._minimumCone,i[e++]=t._maximumCone,i[e++]=t._stackPartitions,i[e++]=t._slicePartitions,i[e++]=t._subdivisions,i[e]=z.defaultValue(t._offsetAttribute,-1),i};const c=new I.Cartesian3,C=new I.Cartesian3,_={radii:c,innerRadii:C,minimumClock:void 0,maximumClock:void 0,minimumCone:void 0,maximumCone:void 0,stackPartitions:void 0,slicePartitions:void 0,subdivisions:void 0,offsetAttribute:void 0};d.unpack=function(t,i,e){i=z.defaultValue(i,0);var a=I.Cartesian3.unpack(t,i,c);i+=I.Cartesian3.packedLength;var n=I.Cartesian3.unpack(t,i,C);i+=I.Cartesian3.packedLength;var o=t[i++],r=t[i++],s=t[i++],m=t[i++],u=t[i++],f=t[i++],l=t[i++],i=t[i];return z.defined(e)?(e._radii=I.Cartesian3.clone(a,e._radii),e._innerRadii=I.Cartesian3.clone(n,e._innerRadii),e._minimumClock=o,e._maximumClock=r,e._minimumCone=s,e._maximumCone=m,e._stackPartitions=u,e._slicePartitions=f,e._subdivisions=l,e._offsetAttribute=-1===i?void 0:i,e):(_.minimumClock=o,_.maximumClock=r,_.minimumCone=s,_.maximumCone=m,_.stackPartitions=u,_.slicePartitions=f,_.subdivisions=l,_.offsetAttribute=-1===i?void 0:i,new d(_))},d.createGeometry=function(d){var c=d._radii;if(!(c.x<=0||c.y<=0||c.z<=0)){var C=d._innerRadii;if(!(C.x<=0||C.y<=0||C.z<=0)){var _=d._minimumClock,p=d._maximumClock,h=d._minimumCone,y=d._maximumCone,k=d._subdivisions,b=I.Ellipsoid.fromCartesian3(c);let e=d._slicePartitions+1,a=d._stackPartitions+1;e=Math.round(e*Math.abs(p-_)/T.CesiumMath.TWO_PI),a=Math.round(a*Math.abs(y-h)/T.CesiumMath.PI),e<2&&(e=2),a<2&&(a=2);let t=0,n=1;var v=C.x!==c.x||C.y!==c.y||C.z!==c.z;let o=!1,r=!1;v&&(n=2,0<h&&(o=!0,t+=e),y<Math.PI&&(r=!0,t+=e));const x=k*n*(a+e),A=new Float64Array(3*x),P=2*(x+t-(e+a)*n),M=N.IndexDatatype.createTypedArray(x,P);let s,i,m,u,f=0;const w=new Array(a),V=new Array(a);for(s=0;s<a;s++)u=h+s*(y-h)/(a-1),w[s]=S(u),V[s]=B(u);const g=new Array(k),E=new Array(k);for(s=0;s<k;s++)m=_+s*(p-_)/(k-1),g[s]=S(m),E[s]=B(m);for(s=0;s<a;s++)for(i=0;i<k;i++)A[f++]=c.x*w[s]*E[i],A[f++]=c.y*w[s]*g[i],A[f++]=c.z*V[s];if(v)for(s=0;s<a;s++)for(i=0;i<k;i++)A[f++]=C.x*w[s]*E[i],A[f++]=C.y*w[s]*g[i],A[f++]=C.z*V[s];for(w.length=k,V.length=k,s=0;s<k;s++)u=h+s*(y-h)/(k-1),w[s]=S(u),V[s]=B(u);for(g.length=e,E.length=e,s=0;s<e;s++)m=_+s*(p-_)/(e-1),g[s]=S(m),E[s]=B(m);for(s=0;s<k;s++)for(i=0;i<e;i++)A[f++]=c.x*w[s]*E[i],A[f++]=c.y*w[s]*g[i],A[f++]=c.z*V[s];if(v)for(s=0;s<k;s++)for(i=0;i<e;i++)A[f++]=C.x*w[s]*E[i],A[f++]=C.y*w[s]*g[i],A[f++]=C.z*V[s];for(f=0,s=0;s<a*n;s++){const d=s*k;for(i=0;i<k-1;i++)M[f++]=d+i,M[f++]=d+i+1}let l=a*k*n;for(s=0;s<e;s++)for(i=0;i<k-1;i++)M[f++]=l+s+i*e,M[f++]=l+s+(i+1)*e;if(v)for(l=a*k*n+e*k,s=0;s<e;s++)for(i=0;i<k-1;i++)M[f++]=l+s+i*e,M[f++]=l+s+(i+1)*e;if(v){let t=a*k*n,i=t+k*e;if(o)for(s=0;s<e;s++)M[f++]=t+s,M[f++]=i+s;if(r)for(t+=k*e-e,i+=k*e-e,s=0;s<e;s++)M[f++]=t+s,M[f++]=i+s}const G=new R.GeometryAttributes({position:new L.GeometryAttribute({componentDatatype:T.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:A})});if(z.defined(d._offsetAttribute)){const D=A.length,I=new Uint8Array(D/3),z=d._offsetAttribute===O.GeometryOffsetAttribute.NONE?0:1;O.arrayFill(I,z),G.applyOffset=new L.GeometryAttribute({componentDatatype:T.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:I})}return new L.Geometry({attributes:G,indices:M,primitiveType:L.PrimitiveType.LINES,boundingSphere:D.BoundingSphere.fromEllipsoid(b),offsetAttribute:d._offsetAttribute})}}},t.EllipsoidOutlineGeometry=d});