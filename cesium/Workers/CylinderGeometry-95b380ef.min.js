define(["exports","./GeometryOffsetAttribute-8c5e10db","./Transforms-dca21951","./Matrix2-37e55508","./ComponentDatatype-a15c9a19","./CylinderGeometryLibrary-76cda53e","./defaultValue-81eec7ed","./RuntimeError-8952249c","./GeometryAttribute-cc3a5bc9","./GeometryAttributes-32b29525","./IndexDatatype-f1dcdf35","./VertexFormat-a0b706b0"],function(t,F,C,w,G,R,V,e,D,T,O,u){"use strict";const L=new w.Cartesian2,P=new w.Cartesian3,E=new w.Cartesian3,M=new w.Cartesian3,k=new w.Cartesian3;function m(t){var e=(t=V.defaultValue(t,V.defaultValue.EMPTY_OBJECT)).length,a=t.topRadius,n=t.bottomRadius,o=V.defaultValue(t.vertexFormat,u.VertexFormat.DEFAULT),r=V.defaultValue(t.slices,128);this._length=e,this._topRadius=a,this._bottomRadius=n,this._vertexFormat=u.VertexFormat.clone(o),this._slices=r,this._offsetAttribute=t.offsetAttribute,this._workerName="createCylinderGeometry"}m.packedLength=u.VertexFormat.packedLength+5,m.pack=function(t,e,a){return a=V.defaultValue(a,0),u.VertexFormat.pack(t._vertexFormat,e,a),a+=u.VertexFormat.packedLength,e[a++]=t._length,e[a++]=t._topRadius,e[a++]=t._bottomRadius,e[a++]=t._slices,e[a]=V.defaultValue(t._offsetAttribute,-1),e};const c=new u.VertexFormat,l={vertexFormat:c,length:void 0,topRadius:void 0,bottomRadius:void 0,slices:void 0,offsetAttribute:void 0};let a;m.unpack=function(t,e,a){e=V.defaultValue(e,0);var n=u.VertexFormat.unpack(t,e,c);e+=u.VertexFormat.packedLength;var o=t[e++],r=t[e++],i=t[e++],s=t[e++],e=t[e];return V.defined(a)?(a._vertexFormat=u.VertexFormat.clone(n,a._vertexFormat),a._length=o,a._topRadius=r,a._bottomRadius=i,a._slices=s,a._offsetAttribute=-1===e?void 0:e,a):(l.length=o,l.topRadius=r,l.bottomRadius=i,l.slices=s,l.offsetAttribute=-1===e?void 0:e,new m(l))},m.createGeometry=function(i){let s=i._length;const u=i._topRadius,m=i._bottomRadius,c=i._vertexFormat,l=i._slices;if(!(s<=0||u<0||m<0||0===u&&0===m)){const o=l+l,p=l+o,y=o+o,f=R.CylinderGeometryLibrary.computePositions(s,u,m,l,!0),b=c.st?new Float32Array(2*y):void 0,A=c.normal?new Float32Array(3*y):void 0,x=c.tangent?new Float32Array(3*y):void 0,g=c.bitangent?new Float32Array(3*y):void 0;let r;var d=c.normal||c.tangent||c.bitangent;if(d){const i=c.tangent||c.bitangent;let t=0,e=0,a=0;const V=Math.atan2(m-u,s),D=P;D.z=Math.sin(V);const T=Math.cos(V);let n=M,o=E;for(r=0;r<l;r++){const V=r/l*G.CesiumMath.TWO_PI,s=T*Math.cos(V),u=T*Math.sin(V);d&&(D.x=s,D.y=u,i&&(n=w.Cartesian3.normalize(w.Cartesian3.cross(w.Cartesian3.UNIT_Z,D,n),n)),c.normal&&(A[t++]=D.x,A[t++]=D.y,A[t++]=D.z,A[t++]=D.x,A[t++]=D.y,A[t++]=D.z),c.tangent&&(x[e++]=n.x,x[e++]=n.y,x[e++]=n.z,x[e++]=n.x,x[e++]=n.y,x[e++]=n.z),c.bitangent&&(o=w.Cartesian3.normalize(w.Cartesian3.cross(D,n,o),o),g[a++]=o.x,g[a++]=o.y,g[a++]=o.z,g[a++]=o.x,g[a++]=o.y,g[a++]=o.z))}for(r=0;r<l;r++)c.normal&&(A[t++]=0,A[t++]=0,A[t++]=-1),c.tangent&&(x[e++]=1,x[e++]=0,x[e++]=0),c.bitangent&&(g[a++]=0,g[a++]=-1,g[a++]=0);for(r=0;r<l;r++)c.normal&&(A[t++]=0,A[t++]=0,A[t++]=1),c.tangent&&(x[e++]=1,x[e++]=0,x[e++]=0),c.bitangent&&(g[a++]=0,g[a++]=1,g[a++]=0)}const _=12*l-12,v=O.IndexDatatype.createTypedArray(y,_);let t=0,e=0;for(r=0;r<l-1;r++)v[t++]=e,v[t++]=e+2,v[t++]=e+3,v[t++]=e,v[t++]=e+3,v[t++]=e+1,e+=2;for(v[t++]=o-2,v[t++]=0,v[t++]=1,v[t++]=o-2,v[t++]=1,v[t++]=o-1,r=1;r<l-1;r++)v[t++]=o+r+1,v[t++]=o+r,v[t++]=o;for(r=1;r<l-1;r++)v[t++]=p,v[t++]=p+r,v[t++]=p+r+1;let a=0;if(c.st){const i=Math.max(u,m);for(r=0;r<y;r++){const F=w.Cartesian3.fromArray(f,3*r,k);b[a++]=(F.x+i)/(2*i),b[a++]=(F.y+i)/(2*i)}}const h=new T.GeometryAttributes;c.position&&(h.position=new D.GeometryAttribute({componentDatatype:G.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:f})),c.normal&&(h.normal=new D.GeometryAttribute({componentDatatype:G.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:A})),c.tangent&&(h.tangent=new D.GeometryAttribute({componentDatatype:G.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:x})),c.bitangent&&(h.bitangent=new D.GeometryAttribute({componentDatatype:G.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:g})),c.st&&(h.st=new D.GeometryAttribute({componentDatatype:G.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:b})),L.x=.5*s,L.y=Math.max(m,u);var n=new C.BoundingSphere(w.Cartesian3.ZERO,w.Cartesian2.magnitude(L));if(V.defined(i._offsetAttribute)){s=f.length;const C=new Uint8Array(s/3),w=i._offsetAttribute===F.GeometryOffsetAttribute.NONE?0:1;F.arrayFill(C,w),h.applyOffset=new D.GeometryAttribute({componentDatatype:G.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:C})}return new D.Geometry({attributes:h,indices:v,primitiveType:D.PrimitiveType.TRIANGLES,boundingSphere:n,offsetAttribute:i._offsetAttribute})}},m.getUnitCylinder=function(){return V.defined(a)||(a=m.createGeometry(new m({topRadius:1,bottomRadius:1,length:1,vertexFormat:u.VertexFormat.POSITION_ONLY}))),a},t.CylinderGeometry=m});