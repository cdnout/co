define(["./defaultValue-81eec7ed","./Matrix2-37e55508","./ArcType-fc72c06c","./Transforms-dca21951","./Color-1ca27bfa","./ComponentDatatype-a15c9a19","./RuntimeError-8952249c","./GeometryAttribute-cc3a5bc9","./GeometryAttributes-32b29525","./IndexDatatype-f1dcdf35","./PolylinePipeline-21ef0cd0","./_commonjsHelpers-3aae1032-26891ab7","./combine-3c023bda","./WebGLConstants-508b9636","./EllipsoidGeodesic-cc3bace8","./EllipsoidRhumbLine-125a8b72","./IntersectionTests-ee135b8e","./Plane-6ee42cab"],function(g,b,_,P,B,A,e,E,k,v,G,o,t,r,l,a,i,n){"use strict";function d(e){var o=(e=g.defaultValue(e,g.defaultValue.EMPTY_OBJECT)).positions,t=e.colors,r=g.defaultValue(e.colorsPerVertex,!1);this._positions=o,this._colors=t,this._colorsPerVertex=r,this._arcType=g.defaultValue(e.arcType,_.ArcType.GEODESIC),this._granularity=g.defaultValue(e.granularity,A.CesiumMath.RADIANS_PER_DEGREE),this._ellipsoid=g.defaultValue(e.ellipsoid,b.Ellipsoid.WGS84),this._workerName="createSimplePolylineGeometry";o=1+o.length*b.Cartesian3.packedLength;o+=g.defined(t)?1+t.length*B.Color.packedLength:1,this.packedLength=o+b.Ellipsoid.packedLength+3}d.pack=function(e,o,t){let r;t=g.defaultValue(t,0);var l=e._positions;let a=l.length;for(o[t++]=a,r=0;r<a;++r,t+=b.Cartesian3.packedLength)b.Cartesian3.pack(l[r],o,t);var i=e._colors;for(a=g.defined(i)?i.length:0,o[t++]=a,r=0;r<a;++r,t+=B.Color.packedLength)B.Color.pack(i[r],o,t);return b.Ellipsoid.pack(e._ellipsoid,o,t),t+=b.Ellipsoid.packedLength,o[t++]=e._colorsPerVertex?1:0,o[t++]=e._arcType,o[t]=e._granularity,o},d.unpack=function(e,o,t){let r;o=g.defaultValue(o,0);let l=e[o++];const a=new Array(l);for(r=0;r<l;++r,o+=b.Cartesian3.packedLength)a[r]=b.Cartesian3.unpack(e,o);l=e[o++];const i=0<l?new Array(l):void 0;for(r=0;r<l;++r,o+=B.Color.packedLength)i[r]=B.Color.unpack(e,o);var n=b.Ellipsoid.unpack(e,o);o+=b.Ellipsoid.packedLength;var s=1===e[o++],c=e[o++],p=e[o];return g.defined(t)?(t._positions=a,t._colors=i,t._ellipsoid=n,t._colorsPerVertex=s,t._arcType=c,t._granularity=p,t):new d({positions:a,colors:i,ellipsoid:n,colorsPerVertex:s,arcType:c,granularity:p})};const D=new Array(2),L=new Array(2),w={positions:D,height:L,ellipsoid:void 0,minDistance:void 0,granularity:void 0};return d.createGeometry=function(e){var a=e._positions,i=e._colors,o=e._colorsPerVertex,n=e._arcType,s=e._granularity,e=e._ellipsoid,c=A.CesiumMath.chordLength(s,e.maximumRadius),p=g.defined(i)&&!o;let d;var y=a.length;let f,t,u,h,C=0;if(n===_.ArcType.GEODESIC||n===_.ArcType.RHUMB){let t,r,l;l=n===_.ArcType.GEODESIC?(t=A.CesiumMath.chordLength(s,e.maximumRadius),r=G.PolylinePipeline.numberOfPoints,G.PolylinePipeline.generateArc):(t=s,r=G.PolylinePipeline.numberOfPointsRhumbLine,G.PolylinePipeline.generateRhumbArc);const E=G.PolylinePipeline.extractHeights(a,e),k=w;if(n===_.ArcType.GEODESIC?k.minDistance=c:k.granularity=s,k.ellipsoid=e,p){let e=0;for(d=0;d<y-1;d++)e+=r(a[d],a[d+1],t)+1;f=new Float64Array(3*e),u=new Uint8Array(4*e),k.positions=D,k.height=L;let o=0;for(d=0;d<y-1;++d){D[0]=a[d],D[1]=a[d+1],L[0]=E[d],L[1]=E[d+1];const b=l(k);if(g.defined(i)){const g=b.length/3;h=i[d];for(let e=0;e<g;++e)u[o++]=B.Color.floatToByte(h.red),u[o++]=B.Color.floatToByte(h.green),u[o++]=B.Color.floatToByte(h.blue),u[o++]=B.Color.floatToByte(h.alpha)}f.set(b,C),C+=b.length}}else if(k.positions=a,k.height=E,f=new Float64Array(l(k)),g.defined(i)){for(u=new Uint8Array(f.length/3*4),d=0;d<y-1;++d)C=function(e,o,t,r,l,a,i){var n=G.PolylinePipeline.numberOfPoints(e,o,l);let s;var c=t.red,p=t.green,d=t.blue,y=t.alpha,f=r.red,e=r.green,o=r.blue,l=r.alpha;if(B.Color.equals(t,r)){for(s=0;s<n;s++)a[i++]=B.Color.floatToByte(c),a[i++]=B.Color.floatToByte(p),a[i++]=B.Color.floatToByte(d),a[i++]=B.Color.floatToByte(y);return i}var u=(f-c)/n,h=(e-p)/n,C=(o-d)/n,m=(l-y)/n;let T=i;for(s=0;s<n;s++)a[T++]=B.Color.floatToByte(c+s*u),a[T++]=B.Color.floatToByte(p+s*h),a[T++]=B.Color.floatToByte(d+s*C),a[T++]=B.Color.floatToByte(y+s*m);return T}(a[d],a[d+1],i[d],i[d+1],c,u,C);const g=i[y-1];u[C++]=B.Color.floatToByte(g.red),u[C++]=B.Color.floatToByte(g.green),u[C++]=B.Color.floatToByte(g.blue),u[C++]=B.Color.floatToByte(g.alpha)}}else{t=p?2*y-2:y,f=new Float64Array(3*t),u=g.defined(i)?new Uint8Array(4*t):void 0;let e=0,o=0;for(d=0;d<y;++d){const A=a[d];if(p&&0<d&&(b.Cartesian3.pack(A,f,e),e+=3,h=i[d-1],u[o++]=B.Color.floatToByte(h.red),u[o++]=B.Color.floatToByte(h.green),u[o++]=B.Color.floatToByte(h.blue),u[o++]=B.Color.floatToByte(h.alpha)),p&&d===y-1)break;b.Cartesian3.pack(A,f,e),e+=3,g.defined(i)&&(h=i[d],u[o++]=B.Color.floatToByte(h.red),u[o++]=B.Color.floatToByte(h.green),u[o++]=B.Color.floatToByte(h.blue),u[o++]=B.Color.floatToByte(h.alpha))}}const r=new k.GeometryAttributes;r.position=new E.GeometryAttribute({componentDatatype:A.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:f}),g.defined(i)&&(r.color=new E.GeometryAttribute({componentDatatype:A.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:4,values:u,normalize:!0})),t=f.length/3;const l=2*(t-1),m=v.IndexDatatype.createTypedArray(t,l);let T=0;for(d=0;d<t-1;++d)m[T++]=d,m[T++]=d+1;return new E.Geometry({attributes:r,indices:m,primitiveType:E.PrimitiveType.LINES,boundingSphere:P.BoundingSphere.fromPoints(a)})},function(e,o){return(e=g.defined(o)?d.unpack(e,o):e)._ellipsoid=b.Ellipsoid.clone(e._ellipsoid),d.createGeometry(e)}});