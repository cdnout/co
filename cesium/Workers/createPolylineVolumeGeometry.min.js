define(["./defaultValue-81eec7ed","./Matrix2-37e55508","./arrayRemoveDuplicates-dc2f4046","./BoundingRectangle-aeed4004","./Transforms-dca21951","./ComponentDatatype-a15c9a19","./PolylineVolumeGeometryLibrary-996c2dbb","./RuntimeError-8952249c","./GeometryAttribute-cc3a5bc9","./GeometryAttributes-32b29525","./GeometryPipeline-20022973","./IndexDatatype-f1dcdf35","./PolygonPipeline-b6cd7820","./VertexFormat-a0b706b0","./_commonjsHelpers-3aae1032-26891ab7","./combine-3c023bda","./WebGLConstants-508b9636","./EllipsoidTangentPlane-06e319ef","./AxisAlignedBoundingBox-0ddf9b79","./IntersectionTests-ee135b8e","./Plane-6ee42cab","./PolylinePipeline-21ef0cd0","./EllipsoidGeodesic-cc3bace8","./EllipsoidRhumbLine-125a8b72","./AttributeCompression-27507afe","./EncodedCartesian3-96fdc0ef"],function(d,u,o,a,_,E,k,e,V,L,x,C,F,m,t,n,i,r,l,s,p,c,y,g,h,f){"use strict";function b(e){var t=(e=d.defaultValue(e,d.defaultValue.EMPTY_OBJECT)).polylinePositions,n=e.shapePositions;this._positions=t,this._shape=n,this._ellipsoid=u.Ellipsoid.clone(d.defaultValue(e.ellipsoid,u.Ellipsoid.WGS84)),this._cornerType=d.defaultValue(e.cornerType,k.CornerType.ROUNDED),this._vertexFormat=m.VertexFormat.clone(d.defaultValue(e.vertexFormat,m.VertexFormat.DEFAULT)),this._granularity=d.defaultValue(e.granularity,E.CesiumMath.RADIANS_PER_DEGREE),this._workerName="createPolylineVolumeGeometry";t=1+t.length*u.Cartesian3.packedLength;t+=1+n.length*u.Cartesian2.packedLength,this.packedLength=t+u.Ellipsoid.packedLength+m.VertexFormat.packedLength+2}b.pack=function(e,t,n){let i;n=d.defaultValue(n,0);var o=e._positions;let a=o.length;for(t[n++]=a,i=0;i<a;++i,n+=u.Cartesian3.packedLength)u.Cartesian3.pack(o[i],t,n);var r=e._shape;for(a=r.length,t[n++]=a,i=0;i<a;++i,n+=u.Cartesian2.packedLength)u.Cartesian2.pack(r[i],t,n);return u.Ellipsoid.pack(e._ellipsoid,t,n),n+=u.Ellipsoid.packedLength,m.VertexFormat.pack(e._vertexFormat,t,n),n+=m.VertexFormat.packedLength,t[n++]=e._cornerType,t[n]=e._granularity,t};const v=u.Ellipsoid.clone(u.Ellipsoid.UNIT_SPHERE),P=new m.VertexFormat,A={polylinePositions:void 0,shapePositions:void 0,ellipsoid:v,vertexFormat:P,cornerType:void 0,granularity:void 0};b.unpack=function(e,t,n){let i;t=d.defaultValue(t,0);let o=e[t++];const a=new Array(o);for(i=0;i<o;++i,t+=u.Cartesian3.packedLength)a[i]=u.Cartesian3.unpack(e,t);o=e[t++];const r=new Array(o);for(i=0;i<o;++i,t+=u.Cartesian2.packedLength)r[i]=u.Cartesian2.unpack(e,t);var l=u.Ellipsoid.unpack(e,t,v);t+=u.Ellipsoid.packedLength;var s=m.VertexFormat.unpack(e,t,P);t+=m.VertexFormat.packedLength;var p=e[t++],c=e[t];return d.defined(n)?(n._positions=a,n._shape=r,n._ellipsoid=u.Ellipsoid.clone(l,n._ellipsoid),n._vertexFormat=m.VertexFormat.clone(s,n._vertexFormat),n._cornerType=p,n._granularity=c,n):(A.polylinePositions=a,A.shapePositions=r,A.cornerType=p,A.granularity=c,new b(A))};const T=new a.BoundingRectangle;return b.createGeometry=function(e){var t=e._positions,n=o.arrayRemoveDuplicates(t,u.Cartesian3.equalsEpsilon);let i=e._shape;if(i=k.PolylineVolumeGeometryLibrary.removeDuplicatesFromShape(i),!(n.length<2||i.length<3)){F.PolygonPipeline.computeWindingOrder2D(i)===F.WindingOrder.CLOCKWISE&&i.reverse();t=a.BoundingRectangle.fromPoints(i,T);return function(i,o,a,r){const l=new L.GeometryAttributes;r.position&&(l.position=new V.GeometryAttribute({componentDatatype:E.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:i}));const s=o.length,p=i.length/3,c=(p-2*s)/(2*s),e=F.PolygonPipeline.triangulate(o),t=(c-1)*s*6+2*e.length,n=C.IndexDatatype.createTypedArray(p,t);let d,u,m,y,g,h;var f=2*s;let b=0;for(d=0;d<c-1;d++){for(u=0;u<s-1;u++)m=2*u+d*s*2,h=m+f,y=m+1,g=y+f,n[b++]=y,n[b++]=m,n[b++]=g,n[b++]=g,n[b++]=m,n[b++]=h;m=2*s-2+d*s*2,y=m+1,g=y+f,h=m+f,n[b++]=y,n[b++]=m,n[b++]=g,n[b++]=g,n[b++]=m,n[b++]=h}if(r.st||r.tangent||r.bitangent){const i=new Float32Array(2*p),r=1/(c-1),_=1/a.height,k=a.height/2;let e,t,n=0;for(d=0;d<c;d++){for(e=d*r,t=_*(o[0].y+k),i[n++]=e,i[n++]=t,u=1;u<s;u++)t=_*(o[u].y+k),i[n++]=e,i[n++]=t,i[n++]=e,i[n++]=t;t=_*(o[0].y+k),i[n++]=e,i[n++]=t}for(u=0;u<s;u++)e=0,t=_*(o[u].y+k),i[n++]=e,i[n++]=t;for(u=0;u<s;u++)e=(c-1)*r,t=_*(o[u].y+k),i[n++]=e,i[n++]=t;l.st=new V.GeometryAttribute({componentDatatype:E.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:new Float32Array(i)})}var v=p-2*s;for(d=0;d<e.length;d+=3){const i=e[d]+v,o=e[d+1]+v,a=e[d+2]+v;n[b++]=i,n[b++]=o,n[b++]=a,n[b++]=a+s,n[b++]=o+s,n[b++]=i+s}let P=new V.Geometry({attributes:l,indices:n,boundingSphere:_.BoundingSphere.fromVertices(i),primitiveType:V.PrimitiveType.TRIANGLES});if(r.normal&&(P=x.GeometryPipeline.computeNormal(P)),r.tangent||r.bitangent){try{P=x.GeometryPipeline.computeTangentAndBitangent(P)}catch(i){k.oneTimeWarning("polyline-volume-tangent-bitangent","Unable to compute tangents and bitangents for polyline volume geometry")}r.tangent||(P.attributes.tangent=void 0),r.bitangent||(P.attributes.bitangent=void 0),r.st||(P.attributes.st=void 0)}return P}(k.PolylineVolumeGeometryLibrary.computePositions(n,i,t,e,!0),i,t,e._vertexFormat)}},function(e,t){return(e=d.defined(t)?b.unpack(e,t):e)._ellipsoid=u.Ellipsoid.clone(e._ellipsoid),b.createGeometry(e)}});