define(["exports","./AttributeCompression-27507afe","./Matrix2-37e55508","./RuntimeError-8952249c","./defaultValue-81eec7ed","./ComponentDatatype-a15c9a19","./Transforms-dca21951","./EncodedCartesian3-96fdc0ef","./GeometryAttribute-cc3a5bc9","./IndexDatatype-f1dcdf35","./IntersectionTests-ee135b8e","./Plane-6ee42cab"],function(e,v,N,t,L,T,h,c,x,b,P,i){"use strict";const g=new N.Cartesian3,A=new N.Cartesian3,w=new N.Cartesian3,a={calculateACMR:function(e){var n=(e=L.defaultValue(e,L.defaultValue.EMPTY_OBJECT)).indices;let i=e.maximumIndex;var t=L.defaultValue(e.cacheSize,24),r=n.length;if(!L.defined(i)){let e=i=0,t=n[e];for(;e<r;)t>i&&(i=t),++e,t=n[e]}const a=[];for(let e=0;e<i+1;e++)a[e]=0;let s=t+1;for(let e=0;e<r;++e)s-a[n[e]]>t&&(a[n[e]]=s,++s);return(s-t+1)/(r/3)}};a.tipsify=function(e){var t=(e=L.defaultValue(e,L.defaultValue.EMPTY_OBJECT)).indices,n=e.maximumIndex,i=L.defaultValue(e.cacheSize,24);let p;e=t.length;let r=0,a=0,s=t[a];var o,u,l=e;if(L.defined(n))r=n+1;else{for(;a<l;)s>r&&(r=s),++a,s=t[a];if(-1===r)return 0;++r}const c=[];let d;for(d=0;d<r;d++)c[d]={numLiveTriangles:0,timeStamp:0,vertexTriangles:[]};let y=a=0;for(;a<l;)c[t[a]].vertexTriangles.push(y),++c[t[a]].numLiveTriangles,c[t[a+1]].vertexTriangles.push(y),++c[t[a+1]].numLiveTriangles,c[t[a+2]].vertexTriangles.push(y),++c[t[a+2]].numLiveTriangles,++y,a+=3;let f=0,m=i+1;p=1;let C=[];const v=[];let h,b,g=0;const A=[],T=e/3,x=[];for(d=0;d<T;d++)x[d]=!1;for(;-1!==f;){C=[],u=(b=c[f]).vertexTriangles.length;for(let e=0;e<u;++e)if(y=b.vertexTriangles[e],!x[y]){x[y]=!0,a=y+y+y;for(let e=0;e<3;++e)o=t[a],C.push(o),v.push(o),A[g]=o,++g,h=c[o],--h.numLiveTriangles,m-h.timeStamp>i&&(h.timeStamp=m,++m),++a}f=function(e,t,n,i,r,a){let s,o=-1,u=-1,l=0;for(;l<t.length;){const c=t[l];n[c].numLiveTriangles&&(s=0,i-n[c].timeStamp+2*n[c].numLiveTriangles<=e&&(s=i-n[c].timeStamp),(s>u||-1===u)&&(u=s,o=c)),++l}return-1===o?function(e,t,n){for(;1<=t.length;){const i=t[t.length-1];if(t.splice(t.length-1,1),0<e[i].numLiveTriangles)return i}for(;p<n;){if(0<e[p].numLiveTriangles)return++p,p-1;++p}return-1}(n,r,a):o}(i,C,c,m,v,r)}return A};const n={};function s(e,t,n,i,r){e[t++]=n,e[t++]=i,e[t++]=i,e[t++]=r,e[t++]=r,e[t]=n}function p(e){const t={};for(const i in e){var n;e.hasOwnProperty(i)&&L.defined(e[i])&&L.defined(e[i].values)&&(n=e[i],t[i]=new x.GeometryAttribute({componentDatatype:n.componentDatatype,componentsPerAttribute:n.componentsPerAttribute,normalize:n.normalize,values:[]}))}return t}n.toWireframe=function(e){var t=e.indices;if(L.defined(t)){switch(e.primitiveType){case x.PrimitiveType.TRIANGLES:e.indices=function(t){var n=t.length,i=b.IndexDatatype.createTypedArray(n,n/3*6);let r=0;for(let e=0;e<n;e+=3,r+=6)s(i,r,t[e],t[e+1],t[e+2]);return i}(t);break;case x.PrimitiveType.TRIANGLE_STRIP:e.indices=function(n){var i=n.length;if(3<=i){var r=b.IndexDatatype.createTypedArray(i,6*(i-2));s(r,0,n[0],n[1],n[2]);let t=6;for(let e=3;e<i;++e,t+=6)s(r,t,n[e-1],n[e],n[e-2]);return r}return new Uint16Array}(t);break;case x.PrimitiveType.TRIANGLE_FAN:e.indices=function(n){if(0<n.length){var i=n.length-1,r=b.IndexDatatype.createTypedArray(i,6*(i-1)),a=n[0];let t=0;for(let e=1;e<i;++e,t+=6)s(r,t,a,n[e],n[e+1]);return r}return new Uint16Array}(t)}e.primitiveType=x.PrimitiveType.LINES}return e},n.createLineSegmentsForVectors=function(e,t,n){t=L.defaultValue(t,"normal"),n=L.defaultValue(n,1e4);const i=e.attributes.position.values,r=e.attributes[t].values,a=i.length,s=new Float64Array(2*a);let o,u=0;for(let e=0;e<a;e+=3)s[u++]=i[e],s[u++]=i[e+1],s[u++]=i[e+2],s[u++]=i[e]+r[e]*n,s[u++]=i[e+1]+r[e+1]*n,s[u++]=i[e+2]+r[e+2]*n;e=e.boundingSphere;return L.defined(e)&&(o=new h.BoundingSphere(e.center,e.radius+n)),new x.Geometry({attributes:{position:new x.GeometryAttribute({componentDatatype:T.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:s})},primitiveType:x.PrimitiveType.LINES,boundingSphere:o})},n.createAttributeLocations=function(e){const t=["position","positionHigh","positionLow","position3DHigh","position3DLow","position2DHigh","position2DLow","pickColor","normal","st","tangent","bitangent","extrudeDirection","compressedAttributes"],n=e.attributes,i={};let r,a=0;var s=t.length;for(r=0;r<s;++r){const e=t[r];L.defined(n[e])&&(i[e]=a++)}for(const e in n)n.hasOwnProperty(e)&&!L.defined(i[e])&&(i[e]=a++);return i},n.reorderForPreVertexCache=function(r){const a=x.Geometry.computeNumberOfVertices(r),s=r.indices;if(L.defined(s)){const o=new Int32Array(a);for(let e=0;e<a;e++)o[e]=-1;const u=s,l=u.length,x=b.IndexDatatype.createTypedArray(a,l);let e,t=0,n=0,i=0;for(;t<l;)e=o[u[t]],-1!==e?x[n]=e:(e=u[t],o[e]=i,x[n]=i,++i),++t,++n;r.indices=x;const c=r.attributes;for(const r in c)if(c.hasOwnProperty(r)&&L.defined(c[r])&&L.defined(c[r].values)){const s=c[r],L=s.values;let t=0;const p=s.componentsPerAttribute,x=T.ComponentDatatype.createTypedArray(s.componentDatatype,i*p);for(;t<a;){const r=o[t];if(-1!==r)for(let e=0;e<p;e++)x[p*r+e]=L[p*t+e];++t}s.values=x}}return r},n.reorderForPostVertexCache=function(e,n){var i=e.indices;if(e.primitiveType===x.PrimitiveType.TRIANGLES&&L.defined(i)){var r=i.length;let t=0;for(let e=0;e<r;e++)i[e]>t&&(t=i[e]);e.indices=a.tipsify({indices:i,maximumIndex:t,cacheSize:n})}return e},n.fitToUnsignedShortIndices=function(o){const t=[],e=x.Geometry.computeNumberOfVertices(o);if(L.defined(o.indices)&&e>=T.CesiumMath.SIXTY_FOUR_KILOBYTES){let i=[],r=[],a=0,s=p(o.attributes);var u=o.indices,l=u.length;let e;o.primitiveType===x.PrimitiveType.TRIANGLES?e=3:o.primitiveType===x.PrimitiveType.LINES?e=2:o.primitiveType===x.PrimitiveType.POINTS&&(e=1);for(let n=0;n<l;n+=e){for(let t=0;t<e;++t){const T=u[n+t];let e=i[T];L.defined(e)||(e=a++,i[T]=e,function(t,e,n){for(const i in e)if(e.hasOwnProperty(i)&&L.defined(e[i])&&L.defined(e[i].values)){const L=e[i];for(let e=0;e<L.componentsPerAttribute;++e)t[i].values.push(L.values[n*L.componentsPerAttribute+e])}}(s,o.attributes,T)),r.push(e)}a+e>=T.CesiumMath.SIXTY_FOUR_KILOBYTES&&(t.push(new x.Geometry({attributes:s,indices:r,primitiveType:o.primitiveType,boundingSphere:o.boundingSphere,boundingSphereCV:o.boundingSphereCV})),i=[],r=[],a=0,s=p(o.attributes))}0!==r.length&&t.push(new x.Geometry({attributes:s,indices:r,primitiveType:o.primitiveType,boundingSphere:o.boundingSphere,boundingSphereCV:o.boundingSphereCV}))}else t.push(o);return t};const d=new N.Cartesian3,y=new N.Cartographic;n.projectTo2D=function(e,t,n,i,r){const a=e.attributes[t],s=(r=L.defined(r)?r:new h.GeographicProjection).ellipsoid,o=a.values,u=new Float64Array(o.length);let l=0;for(let e=0;e<o.length;e+=3){const t=N.Cartesian3.fromArray(o,e,d),n=s.cartesianToCartographic(t,y),L=r.project(n,d);u[l++]=L.x,u[l++]=L.y,u[l++]=L.z}return e.attributes[n]=a,e.attributes[i]=new x.GeometryAttribute({componentDatatype:T.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:u}),delete e.attributes[t],e};const f={high:0,low:0};n.encodeAttribute=function(e,t,n,i){const r=e.attributes[t],a=r.values,s=a.length,o=new Float32Array(s),u=new Float32Array(s);for(let e=0;e<s;++e)c.EncodedCartesian3.encode(a[e],f),o[e]=f.high,u[e]=f.low;var l=r.componentsPerAttribute;return e.attributes[n]=new x.GeometryAttribute({componentDatatype:T.ComponentDatatype.FLOAT,componentsPerAttribute:l,values:o}),e.attributes[i]=new x.GeometryAttribute({componentDatatype:T.ComponentDatatype.FLOAT,componentsPerAttribute:l,values:u}),delete e.attributes[t],e};let r=new N.Cartesian3;function o(t,e){if(L.defined(e)){const n=e.values,L=n.length;for(let e=0;e<L;e+=3)N.Cartesian3.unpack(n,e,r),N.Matrix4.multiplyByPoint(t,r,r),N.Cartesian3.pack(r,n,e)}}function u(t,e){if(L.defined(e)){const n=e.values,L=n.length;for(let e=0;e<L;e+=3)N.Cartesian3.unpack(n,e,r),N.Matrix3.multiplyByVector(t,r,r),r=N.Cartesian3.normalize(r,r),N.Cartesian3.pack(r,n,e)}}const l=new N.Matrix4,m=new N.Matrix3;n.transformToWorldCoordinates=function(e){var t=e.modelMatrix;if(N.Matrix4.equals(t,N.Matrix4.IDENTITY))return e;var n=e.geometry.attributes;o(t,n.position),o(t,n.prevPosition),o(t,n.nextPosition),(L.defined(n.normal)||L.defined(n.tangent)||L.defined(n.bitangent))&&(N.Matrix4.inverse(t,l),N.Matrix4.transpose(l,l),N.Matrix4.getMatrix3(l,m),u(m,n.normal),u(m,n.tangent),u(m,n.bitangent));n=e.geometry.boundingSphere;return L.defined(n)&&(e.geometry.boundingSphere=h.BoundingSphere.transform(n,t,n)),e.modelMatrix=N.Matrix4.clone(N.Matrix4.IDENTITY),e};const S=new N.Cartesian3;function C(i,r){const a=i.length;let e,s,t,o;i[0].modelMatrix;const n=L.defined(i[0][r].indices),u=i[0][r].primitiveType,l=function(i,r){const a=i.length,e={},s=i[0][r].attributes;let o;for(o in s)if(s.hasOwnProperty(o)&&L.defined(s[o])&&L.defined(s[o].values)){var u=s[o];let t=u.values.length,n=!0;for(let e=1;e<a;++e){const a=i[e][r].attributes[o];if(!L.defined(a)||u.componentDatatype!==a.componentDatatype||u.componentsPerAttribute!==a.componentsPerAttribute||u.normalize!==a.normalize){n=!1;break}t+=a.values.length}n&&(e[o]=new x.GeometryAttribute({componentDatatype:u.componentDatatype,componentsPerAttribute:u.componentsPerAttribute,normalize:u.normalize,values:T.ComponentDatatype.createTypedArray(u.componentDatatype,t)}))}return e}(i,r);let c,p,d,y;for(e in l)if(l.hasOwnProperty(e))for(c=l[e].values,o=0,s=0;s<a;++s)for(p=i[s][r].attributes[e].values,d=p.length,t=0;t<d;++t)c[o++]=p[t];if(n){let e=0;for(s=0;s<a;++s)e+=i[s][r].indices.length;const L=x.Geometry.computeNumberOfVertices(new x.Geometry({attributes:l,primitiveType:x.PrimitiveType.POINTS})),T=b.IndexDatatype.createTypedArray(L,e);let t=0,n=0;for(s=0;s<a;++s){const N=i[s][r].indices,a=N.length;for(o=0;o<a;++o)T[t++]=n+N[o];n+=x.Geometry.computeNumberOfVertices(i[s][r])}y=T}let f,m=new N.Cartesian3,C=0;for(s=0;s<a;++s){if(f=i[s][r].boundingSphere,!L.defined(f)){m=void 0;break}N.Cartesian3.add(f.center,m,m)}if(L.defined(m))for(N.Cartesian3.divideByScalar(m,a,m),s=0;s<a;++s){f=i[s][r].boundingSphere;const a=N.Cartesian3.magnitude(N.Cartesian3.subtract(f.center,m,S))+f.radius;a>C&&(C=a)}return new x.Geometry({attributes:l,indices:y,primitiveType:u,boundingSphere:L.defined(m)?new h.BoundingSphere(m,C):void 0})}n.combineInstances=function(t){const n=[],i=[],r=t.length;for(let e=0;e<r;++e){const r=t[e];L.defined(r.geometry)?n.push(r):L.defined(r.westHemisphereGeometry)&&L.defined(r.eastHemisphereGeometry)&&i.push(r)}const e=[];return 0<n.length&&e.push(C(n,"geometry")),0<i.length&&(e.push(C(i,"westHemisphereGeometry")),e.push(C(i,"eastHemisphereGeometry"))),e};const I=new N.Cartesian3,O=new N.Cartesian3,E=new N.Cartesian3,z=new N.Cartesian3;n.computeNormal=function(e){const t=e.indices,n=e.attributes,i=n.position.values,r=n.position.values.length/3,a=t.length,s=new Array(r),o=new Array(a/3),u=new Array(a);let l;for(l=0;l<r;l++)s[l]={indexOffset:0,count:0,currentCount:0};let c=0;for(l=0;l<a;l+=3){const e=t[l],n=t[l+1],T=t[l+2],r=3*e,a=3*n,x=3*T;O.x=i[r],O.y=i[1+r],O.z=i[2+r],E.x=i[a],E.y=i[1+a],E.z=i[2+a],z.x=i[x],z.y=i[1+x],z.z=i[2+x],s[e].count++,s[n].count++,s[T].count++,N.Cartesian3.subtract(E,O,E),N.Cartesian3.subtract(z,O,z),o[c]=N.Cartesian3.cross(E,z,new N.Cartesian3),c++}let p,d=0;for(l=0;l<r;l++)s[l].indexOffset+=d,d+=s[l].count;for(c=0,l=0;l<a;l+=3){p=s[t[l]];var y=p.indexOffset+p.currentCount;u[y]=c,p.currentCount++,p=s[t[l+1]],y=p.indexOffset+p.currentCount,u[y]=c,p.currentCount++,p=s[t[l+2]],y=p.indexOffset+p.currentCount,u[y]=c,p.currentCount++,c++}const f=new Float32Array(3*r);for(l=0;l<r;l++){const e=3*l;if(p=s[l],N.Cartesian3.clone(N.Cartesian3.ZERO,I),0<p.count){for(c=0;c<p.count;c++)N.Cartesian3.add(I,o[u[p.indexOffset+c]],I);N.Cartesian3.equalsEpsilon(N.Cartesian3.ZERO,I,T.CesiumMath.EPSILON10)&&N.Cartesian3.clone(o[u[p.indexOffset]],I)}N.Cartesian3.equalsEpsilon(N.Cartesian3.ZERO,I,T.CesiumMath.EPSILON10)&&(I.z=1),N.Cartesian3.normalize(I,I),f[e]=I.x,f[1+e]=I.y,f[2+e]=I.z}return e.attributes.normal=new x.GeometryAttribute({componentDatatype:T.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:f}),e};const D=new N.Cartesian3,M=new N.Cartesian3,G=new N.Cartesian3;n.computeTangentAndBitangent=function(e){e.attributes;const t=e.indices,n=e.attributes.position.values,i=e.attributes.normal.values,r=e.attributes.st.values,a=e.attributes.position.values.length/3,s=t.length,o=new Array(3*a);let u,l,c,p;for(u=0;u<o.length;u++)o[u]=0;for(u=0;u<s;u+=3){const e=t[u],N=t[u+1],i=t[u+2];l=3*e,c=3*N,p=3*i;const T=2*e,a=2*N,x=2*i,s=n[l],d=n[l+1],y=n[l+2],f=r[T],m=r[1+T],C=r[1+a]-m,v=r[1+x]-m,h=1/((r[a]-f)*v-(r[x]-f)*C),b=(v*(n[c]-s)-C*(n[p]-s))*h,g=(v*(n[c+1]-d)-C*(n[p+1]-d))*h,A=(v*(n[c+2]-y)-C*(n[p+2]-y))*h;o[l]+=b,o[l+1]+=g,o[l+2]+=A,o[c]+=b,o[c+1]+=g,o[c+2]+=A,o[p]+=b,o[p+1]+=g,o[p+2]+=A}const d=new Float32Array(3*a),y=new Float32Array(3*a);for(u=0;u<a;u++){l=3*u,c=l+1,p=l+2;const e=N.Cartesian3.fromArray(i,l,D),t=N.Cartesian3.fromArray(o,l,G),n=N.Cartesian3.dot(e,t);N.Cartesian3.multiplyByScalar(e,n,M),N.Cartesian3.normalize(N.Cartesian3.subtract(t,M,t),t),d[l]=t.x,d[c]=t.y,d[p]=t.z,N.Cartesian3.normalize(N.Cartesian3.cross(e,t,t),t),y[l]=t.x,y[c]=t.y,y[p]=t.z}return e.attributes.tangent=new x.GeometryAttribute({componentDatatype:T.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:d}),e.attributes.bitangent=new x.GeometryAttribute({componentDatatype:T.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:y}),e};const R=new N.Cartesian2,V=new N.Cartesian3,F=new N.Cartesian3,B=new N.Cartesian3;let _=new N.Cartesian2;function k(e,t){Math.abs(e.y)<T.CesiumMath.EPSILON6&&(e.y=t?-T.CesiumMath.EPSILON6:T.CesiumMath.EPSILON6)}n.compressVertices=function(t){var n=t.attributes.extrudeDirection;let i,r;if(L.defined(n)){const L=n.values;r=L.length/3;const a=new Float32Array(2*r);let e=0;for(i=0;i<r;++i)N.Cartesian3.fromArray(L,3*i,V),N.Cartesian3.equals(V,N.Cartesian3.ZERO)?e+=2:(_=v.AttributeCompression.octEncodeInRange(V,65535,_),a[e++]=_.x,a[e++]=_.y);return t.attributes.compressedAttributes=new x.GeometryAttribute({componentDatatype:T.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:a}),delete t.attributes.extrudeDirection,t}const a=t.attributes.normal,e=t.attributes.st,s=L.defined(a),o=L.defined(e);if(!s&&!o)return t;var u=t.attributes.tangent,n=t.attributes.bitangent,l=L.defined(u),c=L.defined(n);let p,d,y,f;s&&(p=a.values),o&&(d=e.values),l&&(y=u.values),c&&(f=n.values),r=(s?p:d).length/(s?3:2);u=r,n=o&&s?2:1;u*=n+=l||c?1:0;const m=new Float32Array(u);let C=0;for(i=0;i<r;++i){o&&(N.Cartesian2.fromArray(d,2*i,R),m[C++]=v.AttributeCompression.compressTextureCoordinates(R));const t=3*i;s&&L.defined(y)&&L.defined(f)?(N.Cartesian3.fromArray(p,t,V),N.Cartesian3.fromArray(y,t,F),N.Cartesian3.fromArray(f,t,B),v.AttributeCompression.octPack(V,F,B,R),m[C++]=R.x,m[C++]=R.y):(s&&(N.Cartesian3.fromArray(p,t,V),m[C++]=v.AttributeCompression.octEncodeFloat(V)),l&&(N.Cartesian3.fromArray(y,t,V),m[C++]=v.AttributeCompression.octEncodeFloat(V)),c&&(N.Cartesian3.fromArray(f,t,V),m[C++]=v.AttributeCompression.octEncodeFloat(V)))}return t.attributes.compressedAttributes=new x.GeometryAttribute({componentDatatype:T.ComponentDatatype.FLOAT,componentsPerAttribute:n,values:m}),s&&delete t.attributes.normal,o&&delete t.attributes.st,c&&delete t.attributes.bitangent,l&&delete t.attributes.tangent,t};const q=new N.Cartesian3;function U(e,t,n,i){N.Cartesian3.add(e,N.Cartesian3.multiplyByScalar(N.Cartesian3.subtract(t,e,q),e.y/(e.y-t.y),q),n),N.Cartesian3.clone(n,i),k(n,!0),k(i,!1)}const Y=new N.Cartesian3,Z=new N.Cartesian3,H=new N.Cartesian3,W=new N.Cartesian3,X={positions:new Array(7),indices:new Array(9)};function j(e,t,n){if(!(0<=e.x||0<=t.x||0<=n.x)){!function(e,t,n){if(0!==e.y&&0!==t.y&&0!==n.y)return k(e,e.y<0),k(t,t.y<0),k(n,n.y<0);var i=Math.abs(e.y),r=Math.abs(t.y),a=Math.abs(n.y),r=(r<i?a<i?T.CesiumMath.sign(e.y):T.CesiumMath.sign(n.y):a<r?T.CesiumMath.sign(t.y):T.CesiumMath.sign(n.y))<0;k(e,r),k(t,r),k(n,r)}(e,t,n);var i=e.y<0,r=t.y<0,a=n.y<0,s=0;s+=i?1:0,s+=r?1:0,s+=a?1:0;const o=X.indices;1==s?(o[1]=3,o[2]=4,o[5]=6,o[7]=6,o[8]=5,i?(U(e,t,Y,H),U(e,n,Z,W),o[0]=0,o[3]=1,o[4]=2,o[6]=1):r?(U(t,n,Y,H),U(t,e,Z,W),o[0]=1,o[3]=2,o[4]=0,o[6]=2):a&&(U(n,e,Y,H),U(n,t,Z,W),o[0]=2,o[3]=0,o[4]=1,o[6]=0)):2==s&&(o[2]=4,o[4]=4,o[5]=3,o[7]=5,o[8]=6,i?r?a||(U(n,e,Y,H),U(n,t,Z,W),o[0]=0,o[1]=1,o[3]=0,o[6]=2):(U(t,n,Y,H),U(t,e,Z,W),o[0]=2,o[1]=0,o[3]=2,o[6]=1):(U(e,t,Y,H),U(e,n,Z,W),o[0]=1,o[1]=2,o[3]=1,o[6]=0));const u=X.positions;return u[0]=e,u[1]=t,u[2]=n,u.length=3,1!=s&&2!=s||(u[3]=Y,u[4]=Z,u[5]=H,u[6]=W,u.length=7),X}}function J(e,t){const n=e.attributes;if(0!==n.position.values.length){for(const e in n)if(n.hasOwnProperty(e)&&L.defined(n[e])&&L.defined(n[e].values)){const t=n[e];t.values=T.ComponentDatatype.createTypedArray(t.componentDatatype,t.values)}var i=x.Geometry.computeNumberOfVertices(e);return e.indices=b.IndexDatatype.createTypedArray(i,e.indices),t&&(e.boundingSphere=h.BoundingSphere.fromVertices(n.position.values)),e}}function K(e){const t=e.attributes,n={};for(const e in t){var i;t.hasOwnProperty(e)&&L.defined(t[e])&&L.defined(t[e].values)&&(i=t[e],n[e]=new x.GeometryAttribute({componentDatatype:i.componentDatatype,componentsPerAttribute:i.componentsPerAttribute,normalize:i.normalize,values:[]}))}return new x.Geometry({attributes:n,indices:[],primitiveType:e.primitiveType})}function Q(e,t,n){var i=L.defined(e.geometry.boundingSphere);t=J(t,i),n=J(n,i),L.defined(n)&&!L.defined(t)?e.geometry=n:!L.defined(n)&&L.defined(t)?e.geometry=t:(e.westHemisphereGeometry=t,e.eastHemisphereGeometry=n,e.geometry=void 0)}function $(u,l){const c=new u,p=new u,d=new u;return function(e,t,n,i,r,a,s,o){e=u.fromArray(r,e*l,c),t=u.fromArray(r,t*l,p),n=u.fromArray(r,n*l,d);u.multiplyByScalar(e,i.x,e),u.multiplyByScalar(t,i.y,t),u.multiplyByScalar(n,i.z,n);e=u.add(e,t,e);u.add(e,n,e),o&&u.normalize(e,e),u.pack(e,a,s*l)}}const ee=$(N.Cartesian4,4),te=$(N.Cartesian3,3),ne=$(N.Cartesian2,2),ie=new N.Cartesian3,re=new N.Cartesian3,ae=new N.Cartesian3,se=new N.Cartesian3;function oe(t,n,i,r,e,a,s,o,u,l,c,p,d,y,f,m){if(L.defined(a)||L.defined(s)||L.defined(o)||L.defined(u)||L.defined(l)||0!==y){var C=function(e,t,n,i,r){let a,s,o,u,l,c,p,d;if(L.defined(r)||(r=new N.Cartesian3),L.defined(t.z)){if(N.Cartesian3.equalsEpsilon(e,t,T.CesiumMath.EPSILON14))return N.Cartesian3.clone(N.Cartesian3.UNIT_X,r);if(N.Cartesian3.equalsEpsilon(e,n,T.CesiumMath.EPSILON14))return N.Cartesian3.clone(N.Cartesian3.UNIT_Y,r);if(N.Cartesian3.equalsEpsilon(e,i,T.CesiumMath.EPSILON14))return N.Cartesian3.clone(N.Cartesian3.UNIT_Z,r);a=N.Cartesian3.subtract(n,t,g),s=N.Cartesian3.subtract(i,t,A),o=N.Cartesian3.subtract(e,t,w),u=N.Cartesian3.dot(a,a),l=N.Cartesian3.dot(a,s),c=N.Cartesian3.dot(a,o),p=N.Cartesian3.dot(s,s),d=N.Cartesian3.dot(s,o)}else{if(N.Cartesian2.equalsEpsilon(e,t,T.CesiumMath.EPSILON14))return N.Cartesian3.clone(N.Cartesian3.UNIT_X,r);if(N.Cartesian2.equalsEpsilon(e,n,T.CesiumMath.EPSILON14))return N.Cartesian3.clone(N.Cartesian3.UNIT_Y,r);if(N.Cartesian2.equalsEpsilon(e,i,T.CesiumMath.EPSILON14))return N.Cartesian3.clone(N.Cartesian3.UNIT_Z,r);a=N.Cartesian2.subtract(n,t,g),s=N.Cartesian2.subtract(i,t,A),o=N.Cartesian2.subtract(e,t,w),u=N.Cartesian2.dot(a,a),l=N.Cartesian2.dot(a,s),c=N.Cartesian2.dot(a,o),p=N.Cartesian2.dot(s,s),d=N.Cartesian2.dot(s,o)}r.y=p*c-l*d,r.z=u*d-l*c;t=u*p-l*l;if(0!=t)return r.y/=t,r.z/=t,r.x=1-r.y-r.z,r}(r,N.Cartesian3.fromArray(e,3*t,ie),N.Cartesian3.fromArray(e,3*n,re),N.Cartesian3.fromArray(e,3*i,ae),se);if(L.defined(C)){if(L.defined(a)&&te(t,n,i,C,a,p.normal.values,m,!0),L.defined(l)){const L=N.Cartesian3.fromArray(l,3*t,ie),T=N.Cartesian3.fromArray(l,3*n,re),r=N.Cartesian3.fromArray(l,3*i,ae);let e;N.Cartesian3.multiplyByScalar(L,C.x,L),N.Cartesian3.multiplyByScalar(T,C.y,T),N.Cartesian3.multiplyByScalar(r,C.z,r),N.Cartesian3.equals(L,N.Cartesian3.ZERO)&&N.Cartesian3.equals(T,N.Cartesian3.ZERO)&&N.Cartesian3.equals(r,N.Cartesian3.ZERO)?(e=ie,e.x=0,e.y=0,e.z=0):(e=N.Cartesian3.add(L,T,L),N.Cartesian3.add(e,r,e),N.Cartesian3.normalize(e,e)),N.Cartesian3.pack(e,p.extrudeDirection.values,3*m)}if(L.defined(c)&&(e=p.applyOffset.values,a=c[t]*C.x,l=c[n]*C.y,c=c[i]*C.z,e[m]=a+l+c>T.CesiumMath.EPSILON6?1:0),L.defined(s)&&te(t,n,i,C,s,p.tangent.values,m,!0),L.defined(o)&&te(t,n,i,C,o,p.bitangent.values,m,!0),L.defined(u)&&ne(t,n,i,C,u,p.st.values,m),0<y)for(let e=0;e<y;e++){const L=d[e];!function(e,t,n,i,r,a,s){const o=a.componentsPerAttribute,u=a.values,l=s.values;switch(o){case 4:ee(e,t,n,i,u,l,r,!1);break;case 3:te(e,t,n,i,u,l,r,!1);break;case 2:ne(e,t,n,i,u,l,r,!1);break;default:l[r]=u[e]*i.x+u[t]*i.y+u[n]*i.z}}(t,n,i,C,m,f[L],p[L])}}}}function ue(e,t,n,i,r,a){var s=e.position.values.length/3;if(-1===r)return e.position.values.push(a.x,a.y,a.z),t.push(s),s;i=i[r],r=n[i];return-1===r?(n[i]=s,e.position.values.push(a.x,a.y,a.z),t.push(s),s):(t.push(r),r)}const le={position:!0,normal:!0,bitangent:!0,tangent:!0,st:!0,extrudeDirection:!0,applyOffset:!0};function ce(i){const r=i.geometry,a=r.attributes,s=a.position.values,o=L.defined(a.normal)?a.normal.values:void 0,u=L.defined(a.bitangent)?a.bitangent.values:void 0,l=L.defined(a.tangent)?a.tangent.values:void 0,c=L.defined(a.st)?a.st.values:void 0,p=L.defined(a.extrudeDirection)?a.extrudeDirection.values:void 0,d=L.defined(a.applyOffset)?a.applyOffset.values:void 0,y=r.indices,f=[];for(const i in a)a.hasOwnProperty(i)&&!le[i]&&L.defined(a[i])&&f.push(i);var m=f.length,C=K(r),v=K(r);let h,b,g,A,T;const x=[];x.length=s.length/3;const P=[];for(P.length=s.length/3,T=0;T<x.length;++T)x[T]=-1,P[T]=-1;const w=y.length;for(T=0;T<w;T+=3){const i=y[T],r=y[T+1],w=y[T+2];let e=N.Cartesian3.fromArray(s,3*i),t=N.Cartesian3.fromArray(s,3*r),n=N.Cartesian3.fromArray(s,3*w);var S=j(e,t,n);if(L.defined(S)&&3<S.positions.length){const N=S.positions,L=S.indices,E=L.length;for(let e=0;e<E;++e){var I=L[e],O=N[I];g=O.y<0?(h=v.attributes,b=v.indices,x):(h=C.attributes,b=C.indices,P),A=ue(h,b,g,y,I<3?T+I:-1,O),oe(i,r,w,O,s,o,l,u,c,p,d,h,f,m,a,A)}}else L.defined(S)&&(e=S.positions[0],t=S.positions[1],n=S.positions[2]),g=e.y<0?(h=v.attributes,b=v.indices,x):(h=C.attributes,b=C.indices,P),A=ue(h,b,g,y,T,e),oe(i,r,w,e,s,o,l,u,c,p,d,h,f,m,a,A),A=ue(h,b,g,y,T+1,t),oe(i,r,w,t,s,o,l,u,c,p,d,h,f,m,a,A),A=ue(h,b,g,y,T+2,n),oe(i,r,w,n,s,o,l,u,c,p,d,h,f,m,a,A)}Q(i,v,C)}const pe=i.Plane.fromPointNormal(N.Cartesian3.ZERO,N.Cartesian3.UNIT_Y),de=new N.Cartesian3,ye=new N.Cartesian3;function fe(e,t,n,i,r,a,s){L.defined(s)&&(i=N.Cartesian3.fromArray(i,3*e,ie),N.Cartesian3.equalsEpsilon(i,n,T.CesiumMath.EPSILON10)?a.applyOffset.values[r]=s[e]:a.applyOffset.values[r]=s[t])}function me(o){const u=o.geometry,l=u.attributes,c=l.position.values,p=L.defined(l.applyOffset)?l.applyOffset.values:void 0,d=u.indices,y=K(u),f=K(u);let m;const C=d.length,v=[];v.length=c.length/3;const h=[];for(h.length=c.length/3,m=0;m<v.length;++m)v[m]=-1,h[m]=-1;for(m=0;m<C;m+=2){const o=d[m],u=d[m+1],l=N.Cartesian3.fromArray(c,3*o,ie),C=N.Cartesian3.fromArray(c,3*u,re);let i;Math.abs(l.y)<T.CesiumMath.EPSILON6&&(l.y<0?l.y=-T.CesiumMath.EPSILON6:l.y=T.CesiumMath.EPSILON6),Math.abs(C.y)<T.CesiumMath.EPSILON6&&(C.y<0?C.y=-T.CesiumMath.EPSILON6:C.y=T.CesiumMath.EPSILON6);let e=y.attributes,t=y.indices,n=h,r=f.attributes,a=f.indices,s=v;var b=P.IntersectionTests.lineSegmentPlane(l,C,pe,ae);if(L.defined(b)){const L=N.Cartesian3.multiplyByScalar(N.Cartesian3.UNIT_Y,5*T.CesiumMath.EPSILON9,de);l.y<0&&(N.Cartesian3.negate(L,L),e=f.attributes,t=f.indices,n=v,r=y.attributes,a=y.indices,s=h);const P=N.Cartesian3.add(b,L,ye);i=ue(e,t,n,d,m,l),fe(o,u,l,c,i,e,p),i=ue(e,t,n,d,-1,P),fe(o,u,P,c,i,e,p),N.Cartesian3.negate(L,L),N.Cartesian3.add(b,L,P),i=ue(r,a,s,d,-1,P),fe(o,u,P,c,i,r,p),i=ue(r,a,s,d,m+1,C),fe(o,u,C,c,i,r,p)}else{let e,t,n;n=l.y<0?(e=f.attributes,t=f.indices,v):(e=y.attributes,t=y.indices,h),i=ue(e,t,n,d,m,l),fe(o,u,l,c,i,e,p),i=ue(e,t,n,d,m+1,C),fe(o,u,C,c,i,e,p)}}Q(o,f,y)}const Ce=new N.Cartesian2,ve=new N.Cartesian2,he=new N.Cartesian3,be=new N.Cartesian3,ge=new N.Cartesian3,Ae=new N.Cartesian3,Te=new N.Cartesian3,xe=new N.Cartesian3,Pe=new N.Cartesian4;function we(e){const t=e.attributes,n=t.position.values,i=t.prevPosition.values,r=t.nextPosition.values,a=n.length;for(let e=0;e<a;e+=3){const t=N.Cartesian3.unpack(n,e,he);var s;0<t.x||(s=N.Cartesian3.unpack(i,e,be),(t.y<0&&0<s.y||0<t.y&&s.y<0)&&(0<e-3?(i[e]=n[e-3],i[e+1]=n[e-2],i[e+2]=n[e-1]):N.Cartesian3.pack(t,i,e)),s=N.Cartesian3.unpack(r,e,ge),(t.y<0&&0<s.y||0<t.y&&s.y<0)&&(e+3<a?(r[e]=n[e+3],r[e+1]=n[e+4],r[e+2]=n[e+5]):N.Cartesian3.pack(t,r,e)))}}const Se=5*T.CesiumMath.EPSILON9,Ie=T.CesiumMath.EPSILON6;n.splitLongitude=function(e){var t=e.geometry,n=t.boundingSphere;if(L.defined(n)&&(0<n.center.x-n.radius||h.BoundingSphere.intersectPlane(n,i.Plane.ORIGIN_ZX_PLANE)!==h.Intersect.INTERSECTING))return e;if(t.geometryType!==x.GeometryType.NONE)switch(t.geometryType){case x.GeometryType.POLYLINES:!function(r){const a=r.geometry,s=a.attributes,o=s.position.values,u=s.prevPosition.values,l=s.nextPosition.values,c=s.expandAndWidth.values,p=L.defined(s.st)?s.st.values:void 0,d=L.defined(s.color)?s.color.values:void 0,y=K(a),f=K(a);let m,C,v,h=!1;const b=o.length/3;for(m=0;m<b;m+=4){const r=m,a=m+2,s=N.Cartesian3.fromArray(o,3*r,he),b=N.Cartesian3.fromArray(o,3*a,be);if(Math.abs(s.y)<Ie)for(s.y=Ie*(b.y<0?-1:1),o[3*m+1]=s.y,o[3*(m+1)+1]=s.y,C=3*r;C<3*r+12;C+=3)u[C]=o[3*m],u[C+1]=o[3*m+1],u[C+2]=o[3*m+2];if(Math.abs(b.y)<Ie)for(b.y=Ie*(s.y<0?-1:1),o[3*(m+2)+1]=b.y,o[3*(m+3)+1]=b.y,C=3*r;C<3*r+12;C+=3)l[C]=o[3*(m+2)],l[C+1]=o[3*(m+2)+1],l[C+2]=o[3*(m+2)+2];let e=y.attributes,t=y.indices,n=f.attributes,i=f.indices;var g=P.IntersectionTests.lineSegmentPlane(s,b,pe,Ae);if(L.defined(g)){h=!0;const o=N.Cartesian3.multiplyByScalar(N.Cartesian3.UNIT_Y,Se,Te);s.y<0&&(N.Cartesian3.negate(o,o),e=f.attributes,t=f.indices,n=y.attributes,i=y.indices);const P=N.Cartesian3.add(g,o,xe);e.position.values.push(s.x,s.y,s.z,s.x,s.y,s.z),e.position.values.push(P.x,P.y,P.z),e.position.values.push(P.x,P.y,P.z),e.prevPosition.values.push(u[3*r],u[3*r+1],u[3*r+2]),e.prevPosition.values.push(u[3*r+3],u[3*r+4],u[3*r+5]),e.prevPosition.values.push(s.x,s.y,s.z,s.x,s.y,s.z),e.nextPosition.values.push(P.x,P.y,P.z),e.nextPosition.values.push(P.x,P.y,P.z),e.nextPosition.values.push(P.x,P.y,P.z),e.nextPosition.values.push(P.x,P.y,P.z),N.Cartesian3.negate(o,o),N.Cartesian3.add(g,o,P),n.position.values.push(P.x,P.y,P.z),n.position.values.push(P.x,P.y,P.z),n.position.values.push(b.x,b.y,b.z,b.x,b.y,b.z),n.prevPosition.values.push(P.x,P.y,P.z),n.prevPosition.values.push(P.x,P.y,P.z),n.prevPosition.values.push(P.x,P.y,P.z),n.prevPosition.values.push(P.x,P.y,P.z),n.nextPosition.values.push(b.x,b.y,b.z,b.x,b.y,b.z),n.nextPosition.values.push(l[3*a],l[3*a+1],l[3*a+2]),n.nextPosition.values.push(l[3*a+3],l[3*a+4],l[3*a+5]);var A=N.Cartesian2.fromArray(c,2*r,Ce),A=Math.abs(A.y);e.expandAndWidth.values.push(-1,A,1,A),e.expandAndWidth.values.push(-1,-A,1,-A),n.expandAndWidth.values.push(-1,A,1,A),n.expandAndWidth.values.push(-1,-A,1,-A);g=N.Cartesian3.magnitudeSquared(N.Cartesian3.subtract(g,s,ge));if(g/=N.Cartesian3.magnitudeSquared(N.Cartesian3.subtract(b,s,ge)),L.defined(d)){const s=N.Cartesian4.fromArray(d,4*r,Pe),L=N.Cartesian4.fromArray(d,4*a,Pe),o=T.CesiumMath.lerp(s.x,L.x,g),u=T.CesiumMath.lerp(s.y,L.y,g),l=T.CesiumMath.lerp(s.z,L.z,g),c=T.CesiumMath.lerp(s.w,L.w,g);for(C=4*r;C<4*r+8;++C)e.color.values.push(d[C]);for(e.color.values.push(o,u,l,c),e.color.values.push(o,u,l,c),n.color.values.push(o,u,l,c),n.color.values.push(o,u,l,c),C=4*a;C<4*a+8;++C)n.color.values.push(d[C])}if(L.defined(p)){const s=N.Cartesian2.fromArray(p,2*r,Ce),L=N.Cartesian2.fromArray(p,2*(m+3),ve),o=T.CesiumMath.lerp(s.x,L.x,g);for(C=2*r;C<2*r+4;++C)e.st.values.push(p[C]);for(e.st.values.push(o,s.y),e.st.values.push(o,L.y),n.st.values.push(o,s.y),n.st.values.push(o,L.y),C=2*a;C<2*a+4;++C)n.st.values.push(p[C])}v=e.position.values.length/3-4,t.push(v,v+2,v+1),t.push(v+1,v+2,v+3),v=n.position.values.length/3-4,i.push(v,v+2,v+1),i.push(v+1,v+2,v+3)}else{let e,t;for(t=s.y<0?(e=f.attributes,f.indices):(e=y.attributes,y.indices),e.position.values.push(s.x,s.y,s.z),e.position.values.push(s.x,s.y,s.z),e.position.values.push(b.x,b.y,b.z),e.position.values.push(b.x,b.y,b.z),C=3*m;C<3*m+12;++C)e.prevPosition.values.push(u[C]),e.nextPosition.values.push(l[C]);for(C=2*m;C<2*m+8;++C)e.expandAndWidth.values.push(c[C]),L.defined(p)&&e.st.values.push(p[C]);if(L.defined(d))for(C=4*m;C<4*m+16;++C)e.color.values.push(d[C]);v=e.position.values.length/3-4,t.push(v,v+2,v+1),t.push(v+1,v+2,v+3)}}h&&(we(f),we(y)),Q(r,f,y)}(e);break;case x.GeometryType.TRIANGLES:ce(e);break;case x.GeometryType.LINES:me(e)}else(function(e){switch(e.primitiveType){case x.PrimitiveType.TRIANGLE_FAN:return function(e){const t=x.Geometry.computeNumberOfVertices(e),n=b.IndexDatatype.createTypedArray(t,3*(t-2));n[0]=1,n[1]=0,n[2]=2;let i=3;for(let e=3;e<t;++e)n[i++]=e-1,n[i++]=0,n[i++]=e;e.indices=n,e.primitiveType=x.PrimitiveType.TRIANGLES}(e);case x.PrimitiveType.TRIANGLE_STRIP:return function(e){const t=x.Geometry.computeNumberOfVertices(e),n=b.IndexDatatype.createTypedArray(t,3*(t-2));n[0]=0,n[1]=1,n[2]=2,3<t&&(n[3]=0,n[4]=2,n[5]=3);let i=6;for(let e=3;e<t-1;e+=2)n[i++]=e,n[i++]=e-1,n[i++]=e+1,e+2<t&&(n[i++]=e,n[i++]=e+1,n[i++]=e+2);e.indices=n,e.primitiveType=x.PrimitiveType.TRIANGLES}(e);case x.PrimitiveType.TRIANGLES:return function(e){if(L.defined(e.indices))return;const t=x.Geometry.computeNumberOfVertices(e),n=b.IndexDatatype.createTypedArray(t,t);for(let e=0;e<t;++e)n[e]=e;e.indices=n}(e);case x.PrimitiveType.LINE_STRIP:return function(e){const t=x.Geometry.computeNumberOfVertices(e),n=b.IndexDatatype.createTypedArray(t,2*(t-1));n[0]=0,n[1]=1;let i=2;for(let e=2;e<t;++e)n[i++]=e-1,n[i++]=e;e.indices=n,e.primitiveType=x.PrimitiveType.LINES}(e);case x.PrimitiveType.LINE_LOOP:return function(e){const t=x.Geometry.computeNumberOfVertices(e),n=b.IndexDatatype.createTypedArray(t,2*t);n[0]=0,n[1]=1;let i=2;for(let e=2;e<t;++e)n[i++]=e-1,n[i++]=e;n[i++]=t-1,n[i]=0,e.indices=n,e.primitiveType=x.PrimitiveType.LINES}(e);case x.PrimitiveType.LINES:return function(e){if(L.defined(e.indices))return;const t=x.Geometry.computeNumberOfVertices(e),n=b.IndexDatatype.createTypedArray(t,t);for(let e=0;e<t;++e)n[e]=e;e.indices=n}(e)}})(t),t.primitiveType===x.PrimitiveType.TRIANGLES?ce(e):t.primitiveType===x.PrimitiveType.LINES&&me(e);return e},e.GeometryPipeline=n});