!function(){"use strict";const{Array:l,Object:h,Math:p,Error:m,Uint8Array:d,Uint32Array:c,DataView:f,TextEncoder:r,crypto:o,postMessage:a}=globalThis,i=[];for(let t=0;t<256;t++){let e=t;for(let t=0;t<8;t++)1&e?e=e>>>1^3988292384:e>>>=1;i[t]=e}class u{constructor(t){this.crc=t||-1}append(n){let s=0|this.crc;for(let t=0,e=0|n.length;e>t;t++)s=s>>>8^i[255&(s^n[t])];this.crc=s}get(){return~this.crc}}const g={concat(t,e){if(0===t.length||0===e.length)return t.concat(e);var n=t[t.length-1],s=g.getPartial(n);return 32===s?t.concat(e):g._shiftRight(e,s,0|n,t.slice(0,t.length-1))},bitLength(t){var e=t.length;if(0===e)return 0;t=t[e-1];return 32*(e-1)+g.getPartial(t)},clamp(t,e){if(32*t.length<e)return t;var n=(t=t.slice(0,p.ceil(e/32))).length;return e&=31,0<n&&e&&(t[n-1]=g.partial(e,t[n-1]&2147483648>>e-1,1)),t},partial:(t,e,n)=>32===t?e:(n?0|e:e<<32-t)+1099511627776*t,getPartial:t=>p.round(t/1099511627776)||32,_shiftRight(e,n,s,a){for(void 0===a&&(a=[]);32<=n;n-=32)a.push(s),s=0;if(0===n)return a.concat(e);for(let t=0;t<e.length;t++)a.push(s|e[t]>>>n),s=e[t]<<32-n;var t=e.length?e[e.length-1]:0,t=g.getPartial(t);return a.push(g.partial(n+t&31,32<n+t?s:a.pop(),1)),a}},w={bytes:{fromBits(e){const n=g.bitLength(e)/8,s=new d(n);let a;for(let t=0;n>t;t++)0==(3&t)&&(a=e[t/4]),s[t]=a>>>24,a<<=8;return s},toBits(t){const e=[];let n,s=0;for(n=0;n<t.length;n++)s=s<<8|t[n],3==(3&n)&&(e.push(s),s=0);return 3&n&&e.push(g.partial(8*(3&n),s)),e}}},y={sha1:function(t){t?(this._h=t._h.slice(0),this._buffer=t._buffer.slice(0),this._length=t._length):this.reset()}};y.sha1.prototype={blockSize:512,reset:function(){return this._h=this._init.slice(0),this._buffer=[],this._length=0,this},update:function(t){var e=this;"string"==typeof t&&(t=w.utf8String.toBits(t));const n=e._buffer=g.concat(e._buffer,t),s=e._length,a=e._length=s+g.bitLength(t);if(9007199254740991<a)throw new m("Cannot hash more than 2^53 - 1 bits");const r=new c(n);let i=0;for(let t=e.blockSize+s-(e.blockSize+s&e.blockSize-1);a>=t;t+=e.blockSize)e._block(r.subarray(16*i,16*(i+1))),i+=1;return n.splice(0,16*i),e},finalize:function(){var t=this;let e=t._buffer;var n=t._h;e=g.concat(e,[g.partial(1,1)]);for(let t=e.length+2;15&t;t++)e.push(0);for(e.push(p.floor(t._length/4294967296)),e.push(0|t._length);e.length;)t._block(e.splice(0,16));return t.reset(),n},_init:[1732584193,4023233417,2562383102,271733878,3285377520],_key:[1518500249,1859775393,2400959708,3395469782],_f:(t,e,n,s)=>19<t?39<t?59<t?79<t?void 0:e^n^s:e&n|e&s|n&s:e^n^s:e&n|~e&s,_S:(t,e)=>e<<t|e>>>32-t,_block:function(e){const n=this,t=n._h,s=l(80);for(let t=0;t<16;t++)s[t]=e[t];let a=t[0],r=t[1],i=t[2],c=t[3],o=t[4];for(let t=0;t<=79;t++){t<16||(s[t]=n._S(1,s[t-3]^s[t-8]^s[t-14]^s[t-16]));const e=n._S(5,a)+n._f(t,r,i,c)+o+s[t]+n._key[p.floor(t/20)]|0;o=c,c=i,i=n._S(30,r),r=a,a=e}t[0]=t[0]+a|0,t[1]=t[1]+r|0,t[2]=t[2]+i|0,t[3]=t[3]+c|0,t[4]=t[4]+o|0}};const _={getRandomValues(t){const s=new c(t.buffer);for(let e,n=0;n<t.length;n+=4){let t=(t=>{let e=987654321;const n=4294967295;return()=>(e=36969*(65535&e)+(e>>16)&n,(((e<<16)+(t=18e3*(65535&t)+(t>>16)&n)&n)/4294967296+.5)*(.5<p.random()?1:-1))})(4294967296*(e||p.random()));e=987654071*t(),s[n/4]=4294967296*t()|0}return t}},v={importKey:t=>new v.hmacSha1(w.bytes.toBits(t)),pbkdf2(t,e,n,s){if(n=n||1e4,s<0||n<0)throw new m("invalid params to pbkdf2");var a=1+(s>>5)<<2;let r,i,c,o,l;const h=new ArrayBuffer(a);let p=new f(h),d=0;const u=g;for(e=w.bytes.toBits(e),l=1;(a||1)>d;l++){for(r=i=t.encrypt(u.concat(e,[l])),c=1;n>c;c++)for(i=t.encrypt(i),o=0;o<i.length;o++)r[o]^=i[o];for(c=0;(a||1)>d&&c<r.length;c++)p.setInt32(d,r[c]),d+=4}return h.slice(0,s/8)},hmacSha1:class{constructor(e){const t=this,n=t._hash=y.sha1,s=[[],[]],a=n.prototype.blockSize/32;t._baseHash=[new n,new n],e.length>a&&(e=n.hash(e));for(let t=0;a>t;t++)s[0][t]=909522486^e[t],s[1][t]=1549556828^e[t];t._baseHash[0].update(s[0]),t._baseHash[1].update(s[1]),t._resultHash=new n(t._baseHash[0])}reset(){this._resultHash=new this._hash(this._baseHash[0]),this._updated=!1}update(t){this._updated=!0,this._resultHash.update(t)}digest(){var t=this._resultHash.finalize(),t=new this._hash(this._baseHash[1]).update(t).finalize();return this.reset(),t}encrypt(t){if(this._updated)throw new m("encrypt on already updated hmac called!");return this.update(t),this.digest(t)}}},s="Invalid pasword",b=16,t={name:"PBKDF2"},k=h.assign({hash:{name:"HMAC"}},t),z=h.assign({iterations:1e3,hash:{name:"SHA-1"}},t),C=["deriveBits"],S=[8,12,16],B=[16,24,32],I=10,D=[0,0,0,0],V=void 0!==o,H=V&&void 0!==o.subtle,K=w.bytes,A=class{constructor(t){const e=this;e._tables=[[[],[],[],[],[]],[[],[],[],[],[]]],e._tables[0][0][0]||e._precompute();var n=e._tables[0][4],s=e._tables[1],a=t.length;let r,i,c,o=1;if(4!==a&&6!==a&&8!==a)throw new m("invalid aes key size");for(e._key=[i=t.slice(0),c=[]],r=a;4*a+28>r;r++){let t=i[r-1];(r%a==0||8===a&&r%a==4)&&(t=n[t>>>24]<<24^n[t>>16&255]<<16^n[t>>8&255]<<8^n[255&t],r%a==0&&(t=t<<8^t>>>24^o<<24,o=o<<1^283*(o>>7))),i[r]=i[r-a]^t}for(let t=0;r;t++,r--){const e=i[3&t?r:r-4];c[t]=r<=4||t<4?e:s[0][n[e>>>24]]^s[1][n[e>>16&255]]^s[2][n[e>>8&255]]^s[3][n[255&e]]}}encrypt(t){return this._crypt(t,0)}decrypt(t){return this._crypt(t,1)}_precompute(){const a=this._tables[0],r=this._tables[1],t=a[4],i=r[4],c=[],e=[];let o,l,h;for(let t=0;t<256;t++)e[(c[t]=t<<1^283*(t>>7))^t]=t;for(let s=o=0;!t[s];s^=l||1,o=e[o]||1){var p=(p=o^o<<1^o<<2^o<<3^o<<4)>>8^255&p^99;t[s]=p,i[p]=s;let e=16843009*c[h=c[l=c[s]]]^65537*h^257*l^16843008*s,n=257*c[p]^16843008*p;for(let t=0;t<4;t++)a[t][s]=n=n<<24^n>>>8,r[t][p]=e=e<<24^e>>>8}for(let t=0;t<5;t++)a[t]=a[t].slice(0),r[t]=r[t].slice(0)}_crypt(t,e){if(4!==t.length)throw new m("invalid aes block size");const n=this._key[e],s=n.length/4-2,a=[0,0,0,0],r=this._tables[e],i=r[0],c=r[1],o=r[2],l=r[3],h=r[4];let p,d,u,f=t[0]^n[0],g=t[e?3:1]^n[1],w=t[2]^n[2],y=t[e?1:3]^n[3],_=4;for(let t=0;s>t;t++)p=i[f>>>24]^c[g>>16&255]^o[w>>8&255]^l[255&y]^n[_],d=i[g>>>24]^c[w>>16&255]^o[y>>8&255]^l[255&f]^n[_+1],u=i[w>>>24]^c[y>>16&255]^o[f>>8&255]^l[255&g]^n[_+2],y=i[y>>>24]^c[f>>16&255]^o[g>>8&255]^l[255&w]^n[_+3],_+=4,f=p,g=d,w=u;for(let t=0;t<4;t++)a[e?3&-t:t]=h[f>>>24]<<24^h[g>>16&255]<<16^h[w>>8&255]<<8^h[255&y]^n[_++],p=f,f=g,g=w,w=y,y=p;return a}},R=class{constructor(t,e){this._prf=t,this._initIv=e,this._iv=e}reset(){this._iv=this._initIv}update(t){return this.calculate(this._prf,t,this._iv)}incWord(s){if(255==(s>>24&255)){let t=s>>16&255,e=s>>8&255,n=255&s;255===t?(t=0,255===e?(e=0,255===n?n=0:++n):++e):++t,s=0,s+=t<<16,s+=e<<8,s+=n}else s+=1<<24;return s}incCounter(t){0===(t[0]=this.incWord(t[0]))&&(t[1]=this.incWord(t[1]))}calculate(e,n,s){let a;if(!(a=n.length))return[];var t=g.bitLength(n);for(let t=0;a>t;t+=4){this.incCounter(s);const a=e.encrypt(s);n[t]^=a[0],n[t+1]^=a[1],n[t+2]^=a[2],n[t+3]^=a[3]}return g.clamp(n,t)}},W=v.hmacSha1;class T{constructor(t,e,n){h.assign(this,{password:t,signed:e,strength:n-1,pendingInput:new d(0)})}async append(t){var e=this;if(e.password){const d=E(t,0,S[e.strength]+2);await(async(t,e,n)=>{await P(t,n,E(e,0,S[t.strength]));e=E(e,S[t.strength]),t=t.keys.passwordVerification;if(t[0]!=e[0]||t[1]!=e[1])throw new m(s)})(e,d,e.password),e.password=null,e.aesCtrGladman=new R(new A(e.keys.key),l.from(D)),e.hmac=new W(e.keys.authentication),t=E(t,S[e.strength]+2)}return L(e,t,new d(t.length-I-(t.length-I)%b),0,I,!0)}flush(){const t=this,e=t.pendingInput,n=E(e,0,e.length-I),s=E(e,e.length-I);let a=new d(0);if(n.length){const e=K.toBits(n);t.hmac.update(e);const s=t.aesCtrGladman.update(e);a=K.fromBits(s)}let r=!0;if(t.signed){const e=E(K.fromBits(t.hmac.digest()),0,I);for(let t=0;I>t;t++)e[t]!=s[t]&&(r=!1)}return{valid:r,data:a}}}class G{constructor(t,e){h.assign(this,{password:t,strength:e-1,pendingInput:new d(0)})}async append(t){var e,n,s,a=this;let r=new d(0);a.password&&(r=(n=(e=a).password,s=new d(S[e.strength]),s=(V&&"function"==typeof o.getRandomValues?o:_).getRandomValues(s),await P(e,n,s),await U(s,e.keys.passwordVerification)),a.password=null,a.aesCtrGladman=new R(new A(a.keys.key),l.from(D)),a.hmac=new W(a.keys.authentication));const i=new d(r.length+t.length-t.length%b);return i.set(r,0),L(a,t,i,r.length,0)}flush(){var t=this;let e=new d(0);if(t.pendingInput.length){const n=t.aesCtrGladman.update(K.toBits(t.pendingInput));t.hmac.update(n),e=K.fromBits(n)}const n=E(K.fromBits(t.hmac.digest()),0,I);return{data:U(e,n),signature:n}}}function L(t,e,n,s,a,r){var i,c,o=e.length-a;let l;for(t.pendingInput.length&&(e=U(t.pendingInput,e),i=n,(c=o-o%b)&&c>i.length&&(a=i,(i=new d(c)).set(a,0)),n=i),l=0;o-b>=l;l+=b){const d=K.toBits(E(e,l,l+b));r&&t.hmac.update(d);const h=t.aesCtrGladman.update(d);r||t.hmac.update(h),n.set(K.fromBits(h),l+s)}return t.pendingInput=E(e,l),n}async function P(t,e,n){var s,a=(e=>{if(void 0!==r)return(new r).encode(e);{const n=new d((e=unescape(encodeURIComponent(e))).length);for(let t=0;t<n.length;t++)n[t]=e.charCodeAt(t);return n}})(e),a=(s=a,e=k,a=C,await(V&&H&&"function"==typeof o.subtle.importKey?o.subtle.importKey("raw",s,e,!1,a):v.importKey(s))),a=(s=h.assign({salt:n},z),n=a,a=8*(2*B[t.strength]+2),await(V&&H&&"function"==typeof o.subtle.deriveBits?await o.subtle.deriveBits(s,n,a):v.pbkdf2(n,s.salt,z.iterations,a))),a=new d(a);t.keys={key:K.toBits(E(a,0,B[t.strength])),authentication:K.toBits(E(a,B[t.strength],2*B[t.strength])),passwordVerification:E(a,2*B[t.strength])}}function U(t,e){let n=t;return t.length+e.length&&(n=new d(t.length+e.length),n.set(t,0),n.set(e,t.length)),n}function E(t,e,n){return t.subarray(e,n)}class M{constructor(t,e){h.assign(this,{password:t,passwordVerification:e}),n(this,t)}append(t){var e=this;if(e.password){var n=x(e,t.subarray(0,12));if(e.password=null,n[11]!=e.passwordVerification)throw new m(s);t=t.subarray(12)}return x(e,t)}flush(){return{valid:!0,data:new d(0)}}}class j{constructor(t,e){h.assign(this,{password:t,passwordVerification:e}),n(this,t)}append(t){var e=this;let n,s;if(e.password){e.password=null;const a=o.getRandomValues(new d(12));a[11]=e.passwordVerification,n=new d(t.length+a.length),n.set(F(e,a),0),s=12}else n=new d(t.length),s=0;return n.set(F(e,t),s),n}flush(){return{data:new d(0)}}}function x(e,n){const s=new d(n.length);for(let t=0;t<n.length;t++)s[t]=q(e)^n[t],O(e,s[t]);return s}function F(e,n){const s=new d(n.length);for(let t=0;t<n.length;t++)s[t]=q(e)^n[t],O(e,n[t]);return s}function n(e,n){e.keys=[305419896,591751049,878082192],e.crcKey0=new u(e.keys[0]),e.crcKey2=new u(e.keys[2]);for(let t=0;t<n.length;t++)O(e,n.charCodeAt(t))}function O(t,e){t.crcKey0.append([e]),t.keys[0]=~t.crcKey0.get(),t.keys[1]=N(t.keys[1]+J(t.keys[0])),t.keys[1]=N(p.imul(t.keys[1],134775813)+1),t.crcKey2.append([t.keys[1]>>>24]),t.keys[2]=~t.crcKey2.get()}function q(t){t=2|t.keys[2];return J(p.imul(t,1^t)>>>8)}function J(t){return 255&t}function N(t){return 4294967295&t}const Q="deflate",X="inflate",Y="Invalid signature";class Z{constructor(t,{signature:e,password:n,signed:s,compressed:a,zipCrypto:r,passwordVerification:i,encryptionStrength:c},{chunkSize:o}){var l=!!n;h.assign(this,{signature:e,encrypted:l,signed:s,compressed:a,inflate:a&&new t({chunkSize:o}),crc32:s&&new u,zipCrypto:r,decrypt:l&&r?new M(n,i):new T(n,s,c)})}async append(t){var e=this;return e.encrypted&&t.length&&(t=await e.decrypt.append(t)),e.compressed&&t.length&&(t=await e.inflate.append(t)),(!e.encrypted||e.zipCrypto)&&e.signed&&t.length&&e.crc32.append(t),t}async flush(){var t=this;let e,n=new d(0);if(t.encrypted){const e=t.decrypt.flush();if(!e.valid)throw new m(Y);n=e.data}if((!t.encrypted||t.zipCrypto)&&t.signed){const n=new f(new d(4).buffer);if(e=t.crc32.get(),n.setUint32(0,e),t.signature!=n.getUint32(0,!1))throw new m(Y)}return t.compressed&&(n=await t.inflate.append(n)||new d(0),await t.inflate.flush()),{data:n,signature:e}}}class ${constructor(t,{encrypted:e,signed:n,compressed:s,level:a,zipCrypto:r,password:i,passwordVerification:c,encryptionStrength:o},{chunkSize:l}){h.assign(this,{encrypted:e,signed:n,compressed:s,deflate:s&&new t({level:a||5,chunkSize:l}),crc32:n&&new u,zipCrypto:r,encrypt:e&&r?new j(i,c):new G(i,o)})}async append(t){var e=this;let n=t;return e.compressed&&t.length&&(n=await e.deflate.append(t)),e.encrypted&&n.length&&(n=await e.encrypt.append(n)),(!e.encrypted||e.zipCrypto)&&e.signed&&t.length&&e.crc32.append(t),n}async flush(){var t=this;let e,n=new d(0);if(t.compressed&&(n=await t.deflate.flush()||new d(0)),t.encrypted){n=await t.encrypt.append(n);var s=t.encrypt.flush();e=s.signature;const a=new d(n.length+s.data.length);a.set(n,0),a.set(s.data,n.length),n=a}return t.encrypted&&!t.zipCrypto||!t.signed||(e=t.crc32.get()),{data:n,signature:e}}}const tt={init(t){t.scripts&&t.scripts.length&&importScripts.apply(void 0,t.scripts);const e=t.options;let n;var s,a;self.initCodec&&self.initCodec(),e.codecType.startsWith(Q)?n=self.Deflate:e.codecType.startsWith(X)&&(n=self.Inflate),et=(s=n,a=e,t=t.config,a.codecType.startsWith(Q)?new $(s,a,t):a.codecType.startsWith(X)?new Z(s,a,t):void 0)},append:async t=>({data:await et.append(t.data)}),flush:()=>et.flush()};let et;function nt(e,s,a){return class{constructor(t){const n=this;n.codec=new e(h.assign({},s,t)),a(n.codec,t=>{var e;n.pendingData?(e=n.pendingData,n.pendingData=new d(e.length+t.length),n.pendingData.set(e,0),n.pendingData.set(t,e.length)):n.pendingData=new d(t)})}async append(t){return this.codec.push(t),n(this)}async flush(){return this.codec.push(new d(0),!0),n(this)}};function n(t){if(t.pendingData){var e=t.pendingData;return t.pendingData=null,e}return new d(0)}}addEventListener("message",async t=>{const e=t.data,n=e.type,s=tt[n];if(s)try{e.data&&(e.data=new d(e.data));const t=await s(e)||{};if(t.type=n,t.data)try{t.data=t.data.buffer,a(t,[t.data])}catch(e){a(t)}else a(t)}catch(t){a({type:n,error:{message:t.message,stack:t.stack}})}}),self.initCodec=()=>{var t,{Deflate:e,Inflate:n}=(t=pako,e={deflate:{raw:!0},inflate:{raw:!0}},n=(t,e)=>t.onData=e,{Deflate:nt(t.Deflate,e.deflate,n),Inflate:nt(t.Inflate,e.inflate,n)});self.Deflate=e,self.Inflate=n}}();