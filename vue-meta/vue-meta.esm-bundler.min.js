import{markRaw,h,getCurrentInstance,isProxy,watch,inject,defineComponent,reactive,onUnmounted,Teleport,Comment,computed}from"vue";const resolveOption=(o,r)=>(e,t)=>{let n=-1;if(t.reduce((e,t,r)=>{t=o(e,t);return t!==e?(n=r,t):e},r),-1<n)return e[n]},setup=t=>{let r=0;if(t.vm){let e=t["vm"];for(;e.parent&&(r++,e=e.parent),e&&e.parent&&e!==e.root;);}t.depth=r},resolve=resolveOption((e,t)=>{var t=t["depth"];return!e||e<t?t:e});var defaultResolver=Object.freeze({__proto__:null,setup:setup,resolve:resolve});const defaultConfig={body:{tag:"script",to:"body"},base:{valueAttribute:"href"},charset:{tag:"meta",nameless:!0,valueAttribute:"charset"},description:{tag:"meta"},og:{group:!0,namespacedAttribute:!0,tag:"meta",keyAttribute:"property"},twitter:{group:!0,namespacedAttribute:!0,tag:"meta"},htmlAttrs:{attributesFor:"html"},headAttrs:{attributesFor:"head"},bodyAttrs:{attributesFor:"body"}},tags={title:{attributes:!1},base:{contentAsAttribute:!0,attributes:["href","target"]},meta:{contentAsAttribute:!0,keyAttribute:"name",attributes:["content","name","http-equiv","charset"]},link:{contentAsAttribute:!0,attributes:["href","crossorigin","rel","media","integrity","hreflang","type","referrerpolicy","sizes","imagesrcset","imagesizes","as","color"]},style:{attributes:["media"]},script:{attributes:["src","type","nomodule","async","defer","crossorigin","integrity","referrerpolicy"]},noscript:{attributes:!1}};function getTagConfigItem(e,t){for(const n of e){var r=tags[n];if(n&&r)return r[t]}}Object.freeze({}),Object.freeze([]);const isArray=Array.isArray,isFunction=e=>"function"==typeof e,isString=e=>"string"==typeof e,isObject=e=>null!==e&&"object"==typeof e,objectToString=Object.prototype.toString,toTypeString=e=>objectToString.call(e),isPlainObject=e=>"[object Object]"===toTypeString(e),IS_PROXY=Symbol("kIsProxy"),PROXY_SOURCES=Symbol("kProxySources"),PROXY_TARGET=Symbol("kProxyTarget"),RESOLVE_CONTEXT=Symbol("kResolveContext");function clone(e){if(isArray(e))return e.map(clone);if(isObject(e)){const t={};for(const r in e)"context"===r?t[r]=e[r]:t[r]=clone(e[r]);return t}return e}const pluck=(e,t,r)=>{const n=[];for(const o of e)o&&t in o&&(n.push(o[t]),r&&r(o));return n},allKeys=(e,...t)=>{const r=e?Object.keys(e):[];if(t)for(const e of t)if(e&&isObject(e))for(const n in e)r.includes(n)||r.push(n);return r},recompute=(r,n=[],o,a)=>{var e=!o&&!a;if(e&&({active:o,sources:a}=r,n.length))for(let e=0;e<n.length;e++){const t=n[e];if(!o||!o[t])return void console.error(`recompute: segment ${t} not found on target`,n,o);o=o[t],a=a.map(e=>e[t]).filter(Boolean)}if(o&&a){const c=allKeys(...a);for(const l of Object.keys(o))c.includes(l)||delete o[l];for(const u of c){let t=!1;for(let e=0;e<a.length;e++){var s=a[e];if(s&&u in s&&void 0!==s[u]){t=isPlainObject(s[u]);break}}if(t){o[u]||(o[u]={});const f=[];for(const d of a)u in d&&f.push(d[u]);recompute(r,[...n,u],o[u],f)}else{!o[u]&&isArray(a[0][u])&&(o[u]=[]);const p=[];var i=pluck(a,u,e=>p.push(e[RESOLVE_CONTEXT]));let e=r.resolve(i,p,o[u],u,n);isPlainObject(e)&&(e=clone(e)),o[u]=e}}}},createProxy=(e,t,r,n=[])=>{r=createHandler(e,r,n),r=markRaw(new Proxy(t,r));return!n.length&&e.sources&&e.sources.push(r),r},createHandler=(m,o,g=[])=>({get:(e,t,r)=>{if(t===IS_PROXY)return!0;if(t===PROXY_SOURCES)return m.sources;if(t===PROXY_TARGET)return e;if(t===RESOLVE_CONTEXT)return o;let n=Reflect.get(e,t,r);return isObject(n)&&(n[IS_PROXY]||(r=[...g,t],n=createProxy(m,n,o,r),Reflect.set(e,t,n))),n},set:(c,l,u)=>{var f=Reflect.set(c,l,u);if(f){var d=isArray(c);let e=!1,{sources:t,active:r}=m,n,o=0;for(const p of g){if(t=pluck(t,p),d&&o===g.length-1){n=p;break}isArray(r)&&(e=!0),r=r[p],o++}if(e)return recompute(m),f;if(isPlainObject(u))return recompute(m,g),f;let a=[],s;d?(s=t,a=t.map(e=>e[RESOLVE_CONTEXT])):s=pluck(t,l,e=>a.push(e[RESOLVE_CONTEXT]));let i=m.resolve(s,a,r,l,g);isPlainObject(i)&&(i=clone(i)),d&&n?r[n]=i:r[l]=i}return f},deleteProperty:(t,s)=>{var e=Reflect.deleteProperty(t,s);if(e){var i=isArray(t);let n,o=m.sources,a=m.active,e=0;for(const r of g){if(o=o.map(e=>e&&e[r]),i&&e===g.length-1){n=r;break}a=a[r],e++}if(o.some(e=>e&&s in e)){let t=[],e;i?(e=o,t=o.map(e=>e[RESOLVE_CONTEXT])):e=pluck(o,s,e=>t.push(e[RESOLVE_CONTEXT]));let r=m.resolve(e,t,a,s,g);isPlainObject(r)&&(r=clone(r)),i&&n?a[n]=r:a[s]=r}else delete a[s]}return e}}),createMergedObject=(e,t)=>{const n=[],o={active:t,resolve:e,sources:n},a=()=>recompute(o);return{context:o,compute:a,addSource:(e,t,r=!1)=>{t=createProxy(o,e,t||{});return r&&a(),t},delSource:(t,e=!0)=>{var r=n.findIndex(e=>e===t||e[PROXY_TARGET]===t);return-1<r&&(n.splice(r,1),e&&a(),!0)}}},cachedElements={};function renderMeta(e,t,r,n){return("attributesFor"in n?renderAttributes:"group"in n?renderGroup:renderTag)(e,t,r,n)}function renderGroup(n,o,a,s){return isArray(a)?(console.warn("Specifying an array for group properties isnt supported"),[]):Object.keys(a).map(e=>{const t={group:o,data:a};var r;return s.namespaced?t.tagNamespace=!0===s.namespaced?o:s.namespaced:s.namespacedAttribute&&(r=!0===s.namespacedAttribute?o:s.namespacedAttribute,t.fullName=`${r}:${e}`,t.slotName=`${r}(${e})`),renderTag(n,o,a[e],s,t)}).filter(Boolean).flat()}function renderTag(r,n,t,o={},a){var s=["content","json","rawContent"],i=e=>getTagConfigItem([c,o.tag],e);if(isArray(t))return t.map(e=>renderTag(r,n,e,o,a)).filter(Boolean).flat();const{tag:c=o.tag||n}=t;let l="",e=!1,u=!1;if(isString(t))l=t;else if(t.children&&isArray(t.children))e=!0,l=t.children.map(e=>{const t=renderTag(r,n,e,o,a);return isArray(t)?t.map(({vnode:e})=>e):t&&t.vnode});else{let e=0;for(const g of s){if(!l&&t[g]){l=1===e?JSON.stringify(t[g]):t[g],u=1<e;break}e++}}var f=a&&a.fullName||n,d=a&&a.slotName||n;let p=t["attrs"];if(p||"object"!=typeof t)p=p||{};else{p={...t},delete p.tag,delete p.children,delete p.to;for(const y of s)delete p[y]}if(e)l=getSlotContent(r,d,l,t);else{var m,s=!!i("contentAsAttribute");let e=o["valueAttribute"];!e&&s&&([m]=i("attributes"),e=isString(s)?s:m),l=e?(m=o["nameless"],m||(i=o.keyAttribute||i("keyAttribute"))&&(p[i]=f),p[e]=getSlotContent(r,d,p[e]||l,a),""):getSlotContent(r,d,l,t)}d=a&&a.tagNamespace?`${a.tagNamespace}:${c}`:c;if("title"!==d||r.isSSR){u&&l&&(p.innerHTML=l);d=h(d,p,l||void 0);return{to:t.to,vnode:d}}document.title=l}function renderAttributes(t,r,n,e){var e=e["attributesFor"];if(e&&n){if(t.isSSR)return{to:"",vnode:h(`ssr-${e}`,n)};if(!cachedElements[e]){const[o,s]=Array.from(document.querySelectorAll(e));if(!o)return void console.error("Could not find element for selector",e,", won't render attributes");s&&console.warn("Found multiple elements for selector",e),cachedElements[e]={el:o,attrs:[]}}const{el:o,attrs:a}=cachedElements[e];for(const i in n){let e=getSlotContent(t,`${r}(${i})`,n[i],n);isArray(e)&&(e=e.join(",")),o.setAttribute(i,e||""),a.includes(i)||a.push(i)}for(const c of a.filter(e=>!n[e]))o.removeAttribute(c)}}function getSlotContent({metainfo:e,slots:t},r,n,o){const a=t&&t[r];if(!a||!isFunction(a))return n;const s={content:n,metainfo:e};o&&o.group&&({group:o,data:i}=o,s[o]=i);var i=a(s);if(i&&i.length){const c=i[0]["children"];return c?c.toString():""}return n}const hasSymbol="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag,PolySymbol=e=>hasSymbol?Symbol("[vue-meta]: "+e):"[vue-meta]: "+e,metaActiveKey=PolySymbol("meta_active");function applyDifference(e,t,r){for(const n in t)n in r?isObject(e[n])?applyDifference(e[n],t[n],r[n]):t[n]!==r[n]&&(e[n]=t[n]):e[n]=t[n];for(const o in r)t&&o in t||delete e[o]}function getCurrentManager(e){if(e=e||(getCurrentInstance()||void 0))return e.appContext.config.globalProperties.$metaManager}function useMeta(e,t){var r=getCurrentInstance()||void 0;if(!(t=!t&&r?getCurrentManager(r):t))throw new Error("No manager or current instance");isProxy(e)&&(watch(e,(e,t)=>{applyDifference(n.meta,e,t)}),e=e.value);const n=t.addMeta(e,r);return n}function useActiveMeta(){return inject(metaActiveKey)}const MetainfoImpl=defineComponent({name:"Metainfo",inheritAttrs:!1,setup(e,{slots:t}){return()=>{const e=getCurrentManager();if(e)return e.render({slots:t})}}}),Metainfo=MetainfoImpl,ssrAttribute="data-vm-ssr";function addVnode(e,t,r,n){const o=isArray(n)?n:[n];e?r.endsWith("Attrs")||o.forEach(e=>{e.props||(e.props={}),e.props[ssrAttribute]=!0}):o.forEach((e,t)=>{e.type===Comment&&o.splice(t,1)}),t[r]||(t[r]=[]),t[r].push(...o)}const createMetaManager=(e=!1,t,r)=>MetaManager.create(e,t||defaultConfig,r||defaultResolver);class MetaManager{isSSR=!1;config;target;resolver;ssrCleanedUp=!1;constructor(e,t,r,n){this.isSSR=e,this.config=t,this.target=r,n&&"setup"in n&&isFunction(n.setup)&&(this.resolver=n)}static create=(e,t,a)=>{var r=reactive({}),r=createMergedObject((e,t,r,n,o)=>isFunction(a)?a(e,t,r,n,o):a.resolve(e,t,r,n,o),r);return new MetaManager(e,t,r,a)};install(e){e.component("Metainfo",Metainfo),e.config.globalProperties.$metaManager=this,e.provide(metaActiveKey,this.target.context.active)}addMeta(e,t){t=t||(getCurrentInstance()||void 0);const r={removed:[]};var n={vm:t};const o=this["resolver"];o&&o.setup&&o.setup(n);const a=this.target.addSource(e,n,!0);n=e=>this.unmount(!!e,a,r,t);return t&&onUnmounted(n),{meta:a,onRemoved:e=>r.removed.push(e),unmount:n}}unmount(n,o,a,e){if(e){const s=e.proxy["$el"];if(s&&s.offsetParent){let r=new MutationObserver(e=>{for(var{removedNodes:t}of e)t&&t.forEach(e=>{e===s&&r&&(r.disconnect(),r=void 0,this.reallyUnmount(n,o,a))})});return void r.observe(s.parentNode,{childList:!0})}}this.reallyUnmount(n,o,a)}async reallyUnmount(e,t,r){this.target.delSource(t),!e&&r&&await Promise.all(r.removed.map(e=>e()))}render({slots:e}={}){var t,r=this.target.context.active,n=this["isSSR"];n||this.ssrCleanedUp||(this.ssrCleanedUp=!0,t=()=>{const e=document.querySelectorAll(`[${ssrAttribute}]`);e&&e.length&&e.forEach(e=>e.parentNode&&e.parentNode.removeChild(e))},"loading"===document.readyState?window.addEventListener("DOMContentLoaded",t,{once:!0}):t());const o={};for(const l in r){var a=this.config[l]||{};let t=renderMeta({isSSR:n,metainfo:r,slots:e},l,r[l],a);if(t){isArray(t)||(t=[t]);let e="base"!==l&&r[l].to;!e&&"to"in a&&(e=a.to),!e&&"attributesFor"in a&&(e=l);for(var{to:s,vnode:i}of t)addVnode(this.isSSR,o,s||e||"head",i)}}if(e)for(const u in e){var c="default"===u?"head":u;if("head"===c||"body"===c){const f=e[u];isFunction(f)&&addVnode(this.isSSR,o,c,f({metainfo:r}))}}return Object.keys(o).map(e=>{var t=o[e];return h(Teleport,{to:e},t)})}}const defaultOptions={keyName:"metaInfo"},createMixin=r=>({created(){var e=getCurrentInstance();if(e?.type&&r.keyName in e.type){const t=e.type[r.keyName];isFunction(t)?useMeta(computed(t.bind(this))):useMeta(t)}}}),install=(e,t={})=>{t=Object.assign({},defaultOptions,t);e.mixin(createMixin(t))};export{createMetaManager,defaultResolver as deepestResolver,defaultConfig,getCurrentManager,install as plugin,resolveOption,useActiveMeta,useMeta};