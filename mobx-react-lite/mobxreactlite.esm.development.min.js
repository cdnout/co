import{makeObservable,configure,getDependencyTree,Reaction,observable,runInAction}from"mobx";import React,{useState,forwardRef,memo}from"react";import{unstable_batchedUpdates}from"react-dom";if(!useState)throw new Error("mobx-react-lite requires React with Hooks support");if(!makeObservable)throw new Error("mobx-react-lite@3 requires mobx at least version 6 to be available");function defaultNoopBatch(e){e()}function observerBatching(e){e||(e=defaultNoopBatch,console.warn("[MobX] Failed to get unstable_batched updates from react-dom / react-native")),configure({reactionScheduler:e})}var isObserverBatched=function(){return console.warn("[MobX] Deprecated"),!0},deprecatedMessages=[];function useDeprecated(e){deprecatedMessages.includes(e)||(deprecatedMessages.push(e),console.warn(e))}function printDebugValue(e){return getDependencyTree(e)}var FinalizationRegistryLocal="undefined"==typeof FinalizationRegistry?void 0:FinalizationRegistry;function createTrackingData(e){return{reaction:e,mounted:!1,changedBeforeMount:!1,cleanAt:Date.now()+CLEANUP_LEAKED_REACTIONS_AFTER_MILLIS}}var CLEANUP_LEAKED_REACTIONS_AFTER_MILLIS=1e4,CLEANUP_TIMER_LOOP_MILLIS=1e4;function createReactionCleanupTrackingUsingFinalizationRegister(e){var o=new Map,a=1,i=new e(function(e){var r=o.get(e);r&&(r.reaction.dispose(),o.delete(e))});return{addReactionToTrack:function(e,r,t){var n=a++;return i.register(t,n,e),e.current=createTrackingData(r),e.current.finalizationRegistryCleanupToken=n,o.set(n,e.current),e.current},recordReactionAsCommitted:function(e){i.unregister(e),e.current&&e.current.finalizationRegistryCleanupToken&&o.delete(e.current.finalizationRegistryCleanupToken)},forceCleanupTimerToRunNowForTests:function(){},resetCleanupScheduleForTests:function(){}}}function _unsupportedIterableToArray(e,r){if(e){if("string"==typeof e)return _arrayLikeToArray(e,r);var t=Object.prototype.toString.call(e).slice(8,-1);return"Map"===(t="Object"===t&&e.constructor?e.constructor.name:t)||"Set"===t?Array.from(e):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?_arrayLikeToArray(e,r):void 0}}function _arrayLikeToArray(e,r){(null==r||r>e.length)&&(r=e.length);for(var t=0,n=new Array(r);t<r;t++)n[t]=e[t];return n}function _createForOfIteratorHelperLoose(e,r){var t="undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(t)return(t=t.call(e)).next.bind(t);if(Array.isArray(e)||(t=_unsupportedIterableToArray(e))||r&&e&&"number"==typeof e.length){t&&(e=t);var n=0;return function(){return n>=e.length?{done:!0}:{done:!1,value:e[n++]}}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function createTimerBasedReactionCleanupTracking(){var n,o=new Set;function a(){void 0===n&&(n=setTimeout(e,CLEANUP_TIMER_LOOP_MILLIS))}function e(){n=void 0;var t=Date.now();o.forEach(function(e){var r=e.current;r&&t>=r.cleanAt&&(r.reaction.dispose(),e.current=null,o.delete(e))}),0<o.size&&a()}return{addReactionToTrack:function(e,r,t){return e.current=createTrackingData(r),o.add(e),a(),e.current},recordReactionAsCommitted:function(e){o.delete(e)},forceCleanupTimerToRunNowForTests:function(){n&&(clearTimeout(n),e())},resetCleanupScheduleForTests:function(){if(0<o.size){for(var e=_createForOfIteratorHelperLoose(o);!(t=e()).done;){var r=t.value,t=r.current;t&&(t.reaction.dispose(),r.current=null)}o.clear()}n&&(clearTimeout(n),n=void 0)}}}var _ref=FinalizationRegistryLocal?createReactionCleanupTrackingUsingFinalizationRegister(FinalizationRegistryLocal):createTimerBasedReactionCleanupTracking(),addReactionToTrack=_ref.addReactionToTrack,recordReactionAsCommitted=_ref.recordReactionAsCommitted,resetCleanupScheduleForTests=_ref.resetCleanupScheduleForTests,globalIsUsingStaticRendering=!1;function enableStaticRendering(e){globalIsUsingStaticRendering=e}function isUsingStaticRendering(){return globalIsUsingStaticRendering}function observerComponentNameFor(e){return"observer"+e}var ObjectToBeRetainedByReact=function(){};function objectToBeRetainedByReactFactory(){return new ObjectToBeRetainedByReact}function useObserver(e,r){if(void 0===r&&(r="observed"),isUsingStaticRendering())return e();function t(){return i([])}var n,o,a=React.useState(objectToBeRetainedByReactFactory)[0],i=React.useState()[1],c=React.useRef(null);c.current||(n=new Reaction(observerComponentNameFor(r),function(){o.mounted?t():o.changedBeforeMount=!0}),o=addReactionToTrack(c,n,a));var s,u,a=c.current.reaction;if(React.useDebugValue(a,printDebugValue),React.useEffect(function(){return recordReactionAsCommitted(c),c.current?(c.current.mounted=!0,c.current.changedBeforeMount&&(c.current.changedBeforeMount=!1,t())):(c.current={reaction:new Reaction(observerComponentNameFor(r),function(){t()}),mounted:!0,changedBeforeMount:!1,cleanAt:1/0},t()),function(){c.current.reaction.dispose(),c.current=null}},[]),a.track(function(){try{s=e()}catch(e){u=e}}),u)throw u;return s}var warnObserverOptionsDeprecated=!0,hasSymbol="function"==typeof Symbol&&Symbol.for,ReactForwardRefSymbol=hasSymbol?Symbol.for("react.forward_ref"):"function"==typeof forwardRef&&forwardRef(function(e){return null}).$$typeof,ReactMemoSymbol=hasSymbol?Symbol.for("react.memo"):"function"==typeof memo&&memo(function(e){return null}).$$typeof;function observer(e,r){if(warnObserverOptionsDeprecated&&r&&(warnObserverOptionsDeprecated=!1,console.warn("[mobx-react-lite] `observer(fn, { forwardRef: true })` is depreacted, use `observer(React.forwardRef(fn))`")),ReactMemoSymbol&&e.$$typeof===ReactMemoSymbol)throw new Error("[mobx-react-lite] You are trying to use `observer` on a function component wrapped in either another `observer` or `React.memo`. The observer already applies 'React.memo' for you.");if(isUsingStaticRendering())return e;var r=null!=(o=null==r?void 0:r.forwardRef)&&o,t=e,n=e.displayName||e.name;if(ReactForwardRefSymbol&&e.$$typeof===ReactForwardRefSymbol&&(r=!0,"function"!=typeof(t=e.render)))throw new Error("[mobx-react-lite] `render` property of ForwardRef was not a function");var o=function(e,r){return useObserver(function(){return t(e,r)},n)};return""!==n&&(o.displayName=n),e.contextTypes&&(o.contextTypes=e.contextTypes),r&&(o=forwardRef(o)),copyStaticProperties(e,o=memo(o)),Object.defineProperty(o,"contextTypes",{set:function(){var e;throw new Error("[mobx-react-lite] `"+(this.displayName||(null==(e=this.type)?void 0:e.displayName)||"Component")+".contextTypes` must be set before applying `observer`.")}}),o}var hoistBlackList={$$typeof:!0,render:!0,compare:!0,type:!0,displayName:!0};function copyStaticProperties(r,t){Object.keys(r).forEach(function(e){hoistBlackList[e]||Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(r,e))})}function ObserverComponent(e){var r=e.children,e=e.render,e=r||e;return"function"!=typeof e?null:useObserver(e)}function ObserverPropsCheck(e,r,t,n,o){var a="function"==typeof e[r],i="function"==typeof e["children"===r?"render":"children"];return a&&i?new Error("MobX Observer: Do not use children and render in the same time in`"+t):a||i?null:new Error("Invalid prop `"+o+"` of type `"+typeof e[r]+"` supplied to `"+t+"`, expected `function`.")}function useLocalObservable(e,r){return useState(function(){return observable(e(),r,{autoBind:!0})})[0]}function useAsObservableSource(e){useDeprecated("[mobx-react-lite] 'useAsObservableSource' is deprecated, please store the values directly in an observable, for example by using 'useLocalObservable', and sync future updates using 'useEffect' when needed. See the README for examples.");var r=useState(function(){return observable(e,{},{deep:!1})})[0];return runInAction(function(){Object.assign(r,e)}),r}function useLocalStore(e,r){useDeprecated("[mobx-react-lite] 'useLocalStore' is deprecated, use 'useLocalObservable' instead.");var t=r&&useAsObservableSource(r);return useState(function(){return observable(e(t),void 0,{autoBind:!0})})[0]}function useObserver$1(e,r){return void 0===r&&(r="observed"),useDeprecated("[mobx-react-lite] 'useObserver(fn)' is deprecated. Use `<Observer>{fn}</Observer>` instead, or wrap the entire component in `observer`."),useObserver(e,r)}function useStaticRendering(e){console.warn("[mobx-react-lite] 'useStaticRendering' is deprecated, use 'enableStaticRendering' instead"),enableStaticRendering(e)}ObserverComponent.propTypes={children:ObserverPropsCheck,render:ObserverPropsCheck},ObserverComponent.displayName="Observer",observerBatching(unstable_batchedUpdates);export{ObserverComponent as Observer,resetCleanupScheduleForTests as clearTimers,enableStaticRendering,isObserverBatched,isUsingStaticRendering,observer,observerBatching,useAsObservableSource,useLocalObservable,useLocalStore,useObserver$1 as useObserver,useStaticRendering};