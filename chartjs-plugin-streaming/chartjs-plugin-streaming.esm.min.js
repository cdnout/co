import{registry,TimeScale,defaults,DatasetController,Chart}from"chart.js";import{valueOrDefault,each,requestAnimFrame,callback,noop,isFinite,clipArea,unclipArea,isNumber,_lookup,isArray,getRelativePosition}from"chart.js/helpers";function clamp(e,t,a){return Math.min(Math.max(e,t),a)}function resolveOption(e,t){var a=e.options.realtime,e=e.chart.options.plugins.streaming;return valueOrDefault(a[t],e[t])}function getAxisMap(e,{x:t,y:a},{xAxisID:i,yAxisID:o}){const r={};return each(t,e=>{r[e]={axisId:i}}),each(a,e=>{r[e]={axisId:o}}),r}const cancelAnimFrame="undefined"==typeof window?noop:window.cancelAnimationFrame;function startFrameRefreshTimer(i,o){if(!i.frameRequestID){const r=()=>{var e,t=i.nextRefresh||0,a=Date.now();t<=a&&(e=callback(o),t=1e3/(Math.max(e,0)||30),e=i.nextRefresh+t||0,i.nextRefresh=a<e?e:a+t),i.frameRequestID=requestAnimFrame.call(window,r)};i.frameRequestID=requestAnimFrame.call(window,r)}}function stopFrameRefreshTimer(e){var t=e.frameRequestID;t&&(cancelAnimFrame.call(window,t),delete e.frameRequestID)}function stopDataRefreshTimer(e){var t=e.refreshTimerID;t&&(clearInterval(t),delete e.refreshTimerID,delete e.refreshInterval)}function startDataRefreshTimer(t,a,e){t.refreshTimerID||(t.refreshTimerID=setInterval(()=>{var e=callback(a);t.refreshInterval===e||isNaN(e)||(stopDataRefreshTimer(t),startDataRefreshTimer(t,a,e))},e||0),t.refreshInterval=e||0)}function scaleValue(e,t,a){return t="number"==typeof t?t:e.parse(t),isFinite(t)?{value:e.getPixelForValue(t),transitionable:!0}:{value:a}}function updateBoxAnnotation(e,t,a){var{scales:i,chartArea:o}=t,{xScaleID:r,yScaleID:n,xMin:s,xMax:l,yMin:c,yMax:d}=a,u=i[r],m=i[n],{top:t,left:a,bottom:i,right:o}=o;const p=e.$streaming={};u&&(a=scaleValue(u,s,a),l=scaleValue(u,l,o),o=a.value>l.value,a.transitionable&&(p[o?"x2":"x"]={axisId:r}),l.transitionable&&(p[o?"x":"x2"]={axisId:r}),a.transitionable!==l.transitionable&&(p.width={axisId:r,reverse:a.transitionable})),m&&(t=scaleValue(m,c,t),d=scaleValue(m,d,i),i=t.value>d.value,t.transitionable&&(p[i?"y2":"y"]={axisId:n}),d.transitionable&&(p[i?"y":"y2"]={axisId:n}),t.transitionable!==d.transitionable&&(p.height={axisId:n,reverse:t.transitionable}))}function updateLineAnnotation(e,t,a){var{scales:i,chartArea:o}=t,{scaleID:r,value:n}=a;const s=i[r];var{top:l,left:c,bottom:d,right:u}=o;const m=e.$streaming={};if(s){var p=s.isHorizontal();return scaleValue(s,n).transitionable&&(m[p?"x":"y"]={axisId:r},m[p?"x2":"y2"]={axisId:r}),p?{top:l,bottom:d}:{left:c,right:u}}var{xScaleID:t,yScaleID:o,xMin:e,xMax:n,yMin:r,yMax:p}=a,a=i[t],i=i[o];const h={};return a&&(e=scaleValue(a,e),n=scaleValue(a,n),e.transitionable?m.x={axisId:t}:h.left=c,n.transitionable?m.x2={axisId:t}:h.right=u),i&&(r=scaleValue(i,r),p=scaleValue(i,p),r.transitionable?m.y={axisId:o}:h.top=l,p.transitionable?m.y2={axisId:o}:h.bottom=d),h}function updatePointAnnotation(e,t,a){var i=t.scales,{xScaleID:o,yScaleID:r,xValue:n,yValue:t}=a,a=i[o],i=i[r];const s=e.$streaming={};a&&scaleValue(a,n).transitionable&&(s.x={axisId:o}),i&&scaleValue(i,t).transitionable&&(s.y={axisId:r})}function initAnnotationPlugin(){const e=registry.getElement("boxAnnotation"),t=registry.getElement("lineAnnotation"),a=registry.getElement("pointAnnotation"),i=e.prototype.resolveElementProperties,o=t.prototype.resolveElementProperties,r=a.prototype.resolveElementProperties;e.prototype.resolveElementProperties=function(e,t){return updateBoxAnnotation(this,e,t),i.call(this,e,t)},t.prototype.resolveElementProperties=function(e,t){var a=e.chartArea;e.chartArea=updateLineAnnotation(this,e,t);t=o.call(this,e,t);return e.chartArea=a,t},a.prototype.resolveElementProperties=function(e,t){return updatePointAnnotation(this,e,t),r.call(this,e,t)}}function attachChart$1(e,t){const a=t.$streaming;if(a.annotationPlugin!==e){const r=e.afterUpdate;initAnnotationPlugin(),(a.annotationPlugin=e).afterUpdate=(e,t,a)=>{var i=t.mode,o=a.animation;"quiet"===i&&(a.animation=!1),r.call(this,e,t,a),"quiet"===i&&(a.animation=o)}}}function getElements(e){const t=e.$streaming.annotationPlugin;if(t){e=t._getState(e);return e&&e.elements||[]}return[]}function detachChart$1(e){delete e.$streaming.annotationPlugin}const transitionKeys$1={x:["x","caretX"],y:["y","caretY"]};function update$1(...e){var t=this,a=t.getActiveElements()[0];a?(a=t._chart.getDatasetMeta(a.datasetIndex),t.$streaming=getAxisMap(t,transitionKeys$1,a)):t.$streaming={},t.constructor.prototype.update.call(t,...e)}const chartStates=new WeakMap;function getState(e){let t=chartStates.get(e);return t||(t={originalScaleOptions:{}},chartStates.set(e,t)),t}function removeState(e){chartStates.delete(e)}function storeOriginalScaleOptions(e){const{originalScaleOptions:a}=getState(e),i=e.scales;return each(i,e=>{var t=e.id;a[t]||(a[t]={duration:resolveOption(e,"duration"),delay:resolveOption(e,"delay")})}),each(a,(e,t)=>{i[t]||delete a[t]}),a}function zoomRealTimeScale(e,t,a,i){var{chart:o,axis:r}=e,{minDuration:n=0,maxDuration:s=1/0,minDelay:l=-1/0,maxDelay:c=1/0}=i&&i[r]||{};const d=e.options.realtime;i=resolveOption(e,"duration"),r=resolveOption(e,"delay"),s=clamp(i*(2-t),n,s);let u,m;return storeOriginalScaleOptions(o),u=e.isHorizontal()?(e.right-a.x)/(e.right-e.left):(e.bottom-a.y)/(e.bottom-e.top),m=r+u*(i-s),d.duration=s,d.delay=clamp(m,l,c),s!==e.max-e.min}function panRealTimeScale(e,t,a){var{chart:i,axis:o}=e,{minDelay:a=-1/0,maxDelay:o=1/0}=a&&a[o]||{},t=resolveOption(e,"delay")+(e.getValueForPixel(t)-e.getValueForPixel(0));return storeOriginalScaleOptions(i),e.options.realtime.delay=clamp(t,a,o),!0}function resetRealTimeScaleOptions(e){const a=storeOriginalScaleOptions(e);each(e.scales,e=>{const t=e.options.realtime;t&&((e=a[e.id])?(t.duration=e.duration,t.delay=e.delay):(delete t.duration,delete t.delay))})}function initZoomPlugin(e){e.zoomFunctions.realtime=zoomRealTimeScale,e.panFunctions.realtime=panRealTimeScale}function attachChart(e,t){const a=t.$streaming;if(a.zoomPlugin!==e){const i=a.resetZoom=t.resetZoom;initZoomPlugin(e),t.resetZoom=e=>{resetRealTimeScaleOptions(t),i(e)},a.zoomPlugin=e}}function detachChart(e){const t=e.$streaming;t.zoomPlugin&&(e.resetZoom=t.resetZoom,removeState(e),delete t.resetZoom,delete t.zoomPlugin)}const INTERVALS={millisecond:{common:!0,size:1,steps:[1,2,5,10,20,50,100,250,500]},second:{common:!0,size:1e3,steps:[1,2,5,10,15,30]},minute:{common:!0,size:6e4,steps:[1,2,5,10,15,30]},hour:{common:!0,size:36e5,steps:[1,2,3,6,12]},day:{common:!0,size:864e5,steps:[1,2,5]},week:{common:!1,size:6048e5,steps:[1,2,3,4]},month:{common:!0,size:2628e6,steps:[1,2,3]},quarter:{common:!1,size:7884e6,steps:[1,2,3,4]},year:{common:!0,size:3154e7}},UNITS=Object.keys(INTERVALS);function determineStepSize(e,t,a,i){var o=t-e,{size:r,steps:n}=INTERVALS[a];let s;if(!n)return Math.ceil(o/(i*r));for(let e=0,t=n.length;e<t&&(s=n[e],!(Math.ceil(o/(r*s))<=i));++e);return s}function determineUnitForAutoTicks(t,e,a,i){var o=a-e,r=UNITS.length;for(let e=UNITS.indexOf(t);e<r-1;++e){var{common:n,size:s,steps:l}=INTERVALS[UNITS[e]],l=l?l[l.length-1]:Number.MAX_SAFE_INTEGER;if(n&&Math.ceil(o/(l*s))<=i)return UNITS[e]}return UNITS[r-1]}function determineMajorUnit(a){for(let e=UNITS.indexOf(a)+1,t=UNITS.length;e<t;++e)if(INTERVALS[UNITS[e]].common)return UNITS[e]}function addTick(e,t,a){var i,o;a?a.length&&({lo:i,hi:o}=_lookup(a,t),e[a[i]>=t?a[i]:a[o]]=!0):e[t]=!0}const datasetPropertyKeys=["pointBackgroundColor","pointBorderColor","pointBorderWidth","pointRadius","pointRotation","pointStyle","pointHitRadius","pointHoverBackgroundColor","pointHoverBorderColor","pointHoverBorderWidth","pointHoverRadius","backgroundColor","borderColor","borderSkipped","borderWidth","hoverBackgroundColor","hoverBorderColor","hoverBorderWidth","hoverRadius","hitRadius","radius","rotation"];function clean(e){const{chart:c,id:d,max:u}=e;var t=resolveOption(e,"duration"),a=resolveOption(e,"delay");const m=resolveOption(e,"ttl"),p=resolveOption(e,"pause"),h=Date.now()-(isNaN(m)?t+a:m);let f,v,g,y;each(c.data.datasets,(t,a)=>{var e=c.getDatasetMeta(a),i=d===e.xAxisID?"x":d===e.yAxisID&&"y";if(i){const s=e.controller,l=t.data;var o=l.length;if(p){for(f=0;f<o;++f){var r=s.getParsed(f);if(r&&!(r[i]<u))break}v=f+2}else v=0;for(f=v;f<o;++f){var n=s.getParsed(f);if(!(n&&n[i]<=h))break}g=f-v,isNaN(m)&&(g=Math.max(g-2,0)),l.splice(v,g),each(datasetPropertyKeys,e=>{isArray(t[e])&&t[e].splice(v,g)}),each(t.datalabels,e=>{isArray(e)&&e.splice(v,g)}),"object"!=typeof l[0]&&(y={start:v,count:g}),each(c._active,(e,t)=>{e.datasetIndex===a&&e.index>=v&&(e.index>=v+g?e.index-=g:c._active.splice(t,1))},null,!0)}}),y&&c.data.labels.splice(y.start,y.count)}function transition(i,o,r){const n=i.$animations||{};each(i.$streaming,(e,t)=>{if(e.axisId===o){e=e.reverse?-r:r;const a=n[t];isFinite(i[t])&&(i[t]-=e),a&&(a._from-=e,a._to-=e)}})}function scroll(e){const{chart:o,id:r,$realtime:t}=e;var a=resolveOption(e,"duration"),i=resolveOption(e,"delay"),n=e.isHorizontal(),s=n?e.width:e.height,l=Date.now(),c=o.tooltip,d=getElements(o);let u=s*(l-t.head)/a;n===!!e.options.reverse&&(u=-u),each(o.data.datasets,(e,t)=>{const{data:a=[],dataset:i}=o.getDatasetMeta(t);for(let e=0,t=a.length;e<t;++e)transition(a[e],r,u);i&&(transition(i,r,u),delete i._path)});for(let e=0,t=d.length;e<t;++e)transition(d[e],r,u);c&&transition(c,r,u),e.max=l-i,e.min=e.max-a,t.head=l}class RealTimeScale extends TimeScale{constructor(e){super(e),this.$realtime=this.$realtime||{}}init(e,t){const a=this;super.init(e,t),startDataRefreshTimer(a.$realtime,()=>{const e=a.chart;var t=resolveOption(a,"onRefresh");return callback(t,[e],a),clean(a),e.update("quiet"),resolveOption(a,"refresh")})}update(e,t,a){const i=this,{$realtime:o,options:r}=i,{bounds:n,offset:s,ticks:l}=r,{autoSkip:c,source:d,major:u}=l;var m=u.enabled;resolveOption(i,"pause")?stopFrameRefreshTimer(o):(o.frameRequestID||(o.head=Date.now()),startFrameRefreshTimer(o,()=>{var e=i.chart,t=e.$streaming;return scroll(i),t&&callback(t.render,[e]),resolveOption(i,"frameRate")})),r.bounds=void 0,r.offset=!1,l.autoSkip=!1,l.source="auto"===d?"":d,u.enabled=!0,super.update(e,t,a),r.bounds=n,r.offset=s,l.autoSkip=c,l.source=d,u.enabled=m}buildTicks(){var e=this,t=resolveOption(e,"duration"),a=resolveOption(e,"delay"),i=e.$realtime.head-a,a=i-t;const o=[1e15,i],r=[-1e15,a];Object.defineProperty(e,"min",{get:()=>r.shift(),set:noop}),Object.defineProperty(e,"max",{get:()=>o.shift(),set:noop});t=super.buildTicks();return delete e.min,delete e.max,e.min=a,e.max=i,t}calculateLabelRotation(){const e=this.options.ticks;var t=e.maxRotation;e.maxRotation=e.minRotation||0,super.calculateLabelRotation(),e.maxRotation=t}fit(){var e=this,t=e.options;super.fit(),t.ticks.display&&t.display&&e.isHorizontal()&&(e.paddingLeft=3,e.paddingRight=3,e._handleMargins())}draw(e){var{chart:t,ctx:a}=this,t=this.isHorizontal()?{left:e.left,top:0,right:e.right,bottom:t.height}:{left:0,top:e.top,right:t.width,bottom:e.bottom};this._gridLineItems=null,this._labelItems=null,clipArea(a,t),super.draw(e),unclipArea(a)}destroy(){var e=this.$realtime;stopFrameRefreshTimer(e),stopDataRefreshTimer(e)}_generate(){var e=this;const t=e._adapter;var a=resolveOption(e,"duration"),i=resolveOption(e,"delay"),o=resolveOption(e,"refresh"),r=e.$realtime.head-i,n=r-a,s=e._getLabelCapacity(n),{time:l,ticks:c}=e.options,d=l.unit||determineUnitForAutoTicks(l.minUnit,n,r,s),u=determineMajorUnit(d),m=l.stepSize||determineStepSize(n,r,d,s),p="week"===d&&l.isoWeekday,i=c.major.enabled,a=isNumber(p)||!0===p,s=INTERVALS[d],h={};let f=n,v,g;if(a&&(f=+t.startOf(f,"isoWeek",p)),f=+t.startOf(f,a?"day":d),t.diff(r,n,d)>1e5*m)throw new Error(n+" and "+r+" are too far apart with stepSize of "+m+" "+d);v=f,i&&u&&!a&&!l.round&&(v=+t.startOf(v,u),v=+t.add(v,~~((f-v)/(s.size*m))*m,d));var y="data"===c.source&&e.getDataTimestamps();for(g=0;v<r+o;v=+t.add(v,m,d),g++)addTick(h,v,y);return v!==r+o&&1!==g||addTick(h,v,y),Object.keys(h).sort((e,t)=>e-t).map(e=>+e)}}RealTimeScale.id="realtime",RealTimeScale.defaults={bounds:"data",adapters:{},time:{parser:!1,unit:!1,round:!1,isoWeekday:!1,minUnit:"millisecond",displayFormats:{}},realtime:{},ticks:{autoSkip:!1,source:"auto",major:{enabled:!0}}},defaults.describe("scale.realtime",{_scriptable:e=>"onRefresh"!==e});var version="2.0.0";defaults.set("transitions",{quiet:{animation:{duration:0}}});const transitionKeys={x:["x","cp1x","cp2x"],y:["y","cp1y","cp2y"]};function update(e){const i=this;"quiet"===e&&each(i.data.datasets,(e,t)=>{const a=i.getDatasetMeta(t).controller;a._setStyle=function(e,t,a,i){DatasetController.prototype._setStyle.call(this,e,t,"quiet",i)}}),Chart.prototype.update.call(i,e),"quiet"===e&&each(i.data.datasets,(e,t)=>{delete i.getDatasetMeta(t).controller._setStyle})}function render(t){const a=t.$streaming;t.render(),a.lastMouseEvent&&setTimeout(()=>{var e=a.lastMouseEvent;e&&t._eventHandler(e)},0)}var StreamingPlugin={id:"streaming",version:version,beforeInit(a){const i=a.$streaming=a.$streaming||{render:render},e=i.canvas=a.canvas;var t=i.mouseEventListener=e=>{var t=getRelativePosition(e,a);i.lastMouseEvent={type:"mousemove",chart:a,native:e,x:t.x,y:t.y}};e.addEventListener("mousedown",t),e.addEventListener("mouseup",t)},afterInit(e){e.update=update},beforeUpdate(t){const{scales:e,elements:a}=t.options,i=t.tooltip;each(e,({type:e})=>{"realtime"===e&&(a.line.capBezierPoints=!1)}),i&&(i.update=update$1);try{attachChart$1(registry.getPlugin("annotation"),t)}catch(e){detachChart$1(t)}try{attachChart(registry.getPlugin("zoom"),t)}catch(e){detachChart(t)}},beforeDatasetUpdate(e,t){var{meta:a,mode:t}=t;if("quiet"===t){const{controller:i,$animations:o}=a;o&&o.visible&&o.visible._active&&(i.updateElement=noop,i.updateSharedOptions=noop)}},afterDatasetUpdate(e,t){var{meta:a,mode:t}=t;const{data:i=[],dataset:o,controller:r}=a;for(let e=0,t=i.length;e<t;++e)i[e].$streaming=getAxisMap(i[e],transitionKeys,a);o&&(o.$streaming=getAxisMap(o,transitionKeys,a)),"quiet"===t&&(delete r.updateElement,delete r.updateSharedOptions)},beforeDatasetDraw(e,t){var{ctx:a,chartArea:i,width:o,height:e}=e;const{xAxisID:r,yAxisID:n,controller:s}=t.meta,l={left:0,top:0,right:o,bottom:e};r&&s.getScaleForId(r)instanceof RealTimeScale&&(l.left=i.left,l.right=i.right),n&&s.getScaleForId(n)instanceof RealTimeScale&&(l.top=i.top,l.bottom=i.bottom),clipArea(a,l)},afterDatasetDraw(e){unclipArea(e.ctx)},beforeEvent(e,t){const a=e.$streaming;t=t.event;"mousemove"===t.type?a.lastMouseEvent=t:"mouseout"===t.type&&delete a.lastMouseEvent},destroy(e){const{scales:t,$streaming:a,tooltip:i}=e,{canvas:o,mouseEventListener:r}=a;delete e.update,i&&delete i.update,o.removeEventListener("mousedown",r),o.removeEventListener("mouseup",r),each(t,e=>{e instanceof RealTimeScale&&e.destroy()})},defaults:{duration:1e4,delay:0,frameRate:30,refresh:1e3,onRefresh:null,pause:!1,ttl:void 0},descriptors:{_scriptable:e=>"onRefresh"!==e}};const registerables=[StreamingPlugin,RealTimeScale];export default registerables;export{RealTimeScale,StreamingPlugin};