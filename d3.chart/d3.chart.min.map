{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///d3.chart.min.js","webpack:///webpack/bootstrap 6342383388dbd94da3e1","webpack:///./chart-extensions.js","webpack:///external \"d3\"","webpack:///./chart.js","webpack:///./assert.js","webpack:///./layer-extensions.js","webpack:///./layer.js"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_1__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","__WEBPACK_AMD_DEFINE_RESULT__","d3","Chart","assert","test","version","chart","name","arguments","length","extend","apply","selection","prototype","chartName","options","_chart","ChartCtor","enter","transition","undefined","object","argsIndex","argsLength","iteratee","key","hasOwnProp","Object","hasOwnProperty","initCascade","instance","args","ctor","constructor","sup","__super__","initialize","transformCascade","data","transform","chartOptions","base","_layers","_attached","_events","unlayer","layer","draw","attach","attachmentName","layerName","attachmentData","demux","on","callback","context","events","push","once","self","off","names","n","event","i","j","keys","splice","trigger","ev","Array","slice","protoProps","staticProps","child","parent","Surrogate","message","Error","Layer","eventName","dataBind","insert","lifecycleRe","_base","_handlers","handler","idx","handlers","bound","entering","method","len","exit","l","empty"],"mappings":"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","file":"d3.chart.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"d3\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"d3.chart\", [\"d3\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"d3.chart\"] = factory(require(\"d3\"));\n\telse\n\t\troot[\"d3.chart\"] = factory(root[\"d3\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","/*!\n * d3.chart - v0.3.0\n * License: MIT\n * Date: 2016-01-23\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"d3\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"d3.chart\", [\"d3\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"d3.chart\"] = factory(require(\"d3\"));\n\telse\n\t\troot[\"d3.chart\"] = factory(root[\"d3\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {\n\t\t\"use strict\";\n\t\tvar d3 = __webpack_require__(1);\n\t\n\t\tvar Chart = __webpack_require__(2);\n\t\tvar assert = __webpack_require__(3);\n\t\n\t\tassert(/^3\\./.test(d3.version), \"d3.js version 3 is required\");\n\t\n\t\t__webpack_require__(4);\n\t\n\t\t/**\n\t\t * A namespace defined by [the D3.js library](http://d3js.org/). The d3.chart\n\t\t * API is defined within this namespace.\n\t\t * @namespace d3\n\t\t */\n\t\n\t\t/**\n\t\t * A constructor function defined by [the D3.js library](http://d3js.org/).\n\t\t * @constructor d3.selection\n\t\t * @memberof d3\n\t\t */\n\t\n\t\t/**\n\t\t * Create a new chart constructor or return a previously-created chart\n\t\t * constructor.\n\t\t *\n\t\t * @static\n\t\t * @memberof d3\n\t\t * @externalExample {runnable} chart\n\t\t *\n\t\t * @param {String} name If no other arguments are specified, return the\n\t\t *        previously-created chart with this name.\n\t\t * @param {Object} protoProps If specified, this value will be forwarded to\n\t\t *        {@link Chart.extend} and used to create a new chart.\n\t\t * @param {Object} staticProps If specified, this value will be forwarded to\n\t\t *        {@link Chart.extend} and used to create a new chart.\n\t\t */\n\t\td3.chart = function(name) {\n\t\t\tif (arguments.length === 0) {\n\t\t\t\treturn Chart;\n\t\t\t} else if (arguments.length === 1) {\n\t\t\t\treturn Chart[name];\n\t\t\t}\n\t\n\t\t\treturn Chart.extend.apply(Chart, arguments);\n\t\t};\n\t\n\t\t/**\n\t\t * Instantiate a chart or return the chart that the current selection belongs\n\t\t * to.\n\t\t *\n\t\t * @externalExample {runnable} selection-chart\n\t\t *\n\t\t * @param {String} [chartName] The name of the chart to instantiate. If the\n\t\t *        name is unspecified, this method will return the chart that the\n\t\t *        current selection belongs to.\n\t\t * @param {mixed} options The options to use when instantiated the new chart.\n\t\t *        See {@link Chart} for more information.\n\t\t */\n\t\td3.selection.prototype.chart = function(chartName, options) {\n\t\t\t// Without an argument, attempt to resolve the current selection's\n\t\t\t// containing d3.chart.\n\t\t\tif (arguments.length === 0) {\n\t\t\t\treturn this._chart;\n\t\t\t}\n\t\t\tvar ChartCtor = Chart[chartName];\n\t\t\tassert(ChartCtor, \"No chart registered with name '\" + chartName + \"'\");\n\t\n\t\t\treturn new ChartCtor(this, options);\n\t\t};\n\t\n\t\t// Implement the zero-argument signature of `d3.selection.prototype.chart`\n\t\t// for all selection types.\n\t\td3.selection.enter.prototype.chart = function() {\n\t\t\treturn this._chart;\n\t\t};\n\t\td3.transition.prototype.chart = d3.selection.enter.prototype.chart;\n\t\n\t\tmodule.exports = d3.chart;\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {\n\t\t\"use strict\";\n\t\tvar assert = __webpack_require__(3);\n\t\tvar hasOwnProp = Object.hasOwnProperty;\n\t\n\t\t// extend\n\t\t// Borrowed from Underscore.js\n\t\tfunction extend(object) {\n\t\t\tvar argsIndex, argsLength, iteratee, key;\n\t\t\tif (!object) {\n\t\t\t\treturn object;\n\t\t\t}\n\t\t\targsLength = arguments.length;\n\t\t\tfor (argsIndex = 1; argsIndex < argsLength; argsIndex++) {\n\t\t\t\titeratee = arguments[argsIndex];\n\t\t\t\tif (iteratee) {\n\t\t\t\t\tfor (key in iteratee) {\n\t\t\t\t\t\tobject[key] = iteratee[key];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn object;\n\t\t}\n\t\n\t\t/**\n\t\t * Call the {@Chart#initialize} method up the inheritance chain, starting with\n\t\t * the base class and continuing \"downward\".\n\t\t *\n\t\t * @private\n\t\t */\n\t\tvar initCascade = function(instance, args) {\n\t\t\tvar ctor = this.constructor;\n\t\t\tvar sup = ctor.__super__;\n\t\t\tif (sup) {\n\t\t\t\tinitCascade.call(sup, instance, args);\n\t\t\t}\n\t\n\t\t\t// Do not invoke the `initialize` method on classes further up the\n\t\t\t// prototype chain (again).\n\t\t\tif (hasOwnProp.call(ctor.prototype, \"initialize\")) {\n\t\t\t\tthis.initialize.apply(instance, args);\n\t\t\t}\n\t\t};\n\t\n\t\t/**\n\t\t * Call the `transform` method down the inheritance chain, starting with the\n\t\t * instance and continuing \"upward\". The result of each transformation should\n\t\t * be supplied as input to the next.\n\t\t *\n\t\t * @private\n\t\t */\n\t\tvar transformCascade = function(instance, data) {\n\t\t\tvar ctor = this.constructor;\n\t\t\tvar sup = ctor.__super__;\n\t\n\t\t\t// Unlike `initialize`, the `transform` method has significance when\n\t\t\t// attached directly to a chart instance. Ensure that this transform takes\n\t\t\t// first but is not invoked on later recursions.\n\t\t\tif (this === instance && hasOwnProp.call(this, \"transform\")) {\n\t\t\t\tdata = this.transform(data);\n\t\t\t}\n\t\n\t\t\t// Do not invoke the `transform` method on classes further up the prototype\n\t\t\t// chain (yet).\n\t\t\tif (hasOwnProp.call(ctor.prototype, \"transform\")) {\n\t\t\t\tdata = ctor.prototype.transform.call(instance, data);\n\t\t\t}\n\t\n\t\t\tif (sup) {\n\t\t\t\tdata = transformCascade.call(sup, instance, data);\n\t\t\t}\n\t\n\t\t\treturn data;\n\t\t};\n\t\n\t\t/**\n\t\t * Create a d3.chart\n\t\t *\n\t\t * @constructor\n\t\t * @externalExample {runnable} chart\n\t\t *\n\t\t * @param {d3.selection} selection The chart's \"base\" DOM node. This should\n\t\t *        contain any nodes that the chart generates.\n\t\t * @param {mixed} chartOptions A value for controlling how the chart should be\n\t\t *        created. This value will be forwarded to {@link Chart#initialize}, so\n\t\t *        charts may define additional properties for consumers to modify their\n\t\t *        behavior during initialization. The following attributes will be\n\t\t *        copied onto the chart instance (if present):\n\t\t * @param {Function} [chartOptions.transform] - A data transformation function\n\t\t *        unique to the Chart instance being created. If specified, this\n\t\t *        function will be invoked after all inherited implementations as part\n\t\t *        of the `Chart#draw` operation.\n\t\t * @param {Function} [chartOptions.demux] - A data filtering function for\n\t\t *        attachment charts. If specified, this function will be invoked with\n\t\t *        every {@link Chart#draw|draw} operation and provided with two\n\t\t *        arguments: the attachment name (see {@link Chart#attach}) and the\n\t\t *        data.\n\t\t *\n\t\t * @constructor\n\t\t */\n\t\tvar Chart = function(selection, chartOptions) {\n\t\t\tthis.base = selection;\n\t\t\tthis._layers = {};\n\t\t\tthis._attached = {};\n\t\t\tthis._events = {};\n\t\n\t\t\tif (chartOptions && chartOptions.transform) {\n\t\t\t\tthis.transform = chartOptions.transform;\n\t\t\t}\n\t\n\t\t\tinitCascade.call(this, this, [chartOptions]);\n\t\t};\n\t\n\t\t/**\n\t\t * Set up a chart instance. This method is intended to be overridden by Charts\n\t\t * authored with this library. It will be invoked with a single argument: the\n\t\t * `options` value supplied to the {@link Chart|constructor}.\n\t\t *\n\t\t * For charts that are defined as extensions of other charts using\n\t\t * `Chart.extend`, each chart's `initilize` method will be invoked starting\n\t\t * with the \"oldest\" ancestor (see the private {@link initCascade} function for\n\t\t * more details).\n\t\t */\n\t\tChart.prototype.initialize = function() {};\n\t\n\t\t/**\n\t\t * Remove a layer from the chart.\n\t\t *\n\t\t * @externalExample chart-unlayer\n\t\t *\n\t\t * @param {String} name The name of the layer to remove.\n\t\t *\n\t\t * @returns {Layer} The layer removed by this operation.\n\t\t */\n\t\tChart.prototype.unlayer = function(name) {\n\t\t\tvar layer = this.layer(name);\n\t\n\t\t\tdelete this._layers[name];\n\t\t\tdelete layer._chart;\n\t\n\t\t\treturn layer;\n\t\t};\n\t\n\t\t/**\n\t\t * Interact with the chart's {@link Layer|layers}.\n\t\t *\n\t\t * If only a `name` is provided, simply return the layer registered to that\n\t\t * name (if any).\n\t\t *\n\t\t * If a `name` and `selection` are provided, treat the `selection` as a\n\t\t * previously-created layer and attach it to the chart with the specified\n\t\t * `name`.\n\t\t *\n\t\t * If all three arguments are specified, initialize a new {@link Layer} using\n\t\t * the specified `selection` as a base passing along the specified `options`.\n\t\t *\n\t\t * The {@link Layer.draw} method of attached layers will be invoked\n\t\t * whenever this chart's {@link Chart#draw} is invoked and will receive the\n\t\t * data (optionally modified by the chart's {@link Chart#transform} method.\n\t\t *\n\t\t * @externalExample chart-layer\n\t\t *\n\t\t * @param {String} name Name of the layer to attach or retrieve.\n\t\t * @param {d3.selection|Layer} [selection] The layer's base or a\n\t\t *        previously-created {@link Layer}.\n\t\t * @param {Object} [options] Options to be forwarded to {@link Layer|the Layer\n\t\t *        constructor}\n\t\t *\n\t\t * @returns {Layer}\n\t\t */\n\t\tChart.prototype.layer = function(name, selection, options) {\n\t\t\tvar layer;\n\t\n\t\t\tif (arguments.length === 1) {\n\t\t\t\treturn this._layers[name];\n\t\t\t}\n\t\n\t\t\t// we are reattaching a previous layer, which the\n\t\t\t// selection argument is now set to.\n\t\t\tif (arguments.length === 2) {\n\t\n\t\t\t\tif (typeof selection.draw === \"function\") {\n\t\t\t\t\tselection._chart = this;\n\t\t\t\t\tthis._layers[name] = selection;\n\t\t\t\t\treturn this._layers[name];\n\t\n\t\t\t\t} else {\n\t\t\t\t\tassert(false, \"When reattaching a layer, the second argument \" +\n\t\t\t\t\t\t\"must be a d3.chart layer\");\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tlayer = selection.layer(options);\n\t\n\t\t\tthis._layers[name] = layer;\n\t\n\t\t\tselection._chart = this;\n\t\n\t\t\treturn layer;\n\t\t};\n\t\n\t\t/**\n\t\t * Register or retrieve an \"attachment\" Chart. The \"attachment\" chart's `draw`\n\t\t * method will be invoked whenever the containing chart's `draw` method is\n\t\t * invoked.\n\t\t *\n\t\t * @externalExample chart-attach\n\t\t *\n\t\t * @param {String} attachmentName Name of the attachment\n\t\t * @param {Chart} [chart] d3.chart to register as a mix in of this chart. When\n\t\t *        unspecified, this method will return the attachment previously\n\t\t *        registered with the specified `attachmentName` (if any).\n\t\t *\n\t\t * @returns {Chart} Reference to this chart (chainable).\n\t\t */\n\t\tChart.prototype.attach = function(attachmentName, chart) {\n\t\t\tif (arguments.length === 1) {\n\t\t\t\treturn this._attached[attachmentName];\n\t\t\t}\n\t\n\t\t\tthis._attached[attachmentName] = chart;\n\t\t\treturn chart;\n\t\t};\n\t\n\t\t/**\n\t\t * A \"hook\" method that you may define to modify input data before it is used\n\t\t * to draw the chart's layers and attachments. This method will be used by all\n\t\t * sub-classes (see {@link transformCascade} for details).\n\t\t *\n\t\t * Note you will most likely never call this method directly, but rather\n\t\t * include it as part of a chart definition, and then rely on d3.chart to\n\t\t * invoke it when you draw the chart with {@link Chart#draw}.\n\t\t *\n\t\t * @externalExample {runnable} chart-transform\n\t\t *\n\t\t * @param {Array} data Input data provided to @link Chart#draw}.\n\t\t *\n\t\t * @returns {mixed} Data to be used in drawing the chart's layers and\n\t\t *                  attachments.\n\t\t */\n\t\tChart.prototype.transform = function(data) {\n\t\t\treturn data;\n\t\t};\n\t\n\t\t/**\n\t\t * Update the chart's representation in the DOM, drawing all of its layers and\n\t\t * any \"attachment\" charts (as attached via {@link Chart#attach}).\n\t\t *\n\t\t * @externalExample chart-draw\n\t\t *\n\t\t * @param {Object} data Data to pass to the {@link Layer#draw|draw method} of\n\t\t *        this cart's {@link Layer|layers} (if any) and the {@link\n\t\t *        Chart#draw|draw method} of this chart's attachments (if any).\n\t\t */\n\t\tChart.prototype.draw = function(data) {\n\t\n\t\t\tvar layerName, attachmentName, attachmentData;\n\t\n\t\t\tdata = transformCascade.call(this, this, data);\n\t\n\t\t\tfor (layerName in this._layers) {\n\t\t\t\tthis._layers[layerName].draw(data);\n\t\t\t}\n\t\n\t\t\tfor (attachmentName in this._attached) {\n\t\t\t\tif (this.demux) {\n\t\t\t\t\tattachmentData = this.demux(attachmentName, data);\n\t\t\t\t} else {\n\t\t\t\t\tattachmentData = data;\n\t\t\t\t}\n\t\t\t\tthis._attached[attachmentName].draw(attachmentData);\n\t\t\t}\n\t\t};\n\t\n\t\t/**\n\t\t * Function invoked with the context specified when the handler was bound (via\n\t\t * {@link Chart#on} {@link Chart#once}).\n\t\t *\n\t\t * @callback ChartEventHandler\n\t\t * @param {...*} arguments Invoked with the arguments passed to {@link\n\t\t *         Chart#trigger}\n\t\t */\n\t\n\t\t/**\n\t\t * Subscribe a callback function to an event triggered on the chart. See {@link\n\t\t * Chart#once} to subscribe a callback function to an event for one occurence.\n\t\t *\n\t\t * @externalExample {runnable} chart-on\n\t\t *\n\t\t * @param {String} name Name of the event\n\t\t * @param {ChartEventHandler} callback Function to be invoked when the event\n\t\t *        occurs\n\t\t * @param {Object} [context] Value to set as `this` when invoking the\n\t\t *        `callback`. Defaults to the chart instance.\n\t\t *\n\t\t * @returns {Chart} A reference to this chart (chainable).\n\t\t */\n\t\tChart.prototype.on = function(name, callback, context) {\n\t\t\tvar events = this._events[name] || (this._events[name] = []);\n\t\t\tevents.push({\n\t\t\t\tcallback: callback,\n\t\t\t\tcontext: context || this,\n\t\t\t\t_chart: this\n\t\t\t});\n\t\t\treturn this;\n\t\t};\n\t\n\t\t/**\n\t\t * Subscribe a callback function to an event triggered on the chart. This\n\t\t * function will be invoked at the next occurance of the event and immediately\n\t\t * unsubscribed. See {@link Chart#on} to subscribe a callback function to an\n\t\t * event indefinitely.\n\t\t *\n\t\t * @externalExample {runnable} chart-once\n\t\t *\n\t\t * @param {String} name Name of the event\n\t\t * @param {ChartEventHandler} callback Function to be invoked when the event\n\t\t *        occurs\n\t\t * @param {Object} [context] Value to set as `this` when invoking the\n\t\t *        `callback`. Defaults to the chart instance\n\t\t *\n\t\t * @returns {Chart} A reference to this chart (chainable)\n\t\t */\n\t\tChart.prototype.once = function(name, callback, context) {\n\t\t\tvar self = this;\n\t\t\tvar once = function() {\n\t\t\t\tself.off(name, once);\n\t\t\t\tcallback.apply(this, arguments);\n\t\t\t};\n\t\t\treturn this.on(name, once, context);\n\t\t};\n\t\n\t\t/**\n\t\t * Unsubscribe one or more callback functions from an event triggered on the\n\t\t * chart. When no arguments are specified, *all* handlers will be unsubscribed.\n\t\t * When only a `name` is specified, all handlers subscribed to that event will\n\t\t * be unsubscribed. When a `name` and `callback` are specified, only that\n\t\t * function will be unsubscribed from that event. When a `name` and `context`\n\t\t * are specified (but `callback` is omitted), all events bound to the given\n\t\t * event with the given context will be unsubscribed.\n\t\t *\n\t\t * @externalExample {runnable} chart-off\n\t\t *\n\t\t * @param {String} [name] Name of the event to be unsubscribed\n\t\t * @param {ChartEventHandler} [callback] Function to be unsubscribed\n\t\t * @param {Object} [context] Contexts to be unsubscribe\n\t\t *\n\t\t * @returns {Chart} A reference to this chart (chainable).\n\t\t */\n\t\tChart.prototype.off = function(name, callback, context) {\n\t\t\tvar names, n, events, event, i, j;\n\t\n\t\t\t// remove all events\n\t\t\tif (arguments.length === 0) {\n\t\t\t\tfor (name in this._events) {\n\t\t\t\t\tthis._events[name].length = 0;\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\n\t\t\t// remove all events for a specific name\n\t\t\tif (arguments.length === 1) {\n\t\t\t\tevents = this._events[name];\n\t\t\t\tif (events) {\n\t\t\t\t\tevents.length = 0;\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\n\t\t\t// remove all events that match whatever combination of name, context\n\t\t\t// and callback.\n\t\t\tnames = name ? [name] : Object.keys(this._events);\n\t\t\tfor (i = 0; i < names.length; i++) {\n\t\t\t\tn = names[i];\n\t\t\t\tevents = this._events[n];\n\t\t\t\tj = events.length;\n\t\t\t\twhile (j--) {\n\t\t\t\t\tevent = events[j];\n\t\t\t\t\tif ((callback && callback === event.callback) ||\n\t\t\t\t\t\t\t(context && context === event.context)) {\n\t\t\t\t\t\tevents.splice(j, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\t};\n\t\n\t\t/**\n\t\t * Publish an event on this chart with the given `name`.\n\t\t *\n\t\t * @externalExample {runnable} chart-trigger\n\t\t *\n\t\t * @param {String} name Name of the event to publish\n\t\t * @param {...*} arguments Values with which to invoke the registered\n\t\t *        callbacks.\n\t\t *\n\t\t * @returns {Chart} A reference to this chart (chainable).\n\t\t */\n\t\tChart.prototype.trigger = function(name) {\n\t\t\tvar args = Array.prototype.slice.call(arguments, 1);\n\t\t\tvar events = this._events[name];\n\t\t\tvar i, ev;\n\t\n\t\t\tif (events !== undefined) {\n\t\t\t\tfor (i = 0; i < events.length; i++) {\n\t\t\t\t\tev = events[i];\n\t\t\t\t\tev.callback.apply(ev.context, args);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\t};\n\t\n\t\t/**\n\t\t * Create a new {@link Chart} constructor with the provided options acting as\n\t\t * \"overrides\" for the default chart instance methods. Allows for basic\n\t\t * inheritance so that new chart constructors may be defined in terms of\n\t\t * existing chart constructors. Based on the `extend` function defined by\n\t\t * [Backbone.js](http://backbonejs.org/).\n\t\t *\n\t\t * @static\n\t\t * @externalExample {runnable} chart-extend\n\t\t *\n\t\t * @param {String} name Identifier for the new Chart constructor.\n\t\t * @param {Object} protoProps Properties to set on the new chart's prototype.\n\t\t * @param {Object} staticProps Properties to set on the chart constructor\n\t\t *        itself.\n\t\t *\n\t\t * @returns {Function} A new Chart constructor\n\t\t */\n\t\tChart.extend = function(name, protoProps, staticProps) {\n\t\t\tvar parent = this;\n\t\t\tvar child;\n\t\n\t\t\t// The constructor function for the new subclass is either defined by\n\t\t\t// you (the \"constructor\" property in your `extend` definition), or\n\t\t\t// defaulted by us to simply call the parent's constructor.\n\t\t\tif (protoProps && hasOwnProp.call(protoProps, \"constructor\")) {\n\t\t\t\tchild = protoProps.constructor;\n\t\t\t} else {\n\t\t\t\tchild = function(){ return parent.apply(this, arguments); };\n\t\t\t}\n\t\n\t\t\t// Add static properties to the constructor function, if supplied.\n\t\t\textend(child, parent, staticProps);\n\t\n\t\t\t// Set the prototype chain to inherit from `parent`, without calling\n\t\t\t// `parent`'s constructor function.\n\t\t\tvar Surrogate = function(){ this.constructor = child; };\n\t\t\tSurrogate.prototype = parent.prototype;\n\t\t\tchild.prototype = new Surrogate();\n\t\n\t\t\t// Add prototype properties (instance properties) to the subclass, if\n\t\t\t// supplied.\n\t\t\tif (protoProps) { extend(child.prototype, protoProps); }\n\t\n\t\t\t// Set a convenience property in case the parent's prototype is needed\n\t\t\t// later.\n\t\t\tchild.__super__ = parent.prototype;\n\t\n\t\t\tChart[name] = child;\n\t\t\treturn child;\n\t\t};\n\t\n\t\tmodule.exports = Chart;\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {\n\t\t\"use strict\";\n\t\n\t\tmodule.exports = function(test, message) {\n\t\t\tif (test) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthrow new Error(\"[d3.chart] \" + message);\n\t\t};\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {\n\t\t\"use strict\";\n\t\tvar d3 = __webpack_require__(1);\n\t\n\t\tvar Layer = __webpack_require__(5);\n\t\n\t\t/**\n\t\t * Create a new layer on the d3 selection from which it is called.\n\t\t *\n\t\t * @static\n\t\t *\n\t\t * @param {Object} [options] Options to be forwarded to {@link Layer|the Layer\n\t\t *        constructor}\n\t\t * @returns {d3.selection}\n\t\t */\n\t\td3.selection.prototype.layer = function(options) {\n\t\t\tvar layer = new Layer(this);\n\t\t\tvar eventName;\n\t\n\t\t\t// Set layer methods (required)\n\t\t\tlayer.dataBind = options.dataBind;\n\t\t\tlayer.insert = options.insert;\n\t\n\t\t\t// Bind events (optional)\n\t\t\tif (\"events\" in options) {\n\t\t\t\tfor (eventName in options.events) {\n\t\t\t\t\tlayer.on(eventName, options.events[eventName]);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Mix the public methods into the D3.js selection (bound appropriately)\n\t\t\tthis.on = function() { return layer.on.apply(layer, arguments); };\n\t\t\tthis.off = function() { return layer.off.apply(layer, arguments); };\n\t\t\tthis.draw = function() { return layer.draw.apply(layer, arguments); };\n\t\n\t\t\treturn this;\n\t\t};\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {\n\t\t\"use strict\";\n\t\tvar d3 = __webpack_require__(1);\n\t\n\t\tvar assert = __webpack_require__(3);\n\t\n\t\tvar lifecycleRe = /^(enter|update|merge|exit)(:transition)?$/;\n\t\n\t\t/**\n\t\t * Create a layer using the provided `base`. The layer instance is *not*\n\t\t * exposed to d3.chart users. Instead, its instance methods are mixed in to the\n\t\t * `base` selection it describes; users interact with the instance via these\n\t\t * bound methods.\n\t\t *\n\t\t * @private\n\t\t * @constructor\n\t\t * @externalExample {runnable} layer\n\t\t *\n\t\t * @param {d3.selection} base The containing DOM node for the layer.\n\t\t */\n\t\tvar Layer = function(base) {\n\t\t\tassert(base, \"Layers must be initialized with a base.\");\n\t\t\tthis._base = base;\n\t\t\tthis._handlers = {};\n\t\t};\n\t\n\t\t/**\n\t\t * Invoked by {@link Layer#draw} to join data with this layer's DOM nodes. This\n\t\t * implementation is \"virtual\"--it *must* be overridden by Layer instances.\n\t\t *\n\t\t * @param {Array} data Value passed to {@link Layer#draw}\n\t\t */\n\t\tLayer.prototype.dataBind = function() {\n\t\t\tassert(false, \"Layers must specify a `dataBind` method.\");\n\t\t};\n\t\n\t\t/**\n\t\t * Invoked by {@link Layer#draw} in order to insert new DOM nodes into this\n\t\t * layer's `base`. This implementation is \"virtual\"--it *must* be overridden by\n\t\t * Layer instances.\n\t\t */\n\t\tLayer.prototype.insert = function() {\n\t\t\tassert(false, \"Layers must specify an `insert` method.\");\n\t\t};\n\t\n\t\t/**\n\t\t * Subscribe a handler to a \"lifecycle event\". These events (and only these\n\t\t * events) are triggered when {@link Layer#draw} is invoked--see that method\n\t\t * for more details on lifecycle events.\n\t\t *\n\t\t * @externalExample {runnable} layer-on\n\t\t *\n\t\t * @param {String} eventName Identifier for the lifecycle event for which to\n\t\t *        subscribe.\n\t\t * @param {Function} handler Callback function\n\t\t *\n\t\t * @returns {d3.selection} Reference to the layer's base.\n\t\t */\n\t\tLayer.prototype.on = function(eventName, handler, options) {\n\t\t\toptions = options || {};\n\t\n\t\t\tassert(\n\t\t\t\tlifecycleRe.test(eventName),\n\t\t\t\t\"Unrecognized lifecycle event name specified to `Layer#on`: '\" +\n\t\t\t\teventName + \"'.\"\n\t\t\t);\n\t\n\t\t\tif (!(eventName in this._handlers)) {\n\t\t\t\tthis._handlers[eventName] = [];\n\t\t\t}\n\t\t\tthis._handlers[eventName].push({\n\t\t\t\tcallback: handler,\n\t\t\t\tchart: options.chart || null\n\t\t\t});\n\t\t\treturn this._base;\n\t\t};\n\t\n\t\t/**\n\t\t * Unsubscribe the specified handler from the specified event. If no handler is\n\t\t * supplied, remove *all* handlers from the event.\n\t\t *\n\t\t * @externalExample {runnable} layer-off\n\t\t *\n\t\t * @param {String} eventName Identifier for event from which to remove\n\t\t *        unsubscribe\n\t\t * @param {Function} handler Callback to remove from the specified event\n\t\t *\n\t\t * @returns {d3.selection} Reference to the layer's base.\n\t\t */\n\t\tLayer.prototype.off = function(eventName, handler) {\n\t\n\t\t\tvar handlers = this._handlers[eventName];\n\t\t\tvar idx;\n\t\n\t\t\tassert(\n\t\t\t\tlifecycleRe.test(eventName),\n\t\t\t\t\"Unrecognized lifecycle event name specified to `Layer#off`: '\" +\n\t\t\t\teventName + \"'.\"\n\t\t\t);\n\t\n\t\t\tif (!handlers) {\n\t\t\t\treturn this._base;\n\t\t\t}\n\t\n\t\t\tif (arguments.length === 1) {\n\t\t\t\thandlers.length = 0;\n\t\t\t\treturn this._base;\n\t\t\t}\n\t\n\t\t\tfor (idx = handlers.length - 1; idx > -1; --idx) {\n\t\t\t\tif (handlers[idx].callback === handler) {\n\t\t\t\t\thandlers.splice(idx, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this._base;\n\t\t};\n\t\n\t\t/**\n\t\t * Render the layer according to the input data: Bind the data to the layer\n\t\t * (according to {@link Layer#dataBind}, insert new elements (according to\n\t\t * {@link Layer#insert}, make lifecycle selections, and invoke all relevant\n\t\t * handlers (as attached via {@link Layer#on}) with the lifecycle selections.\n\t\t *\n\t\t * - update\n\t\t * - update:transition\n\t\t * - enter\n\t\t * - enter:transition\n\t\t * - exit\n\t\t * - exit:transition\n\t\t *\n\t\t * @externalExample {runnable} layer-draw\n\t\t *\n\t\t * @param {Array} data Data to drive the rendering.\n\t\t */\n\t\tLayer.prototype.draw = function(data) {\n\t\t\tvar bound, entering, events, selection, method, handlers, eventName, idx,\n\t\t\t\tlen;\n\t\n\t\t\tbound = this.dataBind.call(this._base, data);\n\t\n\t\t\t// Although `bound instanceof d3.selection` is more explicit, it fails\n\t\t\t// in IE8, so we use duck typing to maintain compatability.\n\t\t\tassert(bound && bound.call === d3.selection.prototype.call,\n\t\t\t\t\"Invalid selection defined by `Layer#dataBind` method.\");\n\t\t\tassert(bound.enter, \"Layer selection not properly bound.\");\n\t\n\t\t\tentering = bound.enter();\n\t\t\tentering._chart = this._base._chart;\n\t\n\t\t\tevents = [\n\t\t\t\t{\n\t\t\t\t\tname: \"update\",\n\t\t\t\t\tselection: bound\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: \"enter\",\n\t\t\t\t\tselection: entering,\n\t\t\t\t\tmethod: this.insert\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: \"merge\",\n\t\t\t\t\t// Although the `merge` lifecycle event shares its selection object\n\t\t\t\t\t// with the `update` lifecycle event, the object's contents will be\n\t\t\t\t\t// modified when d3.chart invokes the user-supplied `insert` method\n\t\t\t\t\t// when triggering the `enter` event.\n\t\t\t\t\tselection: bound\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: \"exit\",\n\t\t\t\t\t// Although the `exit` lifecycle event shares its selection object\n\t\t\t\t\t// with the `update` and `merge` lifecycle events, the object's\n\t\t\t\t\t// contents will be modified when d3.chart invokes\n\t\t\t\t\t// `d3.selection.exit`.\n\t\t\t\t\tselection: bound,\n\t\t\t\t\tmethod: bound.exit\n\t\t\t\t}\n\t\t\t];\n\t\n\t\t\tfor (var i = 0, l = events.length; i < l; ++i) {\n\t\t\t\teventName = events[i].name;\n\t\t\t\tselection = events[i].selection;\n\t\t\t\tmethod = events[i].method;\n\t\n\t\t\t\t// Some lifecycle selections modify shared state, so they must be\n\t\t\t\t// deferred until just prior to handler invocation.\n\t\t\t\tif (typeof method === \"function\") {\n\t\t\t\t\tselection = method.call(selection);\n\t\t\t\t}\n\t\n\t\t\t\tif (selection.empty()) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\n\t\t\t\t// Although `selection instanceof d3.selection` is more explicit,\n\t\t\t\t// it fails in IE8, so we use duck typing to maintain\n\t\t\t\t// compatability.\n\t\t\t\tassert(selection &&\n\t\t\t\t\tselection.call === d3.selection.prototype.call,\n\t\t\t\t\t\"Invalid selection defined for '\" + eventName +\n\t\t\t\t\t\"' lifecycle event.\");\n\t\n\t\t\t\thandlers = this._handlers[eventName];\n\t\n\t\t\t\tif (handlers) {\n\t\t\t\t\tfor (idx = 0, len = handlers.length; idx < len; ++idx) {\n\t\t\t\t\t\t// Attach a reference to the parent chart so the selection\"s\n\t\t\t\t\t\t// `chart` method will function correctly.\n\t\t\t\t\t\tselection._chart = handlers[idx].chart || this._base._chart;\n\t\t\t\t\t\tselection.call(handlers[idx].callback);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\thandlers = this._handlers[eventName + \":transition\"];\n\t\n\t\t\t\tif (handlers && handlers.length) {\n\t\t\t\t\tselection = selection.transition();\n\t\t\t\t\tfor (idx = 0, len = handlers.length; idx < len; ++idx) {\n\t\t\t\t\t\tselection._chart = handlers[idx].chart || this._base._chart;\n\t\t\t\t\t\tselection.call(handlers[idx].callback);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\n\t\tmodule.exports = Layer;\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** d3.chart.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 6342383388dbd94da3e1\n **/","define(function(require, exports, module) {\n\t\"use strict\";\n\tvar d3 = require(\"d3\");\n\n\tvar Chart = require(\"./chart\");\n\tvar assert = require(\"./assert\");\n\n\tassert(/^3\\./.test(d3.version), \"d3.js version 3 is required\");\n\n\trequire(\"./layer-extensions\");\n\n\t/**\n\t * A namespace defined by [the D3.js library](http://d3js.org/). The d3.chart\n\t * API is defined within this namespace.\n\t * @namespace d3\n\t */\n\n\t/**\n\t * A constructor function defined by [the D3.js library](http://d3js.org/).\n\t * @constructor d3.selection\n\t * @memberof d3\n\t */\n\n\t/**\n\t * Create a new chart constructor or return a previously-created chart\n\t * constructor.\n\t *\n\t * @static\n\t * @memberof d3\n\t * @externalExample {runnable} chart\n\t *\n\t * @param {String} name If no other arguments are specified, return the\n\t *        previously-created chart with this name.\n\t * @param {Object} protoProps If specified, this value will be forwarded to\n\t *        {@link Chart.extend} and used to create a new chart.\n\t * @param {Object} staticProps If specified, this value will be forwarded to\n\t *        {@link Chart.extend} and used to create a new chart.\n\t */\n\td3.chart = function(name) {\n\t\tif (arguments.length === 0) {\n\t\t\treturn Chart;\n\t\t} else if (arguments.length === 1) {\n\t\t\treturn Chart[name];\n\t\t}\n\n\t\treturn Chart.extend.apply(Chart, arguments);\n\t};\n\n\t/**\n\t * Instantiate a chart or return the chart that the current selection belongs\n\t * to.\n\t *\n\t * @externalExample {runnable} selection-chart\n\t *\n\t * @param {String} [chartName] The name of the chart to instantiate. If the\n\t *        name is unspecified, this method will return the chart that the\n\t *        current selection belongs to.\n\t * @param {mixed} options The options to use when instantiated the new chart.\n\t *        See {@link Chart} for more information.\n\t */\n\td3.selection.prototype.chart = function(chartName, options) {\n\t\t// Without an argument, attempt to resolve the current selection's\n\t\t// containing d3.chart.\n\t\tif (arguments.length === 0) {\n\t\t\treturn this._chart;\n\t\t}\n\t\tvar ChartCtor = Chart[chartName];\n\t\tassert(ChartCtor, \"No chart registered with name '\" + chartName + \"'\");\n\n\t\treturn new ChartCtor(this, options);\n\t};\n\n\t// Implement the zero-argument signature of `d3.selection.prototype.chart`\n\t// for all selection types.\n\td3.selection.enter.prototype.chart = function() {\n\t\treturn this._chart;\n\t};\n\td3.transition.prototype.chart = d3.selection.enter.prototype.chart;\n\n\tmodule.exports = d3.chart;\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./chart-extensions.js\n ** module id = 0\n ** module chunks = 0\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"d3\"\n ** module id = 1\n ** module chunks = 0\n **/","define(function(require, exports, module) {\n\t\"use strict\";\n\tvar assert = require(\"./assert\");\n\tvar hasOwnProp = Object.hasOwnProperty;\n\n\t// extend\n\t// Borrowed from Underscore.js\n\tfunction extend(object) {\n\t\tvar argsIndex, argsLength, iteratee, key;\n\t\tif (!object) {\n\t\t\treturn object;\n\t\t}\n\t\targsLength = arguments.length;\n\t\tfor (argsIndex = 1; argsIndex < argsLength; argsIndex++) {\n\t\t\titeratee = arguments[argsIndex];\n\t\t\tif (iteratee) {\n\t\t\t\tfor (key in iteratee) {\n\t\t\t\t\tobject[key] = iteratee[key];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn object;\n\t}\n\n\t/**\n\t * Call the {@Chart#initialize} method up the inheritance chain, starting with\n\t * the base class and continuing \"downward\".\n\t *\n\t * @private\n\t */\n\tvar initCascade = function(instance, args) {\n\t\tvar ctor = this.constructor;\n\t\tvar sup = ctor.__super__;\n\t\tif (sup) {\n\t\t\tinitCascade.call(sup, instance, args);\n\t\t}\n\n\t\t// Do not invoke the `initialize` method on classes further up the\n\t\t// prototype chain (again).\n\t\tif (hasOwnProp.call(ctor.prototype, \"initialize\")) {\n\t\t\tthis.initialize.apply(instance, args);\n\t\t}\n\t};\n\n\t/**\n\t * Call the `transform` method down the inheritance chain, starting with the\n\t * instance and continuing \"upward\". The result of each transformation should\n\t * be supplied as input to the next.\n\t *\n\t * @private\n\t */\n\tvar transformCascade = function(instance, data) {\n\t\tvar ctor = this.constructor;\n\t\tvar sup = ctor.__super__;\n\n\t\t// Unlike `initialize`, the `transform` method has significance when\n\t\t// attached directly to a chart instance. Ensure that this transform takes\n\t\t// first but is not invoked on later recursions.\n\t\tif (this === instance && hasOwnProp.call(this, \"transform\")) {\n\t\t\tdata = this.transform(data);\n\t\t}\n\n\t\t// Do not invoke the `transform` method on classes further up the prototype\n\t\t// chain (yet).\n\t\tif (hasOwnProp.call(ctor.prototype, \"transform\")) {\n\t\t\tdata = ctor.prototype.transform.call(instance, data);\n\t\t}\n\n\t\tif (sup) {\n\t\t\tdata = transformCascade.call(sup, instance, data);\n\t\t}\n\n\t\treturn data;\n\t};\n\n\t/**\n\t * Create a d3.chart\n\t *\n\t * @constructor\n\t * @externalExample {runnable} chart\n\t *\n\t * @param {d3.selection} selection The chart's \"base\" DOM node. This should\n\t *        contain any nodes that the chart generates.\n\t * @param {mixed} chartOptions A value for controlling how the chart should be\n\t *        created. This value will be forwarded to {@link Chart#initialize}, so\n\t *        charts may define additional properties for consumers to modify their\n\t *        behavior during initialization. The following attributes will be\n\t *        copied onto the chart instance (if present):\n\t * @param {Function} [chartOptions.transform] - A data transformation function\n\t *        unique to the Chart instance being created. If specified, this\n\t *        function will be invoked after all inherited implementations as part\n\t *        of the `Chart#draw` operation.\n\t * @param {Function} [chartOptions.demux] - A data filtering function for\n\t *        attachment charts. If specified, this function will be invoked with\n\t *        every {@link Chart#draw|draw} operation and provided with two\n\t *        arguments: the attachment name (see {@link Chart#attach}) and the\n\t *        data.\n\t *\n\t * @constructor\n\t */\n\tvar Chart = function(selection, chartOptions) {\n\t\tthis.base = selection;\n\t\tthis._layers = {};\n\t\tthis._attached = {};\n\t\tthis._events = {};\n\n\t\tif (chartOptions && chartOptions.transform) {\n\t\t\tthis.transform = chartOptions.transform;\n\t\t}\n\n\t\tinitCascade.call(this, this, [chartOptions]);\n\t};\n\n\t/**\n\t * Set up a chart instance. This method is intended to be overridden by Charts\n\t * authored with this library. It will be invoked with a single argument: the\n\t * `options` value supplied to the {@link Chart|constructor}.\n\t *\n\t * For charts that are defined as extensions of other charts using\n\t * `Chart.extend`, each chart's `initilize` method will be invoked starting\n\t * with the \"oldest\" ancestor (see the private {@link initCascade} function for\n\t * more details).\n\t */\n\tChart.prototype.initialize = function() {};\n\n\t/**\n\t * Remove a layer from the chart.\n\t *\n\t * @externalExample chart-unlayer\n\t *\n\t * @param {String} name The name of the layer to remove.\n\t *\n\t * @returns {Layer} The layer removed by this operation.\n\t */\n\tChart.prototype.unlayer = function(name) {\n\t\tvar layer = this.layer(name);\n\n\t\tdelete this._layers[name];\n\t\tdelete layer._chart;\n\n\t\treturn layer;\n\t};\n\n\t/**\n\t * Interact with the chart's {@link Layer|layers}.\n\t *\n\t * If only a `name` is provided, simply return the layer registered to that\n\t * name (if any).\n\t *\n\t * If a `name` and `selection` are provided, treat the `selection` as a\n\t * previously-created layer and attach it to the chart with the specified\n\t * `name`.\n\t *\n\t * If all three arguments are specified, initialize a new {@link Layer} using\n\t * the specified `selection` as a base passing along the specified `options`.\n\t *\n\t * The {@link Layer.draw} method of attached layers will be invoked\n\t * whenever this chart's {@link Chart#draw} is invoked and will receive the\n\t * data (optionally modified by the chart's {@link Chart#transform} method.\n\t *\n\t * @externalExample chart-layer\n\t *\n\t * @param {String} name Name of the layer to attach or retrieve.\n\t * @param {d3.selection|Layer} [selection] The layer's base or a\n\t *        previously-created {@link Layer}.\n\t * @param {Object} [options] Options to be forwarded to {@link Layer|the Layer\n\t *        constructor}\n\t *\n\t * @returns {Layer}\n\t */\n\tChart.prototype.layer = function(name, selection, options) {\n\t\tvar layer;\n\n\t\tif (arguments.length === 1) {\n\t\t\treturn this._layers[name];\n\t\t}\n\n\t\t// we are reattaching a previous layer, which the\n\t\t// selection argument is now set to.\n\t\tif (arguments.length === 2) {\n\n\t\t\tif (typeof selection.draw === \"function\") {\n\t\t\t\tselection._chart = this;\n\t\t\t\tthis._layers[name] = selection;\n\t\t\t\treturn this._layers[name];\n\n\t\t\t} else {\n\t\t\t\tassert(false, \"When reattaching a layer, the second argument \" +\n\t\t\t\t\t\"must be a d3.chart layer\");\n\t\t\t}\n\t\t}\n\n\t\tlayer = selection.layer(options);\n\n\t\tthis._layers[name] = layer;\n\n\t\tselection._chart = this;\n\n\t\treturn layer;\n\t};\n\n\t/**\n\t * Register or retrieve an \"attachment\" Chart. The \"attachment\" chart's `draw`\n\t * method will be invoked whenever the containing chart's `draw` method is\n\t * invoked.\n\t *\n\t * @externalExample chart-attach\n\t *\n\t * @param {String} attachmentName Name of the attachment\n\t * @param {Chart} [chart] d3.chart to register as a mix in of this chart. When\n\t *        unspecified, this method will return the attachment previously\n\t *        registered with the specified `attachmentName` (if any).\n\t *\n\t * @returns {Chart} Reference to this chart (chainable).\n\t */\n\tChart.prototype.attach = function(attachmentName, chart) {\n\t\tif (arguments.length === 1) {\n\t\t\treturn this._attached[attachmentName];\n\t\t}\n\n\t\tthis._attached[attachmentName] = chart;\n\t\treturn chart;\n\t};\n\n\t/**\n\t * A \"hook\" method that you may define to modify input data before it is used\n\t * to draw the chart's layers and attachments. This method will be used by all\n\t * sub-classes (see {@link transformCascade} for details).\n\t *\n\t * Note you will most likely never call this method directly, but rather\n\t * include it as part of a chart definition, and then rely on d3.chart to\n\t * invoke it when you draw the chart with {@link Chart#draw}.\n\t *\n\t * @externalExample {runnable} chart-transform\n\t *\n\t * @param {Array} data Input data provided to @link Chart#draw}.\n\t *\n\t * @returns {mixed} Data to be used in drawing the chart's layers and\n\t *                  attachments.\n\t */\n\tChart.prototype.transform = function(data) {\n\t\treturn data;\n\t};\n\n\t/**\n\t * Update the chart's representation in the DOM, drawing all of its layers and\n\t * any \"attachment\" charts (as attached via {@link Chart#attach}).\n\t *\n\t * @externalExample chart-draw\n\t *\n\t * @param {Object} data Data to pass to the {@link Layer#draw|draw method} of\n\t *        this cart's {@link Layer|layers} (if any) and the {@link\n\t *        Chart#draw|draw method} of this chart's attachments (if any).\n\t */\n\tChart.prototype.draw = function(data) {\n\n\t\tvar layerName, attachmentName, attachmentData;\n\n\t\tdata = transformCascade.call(this, this, data);\n\n\t\tfor (layerName in this._layers) {\n\t\t\tthis._layers[layerName].draw(data);\n\t\t}\n\n\t\tfor (attachmentName in this._attached) {\n\t\t\tif (this.demux) {\n\t\t\t\tattachmentData = this.demux(attachmentName, data);\n\t\t\t} else {\n\t\t\t\tattachmentData = data;\n\t\t\t}\n\t\t\tthis._attached[attachmentName].draw(attachmentData);\n\t\t}\n\t};\n\n\t/**\n\t * Function invoked with the context specified when the handler was bound (via\n\t * {@link Chart#on} {@link Chart#once}).\n\t *\n\t * @callback ChartEventHandler\n\t * @param {...*} arguments Invoked with the arguments passed to {@link\n\t *         Chart#trigger}\n\t */\n\n\t/**\n\t * Subscribe a callback function to an event triggered on the chart. See {@link\n\t * Chart#once} to subscribe a callback function to an event for one occurence.\n\t *\n\t * @externalExample {runnable} chart-on\n\t *\n\t * @param {String} name Name of the event\n\t * @param {ChartEventHandler} callback Function to be invoked when the event\n\t *        occurs\n\t * @param {Object} [context] Value to set as `this` when invoking the\n\t *        `callback`. Defaults to the chart instance.\n\t *\n\t * @returns {Chart} A reference to this chart (chainable).\n\t */\n\tChart.prototype.on = function(name, callback, context) {\n\t\tvar events = this._events[name] || (this._events[name] = []);\n\t\tevents.push({\n\t\t\tcallback: callback,\n\t\t\tcontext: context || this,\n\t\t\t_chart: this\n\t\t});\n\t\treturn this;\n\t};\n\n\t/**\n\t * Subscribe a callback function to an event triggered on the chart. This\n\t * function will be invoked at the next occurance of the event and immediately\n\t * unsubscribed. See {@link Chart#on} to subscribe a callback function to an\n\t * event indefinitely.\n\t *\n\t * @externalExample {runnable} chart-once\n\t *\n\t * @param {String} name Name of the event\n\t * @param {ChartEventHandler} callback Function to be invoked when the event\n\t *        occurs\n\t * @param {Object} [context] Value to set as `this` when invoking the\n\t *        `callback`. Defaults to the chart instance\n\t *\n\t * @returns {Chart} A reference to this chart (chainable)\n\t */\n\tChart.prototype.once = function(name, callback, context) {\n\t\tvar self = this;\n\t\tvar once = function() {\n\t\t\tself.off(name, once);\n\t\t\tcallback.apply(this, arguments);\n\t\t};\n\t\treturn this.on(name, once, context);\n\t};\n\n\t/**\n\t * Unsubscribe one or more callback functions from an event triggered on the\n\t * chart. When no arguments are specified, *all* handlers will be unsubscribed.\n\t * When only a `name` is specified, all handlers subscribed to that event will\n\t * be unsubscribed. When a `name` and `callback` are specified, only that\n\t * function will be unsubscribed from that event. When a `name` and `context`\n\t * are specified (but `callback` is omitted), all events bound to the given\n\t * event with the given context will be unsubscribed.\n\t *\n\t * @externalExample {runnable} chart-off\n\t *\n\t * @param {String} [name] Name of the event to be unsubscribed\n\t * @param {ChartEventHandler} [callback] Function to be unsubscribed\n\t * @param {Object} [context] Contexts to be unsubscribe\n\t *\n\t * @returns {Chart} A reference to this chart (chainable).\n\t */\n\tChart.prototype.off = function(name, callback, context) {\n\t\tvar names, n, events, event, i, j;\n\n\t\t// remove all events\n\t\tif (arguments.length === 0) {\n\t\t\tfor (name in this._events) {\n\t\t\t\tthis._events[name].length = 0;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\t// remove all events for a specific name\n\t\tif (arguments.length === 1) {\n\t\t\tevents = this._events[name];\n\t\t\tif (events) {\n\t\t\t\tevents.length = 0;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\t// remove all events that match whatever combination of name, context\n\t\t// and callback.\n\t\tnames = name ? [name] : Object.keys(this._events);\n\t\tfor (i = 0; i < names.length; i++) {\n\t\t\tn = names[i];\n\t\t\tevents = this._events[n];\n\t\t\tj = events.length;\n\t\t\twhile (j--) {\n\t\t\t\tevent = events[j];\n\t\t\t\tif ((callback && callback === event.callback) ||\n\t\t\t\t\t\t(context && context === event.context)) {\n\t\t\t\t\tevents.splice(j, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t};\n\n\t/**\n\t * Publish an event on this chart with the given `name`.\n\t *\n\t * @externalExample {runnable} chart-trigger\n\t *\n\t * @param {String} name Name of the event to publish\n\t * @param {...*} arguments Values with which to invoke the registered\n\t *        callbacks.\n\t *\n\t * @returns {Chart} A reference to this chart (chainable).\n\t */\n\tChart.prototype.trigger = function(name) {\n\t\tvar args = Array.prototype.slice.call(arguments, 1);\n\t\tvar events = this._events[name];\n\t\tvar i, ev;\n\n\t\tif (events !== undefined) {\n\t\t\tfor (i = 0; i < events.length; i++) {\n\t\t\t\tev = events[i];\n\t\t\t\tev.callback.apply(ev.context, args);\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t};\n\n\t/**\n\t * Create a new {@link Chart} constructor with the provided options acting as\n\t * \"overrides\" for the default chart instance methods. Allows for basic\n\t * inheritance so that new chart constructors may be defined in terms of\n\t * existing chart constructors. Based on the `extend` function defined by\n\t * [Backbone.js](http://backbonejs.org/).\n\t *\n\t * @static\n\t * @externalExample {runnable} chart-extend\n\t *\n\t * @param {String} name Identifier for the new Chart constructor.\n\t * @param {Object} protoProps Properties to set on the new chart's prototype.\n\t * @param {Object} staticProps Properties to set on the chart constructor\n\t *        itself.\n\t *\n\t * @returns {Function} A new Chart constructor\n\t */\n\tChart.extend = function(name, protoProps, staticProps) {\n\t\tvar parent = this;\n\t\tvar child;\n\n\t\t// The constructor function for the new subclass is either defined by\n\t\t// you (the \"constructor\" property in your `extend` definition), or\n\t\t// defaulted by us to simply call the parent's constructor.\n\t\tif (protoProps && hasOwnProp.call(protoProps, \"constructor\")) {\n\t\t\tchild = protoProps.constructor;\n\t\t} else {\n\t\t\tchild = function(){ return parent.apply(this, arguments); };\n\t\t}\n\n\t\t// Add static properties to the constructor function, if supplied.\n\t\textend(child, parent, staticProps);\n\n\t\t// Set the prototype chain to inherit from `parent`, without calling\n\t\t// `parent`'s constructor function.\n\t\tvar Surrogate = function(){ this.constructor = child; };\n\t\tSurrogate.prototype = parent.prototype;\n\t\tchild.prototype = new Surrogate();\n\n\t\t// Add prototype properties (instance properties) to the subclass, if\n\t\t// supplied.\n\t\tif (protoProps) { extend(child.prototype, protoProps); }\n\n\t\t// Set a convenience property in case the parent's prototype is needed\n\t\t// later.\n\t\tchild.__super__ = parent.prototype;\n\n\t\tChart[name] = child;\n\t\treturn child;\n\t};\n\n\tmodule.exports = Chart;\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./chart.js\n ** module id = 2\n ** module chunks = 0\n **/","define(function(require, exports, module) {\n\t\"use strict\";\n\n\tmodule.exports = function(test, message) {\n\t\tif (test) {\n\t\t\treturn;\n\t\t}\n\t\tthrow new Error(\"[d3.chart] \" + message);\n\t};\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./assert.js\n ** module id = 3\n ** module chunks = 0\n **/","define(function(require) {\n\t\"use strict\";\n\tvar d3 = require(\"d3\");\n\n\tvar Layer = require(\"./layer\");\n\n\t/**\n\t * Create a new layer on the d3 selection from which it is called.\n\t *\n\t * @static\n\t *\n\t * @param {Object} [options] Options to be forwarded to {@link Layer|the Layer\n\t *        constructor}\n\t * @returns {d3.selection}\n\t */\n\td3.selection.prototype.layer = function(options) {\n\t\tvar layer = new Layer(this);\n\t\tvar eventName;\n\n\t\t// Set layer methods (required)\n\t\tlayer.dataBind = options.dataBind;\n\t\tlayer.insert = options.insert;\n\n\t\t// Bind events (optional)\n\t\tif (\"events\" in options) {\n\t\t\tfor (eventName in options.events) {\n\t\t\t\tlayer.on(eventName, options.events[eventName]);\n\t\t\t}\n\t\t}\n\n\t\t// Mix the public methods into the D3.js selection (bound appropriately)\n\t\tthis.on = function() { return layer.on.apply(layer, arguments); };\n\t\tthis.off = function() { return layer.off.apply(layer, arguments); };\n\t\tthis.draw = function() { return layer.draw.apply(layer, arguments); };\n\n\t\treturn this;\n\t};\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./layer-extensions.js\n ** module id = 4\n ** module chunks = 0\n **/","define(function(require, exports, module) {\n\t\"use strict\";\n\tvar d3 = require(\"d3\");\n\n\tvar assert = require(\"./assert\");\n\n\tvar lifecycleRe = /^(enter|update|merge|exit)(:transition)?$/;\n\n\t/**\n\t * Create a layer using the provided `base`. The layer instance is *not*\n\t * exposed to d3.chart users. Instead, its instance methods are mixed in to the\n\t * `base` selection it describes; users interact with the instance via these\n\t * bound methods.\n\t *\n\t * @private\n\t * @constructor\n\t * @externalExample {runnable} layer\n\t *\n\t * @param {d3.selection} base The containing DOM node for the layer.\n\t */\n\tvar Layer = function(base) {\n\t\tassert(base, \"Layers must be initialized with a base.\");\n\t\tthis._base = base;\n\t\tthis._handlers = {};\n\t};\n\n\t/**\n\t * Invoked by {@link Layer#draw} to join data with this layer's DOM nodes. This\n\t * implementation is \"virtual\"--it *must* be overridden by Layer instances.\n\t *\n\t * @param {Array} data Value passed to {@link Layer#draw}\n\t */\n\tLayer.prototype.dataBind = function() {\n\t\tassert(false, \"Layers must specify a `dataBind` method.\");\n\t};\n\n\t/**\n\t * Invoked by {@link Layer#draw} in order to insert new DOM nodes into this\n\t * layer's `base`. This implementation is \"virtual\"--it *must* be overridden by\n\t * Layer instances.\n\t */\n\tLayer.prototype.insert = function() {\n\t\tassert(false, \"Layers must specify an `insert` method.\");\n\t};\n\n\t/**\n\t * Subscribe a handler to a \"lifecycle event\". These events (and only these\n\t * events) are triggered when {@link Layer#draw} is invoked--see that method\n\t * for more details on lifecycle events.\n\t *\n\t * @externalExample {runnable} layer-on\n\t *\n\t * @param {String} eventName Identifier for the lifecycle event for which to\n\t *        subscribe.\n\t * @param {Function} handler Callback function\n\t *\n\t * @returns {d3.selection} Reference to the layer's base.\n\t */\n\tLayer.prototype.on = function(eventName, handler, options) {\n\t\toptions = options || {};\n\n\t\tassert(\n\t\t\tlifecycleRe.test(eventName),\n\t\t\t\"Unrecognized lifecycle event name specified to `Layer#on`: '\" +\n\t\t\teventName + \"'.\"\n\t\t);\n\n\t\tif (!(eventName in this._handlers)) {\n\t\t\tthis._handlers[eventName] = [];\n\t\t}\n\t\tthis._handlers[eventName].push({\n\t\t\tcallback: handler,\n\t\t\tchart: options.chart || null\n\t\t});\n\t\treturn this._base;\n\t};\n\n\t/**\n\t * Unsubscribe the specified handler from the specified event. If no handler is\n\t * supplied, remove *all* handlers from the event.\n\t *\n\t * @externalExample {runnable} layer-off\n\t *\n\t * @param {String} eventName Identifier for event from which to remove\n\t *        unsubscribe\n\t * @param {Function} handler Callback to remove from the specified event\n\t *\n\t * @returns {d3.selection} Reference to the layer's base.\n\t */\n\tLayer.prototype.off = function(eventName, handler) {\n\n\t\tvar handlers = this._handlers[eventName];\n\t\tvar idx;\n\n\t\tassert(\n\t\t\tlifecycleRe.test(eventName),\n\t\t\t\"Unrecognized lifecycle event name specified to `Layer#off`: '\" +\n\t\t\teventName + \"'.\"\n\t\t);\n\n\t\tif (!handlers) {\n\t\t\treturn this._base;\n\t\t}\n\n\t\tif (arguments.length === 1) {\n\t\t\thandlers.length = 0;\n\t\t\treturn this._base;\n\t\t}\n\n\t\tfor (idx = handlers.length - 1; idx > -1; --idx) {\n\t\t\tif (handlers[idx].callback === handler) {\n\t\t\t\thandlers.splice(idx, 1);\n\t\t\t}\n\t\t}\n\t\treturn this._base;\n\t};\n\n\t/**\n\t * Render the layer according to the input data: Bind the data to the layer\n\t * (according to {@link Layer#dataBind}, insert new elements (according to\n\t * {@link Layer#insert}, make lifecycle selections, and invoke all relevant\n\t * handlers (as attached via {@link Layer#on}) with the lifecycle selections.\n\t *\n\t * - update\n\t * - update:transition\n\t * - enter\n\t * - enter:transition\n\t * - exit\n\t * - exit:transition\n\t *\n\t * @externalExample {runnable} layer-draw\n\t *\n\t * @param {Array} data Data to drive the rendering.\n\t */\n\tLayer.prototype.draw = function(data) {\n\t\tvar bound, entering, events, selection, method, handlers, eventName, idx,\n\t\t\tlen;\n\n\t\tbound = this.dataBind.call(this._base, data);\n\n\t\t// Although `bound instanceof d3.selection` is more explicit, it fails\n\t\t// in IE8, so we use duck typing to maintain compatability.\n\t\tassert(bound && bound.call === d3.selection.prototype.call,\n\t\t\t\"Invalid selection defined by `Layer#dataBind` method.\");\n\t\tassert(bound.enter, \"Layer selection not properly bound.\");\n\n\t\tentering = bound.enter();\n\t\tentering._chart = this._base._chart;\n\n\t\tevents = [\n\t\t\t{\n\t\t\t\tname: \"update\",\n\t\t\t\tselection: bound\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"enter\",\n\t\t\t\tselection: entering,\n\t\t\t\tmethod: this.insert\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"merge\",\n\t\t\t\t// Although the `merge` lifecycle event shares its selection object\n\t\t\t\t// with the `update` lifecycle event, the object's contents will be\n\t\t\t\t// modified when d3.chart invokes the user-supplied `insert` method\n\t\t\t\t// when triggering the `enter` event.\n\t\t\t\tselection: bound\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"exit\",\n\t\t\t\t// Although the `exit` lifecycle event shares its selection object\n\t\t\t\t// with the `update` and `merge` lifecycle events, the object's\n\t\t\t\t// contents will be modified when d3.chart invokes\n\t\t\t\t// `d3.selection.exit`.\n\t\t\t\tselection: bound,\n\t\t\t\tmethod: bound.exit\n\t\t\t}\n\t\t];\n\n\t\tfor (var i = 0, l = events.length; i < l; ++i) {\n\t\t\teventName = events[i].name;\n\t\t\tselection = events[i].selection;\n\t\t\tmethod = events[i].method;\n\n\t\t\t// Some lifecycle selections modify shared state, so they must be\n\t\t\t// deferred until just prior to handler invocation.\n\t\t\tif (typeof method === \"function\") {\n\t\t\t\tselection = method.call(selection);\n\t\t\t}\n\n\t\t\tif (selection.empty()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Although `selection instanceof d3.selection` is more explicit,\n\t\t\t// it fails in IE8, so we use duck typing to maintain\n\t\t\t// compatability.\n\t\t\tassert(selection &&\n\t\t\t\tselection.call === d3.selection.prototype.call,\n\t\t\t\t\"Invalid selection defined for '\" + eventName +\n\t\t\t\t\"' lifecycle event.\");\n\n\t\t\thandlers = this._handlers[eventName];\n\n\t\t\tif (handlers) {\n\t\t\t\tfor (idx = 0, len = handlers.length; idx < len; ++idx) {\n\t\t\t\t\t// Attach a reference to the parent chart so the selection\"s\n\t\t\t\t\t// `chart` method will function correctly.\n\t\t\t\t\tselection._chart = handlers[idx].chart || this._base._chart;\n\t\t\t\t\tselection.call(handlers[idx].callback);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\thandlers = this._handlers[eventName + \":transition\"];\n\n\t\t\tif (handlers && handlers.length) {\n\t\t\t\tselection = selection.transition();\n\t\t\t\tfor (idx = 0, len = handlers.length; idx < len; ++idx) {\n\t\t\t\t\tselection._chart = handlers[idx].chart || this._base._chart;\n\t\t\t\t\tselection.call(handlers[idx].callback);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tmodule.exports = Layer;\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./layer.js\n ** module id = 5\n ** module chunks = 0\n **/"],"sourceRoot":""}