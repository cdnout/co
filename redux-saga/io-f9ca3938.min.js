var createSymbol=e=>"@@redux-saga/"+e,CANCEL=createSymbol("CANCEL_PROMISE"),CHANNEL_END_TYPE=createSymbol("CHANNEL_END"),IO=createSymbol("IO"),MATCH=createSymbol("MATCH"),MULTICAST=createSymbol("MULTICAST"),SAGA_ACTION=createSymbol("SAGA_ACTION"),SELF_CANCELLATION=createSymbol("SELF_CANCELLATION"),TASK=createSymbol("TASK"),TASK_CANCEL=createSymbol("TASK_CANCEL"),TERMINATE=createSymbol("TERMINATE"),SAGA_LOCATION=createSymbol("LOCATION");function _extends(){return(_extends=Object.assign||function(e){for(var a=1;a<arguments.length;a++){var n=arguments[a];for(var t in n)Object.prototype.hasOwnProperty.call(n,t)&&(e[t]=n[t])}return e}).apply(this,arguments)}var undef=e=>null==e,notUndef=e=>null!=e,func=e=>"function"==typeof e,string=e=>"string"==typeof e,array=Array.isArray,object=e=>e&&!array(e)&&"object"==typeof e,promise=e=>e&&func(e.then),iterator=e=>e&&func(e.next)&&func(e.throw),task=e=>e&&e[TASK],buffer=e=>e&&func(e.isEmpty)&&func(e.take)&&func(e.put),pattern=e=>e&&(string(e)||symbol(e)||func(e)||array(e)&&e.every(pattern)),channel=e=>e&&func(e.take)&&func(e.close),stringableFunc=e=>func(e)&&e.hasOwnProperty("toString"),symbol=e=>Boolean(e)&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype,multicast=e=>channel(e)&&e[MULTICAST],effect=e=>e&&e[IO],konst=e=>()=>e,kTrue=konst(!0),noop=()=>{};"undefined"!=typeof Proxy&&(noop=new Proxy(noop,{set:()=>{throw internalErr("There was an attempt to assign a property to internal `noop` function.")}}));var identity=e=>e,hasSymbol="function"==typeof Symbol,asyncIteratorSymbol=hasSymbol&&Symbol.asyncIterator?Symbol.asyncIterator:"@@asyncIterator";function check(e,a,n){if(!a(e))throw new Error(n)}var assignWithSymbols=(e,a)=>{_extends(e,a),Object.getOwnPropertySymbols&&Object.getOwnPropertySymbols(a).forEach(n=>{e[n]=a[n]})},flatMap=(e,a)=>[].concat(...a.map(e));function remove(e,a){var n=e.indexOf(a);n>=0&&e.splice(n,1)}function once(e){var a=!1;return()=>{a||(a=!0,e())}}var kThrow=e=>{throw e},kReturn=e=>({value:e,done:!0});function makeIterator(e,a,n){void 0===a&&(a=kThrow),void 0===n&&(n="iterator");var t={meta:{name:n},next:e,throw:a,return:kReturn,isSagaIterator:!0};return"undefined"!=typeof Symbol&&(t[Symbol.iterator]=(()=>t)),t}function logError(e,a){var{sagaStack:n}=a;console.error(e),console.error(n)}var internalErr=e=>new Error("\n  redux-saga: Error checking hooks detected an inconsistent state. This is likely a bug\n  in redux-saga code and not yours. Thanks for reporting this in the project's github repo.\n  Error: "+e+"\n"),createSetContextWarning=(e,a)=>(e?e+".":"")+"setContext(props): argument "+a+" is not a plain object",FROZEN_ACTION_ERROR="You can't put (a.k.a. dispatch from saga) frozen actions.\nWe have to define a special non-enumerable property on those actions for scheduling purposes.\nOtherwise you wouldn't be able to communicate properly between sagas & other subscribers (action ordering would become far less predictable).\nIf you are using redux and you care about this behaviour (frozen actions),\nthen you might want to switch to freezing actions in a middleware rather than in action creator.\nExample implementation:\n\nconst freezeActions = store => next => action => next(Object.freeze(action))\n",createEmptyArray=e=>Array.apply(null,new Array(e)),wrapSagaDispatch=e=>a=>(check(a,e=>!Object.isFrozen(e),FROZEN_ACTION_ERROR),e(Object.defineProperty(a,SAGA_ACTION,{value:!0}))),shouldTerminate=e=>e===TERMINATE,shouldCancel=e=>e===TASK_CANCEL,shouldComplete=e=>shouldTerminate(e)||shouldCancel(e);function createAllStyleChildCallbacks(e,a){var n=Object.keys(e),t=n.length;check(t,e=>e>0,"createAllStyleChildCallbacks: get an empty array or object");var r,o=0,c=array(e)?createEmptyArray(t):{},s={};return n.forEach(e=>{var n=(n,s)=>{r||(s||shouldComplete(n)?(a.cancel(),a(n,s)):(c[e]=n,++o===t&&(r=!0,a(c))))};n.cancel=noop,s[e]=n}),a.cancel=(()=>{r||(r=!0,n.forEach(e=>s[e].cancel()))}),s}function getMetaInfo(e){return{name:e.name||"anonymous",location:getLocation(e)}}function getLocation(e){return e[SAGA_LOCATION]}var BUFFER_OVERFLOW="Channel's Buffer overflow!",ON_OVERFLOW_THROW=1,ON_OVERFLOW_DROP=2,ON_OVERFLOW_SLIDE=3,ON_OVERFLOW_EXPAND=4,zeroBuffer={isEmpty:kTrue,put:noop,take:noop};function ringBuffer(e,a){void 0===e&&(e=10);var n=new Array(e),t=0,r=0,o=0,c=a=>{n[r]=a,r=(r+1)%e,t++},s=()=>{if(0!=t){var a=n[o];return n[o]=null,t--,o=(o+1)%e,a}},i=()=>{for(var e=[];t;)e.push(s());return e};return{isEmpty:()=>0==t,put:s=>{var l;if(t<e)c(s);else switch(a){case ON_OVERFLOW_THROW:throw new Error(BUFFER_OVERFLOW);case ON_OVERFLOW_SLIDE:n[r]=s,o=r=(r+1)%e;break;case ON_OVERFLOW_EXPAND:l=2*e,n=i(),t=n.length,r=n.length,o=0,n.length=l,e=l,c(s)}},take:s,flush:i}}var none=()=>zeroBuffer,fixed=e=>ringBuffer(e,ON_OVERFLOW_THROW),dropping=e=>ringBuffer(e,ON_OVERFLOW_DROP),sliding=e=>ringBuffer(e,ON_OVERFLOW_SLIDE),expanding=e=>ringBuffer(e,ON_OVERFLOW_EXPAND),buffers=Object.freeze({__proto__:null,none:none,fixed:fixed,dropping:dropping,sliding:sliding,expanding:expanding}),TAKE="TAKE",PUT="PUT",ALL="ALL",RACE="RACE",CALL="CALL",CPS="CPS",FORK="FORK",JOIN="JOIN",CANCEL$1="CANCEL",SELECT="SELECT",ACTION_CHANNEL="ACTION_CHANNEL",CANCELLED="CANCELLED",FLUSH="FLUSH",GET_CONTEXT="GET_CONTEXT",SET_CONTEXT="SET_CONTEXT",effectTypes=Object.freeze({__proto__:null,TAKE:TAKE,PUT:PUT,ALL:ALL,RACE:RACE,CALL:CALL,CPS:CPS,FORK:FORK,JOIN:JOIN,CANCEL:CANCEL$1,SELECT:SELECT,ACTION_CHANNEL:ACTION_CHANNEL,CANCELLED:CANCELLED,FLUSH:FLUSH,GET_CONTEXT:GET_CONTEXT,SET_CONTEXT:SET_CONTEXT});function delayP(e,a){var n;void 0===a&&(a=!0);var t=new Promise(t=>{n=setTimeout(t,e,a)});return t[CANCEL]=(()=>{clearTimeout(n)}),t}var TEST_HINT="\n(HINT: if you are getting these errors in tests, consider using createMockTask from @redux-saga/testing-utils)",makeEffect=(e,a)=>({[IO]:!0,combinator:!1,type:e,payload:a}),isForkEffect=e=>effect(e)&&e.type===FORK,detach=e=>(check(e,isForkEffect,"detach(eff): argument must be a fork effect"),makeEffect(FORK,_extends({},e.payload,{detached:!0})));function take(e,a){if(void 0===e&&(e="*"),arguments.length&&check(arguments[0],notUndef,"take(patternOrChannel): patternOrChannel is undefined"),pattern(e))return makeEffect(TAKE,{pattern:e});if(multicast(e)&&notUndef(a)&&pattern(a))return makeEffect(TAKE,{channel:e,pattern:a});if(channel(e))return makeEffect(TAKE,{channel:e});throw new Error("take(patternOrChannel): argument "+e+" is not valid channel or a valid pattern")}var takeMaybe=function(){var e=take(...arguments);return e.payload.maybe=!0,e};function put(e,a){return arguments.length>1?(check(e,notUndef,"put(channel, action): argument channel is undefined"),check(e,channel,"put(channel, action): argument "+e+" is not a valid channel"),check(a,notUndef,"put(channel, action): argument action is undefined")):check(e,notUndef,"put(action): argument action is undefined"),undef(a)&&(a=e,e=void 0),makeEffect(PUT,{channel:e,action:a})}var putResolve=function(){var e=put(...arguments);return e.payload.resolve=!0,e};function all(e){var a=makeEffect(ALL,e);return a.combinator=!0,a}function race(e){var a=makeEffect(RACE,e);return a.combinator=!0,a}var validateFnDescriptor=(e,a)=>{if(check(a,notUndef,e+": argument fn is undefined or null"),!func(a)){var n,t=null;if(array(a))[t,n]=a,check(n,notUndef,e+": argument of type [context, fn] has undefined or null `fn`");else{if(!object(a))return void check(a,func,e+": argument fn is not function");({context:t,fn:n}=a),check(n,notUndef,e+": argument of type {context, fn} has undefined or null `fn`")}t&&string(n)?check(t[n],func,e+': context arguments has no such method - "'+n+'"'):check(n,func,e+": unpacked fn argument (from [context, fn] or {context, fn}) is not a function")}};function getFnCallDescriptor(e,a){var n,t=null;return func(e)?n=e:(array(e)?[t,n]=e:({context:t,fn:n}=e),t&&string(n)&&func(t[n])&&(n=t[n])),{context:t,fn:n,args:a}}var isNotDelayEffect=e=>e!==delay;function call(e){for(var a=arguments.length,n=new Array(a>1?a-1:0),t=1;t<a;t++)n[t-1]=arguments[t];var r="number"==typeof n[0]?n[0]:"ms";return check(e,isNotDelayEffect,"instead of writing `yield call(delay, "+r+")` where delay is an effect from `redux-saga/effects` you should write `yield delay("+r+")`"),validateFnDescriptor("call",e),makeEffect(CALL,getFnCallDescriptor(e,n))}function apply(e,a,n){return void 0===n&&(n=[]),validateFnDescriptor("apply",[e,a]),makeEffect(CALL,getFnCallDescriptor([e,a],n))}function cps(e){validateFnDescriptor("cps",e);for(var a=arguments.length,n=new Array(a>1?a-1:0),t=1;t<a;t++)n[t-1]=arguments[t];return makeEffect(CPS,getFnCallDescriptor(e,n))}function fork(e){validateFnDescriptor("fork",e),check(e,e=>!effect(e),"fork: argument must not be an effect");for(var a=arguments.length,n=new Array(a>1?a-1:0),t=1;t<a;t++)n[t-1]=arguments[t];return makeEffect(FORK,getFnCallDescriptor(e,n))}function spawn(e){validateFnDescriptor("spawn",e);for(var a=arguments.length,n=new Array(a>1?a-1:0),t=1;t<a;t++)n[t-1]=arguments[t];return detach(fork(e,...n))}function join(e){if(arguments.length>1)throw new Error("join(...tasks) is not supported any more. Please use join([...tasks]) to join multiple tasks.");return array(e)?e.forEach(e=>{check(e,task,"join([...tasks]): argument "+e+" is not a valid Task object "+TEST_HINT)}):check(e,task,"join(task): argument "+e+" is not a valid Task object "+TEST_HINT),makeEffect(JOIN,e)}function cancel(e){if(void 0===e&&(e=SELF_CANCELLATION),arguments.length>1)throw new Error("cancel(...tasks) is not supported any more. Please use cancel([...tasks]) to cancel multiple tasks.");return array(e)?e.forEach(e=>{check(e,task,"cancel([...tasks]): argument "+e+" is not a valid Task object "+TEST_HINT)}):e!==SELF_CANCELLATION&&notUndef(e)&&check(e,task,"cancel(task): argument "+e+" is not a valid Task object "+TEST_HINT),makeEffect(CANCEL$1,e)}function select(e){void 0===e&&(e=identity);for(var a=arguments.length,n=new Array(a>1?a-1:0),t=1;t<a;t++)n[t-1]=arguments[t];return arguments.length&&(check(arguments[0],notUndef,"select(selector, [...]): argument selector is undefined"),check(e,func,"select(selector, [...]): argument "+e+" is not a function")),makeEffect(SELECT,{selector:e,args:n})}function actionChannel(e,a){return check(e,pattern,"actionChannel(pattern,...): argument pattern is not valid"),arguments.length>1&&(check(a,notUndef,"actionChannel(pattern, buffer): argument buffer is undefined"),check(a,buffer,"actionChannel(pattern, buffer): argument "+a+" is not a valid buffer")),makeEffect(ACTION_CHANNEL,{pattern:e,buffer:a})}function cancelled(){return makeEffect(CANCELLED,{})}function flush(e){return check(e,channel,"flush(channel): argument "+e+" is not valid channel"),makeEffect(FLUSH,e)}function getContext(e){return check(e,string,"getContext(prop): argument "+e+" is not a string"),makeEffect(GET_CONTEXT,e)}function setContext(e){return check(e,object,createSetContextWarning(null,e)),makeEffect(SET_CONTEXT,e)}var delay=call.bind(null,delayP);export{shouldCancel as $,ALL as A,getMetaInfo as B,CHANNEL_END_TYPE as C,undef as D,createAllStyleChildCallbacks as E,FORK as F,GET_CONTEXT as G,SELF_CANCELLATION as H,createEmptyArray as I,JOIN as J,assignWithSymbols as K,makeIterator as L,MULTICAST as M,TERMINATE as N,shouldComplete as O,PUT as P,noop as Q,RACE as R,SAGA_ACTION as S,TAKE as T,flatMap as U,getLocation as V,TASK as W,TASK_CANCEL as X,createSetContextWarning as Y,object as Z,asyncIteratorSymbol as _,array as a,shouldTerminate as a0,IO as a1,logError as a2,wrapSagaDispatch as a3,identity as a4,channel as a5,_extends as a6,buffers as a7,SAGA_LOCATION as a8,detach as a9,take as aa,fork as ab,cancel as ac,call as ad,actionChannel as ae,sliding as af,delay as ag,race as ah,effectTypes as ai,takeMaybe as aj,put as ak,putResolve as al,all as am,apply as an,cps as ao,spawn as ap,join as aq,select as ar,cancelled as as,flush as at,getContext as au,setContext as av,stringableFunc as b,symbol as c,check as d,expanding as e,func as f,buffer as g,MATCH as h,none as i,internalErr as j,kTrue as k,CANCEL as l,CALL as m,notUndef as n,once as o,CPS as p,CANCEL$1 as q,remove as r,string as s,SELECT as t,ACTION_CHANNEL as u,CANCELLED as v,FLUSH as w,SET_CONTEXT as x,promise as y,iterator as z};