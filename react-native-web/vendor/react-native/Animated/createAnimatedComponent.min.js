"use strict";function _extends(){return(_extends=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(t[o]=n[o])}return t}).apply(this,arguments)}function _inheritsLoose(t,e){t.prototype=Object.create(e.prototype),t.prototype.constructor=t,t.__proto__=e}import{AnimatedEvent}from"./AnimatedEvent";import AnimatedProps from"./nodes/AnimatedProps";import React from"react";import invariant from"fbjs/lib/invariant";import mergeRefs from"../../../modules/mergeRefs";function createAnimatedComponent(t,e){invariant("function"!=typeof t||t.prototype&&t.prototype.isReactComponent,"`createAnimatedComponent` does not support stateless functional components; use a class component instead.");var n=function(n){function o(t){var e;return(e=n.call(this,t)||this)._invokeAnimatedPropsCallbackOnMount=!1,e._eventDetachers=[],e._animatedPropsCallback=function(){if(null==e._component)e._invokeAnimatedPropsCallbackOnMount=!0;else if(o.__skipSetNativeProps_FOR_TESTS_ONLY||"function"!=typeof e._component.setNativeProps)e.forceUpdate();else{if(e._propsAnimated.__isNative)throw new Error('Attempting to run JS driven animation on animated node that has been moved to "native" earlier by starting an animation with `useNativeDriver: true`');e._component.setNativeProps(e._propsAnimated.__getAnimatedValue())}},e._setComponentRef=mergeRefs(e.props.forwardedRef,function(t){e._prevComponent=e._component,e._component=t,null!=t&&null==t.getNode&&(t.getNode=function(){var e;return console.warn("%s: Calling `getNode()` on the ref of an Animated component is no longer necessary. You can now directly use the ref instead. This method will be removed in a future release.",null!==(e=t.constructor.name)&&void 0!==e?e:"<<anonymous>>"),t})}),e}_inheritsLoose(o,n);var i=o.prototype;return i.componentWillUnmount=function(){this._propsAnimated&&this._propsAnimated.__detach(),this._detachNativeEvents()},i.UNSAFE_componentWillMount=function(){this._attachProps(this.props)},i.componentDidMount=function(){this._invokeAnimatedPropsCallbackOnMount&&(this._invokeAnimatedPropsCallbackOnMount=!1,this._animatedPropsCallback()),this._propsAnimated.setNativeView(this._component),this._attachNativeEvents()},i._attachNativeEvents=function(){var t=this,e=this._component&&this._component.getScrollableNode?this._component.getScrollableNode():this._component,n=function(n){var o=t.props[n];o instanceof AnimatedEvent&&o.__isNative&&(o.__attach(e,n),t._eventDetachers.push(function(){return o.__detach(e,n)}))};for(var o in this.props)n(o)},i._detachNativeEvents=function(){this._eventDetachers.forEach(function(t){return t()}),this._eventDetachers=[]},i._attachProps=function(t){var e=this._propsAnimated;this._propsAnimated=new AnimatedProps(t,this._animatedPropsCallback),e&&e.__detach()},i.UNSAFE_componentWillReceiveProps=function(t){this._attachProps(t)},i.componentDidUpdate=function(t){this._component!==this._prevComponent&&this._propsAnimated.setNativeView(this._component),this._component===this._prevComponent&&t===this.props||(this._detachNativeEvents(),this._attachNativeEvents())},i.render=function(){var n=this._propsAnimated.__getValue();return React.createElement(t,_extends({},e,n,{ref:this._setComponentRef}))},o}(React.Component);n.__skipSetNativeProps_FOR_TESTS_ONLY=!1;t.propTypes;return React.forwardRef(function(t,e){return React.createElement(n,_extends({},t,null==e?null:{forwardedRef:e}))})}export default createAnimatedComponent;