"use strict";import invariant from"fbjs/lib/invariant";function elementsThatOverlapOffsets(t,e,n){for(var a=[],r=0,i=0;i<e;i++)for(var s=n(i),f=s.offset+s.length,l=0;l<t.length;l++)if(null==a[l]&&f>=t[l]&&(a[l]=i,r++,l===t.length-1))return invariant(r===t.length,"bad offsets input, should be in increasing order: %s",JSON.stringify(t)),a;return a}function newRangeCount(t,e){return e.last-e.first+1-Math.max(0,1+Math.min(e.last,t.last)-Math.max(e.first,t.first))}function computeWindowedRenderLimits(t,e,n,a){var r=t.data,i=t.getItemCount,s=t.maxToRenderPerBatch,f=t.windowSize,l=i(r);if(0===l)return e;var o=a.offset,u=a.velocity,m=a.visibleLength,d=Math.max(0,o),h=d+m,v=(f-1)*m,c=u>1?"after":u<-1?"before":"none",g=Math.max(0,d-.5*v),w=Math.max(0,h+.5*v);if(n(l-1).offset<g)return{first:Math.max(0,l-1-s),last:l-1};var p=elementsThatOverlapOffsets([g,d,h,w],t.getItemCount(t.data),n),O=p[0],x=p[1],R=p[2],b=p[3];O=null==O?0:O,b=null==b?l-1:b;for(var M={first:x=null==x?Math.max(0,O):x,last:R=null==R?Math.min(b,x+s-1):R},C=newRangeCount(e,M);!(x<=O&&R>=b);){var L=C>=s,T=x<=e.first||x>e.last,W=x>O&&(!L||!T),y=R>=e.last||R<e.first,z=R<b&&(!L||!y);if(L&&!W&&!z)break;!W||"after"===c&&z&&y||(T&&C++,x--),!z||"before"===c&&W&&T||(y&&C++,R++)}if(!(R>=x&&x>=0&&R<l&&x>=O&&R<=b&&x<=M.first&&R>=M.last))throw new Error("Bad window calculation "+JSON.stringify({first:x,last:R,itemCount:l,overscanFirst:O,overscanLast:b,visible:M}));return{first:x,last:R}}var VirtualizeUtils={computeWindowedRenderLimits:computeWindowedRenderLimits,elementsThatOverlapOffsets:elementsThatOverlapOffsets,newRangeCount:newRangeCount};export{computeWindowedRenderLimits,elementsThatOverlapOffsets,newRangeCount};export default VirtualizeUtils;