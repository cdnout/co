import { default as Long_2 } from 'long';
/**
 * `ActorID` is used to identify who is making changes to the document.
 * It is hexadecimal string and should be generated by unique value.
 *
 * @public
 */
export declare type ActorID = string;
/**
 * @internal
 */
declare interface BaseClientEvent {
    type: ClientEventType;
}
/**
 * @internal
 */
declare interface BaseDocEvent {
    type: DocEventType;
}
/**
 * `Change` represents a unit of modification in the document.
 */
declare class Change {
    private id;
    private operations;
    private message?;
    constructor(id: ChangeID, operations: Operation[], message?: string);
    /**
     * `create` creates a new instance of Change.
     */
    static create(id: ChangeID, operations: Operation[], message?: string): Change;
    /**
     * `getID` returns the ID of this change.
     */
    getID(): ChangeID;
    /**
     * `getMessage` returns the message of this change.
     */
    getMessage(): string | undefined;
    /**
     * `getOperations` returns the operations of this change.
     */
    getOperations(): Operation[];
    /**
     * `setActor` sets the given actor.
     */
    setActor(actorID: ActorID): void;
    /**
     * `execute` executes the operations of this change to the given root.
     */
    execute(root: JSONRoot): void;
    /**
     * `getAnnotatedString` returns a string containing the meta data of this change.
     */
    getAnnotatedString(): string;
}
/**
 * `ChangeContext` is used to record the context of modification when editing
 * a document. Each time we add an operation, a new time ticket is issued.
 * Finally returns a Change after the modification has been completed.
 */
declare class ChangeContext {
    private id;
    private root;
    private operations;
    private message?;
    private delimiter;
    constructor(id: ChangeID, root: JSONRoot, message?: string);
    /**
     * `create` creates a new instance of ChangeContext.
     */
    static create(id: ChangeID, root: JSONRoot, message?: string): ChangeContext;
    /**
     * `push` pushes the given operation to this context.
     */
    push(operation: Operation): void;
    /**
     * `registerElement` registers the given element to the root.
     */
    registerElement(element: JSONElement, parent: JSONArray): void;
    /**
     * `registerRemovedElement` register removed element for garbage collection.
     */
    registerRemovedElement(deleted: JSONElement): void;
    /**
     * `registerRemovedNodeTextElement` register text element has removed node for
     * garbage collection.
     */
    registerRemovedNodeTextElement(text: PlainText): void;
    /**
     * `getChange` creates a new instance of Change in this context.
     */
    getChange(): Change;
    /**
     * `hasOperations` returns the whether this context has operations or not.
     */
    hasOperations(): boolean;
    /**
     * `issueTimeTicket` creates a time ticket to be used to create a new operation.
     */
    issueTimeTicket(): TimeTicket;
}
/**
 * `ChangeID` is for identifying the Change. This is immutable.
 */
declare class ChangeID {
    private clientSeq;
    private serverSeq?;
    private lamport;
    private actor?;
    constructor(clientSeq: number, lamport: Long_2, actor?: ActorID);
    /**
     * `of` creates a new instance of ChangeID.
     */
    static of(clientSeq: number, lamport: Long_2, actor?: ActorID): ChangeID;
    /**
     * `next` creates a next ID of this ID.
     */
    next(): ChangeID;
    /**
     * `syncLamport` syncs lamport timestamp with the given ID.
     *
     * {@link https://en.wikipedia.org/wiki/Lamport_timestamps#Algorithm}
     */
    syncLamport(otherLamport: Long_2): ChangeID;
    /**
     * `createTimeTicket` creates a ticket of the given delimiter.
     */
    createTimeTicket(delimiter: number): TimeTicket;
    /**
     * `setActor` sets the given actor.
     */
    setActor(actorID: ActorID): ChangeID;
    /**
     * `getClientSeq` returns the client sequence of this ID.
     */
    getClientSeq(): number;
    /**
     * `getLamport` returns the lamport clock of this ID.
     */
    getLamport(): Long_2;
    /**
     * `getLamportAsString` returns the lamport clock of this ID as a string.
     */
    getLamportAsString(): string;
    /**
     * `getActorID` returns the actor of this ID.
     */
    getActorID(): string | undefined;
    /**
     * `getAnnotatedString` returns a string containing the meta data of this ID.
     */
    getAnnotatedString(): string;
}
/**
 * `ChangeInfo` represents a pair of `Change` and the JsonPath of the changed
 * element.
 */
declare interface ChangeInfo {
    change: Change;
    paths: Array<string>;
}
/**
 * `ChangePack` is a unit for delivering changes in a document to the remote.
 *
 * @internal
 */
declare class ChangePack {
    /**
     * `key` is the key of the document.
     */
    private key;
    /**
     * `Checkpoint` is used to determine the client received changes.
     */
    private checkpoint;
    private changes;
    /**
     * `snapshot` is a byte array that encode the document.
     */
    private snapshot?;
    /**
     * `minSyncedTicket` is the minimum logical time taken by clients who attach
     * the document. It used to collect garbage on the replica on the client.
     */
    private minSyncedTicket?;
    constructor(key: DocumentKey, checkpoint: Checkpoint, changes: Change[], snapshot?: Uint8Array, minSyncedTicket?: TimeTicket);
    /**
     * `create` creates a new instance of ChangePack.
     */
    static create(key: DocumentKey, checkpoint: Checkpoint, changes: Change[], snapshot?: Uint8Array, minSyncedTicket?: TimeTicket): ChangePack;
    /**
     * `getKey` returns the document key of this pack.
     */
    getKey(): DocumentKey;
    /**
     * `getCheckpoint` returns the checkpoint of this pack.
     */
    getCheckpoint(): Checkpoint;
    /**
     * `getChanges` returns the changes of this pack.
     */
    getChanges(): Change[];
    /**
     * `hasChanges` returns the whether this pack has changes or not.
     */
    hasChanges(): boolean;
    /**
     * `getChangeSize` returns the size of changes this pack has.
     */
    getChangeSize(): number;
    /**
     * `hasSnapshot` returns the whether this pack has a snapshot or not.
     */
    hasSnapshot(): boolean;
    /**
     * `getSnapshot` returns the snapshot of this pack.
     */
    getSnapshot(): Uint8Array | undefined;
    /**
     * `getMinSyncedTicket` returns the minimum synced ticket of this pack.
     */
    getMinSyncedTicket(): TimeTicket | undefined;
}
/**
 * `Checkpoint` is used to determine the changes sent and received by the
 * client. This is immutable.
 *
 * @internal
 **/
declare class Checkpoint {
    private serverSeq;
    private clientSeq;
    constructor(serverSeq: Long_2, clientSeq: number);
    /**
     * `of` creates a new instance of Checkpoint.
     */
    static of(serverSeq: Long_2, clientSeq: number): Checkpoint;
    /**
     * `increaseClientSeq` creates a new instance with increased client sequence.
     */
    increaseClientSeq(inc: number): Checkpoint;
    /**
     * `forward` updates the given checkpoint with those values when it is greater
     * than the values of internal properties.
     */
    forward(other: Checkpoint): Checkpoint;
    /**
     * `getServerSeqAsString` returns the server seq of this checkpoint as a
     * string.
     */
    getServerSeqAsString(): string;
    /**
     * `getClientSeq` returns the client seq of this checkpoint.
     */
    getClientSeq(): number;
    /**
     * `getServerSeq` returns the server seq of this checkpoint.
     */
    getServerSeq(): Long_2;
    /**
     * `equals` returns whether the given checkpoint is equal to this checkpoint
     * or not.
     */
    equals(other: Checkpoint): boolean;
    /**
     * `getAnnotatedString` returns a string containing the meta data of this
     * checkpoint.
     */
    getAnnotatedString(): string;
}
/**
 * `Client` is a normal client that can communicate with the agent.
 * It has documents and sends changes of the documents in local
 * to the agent to synchronize with other replicas in remote.
 *
 * @public
 */
export declare class Client<M = Indexable> implements Observable<ClientEvent<M>> {
    private id?;
    private key;
    private metadataInfo;
    private status;
    private attachmentMap;
    private syncLoopDuration;
    private reconnectStreamDelay;
    private rpcClient;
    private watchLoopTimerID?;
    private remoteChangeEventStream?;
    private eventStream;
    private eventStreamObserver;
    private constructor();
    /**
     * `ativate` activates this client. That is, it register itself to the agent
     * and receives a unique ID from the agent. The given ID is used to
     * distinguish different clients.
     */
    activate(): Promise<void>;
    /**
     * `deactivate` deactivates this client.
     */
    deactivate(): Promise<void>;
    /**
     * `attach` attaches the given document to this client. It tells the agent that
     * this client will synchronize the given document.
     */
    attach(doc: DocumentReplica<unknown>, isManualSync?: boolean): Promise<DocumentReplica<unknown>>;
    /**
     * `detach` detaches the given document from this client. It tells the
     * agent that this client will no longer synchronize the given document.
     *
     * To collect garbage things like CRDT tombstones left on the document, all
     * the changes should be applied to other replicas before GC time. For this,
     * if the document is no longer used by this client, it should be detached.
     */
    detach(doc: DocumentReplica<unknown>): Promise<DocumentReplica<unknown>>;
    /**
     * `sync` pushes local changes of the attached documents to the Agent and
     * receives changes of the remote replica from the agent then apply them to
     * local documents.
     */
    sync(): Promise<DocumentReplica<unknown>[]>;
    /**
     * `updateMetadata` updates the metadata of this client.
     */
    updateMetadata<K extends keyof M>(key: K, value: M[K]): Promise<void>;
    /**
     * `subscribe` subscribes to the given topics.
     */
    subscribe(nextOrObserver: Observer<ClientEvent<M>> | NextFn<ClientEvent<M>>, error?: ErrorFn, complete?: CompleteFn): Unsubscribe;
    /**
     * `getID` returns a ActorID of client.
     */
    getID(): string | undefined;
    /**
     * `getKey` returns a key of client.
     */
    getKey(): string;
    /**
     * `isActive` checks if the client is active.
     */
    isActive(): boolean;
    /**
     * `getStatus` returns the status of this client.
     */
    getStatus(): ClientStatus;
    /**
     * `getMetadata` returns the metadata of this client.
     */
    getMetadata(): M;
    /**
     * `getPeers` returns the peers of the given document.
     */
    getPeers(key: string): Record<string, M>;
    private runSyncLoop;
    private runWatchLoop;
    private handleWatchDocumentsResponse;
    private syncInternal;
}
/**
 * `ClientEvent` is an event that occurs in `Client`. It can be delivered using
 * `Client.subscribe()`.
 *
 * @public
 */
export declare type ClientEvent<M = Indexable> = StatusChangedEvent | DocumentsChangedEvent | PeersChangedEvent<M> | StreamConnectionStatusChangedEvent | DocumentSyncedEvent;
/**
 * `ClientEventType` is client event types
 * @public
 */
export declare enum ClientEventType {
    /**
     * client event type when status changed.
     */
    StatusChanged = "status-changed",
    /**
     * client event type when documents changed.
     */
    DocumentsChanged = "documents-changed",
    /**
     * client event type when peers changed.
     */
    PeersChanged = "peers-changed",
    /**
     * client event type when stream connection changed.
     */
    StreamConnectionStatusChanged = "stream-connection-status-changed",
    /**
     * client event type when document synced.
     */
    DocumentSynced = "document-synced"
}
/**
 * `ClientOptions` are user-settable options used when defining clients.
 *
 * @public
 */
export declare interface ClientOptions<M> {
    key?: string;
    metadata?: M;
    token?: string;
    syncLoopDuration?: number;
    reconnectStreamDelay?: number;
}
/**
 * `ClientStatus` is client status types
 * @public
 */
export declare enum ClientStatus {
    /**
     * client deactivated status
     */
    Deactivated = "deactivated",
    /**
     * client activated status
     */
    Activated = "activated"
}
declare type Comparator<K> = (keyA: K, keyB: K) => number;
/**
 * @internal
 */
export declare type CompleteFn = () => void;
/**
 * `Counter` represents changeable number data type.
 *
 * @public
 */
declare class Counter extends JSONElement {
    private valueType?;
    private value;
    constructor(value: CounterValue, createdAt: TimeTicket);
    /**
     * `of` creates a new instance of Counter.
     */
    static of(value: CounterValue, createdAt: TimeTicket): JSONElement;
    /**
     * `valueFromBytes` parses the given bytes into value.
     */
    static valueFromBytes(counterType: CounterType, bytes: Uint8Array): CounterValue;
    /**
     * `toJSON` returns the JSON encoding of the value.
     */
    toJSON(): string;
    /**
     * `toSortedJSON` returns the sorted JSON encoding of the value.
     */
    toSortedJSON(): string;
    /**
     * `deepcopy` copies itself deeply.
     */
    deepcopy(): JSONElement;
    /**
     * `getType` returns the type of the value.
     */
    getType(): CounterType;
    /**
     * `getCounterType` returns counter type of given value.
     */
    static getCounterType(value: CounterValue): CounterType | undefined;
    /**
     * `isSupport` check if there is a counter type of given value.
     */
    static isSupport(value: CounterValue): boolean;
    /**
     * `isInteger` checks if the num is integer.
     */
    static isInteger(num: number): boolean;
    /**
     * `isNumericType` check numeric type by JSONCounter.
     */
    isNumericType(): boolean;
    /**
     * `getValue` get counter value.
     */
    getValue(): CounterValue;
    /**
     * `toBytes` creates an array representing the value.
     */
    toBytes(): Uint8Array;
    /**
     * `increase` increases numeric data.
     */
    increase(v: JSONElement): JSONElement;
}
/**
 * CounterProxy is a proxy representing Counter types.
 *
 * @internal
 */
declare class CounterProxy {
    private context;
    private handlers;
    private counter;
    constructor(context: ChangeContext, counter: JSONElement);
    /**
     * `create` creates a new instance of CounterProxy.
     */
    static create(context: ChangeContext, target: JSONElement): JSONElement;
    /**
     * `increase` adds an increase operation.
     * Only numeric types are allowed as operand values.
     */
    increase(v: number | Long_2): CounterProxy;
    /**
     * `getHandlers` gets handlers.
     */
    getHandlers(): any;
}
/**
 * @internal
 */
declare enum CounterType {
    IntegerCnt = 0,
    LongCnt = 1,
    DoubleCnt = 2
}
declare type CounterValue = number | Long_2;
/**
 * `createClient` creates a new instance of `Client`.
 *
 * @public
 */
export declare function createClient<M = Indexable>(rpcAddr: string, opts?: ClientOptions<M>): Client<M>;
/**
 * `createDocument` creates a new instance of `DocumentReplica`.
 *
 * @public
 */
export declare function createDocument<T = Indexable>(collection: string, document: string): DocumentReplica<T>;
/**
 * `DocEvent` is an event that occurs in `DocumentReplica`. It can be delivered
 * using `DocumentReplica.subscribe()`.
 *
 * @public
 */
export declare type DocEvent = SnapshotEvent | LocalChangeEvent | RemoteChangeEvent;
/**
 * `DocEventType` is document event types
 * @public
 */
export declare enum DocEventType {
    /**
     * snapshot event type
     */
    Snapshot = "snapshot",
    /**
     * local document change event type
     */
    LocalChange = "local-change",
    /**
     * remote document change event type
     */
    RemoteChange = "remote-change"
}
/**
 * `DocumentKey` represents the key of the Document.
 *
 * @internal
 */
declare class DocumentKey {
    private collection;
    private document;
    constructor(collection: string, document: string);
    /**
     * `create` creates a new instance of DocumentKey.
     */
    static of(collection: string, document: string): DocumentKey;
    /**
     * `getCollection` return the collection string.
     */
    getCollection(): string;
    /**
     * `getDocument` return the document string.
     */
    getDocument(): string;
    /**
     * `toIDString` returns the key string for this Document.
     */
    toIDString(): string;
}
/**
 * `DocumentReplica` is a CRDT-based data type. We can representing the model
 * of the application. And we can edit it even while offline.
 *
 * @public
 */
export declare class DocumentReplica<T = Indexable> implements Observable<DocEvent> {
    private key;
    private root;
    private clone?;
    private changeID;
    private checkpoint;
    private localChanges;
    private eventStream;
    private eventStreamObserver;
    private constructor();
    /**
     * `create` creates a new instance of Document.
     */
    static create<T = Indexable>(collection: string, document: string): DocumentReplica<T>;
    /**
     * `update` executes the given updater to update this document.
     */
    update(updater: (root: T & JSONObject) => void, message?: string): void;
    /**
     * `subscribe` adds the given observer to the fan-out list.
     */
    subscribe(nextOrObserver: Observer<DocEvent> | NextFn<DocEvent>, error?: ErrorFn, complete?: CompleteFn): Unsubscribe;
    /**
     * `applyChangePack` applies the given change pack into this document.
     * 1. Remove local changes applied to server.
     * 2. Update the checkpoint.
     * 3. Do Garbage collection.
     *
     * @param pack - change pack
     * @internal
     */
    applyChangePack(pack: ChangePack): void;
    /**
     * `getCheckpoint` returns the checkpoint of this document.
     *
     * @internal
     */
    getCheckpoint(): Checkpoint;
    /**
     * `hasLocalChanges` returns whether this document has local changes or not.
     *
     * @internal
     */
    hasLocalChanges(): boolean;
    /**
     * `ensureClone` make a clone of root.
     *
     * @internal
     */
    ensureClone(): void;
    /**
     * `createChangePack` create change pack of the local changes to send to the
     * remote server.
     *
     * @internal
     */
    createChangePack(): ChangePack;
    /**
     * `setActor` sets actor into this document. This is also applied in the local
     * changes the document has.
     *
     * @internal
     */
    setActor(actorID: ActorID): void;
    /**
     * `getKey` returns the key of this document as a string. The string is
     * a combination pattern of collection and document.
     * e.g. `Collection$Document`;
     */
    getKey(): string;
    /**
     * `getDocumentKey` returns the key of this document.
     *
     * @internal
     */
    getDocumentKey(): DocumentKey;
    /**
     * `getClone` return clone object.
     *
     * @internal
     */
    getClone(): JSONObject | undefined;
    /**
     * `getRoot` returns a new proxy of cloned root.
     */
    getRoot(): T;
    /**
     * `garbageCollect` purges elements that were removed before the given time.
     *
     * @internal
     */
    garbageCollect(ticket: TimeTicket): number;
    /**
     * `getRootObject` returns root object.
     *
     * @internal
     */
    getRootObject(): JSONObject;
    /**
     * `getGarbageLen` returns the length of elements should be purged.
     *
     * @internal
     */
    getGarbageLen(): number;
    /**
     * `toJSON` returns the JSON encoding of this array.
     */
    toJSON(): string;
    /**
     * `toJSON` returns the sorted JSON encoding of this array.
     */
    toSortedJSON(): string;
    private applySnapshot;
    private applyChanges;
    private createPaths;
}
/**
 * `DocumentsChangedEvent` is an event that occurs when documents attached to
 * the client changes.
 *
 * @public
 */
export declare interface DocumentsChangedEvent {
    /**
     * enum {@link ClientEventType}.DocumentsChangedEvent
     */
    type: ClientEventType.DocumentsChanged;
    /**
     * `DocumentsChangedEvent` value
     */
    value: Array<DocumentKey>;
}
/**
 * `DocumentSyncedEvent` is an event that occurs when documents
 * attached to the client are synced.
 *
 * @public
 */
export declare interface DocumentSyncedEvent {
    /**
     * `DocumentSyncedEvent` type
     * enum {@link ClientEventType}.DocumentSyncedEvent
     */
    type: ClientEventType.DocumentSynced;
    /**
     * `DocumentSyncedEvent` value
     */
    value: DocumentSyncResultType;
}
/**
 * `DocumentSyncResultType` is document sync result types
 * @public
 */
export declare enum DocumentSyncResultType {
    /**
     * type when Document synced.
     */
    Synced = "synced",
    /**
     * type when Document sync failed.
     */
    SyncFailed = "sync-failed"
}
/**
 * @internal
 */
export declare type ErrorFn = (error: Error) => void;
declare type Executor<T> = (observer: Observer<T>) => void;
/**
 * `HeapNode` is a node of `Heap`.
 */
declare class HeapNode<K, V> {
    private key;
    private value;
    constructor(key: K, value: V);
    /**
     * `getKey` returns a key of HeapNode.
     */
    getKey(): K;
    /**
     * `getValue` returns a value of HeapNode.
     */
    getValue(): V;
}
/**
 * Indexable key, value
 * @public
 */
export declare type Indexable = Record<string, any>;
/**
 * `JSONArray` represents JSON array data structure including logical clock.
 *
 * @internal
 */
export declare class JSONArray {
    private elements;
    private constructor();
    /**
     * `create` creates a new instance of Array.
     */
    static create(createdAt: TimeTicket): JSONArray;
    /**
     * `keyof` returns key of the given `createdAt` element.
     */
    keyOf(createdAt: TimeTicket): string | undefined;
    /**
     * `purge` physically purge child element.
     */
    purge(element: JSONElement): void;
    /**
     * `insertAfter` inserts the given element after the given previous element.
     */
    insertAfter(prevCreatedAt: TimeTicket, value: JSONElement): void;
    /**
     * `moveAfter` moves the given `createdAt` element after the `prevCreatedAt`.
     */
    moveAfter(prevCreatedAt: TimeTicket, createdAt: TimeTicket, executedAt: TimeTicket): void;
    /**
     * `get` returns the element of the given createAt.
     */
    get(createdAt: TimeTicket): JSONElement | undefined;
    /**
     * `getByIndex` returns the element of the given index.
     */
    getByIndex(index: number): JSONElement | undefined;
    /**
     * `getHead` returns dummy head element.
     */
    getHead(): JSONElement;
    /**
     * `getLast` returns last element.
     */
    getLast(): JSONElement;
    /**
     * `getPrevCreatedAt` returns the creation time of
     * the previous element of the given element.
     */
    getPrevCreatedAt(createdAt: TimeTicket): TimeTicket;
    /**
     * `delete` deletes the element of the given index.
     */
    delete(createdAt: TimeTicket, editedAt: TimeTicket): JSONElement;
    /**
     * `deleteByIndex` deletes the element of given index and editedAt.
     */
    deleteByIndex(index: number, editedAt: TimeTicket): JSONElement | undefined;
    /**
     * `getLastCreatedAt` get last created element.
     */
    getLastCreatedAt(): TimeTicket;
    /**
     * `length` returns length of this elements.
     */
    get length(): number;
    /**
     * eslint-disable-next-line jsdoc/require-jsdoc
     * @internal
     */
    [Symbol.iterator](): IterableIterator<JSONElement>;
    /**
     * `getDescendants` traverse the descendants of this array.
     */
    getDescendants(callback: (elem: JSONElement, parent: JSONArray) => boolean): void;
    /**
     * `toJSON` returns the JSON encoding of this array.
     */
    toJSON(): string;
    /**
     * `toJS` return the javascript object of this array.
     */
    toJS(): any;
    /**
     * `toSortedJSON` returns the sorted JSON encoding of this array.
     */
    toSortedJSON(): string;
    /**
     * `getElements` returns an array of elements contained in this RGATreeList.
     */
    getElements(): RGATreeList;
    /**
     * `deepcopy` copies itself deeply.
     */
    deepcopy(): JSONArray;
}
/**
 *
 * `JSONContainer` represents Array or Object.
 * @internal
 */
declare abstract class JSONContainer extends JSONElement {
    constructor(createdAt: TimeTicket);
    abstract keyOf(createdAt: TimeTicket): string | undefined;
    abstract purge(element: JSONElement): void;
    abstract delete(createdAt: TimeTicket, executedAt: TimeTicket): JSONElement;
    abstract getDescendants(callback: (elem: JSONElement, parent: JSONArray) => boolean): void;
}
/**
 * `JSONElement` represents JSON element including logical clock.
 *
 * @internal
 */
export declare abstract class JSONElement {
    private createdAt;
    private movedAt?;
    private removedAt?;
    constructor(createdAt: TimeTicket);
    /**
     * `getCreatedAt` returns the creation time of this element.
     */
    getCreatedAt(): TimeTicket;
    /**
     * `getID` returns the creation time of this element.
     */
    getID(): TimeTicket;
    /**
     * `getMovedAt` returns the move time of this element.
     */
    getMovedAt(): TimeTicket | undefined;
    /**
     * `getRemovedAt` returns the removal time of this element.
     */
    getRemovedAt(): TimeTicket | undefined;
    /**
     * `setMovedAt` sets the move time of this element.
     */
    setMovedAt(movedAt?: TimeTicket): boolean;
    /**
     * `setRemovedAt` sets the remove time of this element.
     */
    setRemovedAt(removedAt?: TimeTicket): void;
    /**
     * `remove` removes this element.
     */
    remove(removedAt?: TimeTicket): boolean;
    /**
     * `isRemoved` check if this element was removed.
     */
    isRemoved(): boolean;
    abstract toJSON(): string;
    abstract toSortedJSON(): string;
    abstract deepcopy(): JSONElement;
}
/**
 * `JSONObject` represents a JSON object, but unlike regular JSON, it has time
 * tickets which is created by logical clock.
 *
 * @internal
 */
export declare class JSONObject {
    private memberNodes;
    private constructor();
    /**
     * `create` creates a new instance of Object.
     */
    static create(createdAt: TimeTicket): JSONObject;
    /**
     * Don't use createText directly. Be sure to use it through a proxy.
     * The reason for setting the PlainText type as the return value
     * is to provide the PlainText interface to the user.
     */
    createText(key: string): PlainText;
    /**
     * Don't use createRichText directly. Be sure to use it through a proxy.
     * The reason for setting the RichText type as the return value
     * is to provide the RichText interface to the user.
     */
    createRichText(key: string): RichText;
    /**
     * `keyOf` returns a key of RHTPQMap based on the given creation time.
     */
    keyOf(createdAt: TimeTicket): string | undefined;
    /**
     * `purge` physically purges child element.
     */
    purge(value: JSONElement): void;
    /**
     * Don't use createCounter directly. Be sure to use it through a proxy.
     * The reason for setting the CounterProxy type as the return value
     * is to provide the CounterProxy interface to the user.
     */
    createCounter(key: string, value: CounterType): CounterProxy;
    /**
     * `set` sets the given element of the given key.
     */
    set(key: string, value: JSONElement): JSONElement | undefined;
    /**
     * `delete` deletes the element of the given key.
     */
    delete(createdAt: TimeTicket, executedAt: TimeTicket): JSONElement;
    /**
     * `deleteByKey` deletes the element of the given key and execution time.
     */
    deleteByKey(key: string, executedAt: TimeTicket): JSONElement | undefined;
    /**
     * `get` returns the value of the given key.
     */
    get(key: string): JSONElement | undefined;
    /**
     * `has` returns whether the element exists of the given key or not.
     */
    has(key: string): boolean;
    /**
     * `toJSON` returns the JSON encoding of this object.
     */
    toJSON(): string;
    /**
     * `toJS` return the javascript object of this object.
     */
    toJS(): any;
    /**
     * `getKeys` returns array of this object.
     */
    getKeys(): Array<string>;
    /**
     * `toSortedJSON` returns the sorted JSON encoding of this object.
     */
    toSortedJSON(): string;
    /**
     * `getRHT` RHTNodes returns the RHTPQMap nodes.
     */
    getRHT(): RHTPQMap;
    /**
     * `deepcopy` copies itself deeply.
     */
    deepcopy(): JSONObject;
    /**
     * `getDescendants` returns the descendants of this object by traversing.
     */
    getDescendants(callback: (elem: JSONElement, parent: JSONArray) => boolean): void;
    /**
     * eslint-disable-next-line jsdoc/require-jsdoc
     * @internal
     */
    [Symbol.iterator](): IterableIterator<[string, JSONElement]>;
}
/**
 * `JSONPrimitive` represents JSON primitive data type including logical lock.
 * This is immutable.
 */
declare class JSONPrimitive extends JSONElement {
    private valueType;
    private value;
    constructor(value: PrimitiveValue, createdAt: TimeTicket);
    /**
     * `of` creates a new instance of Primitive.
     */
    static of(value: PrimitiveValue, createdAt: TimeTicket): JSONElement;
    /**
     * `valueFromBytes` parses the given bytes into value.
     */
    static valueFromBytes(primitiveType: PrimitiveType, bytes: Uint8Array): PrimitiveValue;
    /**
     * `toJSON` returns the JSON encoding of the value.
     */
    toJSON(): string;
    /**
     * `toSortedJSON` returns the sorted JSON encoding of the value.
     */
    toSortedJSON(): string;
    /**
     * `deepcopy` copies itself deeply.
     */
    deepcopy(): JSONElement;
    /**
     * `getType` returns the type of the value.
     */
    getType(): PrimitiveType;
    /**
     * `getPrimitiveType` returns the primitive type of the value.
     */
    static getPrimitiveType(value: unknown): PrimitiveType | undefined;
    /**
     * `isSupport` check if the given value is supported type.
     */
    static isSupport(value: unknown): boolean;
    /**
     * `isInteger` checks if the given number is integer.
     */
    static isInteger(num: number): boolean;
    /**
     * `isNumericType` checks numeric type by JSONPrimitive
     */
    isNumericType(): boolean;
    /**
     * `getValue` returns the value of Primitive.
     */
    getValue(): PrimitiveValue;
    /**
     * `toBytes` creates an array representing the value.
     */
    toBytes(): Uint8Array;
}
/**
 * `JSONRoot` is a structure represents the root of JSON. It has a hash table of
 * all JSON elements to find a specific element when applying remote changes
 * received from agent.
 *
 * Every element has a unique time ticket at creation, which allows us to find
 * a particular element.
 */
declare class JSONRoot {
    private rootObject;
    private elementPairMapByCreatedAt;
    private removedElementSetByCreatedAt;
    private textWithGarbageSetByCreatedAt;
    constructor(rootObject: JSONObject);
    /**
     * `create` creates a new instance of Root.
     */
    static create(): JSONRoot;
    /**
     * `findByCreatedAt` returns the element of given creation time.
     */
    findByCreatedAt(createdAt: TimeTicket): JSONElement | undefined;
    /**
     * `createPath` creates path of the given element.
     */
    createPath(createdAt: TimeTicket): string | undefined;
    /**
     * `registerElement` registers the given element to hash table.
     */
    registerElement(element: JSONElement, parent: JSONArray): void;
    /**
     * `deregisterElement` deregister the given element from hash table.
     */
    deregisterElement(element: JSONElement): void;
    /**
     * `registerRemovedElement` registers the given element to hash table.
     */
    registerRemovedElement(element: JSONElement): void;
    /**
     * `registerTextWithGarbage` registers the given text to hash set.
     */
    registerTextWithGarbage(text: PlainText): void;
    /**
     * `getElementMapSize` returns the size of element map.
     */
    getElementMapSize(): number;
    /**
     * `getRemovedElementSetSize()` returns the size of removed element set.
     */
    getRemovedElementSetSize(): number;
    /**
     * `getObject` returns root object.
     */
    getObject(): JSONObject;
    /**
     * `getGarbageLen` returns length of nodes which should garbage collection task
     */
    getGarbageLen(): number;
    /**
     * `deepcopy` copies itself deeply.
     */
    deepcopy(): JSONRoot;
    /**
     * `garbageCollect` purges elements that were removed before the given time.
     */
    garbageCollect(ticket: TimeTicket): number;
    private garbageCollectInternal;
    /**
     * `toJSON` returns the JSON encoding of this root object.
     */
    toJSON(): string;
    /**
     * `toSortedJSON` returns the sorted JSON encoding of this root object.
     */
    toSortedJSON(): string;
}
/**
 * `LocalChangeEvent` is an event that occurs when the document is changed
 * by local changes.
 *
 * @public
 */
export declare interface LocalChangeEvent {
    /**
     * enum {@link DocEventType}.LocalChange
     */
    type: DocEventType.LocalChange;
    /**
     * LocalChangeEvent type
     */
    value: Array<ChangeInfo>;
}
/**
 * `MetadataInfo` is metadata information of this client.
 *
 * @public
 */
export declare type MetadataInfo<M> = {
    clock: number;
    data: M;
};
/**
 * @internal
 */
export declare type NextFn<T> = (value: T) => void;
/**
 * @internal
 */
export declare interface Observable<T> {
    subscribe: SubscribeFn<T>;
    getProxy?: () => Observer<T>;
}
/**
 * @internal
 */
export declare interface Observer<T> {
    next: NextFn<T>;
    error?: ErrorFn;
    complete?: CompleteFn;
}
/**
 * `ObserverProxy` is proxy of `Observer`.
 */
declare class ObserverProxy<T> implements Observer<T> {
    finalized: boolean;
    onNoObservers: Executor<T> | undefined;
    private observers;
    private unsubscribes;
    private observerCount;
    private task;
    private finalError?;
    constructor(executor: Executor<T>, onNoObservers?: Executor<T>);
    /**
     * `next` iterates next observer.
     */
    next(value: T): void;
    /**
     * `error` invoke error.
     */
    error(error: Error): void;
    /**
     * `complete` completes observer.
     */
    complete(): void;
    /**
     * `subscribe` is a function for subscribing observer.
     */
    subscribe(nextOrObserver: Observer<T> | NextFn<T>, error?: ErrorFn, complete?: CompleteFn): Unsubscribe;
    private unsubscribeOne;
    private forEachObserver;
    private sendOne;
    private close;
}
/**
 * `Operation` represents an operation to be executed on a document.
 */
declare abstract class Operation {
    private parentCreatedAt;
    private executedAt;
    constructor(parentCreatedAt: TimeTicket, executedAt: TimeTicket);
    /**
     * `getParentCreatedAt` returns the creation time of the target element to
     * execute the operation.
     */
    getParentCreatedAt(): TimeTicket;
    /**
     * `getExecutedAt` returns execution time of this operation.
     */
    getExecutedAt(): TimeTicket;
    /**
     * `setActor` sets the given actor to this operation.
     */
    setActor(actorID: ActorID): void;
    /**
     * `getEffectedCreatedAt` returns the time of the effected element.
     */
    abstract getEffectedCreatedAt(): TimeTicket;
    /**
     * `getAnnotatedString` returns a string containing the meta data.
     */
    abstract getAnnotatedString(): string;
    /**
     * `execute` executes this operation on the given document(`root`).
     */
    abstract execute(root: JSONRoot): void;
}
/**
 * `PeersChangedEvent` is an event that occurs when the states of another peers
 * of the attached documents changes.
 *
 * @public
 */
export declare interface PeersChangedEvent<M> {
    /**
     * enum {@link ClientEventType}.PeersChangedEvent
     */
    type: ClientEventType.PeersChanged;
    /**
     * `PeersChangedEvent` value
     */
    value: Record<string, Record<string, M>>;
}
/**
 * `PlainText` represents plain text element
 * Text is an extended data type for the contents of a text editor
 *
 * @internal
 */
export declare class PlainText {
    private onChangesHandler?;
    private rgaTreeSplit;
    private selectionMap;
    private remoteChangeLock;
    private constructor();
    /**
     * `create` creates a new instance of `PlainText`.
     */
    static create(rgaTreeSplit: RGATreeSplit<string>, createdAt: TimeTicket): PlainText;
    /**
     * Don't use edit directly. Be sure to use it through a proxy.
     * The reason for setting the PlainText type as the return value
     * is to provide the PlainText interface to the user.
     */
    edit(fromIdx: number, toIdx: number, content: string): PlainText;
    /**
     * `editInternal` edits the given range with the given content.
     *
     * @internal
     */
    editInternal(range: RGATreeSplitNodeRange, content: string, editedAt: TimeTicket, latestCreatedAtMapByActor?: Map<string, TimeTicket>): Map<string, TimeTicket>;
    /**
     * Don't use select directly. Be sure to use it through a proxy.
     */
    select(fromIdx: number, toIdx: number): void;
    /**
     * `selectInternal` updates selection info of the given selection range.
     *
     * @internal
     */
    selectInternal(range: RGATreeSplitNodeRange, updatedAt: TimeTicket): void;
    /**
     * `hasRemoteChangeLock` checks whether remoteChangeLock has.
     */
    hasRemoteChangeLock(): boolean;
    /**
     * onChanges registers a handler of onChanges event.
     */
    onChanges(handler: (changes: Array<TextChange>) => void): void;
    /**
     * `createRange` returns pair of RGATreeSplitNodePos of the given integer offsets.
     */
    createRange(fromIdx: number, toIdx: number): RGATreeSplitNodeRange;
    /**
     * `toJSON` returns the JSON encoding of this text.
     */
    toJSON(): string;
    /**
     * `toSortedJSON` returns the sorted JSON encoding of this text.
     */
    toSortedJSON(): string;
    /**
     * `getValue` returns the JSON encoding of rgaTreeSplit.
     */
    getValue(): string;
    /**
     * `getRGATreeSplit` returns the rgaTreeSplit.
     *
     * @internal
     */
    getRGATreeSplit(): RGATreeSplit<string>;
    /**
     * `getAnnotatedString` returns a String containing the meta data of the text.
     */
    getAnnotatedString(): string;
    /**
     * `getRemovedNodesLen` returns length of removed nodes.
     */
    getRemovedNodesLen(): number;
    /**
     * `purgeTextNodesWithGarbage` physically purges nodes that have been removed.
     *
     * @internal
     */
    purgeTextNodesWithGarbage(ticket: TimeTicket): number;
    /**
     * `deepcopy` copies itself deeply.
     */
    deepcopy(): PlainText;
    private selectPriv;
}
declare enum PrimitiveType {
    Null = 0,
    Boolean = 1,
    Integer = 2,
    Long = 3,
    Double = 4,
    String = 5,
    Bytes = 6,
    Date = 7
}
declare type PrimitiveValue = null | boolean | number | Long_2 | string | Uint8Array | Date;
/**
 * `RemoteChangeEvent` is an event that occurs when the document is changed
 * by remote changes.
 *
 * @public
 */
export declare interface RemoteChangeEvent {
    /**
     * enum {@link DocEventType}.RemoteChange
     */
    type: DocEventType.RemoteChange;
    /**
     * RemoteChangeEvent type
     */
    value: Array<ChangeInfo>;
}
/**
 * `RGATreeList` is replicated growable array.
 *
 * @internal
 */
declare class RGATreeList {
    private dummyHead;
    private last;
    private size;
    private nodeMapByIndex;
    private nodeMapByCreatedAt;
    constructor();
    /**
     * `create` creates instance of RGATreeList.
     */
    static create(): RGATreeList;
    /**
     * `length` returns size of RGATreeList.
     */
    get length(): number;
    /**
     * `findNextBeforeExecutedAt` returns the node by the given createdAt and
     * executedAt. It passes through nodes created after executedAt from the
     * given node and returns the next node.
     * @param createdAt - created time
     * @param executedAt - executed time
     * @returns next node
     */
    private findNextBeforeExecutedAt;
    private release;
    /**
     * `insertAfter` adds next element of previously created node.
     */
    insertAfter(prevCreatedAt: TimeTicket, value: JSONElement, executedAt?: TimeTicket): void;
    /**
     * `moveAfter` moves the given `createdAt` element
     * after the `prevCreatedAt` element.
     */
    moveAfter(prevCreatedAt: TimeTicket, createdAt: TimeTicket, executedAt: TimeTicket): void;
    /**
     * `insert` adds the given element after  the last creation time.
     */
    insert(value: JSONElement): void;
    /**
     * `get` returns the element of the given index.
     */
    get(createdAt: TimeTicket): JSONElement | undefined;
    /**
     * `keyOf` key based on the creation time of the node.
     */
    keyOf(createdAt: TimeTicket): string | undefined;
    /**
     * `purge` physically purges child element.
     */
    purge(element: JSONElement): void;
    /**
     * `getByIndex` returns node of the given index.
     */
    getByIndex(idx: number): RGATreeListNode | undefined;
    /**
     * `getPrevCreatedAt` returns a creation time of the previous node.
     */
    getPrevCreatedAt(createdAt: TimeTicket): TimeTicket;
    /**
     * `delete` deletes the node of the given creation time.
     */
    delete(createdAt: TimeTicket, editedAt: TimeTicket): JSONElement;
    /**
     * `deleteByIndex` deletes the node of the given index.
     */
    deleteByIndex(index: number, editedAt: TimeTicket): JSONElement | undefined;
    /**
     * `getHead` returns the value of head elements.
     */
    getHead(): JSONElement;
    /**
     * `getLast` returns the value of last elements.
     */
    getLast(): JSONElement;
    /**
     * `getLastCreatedAt` returns the creation time of last elements.
     */
    getLastCreatedAt(): TimeTicket;
    /**
     * `getAnnotatedString` returns a String containing the meta data of the node id
     * for debugging purpose.
     */
    getAnnotatedString(): string;
    [Symbol.iterator](): IterableIterator<RGATreeListNode>;
}
/**
 * `RGATreeListNode` is a node of RGATreeList.
 */
declare class RGATreeListNode {
    private prev?;
    private next?;
    constructor(value: JSONElement);
    /**
     * `createAfter` creates a new node after the previous node.
     */
    static createAfter(prev: RGATreeListNode, value: JSONElement): RGATreeListNode;
    /**
     * `remove` removes value based on removing time.
     */
    remove(removedAt: TimeTicket): boolean;
    /**
     * `getCreatedAt` returns creation time of this value
     */
    getCreatedAt(): TimeTicket;
    /**
     * `getPositionedAt` returns time this element was positioned in the array.
     */
    getPositionedAt(): TimeTicket;
    /**
     * `release` releases prev and next node.
     */
    release(): void;
    /**
     * `getLength` returns the length of this node.
     */
    getLength(): number;
    /**
     * `getPrev` returns a previous node.
     */
    getPrev(): RGATreeListNode | undefined;
    /**
     * `getNext` returns a next node.
     */
    getNext(): RGATreeListNode | undefined;
    /**
     * `getValue` returns a element value.
     */
    getValue(): JSONElement;
    /**
     * `isRemoved` checks if the value was removed.
     */
    isRemoved(): boolean;
}
/**
 * `RGATreeSplit` is a block-based list with improved index-based lookup in RGA.
 * The difference from RGATreeList is that it has data on a block basis to
 * reduce the size of CRDT metadata. When an edit occurs on a block,
 * the block is split.
 *
 * @internal
 */
declare class RGATreeSplit<T extends RGATreeSplitValue> {
    private head;
    private treeByIndex;
    private treeByID;
    private removedNodeMap;
    constructor();
    /**
     * `create` creates a instance RGATreeSplit.
     */
    static create<T extends RGATreeSplitValue>(): RGATreeSplit<T>;
    /**
     * `edit` does following steps
     * 1. split nodes with from and to
     * 2. delete between from and to
     * 3. insert a new node
     * 4. add removed node
     * @param range - range of RGATreeSplitNode
     * @param editedAt - edited time
     * @param value - value
     * @param latestCreatedAtMapByActor - latestCreatedAtMapByActor
     * @returns `[RGATreeSplitNodePos, Map<string, TimeTicket>, Array<Change>]`
     */
    edit(range: RGATreeSplitNodeRange, editedAt: TimeTicket, value?: T, latestCreatedAtMapByActor?: Map<string, TimeTicket>): [RGATreeSplitNodePos, Map<string, TimeTicket>, Array<TextChange>];
    /**
     * `findNodePos` finds RGATreeSplitNodePos of given offset.
     */
    findNodePos(idx: number): RGATreeSplitNodePos;
    /**
     * `findIndexesFromRange` finds indexes based on range.
     */
    findIndexesFromRange(range: RGATreeSplitNodeRange): [number, number];
    /**
     * `findIdxFromNodePos` finds index based on node position.
     */
    findIdxFromNodePos(pos: RGATreeSplitNodePos, preferToLeft: boolean): number;
    /**
     * `findNode` finds node of given id.
     */
    findNode(id: RGATreeSplitNodeID): RGATreeSplitNode<T>;
    /**
     * `toJSON` returns the JSON encoding of this Array.
     */
    toJSON(): string;
    [Symbol.iterator](): IterableIterator<RGATreeSplitNode<T>>;
    /**
     * `getHead` returns head of RGATreeSplitNode.
     */
    getHead(): RGATreeSplitNode<T>;
    /**
     * `deepcopy` copies itself deeply.
     */
    deepcopy(): RGATreeSplit<T>;
    /**
     * `getAnnotatedString` returns a String containing the meta data of the node
     * for debugging purpose.
     */
    getAnnotatedString(): string;
    /**
     * `insertAfter` inserts the given node after the given previous node.
     */
    insertAfter(prevNode: RGATreeSplitNode<T>, newNode: RGATreeSplitNode<T>): RGATreeSplitNode<T>;
    /**
     * `findNodeWithSplit` splits and return nodes of the given position.
     */
    findNodeWithSplit(pos: RGATreeSplitNodePos, editedAt: TimeTicket): [RGATreeSplitNode<T>, RGATreeSplitNode<T>];
    private findFloorNodePreferToLeft;
    private findFloorNode;
    /**
     * `findBetween` returns nodes between fromNode and toNode.
     */
    findBetween(fromNode: RGATreeSplitNode<T>, toNode: RGATreeSplitNode<T>): Array<RGATreeSplitNode<T>>;
    private splitNode;
    private deleteNodes;
    /**
     * `getRemovedNodesLen` returns size of removed nodes.
     */
    getRemovedNodesLen(): number;
    /**
     * `purgeTextNodesWithGarbage` physically purges nodes that have been removed.
     */
    purgeTextNodesWithGarbage(ticket: TimeTicket): number;
    /**
     * `purge` physically purges the given node from RGATreeSplit.
     */
    purge(node: RGATreeSplitNode<T>): void;
}
/**
 * `RGATreeSplitNode` is a node of RGATreeSplit.
 */
declare class RGATreeSplitNode<T extends RGATreeSplitValue> {
    private id;
    private removedAt?;
    private prev?;
    private next?;
    private insPrev?;
    private insNext?;
    constructor(id: RGATreeSplitNodeID, value?: T, removedAt?: TimeTicket);
    /**
     * `create` creates a instance of RGATreeSplitNode.
     */
    static create<T extends RGATreeSplitValue>(id: RGATreeSplitNodeID, value?: T): RGATreeSplitNode<T>;
    /**
     * `createComparator` creates a function to compare two RGATreeSplitNodeID.
     */
    static createComparator(): Comparator<RGATreeSplitNodeID>;
    /**
     * `getID` returns the ID of this RGATreeSplitNode.
     */
    getID(): RGATreeSplitNodeID;
    /**
     * `getCreatedAt` returns creation time of the Id of RGATreeSplitNode.
     */
    getCreatedAt(): TimeTicket;
    /**
     * `getLength` returns the length of this node.
     */
    getLength(): number;
    /**
     * `getContentLength` returns the length of this value.
     */
    getContentLength(): number;
    /**
     * `getPrev` returns a previous node of this node.
     */
    getPrev(): RGATreeSplitNode<T> | undefined;
    /**
     * `getNext` returns a next node of this node.
     */
    getNext(): RGATreeSplitNode<T> | undefined;
    /**
     * `getInsPrev` returns a previous node of this node insertion.
     */
    getInsPrev(): RGATreeSplitNode<T> | undefined;
    /**
     * `getInsNext` returns a next node of this node insertion.
     */
    getInsNext(): RGATreeSplitNode<T> | undefined;
    /**
     * `getInsPrevID` returns a ID of previous node insertion.
     */
    getInsPrevID(): RGATreeSplitNodeID;
    /**
     * `setPrev` sets previous node of this node.
     */
    setPrev(node?: RGATreeSplitNode<T>): void;
    /**
     * `setNext` sets next node of this node.
     */
    setNext(node?: RGATreeSplitNode<T>): void;
    /**
     * `setInsPrev` sets previous node of this node insertion.
     */
    setInsPrev(node?: RGATreeSplitNode<T>): void;
    /**
     * `setInsNext` sets next node of this node insertion.
     */
    setInsNext(node?: RGATreeSplitNode<T>): void;
    /**
     * `hasNext` checks if next node exists.
     */
    hasNext(): boolean;
    /**
     * `hasInsPrev` checks if previous insertion node exists.
     */
    hasInsPrev(): boolean;
    /**
     * `isRemoved` checks if removed time exists.
     */
    isRemoved(): boolean;
    /**
     * `getRemovedAt` returns the remove time of this node.
     */
    getRemovedAt(): TimeTicket | undefined;
    /**
     * `split` creates a new split node of the given offset.
     */
    split(offset: number): RGATreeSplitNode<T>;
    /**
     * `canDelete` checks if node is able to delete.
     */
    canDelete(editedAt: TimeTicket, latestCreatedAt: TimeTicket): boolean;
    /**
     * `remove` removes node of given edited time.
     */
    remove(editedAt?: TimeTicket): void;
    /**
     * `createRange` creates ranges of RGATreeSplitNodePos.
     */
    createRange(): RGATreeSplitNodeRange;
    /**
     * `deepcopy` returns a new instance of this RGATreeSplitNode without structural info.
     */
    deepcopy(): RGATreeSplitNode<T>;
    /**
     * `getAnnotatedString` returns a String containing
     * the meta data of the node for debugging purpose.
     */
    getAnnotatedString(): string;
    private splitValue;
}
/**
 * `RGATreeSplitNodeID` is an ID of RGATreeSplitNode.
 */
declare class RGATreeSplitNodeID {
    private createdAt;
    private offset;
    constructor(createdAt: TimeTicket, offset: number);
    /**
     * `of` creates a instance of RGATreeSplitNodeID.
     */
    static of(createdAt: TimeTicket, offset: number): RGATreeSplitNodeID;
    /**
     * `getCreatedAt` returns the creation time of this ID.
     */
    getCreatedAt(): TimeTicket;
    /**
     * `getOffset` returns returns the offset of this ID.
     */
    getOffset(): number;
    /**
     * `equals` returns whether given ID equals to this ID or not.
     */
    equals(other: RGATreeSplitNodeID): boolean;
    /**
     * `hasSameCreatedAt` returns whether given ID has same creation time with this ID.
     */
    hasSameCreatedAt(other: RGATreeSplitNodeID): boolean;
    /**
     * `split` creates a new ID with an offset from this ID.
     */
    split(offset: number): RGATreeSplitNodeID;
    /**
     * `getAnnotatedString` returns a String containing
     * the meta data of the node id for debugging purpose.
     */
    getAnnotatedString(): string;
}
/**
 * `RGATreeSplitNodePos` is the position of the text inside the node.
 */
declare class RGATreeSplitNodePos {
    private id;
    private relativeOffset;
    constructor(id: RGATreeSplitNodeID, relativeOffset: number);
    /**
     * `of` creates a instance of RGATreeSplitNodePos.
     */
    static of(id: RGATreeSplitNodeID, relativeOffset: number): RGATreeSplitNodePos;
    /**
     * `getID` returns the ID of this RGATreeSplitNodePos.
     */
    getID(): RGATreeSplitNodeID;
    /**
     * `getRelativeOffset` returns the relative offset of this RGATreeSplitNodePos.
     */
    getRelativeOffset(): number;
    /**
     * `getAbsoluteID` returns the absolute id of this RGATreeSplitNodePos.
     */
    getAbsoluteID(): RGATreeSplitNodeID;
    /**
     *`getAnnotatedString` returns a String containing
     * the meta data of the position for debugging purpose.
     */
    getAnnotatedString(): string;
    /**
     * `equals` returns whether given pos equal to this pos or not.
     */
    equals(other: RGATreeSplitNodePos): boolean;
}
/**
 * @internal
 */
declare type RGATreeSplitNodeRange = [RGATreeSplitNodePos, RGATreeSplitNodePos];
declare interface RGATreeSplitValue {
    length: number;
    substring(indexStart: number, indexEnd?: number): RGATreeSplitValue;
}
/**
 * RHTPQMap is replicated hash table with priority queue by creation time.
 *
 * @internal
 */
declare class RHTPQMap {
    private elementQueueMapByKey;
    private nodeMapByCreatedAt;
    constructor();
    /**
     * `create` creates a instance of RHTPQMap.
     */
    static create(): RHTPQMap;
    /**
     * `set` sets the value of the given key.
     */
    set(key: string, value: JSONElement): JSONElement | undefined;
    /**
     * `setInternal` sets the value of the given key.
     */
    setInternal(key: string, value: JSONElement): void;
    /**
     * `delete` deletes deletes the Element of the given key.
     */
    delete(createdAt: TimeTicket, executedAt: TimeTicket): JSONElement;
    /**
     * `keyOf` returns a key of node based on creation time
     */
    keyOf(createdAt: TimeTicket): string | undefined;
    /**
     * `purge` physically purge child element.
     */
    purge(element: JSONElement): void;
    /**
     * `deleteByKey` deletes the Element of the given key and removed time.
     */
    deleteByKey(key: string, removedAt: TimeTicket): JSONElement | undefined;
    /**
     * `has` returns whether the element exists of the given key or not.
     */
    has(key: string): boolean;
    /**
     * `get` returns the value of the given key.
     */
    get(key: string): JSONElement | undefined;
    [Symbol.iterator](): IterableIterator<RHTPQMapNode>;
}
/**
 * `RHTPQMapNode` is a node of RHTPQMap.
 */
declare class RHTPQMapNode {
    private strKey;
    constructor(strKey: string, value: JSONElement);
    /**
     * `of` creates a instance of RHTPQMapNode.
     */
    static of(strKey: string, value: JSONElement): RHTPQMapNode;
    /**
     * `isRemoved` checks whether this value was removed.
     */
    isRemoved(): boolean;
    /**
     * `getStrKey` returns the key of this node.
     */
    getStrKey(): string;
    /**
     * `remove` removes a value base on removing time.
     */
    remove(removedAt: TimeTicket): void;
}
/**
 *  `RichText` is an extended data type for the contents of a text editor.
 *
 * @internal
 */
export declare class RichText {
    private onChangesHandler?;
    private rgaTreeSplit;
    private selectionMap;
    private remoteChangeLock;
    constructor(rgaTreeSplit: RGATreeSplit<RichTextValue>, createdAt: TimeTicket);
    /**
     * `create` a instance of RichText.
     */
    static create(rgaTreeSplit: RGATreeSplit<RichTextValue>, createdAt: TimeTicket): RichText;
    /**
     * Don't use edit directly. Be sure to use it through a proxy.
     * The reason for setting the RichText type as the return value
     * is to provide the RichText interface to the user.
     */
    edit(fromIdx: number, toIdx: number, content: string, attributes?: Record<string, string>): RichText;
    /**
     * Don't use setStyle directly. Be sure to use it through a proxy.
     * The reason for setting the RichText type as the return value
     * is to provide the RichText interface to the user.
     */
    setStyle(fromIdx: number, toIdx: number, key: string, value: string): RichText;
    /**
     * `editInternal` edits the given range with the given content and attributes.
     *
     * @internal
     */
    editInternal(range: RGATreeSplitNodeRange, content: string, editedAt: TimeTicket, attributes?: Record<string, string>, latestCreatedAtMapByActor?: Map<string, TimeTicket>): Map<string, TimeTicket>;
    /**
     * `setStyleInternal` applies the style of the given range.
     * 01. split nodes with from and to
     * 02. style nodes between from and to
     *
     * @param range - range of RGATreeSplitNode
     * @param attributes - style attributes
     * @param editedAt - edited time
     * @internal
     */
    setStyleInternal(range: RGATreeSplitNodeRange, attributes: Record<string, string>, editedAt: TimeTicket): void;
    /**
     * Don't use select directly. Be sure to use it through a proxy.
     */
    select(fromIdx: number, toIdx: number): void;
    /**
     * `selectInternal` stores that the given range has been selected.
     *
     * @internal
     */
    selectInternal(range: RGATreeSplitNodeRange, updatedAt: TimeTicket): void;
    /**
     * `hasRemoteChangeLock` checks whether remoteChangeLock has.
     */
    hasRemoteChangeLock(): boolean;
    /**
     * `onChanges` registers a handler of onChanges event.
     */
    onChanges(handler: (changes: Array<TextChange>) => void): void;
    /**
     * `createRange` returns pair of RGATreeSplitNodePos of the given integer offsets.
     */
    createRange(fromIdx: number, toIdx: number): RGATreeSplitNodeRange;
    /**
     * `toJSON` returns the JSON encoding of this rich text.
     */
    toJSON(): string;
    /**
     * `toSortedJSON` returns the sorted JSON encoding of this rich text.
     */
    toSortedJSON(): string;
    /**
     * `getValue` returns value array of this RichTextVal.
     */
    getValue(): Array<RichTextVal>;
    /**
     * `getRGATreeSplit` returns rgaTreeSplit.
     *
     * @internal
     */
    getRGATreeSplit(): RGATreeSplit<RichTextValue>;
    /**
     * `getAnnotatedString` returns a String containing the meta data of this value
     * for debugging purpose.
     */
    getAnnotatedString(): string;
    /**
     * `getRemovedNodesLen` returns length of removed nodes
     */
    getRemovedNodesLen(): number;
    /**
     * `purgeTextNodesWithGarbage` physically purges nodes that have been removed.
     *
     * @internal
     */
    purgeTextNodesWithGarbage(ticket: TimeTicket): number;
    /**
     * `deepcopy` copies itself deeply.
     */
    deepcopy(): RichText;
    private selectPriv;
}
declare interface RichTextVal {
    attributes: Record<string, string>;
    content: string;
}
/**
 * `RichTextValue` is a value of RichText
 * which has a attributes that expresses the text style.
 *
 * @internal
 */
declare class RichTextValue {
    private attributes;
    private content;
    private constructor();
    /**
     * `create` creates a instance of RichTextValue.
     */
    static create(content: string): RichTextValue;
    /**
     * `length` returns the length of content.
     */
    get length(): number;
    /**
     * `substring` returns a sub-string value of the given range.
     */
    substring(indexStart: number, indexEnd: number): RichTextValue;
    /**
     * `setAttr` sets attribute of the given key, updated time and value.
     */
    setAttr(key: string, value: string, updatedAt: TimeTicket): void;
    /**
     * `toString` returns content.
     */
    toString(): string;
    /**
     * `toJSON` returns the JSON encoding of this .
     */
    toJSON(): string;
    /**
     * `getAttributes` returns the attributes of this value.
     */
    getAttributes(): Record<string, string>;
    /**
     * `getContent` returns content.
     */
    getContent(): string;
}
/**
 * `SnapshotEvent` is an event that occurs when a snapshot is received from
 * an agent.
 *
 * @public
 */
export declare interface SnapshotEvent {
    /**
     * enum {@link DocEventType}.Snapshot
     */
    type: DocEventType.Snapshot;
    /**
     * SnapshotEvent type
     */
    value: Uint8Array | undefined;
}
/**
 * `SplayNode` is a node of SplayTree.
 */
declare abstract class SplayNode<V> {
    protected value: V;
    private left?;
    private right?;
    private parent?;
    private weight;
    constructor(value: V);
    abstract getLength(): number;
    /**
     * `getNodeString` returns a string of weight and value of this node.
     */
    getNodeString(): string;
    /**
     * `getValue` returns value of this node.
     */
    getValue(): V;
    /**
     * `getLeftWeight` returns left weight of this node.
     */
    getLeftWeight(): number;
    /**
     * `getRightWeight` returns right weight of this node.
     */
    getRightWeight(): number;
    /**
     * `getWeight` returns weight of this node.
     */
    getWeight(): number;
    /**
     * `getLeft` returns a left node.
     */
    getLeft(): SplayNode<V> | undefined;
    /**
     * `getRight` returns a right node.
     */
    getRight(): SplayNode<V> | undefined;
    /**
     * `setRight` sets a right node.
     */
    setRight(right?: SplayNode<V>): void;
    /**
     * `hasLeft` check if the left node exists
     */
    hasLeft(): boolean;
    /**
     * `hasRight` check if the right node exists
     */
    hasRight(): boolean;
    /**
     * `hasParent` check if the parent node exists
     */
    hasParent(): boolean;
    /**
     * `setParent` sets a parent node.
     */
    setParent(parent?: SplayNode<V>): void;
    /**
     * `setLeft` sets a left node.
     */
    setLeft(left?: SplayNode<V>): void;
    /**
     * `getParent` returns parent of this node.
     */
    getParent(): SplayNode<V> | undefined;
    /**
     * `unlink` unlink parent, right and left node.
     */
    unlink(): void;
    /**
     * `hasLinks` checks if parent, right and left node exists.
     */
    hasLinks(): boolean;
    /**
     * `increaseWeight` increases weight.
     */
    increaseWeight(weight: number): void;
    /**
     * `initWeight` set initial weight of this node.
     */
    initWeight(): void;
}
/**
 * `StatusChangedEvent` is an event that occurs when the Client's state changes.
 *
 * @public
 */
export declare interface StatusChangedEvent {
    /**
     * enum {@link ClientEventType}.StatusChanged
     */
    type: ClientEventType.StatusChanged;
    /**
     * `DocumentsChangedEvent` value
     */
    value: ClientStatus;
}
/**
 * `StreamConnectionStatus` is stream connection status types
 * @public
 */
export declare enum StreamConnectionStatus {
    /**
     * stream connected
     */
    Connected = "connected",
    /**
     * stream disconnected
     */
    Disconnected = "disconnected"
}
/**
 * `StreamConnectionStatusChangedEvent` is an event that occurs when
 * the client's stream connection state changes.
 *
 * @public
 */
export declare interface StreamConnectionStatusChangedEvent {
    /**
     * `StreamConnectionStatusChangedEvent` type
     * enum {@link ClientEventType}.StreamConnectionStatusChangedEvent
     */
    type: ClientEventType.StreamConnectionStatusChanged;
    /**
     * `StreamConnectionStatusChangedEvent` value
     */
    value: StreamConnectionStatus;
}
declare interface SubscribeFn<T> {
    (next: Observer<T> | NextFn<T>, error?: ErrorFn, complete?: CompleteFn): Unsubscribe;
    (observer: Observer<T>): Unsubscribe;
}
/**
 * `TextChange` is the value passed as an argument to `Text.onChanges()`.
 * `Text.onChanges()` is called when the `Text` is modified.
 *
 * @internal
 */
export declare interface TextChange {
    type: TextChangeType;
    actor: ActorID;
    from: number;
    to: number;
    content?: string;
    attributes?: Record<string, string>;
}
/**
 * `TextChangeType` is the type of TextChange.
 *
 * @internal
 */
export declare enum TextChangeType {
    Content = "content",
    Selection = "selection",
    Style = "style"
}
/**
 * `TextElement` represents Text or RichText.
 */
declare abstract class TextElement extends JSONElement {
    abstract getRemovedNodesLen(): number;
    abstract purgeTextNodesWithGarbage(ticket: TimeTicket): number;
}
/**
 * `TimeTicket` is a timestamp of the logical clock. Ticket is immutable.
 * It is created by `ChangeID`.
 *
 * @public
 */
export declare class TimeTicket {
    private lamport;
    private delimiter;
    private actorID?;
    private constructor();
    /**
     * `of` creates an instance of Ticket.
     */
    static of(lamport: Long_2, delimiter: number, actorID?: string): TimeTicket;
    /**
     * `toIDString` returns the lamport string for this Ticket.
     */
    toIDString(): string;
    /**
     * `getAnnotatedString` returns a string containing the meta data of the ticket
     * for debugging purpose.
     */
    getAnnotatedString(): string;
    /**
     * `setActor` creates a new instance of Ticket with the given actorID.
     */
    setActor(actorID: ActorID): TimeTicket;
    /**
     * `getLamportAsString` returns the lamport string.
     */
    getLamportAsString(): string;
    /**
     * `getDelimiter` returns delimiter.
     */
    getDelimiter(): number;
    /**
     * `getActorID` returns actorID.
     */
    getActorID(): string | undefined;
    /**
     * `after` returns whether the given ticket was created later.
     */
    after(other: TimeTicket): boolean;
    /**
     * `equals` returns whether the given ticket was created.
     */
    equals(other: TimeTicket): boolean;
    /**
     * `compare` returns an integer comparing two Ticket.
     *  The result will be 0 if id==other, -1 if `id < other`, and +1 if `id > other`.
     *  If the receiver or argument is nil, it would panic at runtime.
     */
    compare(other: TimeTicket): number;
}
/**
 * @internal
 */
export declare type Unsubscribe = () => void;
/**
 * The top-level yorkie namespace with additional properties.
 *
 * In production, this will be called exactly once and the result
 * assigned to the `yorkie` global.
 *
 * e.g) `yorkie.createClient(...);`
 *
 * @public
 */
declare const yorkie: {
    createClient: typeof createClient;
    createDocument: typeof createDocument;
};
export default yorkie;
export {};
