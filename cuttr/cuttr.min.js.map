{"version":3,"sources":["cuttr.js"],"names":["root","define","amd","factory","module","exports","Cuttr","this","el","options","self","Object","create","prototype","elementsToTruncate","originalContent","document","querySelectorAll","contentVisibilityState","contentTruncationState","truncate","length","ending","loadedClass","readMore","readMoreText","readLessText","readMoreBtnTag","dataIndex","keys","forEach","key","truncateIt","thisElement","str","truncateMethod","dataset","cuttrIndex","substring","cuttrMethod","thisIndex","join","sentences","words","splice","match","btnSelectorClass","btnAriaExpanded","currentElement","nextElementSibling","matches","querySelector","addReadMore","updated","console","btnExists","cuttrReadmore","cuttrReadless","cuttrReadmorePosition","readMoreBtnPosition","btnPosition","cuttrReadmoreTag","addEventListener","event","target","contains","cuttrReadmoreAdditionalClasses","readMoreBtnSelectorClass","readMoreBtnAdditionalClasses","updateContent","btnMarkup","btnTag","btnAdditionalClasses","btnText","replace","currentContent","innerHTML","classList","truncatedContent","previousElementSibling","parentNode","cuttrLength","truncateEnding","cuttrEnding","trim","truncateLength","window","prepare","i","cuttrTitle","title","contentToTitle","setAttribute","push","textContent","init","jQuery","$","fn","extend","fp_utils","showError"],"mappings":"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","file":"cuttr.min.js","sourcesContent":["/*!\n * Cuttr 1.2.0\n * https://github.com/d-e-v-s-k/cuttr-js\n *\n * @license GPLv3 for open source use only\n * or Cuttr Commercial License for commercial use\n * https://cuttr.kulahs.de/pricing/\n *\n * Copyright (C) 2020 https://cuttr.kulahs.de/ - A project by DEVSK\n **/\n\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define([], factory);\n    } else if (typeof module === 'object' && module.exports) {\n        // Node. Does not work with strict CommonJS, but\n        // only CommonJS-like environments that support module.exports,\n        // like Node.\n        module.exports = factory();\n    } else {\n        // Browser globals (root is window)\n        root.Cuttr = factory();\n    }\n}(this, function () {\n    const Cuttr = function (el, options){\n        'use strict';\n\n        const self = Object.create(Cuttr.prototype);\n\n        /**\n         * Default settings\n         */\n        self.options = {\n            elementsToTruncate:  typeof el === 'string' ? document.querySelectorAll(el) : el,\n            originalContent: [],\n            contentVisibilityState: [],\n            contentTruncationState: [],\n\n            //  set default options\n            truncate: 'characters', // truncate method [characters|words|sentences]\n            length: 100,  //  truncation limit\n            ending: '...',    //  truncation ending string\n            loadedClass: 'cuttr--loaded', //  class to set when truncation finished\n            title: false,    //  add original content to elements title tag\n            readMore: false, // read more button enabled/disabled\n            readMoreText: 'read more',\n            readLessText: 'read less',\n            readMoreBtnPosition: 'after',  // [after|inside]\n            readMoreBtnTag: 'button', //  read-more button tag [button|a|...]\n            readMoreBtnSelectorClass: 'cuttr-readmore', //  read-more button selector\n            readMoreBtnAdditionalClasses: '',\n\n            //  private options\n            dataIndex: 'data-cuttr-index',   // cuttr index data attribute\n        };\n\n        /**\n         * User defined options\n         */\n        if (options) {\n            Object.keys(options).forEach(function (key){\n                self.options[key] = options[key];\n            });\n        }\n\n\n        const init = function () {\n            prepare.call(this);\n        };\n\n\n        /*\n            prepare cuttable elements\n         */\n        function prepare() {\n\n            //  return if no target element defined\n            if (!self.options.elementsToTruncate) return;\n\n            //  set element type depending on source\n            if ( !('length' in self.options.elementsToTruncate) )\n                self.options.elementsToTruncate = [self.options.elementsToTruncate];\n\n            //  loop through target elements to truncate\n            for (let i = 0; i < self.options.elementsToTruncate.length; i++) {\n\n                const currentElement  = self.options.elementsToTruncate[i];\n                const currentContent  = currentElement.innerHTML;\n                const truncateLength  = (currentElement.dataset.cuttrLength) ? currentElement.dataset.cuttrLength : self.options.length;\n                const truncateEnding  = (currentElement.dataset.cuttrEnding) ? currentElement.dataset.cuttrEnding : self.options.ending;\n                const contentToTitle  = (currentElement.dataset.cuttrTitle) ? currentElement.dataset.cuttrTitle : self.options.title;\n                let truncatedContent;\n\n                //  add truncate-element index to element\n                currentElement.setAttribute(self.options.dataIndex, i);\n\n                //  temporary save elements original content\n                self.options.originalContent.push(currentContent);\n\n                //  truncate content\n                truncatedContent = truncateIt(currentElement, currentContent.trim(), truncateLength, truncateEnding);\n\n                //  set title attr with original text content\n                if (contentToTitle)\n                    currentElement.title = currentElement.textContent.trim();\n\n                //  set new content\n                currentElement.innerHTML = truncatedContent;\n\n                //  add read-more button if current content is truncated\n                if (self.options.contentTruncationState[i]) {\n\n                    if (self.options.readMore)\n                        addReadMore(currentElement);\n\n                    currentElement.classList += ' ' + self.options.loadedClass;\n\n                }\n\n            }\n\n        }\n\n\n        /*\n            truncate text to specific length\n        */\n        function truncateIt(thisElement, str, length, ending) {\n\n            const thisIndex       = thisElement.dataset.cuttrIndex;\n            const truncateMethod  = (thisElement.dataset.cuttrMethod) ? thisElement.dataset.cuttrMethod : self.options.truncate;\n\n            //  set defaults\n            if (length == null) {\n                length = 100;\n            }\n\n            //  set defaults\n            if (ending == null) {\n                ending = '...';\n            }\n\n            //  truncate content based on method\n            switch (truncateMethod) {\n\n                //  truncate characters only\n                case 'characters':\n\n                    //  check if content (string) is longer than truncation limit\n                    if (str.length > length) {\n\n                        //  set current content truncation true and return truncated string\n                        self.options.contentTruncationState[thisIndex] = true;\n                        //  set visibility state\n                        self.options.contentVisibilityState[thisIndex] = false;\n\n                        //  return new string\n                        return str.substring(0, length - ending.length) + ending + ' ';\n\n                    } else {\n                        return str;\n                    }\n\n                    break;\n\n                //  truncate words\n                case 'words':\n\n                    const words = str.split(/ (?=[^>]*(?:<|$))/);\n\n                    //  check if content (string) is longer than truncation limit\n                    if (words.length > length) {\n\n                        //  set current content truncation true and return truncated string\n                        self.options.contentTruncationState[thisIndex] = true;\n                        //  set visibility state\n                        self.options.contentVisibilityState[thisIndex] = false;\n                        //  return new string\n                        //  split spaces followed by sequence of characters are NOT greater-than signs, less-than sign\n                        return words.splice(0,length).join(' ') + ' ' + ending + ' ';\n\n                    } else {\n                        return str;\n                    }\n\n                    break;\n\n                //  truncate full sentences\n                case 'sentences':\n\n                    const sentences = str.match(/[^\\.!\\?]+[\\.!\\?]+/g);\n\n                    //  check if content (string) is longer than truncation limit\n                    if (sentences.length > length) {\n\n                        //  set current contetn truncation true and return truncated string\n                        self.options.contentTruncationState[thisIndex] = true;\n                        //  set visibility state\n                        self.options.contentVisibilityState[thisIndex] = false;\n                        //  return new string\n                        return sentences.splice(0,length).join(' ') + ' ' + ending + ' ';\n\n                    } else {\n                        return str;\n                    }\n\n                    break;\n\n                //  truncate characters by default\n                default:\n\n                    //  check if content (string) is longer than truncation limit\n                    if (str.length > length) {\n\n                        //  set current contetn truncation true and return truncated string\n                        self.options.contentTruncationState[thisIndex] = true;\n                        //  set visibility state\n                        self.options.contentVisibilityState[thisIndex] = false;\n                        //  return new string\n                        return str.substring(0, length - ending.length) + ending;\n\n                    } else {\n                        return str;\n                    }\n\n            }\n\n        }\n\n\n        /*\n            append read more button\n        */\n        function addReadMore(thisElement, updated) {\n\n            const currentElement      = thisElement;\n            const thisIndex           = currentElement.dataset.cuttrIndex;\n            const readMoreText        = (currentElement.dataset.cuttrReadmore) ? currentElement.dataset.cuttrReadmore : self.options.readMoreText;\n            const readLessText        = (currentElement.dataset.cuttrReadmore) ? currentElement.dataset.cuttrReadless : self.options.readLessText;\n            const btnPosition         = (currentElement.dataset.cuttrReadmorePosition) ? currentElement.dataset.cuttrReadmorePosition : self.options.readMoreBtnPosition;\n            const btnTag              = (currentElement.dataset.cuttrReadmoreTag) ? currentElement.dataset.cuttrReadmoreTag : self.options.readMoreBtnTag;\n            const btnSelectorClass    = '.' + self.options.readMoreBtnSelectorClass;\n            const btnAdditionalClasses = (currentElement.dataset.cuttrReadmoreAdditionalClasses) ? currentElement.dataset.cuttrReadmoreAdditionalClasses : self.options.readMoreBtnAdditionalClasses;\n            const btnText             = (self.options.contentVisibilityState[thisIndex]) ? readLessText : readMoreText;\n            const btnAriaExpanded     = (self.options.contentVisibilityState[thisIndex]) ? 'true' : 'false';\n            const btnMarkup           = ' <' + btnTag + ' aria-expanded=\"' + btnAriaExpanded + '\" class=\"' + self.options.readMoreBtnSelectorClass + ' ' + btnAdditionalClasses + '\">' + btnText.replace(/<[^>]*>/g, \"\") + '</' + btnTag + '>';\n            let btnExists;\n\n            //  check for button existence depending on btn position\n            if (btnPosition == 'after' && currentElement.nextElementSibling) {\n                btnExists = currentElement.nextElementSibling.matches(btnSelectorClass);\n            } else if (btnPosition == 'inside') {\n                btnExists = currentElement.querySelector(btnSelectorClass);\n            }\n\n            //  insert element only if it doesn't exist\n            if (!btnExists) {\n\n                //  add read-more button to dom\n                switch (btnPosition) {\n                    case 'after':\n                        currentElement.insertAdjacentHTML('afterend', btnMarkup);\n                        break;\n                    case 'inside':\n                        currentElement.insertAdjacentHTML('beforeend', btnMarkup);\n                        break;\n                    default:\n                        console.log('no matching read-more button position defined');\n                }\n\n                //  listen to read-more clicks - show/hide content\n                if (!updated) {\n\n                    if (btnPosition == 'after') {\n                        currentElement.nextElementSibling.addEventListener('click',function(event) {\n                            if (event.target && event.target.classList.contains(self.options.readMoreBtnSelectorClass)) {\n                                updateContent(event, btnPosition);\n                            }\n                        });\n                    } else if (btnPosition == 'inside') {\n                        currentElement.addEventListener('click',function(event) {\n                            if (event.target && event.target.classList.contains(self.options.readMoreBtnSelectorClass)) {\n                                updateContent(event, btnPosition);\n                            }\n                        });\n                    }\n\n                }\n\n            }\n\n        }\n\n\n        /*\n            display original/truncated content\n        */\n        function updateContent(event, btnPosition) {\n\n            const currentElement      = (btnPosition == 'after') ? event.target.previousElementSibling : event.target.parentNode;\n            const currentContent      = currentElement.innerHTML;\n            const thisIndex           = currentElement.dataset.cuttrIndex;\n            const readMoreText        = (currentElement.dataset.cuttrReadmore) ? currentElement.dataset.cuttrReadmore : self.options.readMoreText;\n            const readLessText        = (currentElement.dataset.cuttrReadmore) ? currentElement.dataset.cuttrReadless : self.options.readLessText;\n            const truncateLength      = (currentElement.dataset.cuttrLength) ? currentElement.dataset.cuttrLength : self.options.length;\n            const truncateEnding      = (currentElement.dataset.cuttrEnding) ? currentElement.dataset.cuttrEnding : self.options.ending;\n            let truncatedContent;\n\n            //  show content if its currently truncated\n            if (!self.options.contentVisibilityState[thisIndex]) {\n\n                //  replace content with original content from element at specific index\n                currentElement.innerHTML = self.options.originalContent[thisIndex];\n\n                //  set visibility state\n                self.options.contentVisibilityState[thisIndex] = true;\n\n                if (btnPosition == 'inside' && self.options.readMore)\n                    addReadMore(currentElement, true);\n\n                //  update button text and aria\n                event.target.innerHTML = readLessText.replace(/<[^>]*>/g, \"\");\n                //event.target.setAttribute('aria-expanded', 'true');\n\n                //  truncate content if its shown completely currently\n            } else {\n\n                //  truncate content\n                truncatedContent = truncateIt(currentElement, currentContent.trim(), truncateLength, truncateEnding);\n                currentElement.innerHTML = truncatedContent;\n\n                //  set visibility state\n                self.options.contentVisibilityState[thisIndex] = false;\n\n                if (btnPosition == 'inside' && self.options.readMore)\n                    addReadMore(currentElement, true);\n\n                //  update button text and aria\n                event.target.innerHTML = readMoreText.replace(/<[^>]*>/g, \"\");\n                //event.target.setAttribute('aria-expanded', 'false');\n\n            }\n\n        }\n\n        init();\n        return self;\n    };\n    return Cuttr;\n}));\n\n\n/**\n * jQuery adapter for Cuttr.js 1.1.0\n */\nif(window.jQuery && window.Cuttr){\n    (function ($, Cuttr) {\n        'use strict';\n\n        // No jQuery No Go\n        if (!$ || !Cuttr) {\n            window.fp_utils.showError('error', 'jQuery is required to use the jQuery Cuttr adapter!');\n            return;\n        }\n\n        $.fn.Cuttr = function(options) {\n            options = $.extend({}, options, {'$': $});\n            var instance = new Cuttr(this, options);\n        };\n    })(window.jQuery, window.Cuttr);\n}\n"]}