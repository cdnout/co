"use strict";exports.__esModule=!0,exports.setupOpenTunnelToParent=setupOpenTunnelToParent;var _src=require("cross-domain-utils/src"),_src2=require("belter/src"),_conf=require("../conf"),_global=require("../global");function cleanTunnelWindows(){const n=(0,_global.globalStore)("tunnelWindows");for(const e of n.keys()){const o=n[e];try{(0,_src2.noop)(o.source)}catch(o){n.del(e);continue}(0,_src.isWindowClosed)(o.source)&&n.del(e)}}function addTunnelWindow({name:n,source:e,canary:o,sendMessage:s}){cleanTunnelWindows();const r=(0,_src2.uniqueID)();return(0,_global.globalStore)("tunnelWindows").set(r,{name:n,source:e,canary:o,sendMessage:s}),r}function setupOpenTunnelToParent({send:n}){(0,_global.getGlobal)(window).openTunnelToParent=function({name:e,source:o,canary:s,sendMessage:r}){const t=(0,_global.globalStore)("tunnelWindows"),c=(0,_src.getParent)(window);if(!c)throw new Error("No parent window found to open tunnel to");const a=addTunnelWindow({name:e,source:o,canary:s,sendMessage:r});return n(c,_conf.MESSAGE_NAME.OPEN_TUNNEL,{name:e,sendMessage(){const n=t.get(a);try{(0,_src2.noop)(n&&n.source)}catch(n){return void t.del(a)}if(n&&n.source&&!(0,_src.isWindowClosed)(n.source)){try{n.canary()}catch(n){return}n.sendMessage.apply(this,arguments)}}},{domain:_conf.WILDCARD})}}