"use strict";exports.__esModule=!0,exports.openTunnelToOpener=openTunnelToOpener;var _src=require("zalgo-promise/src"),_src2=require("cross-domain-utils/src"),_src3=require("belter/src"),_global=require("../global"),_common=require("./common");function awaitRemoteBridgeForWindow(e){return(0,_global.windowStore)("remoteBridgeAwaiters").getOrSet(e,()=>_src.ZalgoPromise.try(()=>{const r=(0,_src2.getFrameByName)(e,(0,_common.getBridgeName)((0,_src2.getDomain)()));if(r)return(0,_src2.isSameDomain)(r)&&(0,_global.getGlobal)((0,_src2.assertSameDomain)(r))?r:new _src.ZalgoPromise(e=>{let o,n;o=setInterval(()=>{if(r&&(0,_src2.isSameDomain)(r)&&(0,_global.getGlobal)((0,_src2.assertSameDomain)(r)))return clearInterval(o),clearTimeout(n),e(r)},100),n=setTimeout(()=>(clearInterval(o),e()),2e3)})}))}function openTunnelToOpener({on:e,send:r,receiveMessage:o}){return _src.ZalgoPromise.try(()=>{const n=(0,_src2.getOpener)(window);if(n&&(0,_common.needsBridge)({win:n}))return(0,_common.registerRemoteWindow)(n),awaitRemoteBridgeForWindow(n).then(t=>t?window.name?(0,_global.getGlobal)((0,_src2.assertSameDomain)(t)).openTunnelToParent({name:window.name,source:window,canary(){},sendMessage(n){try{(0,_src3.noop)(window)}catch(e){return}if(window&&!window.closed)try{o({data:n,origin:this.origin,source:this.source},{on:e,send:r})}catch(e){_src.ZalgoPromise.reject(e)}}}).then(({source:e,origin:r,data:o})=>{if(e!==n)throw new Error("Source does not match opener");(0,_common.registerRemoteSendMessage)(e,r,o.sendMessage)}).catch(e=>{throw(0,_common.rejectRemoteSendMessage)(n,e),e}):(0,_common.rejectRemoteSendMessage)(n,new Error("Can not register with opener: window does not have a name")):(0,_common.rejectRemoteSendMessage)(n,new Error("Can not register with opener: no bridge found in opener")))})}