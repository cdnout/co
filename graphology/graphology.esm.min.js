import{EventEmitter}from"events";import Iterator from"obliterator/iterator";import take from"obliterator/take";import chain from"obliterator/chain";function assignPolyfill(){const r=arguments[0];for(let e=1,t=arguments.length;e<t;e++)if(arguments[e])for(const i in arguments[e])r[i]=arguments[e][i];return r}let assign=assignPolyfill;function getMatchingEdge(e,t,r,i){t=e._nodes.get(t);let n=null;return t&&(n="mixed"===i?t.out&&t.out[r]||t.undirected&&t.undirected[r]:"directed"===i?t.out&&t.out[r]:t.undirected&&t.undirected[r]),n}function isGraph(e){return null!==e&&"object"==typeof e&&"function"==typeof e.addUndirectedEdgeWithKey&&"function"==typeof e.dropNode}function isPlainObject(e){return"object"==typeof e&&null!==e&&e.constructor===Object}function isEmpty(e){let t;for(t in e)return!1;return!0}function privateProperty(e,t,r){Object.defineProperty(e,t,{enumerable:!1,configurable:!1,writable:!0,value:r})}function readOnlyProperty(e,t,r){const i={enumerable:!0,configurable:!0};"function"==typeof r?i.get=r:(i.value=r,i.writable=!1),Object.defineProperty(e,t,i)}function validateHints(e){return!!isPlainObject(e)&&!(e.attributes&&!Array.isArray(e.attributes))}function incrementalIdStartingFromRandomByte(){let e=255&Math.floor(256*Math.random());return()=>e++}"function"==typeof Object.assign&&(assign=Object.assign);class GraphError extends Error{constructor(e){super(),this.name="GraphError",this.message=e}}class InvalidArgumentsGraphError extends GraphError{constructor(e){super(e),this.name="InvalidArgumentsGraphError","function"==typeof Error.captureStackTrace&&Error.captureStackTrace(this,InvalidArgumentsGraphError.prototype.constructor)}}class NotFoundGraphError extends GraphError{constructor(e){super(e),this.name="NotFoundGraphError","function"==typeof Error.captureStackTrace&&Error.captureStackTrace(this,NotFoundGraphError.prototype.constructor)}}class UsageGraphError extends GraphError{constructor(e){super(e),this.name="UsageGraphError","function"==typeof Error.captureStackTrace&&Error.captureStackTrace(this,UsageGraphError.prototype.constructor)}}function MixedNodeData(e,t){this.key=e,this.attributes=t,this.clear()}function DirectedNodeData(e,t){this.key=e,this.attributes=t,this.clear()}function UndirectedNodeData(e,t){this.key=e,this.attributes=t,this.clear()}function EdgeData(e,t,r,i,n){this.key=t,this.attributes=n,this.undirected=e,this.source=r,this.target=i}MixedNodeData.prototype.clear=function(){this.inDegree=0,this.outDegree=0,this.undirectedDegree=0,this.in={},this.out={},this.undirected={}},DirectedNodeData.prototype.clear=function(){this.inDegree=0,this.outDegree=0,this.in={},this.out={}},UndirectedNodeData.prototype.clear=function(){this.undirectedDegree=0,this.undirected={}},EdgeData.prototype.attach=function(){let e="out",t="in";this.undirected&&(e=t="undirected");var r=this.source.key,i=this.target.key;(this.source[e][i]=this).undirected&&r===i||(this.target[t][r]=this)},EdgeData.prototype.attachMulti=function(){let e="out",t="in";var r=this.source.key,i=this.target.key;this.undirected&&(e=t="undirected");const n=this.source[e],o=n[i];void 0!==o?((o.previous=this).next=o,(n[i]=this).target[t][r]=this):(n[i]=this).undirected&&r===i||(this.target[t][r]=this)},EdgeData.prototype.detach=function(){var e=this.source.key,t=this.target.key;let r="out",i="in";this.undirected&&(r=i="undirected"),delete this.source[r][t],delete this.target[i][e]},EdgeData.prototype.detachMulti=function(){var e=this.source.key,t=this.target.key;let r="out",i="in";this.undirected&&(r=i="undirected"),void 0===this.previous?void 0===this.next?(delete this.source[r][t],delete this.target[i][e]):(this.next.previous=void 0,this.source[r][t]=this.next,this.target[i][e]=this.next):(this.previous.next=this.next,void 0!==this.next&&(this.next.previous=this.previous))};const NODE=0,SOURCE=1,TARGET=2,OPPOSITE=3;function findRelevantNodeData(e,t,r,i,n,o,a){let d,h,s,u;if(i=""+i,r===NODE){if(d=e._nodes.get(i),!d)throw new NotFoundGraphError(`Graph.${t}: could not find the "${i}" node in the graph.`);s=n,u=o}else if(r===OPPOSITE){if(n=""+n,h=e._edges.get(n),!h)throw new NotFoundGraphError(`Graph.${t}: could not find the "${n}" edge in the graph.`);var c=h.source.key,p=h.target.key;if(i===c)d=h.target;else{if(i!==p)throw new NotFoundGraphError(`Graph.${t}: the "${i}" node is not attached to the "${n}" edge (${c}, ${p}).`);d=h.source}s=o,u=a}else{if(h=e._edges.get(i),!h)throw new NotFoundGraphError(`Graph.${t}: could not find the "${i}" edge in the graph.`);d=r===SOURCE?h.source:h.target,s=n,u=o}return[d,s,u]}function attachNodeAttributeGetter(e,i,n){e.prototype[i]=function(e,t,r){var[t,r]=findRelevantNodeData(this,i,n,e,t,r);return t.attributes[r]}}function attachNodeAttributesGetter(e,r,i){e.prototype[r]=function(e,t){var[t]=findRelevantNodeData(this,r,i,e,t);return t.attributes}}function attachNodeAttributeChecker(e,o,a){e.prototype[o]=function(e,t,r){const[i,n]=findRelevantNodeData(this,o,a,e,t,r);return i.attributes.hasOwnProperty(n)}}function attachNodeAttributeSetter(e,d,h){e.prototype[d]=function(e,t,r,i){const[n,o,a]=findRelevantNodeData(this,d,h,e,t,r,i);return n.attributes[o]=a,this.emit("nodeAttributesUpdated",{key:n.key,type:"set",attributes:n.attributes,name:o}),this}}function attachNodeAttributeUpdater(e,h,s){e.prototype[h]=function(e,t,r,i){const[n,o,a]=findRelevantNodeData(this,h,s,e,t,r,i);if("function"!=typeof a)throw new InvalidArgumentsGraphError(`Graph.${h}: updater should be a function.`);const d=n.attributes;i=a(d[o]);return d[o]=i,this.emit("nodeAttributesUpdated",{key:n.key,type:"set",attributes:n.attributes,name:o}),this}}function attachNodeAttributeRemover(e,o,a){e.prototype[o]=function(e,t,r){const[i,n]=findRelevantNodeData(this,o,a,e,t,r);return delete i.attributes[n],this.emit("nodeAttributesUpdated",{key:i.key,type:"remove",attributes:i.attributes,name:n}),this}}function attachNodeAttributesReplacer(e,o,a){e.prototype[o]=function(e,t,r){const[i,n]=findRelevantNodeData(this,o,a,e,t,r);if(!isPlainObject(n))throw new InvalidArgumentsGraphError(`Graph.${o}: provided attributes are not a plain object.`);return i.attributes=n,this.emit("nodeAttributesUpdated",{key:i.key,type:"replace",attributes:i.attributes}),this}}function attachNodeAttributesMerger(e,i,n){e.prototype[i]=function(e,t,r){var[t,r]=findRelevantNodeData(this,i,n,e,t,r);if(!isPlainObject(r))throw new InvalidArgumentsGraphError(`Graph.${i}: provided attributes are not a plain object.`);return assign(t.attributes,r),this.emit("nodeAttributesUpdated",{key:t.key,type:"merge",attributes:t.attributes,data:r}),this}}function attachNodeAttributesUpdater(e,o,a){e.prototype[o]=function(e,t,r){const[i,n]=findRelevantNodeData(this,o,a,e,t,r);if("function"!=typeof n)throw new InvalidArgumentsGraphError(`Graph.${o}: provided updater is not a function.`);return i.attributes=n(i.attributes),this.emit("nodeAttributesUpdated",{key:i.key,type:"update",attributes:i.attributes}),this}}const NODE_ATTRIBUTES_METHODS=[{name:e=>`get${e}Attribute`,attacher:attachNodeAttributeGetter},{name:e=>`get${e}Attributes`,attacher:attachNodeAttributesGetter},{name:e=>`has${e}Attribute`,attacher:attachNodeAttributeChecker},{name:e=>`set${e}Attribute`,attacher:attachNodeAttributeSetter},{name:e=>`update${e}Attribute`,attacher:attachNodeAttributeUpdater},{name:e=>`remove${e}Attribute`,attacher:attachNodeAttributeRemover},{name:e=>`replace${e}Attributes`,attacher:attachNodeAttributesReplacer},{name:e=>`merge${e}Attributes`,attacher:attachNodeAttributesMerger},{name:e=>`update${e}Attributes`,attacher:attachNodeAttributesUpdater}];function attachNodeAttributesMethods(r){NODE_ATTRIBUTES_METHODS.forEach(function({name:e,attacher:t}){t(r,e("Node"),NODE),t(r,e("Source"),SOURCE),t(r,e("Target"),TARGET),t(r,e("Opposite"),OPPOSITE)})}function attachEdgeAttributeGetter(e,o,a){e.prototype[o]=function(e,t){let r;if("mixed"!==this.type&&"mixed"!==a&&a!==this.type)throw new UsageGraphError(`Graph.${o}: cannot find this type of edges in your ${this.type} graph.`);if(2<arguments.length){if(this.multi)throw new UsageGraphError(`Graph.${o}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);var i=""+e,n=""+t;if(t=arguments[2],r=getMatchingEdge(this,i,n,a),!r)throw new NotFoundGraphError(`Graph.${o}: could not find an edge for the given path ("${i}" - "${n}").`)}else{if("mixed"!==a)throw new UsageGraphError(`Graph.${o}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,r=this._edges.get(e),!r)throw new NotFoundGraphError(`Graph.${o}: could not find the "${e}" edge in the graph.`)}return r.attributes[t]}}function attachEdgeAttributesGetter(e,n,o){e.prototype[n]=function(e){let t;if("mixed"!==this.type&&"mixed"!==o&&o!==this.type)throw new UsageGraphError(`Graph.${n}: cannot find this type of edges in your ${this.type} graph.`);if(1<arguments.length){if(this.multi)throw new UsageGraphError(`Graph.${n}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);var r=""+e,i=""+arguments[1];if(t=getMatchingEdge(this,r,i,o),!t)throw new NotFoundGraphError(`Graph.${n}: could not find an edge for the given path ("${r}" - "${i}").`)}else{if("mixed"!==o)throw new UsageGraphError(`Graph.${n}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,t=this._edges.get(e),!t)throw new NotFoundGraphError(`Graph.${n}: could not find the "${e}" edge in the graph.`)}return t.attributes}}function attachEdgeAttributeChecker(e,o,a){e.prototype[o]=function(e,t){let r;if("mixed"!==this.type&&"mixed"!==a&&a!==this.type)throw new UsageGraphError(`Graph.${o}: cannot find this type of edges in your ${this.type} graph.`);if(2<arguments.length){if(this.multi)throw new UsageGraphError(`Graph.${o}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);var i=""+e,n=""+t;if(t=arguments[2],r=getMatchingEdge(this,i,n,a),!r)throw new NotFoundGraphError(`Graph.${o}: could not find an edge for the given path ("${i}" - "${n}").`)}else{if("mixed"!==a)throw new UsageGraphError(`Graph.${o}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,r=this._edges.get(e),!r)throw new NotFoundGraphError(`Graph.${o}: could not find the "${e}" edge in the graph.`)}return r.attributes.hasOwnProperty(t)}}function attachEdgeAttributeSetter(e,a,d){e.prototype[a]=function(e,t,r){let i;if("mixed"!==this.type&&"mixed"!==d&&d!==this.type)throw new UsageGraphError(`Graph.${a}: cannot find this type of edges in your ${this.type} graph.`);if(3<arguments.length){if(this.multi)throw new UsageGraphError(`Graph.${a}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);var n=""+e,o=""+t;if(t=arguments[2],r=arguments[3],i=getMatchingEdge(this,n,o,d),!i)throw new NotFoundGraphError(`Graph.${a}: could not find an edge for the given path ("${n}" - "${o}").`)}else{if("mixed"!==d)throw new UsageGraphError(`Graph.${a}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,i=this._edges.get(e),!i)throw new NotFoundGraphError(`Graph.${a}: could not find the "${e}" edge in the graph.`)}return i.attributes[t]=r,this.emit("edgeAttributesUpdated",{key:i.key,type:"set",attributes:i.attributes,name:t}),this}}function attachEdgeAttributeUpdater(e,a,d){e.prototype[a]=function(e,t,r){let i;if("mixed"!==this.type&&"mixed"!==d&&d!==this.type)throw new UsageGraphError(`Graph.${a}: cannot find this type of edges in your ${this.type} graph.`);if(3<arguments.length){if(this.multi)throw new UsageGraphError(`Graph.${a}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);var n=""+e,o=""+t;if(t=arguments[2],r=arguments[3],i=getMatchingEdge(this,n,o,d),!i)throw new NotFoundGraphError(`Graph.${a}: could not find an edge for the given path ("${n}" - "${o}").`)}else{if("mixed"!==d)throw new UsageGraphError(`Graph.${a}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,i=this._edges.get(e),!i)throw new NotFoundGraphError(`Graph.${a}: could not find the "${e}" edge in the graph.`)}if("function"!=typeof r)throw new InvalidArgumentsGraphError(`Graph.${a}: updater should be a function.`);return i.attributes[t]=r(i.attributes[t]),this.emit("edgeAttributesUpdated",{key:i.key,type:"set",attributes:i.attributes,name:t}),this}}function attachEdgeAttributeRemover(e,o,a){e.prototype[o]=function(e,t){let r;if("mixed"!==this.type&&"mixed"!==a&&a!==this.type)throw new UsageGraphError(`Graph.${o}: cannot find this type of edges in your ${this.type} graph.`);if(2<arguments.length){if(this.multi)throw new UsageGraphError(`Graph.${o}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);var i=""+e,n=""+t;if(t=arguments[2],r=getMatchingEdge(this,i,n,a),!r)throw new NotFoundGraphError(`Graph.${o}: could not find an edge for the given path ("${i}" - "${n}").`)}else{if("mixed"!==a)throw new UsageGraphError(`Graph.${o}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,r=this._edges.get(e),!r)throw new NotFoundGraphError(`Graph.${o}: could not find the "${e}" edge in the graph.`)}return delete r.attributes[t],this.emit("edgeAttributesUpdated",{key:r.key,type:"remove",attributes:r.attributes,name:t}),this}}function attachEdgeAttributesReplacer(e,o,a){e.prototype[o]=function(e,t){let r;if("mixed"!==this.type&&"mixed"!==a&&a!==this.type)throw new UsageGraphError(`Graph.${o}: cannot find this type of edges in your ${this.type} graph.`);if(2<arguments.length){if(this.multi)throw new UsageGraphError(`Graph.${o}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);var i=""+e,n=""+t;if(t=arguments[2],r=getMatchingEdge(this,i,n,a),!r)throw new NotFoundGraphError(`Graph.${o}: could not find an edge for the given path ("${i}" - "${n}").`)}else{if("mixed"!==a)throw new UsageGraphError(`Graph.${o}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,r=this._edges.get(e),!r)throw new NotFoundGraphError(`Graph.${o}: could not find the "${e}" edge in the graph.`)}if(!isPlainObject(t))throw new InvalidArgumentsGraphError(`Graph.${o}: provided attributes are not a plain object.`);return r.attributes=t,this.emit("edgeAttributesUpdated",{key:r.key,type:"replace",attributes:r.attributes}),this}}function attachEdgeAttributesMerger(e,o,a){e.prototype[o]=function(e,t){let r;if("mixed"!==this.type&&"mixed"!==a&&a!==this.type)throw new UsageGraphError(`Graph.${o}: cannot find this type of edges in your ${this.type} graph.`);if(2<arguments.length){if(this.multi)throw new UsageGraphError(`Graph.${o}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);var i=""+e,n=""+t;if(t=arguments[2],r=getMatchingEdge(this,i,n,a),!r)throw new NotFoundGraphError(`Graph.${o}: could not find an edge for the given path ("${i}" - "${n}").`)}else{if("mixed"!==a)throw new UsageGraphError(`Graph.${o}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,r=this._edges.get(e),!r)throw new NotFoundGraphError(`Graph.${o}: could not find the "${e}" edge in the graph.`)}if(!isPlainObject(t))throw new InvalidArgumentsGraphError(`Graph.${o}: provided attributes are not a plain object.`);return assign(r.attributes,t),this.emit("edgeAttributesUpdated",{key:r.key,type:"merge",attributes:r.attributes,data:t}),this}}function attachEdgeAttributesUpdater(e,o,a){e.prototype[o]=function(e,t){let r;if("mixed"!==this.type&&"mixed"!==a&&a!==this.type)throw new UsageGraphError(`Graph.${o}: cannot find this type of edges in your ${this.type} graph.`);if(2<arguments.length){if(this.multi)throw new UsageGraphError(`Graph.${o}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);var i=""+e,n=""+t;if(t=arguments[2],r=getMatchingEdge(this,i,n,a),!r)throw new NotFoundGraphError(`Graph.${o}: could not find an edge for the given path ("${i}" - "${n}").`)}else{if("mixed"!==a)throw new UsageGraphError(`Graph.${o}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,r=this._edges.get(e),!r)throw new NotFoundGraphError(`Graph.${o}: could not find the "${e}" edge in the graph.`)}if("function"!=typeof t)throw new InvalidArgumentsGraphError(`Graph.${o}: provided updater is not a function.`);return r.attributes=t(r.attributes),this.emit("edgeAttributesUpdated",{key:r.key,type:"update",attributes:r.attributes}),this}}const EDGE_ATTRIBUTES_METHODS=[{name:e=>`get${e}Attribute`,attacher:attachEdgeAttributeGetter},{name:e=>`get${e}Attributes`,attacher:attachEdgeAttributesGetter},{name:e=>`has${e}Attribute`,attacher:attachEdgeAttributeChecker},{name:e=>`set${e}Attribute`,attacher:attachEdgeAttributeSetter},{name:e=>`update${e}Attribute`,attacher:attachEdgeAttributeUpdater},{name:e=>`remove${e}Attribute`,attacher:attachEdgeAttributeRemover},{name:e=>`replace${e}Attributes`,attacher:attachEdgeAttributesReplacer},{name:e=>`merge${e}Attributes`,attacher:attachEdgeAttributesMerger},{name:e=>`update${e}Attributes`,attacher:attachEdgeAttributesUpdater}];function attachEdgeAttributesMethods(r){EDGE_ATTRIBUTES_METHODS.forEach(function({name:e,attacher:t}){t(r,e("Edge"),"mixed"),t(r,e("DirectedEdge"),"directed"),t(r,e("UndirectedEdge"),"undirected")})}const EDGES_ITERATION=[{name:"edges",type:"mixed"},{name:"inEdges",type:"directed",direction:"in"},{name:"outEdges",type:"directed",direction:"out"},{name:"inboundEdges",type:"mixed",direction:"in"},{name:"outboundEdges",type:"mixed",direction:"out"},{name:"directedEdges",type:"directed"},{name:"undirectedEdges",type:"undirected"}];function forEachSimple(e,t,r,i){for(const a in t)if(a!==i){var n=t[a],o=r(n.key,n.attributes,n.source.key,n.target.key,n.source.attributes,n.target.attributes,n.undirected);if(e&&o)return n.key}}function forEachMulti(e,t,r,i){let n,o,a;var d;for(const h in t)if(h!==i){n=t[h];do{if(o=n.source,a=n.target,d=r(n.key,n.attributes,o.key,a.key,o.attributes,a.attributes,n.undirected),e&&d)return n.key}while(n=n.next,void 0!==n)}}function createIterator(t,r){const i=Object.keys(t),n=i.length;let o,a=0;return new Iterator(function(){do{if(o)o=o.next;else{if(a>=n)return{done:!0};var e=i[a++];e!==r?o=t[e]:o=void 0}}while(!o);return{done:!1,value:{edge:o.key,attributes:o.attributes,source:o.source.key,target:o.target.key,sourceAttributes:o.source.attributes,targetAttributes:o.target.attributes,undirected:o.undirected}}})}function forEachForKeySimple(e,t,r,i){var n=t[r];if(n){t=n.source,r=n.target;return i(n.key,n.attributes,t.key,r.key,t.attributes,r.attributes,n.undirected)&&e?n.key:void 0}}function forEachForKeyMulti(e,t,r,i){let n=t[r];if(n){var o;do{if(o=i(n.key,n.attributes,n.source.key,n.target.key,n.source.attributes,n.target.attributes,n.undirected),e&&o)return n.key}while(n=n.next,void 0!==n)}}function createIteratorForKey(e,t){let r=e[t];return void 0!==r.next?new Iterator(function(){if(!r)return{done:!0};var e={edge:r.key,attributes:r.attributes,source:r.source.key,target:r.target.key,sourceAttributes:r.source.attributes,targetAttributes:r.target.attributes,undirected:r.undirected};return r=r.next,{done:!1,value:e}}):Iterator.of({edge:r.key,attributes:r.attributes,source:r.source.key,target:r.target.key,sourceAttributes:r.source.attributes,targetAttributes:r.target.attributes,undirected:r.undirected})}function createEdgeArray(e,t){if(0===e.size)return[];if("mixed"===t||t===e.type)return"function"==typeof Array.from?Array.from(e._edges.keys()):take(e._edges.keys(),e._edges.size);var r,i="undirected"===t?e.undirectedSize:e.directedSize;const n=new Array(i),o="undirected"===t,a=e._edges.values();let d=0;for(;!0!==(r=a.next()).done;)(r=r.value).undirected===o&&(n[d++]=r.key);return n}function forEachEdge(e,t,r,i){if(0!==t.size){var n,o="mixed"!==r&&r!==t.type,a="undirected"===r;const p=t._edges.values();for(;!0!==(u=p.next()).done;)if(n=u.value,!o||n.undirected===a){var{key:d,attributes:h,source:s,target:u}=n,c=i(d,h,s.key,u.key,s.attributes,u.attributes,n.undirected);if(e&&c)return d}}}function createEdgeIterator(e,t){if(0===e.size)return Iterator.empty();const r="mixed"!==t&&t!==e.type,i="undirected"===t,n=e._edges.values();return new Iterator(function(){let e,t;for(;;){if((e=n.next()).done)return e;if(t=e.value,!r||t.undirected===i)break}return{value:{edge:t.key,attributes:t.attributes,source:t.source.key,target:t.target.key,sourceAttributes:t.source.attributes,targetAttributes:t.target.attributes,undirected:t.undirected},done:!1}})}function forEachEdgeForNode(e,t,r,i,n,o){const a=t?forEachMulti:forEachSimple;let d;if("undirected"!==r){if("out"!==i&&(d=a(e,n.in,o),e&&d))return d;if("in"!==i&&(d=a(e,n.out,o,i?void 0:n.key),e&&d))return d}if("directed"!==r&&(d=a(e,n.undirected,o),e&&d))return d}function createEdgeArrayForNode(e,t,r,i){const n=[];return forEachEdgeForNode(!1,e,t,r,i,function(e){n.push(e)}),n}function createEdgeIteratorForNode(e,t,r){let i=Iterator.empty();return"undirected"!==e&&("out"!==t&&void 0!==r.in&&(i=chain(i,createIterator(r.in))),"in"!==t&&void 0!==r.out&&(i=chain(i,createIterator(r.out,t?void 0:r.key)))),"directed"!==e&&void 0!==r.undirected&&(i=chain(i,createIterator(r.undirected))),i}function forEachEdgeForPath(e,t,r,i,n,o,a){const d=r?forEachForKeyMulti:forEachForKeySimple;let h;if("undirected"!==t){if(void 0!==n.in&&"out"!==i&&(h=d(e,n.in,o,a),e&&h))return h;if(void 0!==n.out&&"in"!==i&&(i||n.key!==o)&&(h=d(e,n.out,o,a),e&&h))return h}if("directed"!==t&&void 0!==n.undirected&&(h=d(e,n.undirected,o,a),e&&h))return h}function createEdgeArrayForPath(e,t,r,i,n){const o=[];return forEachEdgeForPath(!1,e,t,r,i,n,function(e){o.push(e)}),o}function createEdgeIteratorForPath(e,t,r,i){let n=Iterator.empty();return"undirected"!==e&&(void 0!==r.in&&"out"!==t&&i in r.in&&(n=chain(n,createIteratorForKey(r.in,i))),void 0!==r.out&&"in"!==t&&i in r.out&&(t||r.key!==i)&&(n=chain(n,createIteratorForKey(r.out,i)))),"directed"!==e&&void 0!==r.undirected&&i in r.undirected&&(n=chain(n,createIteratorForKey(r.undirected,i))),n}function attachEdgeArrayCreator(e,t){const{name:i,type:n,direction:o}=t;e.prototype[i]=function(e,t){if("mixed"!==n&&"mixed"!==this.type&&n!==this.type)return[];if(!arguments.length)return createEdgeArray(this,n);if(1===arguments.length){var r=this._nodes.get(e=""+e);if(void 0===r)throw new NotFoundGraphError(`Graph.${i}: could not find the "${e}" node in the graph.`);return createEdgeArrayForNode(this.multi,"mixed"===n?this.type:n,o,r)}if(2!==arguments.length)throw new InvalidArgumentsGraphError(`Graph.${i}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`);t=""+t;r=this._nodes.get(e=""+e);if(!r)throw new NotFoundGraphError(`Graph.${i}:  could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new NotFoundGraphError(`Graph.${i}:  could not find the "${t}" target node in the graph.`);return createEdgeArrayForPath(n,this.multi,o,r,t)}}function attachForEachEdge(e,t){const{name:r,type:n,direction:o}=t,a="forEach"+r[0].toUpperCase()+r.slice(1,-1);e.prototype[a]=function(e,t,r){if("mixed"===n||"mixed"===this.type||n===this.type){if(1===arguments.length)return r=e,forEachEdge(!1,this,n,r);if(2===arguments.length){r=t;var i=this._nodes.get(e=""+e);if(void 0===i)throw new NotFoundGraphError(`Graph.${a}: could not find the "${e}" node in the graph.`);return forEachEdgeForNode(!1,this.multi,"mixed"===n?this.type:n,o,i,r)}if(3!==arguments.length)throw new InvalidArgumentsGraphError(`Graph.${a}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`);t=""+t;i=this._nodes.get(e=""+e);if(!i)throw new NotFoundGraphError(`Graph.${a}:  could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new NotFoundGraphError(`Graph.${a}:  could not find the "${t}" target node in the graph.`);return forEachEdgeForPath(!1,n,this.multi,o,i,t,r)}};t="map"+r[0].toUpperCase()+r.slice(1);e.prototype[t]=function(){const t=Array.prototype.slice.call(arguments),h=t.pop();let s;if(0===t.length){let e=0;"directed"!==n&&(e+=this.undirectedSize),"undirected"!==n&&(e+=this.directedSize),s=new Array(e);let d=0;t.push((e,t,r,i,n,o,a)=>{s[d++]=h(e,t,r,i,n,o,a)})}else s=[],t.push((e,t,r,i,n,o,a)=>{s.push(h(e,t,r,i,n,o,a))});return this[a].apply(this,t),s};t="filter"+r[0].toUpperCase()+r.slice(1);e.prototype[t]=function(){const e=Array.prototype.slice.call(arguments),d=e.pop(),h=[];return e.push((e,t,r,i,n,o,a)=>{d(e,t,r,i,n,o,a)&&h.push(e)}),this[a].apply(this,e),h};const i="reduce"+r[0].toUpperCase()+r.slice(1);e.prototype[i]=function(){let e=Array.prototype.slice.call(arguments);if(e.length<2||4<e.length)throw new InvalidArgumentsGraphError(`Graph.${i}: invalid number of arguments (expecting 2, 3 or 4 and got ${e.length}).`);if("function"==typeof e[e.length-1]&&"function"!=typeof e[e.length-2])throw new InvalidArgumentsGraphError(`Graph.${i}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`);let d,t;2===e.length?(d=e[0],t=e[1],e=[]):3===e.length?(d=e[1],t=e[2],e=[e[0]]):4===e.length&&(d=e[2],t=e[3],e=[e[0],e[1]]);let h=t;return e.push((e,t,r,i,n,o,a)=>{h=d(h,e,t,r,i,n,o,a)}),this[a].apply(this,e),h}}function attachFindEdge(e,t){const{name:r,type:n,direction:o}=t,a="find"+r[0].toUpperCase()+r.slice(1,-1);e.prototype[a]=function(e,t,r){if("mixed"!==n&&"mixed"!==this.type&&n!==this.type)return!1;if(1===arguments.length)return r=e,forEachEdge(!0,this,n,r);if(2===arguments.length){r=t;var i=this._nodes.get(e=""+e);if(void 0===i)throw new NotFoundGraphError(`Graph.${a}: could not find the "${e}" node in the graph.`);return forEachEdgeForNode(!0,this.multi,"mixed"===n?this.type:n,o,i,r)}if(3!==arguments.length)throw new InvalidArgumentsGraphError(`Graph.${a}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`);t=""+t;i=this._nodes.get(e=""+e);if(!i)throw new NotFoundGraphError(`Graph.${a}:  could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new NotFoundGraphError(`Graph.${a}:  could not find the "${t}" target node in the graph.`);return forEachEdgeForPath(!0,n,this.multi,o,i,t,r)};t="some"+r[0].toUpperCase()+r.slice(1,-1);e.prototype[t]=function(){const e=Array.prototype.slice.call(arguments),d=e.pop();return e.push((e,t,r,i,n,o,a)=>d(e,t,r,i,n,o,a)),!!this[a].apply(this,e)};t="every"+r[0].toUpperCase()+r.slice(1,-1);e.prototype[t]=function(){const e=Array.prototype.slice.call(arguments),d=e.pop();return e.push((e,t,r,i,n,o,a)=>!d(e,t,r,i,n,o,a)),!this[a].apply(this,e)}}function attachEdgeIteratorCreator(e,t){const{name:r,type:i,direction:n}=t,o=r.slice(0,-1)+"Entries";e.prototype[o]=function(e,t){if("mixed"!==i&&"mixed"!==this.type&&i!==this.type)return Iterator.empty();if(!arguments.length)return createEdgeIterator(this,i);if(1===arguments.length){var r=this._nodes.get(e=""+e);if(!r)throw new NotFoundGraphError(`Graph.${o}: could not find the "${e}" node in the graph.`);return createEdgeIteratorForNode(i,n,r)}if(2!==arguments.length)throw new InvalidArgumentsGraphError(`Graph.${o}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`);t=""+t;r=this._nodes.get(e=""+e);if(!r)throw new NotFoundGraphError(`Graph.${o}:  could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new NotFoundGraphError(`Graph.${o}:  could not find the "${t}" target node in the graph.`);return createEdgeIteratorForPath(i,n,r,t)}}function attachEdgeIterationMethods(t){EDGES_ITERATION.forEach(e=>{attachEdgeArrayCreator(t,e),attachForEachEdge(t,e),attachFindEdge(t,e),attachEdgeIteratorCreator(t,e)})}const NEIGHBORS_ITERATION=[{name:"neighbors",type:"mixed"},{name:"inNeighbors",type:"directed",direction:"in"},{name:"outNeighbors",type:"directed",direction:"out"},{name:"inboundNeighbors",type:"mixed",direction:"in"},{name:"outboundNeighbors",type:"mixed",direction:"out"},{name:"directedNeighbors",type:"directed"},{name:"undirectedNeighbors",type:"undirected"}];function CompositeSetWrapper(){this.A=null,this.B=null}function forEachInObjectOnce(e,t,r,i,n){for(const d in i){var o=i[d],a=o.source,o=o.target,o=a===r?o:a;if(!t||!t.has(o.key)){a=n(o.key,o.attributes);if(e&&a)return o.key}}}function forEachNeighbor(e,t,r,i,n){if("mixed"!==t){if("undirected"===t)return forEachInObjectOnce(e,null,i,i.undirected,n);if("string"==typeof r)return forEachInObjectOnce(e,null,i,i[r],n)}const o=new CompositeSetWrapper;let a;if("undirected"!==t){if("out"!==r){if(a=forEachInObjectOnce(e,null,i,i.in,n),e&&a)return a;o.wrap(i.in)}if("in"!==r){if(a=forEachInObjectOnce(e,o,i,i.out,n),e&&a)return a;o.wrap(i.out)}}if("directed"!==t&&(a=forEachInObjectOnce(e,o,i,i.undirected,n),e&&a))return a}function createNeighborArrayForNode(e,t,r){if("mixed"!==e){if("undirected"===e)return Object.keys(r.undirected);if("string"==typeof t)return Object.keys(r[t])}const i=[];return forEachNeighbor(!1,e,t,r,function(e){i.push(e)}),i}function createDedupedObjectIterator(i,n,o){const a=Object.keys(o),d=a.length;let h=0;return new Iterator(function(){let e=null;do{if(h>=d)return i&&i.wrap(o),{done:!0};var t=o[a[h++]],r=t.source,t=t.target;e=r===n?t:r,i&&i.has(e.key)&&(e=null)}while(null===e);return{done:!1,value:{neighbor:e.key,attributes:e.attributes}}})}function createNeighborIterator(e,t,r){if("mixed"!==e){if("undirected"===e)return createDedupedObjectIterator(null,r,r.undirected);if("string"==typeof t)return createDedupedObjectIterator(null,r,r[t])}let i=Iterator.empty();var n=new CompositeSetWrapper;return"undirected"!==e&&("out"!==t&&(i=chain(i,createDedupedObjectIterator(n,r,r.in))),"in"!==t&&(i=chain(i,createDedupedObjectIterator(n,r,r.out)))),"directed"!==e&&(i=chain(i,createDedupedObjectIterator(n,r,r.undirected))),i}function attachNeighborArrayCreator(e,t){const{name:r,type:i,direction:n}=t;e.prototype[r]=function(e){if("mixed"!==i&&"mixed"!==this.type&&i!==this.type)return[];var t=this._nodes.get(e=""+e);if(void 0===t)throw new NotFoundGraphError(`Graph.${r}: could not find the "${e}" node in the graph.`);return createNeighborArrayForNode("mixed"===i?this.type:i,n,t)}}function attachForEachNeighbor(e,t){const{name:r,type:i,direction:n}=t,o="forEach"+r[0].toUpperCase()+r.slice(1,-1);e.prototype[o]=function(e,t){if("mixed"===i||"mixed"===this.type||i===this.type){var r=this._nodes.get(e=""+e);if(void 0===r)throw new NotFoundGraphError(`Graph.${o}: could not find the "${e}" node in the graph.`);forEachNeighbor(!1,"mixed"===i?this.type:i,n,r,t)}};t="map"+r[0].toUpperCase()+r.slice(1);e.prototype[t]=function(e,r){const i=[];return this[o](e,(e,t)=>{i.push(r(e,t))}),i};t="filter"+r[0].toUpperCase()+r.slice(1);e.prototype[t]=function(e,r){const i=[];return this[o](e,(e,t)=>{r(e,t)&&i.push(e)}),i};const a="reduce"+r[0].toUpperCase()+r.slice(1);e.prototype[a]=function(e,r,t){if(arguments.length<3)throw new InvalidArgumentsGraphError(`Graph.${a}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`);let i=t;return this[o](e,(e,t)=>{i=r(i,e,t)}),i}}function attachFindNeighbor(e,t){const{name:r,type:i,direction:n}=t;t=r[0].toUpperCase()+r.slice(1,-1);const o="find"+t;e.prototype[o]=function(e,t){if("mixed"===i||"mixed"===this.type||i===this.type){var r=this._nodes.get(e=""+e);if(void 0===r)throw new NotFoundGraphError(`Graph.${o}: could not find the "${e}" node in the graph.`);return forEachNeighbor(!0,"mixed"===i?this.type:i,n,r,t)}},e.prototype["some"+t]=function(e,t){return!!this[o](e,t)},e.prototype["every"+t]=function(e,r){return!this[o](e,(e,t)=>!r(e,t))}}function attachNeighborIteratorCreator(e,t){const{name:r,type:i,direction:n}=t,o=r.slice(0,-1)+"Entries";e.prototype[o]=function(e){if("mixed"!==i&&"mixed"!==this.type&&i!==this.type)return Iterator.empty();var t=this._nodes.get(e=""+e);if(void 0===t)throw new NotFoundGraphError(`Graph.${o}: could not find the "${e}" node in the graph.`);return createNeighborIterator("mixed"===i?this.type:i,n,t)}}function attachNeighborIterationMethods(t){NEIGHBORS_ITERATION.forEach(e=>{attachNeighborArrayCreator(t,e),attachForEachNeighbor(t,e),attachFindNeighbor(t,e),attachNeighborIteratorCreator(t,e)})}function forEachAdjacency(t,r,i,e,n){const o=e._nodes.values();var a=e.type;let d,h,s,u,c,p,g;for(;!0!==(d=o.next()).done;){let e=!1;if(h=d.value,"undirected"!==a)for(s in u=h.out,u){c=u[s];do{if(p=c.target,e=!0,g=n(h.key,p.key,h.attributes,p.attributes,c.key,c.attributes,c.undirected),t&&g)return c}while(c=c.next,c)}if("directed"!==a)for(s in u=h.undirected,u)if(!(r&&h.key>s)){c=u[s];do{if(p=c.target,p.key!==s&&(p=c.source),e=!0,g=n(h.key,p.key,h.attributes,p.attributes,c.key,c.attributes,c.undirected),t&&g)return c}while(c=c.next,c)}if(i&&!e&&(g=n(h.key,null,h.attributes,null,null,null,null),t&&g))return null}}function serializeNode(e,t){const r={key:e};return isEmpty(t.attributes)||(r.attributes=assign({},t.attributes)),r}function serializeEdge(e,t){const r={key:e,source:t.source.key,target:t.target.key};return isEmpty(t.attributes)||(r.attributes=assign({},t.attributes)),t.undirected&&(r.undirected=!0),r}function validateSerializedNode(e){if(!isPlainObject(e))throw new InvalidArgumentsGraphError('Graph.import: invalid serialized node. A serialized node should be a plain object with at least a "key" property.');if(!("key"in e))throw new InvalidArgumentsGraphError("Graph.import: serialized node is missing its key.");if("attributes"in e&&(!isPlainObject(e.attributes)||null===e.attributes))throw new InvalidArgumentsGraphError("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.")}function validateSerializedEdge(e){if(!isPlainObject(e))throw new InvalidArgumentsGraphError('Graph.import: invalid serialized edge. A serialized edge should be a plain object with at least a "source" & "target" property.');if(!("source"in e))throw new InvalidArgumentsGraphError("Graph.import: serialized edge is missing its source.");if(!("target"in e))throw new InvalidArgumentsGraphError("Graph.import: serialized edge is missing its target.");if("attributes"in e&&(!isPlainObject(e.attributes)||null===e.attributes))throw new InvalidArgumentsGraphError("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.");if("undirected"in e&&"boolean"!=typeof e.undirected)throw new InvalidArgumentsGraphError("Graph.import: invalid undirectedness information. Undirected should be boolean or omitted.")}CompositeSetWrapper.prototype.wrap=function(e){null===this.A?this.A=e:null===this.B&&(this.B=e)},CompositeSetWrapper.prototype.has=function(e){return null!==this.A&&e in this.A||null!==this.B&&e in this.B};const INSTANCE_ID=incrementalIdStartingFromRandomByte(),TYPES=new Set(["directed","undirected","mixed"]),EMITTER_PROPS=new Set(["domain","_events","_eventsCount","_maxListeners"]),EDGE_ADD_METHODS=[{name:e=>`${e}Edge`,generateKey:!0},{name:e=>`${e}DirectedEdge`,generateKey:!0,type:"directed"},{name:e=>`${e}UndirectedEdge`,generateKey:!0,type:"undirected"},{name:e=>`${e}EdgeWithKey`},{name:e=>`${e}DirectedEdgeWithKey`,type:"directed"},{name:e=>`${e}UndirectedEdgeWithKey`,type:"undirected"}],DEFAULTS={allowSelfLoops:!0,multi:!1,type:"mixed"};function addNode(e,t,r){if(r&&!isPlainObject(r))throw new InvalidArgumentsGraphError(`Graph.addNode: invalid attributes. Expecting an object but got "${r}"`);if(r=r||{},e._nodes.has(t=""+t))throw new UsageGraphError(`Graph.addNode: the "${t}" node already exist in the graph.`);var i=new e.NodeDataClass(t,r);return e._nodes.set(t,i),e.emit("nodeAdded",{key:t,attributes:r}),i}function unsafeAddNode(e,t,r){var i=new e.NodeDataClass(t,r);return e._nodes.set(t,i),e.emit("nodeAdded",{key:t,attributes:r}),i}function addEdge(e,t,r,i,n,o,a,d){if(!i&&"undirected"===e.type)throw new UsageGraphError(`Graph.${t}: you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.`);if(i&&"directed"===e.type)throw new UsageGraphError(`Graph.${t}: you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.`);if(d&&!isPlainObject(d))throw new InvalidArgumentsGraphError(`Graph.${t}: invalid attributes. Expecting an object but got "${d}"`);if(o=""+o,a=""+a,d=d||{},!e.allowSelfLoops&&o===a)throw new UsageGraphError(`Graph.${t}: source & target are the same ("${o}"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`);const h=e._nodes.get(o),s=e._nodes.get(a);if(!h)throw new NotFoundGraphError(`Graph.${t}: source node "${o}" not found.`);if(!s)throw new NotFoundGraphError(`Graph.${t}: target node "${a}" not found.`);const u={key:null,undirected:i,source:o,target:a,attributes:d};if(r)n=e._edgeKeyGenerator();else if(e._edges.has(n=""+n))throw new UsageGraphError(`Graph.${t}: the "${n}" edge already exists in the graph.`);if(!e.multi&&(i?void 0!==h.undirected[a]:void 0!==h.out[a]))throw new UsageGraphError(`Graph.${t}: an edge linking "${o}" to "${a}" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.`);const c=new EdgeData(i,n,h,s,d);e._edges.set(n,c);a=o===a;return i?(h.undirectedDegree++,s.undirectedDegree++,a&&e._undirectedSelfLoopCount++):(h.outDegree++,s.inDegree++,a&&e._directedSelfLoopCount++),e.multi?c.attachMulti():c.attach(),i?e._undirectedSize++:e._directedSize++,u.key=n,e.emit("edgeAdded",u),n}function mergeEdge(e,t,r,i,n,o,a,d,h){if(!i&&"undirected"===e.type)throw new UsageGraphError(`Graph.${t}: you cannot merge/update a directed edge to an undirected graph. Use the #.mergeEdge/#.updateEdge or #.addUndirectedEdge instead.`);if(i&&"directed"===e.type)throw new UsageGraphError(`Graph.${t}: you cannot merge/update an undirected edge to a directed graph. Use the #.mergeEdge/#.updateEdge or #.addDirectedEdge instead.`);if(d)if(h){if("function"!=typeof d)throw new InvalidArgumentsGraphError(`Graph.${t}: invalid updater function. Expecting a function but got "${d}"`)}else if(!isPlainObject(d))throw new InvalidArgumentsGraphError(`Graph.${t}: invalid attributes. Expecting an object but got "${d}"`);o=""+o,a=""+a;let s;if(h&&(s=d,d=void 0),!e.allowSelfLoops&&o===a)throw new UsageGraphError(`Graph.${t}: source & target are the same ("${o}"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`);let u=e._nodes.get(o),c=e._nodes.get(a),p,g;if(!r&&(p=e._edges.get(n),p)){if(!(p.source.key===o&&p.target.key===a||i&&p.source.key===a&&p.target.key===o))throw new UsageGraphError(`Graph.${t}: inconsistency detected when attempting to merge the "${n}" edge with "${o}" source & "${a}" target vs. ("${p.source.key}", "${p.target.key}").`);g=p}if(g||e.multi||!u||(g=(i?u.undirected:u.out)[a]),g){var l,f=[g.key,!1,!1,!1];return(h?s:d)?(h?(l=g.attributes,g.attributes=s(l),e.emit("edgeAttributesUpdated",{type:"replace",key:g.key,attributes:g.attributes})):(assign(g.attributes,d),e.emit("edgeAttributesUpdated",{type:"merge",key:g.key,attributes:g.attributes,data:d})),f):f}d=d||{};const y={key:null,undirected:i,source:o,target:a,attributes:d=h&&s?s(d):d};if(r)n=e._edgeKeyGenerator();else if(e._edges.has(n=""+n))throw new UsageGraphError(`Graph.${t}: the "${n}" edge already exists in the graph.`);let m=!1,b=!1;u||(u=unsafeAddNode(e,o,{}),m=!0,o===a&&(c=u,b=!0)),c||(c=unsafeAddNode(e,a,{}),b=!0),p=new EdgeData(i,n,u,c,d),e._edges.set(n,p);a=o===a;return i?(u.undirectedDegree++,c.undirectedDegree++,a&&e._undirectedSelfLoopCount++):(u.outDegree++,c.inDegree++,a&&e._directedSelfLoopCount++),e.multi?p.attachMulti():p.attach(),i?e._undirectedSize++:e._directedSize++,y.key=n,e.emit("edgeAdded",y),[n,!0,m,b]}function dropEdgeFromData(e,t){e._edges.delete(t.key);const{source:r,target:i,attributes:n}=t;var o=t.undirected,a=r===i;o?(r.undirectedDegree--,i.undirectedDegree--,a&&e._undirectedSelfLoopCount--):(r.outDegree--,i.inDegree--,a&&e._directedSelfLoopCount--),e.multi?t.detachMulti():t.detach(),o?e._undirectedSize--:e._directedSize--,e.emit("edgeDropped",{key:t.key,attributes:n,source:r.key,target:i.key,undirected:o})}class Graph extends EventEmitter{constructor(e){if(super(),"boolean"!=typeof(e=assign({},DEFAULTS,e)).multi)throw new InvalidArgumentsGraphError(`Graph.constructor: invalid 'multi' option. Expecting a boolean but got "${e.multi}".`);if(!TYPES.has(e.type))throw new InvalidArgumentsGraphError(`Graph.constructor: invalid 'type' option. Should be one of "mixed", "directed" or "undirected" but got "${e.type}".`);if("boolean"!=typeof e.allowSelfLoops)throw new InvalidArgumentsGraphError(`Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got "${e.allowSelfLoops}".`);privateProperty(this,"NodeDataClass","mixed"===e.type?MixedNodeData:"directed"===e.type?DirectedNodeData:UndirectedNodeData);const t="geid_"+INSTANCE_ID()+"_";let r=0;privateProperty(this,"_attributes",{}),privateProperty(this,"_nodes",new Map),privateProperty(this,"_edges",new Map),privateProperty(this,"_directedSize",0),privateProperty(this,"_undirectedSize",0),privateProperty(this,"_directedSelfLoopCount",0),privateProperty(this,"_undirectedSelfLoopCount",0),privateProperty(this,"_edgeKeyGenerator",()=>{let e;for(;e=t+r++,this._edges.has(e););return e}),privateProperty(this,"_options",e),EMITTER_PROPS.forEach(e=>privateProperty(this,e,this[e])),readOnlyProperty(this,"order",()=>this._nodes.size),readOnlyProperty(this,"size",()=>this._edges.size),readOnlyProperty(this,"directedSize",()=>this._directedSize),readOnlyProperty(this,"undirectedSize",()=>this._undirectedSize),readOnlyProperty(this,"selfLoopCount",()=>this._directedSelfLoopCount+this._undirectedSelfLoopCount),readOnlyProperty(this,"directedSelfLoopCount",()=>this._directedSelfLoopCount),readOnlyProperty(this,"undirectedSelfLoopCount",()=>this._undirectedSelfLoopCount),readOnlyProperty(this,"multi",this._options.multi),readOnlyProperty(this,"type",this._options.type),readOnlyProperty(this,"allowSelfLoops",this._options.allowSelfLoops),readOnlyProperty(this,"implementation",()=>"graphology")}_resetInstanceCounters(){this._directedSize=0,this._undirectedSize=0,this._directedSelfLoopCount=0,this._undirectedSelfLoopCount=0}hasNode(e){return this._nodes.has(""+e)}hasDirectedEdge(e,t){if("undirected"===this.type)return!1;if(1===arguments.length){var r=this._edges.get(""+e);return!!r&&!r.undirected}if(2!==arguments.length)throw new InvalidArgumentsGraphError(`Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`);t=""+t;r=this._nodes.get(e=""+e);if(!r)return!1;r=r.out[t];return!!r&&(!this.multi||!!r.size)}hasUndirectedEdge(e,t){if("directed"===this.type)return!1;if(1===arguments.length){var r=this._edges.get(""+e);return!!r&&r.undirected}if(2!==arguments.length)throw new InvalidArgumentsGraphError(`Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`);t=""+t;r=this._nodes.get(e=""+e);if(!r)return!1;r=r.undirected[t];return!!r&&(!this.multi||!!r.size)}hasEdge(t,r){if(1===arguments.length)return this._edges.has(""+t);if(2!==arguments.length)throw new InvalidArgumentsGraphError(`Graph.hasEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`);{r=""+r;var i=this._nodes.get(t=""+t);if(!i)return!1;let e=void 0!==i.out&&i.out[r];return e=e||void 0!==i.undirected&&i.undirected[r],e?!this.multi||!!e.size:!1}}directedEdge(e,t){if("undirected"!==this.type){if(e=""+e,t=""+t,this.multi)throw new UsageGraphError("Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.");var r=this._nodes.get(e);if(!r)throw new NotFoundGraphError(`Graph.directedEdge: could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new NotFoundGraphError(`Graph.directedEdge: could not find the "${t}" target node in the graph.`);t=r.out&&r.out[t]||void 0;return t?t.key:void 0}}undirectedEdge(e,t){if("directed"!==this.type){if(e=""+e,t=""+t,this.multi)throw new UsageGraphError("Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.");var r=this._nodes.get(e);if(!r)throw new NotFoundGraphError(`Graph.undirectedEdge: could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new NotFoundGraphError(`Graph.undirectedEdge: could not find the "${t}" target node in the graph.`);t=r.undirected&&r.undirected[t]||void 0;return t?t.key:void 0}}edge(e,t){if(this.multi)throw new UsageGraphError("Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.");t=""+t;var r=this._nodes.get(e=""+e);if(!r)throw new NotFoundGraphError(`Graph.edge: could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new NotFoundGraphError(`Graph.edge: could not find the "${t}" target node in the graph.`);t=r.out&&r.out[t]||r.undirected&&r.undirected[t]||void 0;if(t)return t.key}areDirectedNeighbors(e,t){t=""+t;var r=this._nodes.get(e=""+e);if(!r)throw new NotFoundGraphError(`Graph.areDirectedNeighbors: could not find the "${e}" node in the graph.`);return"undirected"!==this.type&&(t in r.in||t in r.out)}areOutNeighbors(e,t){t=""+t;var r=this._nodes.get(e=""+e);if(!r)throw new NotFoundGraphError(`Graph.areOutNeighbors: could not find the "${e}" node in the graph.`);return"undirected"!==this.type&&t in r.out}areInNeighbors(e,t){t=""+t;var r=this._nodes.get(e=""+e);if(!r)throw new NotFoundGraphError(`Graph.areInNeighbors: could not find the "${e}" node in the graph.`);return"undirected"!==this.type&&t in r.in}areUndirectedNeighbors(e,t){t=""+t;var r=this._nodes.get(e=""+e);if(!r)throw new NotFoundGraphError(`Graph.areUndirectedNeighbors: could not find the "${e}" node in the graph.`);return"directed"!==this.type&&t in r.undirected}areNeighbors(e,t){t=""+t;var r=this._nodes.get(e=""+e);if(!r)throw new NotFoundGraphError(`Graph.areNeighbors: could not find the "${e}" node in the graph.`);return"undirected"!==this.type&&(t in r.in||t in r.out)||"directed"!==this.type&&t in r.undirected}areInboundNeighbors(e,t){t=""+t;var r=this._nodes.get(e=""+e);if(!r)throw new NotFoundGraphError(`Graph.areInboundNeighbors: could not find the "${e}" node in the graph.`);return"undirected"!==this.type&&t in r.in||"directed"!==this.type&&t in r.undirected}areOutboundNeighbors(e,t){t=""+t;var r=this._nodes.get(e=""+e);if(!r)throw new NotFoundGraphError(`Graph.areOutboundNeighbors: could not find the "${e}" node in the graph.`);return"undirected"!==this.type&&t in r.out||"directed"!==this.type&&t in r.undirected}inDegree(e){var t=this._nodes.get(e=""+e);if(!t)throw new NotFoundGraphError(`Graph.inDegree: could not find the "${e}" node in the graph.`);return"undirected"===this.type?0:t.inDegree}outDegree(e){var t=this._nodes.get(e=""+e);if(!t)throw new NotFoundGraphError(`Graph.outDegree: could not find the "${e}" node in the graph.`);return"undirected"===this.type?0:t.outDegree}directedDegree(e){var t=this._nodes.get(e=""+e);if(!t)throw new NotFoundGraphError(`Graph.directedDegree: could not find the "${e}" node in the graph.`);return"undirected"===this.type?0:t.inDegree+t.outDegree}undirectedDegree(e){var t=this._nodes.get(e=""+e);if(!t)throw new NotFoundGraphError(`Graph.undirectedDegree: could not find the "${e}" node in the graph.`);return"directed"===this.type?0:t.undirectedDegree}inboundDegree(e){var t=this._nodes.get(e=""+e);if(!t)throw new NotFoundGraphError(`Graph.inboundDegree: could not find the "${e}" node in the graph.`);let r=0;return"directed"!==this.type&&(r+=t.undirectedDegree),"undirected"!==this.type&&(r+=t.inDegree),r}outboundDegree(e){var t=this._nodes.get(e=""+e);if(!t)throw new NotFoundGraphError(`Graph.outboundDegree: could not find the "${e}" node in the graph.`);let r=0;return"directed"!==this.type&&(r+=t.undirectedDegree),"undirected"!==this.type&&(r+=t.outDegree),r}degree(e){var t=this._nodes.get(e=""+e);if(!t)throw new NotFoundGraphError(`Graph.degree: could not find the "${e}" node in the graph.`);let r=0;return"directed"!==this.type&&(r+=t.undirectedDegree),"undirected"!==this.type&&(r+=t.inDegree+t.outDegree),r}inDegreeWithoutSelfLoops(e){var t=this._nodes.get(e=""+e);if(!t)throw new NotFoundGraphError(`Graph.inDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);if("undirected"===this.type)return 0;e=t.in[e],e=e?this.multi?e.size:1:0;return t.inDegree-e}outDegreeWithoutSelfLoops(e){var t=this._nodes.get(e=""+e);if(!t)throw new NotFoundGraphError(`Graph.outDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);if("undirected"===this.type)return 0;e=t.out[e],e=e?this.multi?e.size:1:0;return t.outDegree-e}directedDegreeWithoutSelfLoops(e){var t=this._nodes.get(e=""+e);if(!t)throw new NotFoundGraphError(`Graph.directedDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);if("undirected"===this.type)return 0;e=t.out[e],e=e?this.multi?e.size:1:0;return t.inDegree+t.outDegree-2*e}undirectedDegreeWithoutSelfLoops(e){var t=this._nodes.get(e=""+e);if(!t)throw new NotFoundGraphError(`Graph.undirectedDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);if("directed"===this.type)return 0;e=t.undirected[e],e=e?this.multi?e.size:1:0;return t.undirectedDegree-2*e}inboundDegreeWithoutSelfLoops(e){var t=this._nodes.get(e=""+e);if(!t)throw new NotFoundGraphError(`Graph.inboundDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);let r,i=0,n=0;return"directed"!==this.type&&(i+=t.undirectedDegree,r=t.undirected[e],n+=2*(r?this.multi?r.size:1:0)),"undirected"!==this.type&&(i+=t.inDegree,r=t.out[e],n+=r?this.multi?r.size:1:0),i-n}outboundDegreeWithoutSelfLoops(e){var t=this._nodes.get(e=""+e);if(!t)throw new NotFoundGraphError(`Graph.outboundDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);let r,i=0,n=0;return"directed"!==this.type&&(i+=t.undirectedDegree,r=t.undirected[e],n+=2*(r?this.multi?r.size:1:0)),"undirected"!==this.type&&(i+=t.outDegree,r=t.in[e],n+=r?this.multi?r.size:1:0),i-n}degreeWithoutSelfLoops(e){var t=this._nodes.get(e=""+e);if(!t)throw new NotFoundGraphError(`Graph.degreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);let r,i=0,n=0;return"directed"!==this.type&&(i+=t.undirectedDegree,r=t.undirected[e],n+=2*(r?this.multi?r.size:1:0)),"undirected"!==this.type&&(i+=t.inDegree+t.outDegree,r=t.out[e],n+=2*(r?this.multi?r.size:1:0)),i-n}source(e){var t=this._edges.get(e=""+e);if(!t)throw new NotFoundGraphError(`Graph.source: could not find the "${e}" edge in the graph.`);return t.source.key}target(e){var t=this._edges.get(e=""+e);if(!t)throw new NotFoundGraphError(`Graph.target: could not find the "${e}" edge in the graph.`);return t.target.key}extremities(e){var t=this._edges.get(e=""+e);if(!t)throw new NotFoundGraphError(`Graph.extremities: could not find the "${e}" edge in the graph.`);return[t.source.key,t.target.key]}opposite(e,t){e=""+e;var r=this._edges.get(t=""+t);if(!r)throw new NotFoundGraphError(`Graph.opposite: could not find the "${t}" edge in the graph.`);var i=r.source.key,r=r.target.key;if(e===i)return r;if(e===r)return i;throw new NotFoundGraphError(`Graph.opposite: the "${e}" node is not attached to the "${t}" edge (${i}, ${r}).`)}hasExtremity(e,t){t=""+t;var r=this._edges.get(e=""+e);if(!r)throw new NotFoundGraphError(`Graph.hasExtremity: could not find the "${e}" edge in the graph.`);return r.source.key===t||r.target.key===t}isUndirected(e){var t=this._edges.get(e=""+e);if(!t)throw new NotFoundGraphError(`Graph.isUndirected: could not find the "${e}" edge in the graph.`);return t.undirected}isDirected(e){var t=this._edges.get(e=""+e);if(!t)throw new NotFoundGraphError(`Graph.isDirected: could not find the "${e}" edge in the graph.`);return!t.undirected}isSelfLoop(e){var t=this._edges.get(e=""+e);if(!t)throw new NotFoundGraphError(`Graph.isSelfLoop: could not find the "${e}" edge in the graph.`);return t.source===t.target}addNode(e,t){return addNode(this,e,t).key}mergeNode(e,t){if(t&&!isPlainObject(t))throw new InvalidArgumentsGraphError(`Graph.mergeNode: invalid attributes. Expecting an object but got "${t}"`);t=t||{};let r=this._nodes.get(e=""+e);return r?(t&&(assign(r.attributes,t),this.emit("nodeAttributesUpdated",{type:"merge",key:e,attributes:r.attributes,data:t})),[e,!1]):(r=new this.NodeDataClass(e,t),this._nodes.set(e,r),this.emit("nodeAdded",{key:e,attributes:t}),[e,!0])}updateNode(e,t){if(t&&"function"!=typeof t)throw new InvalidArgumentsGraphError(`Graph.updateNode: invalid updater function. Expecting a function but got "${t}"`);let r=this._nodes.get(e=""+e);var i;if(r)return t&&(i=r.attributes,r.attributes=t(i),this.emit("nodeAttributesUpdated",{type:"replace",key:e,attributes:r.attributes})),[e,!1];t=t?t({}):{};return r=new this.NodeDataClass(e,t),this._nodes.set(e,r),this.emit("nodeAdded",{key:e,attributes:t}),[e,!0]}dropNode(e){var t=this._nodes.get(e=""+e);if(!t)throw new NotFoundGraphError(`Graph.dropNode: could not find the "${e}" node in the graph.`);let r;if("undirected"!==this.type){for(const i in t.out)for(r=t.out[i];dropEdgeFromData(this,r),r=r.next,r;);for(const n in t.in)for(r=t.in[n];dropEdgeFromData(this,r),r=r.next,r;);}if("directed"!==this.type)for(const o in t.undirected)for(r=t.undirected[o];dropEdgeFromData(this,r),r=r.next,r;);this._nodes.delete(e),this.emit("nodeDropped",{key:e,attributes:t.attributes})}dropEdge(e){let t;if(1<arguments.length){var r=""+arguments[0],i=""+arguments[1];if(t=getMatchingEdge(this,r,i,this.type),!t)throw new NotFoundGraphError(`Graph.dropEdge: could not find the "${r}" -> "${i}" edge in the graph.`)}else if(e=""+e,t=this._edges.get(e),!t)throw new NotFoundGraphError(`Graph.dropEdge: could not find the "${e}" edge in the graph.`);return dropEdgeFromData(this,t),this}dropDirectedEdge(e,t){if(arguments.length<2)throw new UsageGraphError("Graph.dropDirectedEdge: it does not make sense to try and drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");if(this.multi)throw new UsageGraphError("Graph.dropDirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");var r=getMatchingEdge(this,e=""+e,t=""+t,"directed");if(!r)throw new NotFoundGraphError(`Graph.dropDirectedEdge: could not find a "${e}" -> "${t}" edge in the graph.`);return dropEdgeFromData(this,r),this}dropUndirectedEdge(e,t){if(arguments.length<2)throw new UsageGraphError("Graph.dropUndirectedEdge: it does not make sense to drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");if(this.multi)throw new UsageGraphError("Graph.dropUndirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");var r=getMatchingEdge(this,e,t,"undirected");if(!r)throw new NotFoundGraphError(`Graph.dropUndirectedEdge: could not find a "${e}" -> "${t}" edge in the graph.`);return dropEdgeFromData(this,r),this}clear(){this._edges.clear(),this._nodes.clear(),this._resetInstanceCounters(),this.emit("cleared")}clearEdges(){const e=this._nodes.values();let t;for(;t=e.next(),!0!==t.done;)t.value.clear();this._edges.clear(),this._resetInstanceCounters(),this.emit("edgesCleared")}getAttribute(e){return this._attributes[e]}getAttributes(){return this._attributes}hasAttribute(e){return this._attributes.hasOwnProperty(e)}setAttribute(e,t){return this._attributes[e]=t,this.emit("attributesUpdated",{type:"set",attributes:this._attributes,name:e}),this}updateAttribute(e,t){if("function"!=typeof t)throw new InvalidArgumentsGraphError("Graph.updateAttribute: updater should be a function.");var r=this._attributes[e];return this._attributes[e]=t(r),this.emit("attributesUpdated",{type:"set",attributes:this._attributes,name:e}),this}removeAttribute(e){return delete this._attributes[e],this.emit("attributesUpdated",{type:"remove",attributes:this._attributes,name:e}),this}replaceAttributes(e){if(!isPlainObject(e))throw new InvalidArgumentsGraphError("Graph.replaceAttributes: provided attributes are not a plain object.");return this._attributes=e,this.emit("attributesUpdated",{type:"replace",attributes:this._attributes}),this}mergeAttributes(e){if(!isPlainObject(e))throw new InvalidArgumentsGraphError("Graph.mergeAttributes: provided attributes are not a plain object.");return assign(this._attributes,e),this.emit("attributesUpdated",{type:"merge",attributes:this._attributes,data:e}),this}updateAttributes(e){if("function"!=typeof e)throw new InvalidArgumentsGraphError("Graph.updateAttributes: provided updater is not a function.");return this._attributes=e(this._attributes),this.emit("attributesUpdated",{type:"update",attributes:this._attributes}),this}updateEachNodeAttributes(e,t){if("function"!=typeof e)throw new InvalidArgumentsGraphError("Graph.updateEachNodeAttributes: expecting an updater function.");if(t&&!validateHints(t))throw new InvalidArgumentsGraphError("Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");const r=this._nodes.values();let i,n;for(;!0!==(i=r.next()).done;)n=i.value,n.attributes=e(n.key,n.attributes);this.emit("eachNodeAttributesUpdated",{hints:t||null})}updateEachEdgeAttributes(e,t){if("function"!=typeof e)throw new InvalidArgumentsGraphError("Graph.updateEachEdgeAttributes: expecting an updater function.");if(t&&!validateHints(t))throw new InvalidArgumentsGraphError("Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");const r=this._edges.values();let i,n,o,a;for(;!0!==(i=r.next()).done;)n=i.value,o=n.source,a=n.target,n.attributes=e(n.key,n.attributes,o.key,a.key,o.attributes,a.attributes,n.undirected);this.emit("eachEdgeAttributesUpdated",{hints:t||null})}forEachAdjacencyEntry(e){if("function"!=typeof e)throw new InvalidArgumentsGraphError("Graph.forEachAdjacencyEntry: expecting a callback.");forEachAdjacency(!1,!1,!1,this,e)}forEachAdjacencyEntryWithOrphans(e){if("function"!=typeof e)throw new InvalidArgumentsGraphError("Graph.forEachAdjacencyEntryWithOrphans: expecting a callback.");forEachAdjacency(!1,!1,!0,this,e)}forEachAssymetricAdjacencyEntry(e){if("function"!=typeof e)throw new InvalidArgumentsGraphError("Graph.forEachAssymetricAdjacencyEntry: expecting a callback.");forEachAdjacency(!1,!0,!1,this,e)}forEachAssymetricAdjacencyEntryWithOrphans(e){if("function"!=typeof e)throw new InvalidArgumentsGraphError("Graph.forEachAssymetricAdjacencyEntryWithOrphans: expecting a callback.");forEachAdjacency(!1,!0,!0,this,e)}nodes(){return"function"==typeof Array.from?Array.from(this._nodes.keys()):take(this._nodes.keys(),this._nodes.size)}forEachNode(e){if("function"!=typeof e)throw new InvalidArgumentsGraphError("Graph.forEachNode: expecting a callback.");const t=this._nodes.values();for(var r;!0!==(r=t.next()).done;)e((r=r.value).key,r.attributes)}findNode(e){if("function"!=typeof e)throw new InvalidArgumentsGraphError("Graph.findNode: expecting a callback.");const t=this._nodes.values();for(var r;!0!==(r=t.next()).done;)if(e((r=r.value).key,r.attributes))return r.key}mapNodes(e){if("function"!=typeof e)throw new InvalidArgumentsGraphError("Graph.mapNode: expecting a callback.");const t=this._nodes.values();var r;const i=new Array(this.order);let n=0;for(;!0!==(r=t.next()).done;)r=r.value,i[n++]=e(r.key,r.attributes);return i}someNode(e){if("function"!=typeof e)throw new InvalidArgumentsGraphError("Graph.someNode: expecting a callback.");const t=this._nodes.values();for(var r;!0!==(r=t.next()).done;)if(e((r=r.value).key,r.attributes))return!0;return!1}everyNode(e){if("function"!=typeof e)throw new InvalidArgumentsGraphError("Graph.everyNode: expecting a callback.");const t=this._nodes.values();for(var r;!0!==(r=t.next()).done;)if(!e((r=r.value).key,r.attributes))return!1;return!0}filterNodes(e){if("function"!=typeof e)throw new InvalidArgumentsGraphError("Graph.filterNodes: expecting a callback.");const t=this._nodes.values();var r;const i=[];for(;!0!==(r=t.next()).done;)e((r=r.value).key,r.attributes)&&i.push(r.key);return i}reduceNodes(e,t){if("function"!=typeof e)throw new InvalidArgumentsGraphError("Graph.reduceNodes: expecting a callback.");if(arguments.length<2)throw new InvalidArgumentsGraphError("Graph.reduceNodes: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.");let r=t;const i=this._nodes.values();for(var n;!0!==(n=i.next()).done;)n=n.value,r=e(r,n.key,n.attributes);return r}nodeEntries(){const t=this._nodes.values();return new Iterator(()=>{var e=t.next();if(e.done)return e;e=e.value;return{value:{node:e.key,attributes:e.attributes},done:!1}})}export(){const r=new Array(this._nodes.size);let i=0;this._nodes.forEach((e,t)=>{r[i++]=serializeNode(t,e)});const n=new Array(this._edges.size);return i=0,this._edges.forEach((e,t)=>{n[i++]=serializeEdge(t,e)}),{options:{type:this.type,multi:this.multi,allowSelfLoops:this.allowSelfLoops},attributes:this.getAttributes(),nodes:r,edges:n}}import(e,d=!1){if(isGraph(e))return e.forEachNode((e,t)=>{d?this.mergeNode(e,t):this.addNode(e,t)}),e.forEachEdge((e,t,r,i,n,o,a)=>{d?a?this.mergeUndirectedEdgeWithKey(e,r,i,t):this.mergeDirectedEdgeWithKey(e,r,i,t):a?this.addUndirectedEdgeWithKey(e,r,i,t):this.addDirectedEdgeWithKey(e,r,i,t)}),this;if(!isPlainObject(e))throw new InvalidArgumentsGraphError("Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.");if(e.attributes){if(!isPlainObject(e.attributes))throw new InvalidArgumentsGraphError("Graph.import: invalid attributes. Expecting a plain object.");d?this.mergeAttributes(e.attributes):this.replaceAttributes(e.attributes)}let t,r,i,n,o;if(e.nodes){if(i=e.nodes,!Array.isArray(i))throw new InvalidArgumentsGraphError("Graph.import: invalid nodes. Expecting an array.");for(t=0,r=i.length;t<r;t++){validateSerializedNode(n=i[t]);var{key:a,attributes:h}=n;d?this.mergeNode(a,h):this.addNode(a,h)}}if(e.edges){if(i=e.edges,!Array.isArray(i))throw new InvalidArgumentsGraphError("Graph.import: invalid edges. Expecting an array.");for(t=0,r=i.length;t<r;t++){validateSerializedEdge(o=i[t]);var{source:s,target:u,attributes:c,undirected:p=!1}=o;let e;"key"in o?(e=d?p?this.mergeUndirectedEdgeWithKey:this.mergeDirectedEdgeWithKey:p?this.addUndirectedEdgeWithKey:this.addDirectedEdgeWithKey,e.call(this,o.key,s,u,c)):(e=d?p?this.mergeUndirectedEdge:this.mergeDirectedEdge:p?this.addUndirectedEdge:this.addDirectedEdge,e.call(this,s,u,c))}}return this}nullCopy(e){const t=new Graph(assign({},this._options,e));return t.replaceAttributes(assign({},this.getAttributes())),t}emptyCopy(e){const i=this.nullCopy(e);return this._nodes.forEach((e,t)=>{var r=assign({},e.attributes);e=new i.NodeDataClass(t,r),i._nodes.set(t,e)}),i}copy(e){if("string"==typeof(e=e||{}).type&&e.type!==this.type&&"mixed"!==e.type)throw new UsageGraphError(`Graph.copy: cannot create an incompatible copy from "${this.type}" type to "${e.type}" because this would mean losing information about the current graph.`);if("boolean"==typeof e.multi&&e.multi!==this.multi&&!0!==e.multi)throw new UsageGraphError("Graph.copy: cannot create an incompatible copy by downgrading a multi graph to a simple one because this would mean losing information about the current graph.");if("boolean"==typeof e.allowSelfLoops&&e.allowSelfLoops!==this.allowSelfLoops&&!0!==e.allowSelfLoops)throw new UsageGraphError("Graph.copy: cannot create an incompatible copy from a graph allowing self loops to one that does not because this would mean losing information about the current graph.");var t,r=this.emptyCopy(e);const i=this._edges.values();for(;!0!==(t=i.next()).done;)addEdge(r,"copy",!1,(t=t.value).undirected,t.key,t.source.key,t.target.key,assign({},t.attributes));return r}toJSON(){return this.export()}toString(){return"[object Graph]"}inspect(){const r={};this._nodes.forEach((e,t)=>{r[t]=e.attributes});const d={},h={};this._edges.forEach((e,t)=>{var r,i=e.undirected?"--":"->";let n="",o=e.source.key,a=e.target.key;e.undirected&&o>a&&(r=o,o=a,a=r);i=`(${o})${i}(${a})`;t.startsWith("geid_")?this.multi&&(void 0===h[i]?h[i]=0:h[i]++,n+=`${h[i]}. `):n+=`[${t}]: `,n+=i,d[n]=e.attributes});const e={};for(const t in this)this.hasOwnProperty(t)&&!EMITTER_PROPS.has(t)&&"function"!=typeof this[t]&&"symbol"!=typeof t&&(e[t]=this[t]);return e.attributes=this._attributes,e.nodes=r,e.edges=d,privateProperty(e,"constructor",this.constructor),e}}"undefined"!=typeof Symbol&&(Graph.prototype[Symbol.for("nodejs.util.inspect.custom")]=Graph.prototype.inspect),EDGE_ADD_METHODS.forEach(d=>{["add","merge","update"].forEach(n=>{const o=d.name(n),a="add"===n?addEdge:mergeEdge;d.generateKey?Graph.prototype[o]=function(e,t,r){return a(this,o,!0,"undirected"===(d.type||this.type),null,e,t,r,"update"===n)}:Graph.prototype[o]=function(e,t,r,i){return a(this,o,!1,"undirected"===(d.type||this.type),e,t,r,i,"update"===n)}})}),attachNodeAttributesMethods(Graph),attachEdgeAttributesMethods(Graph),attachEdgeIterationMethods(Graph),attachNeighborIterationMethods(Graph);class DirectedGraph extends Graph{constructor(e){e=assign({type:"directed"},e);if("multi"in e&&!1!==e.multi)throw new InvalidArgumentsGraphError("DirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if("directed"!==e.type)throw new InvalidArgumentsGraphError('DirectedGraph.from: inconsistent "'+e.type+'" type in given options!');super(e)}}class UndirectedGraph extends Graph{constructor(e){e=assign({type:"undirected"},e);if("multi"in e&&!1!==e.multi)throw new InvalidArgumentsGraphError("UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if("undirected"!==e.type)throw new InvalidArgumentsGraphError('UndirectedGraph.from: inconsistent "'+e.type+'" type in given options!');super(e)}}class MultiGraph extends Graph{constructor(e){e=assign({multi:!0},e);if("multi"in e&&!0!==e.multi)throw new InvalidArgumentsGraphError("MultiGraph.from: inconsistent indication that the graph should be simple in given options!");super(e)}}class MultiDirectedGraph extends Graph{constructor(e){e=assign({type:"directed",multi:!0},e);if("multi"in e&&!0!==e.multi)throw new InvalidArgumentsGraphError("MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!");if("directed"!==e.type)throw new InvalidArgumentsGraphError('MultiDirectedGraph.from: inconsistent "'+e.type+'" type in given options!');super(e)}}class MultiUndirectedGraph extends Graph{constructor(e){e=assign({type:"undirected",multi:!0},e);if("multi"in e&&!0!==e.multi)throw new InvalidArgumentsGraphError("MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!");if("undirected"!==e.type)throw new InvalidArgumentsGraphError('MultiUndirectedGraph.from: inconsistent "'+e.type+'" type in given options!');super(e)}}function attachStaticFromMethod(i){i.from=function(e,t){t=assign({},e.options,t);const r=new i(t);return r.import(e),r}}attachStaticFromMethod(Graph),attachStaticFromMethod(DirectedGraph),attachStaticFromMethod(UndirectedGraph),attachStaticFromMethod(MultiGraph),attachStaticFromMethod(MultiDirectedGraph),attachStaticFromMethod(MultiUndirectedGraph),Graph.Graph=Graph,Graph.DirectedGraph=DirectedGraph,Graph.UndirectedGraph=UndirectedGraph,Graph.MultiGraph=MultiGraph,Graph.MultiDirectedGraph=MultiDirectedGraph,Graph.MultiUndirectedGraph=MultiUndirectedGraph,Graph.InvalidArgumentsGraphError=InvalidArgumentsGraphError,Graph.NotFoundGraphError=NotFoundGraphError,Graph.UsageGraphError=UsageGraphError;export{DirectedGraph,Graph,InvalidArgumentsGraphError,MultiDirectedGraph,MultiGraph,MultiUndirectedGraph,NotFoundGraphError,UndirectedGraph,UsageGraphError,Graph as default};