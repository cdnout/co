const i=require("./icepick"),tap=require("tap");function test(e,t){tap.test(e,e=>{t(e),e.end()})}test("icepick",e=>{"use strict";test("freeze",e=>{test("should work",e=>{const t=i.freeze({asdf:"foo",zxcv:{asdf:"bar"}});e.equal(t.asdf,"foo"),e.equal(Object.isFrozen(t),!0),e.throws(function(){t.asdf="bar"}),e.throws(function(){t.zxcv.asdf="qux"}),e.throws(function(){t.qwer="bar"})}),test("should not work with cyclical objects",e=>{let t={};t.a=t,e.throws(()=>i.freeze(t)),(t={b:{}}).b.a=t,e.throws(()=>i.freeze(t))})}),test("thaw",e=>{test("should thaw objects",e=>{const t=i.freeze({a:{},b:1,c:new function(){},d:[{e:1}]}),s=i.thaw(t);e.same(s,t),e.equal(Object.isFrozen(s),!1),e.equal(Object.isFrozen(s.a),!1),e.notEqual(t.a,s.a),e.notEqual(t.d,s.d),e.notEqual(t.d[0],s.d[0]),e.equal(t.c,s.c)})}),test("assoc",e=>{test("should work with objects",e=>{const t=i.freeze({a:1,b:2,c:3});let s=i.assoc(t,"b",4);e.same(s,{a:1,b:4,c:3}),s=i.assoc(t,"d",4),e.same(s,{a:1,b:2,c:3,d:4})}),test("should freeze objects you assoc",e=>{const t=i.freeze({a:1,b:2,c:3}),s=i.assoc(t,"b",{d:5});e.same(s,{a:1,b:{d:5},c:3}),e.ok(Object.isFrozen(s.b))}),test("should work with arrays",e=>{const t=i.freeze([1,2,3]);let s=i.assoc(t,1,4);e.same(s,[1,4,3]),s=i.assoc(t,"1",4),e.same(s,[1,4,3]),s=i.assoc(t,3,4),e.same(s,[1,2,3,4])}),test("should freeze arrays you assoc",e=>{const t=i.freeze({a:1,b:2,c:3}),s=i.assoc(t,"b",[1,2]);e.same(s,{a:1,b:[1,2],c:3}),e.ok(Object.isFrozen(s.b))}),test("should return a frozen copy",e=>{const t=i.freeze({a:1,b:2,c:3}),s=i.assoc(t,"b",4);e.notEqual(s,t),e.ok(Object.isFrozen(s))}),test("should not modify child objects",e=>{const t=i.freeze({a:1,b:2,c:{a:4}}),s=i.assoc(t,"b",4);e.equal(s.c,t.c)}),test("should keep references the same if nothing changes",e=>{const t=i.freeze({a:1}),s=i.assoc(t,"a",1);e.equal(s,t)}),test("should work with Object.create(null)",e=>{const t=Object.create(null);t.b=2;const s=i.assoc(t,"a",1);e.same(s,{a:1,b:2}),e.equal(s.constructor,void 0),e.equal(Object.getPrototypeOf(s),null)}),test("should be aliased as set",e=>{e.equal(i.set,i.assoc)})}),test("dissoc",e=>{test("should work with objecs",e=>{const t=i.freeze({a:1,b:2,c:3}),s=i.dissoc(t,"b");e.same(s,{a:1,c:3})}),test("should work with arrays (poorly)",e=>{const t=i.freeze([1,2,3]),s=i.dissoc(t,1);e.same(Object.keys(s),[0,2]),e.equal(s[0],1),e.equal(s[1],void 0),e.equal(s[2],3)}),test("should be aliased as unset",e=>{e.equal(i.unset,i.dissoc)})}),test("assocIn",e=>{test("should work recursively",e=>{const t=i.freeze({a:1,b:2,c:{a:4}}),s=i.assocIn(t,["c","a"],5);e.same(s,{a:1,b:2,c:{a:5}})}),test("should work recursively (deeper)",e=>{const t=i.freeze({a:1,b:{a:2},c:[{a:3,b:4},{a:4}]}),s=i.assocIn(t,["c",0,"a"],8);e.equal(s.c[0].a,8),e.notEqual(s,t),e.equal(s.b,t.b),e.notEqual(s.c,t.c),e.notEqual(s.c[0],t.c[0]),e.equal(s.c[0].b,t.c[0].b),e.equal(s.c[1],t.c[1])}),test("should create collections if they don't exist",e=>{const t=i.assocIn({},["a","b","c"],1);e.same(t,{a:{b:{c:1}}})}),test("should be aliased as setIn",e=>{e.equal(i.setIn,i.assocIn)}),test("should keep references the same if nothing changes",e=>{const t=i.freeze({a:{b:1}}),s=i.assocIn(t,["a","b"],1);e.equal(s,t)})}),test("dissocIn",e=>{test("should work recursively",e=>{const t=i.freeze({a:1,b:2,c:{a:4}}),s=i.dissocIn(t,["c","a"]);e.same(s,{a:1,b:2,c:{}})}),test("should work recursively (deeper)",e=>{const t=i.freeze({a:1,b:{a:2},c:[{a:3,b:4},{a:4}]}),s=i.dissocIn(t,["c",0,"a"]);e.equal(s.c[0].a,void 0),e.notEqual(s,t),e.equal(s.b,t.b),e.notEqual(s.c,t.c),e.notEqual(s.c[0],t.c[0]),e.equal(s.c[0].b,t.c[0].b),e.equal(s.c[1],t.c[1])}),test("should not create collections if they don't exist",e=>{const t=i.dissocIn({},["a","b","c"]);e.same(t,{})}),test("should be aliased as unsetIn",e=>{e.equal(i.unsetIn,i.dissocIn)}),test("should keep references the same if nothing changes",e=>{const t=i.freeze({a:{b:1}}),s=i.dissocIn(t,["a","b","c"]);e.equal(s,t)})}),test("getIn",e=>{test("should work",e=>{const t=i.freeze({a:0,b:{a:2},c:[{a:3,b:4},{a:4}]});e.equal(i.getIn(t,["c",0,"b"]),4),e.equal(i.getIn(t,["a"]),0)}),test("should work without a path",e=>{const t=i.freeze({a:{b:1}});e.equal(i.getIn(t),t)}),test("should return undefined for a non-existant path",e=>{const t=i.freeze({a:1,b:{a:2},c:[{a:3,b:4},{a:4}]});e.equal(i.getIn(t,["q"]),void 0),e.equal(i.getIn(t,["a","s","d"]),void 0)}),test("should return undefined for a non-existant path (null)",e=>{const t=i.freeze({a:null});e.equal(i.getIn(t,["a","b"]),void 0)})}),test("updateIn",e=>{test("should work",e=>{const t=i.freeze({a:1,b:2,c:{a:4}}),s=i.updateIn(t,["c","a"],function(e){return 2*e});e.same(s,{a:1,b:2,c:{a:8}})}),test("should create collections if they don't exist",e=>{const t=i.updateIn({},["a",1,"c"],function(t){return e.equal(t,void 0),1});e.same(t,{a:{1:{c:1}}})}),test("should keep references the same if nothing changes",e=>{const t=i.freeze({a:1}),s=i.updateIn(t,["a","b"],function(e){return e});e.equal(s,t)})}),test("Array methods",e=>{test("push",e=>{const t=i.freeze([1,2]),s=i.push(t,3);e.same(s,[1,2,3]),e.ok(Object.isFrozen(s))}),test("push (with object)",e=>{const t=i.freeze([1,2]),s=i.push(t,{b:1});e.same(s,[1,2,{b:1}]),e.ok(Object.isFrozen(s)),e.ok(Object.isFrozen(s[2]))}),test("unshift",e=>{const t=i.freeze([1,2]),s=i.unshift(t,3);e.same(s,[3,1,2]),e.ok(Object.isFrozen(s))}),test("unshift (with object)",e=>{const t=i.freeze([1,2]),s=i.unshift(t,[0]);e.same(s,[[0],1,2]),e.ok(Object.isFrozen(s)),e.ok(Object.isFrozen(s[0]))}),test("pop",e=>{const t=i.freeze([1,2]),s=i.pop(t);e.same(s,[1]),e.ok(Object.isFrozen(s))}),test("shift",e=>{const t=i.freeze([1,2]),s=i.shift(t);e.same(s,[2]),e.ok(Object.isFrozen(s))}),test("reverse",e=>{const t=i.freeze([1,2,3]),s=i.reverse(t);e.same(s,[3,2,1]),e.ok(Object.isFrozen(s))}),test("sort",e=>{const t=i.freeze([4,1,2,3]),s=i.sort(t);e.same(s,[1,2,3,4]),e.ok(Object.isFrozen(s))}),test("splice",e=>{const t=i.freeze([1,2,3]),s=i.splice(t,1,1,4);e.same(s,[1,4,3]),e.ok(Object.isFrozen(s))}),test("splice (with object)",e=>{const t=i.freeze([1,2,3]),s=i.splice(t,1,1,{b:1},{b:2});e.same(s,[1,{b:1},{b:2},3]),e.ok(Object.isFrozen(s)),e.ok(Object.isFrozen(s[1])),e.ok(Object.isFrozen(s[2]))}),test("slice",e=>{const t=i.freeze([1,2,3]),s=i.slice(t,1,2);e.same(s,[2]),e.ok(Object.isFrozen(s))}),test("map",e=>{const t=i.freeze([1,2,3]),s=i.map(function(e){return 2*e},t);e.same(s,[2,4,6]),e.ok(Object.isFrozen(s))}),test("filter",e=>{const t=i.freeze([1,2,3]),s=i.filter(function(e){return e%2},t);e.same(s,[1,3]),e.ok(Object.isFrozen(s))})}),test("assign",e=>{test("should work",e=>{const t=i.freeze({a:1,b:2,c:3});let s=i.assign(t,{b:3,c:4});e.same(s,{a:1,b:3,c:4}),e.notEqual(s,t),s=i.assign(t,{d:4}),e.same(s,{a:1,b:2,c:3,d:4})}),test("should work with multiple args",e=>{const t=i.freeze({a:1,b:2,c:3}),s=i.assign(t,{b:3,c:4},{d:4});e.same(s,{a:1,b:3,c:4,d:4})}),test("should keep references the same if nothing changes",e=>{const t=i.freeze({a:1}),s=i.assign(t,{a:1});e.equal(s,t)})}),test("merge",e=>{test("should merge nested objects",e=>{const t=i.freeze({a:1,b:{c:1,d:1}}),s=i.freeze({a:1,b:{c:2},e:2}),a=i.merge(t,s);e.same(a,{a:1,b:{c:2,d:1},e:2})}),test("should replace arrays",e=>{const t=i.freeze({a:1,b:{c:[1,1]},d:1}),s=i.freeze({a:2,b:{c:[2]}}),a=i.merge(t,s);e.same(a,{a:2,b:{c:[2]},d:1})}),test("should overwrite with nulls",e=>{const t=i.freeze({a:1,b:{c:[1,1]}}),s=i.freeze({a:2,b:{c:null}}),a=i.merge(t,s);e.same(a,{a:2,b:{c:null}})}),test("should overwrite primitives with objects",e=>{const t=i.freeze({a:1,b:1}),s=i.freeze({a:2,b:{c:2}}),a=i.merge(t,s);e.same(a,{a:2,b:{c:2}})}),test("should overwrite objects with primitives",e=>{const t=i.freeze({a:1,b:{c:2}}),s=i.freeze({a:1,b:2}),a=i.merge(t,s);e.same(a,{a:1,b:2})}),test("should keep references the same if nothing changes",e=>{const t=i.freeze({a:1,b:{c:1,d:1,e:[1]}}),s=i.freeze({a:1,b:{c:1,d:1,e:t.b.e}}),a=i.merge(t,s);e.equal(a,t),e.equal(a.b,t.b)}),test("should handle undefined parameters",e=>{e.same(i.merge({},void 0),{}),e.same(i.merge(void 0,{}),void 0)}),test("custom associator",e=>{test("should use the custom associator",e=>{const t=i.freeze({a:1,b:{c:[1,1]},d:1}),s=i.freeze({a:2,b:{c:[2]}});const a=i.merge(t,s,function(e,t){return Array.isArray(e)&&t?e.concat(t):t});e.same(a,{a:2,b:{c:[1,1,2]},d:1})})})})}),test("chain",e=>{test("should wrap and unwrap a value",e=>{const t=[1,2,3],s=i.chain(t).value();e.same(s,t)}),test("should work with a simple operation",e=>{const t=[1,2,3],s=i.chain(t).assoc(1,4).value();e.same(s,[1,4,3]),e.notEqual(s,t),e.ok(Object.isFrozen(s))}),test("should work with multiple operations",e=>{const t=[1,2,3],s=i.chain(t).assoc(1,4).reverse().pop().push(5).value();e.same(s,[3,4,5]),e.notEqual(s,t),e.ok(Object.isFrozen(s))}),test("should work with multiple operations (more complicated)",e=>{const t={a:[1,2,3],b:{c:1},d:4},s=i.chain(t).assocIn(["a",2],4).merge({b:{c:2,c2:3}}).assoc("e",2).dissoc("d").value();e.same(s,{a:[1,2,4],b:{c:2,c2:3},e:2}),e.notEqual(s,t),e.ok(Object.isFrozen(s))}),test("should have a thru method",e=>{const t=i.chain([1,2]).push(3).thru(function(e){return[0].concat(e)}).value();e.ok(Object.isFrozen(t)),e.same(t,[0,1,2,3])}),test("should work with map and filter",e=>{const t=i.chain([1,2,3]).map(e=>2*e).filter(e=>e>2).value();e.ok(Object.isFrozen(t)),e.same(t,[4,6])})}),test("production mode",e=>{let t;t=process.env.NODE_ENV,process.env.NODE_ENV="production",delete require.cache[require.resolve("./icepick")];const s=require("./icepick");e.tearDown(function(){process.env.NODE_ENV=t}),test("should not freeze objects",e=>{const t=s.freeze({});e.equal(Object.isFrozen(t),!1)}),test("should not freeze objects that are assoc'd",e=>{const t=s.assoc({},"a",{});e.equal(Object.isFrozen(t),!1),e.equal(Object.isFrozen(t.a),!1)}),test("merge should keep references the same if nothing changes",e=>{const t=s.freeze({a:1,b:{c:1,d:1,e:[1]}}),a=s.freeze({a:1,b:{c:1,d:1,e:t.b.e}}),o=s.merge(t,a);e.equal(o,t),e.equal(o.b,t.b)})}),test("internals",e=>{test("_weCareAbout",e=>{function t(){}test("should care about objects",e=>{e.equal(i._weCareAbout({}),!0)}),test("should care about arrays",e=>{e.equal(i._weCareAbout([]),!0)}),test("should not care about dates",e=>{e.equal(i._weCareAbout(new Date),!1)}),test("should not care about null",e=>{e.equal(i._weCareAbout(null),!1)}),test("should not care about undefined",e=>{e.equal(i._weCareAbout(void 0),!1)}),test("should not care about class instances",e=>{e.equal(i._weCareAbout(new t),!1)}),test("should not care about class instances (2)",e=>{e.equal(i._weCareAbout(new class{}),!1)}),test("should not care about objects created with Object.create()",e=>{e.equal(i._weCareAbout(Object.create(t.prototype)),!1)}),test("should not care about objects created with Object.create({})",e=>{e.equal(i._weCareAbout(Object.create({foo:function(){}})),!1)}),test("should care about objects with null prototypes",e=>{e.equal(i._weCareAbout(Object.create(null)),!0)})})});