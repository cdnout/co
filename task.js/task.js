var Task=function(t){var e={};function r(s){if(e[s])return e[s].exports;var i=e[s]={i:s,l:!1,exports:{}};return t[s].call(i.exports,i,i.exports,r),i.l=!0,i.exports}return r.m=t,r.c=e,r.d=function(t,e,s){r.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:s})},r.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},r.t=function(t,e){if(1&e&&(t=r(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var s=Object.create(null);if(r.r(s),Object.defineProperty(s,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var i in t)r.d(s,i,function(e){return t[e]}.bind(null,i));return s},r.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return r.d(e,"a",e),e},r.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},r.p="",r(r.s=1)}([function(t,e){t.exports=function(t){var e,r=t.toString();r=r.substring(r.indexOf("{")+1,r.lastIndexOf("}"));try{e=new Blob([r],{type:"text/javascript"})}catch(t){window.BlobBuilder=window.BlobBuilder||window.WebKitBlobBuilder||window.MozBlobBuilder,(e=new BlobBuilder).append(r),e=e.getBlob()}return(window.URL||window.webkitURL).createObjectURL(e)}},function(t,e,r){const s=r(2),i=r(3);r(4);let n;s()&&(n={DefaultWorkerProxy:r(5)}),t.exports=class extends i{constructor(t={}){if(!n)throw new Error("The browser does not support Workers");let e={workerType:"web_worker"};Object.keys(t).forEach(r=>e[r]=t[r]),super(e,n)}}},function(t,e,r){const s=r(0);t.exports=function(){if("undefined"!=typeof Worker&&(window.URL||window.webkitURL))try{return new Worker(s((function(){}))).terminate(),!0}catch(t){}return!1}},function(t,e,r){function s(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}class i{constructor(t){this.transferables=t.map(t=>{if(!(t instanceof ArrayBuffer)&&t&&t.buffer instanceof ArrayBuffer)return t.buffer;if(t instanceof ArrayBuffer)return t;throw new Error("Task.js: invalid transferable argument (ensure its a buffer backed array, or a buffer)")})}toArray(){return this.transferables}}class n{constructor(t,e){if(s(this,"_next",()=>{if(this._terminated)return;if(this._taskTimeout&&this._reissueTasksInTimedoutWorkers(),!this._queue.length)return;let t=this._getWorker();if(!t)return void setTimeout(this._next,0);let e=this._queue.shift();this._debug&&this._log({action:"send_task_to_worker",taskId:e.id,workerId:t.id,message:`sending taskId(${e.id}) to workerId(${t.id})`}),t.run(e)}),s(this,"_onWorkerTaskComplete",()=>{this._next()}),s(this,"_onWorkerExit",t=>{this._debug&&this._log({action:"worker_died",workerId:t.id,message:"worker died, reissuing tasks"}),this._workers=this._workers.filter(e=>e!=t),t.tasks.forEach(t=>{this._queue.push(t.$options)}),this._next()}),t=t||{},this.id=++n.managerCount,this._workerType=t.workerType,"worker_threads"===this._workerType){try{r(!function(){var t=new Error("Cannot find module 'worker_threads'");throw t.code="MODULE_NOT_FOUND",t}())}catch(t){throw new Error("Your current version, or configuration of Node.js does not support worker_threads.")}this._WorkerProxy=e.NodeWorkerThread}else"simulated_worker"===this._workerType?this._WorkerProxy=e.SimulatedWorker:this._WorkerProxy=e.DefaultWorkerProxy;this._logger=t.logger||console.log,this._requires=t.requires,this._workerTaskConcurrency=(t.workerTaskConcurrency||1)-1,this._maxWorkers=t.maxWorkers||1,this._idleTimeout=!1!==t.idleTimeout&&t.idleTimeout,this._taskTimeout=t.taskTimeout||0,this._idleCheckInterval=1e3,this._warmStart=t.warmStart||!1,this._warmStartCompleted=!1,this._globals=t.globals,this._env=t.env,this._globalsInitializationFunction=t.initialize,this._debug=t.debug,this._terminated=!1,this._debug&&this._log({action:"create_new_pool",message:`creating new pool : ${JSON.stringify(t)}`,config:t}),this._workers=[],this._workersInitializing=[],this._queue=[],this._onWorkerTaskComplete=this._onWorkerTaskComplete.bind(this),this._flushIdleWorkers=this._flushIdleWorkers.bind(this),this._totalWorkersCreated=0,this._lastTaskTimeoutCheck=new Date,this._warmStart&&setTimeout(()=>{this._debug&&this._log({action:"warmstart",message:"warm starting workers"});for(let t=0;t<this._maxWorkers;t++)this._createWorker();this._warmStartCompleted=!0,this._debug&&this._log({action:"warmstart_completed",message:"started workers"})},0)}_log(t){let e={source:"manager",managerId:this.id};Object.keys(t).forEach(r=>{e[r]=t[r]}),e.message||(e.message=e.action),this._logger(e,this)}getActiveWorkerCount(){return this._workersInitializing.length+this._workers.length}_run(t){if(!this._terminated){if(this._idleTimeout&&"number"!=typeof this._idleCheckIntervalID&&(this._idleCheckIntervalID=setInterval(this._flushIdleWorkers,this._idleCheckInterval)),!t.arguments||void 0===t.arguments.length)throw new Error('task.js: "arguments" is required property, and it must be an array/array-like');if(!t.function&&("function"!=typeof t.function||"string"!=typeof t.function))throw new Error('task.js: "function" is required property, and it must be a string or a function');return"object"==typeof t.arguments&&(t.arguments=Array.prototype.slice.call(t.arguments)),t.id=++n.taskCount,this._debug&&this._log({action:"add_to_queue",taskId:t.id,message:`added taskId(${t.id}) to the queue`}),new Promise(function(e,r){t.resolve=e,t.reject=r,this._queue.push(t),this._next()}.bind(this))}}_runOnWorker(t,e,r){return new Promise((function(s,i){t.run({id:++n.taskCount,arguments:e,function:r,resolve:s,reject:i})}))}static transferables(...t){return new i(t)}run(t,...e){return this.wrap(t)(...e)}wrap(t){return function(){let e=Array.from(arguments),r=null,s=e.slice(-1)[0];return s instanceof i&&(r=s.toArray(),e=e.slice(0,-1)),this._run({arguments:e,transferables:r,function:t})}.bind(this)}terminate(){this._debug&&this._log({action:"terminated",message:"terminated"}),this._terminated=!0,this._idleTimeout&&"number"==typeof this._idleCheckIntervalID&&(clearInterval(this._idleCheckIntervalID),this._idleCheckIntervalID=null),this._workers.forEach((function(t){t.terminate()})),this._workers=[],this._queue=[]}_reissueTasksInTimedoutWorkers(){new Date-this._lastTaskTimeoutCheck<5e3||(this._lastTaskTimeoutCheck=new Date,this._workers.forEach(t=>{t.tasks.some(e=>{if(new Date-e.startTime>=this._taskTimeout)return t.forceExit(),!0})}))}_flushIdleWorkers(){this._debug&&this._log({action:"flush_idle_workers",message:"flushing idle workers"}),this._workers=this._workers.filter((function(t){return!(0===t.tasks.length&&new Date-t.lastTaskTimestamp>this._idleTimeout)||(t.terminate(),!1)}),this)}_getWorker(){let t=this._workers.filter(t=>t.tasks.length<=this._workerTaskConcurrency).sort((t,e)=>t.tasks.length-e.tasks.length);return t.length?t[0]:this._workers.length<this._maxWorkers&&0===this._workersInitializing.length&&(!this._warmStart||this._warmStartCompleted)?this._createWorker():null}_createWorker(){let t=++this._totalWorkersCreated,e=new this._WorkerProxy({debug:this._debug,logger:this._logger,env:this._env,id:t,managerId:this.id,onTaskComplete:this._onWorkerTaskComplete,onExit:this._onWorkerExit});if(this._globalsInitializationFunction||this._globals||this._requires){let t;this._debug&&this._log({action:"run_global_initialize",message:"running global initialization code"}),t="web_worker"===this._workerType?"\n\t\t\t\tif (Object.keys(requires).length) {\n\t\t\t\t\timportScripts(...Object.values(requires));\n\n\t\t\t\t\tObject.keys(requires).forEach(key => {\n\t\t\t\t\t\tif (typeof self[key] === 'undefined') {\n\t\t\t\t\t\t\tthrow new Error('Task.js: require failed importing ' + key + ' (\"' + requires[key] + '\")');\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t":"\n\t\t\t\tObject.keys(requires).forEach(key => {\n\t\t\t\t\tglobal[key] = require(requires[key]);\n\t\t\t\t});\n\t\t\t\t";let r=`function (_globals) {\n\t\t\t\tlet requires = ${JSON.stringify(this._requires||{})};\n\n\t\t\t\t${t}\n\n\t\t\t\tif (typeof _globals != 'undefined') {\n\t\t\t\t\tObject.keys(_globals).forEach(key => {\n\t\t\t\t\t\tglobal[key] = _globals[key];\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t(${(this._globalsInitializationFunction||(()=>{})).toString()})();\n\t\t\t}`.trim();return this._workersInitializing.push(e),this._runOnWorker(e,[this._globals||{}],r).then(function(){this._workersInitializing=this._workersInitializing.filter(t=>t!=e),this._workers.push(e)}.bind(this)),null}return this._workers.push(e),e}}s(n,"managerCount",0),s(n,"taskCount",0),t.exports=n},function(t,e){t.exports=function(t,e,r){return function(s,i){let n={};return Object.keys(t).forEach(e=>n[e]=t[e]),Object.keys(s).forEach(t=>n[t]=s[t]),new r(n,i||e)}}},function(t,e,r){function s(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}const i=r(0),n=r(6);t.exports=class extends n{constructor(t){super(...arguments),s(this,"WORKER_SOURCE","function () {\n\t\tlet global = new Proxy(\n\t\t  {},\n\t\t  {\n\t\t    set: (obj, prop, newval) => (self[prop] = newval)\n\t\t  }\n\t\t);\n\n\t\tonmessage = function (event) {\n\t\t\tvar message = event.data;\n\n\t\t\tvar args = Object.keys(message).filter(function (key) {\n\t\t\t\treturn key.match(/^argument/);\n\t\t\t}).sort(function (a, b) {\n\t\t\t\treturn parseInt(a.slice(8), 10) - parseInt(b.slice(8), 10);\n\t\t\t}).map(function (key) {\n\t\t\t\treturn message[key];\n\t\t\t});\n\n\t\t\ttry {\n\t\t\t\tvar result = eval('(' + message.func + ')').apply(null, args);\n\n\t\t\t\tif (result && result.then && result.catch && result.finally) {\n\t\t\t\t\tresult.then(result => {\n\t\t\t\t\t\tself.postMessage({id: message.id, result: result});\n\t\t\t\t\t}).catch(error => {\n\t\t\t\t\t\tself.postMessage({id: message.id, error: error.stack});\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tself.postMessage({id: message.id, result: result});\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tself.postMessage({id: message.id, error: error.stack});\n\t\t\t}\n\t\t}\n\t}"),s(this,"_onMessage",t=>{let e=t.data;this.handleWorkerMessage(e)}),s(this,"postMessage",(t,e)=>{this._debug&&this._log({taskId:t.id,action:"send_task_to_actual_worker",message:`sending taskId(${t.id}) to worker process`}),this._worker.postMessage(t,e)}),s(this,"terminate",()=>{this._debug&&this._log({message:"terminated"}),this._worker.terminate()}),this._worker=new Worker(i(this.WORKER_SOURCE)),this._worker.addEventListener("message",this._onMessage),this._debug&&this._log({action:"initialized"})}}},function(t,e){function r(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}t.exports=class{constructor(t){r(this,"handleWorkerExit",()=>{this._debug&&this._log({action:"killed"}),this._onExitHandler(this)}),r(this,"forceExit",()=>{this._onExit(),this._worker.kill()}),r(this,"handleWorkerMessage",t=>{let e=null;if(this.tasks.some((function(r,s){if(t.id===r.id)return e=s,!0})),null!==e){var r=this.tasks[e];t.error?(this._debug&&this._log({taskId:r.id,action:"task_error",message:`taskId(${r.id}) has thrown an error ${t.error}`}),r.reject(new Error(`task.js: ${t.error}`))):(this._debug&&this._log({taskId:r.id,action:"task_completed",message:`taskId(${r.id}) has completed`}),r.resolve(t.result)),this._onTaskComplete(this),this.tasks.splice(e,1)}}),this.id=t.id,this.managerId=t.managerId,this._debug=t.debug,this._logger=t.logger,this.tasks=[],this.lastTaskTimestamp=null,this._onTaskComplete=t.onTaskComplete,this._onExitHandler=t.onExit}_log(t){let e={source:"worker",managerId:this.managerId,workerId:this.id};Object.keys(t).forEach(r=>{e[r]=t[r]}),e.message||(e.message=e.action),this._logger(e)}run(t){this.lastTaskTimestamp=new Date;let e={id:t.id,startTime:new Date,resolve:t.resolve,reject:t.reject,$options:t};this.tasks.push(e);let r={id:e.id,func:String(t.function)};Object.keys(t.arguments).forEach((function(e,s){r["argument"+s]=t.arguments[s]})),this.postMessage(r,t.transferables)}_purgeTasks(t){this.tasks.forEach(e=>{e.reject(t)}),this.tasks=[]}}}]);
//# sourceMappingURL=task.js.map