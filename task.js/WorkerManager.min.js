function _defineProperty(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}class Transferables{constructor(t){this.transferables=t.map(t=>{if(!(t instanceof ArrayBuffer)&&t&&t.buffer instanceof ArrayBuffer)return t.buffer;if(t instanceof ArrayBuffer)return t;throw new Error("Task.js: invalid transferable argument (ensure its a buffer backed array, or a buffer)")})}toArray(){return this.transferables}}class WorkerManager{constructor(t,e){if(_defineProperty(this,"_next",()=>{if(this._terminated)return;if(this._taskTimeout&&this._reissueTasksInTimedoutWorkers(),!this._queue.length)return;let t=this._getWorker();if(!t)return void setTimeout(this._next,0);let e=this._queue.shift();this._debug&&this._log({action:"send_task_to_worker",taskId:e.id,workerId:t.id,message:`sending taskId(${e.id}) to workerId(${t.id})`}),t.run(e)}),_defineProperty(this,"_onWorkerTaskComplete",()=>{this._next()}),_defineProperty(this,"_onWorkerExit",t=>{this._debug&&this._log({action:"worker_died",workerId:t.id,message:"worker died, reissuing tasks"}),this._workers=this._workers.filter(e=>e!=t),t.tasks.forEach(t=>{this._queue.push(t.$options)}),this._next()}),t=t||{},this.id=++WorkerManager.managerCount,this._workerType=t.workerType,"worker_threads"===this._workerType){try{require("worker_threads")}catch(t){throw new Error("Your current version, or configuration of Node.js does not support worker_threads.")}this._WorkerProxy=e.NodeWorkerThread}else"simulated_worker"===this._workerType?this._WorkerProxy=e.SimulatedWorker:this._WorkerProxy=e.DefaultWorkerProxy;this._logger=t.logger||console.log,this._requires=t.requires,this._workerTaskConcurrency=(t.workerTaskConcurrency||1)-1,this._maxWorkers=t.maxWorkers||1,this._idleTimeout=!1!==t.idleTimeout&&t.idleTimeout,this._taskTimeout=t.taskTimeout||0,this._idleCheckInterval=1e3,this._warmStart=t.warmStart||!1,this._warmStartCompleted=!1,this._globals=t.globals,this._env=t.env,this._globalsInitializationFunction=t.initialize,this._debug=t.debug,this._terminated=!1,this._debug&&this._log({action:"create_new_pool",message:`creating new pool : ${JSON.stringify(t)}`,config:t}),this._workers=[],this._workersInitializing=[],this._queue=[],this._onWorkerTaskComplete=this._onWorkerTaskComplete.bind(this),this._flushIdleWorkers=this._flushIdleWorkers.bind(this),this._totalWorkersCreated=0,this._lastTaskTimeoutCheck=new Date,this._warmStart&&setTimeout(()=>{this._debug&&this._log({action:"warmstart",message:"warm starting workers"});for(let t=0;t<this._maxWorkers;t++)this._createWorker();this._warmStartCompleted=!0,this._debug&&this._log({action:"warmstart_completed",message:"started workers"})},0)}_log(t){let e={source:"manager",managerId:this.id};Object.keys(t).forEach(r=>{e[r]=t[r]}),e.message||(e.message=e.action),this._logger(e,this)}getActiveWorkerCount(){return this._workersInitializing.length+this._workers.length}_run(t){if(!this._terminated){if(this._idleTimeout&&"number"!=typeof this._idleCheckIntervalID&&(this._idleCheckIntervalID=setInterval(this._flushIdleWorkers,this._idleCheckInterval)),!t.arguments||void 0===t.arguments.length)throw new Error('task.js: "arguments" is required property, and it must be an array/array-like');if(!t.function&&("function"!=typeof t.function||"string"!=typeof t.function))throw new Error('task.js: "function" is required property, and it must be a string or a function');return"object"==typeof t.arguments&&(t.arguments=Array.prototype.slice.call(t.arguments)),t.id=++WorkerManager.taskCount,this._debug&&this._log({action:"add_to_queue",taskId:t.id,message:`added taskId(${t.id}) to the queue`}),new Promise(function(e,r){t.resolve=e,t.reject=r,this._queue.push(t),this._next()}.bind(this))}}_runOnWorker(t,e,r){return new Promise(function(i,s){t.run({id:++WorkerManager.taskCount,arguments:e,function:r,resolve:i,reject:s})})}static transferables(...t){return new Transferables(t)}run(t,...e){return this.wrap(t)(...e)}wrap(t){return function(){let e=Array.from(arguments),r=null,i=e.slice(-1)[0];return i instanceof Transferables&&(r=i.toArray(),e=e.slice(0,-1)),this._run({arguments:e,transferables:r,function:t})}.bind(this)}terminate(){this._debug&&this._log({action:"terminated",message:"terminated"}),this._terminated=!0,this._idleTimeout&&"number"==typeof this._idleCheckIntervalID&&(clearInterval(this._idleCheckIntervalID),this._idleCheckIntervalID=null),this._workers.forEach(function(t){t.terminate()}),this._workers=[],this._queue=[]}_reissueTasksInTimedoutWorkers(){new Date-this._lastTaskTimeoutCheck<5e3||(this._lastTaskTimeoutCheck=new Date,this._workers.forEach(t=>{t.tasks.some(e=>{if(new Date-e.startTime>=this._taskTimeout)return t.forceExit(),!0})}))}_flushIdleWorkers(){this._debug&&this._log({action:"flush_idle_workers",message:"flushing idle workers"}),this._workers=this._workers.filter(function(t){return!(0===t.tasks.length&&new Date-t.lastTaskTimestamp>this._idleTimeout)||(t.terminate(),!1)},this)}_getWorker(){let t=this._workers.filter(t=>t.tasks.length<=this._workerTaskConcurrency).sort((t,e)=>t.tasks.length-e.tasks.length);return t.length?t[0]:this._workers.length<this._maxWorkers&&0===this._workersInitializing.length&&(!this._warmStart||this._warmStartCompleted)?this._createWorker():null}_createWorker(){let t=++this._totalWorkersCreated,e=new this._WorkerProxy({debug:this._debug,logger:this._logger,env:this._env,id:t,managerId:this.id,onTaskComplete:this._onWorkerTaskComplete,onExit:this._onWorkerExit});if(this._globalsInitializationFunction||this._globals||this._requires){let t;this._debug&&this._log({action:"run_global_initialize",message:"running global initialization code"}),t="web_worker"===this._workerType?"\n\t\t\t\tif (Object.keys(requires).length) {\n\t\t\t\t\timportScripts(...Object.values(requires));\n\n\t\t\t\t\tObject.keys(requires).forEach(key => {\n\t\t\t\t\t\tif (typeof self[key] === 'undefined') {\n\t\t\t\t\t\t\tthrow new Error('Task.js: require failed importing ' + key + ' (\"' + requires[key] + '\")');\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t":"\n\t\t\t\tObject.keys(requires).forEach(key => {\n\t\t\t\t\tglobal[key] = require(requires[key]);\n\t\t\t\t});\n\t\t\t\t";let r=`function (_globals) {\n\t\t\t\tlet requires = ${JSON.stringify(this._requires||{})};\n\n\t\t\t\t${t}\n\n\t\t\t\tif (typeof _globals != 'undefined') {\n\t\t\t\t\tObject.keys(_globals).forEach(key => {\n\t\t\t\t\t\tglobal[key] = _globals[key];\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t(${(this._globalsInitializationFunction||(()=>{})).toString()})();\n\t\t\t}`.trim();return this._workersInitializing.push(e),this._runOnWorker(e,[this._globals||{}],r).then(function(){this._workersInitializing=this._workersInitializing.filter(t=>t!=e),this._workers.push(e)}.bind(this)),null}return this._workers.push(e),e}}_defineProperty(WorkerManager,"managerCount",0),_defineProperty(WorkerManager,"taskCount",0),module.exports=WorkerManager;