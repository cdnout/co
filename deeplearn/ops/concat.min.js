"use strict";var __decorate=this&&this.__decorate||function(e,t,n,r){var c,o=arguments.length,a=o<3?t:null===r?r=Object.getOwnPropertyDescriptor(t,n):r;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)a=Reflect.decorate(e,t,n,r);else for(var i=e.length-1;0<=i;i--)(c=e[i])&&(a=(o<3?c(a):3<o?c(t,n,a):c(t,n))||a);return 3<o&&a&&Object.defineProperty(t,n,a),a};Object.defineProperty(exports,"__esModule",{value:!0});var doc_1=require("../doc"),environment_1=require("../environment"),util=require("../util"),axis_util_1=require("./axis_util"),concat_util=require("./concat_util"),operation_1=require("./operation"),ConcatOps=function(){function n(){}return n.concat1d=function(e){return n.concat(e,0)},n.concat2d=function(e,t){return n.concat(e,t)},n.concat3d=function(e,t){return n.concat(e,t)},n.concat4d=function(e,t){return n.concat(e,t)},n.concat=function(e,t){void 0===t&&(t=0),util.assert(2<=e.length,"Pass at least two tensors to concat");for(var n=e[0],r=axis_util_1.parseAxisParam(t,n.shape),c=1;c<e.length;++c)n=concat2Tensors(n,e[c],r[0]);return n},__decorate([doc_1.doc({heading:"Tensors",subheading:"Slicing and Joining"}),operation_1.operation],n,"concat",null),n}();function concat2Tensors(e,t,n){concat_util.assertParams(e.shape,t.shape,n);var r=concat_util.computeOutShape(e.shape,t.shape,n),c=e.as2D(-1,util.sizeFromShape(e.shape.slice(n))),o=t.as2D(-1,util.sizeFromShape(t.shape.slice(n))),a=concat_util.computeGradientSliceShapes(c.shape,o.shape),i=a.aBegin,u=a.aSize,s=a.bBegin,l=a.bSize;return environment_1.ENV.engine.runKernel(function(e){return e.concat(c,o)},{a:c,b:o},function(e){return{a:function(){return e.slice(i,u)},b:function(){return e.slice(s,l)}}}).reshape(r)}exports.ConcatOps=ConcatOps;