"use strict";var __decorate=this&&this.__decorate||function(t,r,e,n){var a,o=arguments.length,i=o<3?r:null===n?n=Object.getOwnPropertyDescriptor(r,e):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,r,e,n);else for(var s=t.length-1;0<=s;s--)(a=t[s])&&(i=(o<3?a(i):3<o?a(r,e,i):a(r,e))||i);return 3<o&&i&&Object.defineProperty(r,e,i),i};Object.defineProperty(exports,"__esModule",{value:!0});var MatrixOrientation,doc_1=require("../doc"),environment_1=require("../environment"),util=require("../util"),operation_1=require("./operation");!function(t){t[t.REGULAR=0]="REGULAR",t[t.TRANSPOSED=1]="TRANSPOSED"}(MatrixOrientation=exports.MatrixOrientation||(exports.MatrixOrientation={}));var MatmulOps=function(){function t(){}return t.matMul=function(r,e,n,a){void 0===n&&(n=!1),void 0===a&&(a=!1),i=[enumToBool(n),enumToBool(a)],a=i[1];var t=(n=i[0])?r.shape[0]:r.shape[1],o=a?e.shape[1]:e.shape[0];util.assert(2===r.rank&&2===e.rank,"Error in matMul: inputs must be rank 2, got ranks "+r.rank+" and "+e.rank+"."),util.assert(t===o,"Error in matMul: inner shapes ("+t+") and ("+o+") of Tensors with shapes "+r.shape+" and "+e.shape+" and transposeA="+n+" and transposeB="+a+" must match.");var i;return environment_1.ENV.engine.runKernel(function(t){return t.matMul(r,e,n,a)},{a:r,b:e},function(t){if(n||a)throw new Error("Backprop for transposed MatMul not yet implemented.");return{a:function(){return t.matMul(e.toFloat(),!1,!0)},b:function(){return r.toFloat().matMul(t,!0,!1)}}})},t.vectorTimesMatrix=function(t,r){return util.assert(1===t.rank,"Error in vectorTimesMatrix: first input must be rank 1, but got rank "+t.rank+"."),util.assert(2===r.rank,"Error in vectorTimesMatrix: second input must be rank 2, but got rank "+r.rank+"."),util.assert(t.size===r.shape[0],"Error in vectorTimesMatrix: size of vector ("+t.size+") must match first dimension of matrix ("+r.shape[0]+")"),t.as2D(1,-1).matMul(r).as1D()},t.matrixTimesVector=function(t,r){return util.assert(1===r.rank,"Error in matrixTimesVector: second input must rank 1, but got rank "+r.rank+"."),util.assert(2===t.rank,"Error in matrixTimesVector: first input must be a rank 2, but got rank "+t.rank+"."),util.assert(r.size===t.shape[1],"Error in matrixTimesVector: size of first rank 1 input "+r.size+" must match inner dimension of second rank 2 input, but got shape "+t.shape+"."),t.matMul(r.as2D(-1,1)).as1D()},t.dotProduct=function(t,r){return util.assert(1===t.rank&&1===r.rank,"Error in dotProduct: inputs must be rank 1, but got ranks "+t.rank+" and "+r.rank+"."),util.assert(t.size===r.size,"Error in dotProduct: size of inputs ("+t.size+") and ("+r.size+") must match."),t.as2D(1,-1).matMul(r.as2D(-1,1)).asScalar()},t.outerProduct=function(t,r){return util.assert(1===t.rank&&1===r.rank,"Error in outerProduct: inputs must be rank 1, but got ranks "+t.rank+" and "+r.rank+"."),t.as2D(-1,1).matMul(r.as2D(1,-1))},__decorate([doc_1.doc({heading:"Operations",subheading:"Matrices"}),operation_1.operation],t,"matMul",null),__decorate([operation_1.operation],t,"vectorTimesMatrix",null),__decorate([operation_1.operation],t,"matrixTimesVector",null),__decorate([operation_1.operation],t,"dotProduct",null),__decorate([doc_1.doc({heading:"Operations",subheading:"Matrices"}),operation_1.operation],t,"outerProduct",null),t}();function enumToBool(t){return t!==MatrixOrientation.REGULAR&&(t===MatrixOrientation.TRANSPOSED||t)}exports.MatmulOps=MatmulOps;