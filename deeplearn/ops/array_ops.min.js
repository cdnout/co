"use strict";var __decorate=this&&this.__decorate||function(e,n,r,o){var t,a=arguments.length,i=a<3?n:null===o?o=Object.getOwnPropertyDescriptor(n,r):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(e,n,r,o);else for(var s=e.length-1;0<=s;s--)(t=e[s])&&(i=(a<3?t(i):3<a?t(n,r,i):t(n,r))||i);return 3<a&&i&&Object.defineProperty(n,r,i),i};Object.defineProperty(exports,"__esModule",{value:!0});var doc_1=require("../doc"),environment_1=require("../environment"),tensor_1=require("../tensor"),tensor_util=require("../tensor_util"),util=require("../util"),axis_util_1=require("./axis_util"),concat_1=require("./concat"),operation_1=require("./operation"),rand_1=require("./rand"),ArrayOps=function(){function d(){}return d.tensor=function(e,n,r){void 0===r&&(r="float32");var o=util.inferShape(e);return null!=n&&1!==o.length&&util.assertShapesMatch(n,o,"Error creating a new Tensor. Inferred shape ("+o+") does not match the provided shape ("+n+"). "),util.isTypedArray(e)||Array.isArray(e)||(e=[e]),n=n||o,tensor_1.Tensor.make(n,{values:toTypedArray(e,r)},r)},d.scalar=function(e,n){if(void 0===n&&(n="float32"),util.isTypedArray(e)||Array.isArray(e))throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean)");return d.tensor(e,[],n)},d.tensor1d=function(e,n){void 0===n&&(n="float32");var r=util.inferShape(e);if(1!==r.length)throw new Error("Error creating a new Tensor1D: values must be a flat/TypedArray");return d.tensor(e,r,n)},d.tensor2d=function(e,n,r){void 0===r&&(r="float32");var o=util.inferShape(e);if(2!==o.length&&1!==o.length)throw new Error("Error creating a new Tensor2D: values must be number[][] or flat/TypedArray");return d.tensor(e,n=n||o,r)},d.tensor3d=function(e,n,r){void 0===r&&(r="float32");var o=util.inferShape(e);if(3!==o.length&&1!==o.length)throw new Error("Error creating a new Tensor3D: values must be number[][][]or flat/TypedArray");return d.tensor(e,n=n||o,r)},d.tensor4d=function(e,n,r){void 0===r&&(r="float32");var o=util.inferShape(e);if(4!==o.length&&1!==o.length)throw new Error("Error creating a new Tensor4D: values must be number[][][][]or flat/TypedArray");return d.tensor(e,n=n||o,r)},d.ones=function(e,n){void 0===n&&(n="float32");var r=makeOnesTypedArray(util.sizeFromShape(e),n);return tensor_1.Tensor.make(e,{values:r},n)},d.zeros=function(e,n){void 0===n&&(n="float32");var r=makeZerosTypedArray(util.sizeFromShape(e),n);return tensor_1.Tensor.make(e,{values:r},n)},d.fill=function(e,n,r){void 0===r&&(r="float32");var o=util.getTypedArrayFromDType(r,util.sizeFromShape(e));return o.fill(n),tensor_1.Tensor.make(e,{values:o},r)},d.onesLike=function(e){return d.ones(e.shape,e.dtype)},d.zerosLike=function(e){return d.zeros(e.shape,e.dtype)},d.clone=function(e){return tensor_1.Tensor.make(e.shape,{dataId:e.dataId},e.dtype)},d.randomNormal=function(e,n,r,o,t){if(void 0===n&&(n=0),void 0===r&&(r=1),null!=o&&"bool"===o)throw new Error("Unsupported data type "+o);var a=new rand_1.MPRandGauss(n,r,o,!1,t);return tensor_1.Tensor.rand(e,function(){return a.nextValue()},o)},d.truncatedNormal=function(e,n,r,o,t){if(void 0===n&&(n=0),void 0===r&&(r=1),null!=o&&"bool"===o)throw new Error("Unsupported data type "+o);var a=new rand_1.MPRandGauss(n,r,o,!0,t);return tensor_1.Tensor.rand(e,function(){return a.nextValue()},o)},d.randomUniform=function(e,n,r,o){return void 0===n&&(n=0),void 0===r&&(r=1),void 0===o&&(o="float32"),tensor_1.Tensor.rand(e,function(){return util.randUniform(n,r)},o)},d.rand=function(e,n,r){var o=util.sizeFromShape(e),t=null;if(null==r||"float32"===r)t=new Float32Array(o);else if("int32"===r)t=new Int32Array(o);else{if("bool"!==r)throw new Error("Unknown data type "+r);t=new Uint8Array(o)}for(var a=0;a<o;a++)t[a]=n();return tensor_1.Tensor.make(e,{values:t},r)},d.multinomial=function(e,n,r){var o=e.size,t=e.rank;if(o<2)throw new Error("Error in multinomial: you need at least 2 outcomes, but got "+o+".");if(2<t)throw new Error("Rank of probabilities must be 1 or 2, but is "+t);r=r||Math.random();var a=1===t?e.as2D(1,-1):e,i=environment_1.ENV.engine.runKernel(function(e){return e.multinomial(a,n,r)},{prob2D:a});return 1===t?i.as1D():i},d.oneHot=function(n,r,o,t){if(void 0===o&&(o=1),void 0===t&&(t=0),r<2)throw new Error("Error in oneHot: depth must be >=2, but it is "+r);return environment_1.ENV.engine.runKernel(function(e){return e.oneHot(n,r,o,t)},{indices:n})},d.fromPixels=function(e,n){if(void 0===n&&(n=3),4<n)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");return environment_1.ENV.engine.fromPixels(e,n)},d.reshape=function(n,r){r=util.inferFromImplicitShape(r,n.size),util.assert(n.size===util.sizeFromShape(r),"new shape and old shape must have the same number of elements.");return environment_1.ENV.engine.runKernel(function(e){return tensor_1.Tensor.make(r,{dataId:n.dataId},n.dtype)},{x:n},function(e){return{x:function(){return e.reshape(n.shape)}}})},d.squeeze=function(e,n){return d.reshape(e,util.squeezeShape(e.shape,n).newShape)},d.cast=function(n,r){return environment_1.ENV.engine.runKernel(function(e){if(!util.hasEncodingLoss(n.dtype,r))return tensor_1.Tensor.make(n.shape,{dataId:n.dataId},r);if("int32"===r)return e.int(n);if("bool"===r)return e.notEqual(n,d.scalar(0,n.dtype));throw new Error("Error in Cast: unknown dtype argument ("+r+")")},{x:n},function(e){return{x:function(){return e.clone()}}})},d.tile=function(i,s){util.assert(i.rank===s.length,"Error in transpose: rank of input "+i.rank+" must match length of reps "+s+".");return environment_1.ENV.engine.runKernel(function(e){return e.tile(i,s)},{x:i},function(a){return{x:function(){var e=d.zerosLike(i);if(1===i.rank)for(var n=0;n<s[0];++n)e=e.add(a.slice([n*i.shape[0]],[i.shape[0]]));else if(2===i.rank)for(n=0;n<s[0];++n)for(var r=0;r<s[1];++r)e=e.add(a.slice([n*i.shape[0],r*i.shape[1]],[i.shape[0],i.shape[1]]));else if(3===i.rank)for(n=0;n<s[0];++n)for(r=0;r<s[1];++r)for(var o=0;o<s[2];++o)e=e.add(a.slice([n*i.shape[0],r*i.shape[1],o*i.shape[2]],[i.shape[0],i.shape[1],i.shape[2]]));else{if(4!==i.rank)throw new Error("Gradient for tile operation is not implemented for rank-"+i.rank+" tensors yet.");for(n=0;n<s[0];++n)for(r=0;r<s[1];++r)for(o=0;o<s[2];++o)for(var t=0;t<s[3];++t)e=e.add(a.slice([n*i.shape[0],r*i.shape[1],o*i.shape[2],t*i.shape[3]],[i.shape[0],i.shape[1],i.shape[2],i.shape[3]]))}return e}}})},d.gather=function(n,r,e){void 0===e&&(e=0);var o=axis_util_1.parseAxisParam(e,n.shape);return environment_1.ENV.engine.runKernel(function(e){return e.gather(n,r,o[0])},{x:n,indices:r})},d.pad1d=function(e,n,r){return void 0===r&&(r=0),util.assert(2===n.length,"Invalid number of paddings. Must be length of 2."),d.pad(e,[n],r)},d.pad2d=function(e,n,r){return void 0===r&&(r=0),util.assert(2===n.length&&2===n[0].length&&2===n[1].length,"Invalid number of paddings. Must be length of 2 each."),d.pad(e,n,r)},d.pad3d=function(e,n,r){return void 0===r&&(r=0),util.assert(3===n.length&&2===n[0].length&&2===n[1].length&&2===n[2].length,"Invalid number of paddings. Must be length of 2 each."),d.pad(e,n,r)},d.pad4d=function(e,n,r){return void 0===r&&(r=0),util.assert(4===n.length&&2===n[0].length&&2===n[1].length&&2===n[2].length&&2===n[3].length,"Invalid number of paddings. Must be length of 2 each."),d.pad(e,n,r)},d.pad=function(n,r,o){if(void 0===o&&(o=0),0===n.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");var t=r.map(function(e){return e[0]});return environment_1.ENV.engine.runKernel(function(e){return e.pad(n,r,o)},{x:n},function(e){return{x:function(){return e.slice(t,n.shape)}}})},d.stack=function(e,n){void 0===n&&(n=0),util.assert(2<=e.length,"Pass at least two tensors to dl.stack");var r=e[0].rank,o=e[0].shape,t=e[0].dtype;util.assert(n<=r,"Axis must be <= rank of the tensor"),e.forEach(function(e){util.assertShapesMatch(o,e.shape,"All tensors passed to stack must have matching shapes")}),e.forEach(function(e){util.assert(t===e.dtype,"All tensors passed to stack must have matching dtypes")});var a=e.map(function(e){return e.expandDims(n)});return concat_1.ConcatOps.concat(a,n)},d.expandDims=function(e,n){void 0===n&&(n=0),util.assert(n<=e.rank,"Axis must be <= rank of the tensor");var r=e.shape.slice();return r.splice(n,0,1),d.reshape(e,r)},d.linspace=function(e,n,r){if(0===r)throw new Error("Cannot request zero samples");var o=(n-e)/(r-1),t=makeZerosTypedArray(r,"float32");t[0]=e;for(var a=1;a<t.length;a++)t[a]=t[a-1]+o;return tensor_1.Tensor1D.new(t,"float32")},d.range=function(e,n,r,o){if(void 0===r&&(r=1),void 0===o&&(o="float32"),0===r)throw new Error("Cannot have a step of zero");if(e===n||e<n&&r<0||n<e&&1<r)return d.zeros([0],o);var t=makeZerosTypedArray(Math.abs(Math.ceil((n-e)/r)),o);n<e&&1===r&&(r=-1),t[0]=e;for(var a=1;a<t.length;a++)t[a]=t[a-1]+r;return d.tensor1d(t,o)},d.buffer=function(e,n,r){return void 0===n&&(n="float32"),new tensor_1.TensorBuffer(e,n,r)},d.print=function(e,n){void 0===n&&(n=!1),console.log(tensor_util.tensorToString(e,n))},__decorate([doc_1.doc({heading:"Tensors",subheading:"Creation"})],d,"tensor",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Creation"})],d,"scalar",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Creation"})],d,"tensor1d",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Creation"})],d,"tensor2d",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Creation"})],d,"tensor3d",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Creation"})],d,"tensor4d",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Creation"}),operation_1.operation],d,"ones",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Creation"}),operation_1.operation],d,"zeros",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Creation"}),operation_1.operation],d,"fill",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Creation"}),operation_1.operation],d,"onesLike",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Creation"}),operation_1.operation],d,"zerosLike",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Creation"}),operation_1.operation],d,"clone",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Creation"}),operation_1.operation],d,"randomNormal",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Creation"}),operation_1.operation],d,"truncatedNormal",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Creation"}),operation_1.operation],d,"randomUniform",null),__decorate([operation_1.operation],d,"rand",null),__decorate([operation_1.operation],d,"multinomial",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Creation"}),operation_1.operation],d,"oneHot",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Creation"}),operation_1.operation],d,"fromPixels",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Transformations"}),operation_1.operation],d,"reshape",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Transformations"})],d,"squeeze",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Transformations"}),operation_1.operation],d,"cast",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Slicing and Joining"}),operation_1.operation],d,"tile",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Slicing and Joining"}),operation_1.operation],d,"gather",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Transformations"}),operation_1.operation],d,"pad",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Slicing and Joining"}),operation_1.operation],d,"stack",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Transformations"}),operation_1.operation],d,"expandDims",null),__decorate([operation_1.operation,doc_1.doc({heading:"Tensors",subheading:"Creation"})],d,"linspace",null),__decorate([operation_1.operation,doc_1.doc({heading:"Tensors",subheading:"Creation"})],d,"range",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Creation"})],d,"buffer",null),__decorate([doc_1.doc({heading:"Tensors",subheading:"Creation"})],d,"print",null),d}();function makeZerosTypedArray(e,n){if(null==n||"float32"===n)return new Float32Array(e);if("int32"===n)return new Int32Array(e);if("bool"===n)return new Uint8Array(e);throw new Error("Unknown data type $ {dtype}")}function makeOnesTypedArray(e,n){for(var r=makeZerosTypedArray(e,n),o=0;o<r.length;o++)r[o]=1;return r}function toTypedArray(e,n){return noConversionNeeded(e,n)?e:(Array.isArray(e)&&(e=util.flatten(e)),util.copyTypedArray(e,n))}function noConversionNeeded(e,n){return e instanceof Float32Array&&"float32"===n||e instanceof Int32Array&&"int32"===n||e instanceof Uint8Array&&"bool"===n}exports.ArrayOps=ArrayOps;