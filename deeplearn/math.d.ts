import { BackendType, ENV } from './environment';
import { KernelBackend } from './kernels/backend';
import { ArrayOps } from './ops/array_ops';
import { BatchNormOps } from './ops/batchnorm';
import { BinaryOps } from './ops/binary_ops';
import { CompareOps } from './ops/compare';
import { ConvOps } from './ops/conv';
import { ImageOps } from './ops/image_ops';
import { LogicalOps } from './ops/logical_ops';
import { LRNOps } from './ops/lrn';
import { LSTMOps } from './ops/lstm';
import { MatmulOps } from './ops/matmul';
import { NormOps } from './ops/norm';
import { PoolOps } from './ops/pool';
import { ReductionOps } from './ops/reduction_ops';
import { ReverseOps } from './ops/reverse';
import { SliceOps } from './ops/slice';
import { SoftmaxOps } from './ops/softmax';
import { TransposeOps } from './ops/transpose';
import { UnaryOps } from './ops/unary_ops';
import { Scalar, Tensor, Tensor1D, Tensor2D, Tensor3D, Tensor4D } from './tensor';
import { Tracking } from './tracking';
import { Rank, TensorContainer } from './types';
export declare class NDArrayMath {
    matMul: typeof MatmulOps.matMul;
    vectorTimesMatrix: typeof MatmulOps.vectorTimesMatrix;
    outerProduct: typeof MatmulOps.outerProduct;
    matrixTimesVector: typeof MatmulOps.matrixTimesVector;
    dotProduct: typeof MatmulOps.dotProduct;
    slice: typeof SliceOps.slice;
    slice1D: typeof SliceOps.slice1d;
    slice2D: typeof SliceOps.slice2d;
    slice3D: typeof SliceOps.slice3d;
    slice4D: typeof SliceOps.slice4d;
    reverse: typeof ReverseOps.reverse;
    reverse1D: typeof ReverseOps.reverse1d;
    reverse2D: typeof ReverseOps.reverse2d;
    reverse3D: typeof ReverseOps.reverse3d;
    reverse4D: typeof ReverseOps.reverse4d;
    batchNormalization: typeof BatchNormOps.batchNormalization;
    batchNormalization2D: typeof BatchNormOps.batchNormalization2d;
    batchNormalization3D: typeof BatchNormOps.batchNormalization3d;
    batchNormalization4D: typeof BatchNormOps.batchNormalization4d;
    avgPool: typeof PoolOps.avgPool;
    maxPool: typeof PoolOps.maxPool;
    minPool: typeof PoolOps.minPool;
    maxPoolBackprop: typeof PoolOps.maxPoolBackprop;
    conv2dTranspose: typeof ConvOps.conv2dTranspose;
    depthwiseConv2D: typeof ConvOps.depthwiseConv2d;
    conv2dDerFilter: typeof ConvOps.conv2dDerFilter;
    conv2dDerInput: typeof ConvOps.conv2dDerInput;
    argMax: typeof ReductionOps.argMax;
    argMin: typeof ReductionOps.argMin;
    logSumExp: typeof ReductionOps.logSumExp;
    max: typeof ReductionOps.max;
    mean: typeof ReductionOps.mean;
    min: typeof ReductionOps.min;
    moments: typeof ReductionOps.moments;
    sum: typeof ReductionOps.sum;
    add: typeof BinaryOps.add;
    addStrict: typeof BinaryOps.addStrict;
    div: typeof BinaryOps.div;
    divide: typeof BinaryOps.div;
    divStrict: typeof BinaryOps.divStrict;
    divideStrict: typeof BinaryOps.divStrict;
    maximum: typeof BinaryOps.maximum;
    maximumStrict: typeof BinaryOps.maximumStrict;
    minimum: typeof BinaryOps.minimum;
    minimumStrict: typeof BinaryOps.minimumStrict;
    mul: typeof BinaryOps.mul;
    multiply: typeof BinaryOps.mul;
    mulStrict: typeof BinaryOps.mulStrict;
    multiplyStrict: typeof BinaryOps.mulStrict;
    pow: typeof BinaryOps.pow;
    powStrict: typeof BinaryOps.powStrict;
    sub: typeof BinaryOps.sub;
    subtract: typeof BinaryOps.sub;
    subStrict: typeof BinaryOps.subStrict;
    logicalNot: typeof LogicalOps.logicalNot;
    logicalAnd: typeof LogicalOps.logicalAnd;
    logicalOr: typeof LogicalOps.logicalOr;
    logicalXor: typeof LogicalOps.logicalXor;
    where: typeof LogicalOps.where;
    transpose: typeof TransposeOps.transpose;
    equal: typeof CompareOps.equal;
    equalStrict: typeof CompareOps.equalStrict;
    greater: typeof CompareOps.greater;
    greaterStrict: typeof CompareOps.greaterStrict;
    greaterEqual: typeof CompareOps.greaterEqual;
    greaterEqualStrict: typeof CompareOps.greaterEqualStrict;
    less: typeof CompareOps.less;
    lessStrict: typeof CompareOps.lessStrict;
    lessEqual: typeof CompareOps.lessEqual;
    lessEqualStrict: typeof CompareOps.lessEqualStrict;
    notEqual: typeof CompareOps.notEqual;
    notEqualStrict: typeof CompareOps.notEqualStrict;
    abs: typeof UnaryOps.abs;
    acos: typeof UnaryOps.acos;
    asin: typeof UnaryOps.asin;
    atan: typeof UnaryOps.atan;
    ceil: typeof UnaryOps.ceil;
    clip: typeof UnaryOps.clipByValue;
    cos: typeof UnaryOps.cos;
    cosh: typeof UnaryOps.cosh;
    elu: typeof UnaryOps.elu;
    exp: typeof UnaryOps.exp;
    floor: typeof UnaryOps.floor;
    leakyRelu: typeof UnaryOps.leakyRelu;
    log: typeof UnaryOps.log;
    neg: typeof UnaryOps.neg;
    prelu: typeof UnaryOps.prelu;
    relu: typeof UnaryOps.relu;
    selu: typeof UnaryOps.selu;
    sigmoid: typeof UnaryOps.sigmoid;
    sin: typeof UnaryOps.sin;
    sinh: typeof UnaryOps.sinh;
    sqrt: typeof UnaryOps.sqrt;
    square: typeof UnaryOps.square;
    step: typeof UnaryOps.step;
    tan: typeof UnaryOps.tan;
    tanh: typeof UnaryOps.tanh;
    norm: typeof NormOps.norm;
    basicLSTMCell: typeof LSTMOps.basicLSTMCell;
    multiRNNCell: typeof LSTMOps.multiRNNCell;
    softmax: typeof SoftmaxOps.softmax;
    softmaxCrossEntropy: typeof SoftmaxOps.softmaxCrossEntropy;
    cast: typeof ArrayOps.cast;
    clone: typeof ArrayOps.clone;
    gather: typeof ArrayOps.gather;
    reshape: typeof ArrayOps.reshape;
    tile: typeof ArrayOps.tile;
    oneHot: typeof ArrayOps.oneHot;
    multinomial: typeof ArrayOps.multinomial;
    pad1D: typeof ArrayOps.pad1d;
    pad2D: typeof ArrayOps.pad2d;
    resizeBilinear3D: typeof ImageOps.resizeBilinear;
    localResponseNormalization3D: typeof LRNOps.localResponseNormalization;
    localResponseNormalization4D: typeof LRNOps.localResponseNormalization;
    keep: typeof Tracking.keep;
    engine: typeof ENV.engine;
    dispose: typeof ENV.engine.dispose;
    registeredVariables: typeof ENV.engine.registeredVariables;
    startScope: typeof ENV.engine.startScope;
    endScope: typeof ENV.engine.endScope;
    constructor(backend: BackendType | KernelBackend, safeMode: boolean);
    scope<T extends TensorContainer>(scopeFn?: ScopeFn<T>): T;
    track<T extends Tensor>(result: T): T;
    topK(x: Tensor, k: number): {
        values: Tensor1D;
        indices: Tensor1D;
    };
    elementWiseMul<T extends Tensor>(a: T, b: T): T;
    scalarDividedByArray<T extends Tensor>(c: Scalar, a: T): T;
    arrayDividedByScalar<T extends Tensor>(a: T, c: Scalar): T;
    switchDim<R extends Rank>(x: Tensor<R>, perm?: number[]): Tensor<R>;
    scalarPlusArray<T extends Tensor>(c: Scalar, a: T): T;
    scalarMinusArray<T extends Tensor>(c: Scalar, a: T): T;
    arrayMinusScalar<T extends Tensor>(a: T, c: Scalar): T;
    scaledArrayAdd<T extends Tensor>(c1: Scalar, a: T, c2: Scalar, b: T): T;
    scalarTimesArray<T extends Tensor>(c: Scalar, a: T): T;
    concat<T extends Tensor>(a: T, b: T, axis: number): T;
    concat1D(a: Tensor1D, b: Tensor1D): Tensor1D;
    concat2D(a: Tensor2D, b: Tensor2D, axis: number): Tensor2D;
    concat3D(a: Tensor3D, b: Tensor3D, axis: number): Tensor3D;
    concat4D(a: Tensor4D, b: Tensor4D, axis: number): Tensor4D;
    conv1d<T extends Tensor2D | Tensor3D>(input: T, filter: Tensor3D, bias: Tensor1D | null, stride: number, pad: 'valid' | 'same' | number, dimRoundingMode?: 'floor' | 'round' | 'ceil'): T;
    conv2d<T extends Tensor3D | Tensor4D>(x: T, filter: Tensor4D, bias: Tensor1D | null, strides: [number, number] | number, pad: 'valid' | 'same' | number, dimRoundingMode?: 'floor' | 'round' | 'ceil'): T;
    argMaxEquals(x1: Tensor, x2: Tensor): Scalar;
}
export declare type ScopeFn<T extends TensorContainer> = (keep: <T1 extends Tensor>(tensor: T1) => T1, track: <T2 extends Tensor>(tensor: T2) => T2) => T;
