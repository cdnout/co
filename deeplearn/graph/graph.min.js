"use strict";var __extends=this&&this.__extends||function(){var n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var o in e)e.hasOwnProperty(o)&&(t[o]=e[o])};return function(t,e){function o(){this.constructor=t}n(t,e),t.prototype=null===e?Object.create(e):(o.prototype=e.prototype,new o)}}();Object.defineProperty(exports,"__esModule",{value:!0});var concat_util=require("../ops/concat_util"),conv_util=require("../ops/conv_util"),tensor_1=require("../tensor"),util=require("../util"),initializers_1=require("./initializers"),GraphLayers=function(){function t(t){this.g=t}return t.prototype.dense=function(t,e,o,n,a,s,r){void 0===n&&(n=null),void 0===a&&(a=!0),void 0===s&&(s=new initializers_1.VarianceScalingInitializer),void 0===r&&(r=new initializers_1.ZerosInitializer);var i,u=this.g.variable(t+"-weights",s.initialize([e.shape[0],o],e.shape[0],o)),h=this.g.matmul(e,u);return a&&(i=this.g.variable(t+"-bias",r.initialize([o],e.shape[0],o)),h=this.g.add(h,i)),null!=n&&(h=n(h)),h},t}();exports.GraphLayers=GraphLayers;var Graph=function(){function t(){this.nodes=[],this.layers=new GraphLayers(this)}return t.prototype.variable=function(t,e){return this.addNodeAndReturnOutput(new VariableNode(this,t,e))},t.prototype.placeholder=function(t,e){return this.addNodeAndReturnOutput(new PlaceholderNode(this,t,e))},t.prototype.constant=function(t){if("number"==typeof t)n=tensor_1.Scalar.new(t);else if(t instanceof tensor_1.Tensor)n=t;else{if(!(t instanceof Array))throw new Error("unimplemented constant type.");var e=util.flatten(t),o=new Float32Array(e),n=tensor_1.Tensor.make(util.inferShape(t),{values:o})}return this.addNodeAndReturnOutput(new ConstantNode(this,n))},t.prototype.reshape=function(t,e){return this.addNodeAndReturnOutput(new ReshapeNode(this,"Reshape",t,e))},t.prototype.fusedLinearCombination=function(t,e,o,n){return this.addNodeAndReturnOutput(new FusedLinearCombinationNode(this,t,e,o,n))},t.prototype.add=function(t,e){return this.addNodeAndReturnOutput(new AddNode(this,t,e))},t.prototype.subtract=function(t,e){return this.addNodeAndReturnOutput(new SubtractNode(this,t,e))},t.prototype.multiply=function(t,e){return this.addNodeAndReturnOutput(new MultiplyNode(this,t,e))},t.prototype.divide=function(t,e){return this.addNodeAndReturnOutput(new DivideNode(this,t,e))},t.prototype.reduceSum=function(t){return this.addNodeAndReturnOutput(new ReduceSumNode(this,t))},t.prototype.concat1d=function(t,e){return this.addNodeAndReturnOutput(new Concat1DNode(this,t,e))},t.prototype.concat2d=function(t,e,o){return this.addNodeAndReturnOutput(new Concat2DNode(this,t,e,o))},t.prototype.concat3d=function(t,e,o){return this.addNodeAndReturnOutput(new Concat3DNode(this,t,e,o))},t.prototype.concat4d=function(t,e,o){return this.addNodeAndReturnOutput(new Concat4DNode(this,t,e,o))},t.prototype.matmul=function(t,e){return this.addNodeAndReturnOutput(new MatMulNode(this,t,e))},t.prototype.conv2d=function(t,e,o,n,a,s,r){return void 0===s&&(s=1),this.addNodeAndReturnOutput(new Convolution2DNode(this,t,e,o,n,a,s,r))},t.prototype.maxPool=function(t,e,o,n){return void 0===o&&(o=1),this.addNodeAndReturnOutput(new MaxPoolNode(this,t,e,o,n))},t.prototype.exp=function(t){return this.addNodeAndReturnOutput(new ExpNode(this,t))},t.prototype.log=function(t){return this.addNodeAndReturnOutput(new LogNode(this,t))},t.prototype.relu=function(t){return this.addNodeAndReturnOutput(new ReLUNode(this,t))},t.prototype.leakyRelu=function(t,e){return this.addNodeAndReturnOutput(new LeakyReLUNode(this,t,e))},t.prototype.prelu=function(t,e){return this.addNodeAndReturnOutput(new PReLUNode(this,t,e))},t.prototype.elu=function(t){return this.addNodeAndReturnOutput(new EluNode(this,t))},t.prototype.tanh=function(t){return this.addNodeAndReturnOutput(new TanHNode(this,t))},t.prototype.sigmoid=function(t){return this.addNodeAndReturnOutput(new SigmoidNode(this,t))},t.prototype.square=function(t){return this.addNodeAndReturnOutput(new SquareNode(this,t))},t.prototype.softmax=function(t){return this.addNodeAndReturnOutput(new SoftmaxNode(this,t))},t.prototype.softmaxCrossEntropyCost=function(t,e){return this.addNodeAndReturnOutput(new SoftmaxCrossEntropyCostNode(this,t,e))},t.prototype.meanSquaredCost=function(t,e){return this.addNodeAndReturnOutput(new MeanSquaredCostNode(this,t,e))},t.prototype.argmax=function(t){return this.addNodeAndReturnOutput(new ArgMaxNode(this,t))},t.prototype.argmaxEquals=function(t,e){return this.addNodeAndReturnOutput(new ArgMaxEqualsNode(this,t,e))},t.prototype.addNodeAndReturnOutput=function(t){return this.nodes.push(t),t.validate(),t.output},t.prototype.getNodes=function(){return this.nodes},t}();exports.Graph=Graph;var SymbolicTensor=function(o){function n(t){var e=o.call(this,[],"float32")||this;return e.shape=t,e.id=n.nextID++,e}return __extends(n,o),n.nextID=0,n}(tensor_1.Tensor);exports.SymbolicTensor=SymbolicTensor;var Node=function(){function a(t,e,o,n){this.graph=t,this.name=e,this.inputs=o,this.output=n,this.id=a.nextID++,n.node=this}return a.nextID=0,a}(),VariableNode=function(a){function t(t,e,o){var n=a.call(this,t,e,{},new SymbolicTensor(o.shape))||this;return n.data=o,n}return __extends(t,a),t.prototype.validate=function(){util.assert(null!=this.data,"Error adding variable op: Data for variable '"+this.name+"' is null or undefined")},t}(exports.Node=Node);exports.VariableNode=VariableNode;var PlaceholderNode=function(n){function t(t,e,o){return n.call(this,t,e,{},new SymbolicTensor(o))||this}return __extends(t,n),t.prototype.validate=function(){},t}(Node);exports.PlaceholderNode=PlaceholderNode;var ConstantNode=function(n){function t(t,e){var o=n.call(this,t,"Constant",{},new SymbolicTensor(e.shape))||this;return o.data=e,o}return __extends(t,n),t.prototype.validate=function(){util.assert(null!=this.data,"Error adding constant: data for placeholder '"+this.name+"' is null or undefined")},t}(Node);exports.ConstantNode=ConstantNode;var ReshapeNode=function(s){function t(t,e,o,n){var a=s.call(this,t,e,{x:o},new SymbolicTensor(n))||this;return a.name=e,a.x=o,a.shape=n,a}return __extends(t,s),t.prototype.validate=function(){var t=util.sizeFromShape(this.x.shape),e=util.sizeFromShape(this.shape);util.assert(t===e,"Error making reshape operation: input to reshape '"+this.name+"' of shape ("+this.x.shape+") does not match size of requested shape "+this.shape+".")},t.X="x",t}(Node);exports.ReshapeNode=ReshapeNode;var FusedLinearCombinationNode=function(r){function t(t,e,o,n,a){var s=r.call(this,t,"Linear Combination",{t1:e,t2:o,c1:n,c2:a},new SymbolicTensor(e.shape))||this;return s.t1=e,s.t2=o,s.c1=n,s.c2=a,s}return __extends(t,r),t.prototype.validate=function(){if(util.assertShapesMatch(this.t1.shape,this.t2.shape),!util.isScalarShape(this.c1.shape))throw new Error("Error adding fusedLinearCombination: c1 is not a scalar, got shape: "+this.c1.shape);if(!util.isScalarShape(this.c2.shape))throw new Error("Error adding fusedLinearCombination: c2 is not a scalar, got shape: "+this.c2.shape)},t.T1="t1",t.T2="t2",t.C1="c1",t.C2="c2",t}(Node);exports.FusedLinearCombinationNode=FusedLinearCombinationNode;var AddNode=function(a){function t(t,e,o){var n=a.call(this,t,"Add",{t1:e,t2:o},new SymbolicTensor(1===util.sizeFromShape(e.shape)||e.shape.length<o.shape.length?o.shape:e.shape))||this;return n.t1=e,n.t2=o,n}return __extends(t,a),t.prototype.validate=function(){util.assert(1===util.sizeFromShape(this.t1.shape)||1===util.sizeFromShape(this.t2.shape)||util.arraysEqual(this.t1.shape,this.t2.shape)||2===this.t1.shape.length&&1===this.t2.shape.length&&this.t1.shape[1]===this.t2.shape[0]||1===this.t1.shape.length&&2===this.t2.shape.length&&this.t1.shape[0]===this.t2.shape[1],"Error adding add operation op: one of inputs must be scalar, shapes "+this.t1.shape+" and "+this.t2.shape+" must match,or one of them can be broadcasted (2D and 1D).")},t.T1="t1",t.T2="t2",t}(Node);exports.AddNode=AddNode;var SubtractNode=function(a){function t(t,e,o){var n=a.call(this,t,"Subtract",{t1:e,t2:o},new SymbolicTensor(1===util.sizeFromShape(e.shape)?o.shape:e.shape))||this;return n.t1=e,n.t2=o,n}return __extends(t,a),t.prototype.validate=function(){util.assert(1===util.sizeFromShape(this.t1.shape)||1===util.sizeFromShape(this.t2.shape)||util.arraysEqual(this.t1.shape,this.t2.shape),"Error adding subtract op: one of inputs must be scalar or the shapes "+this.t1.shape+" and "+this.t2.shape+" must match.")},t.T1="t1",t.T2="t2",t}(Node);exports.SubtractNode=SubtractNode;var MultiplyNode=function(a){function t(t,e,o){var n=a.call(this,t,"Multiply",{t1:e,t2:o},new SymbolicTensor(1===util.sizeFromShape(e.shape)?o.shape:e.shape))||this;return n.t1=e,n.t2=o,n}return __extends(t,a),t.prototype.validate=function(){util.assert(1===util.sizeFromShape(this.t1.shape)||1===util.sizeFromShape(this.t2.shape)||util.arraysEqual(this.t1.shape,this.t2.shape),"Error adding multiply op: one of inputs must be scalar or the shapes "+this.t1.shape+" and "+this.t2.shape+" must match.")},t.T1="t1",t.T2="t2",t}(Node);exports.MultiplyNode=MultiplyNode;var DivideNode=function(a){function t(t,e,o){var n=a.call(this,t,"Divide",{t1:e,t2:o},new SymbolicTensor(1===util.sizeFromShape(e.shape)?o.shape:e.shape))||this;return n.t1=e,n.t2=o,n}return __extends(t,a),t.prototype.validate=function(){util.assert(1===util.sizeFromShape(this.t1.shape)||1===util.sizeFromShape(this.t2.shape)||util.arraysEqual(this.t1.shape,this.t2.shape),"Error adding divide op: one of inputs must be scalar or the shapes "+this.t1.shape+" and "+this.t2.shape+" must match.")},t.T1="t1",t.T2="t2",t}(Node);exports.DivideNode=DivideNode;var ReduceSumNode=function(o){function t(t,e){return o.call(this,t,"ReduceSum",{x:e},new SymbolicTensor([]))||this}return __extends(t,o),t.prototype.validate=function(){},t.X="x",t}(Node);exports.ReduceSumNode=ReduceSumNode;var Concat1DNode=function(n){function t(t,e,o){return n.call(this,t,"Concat1D",{x1:e,x2:o},new SymbolicTensor(concat_util.computeOutShape1D(e.shape,o.shape)))||this}return __extends(t,n),t.prototype.validate=function(){},t.X1="x1",t.X2="x2",t}(Node);exports.Concat1DNode=Concat1DNode;var Concat2DNode=function(s){function t(t,e,o,n){var a=s.call(this,t,"Concat2D",{x1:e,x2:o},new SymbolicTensor(concat_util.computeOutShape(e.shape,o.shape,n)))||this;return a.x1=e,a.x2=o,a.axis=n,a}return __extends(t,s),t.prototype.validate=function(){concat_util.assertParams(this.x1.shape,this.x2.shape,this.axis)},t.X1="x1",t.X2="x2",t.AXIS="axis",t}(Node);exports.Concat2DNode=Concat2DNode;var Concat3DNode=function(s){function t(t,e,o,n){var a=s.call(this,t,"Concat3D",{x1:e,x2:o},new SymbolicTensor(concat_util.computeOutShape(e.shape,o.shape,n)))||this;return a.x1=e,a.x2=o,a.axis=n,a}return __extends(t,s),t.prototype.validate=function(){concat_util.assertParams(this.x1.shape,this.x2.shape,this.axis)},t.X1="x1",t.X2="x2",t.AXIS="axis",t}(Node);exports.Concat3DNode=Concat3DNode;var Concat4DNode=function(s){function t(t,e,o,n){var a=s.call(this,t,"Concat4D",{x1:e,x2:o},new SymbolicTensor(concat_util.computeOutShape(e.shape,o.shape,n)))||this;return a.x1=e,a.x2=o,a.axis=n,a}return __extends(t,s),t.prototype.validate=function(){concat_util.assertParams(this.x1.shape,this.x2.shape,this.axis)},t.X1="x1",t.X2="x2",t.AXIS="axis",t}(Node);function getMatMulOutputShape(t,e){return 1===t.length&&1===e.length?[1]:1===t.length&&2===e.length?[e[1]]:2===t.length&&1===e.length?[t[0]]:[t[0],e[1]]}exports.Concat4DNode=Concat4DNode;var MatMulNode=function(a){function t(t,e,o){var n=a.call(this,t,"MatMul",{x1:e,x2:o},new SymbolicTensor(getMatMulOutputShape(e.shape,o.shape)))||this;return n.x1=e,n.x2=o,n}return __extends(t,a),t.prototype.validate=function(){if(2===this.x1.shape.length&&2===this.x2.shape.length)util.assert(this.x1.shape[1]===this.x2.shape[0],"Error adding matmul op: inner shapes of matrices with shapes "+this.x1.shape+" and "+this.x2.shape+" must match.");else if(2===this.x1.shape.length&&1===this.x2.shape.length)util.assert(this.x1.shape[1]===this.x2.shape[0],"Error adding matmul op: second dimension of matrix with shape "+this.x1.shape.toString()+" must match size of vector with shape "+this.x2.shape+".");else{if(1!==this.x1.shape.length||2!==this.x2.shape.length)throw new Error("Error adding matmul op: inputs must be vectors or matrices.");util.assert(this.x1.shape[0]===this.x2.shape[0],"Error adding matmul op: size of vector with shape "+this.x1.shape+" must match first dimension of matrix with shape "+this.x2.shape+".")}},t.X1="x1",t.X2="x2",t}(Node);exports.MatMulNode=MatMulNode;var Convolution2DNode=function(h){function t(t,e,o,n,a,s,r,i){void 0===r&&(r=1);var u=h.call(this,t,"Convolution 2D",{x:e,w:o,b:n},new SymbolicTensor(conv_util.computeOutputShape3D(e.shape,a,s,r,i)))||this;return u.x=e,u.w=o,u.b=n,u.fieldSize=a,u.outputDepth=s,u.stride=r,u.zeroPad=i,u}return __extends(t,h),t.prototype.validate=function(){util.assert(3===this.x.shape.length,"Error adding conv2d op: input must be of rank 3, but got shape: "+this.x.shape+"."),util.assert(4===this.w.shape.length,"Error adding conv2d op: weights must be of rank 4, but got shape: "+this.w.shape+"."),util.assert(1===this.b.shape.length,"Error adding conv2d op: biases must be of rank 1, but got shape: "+this.b.shape+"."),util.assert(this.x.shape[2]===this.w.shape[2],"Error adding conv2d op: depth of input ("+this.x.shape[2]+") must match input depth for weights ("+this.w.shape[2]+").")},t.X="x",t.W="w",t.B="b",t}(Node);exports.Convolution2DNode=Convolution2DNode;var MaxPoolNode=function(r){function t(t,e,o,n,a){void 0===n&&(n=1);var s=r.call(this,t,"Max pool",{x:e},new SymbolicTensor(conv_util.computeOutputShape3D(e.shape,o,e.shape[2],n,a)))||this;return s.x=e,s.fieldSize=o,s.stride=n,s.zeroPad=a,s}return __extends(t,r),t.prototype.validate=function(){util.assert(3===this.x.shape.length,"Error adding maxPool op: input must be of rank 3, but got shape: "+this.x.shape+".")},t.X="x",t}(Node);exports.MaxPoolNode=MaxPoolNode;var ReLUNode=function(o){function t(t,e){return o.call(this,t,"ReLU",{x:e},new SymbolicTensor(e.shape))||this}return __extends(t,o),t.prototype.validate=function(){},t.X="x",t}(Node);exports.ReLUNode=ReLUNode;var LeakyReLUNode=function(a){function t(t,e,o){var n=a.call(this,t,"LeakyReLU",{x:e},new SymbolicTensor(e.shape))||this;return n.alpha=o,n}return __extends(t,a),t.prototype.validate=function(){},t.X="x",t}(Node);exports.LeakyReLUNode=LeakyReLUNode;var PReLUNode=function(a){function t(t,e,o){var n=a.call(this,t,"PReLU",{x:e,alpha:o},new SymbolicTensor(e.shape))||this;return n.x=e,n.alpha=o,n}return __extends(t,a),t.prototype.validate=function(){util.assert(util.arraysEqual(this.x.shape,this.alpha.shape),"Error adding pRelu op: the shapes x: "+this.x.shape+" and alpha: "+this.alpha.shape+" must match.")},t.X="x",t.ALPHA="alpha",t}(Node);exports.PReLUNode=PReLUNode;var EluNode=function(o){function t(t,e){return o.call(this,t,"Elu",{x:e},new SymbolicTensor(e.shape))||this}return __extends(t,o),t.prototype.validate=function(){},t.X="x",t}(Node);exports.EluNode=EluNode;var ExpNode=function(o){function t(t,e){return o.call(this,t,"Exp",{x:e},new SymbolicTensor(e.shape))||this}return __extends(t,o),t.prototype.validate=function(){},t.X="x",t}(Node);exports.ExpNode=ExpNode;var LogNode=function(o){function t(t,e){return o.call(this,t,"Log",{x:e},new SymbolicTensor(e.shape))||this}return __extends(t,o),t.prototype.validate=function(){},t.X="x",t}(Node);exports.LogNode=LogNode;var TanHNode=function(o){function t(t,e){return o.call(this,t,"TanH",{x:e},new SymbolicTensor(e.shape))||this}return __extends(t,o),t.prototype.validate=function(){},t.X="x",t}(Node);exports.TanHNode=TanHNode;var SigmoidNode=function(o){function t(t,e){return o.call(this,t,"Sigmoid",{x:e},new SymbolicTensor(e.shape))||this}return __extends(t,o),t.prototype.validate=function(){},t.X="x",t}(Node);exports.SigmoidNode=SigmoidNode;var SquareNode=function(o){function t(t,e){return o.call(this,t,"Square",{x:e},new SymbolicTensor(e.shape))||this}return __extends(t,o),t.prototype.validate=function(){},t.X="x",t}(Node);exports.SquareNode=SquareNode;var SoftmaxCrossEntropyCostNode=function(a){function t(t,e,o){var n=a.call(this,t,"SoftmaxCrossEntropyCost",{x:e,target:o},new SymbolicTensor([]))||this;return n.x=e,n.target=o,n}return __extends(t,a),t.prototype.validate=function(){util.assert(util.arraysEqual(this.x.shape,this.target.shape),"Error adding softmaxCrossEntropyCost op: x shape ("+this.x.shape+") must match target shape ("+this.target.shape+").")},t.X="x",t.TARGET="target",t}(Node);exports.SoftmaxCrossEntropyCostNode=SoftmaxCrossEntropyCostNode;var SoftmaxNode=function(n){function t(t,e){var o=n.call(this,t,"Softmax",{x:e},new SymbolicTensor(e.shape))||this;return o.x=e,o}return __extends(t,n),t.prototype.validate=function(){util.assert(1===this.x.shape.length,"The input to a softmax must be a 1-D tensor"),util.assert(2<=this.x.shape[0],"The input to a softmax must have at least 2 values")},t.X="x",t}(Node);exports.SoftmaxNode=SoftmaxNode;var MeanSquaredCostNode=function(a){function t(t,e,o){var n=a.call(this,t,"Mean Squared Cost",{label:e,prediction:o},new SymbolicTensor([]))||this;return n.label=e,n.prediction=o,n}return __extends(t,a),t.prototype.validate=function(){util.assert(util.arraysEqual(this.label.shape,this.prediction.shape),"Error adding meanSquaredCost op: label shape ("+this.label.shape+") must match prediction shape ("+this.prediction.shape+").")},t.LABEL="label",t.PREDICTION="prediction",t}(Node);exports.MeanSquaredCostNode=MeanSquaredCostNode;var ArgMaxNode=function(n){function t(t,e){var o=n.call(this,t,"ArgMax",{x:e},new SymbolicTensor([1]))||this;return o.x=e,o}return __extends(t,n),t.prototype.validate=function(){util.assert(0<util.sizeFromShape(this.x.shape),"Error adding argmax op: input tensor must have at least one entry.")},t.X="x",t}(Node);exports.ArgMaxNode=ArgMaxNode;var ArgMaxEqualsNode=function(a){function t(t,e,o){var n=a.call(this,t,"ArgMaxEquals",{x1:e,x2:o},new SymbolicTensor([1]))||this;return n.x1=e,n.x2=o,n}return __extends(t,a),t.prototype.validate=function(){util.assert(util.arraysEqual(this.x1.shape,this.x2.shape),"Error adding ArgMaxEquals op: x1 shape ("+this.x1.shape+") must match x2 shape ("+this.x2.shape+").")},t.X1="x1",t.X2="x2",t}(Node);exports.ArgMaxEqualsNode=ArgMaxEqualsNode;