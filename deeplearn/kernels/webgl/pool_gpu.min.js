"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var Pool2DProgram=function(n,e,t){if(this.variableNames=["x"],"avg"===e&&t)throw new Error("Cannot compute positions for average pool.");var i=n.filterHeight,a=n.filterWidth,o=n.strideHeight,r=n.strideWidth,u=n.padInfo.top,l=n.padInfo.left;this.outputShape=n.outShape;var x,s,c,C,d,v,R="avg"===e,V=R?"0.0":"min"===e?"1.0 / 0.0":"-1.0 / 0.0";t?(x="min"===e?"<=":">=",this.userCode="\n        const ivec2 strides = ivec2("+o+", "+r+");\n        const ivec2 pads = ivec2("+u+", "+l+");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < "+i+"; wR++) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= "+n.inHeight+") {\n              continue;\n            }\n\n            for (int wC = 0; wC < "+a+"; wC++) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= "+n.inWidth+") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              if (isNaN(value)) {\n                setOutput(value);\n                return;\n              }\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value "+x+" currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = wR * "+a+" + wC;\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      "):(s="min"===e?"min":"max",c="avg"===e?"avgValue / "+i*a+".0":e+"("+e+"("+e+"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])",C=4*Math.floor(a/4),d=a%4,v="\n      if (hasNaN(values)) {\n        setOutput(getNaN(values));\n        return;\n      }\n      if ("+R+") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = "+s+"(values, minMaxValue);\n      }\n    ",this.userCode="\n      const ivec2 strides = ivec2("+o+", "+r+");\n      const ivec2 pads = ivec2("+u+", "+l+");\n      const float initializationValue = "+V+";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= "+n.inWidth+") {\n          return initializationValue;\n        }\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4("+V+");\n        float avgValue = 0.0;\n\n        for (int wR = 0; wR < "+i+"; wR++) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= "+n.inHeight+") {\n            continue;\n          }\n\n          for (int wC = 0; wC < "+C+"; wC += 4) {\n            int xC = xCCorner + wC;\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + 1, d),\n              getValue(batch, xR, xC + 2, d),\n              getValue(batch, xR, xC + 3, d)\n            );\n\n            "+v+"\n          }\n\n          int xC = xCCorner + "+C+";\n          if ("+(1==d)+") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n            "+v+"\n          } else if ("+(2==d)+") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + 1, d),\n              initializationValue,\n              initializationValue\n            );\n\n            "+v+"\n          } else if ("+(3==d)+") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + 1, d),\n              getValue(batch, xR, xC + 2, d),\n              initializationValue\n            );\n\n            "+v+"\n          }\n        }\n        setOutput("+c+");\n      }\n    ")};exports.Pool2DProgram=Pool2DProgram;