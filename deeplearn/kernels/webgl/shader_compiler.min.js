"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var environment_1=require("../../environment"),util=require("../../util"),broadcast_util=require("../../ops/broadcast_util"),tex_util=require("./tex_util");function makeShader(e,n,t,r){var a=getSampleSnippet(),o=getSetOutputSnippet(),i=e.map(function(e){return"uniform sampler2D "+e.name+";"}).join("\n"),u=e.map(function(e){return getInputSamplingSnippet(e,n,r)}).join("\n"),l=n.texShape,c=getOutputSamplingSnippet(n.logicalShape,l);return[SHADER_PREFIX,a,o,i,c,u,t].join("\n")}function getSampleSnippet(){return environment_1.ENV.get("WEBGL_FLOAT_TEXTURE_ENABLED")?FLOAT_TEXTURE_SAMPLE_SNIPPET:UNSIGNED_BYTE_TEXTURE_SAMPLE_SNIPPET}function getSetOutputSnippet(){return environment_1.ENV.get("WEBGL_FLOAT_TEXTURE_ENABLED")?FLOAT_TEXTURE_SETOUTPUT_SNIPPET:UNSIGNED_BYTE_TEXTURE_SETOUTPUT_SNIPPET}function getSamplerFromInInfo(e){var n=e.shapeInfo.logicalShape;switch(n.length){case 0:return getSamplerScalar(e);case 1:return getSampler1D(e);case 2:return getSampler2D(e);case 3:return getSampler3D(e);case 4:return getSampler4D(e);default:throw new Error(n.length+"-D input sampling is not yet supported")}}function getInputSamplingSnippet(e,n,t){var r=getSamplerFlat(e);return r+=getSamplerFromInInfo(e),(t||util.arraysEqual(e.shapeInfo.logicalShape,n.logicalShape))&&(r+=getSamplerAtOutputCoords(e,n,t)),r}function getOutputSamplingSnippet(e,n){switch(e.length){case 0:return getOutputScalarCoords();case 1:return getOutput1DCoords(e,n);case 2:return getOutput2DCoords(e,n);case 3:return getOutput3DCoords(e,n);case 4:return getOutput4DCoords(e,n);default:throw new Error(e.length+"-D output sampling is not yet supported")}}exports.makeShader=makeShader;var SAMPLE_1D_SNIPPET="\nvec2 UVfrom1D(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",SAMPLE_2D_SNIPPET="\nvec2 UVfrom2D(int texNumR, int texNumC, int numC, int row, int col) {\n  int index = row * numC + col;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",SAMPLE_3D_SNIPPET="\nvec2 UVfrom3D(int texNumR, int texNumC, int stride0,\n    int stride1, int row, int col, int depth) {\n  // Explicitly use integer operations as dot() only works on floats.\n  int index = row * stride0 + col * stride1 + depth;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",SAMPLE_4D_SNIPPET="\nvec2 UVfrom4D(int texNumR, int texNumC, int stride0,\n    int stride1, int stride2, int row, int col, int depth,\n    int depth2) {\n  // Explicitly use integer operations as dot() only works on floats.\n  int index = row * stride0 + col * stride1 + depth * stride2 + depth2;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",UNSIGNED_BYTE_TEXTURE_SAMPLE_SNIPPET="\n  uniform float NaN;\n\n  const vec4 floatDeltas = vec4(\n      1.0,\n      1.0 / 255.0,\n      1.0 / (255.0 * 255.0),\n      1.0 / (255.0 * 255.0 * 255.0)\n  );\n  const float minValue = "+tex_util.FLOAT_MIN+".0;\n  const float maxValue = "+tex_util.FLOAT_MAX+".0;\n  const float range = (maxValue - minValue) / 255.0;\n  const vec2 dotRange = vec2(1.0, range);\n\n  float sample(sampler2D texture, vec2 uv) {\n    vec4 sampleValue = texture2D(texture, uv);\n    if (all(equal(sampleValue, vec4("+tex_util.BYTE_NAN_VALUE+")))) {\n      return NaN;\n    }\n\n    vec4 encValue = floor(sampleValue * 255.0 + 0.5);\n    float decodedValue = dot(encValue, floatDeltas);\n    return dot(vec2(minValue, decodedValue), dotRange);\n  }\n",UNSIGNED_BYTE_TEXTURE_SETOUTPUT_SNIPPET="\n  const vec4 floatPowers = vec4(\n    1.0,\n    255.0,\n    255.0 * 255.0,\n    255.0 * 255.0 * 255.0\n  );\n  const vec2 recipRange = vec2(1.0/range);\n  const vec2 recipRange255 = vec2(1.0/(maxValue - minValue));\n\n  void setOutput(float decodedValue) {\n    if (isNaN(decodedValue)) {\n      gl_FragColor = vec4("+tex_util.BYTE_NAN_VALUE+");\n      return;\n    }\n\n    float a = dot(vec2(decodedValue, -minValue), recipRange);\n    float b = fract(a) * 255.0;\n    float c = fract(b) * 255.0;\n    float d = fract(c) * 255.0;\n    gl_FragColor = floor(vec4(a, b, c, d)) / 255.0;\n\n    // TODO(dsmilkov): Version above gets better accuracy but probably slower\n    // than the version below. Benchmark to determine if the accuracy is worth\n    // the cost.\n\n    // float normValue = dot(vec2(decodedValue, -minValue), recipRange255);\n    // vec4 f = normValue * floatPowers;\n    // gl_FragColor = floor(fract(f) * 255.0) / 255.0;\n  }\n",FLOAT_TEXTURE_SAMPLE_SNIPPET="\n  float sample(sampler2D texture, vec2 uv) {\n    return texture2D(texture, uv).r;\n  }\n",FLOAT_TEXTURE_SETOUTPUT_SNIPPET="\n  void setOutput(float val) {\n    gl_FragColor = vec4(val, 0, 0, 0);\n  }\n",SHADER_PREFIX="\n  precision highp float;\n  precision highp int;\n  varying vec2 resultUV;\n  const vec2 halfCR = vec2(0.5, 0.5);\n\n  bool isNaN(float val) {\n    float v1 = val * val;\n    float v2 = val * val;\n    return v1 == v2 ? false : true;\n  }\n\n  bool hasNaN(vec4 values) {\n    vec4 v1 = values * values;\n    vec4 v2 = values * values;\n    return any(notEqual(v1, v2));\n  }\n\n  float getNaN(vec4 values) {\n    return dot(vec4(1), values);\n  }\n\n  int round(float value) {\n    return int(floor(value + 0.5));\n  }\n\n  int imod(int x, int y) {\n    return x - y * (x / y);\n  }\n\n  const vec2 randomConst = vec2(\n    23.14069263277926, // e^pi (Gelfond's constant)\n     2.665144142690225 // 2^sqrt(2) (Gelfondâ€“Schneider constant)\n  );\n\n  float random(float seed) {\n      return fract(cos(dot(resultUV * seed, randomConst)) * 12345.6789);\n  }\n\n  "+SAMPLE_1D_SNIPPET+"\n  "+SAMPLE_2D_SNIPPET+"\n  "+SAMPLE_3D_SNIPPET+"\n  "+SAMPLE_4D_SNIPPET+"\n";function getOutputScalarCoords(){return"\n    int getOutputCoords() {\n      return 0;\n    }\n  "}function getOutput1DCoords(e,n){return 1===n[0]?"\n      int getOutputCoords() {\n        return int(resultUV.x * "+n[1]+".0);\n      }\n    ":1===n[1]?"\n      int getOutputCoords() {\n        return int(resultUV.y * "+n[0]+".0);\n      }\n    ":"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+n[0]+", "+n[1]+"));\n      return resTexRC.x * "+n[1]+" + resTexRC.y;\n    }\n  "}function getOutput3DCoords(e,n){var t=e[1]*e[2],r=e[2];return"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+n[0]+", "+n[1]+"));\n      int index = resTexRC.x * "+n[1]+" + resTexRC.y;\n      int r = index / "+t+";\n      index -= r * "+t+";\n      int c = index / "+r+";\n      int d = index - c * "+r+";\n      return ivec3(r, c, d);\n    }\n  "}function getOutput4DCoords(e,n){var t=e[3],r=e[2]*t,a=e[1]*r;return"\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2("+n[0]+", "+n[1]+"));\n      int index = resTexRC.x * "+n[1]+" + resTexRC.y;\n\n      int r = index / "+a+";\n      index -= r * "+a+";\n\n      int c = index / "+r+";\n      index -= c * "+r+";\n\n      int d = index / "+t+";\n      int d2 = index - d * "+t+";\n\n      return ivec4(r, c, d, d2);\n    }\n  "}function getOutput2DCoords(e,n){return util.arraysEqual(e,n)?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2("+n[0]+", "+n[1]+"));\n      }\n    ":1===e[1]?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2("+n[0]+", "+n[1]+"));\n        int index = resTexRC.x * "+n[1]+" + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":1===e[0]?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2("+n[0]+", "+n[1]+"));\n        int index = resTexRC.x * "+n[1]+" + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+n[0]+", "+n[1]+"));\n      int index = resTexRC.x * "+n[1]+" + resTexRC.y;\n      int r = index / "+e[1]+";\n      int c = index - r * "+e[1]+";\n      return ivec2(r, c);\n    }\n  "}function getSamplerScalar(e){var n=e.name;return"\n    float "+("get"+n.charAt(0).toUpperCase()+n.slice(1))+"() {\n      return sample("+n+", halfCR);\n    }\n  "}function getSampler1D(e){var n=e.name,t="get"+n.charAt(0).toUpperCase()+n.slice(1);return"\n    float "+t+"(int index) {\n      return "+t+"Flat(index);\n    }\n  "}function getSampler2D(e){var n=e.shapeInfo.logicalShape,t=e.shapeInfo.texShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),o=t[0],i=t[1];if(util.arraysEqual(n,t))return"\n    float "+a+"(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2("+i+".0, "+o+".0);\n      return sample("+r+", uv);\n    }\n  ";var u=util.squeezeShape(n),l=u.newShape,c=u.keptDims;if(l.length<n.length){return"\n      "+getSamplerFromInInfo(squeezeInputInfo(e,l))+"\n      float "+a+"(int row, int col) {\n        return "+a+"("+getSqueezedParams(["row","col"],c)+");\n      }\n    "}return 1===i?"\n    float "+a+"(int row, int col) {\n      int index = row * "+n[1]+" + col;\n      vec2 uv = vec2(0.5, (float(index) + 0.5) / "+o+".0);\n      return sample("+r+", uv);\n    }\n  ":1===o?"\n    float "+a+"(int row, int col) {\n      int index = row * "+n[1]+" + col;\n      vec2 uv = vec2((float(index) + 0.5) / "+i+".0, 0.5);\n      return sample("+r+", uv);\n    }\n  ":"\n  float "+a+"(int row, int col) {\n    vec2 uv = UVfrom2D("+o+", "+i+", "+n[1]+", row, col);\n    return sample("+r+", uv);\n  }\n"}function getSampler3D(e){var n=e.shapeInfo.texShape,t=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),o=n[0],i=n[1],u=t[1]*t[2],l=t[2],c=util.squeezeShape(t),s=c.newShape,p=c.keptDims;if(s.length<t.length){return"\n        "+getSamplerFromInInfo(squeezeInputInfo(e,s))+"\n        float "+a+"(int row, int col, int depth) {\n          return "+a+"("+getSqueezedParams(["row","col","depth"],p)+");\n        }\n      "}return i===u?"\n        float "+a+"(int row, int col, int depth) {\n          int texR = row;\n          int texC = col * "+l+" + depth;\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2("+i+".0, "+o+".0);\n          return sample("+r+", uv);\n        }\n      ":i===l?"\n    float "+a+"(int row, int col, int depth) {\n      int texR = row * "+t[1]+" + col;\n      int texC = depth;\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2("+i+".0, "+o+".0);\n      return sample("+r+", uv);\n    }\n  ":"\n      float "+a+"(int row, int col, int depth) {\n        vec2 uv = UVfrom3D(\n            "+o+", "+i+", "+u+", "+l+", row, col, depth);\n        return sample("+r+", uv);\n      }\n  "}function getSampler4D(e){var n=e.shapeInfo.logicalShape,t=e.shapeInfo.texShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),o=t[0],i=t[1],u=n[3],l=n[2]*u,c=n[1]*l,s=util.squeezeShape(n),p=s.newShape,v=s.keptDims;if(p.length<n.length){return"\n      "+getSamplerFromInInfo(squeezeInputInfo(e,p))+"\n      float "+a+"(int row, int col, int depth, int depth2) {\n        return "+a+"("+getSqueezedParams(["row","col","depth","depth2"],v)+");\n      }\n    "}return i===c?"\n      float "+a+"(int row, int col, int depth, int depth2) {\n        int texR = row;\n        int texC = col * "+l+" + depth * "+u+" + depth2;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2("+i+".0, "+o+".0);\n        return sample("+r+", uv);\n      }\n    ":i===u?"\n      float "+a+"(int row, int col, int depth, int depth2) {\n        int texR = row * "+n[1]*n[2]+" + col * "+n[2]+" + depth;\n        int texC = depth2;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2("+i+".0, "+o+".0);\n        return sample("+r+", uv);\n      }\n    ":"\n    float "+a+"(int row, int col, int depth, int depth2) {\n      vec2 uv = UVfrom4D("+o+", "+i+", "+c+", "+l+",\n          "+u+", row, col, depth, depth2);\n      return sample("+r+", uv);\n    }\n  "}function getSamplerFlat(e){var n=e.name,t=e.shapeInfo.texShape,r="get"+n.charAt(0).toUpperCase()+n.slice(1)+"Flat",a=t[0],o=t[1];return 1===o&&1===a?"\n      float "+r+"(int index) {\n        return sample("+n+", halfCR);\n      }\n    ":1===o?"\n      float "+r+"(int index) {\n        vec2 uv = vec2(0.5, (float(index) + 0.5) / "+a+".0);\n        return sample("+n+", uv);\n      }\n    ":1===a?"\n      float "+r+"(int index) {\n        vec2 uv = vec2((float(index) + 0.5) / "+o+".0, 0.5);\n        return sample("+n+", uv);\n      }\n    ":"\n    float "+r+"(int index) {\n      vec2 uv = UVfrom1D("+a+", "+o+", index);\n      return sample("+n+", uv);\n    }\n  "}function getBroadcastOutputCoordsSampler(e,n,t,r){var a=e.shapeInfo.logicalShape.length,o=n.logicalShape.length,i="int";2===o?i="ivec2":3===o?i="ivec3":4===o&&(i="ivec4");var u=broadcast_util.getBroadcastDims(e.shapeInfo.logicalShape,n.logicalShape),l=o-a,c=0===a?"":o<2&&1<=u.length?"coords = 0;":u.map(function(e){return"coords["+(e+l)+"] = 0;"}).join("\n");return"\n    float "+r+"() {\n      "+i+" coords = getOutputCoords();\n      "+c+"\n      return get"+t+"("+(o<2&&0<a?"coords":e.shapeInfo.logicalShape.map(function(e,n){return"coords["+(n+l)+"]"}).join(", "))+");\n    }\n  "}function getSamplerAtOutputCoords(e,n,t){var r=e.shapeInfo.texShape,a=e.name,o=a.charAt(0).toUpperCase()+a.slice(1),i="get"+o+"AtOutCoords",u=broadcast_util.getBroadcastDims(e.shapeInfo.logicalShape,n.logicalShape),l=e.shapeInfo.logicalShape.length,c=n.logicalShape.length,s=t&&(l<c||0<u.length),p=broadcast_util.broadcastDimsAreOuter(u);if(s&&!p)return getBroadcastOutputCoordsSampler(e,n,o,i);var v=n.texShape;if(util.arraysEqual(r,v))return"\n      float "+i+"() {\n        return sample("+a+", resultUV);\n      }\n    ";var d=util.sizeFromShape(r),x=s&&p?"\n        int mainPart = index / "+d+";\n        index -= mainPart * "+d+";\n      ":"";return"\n    float "+i+"() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+v[0]+", "+v[1]+"));\n      int index = resTexRC.x * "+v[1]+" + resTexRC.y;\n      "+x+"\n      int texR = index / "+r[1]+";\n      int texC = index - texR * "+r[1]+";\n      vec2 uv = (vec2(texC, texR) + halfCR) /\n                 vec2("+r[1]+".0, "+r[0]+".0);\n\n      return sample("+a+", uv);\n    }\n  "}function getCoordsDataType(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";throw Error("GPU for rank "+e+" is not yet supported")}function squeezeInputInfo(e,n){var t=JSON.parse(JSON.stringify(e));return t.shapeInfo.logicalShape=n,t}function getSqueezedParams(n,e){return e.map(function(e){return n[e]}).join(", ")}exports.getCoordsDataType=getCoordsDataType;