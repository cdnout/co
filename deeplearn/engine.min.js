"use strict";var __awaiter=this&&this.__awaiter||function(o,s,a,u){return new(a=a||Promise)(function(e,t){function n(e){try{i(u.next(e))}catch(e){t(e)}}function r(e){try{i(u.throw(e))}catch(e){t(e)}}function i(t){t.done?e(t.value):new a(function(e){e(t.value)}).then(n,r)}i((u=u.apply(o,s||[])).next())})},__generator=this&&this.__generator||function(n,r){var i,o,s,a={label:0,sent:function(){if(1&s[0])throw s[1];return s[1]},trys:[],ops:[]},e={next:t(0),throw:t(1),return:t(2)};return"function"==typeof Symbol&&(e[Symbol.iterator]=function(){return this}),e;function t(t){return function(e){return function(t){if(i)throw new TypeError("Generator is already executing.");for(;a;)try{if(i=1,o&&(s=o[2&t[0]?"return":t[0]?"throw":"next"])&&!(s=s.call(o,t[1])).done)return s;switch(o=0,s&&(t=[0,s.value]),t[0]){case 0:case 1:s=t;break;case 4:return a.label++,{value:t[1],done:!1};case 5:a.label++,o=t[1],t=[0];continue;case 7:t=a.ops.pop(),a.trys.pop();continue;default:if(!(s=0<(s=a.trys).length&&s[s.length-1])&&(6===t[0]||2===t[0])){a=0;continue}if(3===t[0]&&(!s||t[1]>s[0]&&t[1]<s[3])){a.label=t[1];break}if(6===t[0]&&a.label<s[1]){a.label=s[1],s=t;break}if(s&&a.label<s[2]){a.label=s[2],a.ops.push(t);break}s[2]&&a.ops.pop(),a.trys.pop();continue}t=r.call(n,a)}catch(e){t=[6,e],o=0}finally{i=s=0}if(5&t[0])throw t[1];return{value:t[0]?t[1]:void 0,done:!0}}([t,e])}}};Object.defineProperty(exports,"__esModule",{value:!0});var environment_1=require("./environment"),globals_1=require("./globals"),ops=require("./ops/ops"),profiler_1=require("./profiler"),tape_1=require("./tape"),tensor_1=require("./tensor"),util=require("./util"),Engine=function(){function e(e,t,n){this.backend=e,this.customBackend=t,this.safeMode=n,this.registeredVariables={},this.refCounter=new WeakMap,this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numDataBuffers=0,this.gradientScopeCount=0,this.customGradientDepth=0,this.activeScope={keep:[],track:[]},this.scopeStack=[this.activeScope],this.profiler=new profiler_1.Profiler(e)}return e.prototype.runKernel=function(e,t,n){function r(e){return s.push(e),e}var i,o=this,s=[],a=this.activeScope.name,u=environment_1.ENV.get("DEBUG")?this.profiler.profileKernel(a,function(){return e(o.backend,r)}):e(this.backend,r);return null!=this.activeTape&&0===this.customGradientDepth&&(i={id:this.nextTapeNodeId++,name:a,inputs:t,output:u},null!=n&&(i.gradient=function(e){return n(e,s)}),this.activeTape.push(i)),u},e.prototype.registerTensor=function(e){var t=this.refCounter.has(e.dataId)?this.refCounter.get(e.dataId):0;this.numTensors++,0===t&&(this.numDataBuffers++,this.numBytes+=util.sizeFromShape(e.shape)*util.bytesPerElement(e.dtype),this.backend.register(e.dataId,e.shape,e.dtype)),this.refCounter.set(e.dataId,t+1),e instanceof tensor_1.Variable||this.track(e)},e.prototype.registerVariable=function(e){if(null!=this.registeredVariables[e.name])throw new Error("Variable with name "+e.name+" was already registered");this.registeredVariables[e.name]=e},e.prototype.disposeTensor=function(e){var t;this.refCounter.has(e.dataId)&&(this.numTensors--,(t=this.refCounter.get(e.dataId))<=1?(this.refCounter.delete(e.dataId),this.backend.disposeData(e.dataId),this.numDataBuffers--,this.numBytes-=util.sizeFromShape(e.shape)*util.bytesPerElement(e.dtype)):this.refCounter.set(e.dataId,t-1))},e.prototype.memory=function(){var e=this.backend.memory();return e.numTensors=this.numTensors,e.numDataBuffers=this.numDataBuffers,e.numBytes=this.numBytes,e},e.prototype.shouldRecord=function(){return null!=this.activeTape&&0===this.customGradientDepth},e.prototype.addTapeNode=function(e,t,r){var n={};e.forEach(function(e,t){n[t]=e});var i={id:this.nextTapeNodeId++,name:this.activeScope.name,inputs:n,output:t,gradient:function(e){var t=r(e),n={};return t.forEach(function(e,t){n[t]=function(){return e}}),n}};this.activeTape.push(i)},e.prototype.keep=function(e){if(1===this.scopeStack.length&&environment_1.ENV.engine.safeMode)throw new Error("Safe mode is ON. Enclose all tensor operations inside dl.tidy(): dl.tidy(() => {...}) to avoid memory leaks.");return this.activeScope.keep.push(e),e},e.prototype.startScope=function(e,t){void 0===t&&(t=!1),t&&0===this.gradientScopeCount&&(this.activeTape=[]),t&&this.gradientScopeCount++;var n={keep:[],track:[]};e&&(n.name=e),this.scopeStack.push(n),this.activeScope=n},e.prototype.endScope=function(e,t){var n=this;void 0===t&&(t=!1),t&&(this.gradientScopeCount--,0===this.gradientScopeCount&&(this.activeTape=null));for(var r=this.activeScope.keep,i=util.extractTensorsFromContainer(e),r=r.concat(i),o=0;o<this.activeScope.track.length;o++){var s=this.activeScope.track[o];util.isTensorInList(s,r)||(null!=this.activeTape?i.push(s):s.dispose())}this.scopeStack.pop(),this.activeScope=0===this.scopeStack.length?{keep:[],track:[]}:this.scopeStack[this.scopeStack.length-1],i.forEach(function(e){util.isTensorInList(e,n.activeScope.keep)||n.track(e)})},e.prototype.dispose=function(){this.customBackend&&this.backend.dispose()},e.prototype.gradients=function(r,i,o,s){var a=this;return void 0===s&&(s=!1),util.assert(0<i.length,"gradients() received an empty list of xs."),globals_1.tidy("gradients",function(){var e=r();util.assert(e instanceof tensor_1.Tensor,"The result y returned by f() must be a tensor.");var t=tape_1.getFilteredNodesXToY(a.activeTape,i,e);if(!s&&0===t.length&&0<i.length)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");var n={};return n[e.id]=null==o?ops.ones(e.shape):o,tape_1.backpropagateGradients(n,t),{value:e,grads:i.map(function(e){return n[e.id]})}},!0)},e.prototype.customGrad=function(o){var n=this;return util.assert(util.isFunction(o),"The f passed in customGrad(f) must be a function."),function(){for(var r,i=[],e=0;e<arguments.length;e++)i[e]=arguments[e];util.assert(i.every(function(e){return e instanceof tensor_1.Tensor}),"The args passed in customGrad(f)(x1, x2,...) must all be tensors"),n.customGradientDepth++;var t=globals_1.tidy(o.name,function(){var e=o.apply(void 0,i),t=e.value,n=e.gradFunc;return util.assert(t instanceof tensor_1.Tensor,"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),util.assert(util.isFunction(n),"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r=n,t},!0);return n.customGradientDepth--,n.shouldRecord()&&n.addTapeNode(i,t,function(e){var t=r(e),n=Array.isArray(t)?t:[t];return util.assert(n.length===i.length,"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),util.assert(n.every(function(e){return e instanceof tensor_1.Tensor}),"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."),n}),t}},e.prototype.write=function(e,t){this.backend.write(e,t)},e.prototype.readSync=function(e){return this.backend.readSync(e)},e.prototype.read=function(e){return this.backend.read(e)},e.prototype.fromPixels=function(e,t){return this.backend.fromPixels(e,t)},e.prototype.time=function(r){return __awaiter(this,void 0,void 0,function(){var t,n;return __generator(this,function(e){switch(e.label){case 0:return t=performance.now(),[4,this.backend.time(r)];case 1:return(n=e.sent()).wallMs=performance.now()-t,[2,n]}})})},e.prototype.track=function(e){if(1===this.scopeStack.length&&this.safeMode)throw new Error("Safe mode is ON. Enclose all tensor operations inside dl.tidy(): dl.tidy(() => {op();...}); to avoid memory leaks.");return this.activeScope.track.push(e),e},e}();exports.Engine=Engine;