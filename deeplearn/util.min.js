"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var tensor_1=require("./tensor");function shuffle(r){for(var e=r.length,t=0,n=0;0<e;)n=Math.random()*e|0,t=r[--e],r[e]=r[n],r[n]=t}function clamp(r,e,t){return Math.max(r,Math.min(e,t))}function randUniform(r,e){return Math.random()*(e-r)+r}function distSquared(r,e){for(var t=0,n=0;n<r.length;n++){var a=Number(r[n])-Number(e[n]);t+=a*a}return t}function assert(r,e){if(!r)throw new Error(e)}function assertShapesMatch(r,e,t){void 0===t&&(t=""),assert(arraysEqual(r,e),t+"Shapes "+r+" and "+e+" must match")}function assertTypesMatch(r,e){assert(r.dtype===e.dtype,"The dtypes of the first ("+r.dtype+") and second ("+e.dtype+") input must match")}function flatten(r,e){if(void 0===e&&(e=[]),Array.isArray(r))for(var t=0;t<r.length;++t)flatten(r[t],e);else e.push(r);return e}function inferShape(r){if(isTypedArray(r))return[r.length];if(!Array.isArray(r))return[];for(var e=[];r instanceof Array;)e.push(r.length),r=r[0];return e}function sizeFromShape(r){if(0===r.length)return 1;for(var e=r[0],t=1;t<r.length;t++)e*=r[t];return e}function isScalarShape(r){return 0===r.length}function arraysEqual(r,e){if(r.length!==e.length)return!1;for(var t=0;t<r.length;t++)if(r[t]!==e[t])return!1;return!0}function isInt(r){return r%1==0}function tanh(r){if(null!=Math.tanh)return Math.tanh(r);if(r===1/0)return 1;if(r===-1/0)return-1;var e=Math.exp(2*r);return(e-1)/(e+1)}function sizeToSquarishShape(r){for(var e=Math.floor(Math.sqrt(r));1<e;--e)if(r%e==0)return[e,r/e];return[1,r]}function createShuffledIndices(r){for(var e=new Uint32Array(r),t=0;t<r;++t)e[t]=t;return shuffle(e),e}function rightPad(r,e){return e<=r.length?r:r+" ".repeat(e-r.length)}function repeatedTry(o,s,i){return void 0===s&&(s=function(r){return 0}),new Promise(function(e,t){var n=0,a=function(){var r;o()?e():(r=s(++n),null!=i&&i<=n?t():setTimeout(a,r))};setTimeout(a,0)})}function getQueryParams(r){var n={};return r.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,function(r){for(var e=[],t=1;t<arguments.length;t++)e[t-1]=arguments[t];return decodeParam(n,e[0],e[1]),e.join("=")}),n}function decodeParam(r,e,t){r[decodeURIComponent(e)]=decodeURIComponent(t||"")}function inferFromImplicitShape(r,e){for(var t=1,n=-1,a=0;a<r.length;++a)if(0<r[a])t*=r[a];else if(-1===r[a]){if(-1!==n)throw Error("Shapes can only have 1 implicit size. Found -1 at dim "+n+" and dim "+a);n=a}else if(r[a]<=0)throw Error("Shapes can not be <= 0. Found "+r[a]+" at dim "+a);if(-1===n){if(0<e&&e!==t)throw Error("Size ("+e+") must match the product of shape "+r);return r}if(e%t!=0)throw Error("The implicit shape can't be a fractional number. Got "+e+" / "+t);var o=r.slice();return o[n]=e/t,o}function getNaN(r){if("float32"===r)return exports.NAN_FLOAT32;if("int32"===r)return exports.NAN_INT32;if("bool"===r)return exports.NAN_BOOL;throw new Error("Unknown dtype "+r)}function isValNaN(r,e){if(isNaN(r))return!0;if("float32"===e)return!1;if("int32"===e)return r===exports.NAN_INT32;if("bool"===e)return r===exports.NAN_BOOL;throw new Error("Unknown dtype "+e)}function squeezeShape(r,e){for(var t=[],n=[],a=0,o=0;o<r.length;++o){if(null!=e){if(e[a]===o&&1<r[o])throw new Error("Can't squeeze axis "+o+" since its dim '"+r[o]+"' is not 1");(null==e[a]||e[a]>o)&&1===r[o]&&(t.push(r[o]),n.push(o)),e[a]<=o&&a++}1<r[o]&&(t.push(r[o]),n.push(o))}return{newShape:t,keptDims:n}}function getTypedArrayFromDType(r,e){var t=null;if(null==r||"float32"===r)t=new Float32Array(e);else if("int32"===r)t=new Int32Array(e);else{if("bool"!==r)throw new Error("Unknown data type "+r);t=new Uint8Array(e)}return t}function isTensorInList(r,e){for(var t=0;t<e.length;t++)if(e[t].id===r.id)return!0;return!1}function checkForNaN(r,e,t){for(var n=0;n<r.length;n++)if(isValNaN(r[n],e))throw Error("The result of the '"+t+"' has NaNs.")}function flattenNameArrayMap(r,e){var t=[];if(r instanceof tensor_1.Tensor)t.push(r);else for(var n=r,a=0;a<e.length;a++)t.push(n[e[a]]);return t}function unflattenToNameArrayMap(r,e){if(r.length!==e.length)throw new Error("Cannot unflatten Tensor[], keys and arrays are not of same length.");for(var t={},n=0;n<r.length;n++)t[r[n]]=e[n];return t}function hasEncodingLoss(r,e){return"float32"!==e&&(("int32"!==e||"float32"===r)&&("bool"!==e||"bool"!==r))}function copyTypedArray(r,e){if(null==e||"float32"===e)return new Float32Array(r);if("int32"===e){for(var t=new Int32Array(r.length),n=0;n<t.length;++n){isValNaN(a=r[n],"int32")?t[n]=getNaN("int32"):t[n]=a}return t}if("bool"!==e)throw new Error("Unknown data type "+e);for(var a,o=new Uint8Array(r.length),n=0;n<o.length;++n){isValNaN(a=r[n],"bool")?o[n]=getNaN("bool"):0!==Math.round(a)&&(o[n]=1)}return o}function isTypedArray(r){return r instanceof Float32Array||r instanceof Int32Array||r instanceof Uint8Array}function bytesPerElement(r){if("float32"===r||"int32"===r)return 4;if("bool"===r)return 1;throw new Error("Unknown dtype "+r)}function isFunction(r){return!!(r&&r.constructor&&r.call&&r.apply)}function extractTensorsFromContainer(r){return extractTensorsFromAny(r)}function extractTensorsFromAny(r){if(null==r)return[];if(r instanceof tensor_1.Tensor)return[r];var e=[],t=r;if(!isIterable(t))return[];for(var n in t){var a=flatten(t[n]).filter(function(r){return r instanceof tensor_1.Tensor});e.push.apply(e,a)}return e}function isIterable(r){return Array.isArray(r)||"object"==typeof r}exports.shuffle=shuffle,exports.clamp=clamp,exports.randUniform=randUniform,exports.distSquared=distSquared,exports.assert=assert,exports.assertShapesMatch=assertShapesMatch,exports.assertTypesMatch=assertTypesMatch,exports.flatten=flatten,exports.inferShape=inferShape,exports.sizeFromShape=sizeFromShape,exports.isScalarShape=isScalarShape,exports.arraysEqual=arraysEqual,exports.isInt=isInt,exports.tanh=tanh,exports.sizeToSquarishShape=sizeToSquarishShape,exports.createShuffledIndices=createShuffledIndices,exports.rightPad=rightPad,exports.repeatedTry=repeatedTry,exports.getQueryParams=getQueryParams,exports.inferFromImplicitShape=inferFromImplicitShape,exports.NAN_INT32=1<<31,exports.NAN_BOOL=255,exports.NAN_FLOAT32=NaN,exports.getNaN=getNaN,exports.isValNaN=isValNaN,exports.squeezeShape=squeezeShape,exports.getTypedArrayFromDType=getTypedArrayFromDType,exports.isTensorInList=isTensorInList,exports.checkForNaN=checkForNaN,exports.flattenNameArrayMap=flattenNameArrayMap,exports.unflattenToNameArrayMap=unflattenToNameArrayMap,exports.hasEncodingLoss=hasEncodingLoss,exports.copyTypedArray=copyTypedArray,exports.isTypedArray=isTypedArray,exports.bytesPerElement=bytesPerElement,exports.isFunction=isFunction,exports.extractTensorsFromContainer=extractTensorsFromContainer,exports.extractTensorsFromAny=extractTensorsFromAny;