"use strict";var __decorate=this&&this.__decorate||function(e,n,r,a){var t,s=arguments.length,i=s<3?n:null===a?a=Object.getOwnPropertyDescriptor(n,r):a;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(e,n,r,a);else for(var u=e.length-1;0<=u;u--)(t=e[u])&&(i=(s<3?t(i):3<s?t(n,r,i):t(n,r))||i);return 3<s&&i&&Object.defineProperty(n,r,i),i};Object.defineProperty(exports,"__esModule",{value:!0});var doc_1=require("./doc"),environment_1=require("./environment"),globals_1=require("./globals"),tensor_1=require("./tensor"),util=require("./util"),Gradients=function(){function e(){}return e.gradScope=function(e,n){return globals_1.tidy(e,n,!0)},e.grad=function(s){return util.assert(util.isFunction(s),"The f passed in grad(f) must be a function"),function(e,n){util.assert(e instanceof tensor_1.Tensor,"The x passed in grad(f)(x) must be a tensor"),util.assert(null==n||n instanceof tensor_1.Tensor,"The dy passed in grad(f)(x, dy) must be a tensor");var r=environment_1.ENV.engine.gradients(function(){return s(e)},[e],n),a=r.value,t=r.grads;return null!=n&&util.assertShapesMatch(a.shape,n.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),a.dispose(),checkGrads(t),t[0]}},e.grads=function(s){return util.assert(util.isFunction(s),"The f passed in grads(f) must be a function"),function(e,n){util.assert(Array.isArray(e)&&e.every(function(e){return e instanceof tensor_1.Tensor}),"The args passed in grads(f)(args) must be an array of tensors"),util.assert(null==n||n instanceof tensor_1.Tensor,"The dy passed in grads(f)(args, dy) must be a tensor");var r=environment_1.ENV.engine.gradients(function(){return s.apply(void 0,e)},e,n),a=r.value,t=r.grads;return null!=n&&util.assertShapesMatch(a.shape,n.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),a.dispose(),checkGrads(t),t}},e.valueAndGrad=function(s){return util.assert(util.isFunction(s),"The f passed in valueAndGrad(f) must be a function"),function(e,n){util.assert(e instanceof tensor_1.Tensor,"The x passed in valueAndGrad(f)(x) must be a tensor"),util.assert(null==n||n instanceof tensor_1.Tensor,"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");var r=environment_1.ENV.engine.gradients(function(){return s(e)},[e],n),a=r.grads,t=r.value;return checkGrads(a),{grad:a[0],value:t}}},e.valueAndGrads=function(a){return util.assert(util.isFunction(a),"The f passed in valueAndGrads(f) must be a function"),function(e,n){util.assert(Array.isArray(e)&&e.every(function(e){return e instanceof tensor_1.Tensor}),"The args passed in valueAndGrads(f)(args) must be array of tensors"),util.assert(null==n||n instanceof tensor_1.Tensor,"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");var r=environment_1.ENV.engine.gradients(function(){return a.apply(void 0,e)},e,n);return null!=n&&util.assertShapesMatch(r.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),checkGrads(r.grads),r}},e.variableGrads=function(e,n){if(util.assert(util.isFunction(e),"The f passed in variableGrads(f) must be a function"),util.assert(null==n||Array.isArray(n)&&n.every(function(e){return e instanceof tensor_1.Variable}),"The varList passed in variableGrads(f, varList) must be an array of variables"),null==n)for(var r in n=[],environment_1.ENV.engine.registeredVariables)n.push(environment_1.ENV.engine.registeredVariables[r]);var a=n.length;n=n.filter(function(e){return e.trainable}),util.assert(0<n.length,"variableGrads() expects at least one of the input variables to be trainable, but none of the "+a+" variables is trainable.");var t=environment_1.ENV.engine.gradients(e,n,null,!0),s=t.value,i=t.grads;util.assert(i.some(function(e){return null!=e}),"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),util.assert(0===s.rank,"The f passed in variableGrads(f) must return a scalar, but it returned a rank-"+s.rank+" tensor");var u={};return n.forEach(function(e,n){null!=i[n]&&(u[e.name]=i[n])}),{value:s,grads:u}},e.customGrad=function(e){return environment_1.ENV.engine.customGrad(e)},__decorate([doc_1.doc({heading:"Training",subheading:"Gradients"})],e,"grad",null),__decorate([doc_1.doc({heading:"Training",subheading:"Gradients"})],e,"grads",null),__decorate([doc_1.doc({heading:"Training",subheading:"Gradients"})],e,"valueAndGrad",null),__decorate([doc_1.doc({heading:"Training",subheading:"Gradients"})],e,"valueAndGrads",null),__decorate([doc_1.doc({heading:"Training",subheading:"Gradients"})],e,"variableGrads",null),__decorate([doc_1.doc({heading:"Training",subheading:"Gradients"})],e,"customGrad",null),e}();function checkGrads(e){if(0<e.filter(function(e){return null==e}).length)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.")}exports.Gradients=Gradients;