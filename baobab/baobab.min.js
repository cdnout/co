import Emitter from"emmett";import Cursor from"./cursor";import{MonkeyDefinition,Monkey}from"./monkey";import Watcher from"./watcher";import type from"./type";import update from"./update";import*as helpers from"./helpers";const{arrayFrom:arrayFrom,coercePath:coercePath,deepFreeze:deepFreeze,getIn:getIn,makeError:makeError,deepClone:deepClone,deepMerge:deepMerge,shallowClone:shallowClone,shallowMerge:shallowMerge,hashPath:hashPath}=helpers,DEFAULTS={autoCommit:!0,asynchronous:!0,immutable:!0,lazyMonkeys:!0,monkeyBusiness:!0,persistent:!0,pure:!0,validate:null,validationBehavior:"rollback"};class Baobab extends Emitter{constructor(t,e){if(super(),arguments.length<1&&(t={}),!type.object(t)&&!type.array(t))throw makeError("Baobab: invalid data.",{data:t});this.options=shallowMerge({},DEFAULTS,e),this.options.persistent||(this.options.immutable=!1,this.options.pure=!1),this._identity="[object Baobab]",this._cursors={},this._future=null,this._transaction=[],this._affectedPathsIndex={},this._monkeys={},this._previousData=null,this._data=t,this.root=new Cursor(this,[],"λ"),delete this.root.release,this.options.immutable&&deepFreeze(this._data);["apply","clone","concat","deepClone","deepMerge","exists","get","push","merge","pop","project","serialize","set","shift","splice","unset","unshift"].forEach(t=>{this[t]=function(){const e=this.root[t].apply(this.root,arguments);return e instanceof Cursor?this:e}}),this.options.monkeyBusiness&&this._refreshMonkeys();const s=this.validate();if(s)throw Error("Baobab: invalid data.",{error:s})}_refreshMonkeys(t,e,s){const o=(t,e=[])=>{if(t instanceof Monkey)return t.release(),void update(this._monkeys,e,{type:"unset"},{immutable:!1,persistent:!1,pure:!1});if(type.object(t))for(const s in t)o(t[s],e.concat(s))},a=(t,e=[])=>{if(t instanceof MonkeyDefinition||t instanceof Monkey){const s=new Monkey(this,e,t instanceof Monkey?t.definition:t);update(this._monkeys,e,{type:"set",value:s},{immutable:!1,persistent:!1,pure:!1})}else if(type.object(t))for(const s in t)a(t[s],e.concat(s))};if(arguments.length){const i=getIn(this._monkeys,e).data;i&&o(i,e),"unset"!==s&&a(t,e)}else a(this._data);return this}validate(t){const{validate:e,validationBehavior:s}=this.options;if("function"!=typeof e)return null;const o=e.call(this,this._previousData,this._data,t||[[]]);return o instanceof Error?("rollback"===s&&(this._data=this._previousData,this._affectedPathsIndex={},this._transaction=[],this._previousData=this._data),this.emit("invalid",{error:o}),o):null}select(t){if(t=t||[],arguments.length>1&&(t=arrayFrom(arguments)),!type.path(t))throw makeError("Baobab.select: invalid path.",{path:t});t=[].concat(t);const e=hashPath(t);let s=this._cursors[e];return s||(s=new Cursor(this,t,e),this._cursors[e]=s),this.emit("select",{path:t,cursor:s}),s}update(t,e){if(t=coercePath(t),!type.operationType(e.type))throw makeError(`Baobab.update: unknown operation type "${e.type}".`,{operation:e});const{solvedPath:s,exists:o}=getIn(this._data,t);if(!s)throw makeError("Baobab.update: could not solve the given path.",{path:s});const a=type.monkeyPath(this._monkeys,s);if(a&&s.length>a.length)throw makeError("Baobab.update: attempting to update a read-only path.",{path:s});if("unset"===e.type&&!o)return;let i=e;if(/merge/i.test(e.type)){const t=getIn(this._monkeys,s).data;if(type.object(t)){i=shallowClone(i);const e=getIn(this._data,s).data;/deep/i.test(i.type)?i.value=deepMerge({},deepMerge({},e,deepClone(t)),i.value):i.value=shallowMerge({},deepMerge({},e,deepClone(t)),i.value)}}this._transaction.length||(this._previousData=this._data);const n=update(this._data,s,i,this.options),{data:r,node:h}=n;if(!("data"in n))return h;const p=s.concat("push"===e.type?h.length-1:[]),l=hashPath(p);return this._data=r,this._affectedPathsIndex[l]=!0,this._transaction.push(shallowMerge({},e,{path:p})),this.options.monkeyBusiness&&this._refreshMonkeys(h,s,e.type),this.emit("write",{path:p}),this.options.autoCommit?this.options.asynchronous?(this._future||(this._future=setTimeout(()=>this.commit(),0)),h):(this.commit(),h):h}commit(){if(!this._transaction.length)return this;this._future&&(this._future=clearTimeout(this._future));const t=Object.keys(this._affectedPathsIndex).map(t=>"λ"!==t?t.split("λ").slice(1):[]);if(this.validate(t))return this;const e=this._transaction,s=this._previousData;return this._affectedPathsIndex={},this._transaction=[],this._previousData=this._data,this.emit("update",{paths:t,currentData:this._data,transaction:e,previousData:s}),this}getMonkey(t){t=coercePath(t);const e=getIn(this._monkeys,[].concat(t)).data;return e instanceof Monkey?e:null}watch(t){return new Watcher(this,t)}release(){let t;for(t in this.emit("release"),delete this.root,delete this._data,delete this._previousData,delete this._transaction,delete this._affectedPathsIndex,delete this._monkeys,this._cursors)this._cursors[t].release();delete this._cursors,this.kill()}toJSON(){return this.serialize()}toString(){return this._identity}}Baobab.monkey=function(...t){if(!t.length)throw new Error("Baobab.monkey: missing definition.");return 1===t.length&&"function"!=typeof t[0]?new MonkeyDefinition(t[0]):new MonkeyDefinition(t)},Baobab.dynamicNode=Baobab.monkey;export const monkey=Baobab.monkey;export const dynamic=Baobab.dynamic;export{Cursor,MonkeyDefinition,Monkey,type,helpers};Baobab.VERSION="2.6.1";export const VERSION=Baobab.VERSION;export default Baobab;