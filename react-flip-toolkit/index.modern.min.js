import e,{createContext as t,Component as i,Children as r,cloneElement as n}from"react";import"prop-types";import{getFlippedElementPositionsBeforeUpdate as s,onFlipKeyUpdate as l,utilities as o,constants as p,spring as a}from"flip-toolkit";const d=t({}),c=t("portal");class h extends i{constructor(){super(...arguments),this.inProgressAnimations={},this.flipCallbacks={},this.el=void 0}getSnapshotBeforeUpdate(e){return e.flipKey!==this.props.flipKey&&this.el?s({element:this.el,flipCallbacks:this.flipCallbacks,inProgressAnimations:this.inProgressAnimations,portalKey:this.props.portalKey}):null}componentDidUpdate(e,t,i){this.props.flipKey!==e.flipKey&&this.el&&l({flippedElementPositionsBeforeUpdate:i.flippedElementPositions,cachedOrderedFlipIds:i.cachedOrderedFlipIds,containerEl:this.el,inProgressAnimations:this.inProgressAnimations,flipCallbacks:this.flipCallbacks,applyTransformOrigin:this.props.applyTransformOrigin,spring:this.props.spring,debug:this.props.debug,portalKey:this.props.portalKey,staggerConfig:this.props.staggerConfig,handleEnterUpdateDelete:this.props.handleEnterUpdateDelete,decisionData:{previous:e.decisionData,current:this.props.decisionData},onComplete:this.props.onComplete,onStart:this.props.onStart})}render(){const{element:t,className:i,portalKey:n}=this.props;let r=e.createElement(d.Provider,{value:this.flipCallbacks},e.createElement(t,{className:i,ref:e=>this.el=e},this.props.children));return n&&(r=e.createElement(c.Provider,{value:n},r)),r}}function m(e,t){if(null==e)return{};var i,n,r={},s=Object.keys(e);for(n=0;n<s.length;n++)t.indexOf(i=s[n])>=0||(r[i]=e[i]);return r}h.defaultProps={applyTransformOrigin:!0,element:"div"};const f=e=>{let{children:t,flipId:i,inverseFlipId:s,portalKey:l}=e,a=m(e,["children","flipId","inverseFlipId","portalKey"]),d=t;const c=function(e){return"function"==typeof d}();if(!c)try{d=r.only(t)}catch(e){throw new Error("Each Flipped component must wrap a single child")}a.scale||a.translate||a.opacity||o.assign(a,{translate:!0,scale:!0,opacity:!0});const h={[p.DATA_FLIP_CONFIG]:JSON.stringify(a)};return void 0!==i?h[p.DATA_FLIP_ID]=String(i):s&&(h[p.DATA_INVERSE_FLIP_ID]=String(s)),void 0!==l&&(h[p.DATA_PORTAL_KEY]=l),c?d(h):n(d,h)},u=t=>{let{children:i,flipId:n,shouldFlip:r,shouldInvert:s,onAppear:p,onStart:l,onStartImmediate:a,onComplete:h,onExit:u,onSpringUpdate:g}=t,y=m(t,["children","flipId","shouldFlip","shouldInvert","onAppear","onStart","onStartImmediate","onComplete","onExit","onSpringUpdate"]);return i?y.inverseFlipId?e.createElement(f,Object.assign({},y),i):e.createElement(c.Consumer,null,t=>e.createElement(d.Consumer,null,d=>(o.isObject(d)&&n&&(d[n]={shouldFlip:r,shouldInvert:s,onAppear:p,onStart:l,onStartImmediate:a,onComplete:h,onExit:u,onSpringUpdate:g}),e.createElement(f,Object.assign({flipId:n},y,{portalKey:t}),i)))):null};u.displayName="Flipped";const g=({children:e})=>n(e,{[p.DATA_EXIT_CONTAINER]:!0});export{g as ExitContainer,u as Flipped,h as Flipper,a as spring};