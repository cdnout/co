"use strict";function F(){return!1}function T(){return!0}function add(t,e){return 1===arguments.length?e=>add(t,e):Number(t)+Number(e)}function curry(t,e=[]){return(...r)=>(e=>e.length>=t.length?t(...e):curry(t,e))([...e,...r])}function adjustFn(t,e,r){const n=t<0?r.length+t:t;if(t>=r.length||n<0)return r;const o=r.slice();return o[n]=e(o[n]),o}Object.defineProperty(exports,"__esModule",{value:!0});const adjust=curry(adjustFn);function all(t,e){if(1===arguments.length)return e=>all(t,e);for(let r=0;r<e.length;r++)if(!t(e[r]))return!1;return!0}function allPass(t){return e=>{let r=0;for(;r<t.length;){if(!t[r](e))return!1;r++}return!0}}function always(t){return()=>t}function and(t,e){return 1===arguments.length?e=>and(t,e):t&&e}function any(t,e){if(1===arguments.length)return e=>any(t,e);let r=0;for(;r<e.length;){if(t(e[r],r))return!0;r++}return!1}function anyPass(t){return e=>{let r=0;for(;r<t.length;){if(t[r](e))return!0;r++}return!1}}function append(t,e){if(1===arguments.length)return e=>append(t,e);if("string"==typeof e)return e.split("").concat(t);const r=e.slice();return r.push(t),r}const _isArray=Array.isArray;function __findHighestArity(t,e=0){for(const r in t)!1!==t.hasOwnProperty(r)&&"constructor"!==r&&("object"==typeof t[r]&&(e=Math.max(e,__findHighestArity(t[r]))),"function"==typeof t[r]&&(e=Math.max(e,t[r].length)));return e}function __filterUndefined(){const t=[];let e=0;const r=arguments.length;for(;e<r&&void 0!==arguments[e];)t[e]=arguments[e],e++;return t}function __applySpecWithArity(t,e,r){const n=e-r.length;if(1===n)return n=>__applySpecWithArity(t,e,__filterUndefined(...r,n));if(2===n)return(n,o)=>__applySpecWithArity(t,e,__filterUndefined(...r,n,o));if(3===n)return(n,o,i)=>__applySpecWithArity(t,e,__filterUndefined(...r,n,o,i));if(4===n)return(n,o,i,s)=>__applySpecWithArity(t,e,__filterUndefined(...r,n,o,i,s));if(n>4)return(...n)=>__applySpecWithArity(t,e,__filterUndefined(...r,...n));if(_isArray(t)){const n=[];let o=0;const i=t.length;for(;o<i;o++)("object"==typeof t[o]||_isArray(t[o]))&&(n[o]=__applySpecWithArity(t[o],e,r)),"function"==typeof t[o]&&(n[o]=t[o](...r));return n}const o={};for(const n in t)!1!==t.hasOwnProperty(n)&&"constructor"!==n&&("object"!=typeof t[n]?"function"==typeof t[n]&&(o[n]=t[n](...r)):o[n]=__applySpecWithArity(t[n],e,r));return o}function applySpec(t,...e){const r=__findHighestArity(t);return 0===r?()=>({}):__applySpecWithArity(t,r,e)}function assocFn(t,e,r){return Object.assign({},r,{[t]:e})}const assoc=curry(assocFn);function _isInteger(t){return t<<0===t}var _isInteger$1=Number.isInteger||_isInteger;function assocPathFn(t,e,r){const n="string"==typeof t?t.split(".").map(t=>_isInteger(Number(t))?Number(t):t):t;if(0===n.length)return e;const o=n[0];if(n.length>1){const t="object"!=typeof r||null===r||!r.hasOwnProperty(o)?_isInteger(n[1])?[]:{}:r[o];e=assocPathFn(Array.prototype.slice.call(n,1),e,t)}if(_isInteger(o)&&_isArray(r)){const t=r.slice();return t[o]=e,t}return assoc(o,e,r)}const assocPath=curry(assocPathFn);function both(t,e){return 1===arguments.length?e=>both(t,e):(...r)=>t(...r)&&e(...r)}function chain(t,e){return 1===arguments.length?e=>chain(t,e):[].concat(...e.map(t))}function clampFn(t,e,r){if(t>e)throw new Error("min must not be greater than max in clamp(min, max, value)");return r>=t&&r<=e?r:r>e?e:r<t?t:void 0}const clamp=curry(clampFn);function clone(t){const e=_isArray(t)?Array(t.length):{};if(t&&t.getTime)return new Date(t.getTime());for(const r in t){const n=t[r];e[r]="object"==typeof n&&null!==n?n.getTime?new Date(n.getTime()):clone(n):n}return e}function complement(t){return(...e)=>!t(...e)}function compose(...t){if(0===t.length)throw new Error("compose requires at least one argument");return(...e)=>{const r=t.slice();if(r.length>0){let t=r.pop()(...e);for(;r.length>0;)t=r.pop()(t);return t}}}function concat(t,e){return 1===arguments.length?e=>concat(t,e):"string"==typeof t?`${t}${e}`:[...t,...e]}function cond(t){return e=>{let r,n=!1;return t.forEach(([t,o])=>{!n&&t(e)&&(n=!0,r=o(e))}),r}}function _curryN(t,e,r){return function(){let n=0,o=0;const i=e.length,s=arguments.length,u=new Array(i+s);for(;n<i;)u[n]=e[n],n++;for(;o<s;)u[i+o]=arguments[o],o++;const c=t-u.length;return u.length>=t?r.apply(this,u):_arity(c,_curryN(t,u,r))}}function _arity(t,e){switch(t){case 0:return function(){return e.apply(this,arguments)};case 1:return function(t){return e.apply(this,arguments)};case 2:return function(t,r){return e.apply(this,arguments)};case 3:return function(t,r,n){return e.apply(this,arguments)};case 4:return function(t,r,n,o){return e.apply(this,arguments)};case 5:return function(t,r,n,o,i){return e.apply(this,arguments)};case 6:return function(t,r,n,o,i,s){return e.apply(this,arguments)};case 7:return function(t,r,n,o,i,s,u){return e.apply(this,arguments)};case 8:return function(t,r,n,o,i,s,u,c){return e.apply(this,arguments)};case 9:return function(t,r,n,o,i,s,u,c,p){return e.apply(this,arguments)};default:return function(t,r,n,o,i,s,u,c,p,l){return e.apply(this,arguments)}}}function curryN(t,e){if(1===arguments.length)return e=>curryN(t,e);if(t>10)throw new Error("First argument to _arity must be a non-negative integer no greater than ten");return _arity(t,_curryN(t,[],e))}const _keys=Object.keys;function mapArray(t,e,r=!1){let n=0;const o=Array(e.length);for(;n<e.length;)o[n]=r?t(e[n],n):t(e[n]),n++;return o}function mapObject(t,e){let r=0;const n=_keys(e),o=n.length,i={};for(;r<o;){const o=n[r];i[o]=t(e[o],o,e),r++}return i}function map(t,e){return 1===arguments.length?e=>map(t,e):void 0===e?[]:_isArray(e)?mapArray(t,e):mapObject(t,e)}function max(t,e){return 1===arguments.length?e=>max(t,e):e>t?e:t}function reduceFn(t,e,r){if(!_isArray(r))throw new TypeError("reduce: list must be array or iterable");let n=0;const o=r.length;for(;n<o;)e=t(e,r[n],n,r),n++;return e}const reduce=curry(reduceFn);function converge(t,e){if(1===arguments.length)return e=>converge(t,e);return curryN(reduce((t,e)=>max(t,e.length),0,e),function(){return t.apply(this,map(t=>t.apply(this,arguments),e))})}const dec=t=>t-1;function isFalsy(t){return null==t||!0===Number.isNaN(t)}function defaultTo(t,e){return 1===arguments.length?e=>defaultTo(t,e):isFalsy(e)?t:e}function type(t){const e=typeof t;if(null===t)return"Null";if(void 0===t)return"Undefined";if("boolean"===e)return"Boolean";if("number"===e)return Number.isNaN(t)?"NaN":"Number";if("string"===e)return"String";if(_isArray(t))return"Array";if("symbol"===e)return"Symbol";if(t instanceof RegExp)return"RegExp";const r=t&&t.toString?t.toString():"";return["true","false"].includes(r)?"Boolean":Number.isNaN(Number(r))?r.startsWith("async")?"Async":"[object Promise]"===r?"Promise":"function"===e?"Function":t instanceof String?"String":"Object":"Number"}function parseError(t){const e=t.__proto__.toString();return["Error","TypeError"].includes(e)?[e,t.message]:[]}function parseDate(t){return t.toDateString?[!0,t.getTime()]:[!1]}function parseRegex(t){return t.constructor!==RegExp?[!1]:[!0,t.toString()]}function equals(t,e){if(1===arguments.length)return e=>equals(t,e);const r=type(t);if(r!==type(e))return!1;if("Function"===r)return void 0!==t.name&&t.name===e.name;if(["NaN","Undefined","Null"].includes(r))return!0;if("Number"===r)return Object.is(-0,t)===Object.is(-0,e)&&t.toString()===e.toString();if(["String","Boolean"].includes(r))return t.toString()===e.toString();if("Array"===r){const r=Array.from(t),n=Array.from(e);if(r.toString()!==n.toString())return!1;let o=!0;return r.forEach((t,e)=>{o&&(t===n[e]||equals(t,n[e])||(o=!1))}),o}const n=parseRegex(t),o=parseRegex(e);if(n[0])return!!o[0]&&n[1]===o[1];if(o[0])return!1;const i=parseDate(t),s=parseDate(e);if(i[0])return!!s[0]&&i[1]===s[1];if(s[0])return!1;const u=parseError(t),c=parseError(e);if(u[0])return!!c[0]&&(u[0]===c[0]&&u[1]===c[1]);if("Object"===r){const r=Object.keys(t);if(r.length!==Object.keys(e).length)return!1;let n=!0;return r.forEach(r=>{if(n){const o=t[r],i=e[r];o===i||equals(o,i)||(n=!1)}}),n}return!1}function includesArray(t,e){let r=-1;for(;++r<e.length;)if(equals(e[r],t))return!0;return!1}function includes(t,e){if(1===arguments.length)return e=>includes(t,e);if("string"==typeof e)return e.includes(t);if(!e)throw new TypeError(`Cannot read property 'indexOf' of ${e}`);return!!_isArray(e)&&includesArray(t,e)}function uniq(t){let e=-1;const r=[];for(;++e<t.length;){const n=t[e];includes(n,r)||r.push(n)}return r}function difference(t,e){return 1===arguments.length?e=>difference(t,e):uniq(t).filter(t=>!includes(t,e))}function dissoc(t,e){if(1===arguments.length)return e=>dissoc(t,e);if(null==e)return{};const r={};for(const t in e)r[t]=e[t];return delete r[t],r}function divide(t,e){return 1===arguments.length?e=>divide(t,e):t/e}function drop(t,e){return 1===arguments.length?e=>drop(t,e):e.slice(t>0?t:0)}function dropLast(t,e){return 1===arguments.length?e=>dropLast(t,e):t>0?e.slice(0,-t):e.slice()}function dropLastWhile(t,e){if(1===arguments.length)return e=>dropLastWhile(t,e);if(0===e.length)return e;const r=_isArray(e);if("function"!=typeof t)throw new Error(`'predicate' is from wrong type ${typeof t}`);if(!r&&"string"!=typeof e)throw new Error(`'iterable' is from wrong type ${typeof e}`);let n=!1;const o=[];let i=e.length;for(;i>0;)i--,n||!1!==t(e[i])?n&&o.push(e[i]):(n=!0,o.push(e[i]));return r?o.reverse():o.reverse().join("")}function dropRepeats(t){if(!_isArray(t))throw new Error(`${t} is not a list`);const e=[];return t.reduce((t,r)=>(equals(t,r)||e.push(r),r),void 0),e}function dropRepeatsWith(t,e){if(1===arguments.length)return e=>dropRepeatsWith(t,e);if(!_isArray(e))throw new Error(`${e} is not a list`);const r=[];return e.reduce((e,n)=>void 0===e?(r.push(n),n):(t(e,n)||r.push(n),n),void 0),r}function dropWhile(t,e){if(1===arguments.length)return e=>dropWhile(t,e);const r=_isArray(e);if(!r&&"string"!=typeof e)throw new Error("`iterable` is neither list nor a string");let n=!1;const o=[];let i=-1;for(;i++<e.length-1;)n?o.push(e[i]):t(e[i])||(n||(n=!0),o.push(e[i]));return r?o:o.join("")}function either(t,e){return 1===arguments.length?e=>either(t,e):(...r)=>Boolean(t(...r)||e(...r))}function endsWith(t,e){return 1===arguments.length?e=>endsWith(t,e):e.endsWith(t)}function eqPropsFn(t,e,r){if(!e||!r)throw new Error("wrong object inputs are passed to R.eqProps");return equals(e[t],r[t])}const eqProps=curry(eqPropsFn);function evolveArray(t,e){return mapArray((e,r)=>"Function"===type(t[r])?t[r](e):e,e,!0)}function evolveObject(t,e){return mapObject((e,r)=>{if("Object"===type(e)){const n=type(t[r]);return"Function"===n?t[r](e):"Object"===n?evolve(t[r],e):e}return"Function"===type(t[r])?t[r](e):e},e)}function evolve(t,e){if(1===arguments.length)return e=>evolve(t,e);const r=type(t),n=type(e);if(n!==r)throw new Error("iterableType !== rulesType");if(!["Object","Array"].includes(r))throw new Error(`'iterable' and 'rules' are from wrong type ${r}`);return"Object"===n?evolveObject(t,e):evolveArray(t,e)}function filterObject(t,e){const r={};for(const n in e)t(e[n],n,e)&&(r[n]=e[n]);return r}function filterArray(t,e,r=!1){let n=0;const o=e.length,i=[];for(;n<o;){(r?t(e[n],n):t(e[n]))&&i.push(e[n]),n++}return i}function filter(t,e){return 1===arguments.length?e=>filter(t,e):e?_isArray(e)?filterArray(t,e):filterObject(t,e):[]}function find(t,e){if(1===arguments.length)return e=>find(t,e);let r=0;const n=e.length;for(;r<n;){const n=e[r];if(t(n))return n;r++}}function findIndex(t,e){if(1===arguments.length)return e=>findIndex(t,e);const r=e.length;let n=-1;for(;++n<r;)if(t(e[n]))return n;return-1}function findLast(t,e){if(1===arguments.length)return e=>findLast(t,e);let r=e.length;for(;--r>=0;)if(t(e[r]))return e[r]}function findLastIndex(t,e){if(1===arguments.length)return e=>findLastIndex(t,e);let r=e.length;for(;--r>=0;)if(t(e[r]))return r;return-1}function flatten(t,e){const r=void 0===e?[]:e;for(let e=0;e<t.length;e++)_isArray(t[e])?flatten(t[e],r):r.push(t[e]);return r}function flipFn(t){return(...e)=>{if(1===e.length)return r=>t(r,e[0]);if(2===e.length)return t(e[1],e[0]);if(3===e.length)return t(e[1],e[0],e[2]);if(4===e.length)return t(e[1],e[0],e[2],e[3]);throw new Error("R.flip doesn't work with arity > 4")}}function flip(t){return flipFn(t)}function forEach(t,e){if(1===arguments.length)return e=>forEach(t,e);if(void 0!==e){if(_isArray(e)){let r=0;const n=e.length;for(;r<n;)t(e[r]),r++}else{let r=0;const n=_keys(e),o=n.length;for(;r<o;){const o=n[r];t(e[o],o,e),r++}}return e}}function fromPairs(t){const e={};return t.forEach(([t,r])=>e[t]=r),e}function groupBy(t,e){if(1===arguments.length)return e=>groupBy(t,e);const r={};for(let n=0;n<e.length;n++){const o=e[n],i=t(o);r[i]||(r[i]=[]),r[i].push(o)}return r}function groupWith(t,e){if(!_isArray(e))throw new TypeError("list.reduce is not a function");const r=e.slice();if(1===e.length)return[r];const n=[];let o=[];return r.reduce((r,i,s)=>{if(0===s)return i;const u=t(r,i),c=0===o.length,p=s===e.length-1;return u?(c&&o.push(r),o.push(i),p&&n.push(o),i):c?(n.push([r]),p&&n.push([i]),i):(n.push(o),p&&n.push([i]),o=[],i)},void 0),n}function has(t,e){return 1===arguments.length?e=>has(t,e):!!e&&void 0!==e[t]}function path(t,e){if(1===arguments.length)return e=>path(t,e);if(null==e)return;let r=e,n=0;const o="string"==typeof t?t.split("."):t;for(;n<o.length;){if(null==r)return;r=r[o[n]],n++}return r}function hasPath(t,e){return 1===arguments.length?e=>hasPath(t,e):void 0!==path(t,e)}function head(t){return"string"==typeof t?t[0]||"":t[0]}function _objectIs(t,e){return t===e?0!==t||1/t==1/e:t!=t&&e!=e}var _objectIs$1=Object.is||_objectIs;function identical(t,e){return 1===arguments.length?e=>identical(t,e):_objectIs$1(t,e)}function identity(t){return t}function ifElseFn(t,e,r){return(...n)=>{return!0===("boolean"==typeof t?t:t(...n))?e(...n):r(...n)}}const ifElse=curry(ifElseFn),inc=t=>t+1;function indexByPath(t,e){const r={};for(let n=0;n<e.length;n++){const o=e[n];r[path(t,o)]=o}return r}function indexBy(t,e){if(1===arguments.length)return e=>indexBy(t,e);if("string"==typeof t)return indexByPath(t,e);const r={};for(let n=0;n<e.length;n++){const o=e[n];r[t(o)]=o}return r}function indexOf(t,e){if(1===arguments.length)return e=>indexOf(t,e);let r=-1;const{length:n}=e;for(;++r<n;)if(e[r]===t)return r;return-1}function baseSlice(t,e,r){let n=-1,{length:o}=t;(r=r>o?o:r)<0&&(r+=o),o=e>r?0:r-e>>>0,e>>>=0;const i=Array(o);for(;++n<o;)i[n]=t[n+e];return i}function init(t){return"string"==typeof t?t.slice(0,-1):t.length?baseSlice(t,0,-1):[]}function intersection(t,e){return 1===arguments.length?e=>intersection(t,e):filter(t=>includes(t,e),t)}function intersperse(t,e){if(1===arguments.length)return e=>intersperse(t,e);let r=-1;const n=e.length,o=[];for(;++r<n;)r===n-1?o.push(e[r]):o.push(e[r],t);return o}function is(t,e){return 1===arguments.length?e=>is(t,e):null!=e&&e.constructor===t||e instanceof t}function isEmpty(t){const e=type(t);return!["Undefined","NaN","Number","Null"].includes(e)&&(!t||("Object"===e?0===Object.keys(t).length:"Array"===e&&0===t.length))}function isNil(t){return null==t}function join(t,e){return 1===arguments.length?e=>join(t,e):e.join(t)}function keys(t){return Object.keys(t)}function last(t){return"string"==typeof t?t[t.length-1]||"":t[t.length-1]}function lastIndexOf(t,e){if(1===arguments.length)return e=>lastIndexOf(t,e);let r=e.length;for(;--r>0;)if(equals(e[r],t))return r;return-1}function length(t){return!t&&""!==t||void 0===t.length?NaN:t.length}function lens(t,e){return function(r){return function(n){return r(t(n)).map(t=>e(t,n))}}}function nth(t,e){if(1===arguments.length)return e=>nth(t,e);const r=t<0?e.length+t:t;return"[object String]"===Object.prototype.toString.call(e)?e.charAt(r):e[r]}function updateFn(t,e,r){return r.slice().fill(e,t,t+1)}const update=curry(updateFn);function lensIndex(t){return lens(nth(t),update(t))}function lensPath(t){return lens(path(t),assocPath(t))}function prop(t,e){return 1===arguments.length?e=>prop(t,e):e?e[t]:void 0}function lensProp(t){return lens(prop(t),assoc(t))}function match(t,e){if(1===arguments.length)return e=>match(t,e);const r=e.match(t);return null===r?[]:r}function mathMod(t,e){return 1===arguments.length?e=>mathMod(t,e):!_isInteger$1(t)||!_isInteger$1(e)||e<1?NaN:(t%e+e)%e}function maxByFn(t,e,r){return t(r)>t(e)?r:e}const maxBy=curry(maxByFn);function sum(t){return t.reduce((t,e)=>t+e,0)}function mean(t){return sum(t)/t.length}function median(t){const e=t.length;if(0===e)return NaN;const r=2-e%2,n=(e-r)/2;return mean(Array.prototype.slice.call(t,0).sort((t,e)=>t===e?0:t<e?-1:1).slice(n,n+r))}function merge(t,e){return 1===arguments.length?e=>merge(t,e):Object.assign({},t||{},e||{})}function mergeAll(t){let e={};return map(t=>{e=merge(e,t)},t),e}function mergeDeepRight(t,e){if(1===arguments.length)return e=>mergeDeepRight(t,e);const r=JSON.parse(JSON.stringify(t));return Object.keys(e).forEach(n=>{"Object"===type(e[n])&&"Object"===type(t[n])?r[n]=mergeDeepRight(t[n],e[n]):r[n]=e[n]}),r}function mergeLeft(t,e){return 1===arguments.length?e=>mergeLeft(t,e):merge(e,t)}function min(t,e){return 1===arguments.length?e=>min(t,e):e<t?e:t}function minByFn(t,e,r){return t(r)<t(e)?r:e}const minBy=curry(minByFn);function modulo(t,e){return 1===arguments.length?e=>modulo(t,e):t%e}function moveFn(t,e,r){if(t<0||e<0)throw new Error("Rambda.move does not support negative indexes");if(t>r.length-1||e>r.length-1)return r;const n=r.slice();return n[t]=r[e],n[e]=r[t],n}const move=curry(moveFn);function multiply(t,e){return 1===arguments.length?e=>multiply(t,e):t*e}function negate(t){return-t}function none(t,e){if(1===arguments.length)return e=>none(t,e);for(let r=0;r<e.length;r++)if(!t(e[r]))return!0;return!1}function not(t){return!t}function of(t){return[t]}function omit(t,e){if(1===arguments.length)return e=>omit(t,e);if(null==e)return;const r="string"==typeof t?t.split(","):t,n={};for(const t in e)r.includes(t)||(n[t]=e[t]);return n}function onceFn(t,e){let r;return function(){return t&&(r=t.apply(e||this,arguments),t=null),r}}function once(t,e){if(1===arguments.length){return curry(onceFn(t,e))}return onceFn(t,e)}function or(t,e){return 1===arguments.length?e=>or(t,e):t||e}const Identity=t=>({x:t,map:e=>Identity(e(t))});function overFn(t,e,r){return t(t=>Identity(e(t)))(r).x}const over=curry(overFn);function partial(t,...e){const r=t.length;return(...n)=>e.length+n.length>=r?t(...e,...n):partial(t,...[...e,...n])}function partitionObject(t,e){const r={},n={};return Object.entries(e).forEach(([e,o])=>{t(o,e)?r[e]=o:n[e]=o}),[r,n]}function partitionArray(t,e){const r=[],n=[];let o=-1;for(;o++<e.length-1;)t(e[o])?r.push(e[o]):n.push(e[o]);return[r,n]}function partition(t,e){return 1===arguments.length?e=>partition(t,e):_isArray(e)?partitionArray(t,e):partitionObject(t,e)}function pathEqFn(t,e,r){return equals(path(t,r),e)}const pathEq=curry(pathEqFn);function pathOrFn(t,e,r){return defaultTo(t,path(e,r))}const pathOr=curry(pathOrFn);function paths(t,e){return 1===arguments.length?e=>paths(t,e):t.map(t=>path(t,e))}function pick(t,e){if(1===arguments.length)return e=>pick(t,e);if(null==e)return;const r="string"==typeof t?t.split(","):t,n={};let o=0;for(;o<r.length;)r[o]in e&&(n[r[o]]=e[r[o]]),o++;return n}function pickAll(t,e){if(1===arguments.length)return e=>pickAll(t,e);if(null==e)return;const r="string"==typeof t?t.split(","):t,n={};let o=0;for(;o<r.length;)r[o]in e?n[r[o]]=e[r[o]]:n[r[o]]=void 0,o++;return n}function pipe(...t){if(0===t.length)throw new Error("pipe requires at least one argument");return(...e)=>{const r=t.slice();if(r.length>0){let t=r.shift()(...e);for(;r.length>0;)t=r.shift()(t);return t}}}function pluck(t,e){if(1===arguments.length)return e=>pluck(t,e);const r=[];return map(e=>{void 0!==e[t]&&r.push(e[t])},e),r}function prepend(t,e){return 1===arguments.length?e=>prepend(t,e):[t].concat("string"==typeof e?e.split(""):e)}const product=reduce(multiply,1);function propEqFn(t,e,r){return!!r&&r[t]===e}const propEq=curry(propEqFn);function propIsFn(t,e,r){return is(t,r[e])}const propIs=curry(propIsFn);function propOrFn(t,e,r){return r?defaultTo(t,r[e]):t}const propOr=curry(propOrFn);function props(t,e){if(1===arguments.length)return e=>props(t,e);if(!_isArray(t))throw new Error("propsToPick is not a list");return mapArray(t=>e[t],t)}function range(t,e){if(1===arguments.length)return e=>range(t,e);if(Number.isNaN(Number(t))||Number.isNaN(Number(e)))throw new TypeError("Both arguments to range must be numbers");if(e<t)return[];const r=e-t,n=Array(r);for(let e=0;e<r;e++)n[e]=t+e;return n}function reject(t,e){return 1===arguments.length?e=>reject(t,e):filter(e=>!t(e),e)}function repeat(t,e){return 1===arguments.length?e=>repeat(t,e):Array(e).fill(t)}function replaceFn(t,e,r){return r.replace(t,e)}const replace=curry(replaceFn);function reverse(t){if("string"==typeof t)return t.split("").reverse().join("");return t.slice().reverse()}function setFn(t,e,r){return over(t,always(e),r)}const set=curry(setFn);function sliceFn(t,e,r){return r.slice(t,e)}const slice=curry(sliceFn);function sort(t,e){if(1===arguments.length)return e=>sort(t,e);return e.slice().sort(t)}function sortBy(t,e){if(1===arguments.length)return e=>sortBy(t,e);return e.slice().sort((e,r)=>{const n=t(e),o=t(r);return n===o?0:n<o?-1:1})}function split(t,e){return 1===arguments.length?e=>split(t,e):e.split(t)}function maybe(t,e,r){const n=t&&"Function"===type(e)?e():e,o=t||"Function"!==type(r)?r:r();return t?n:o}function take(t,e){return 1===arguments.length?e=>take(t,e):t<0?e.slice():"string"==typeof e?e.slice(0,t):baseSlice(e,0,t)}function splitAt(t,e){if(1===arguments.length)return e=>splitAt(t,e);if(!e)throw new TypeError(`Cannot read property 'slice' of ${e}`);if(!_isArray(e)&&"string"!=typeof e)return[[],[]];const r=maybe(t<0,e.length+t<0?0:e.length+t,t);return[take(r,e),drop(r,e)]}function splitEvery(t,e){if(1===arguments.length)return e=>splitEvery(t,e);if(t<1)throw new Error("First argument to splitEvery must be a positive integer");const r=[];let n=0;for(;n<e.length;)r.push(e.slice(n,n+=t));return r}function splitWhen(t,e){if(1===arguments.length)return e=>splitWhen(t,e);if(!e)throw new TypeError(`Cannot read property 'length' of ${e}`);const r=[],n=[];let o=!1,i=-1;for(;i++<e.length-1;)o?n.push(e[i]):t(e[i])?(n.push(e[i]),o=!0):r.push(e[i]);return[r,n]}function startsWith(t,e){return 1===arguments.length?e=>startsWith(t,e):e.startsWith(t)}function subtract(t,e){return 1===arguments.length?e=>subtract(t,e):t-e}function symmetricDifference(t,e){return 1===arguments.length?e=>symmetricDifference(t,e):concat(filter(t=>!includes(t,e),t),filter(e=>!includes(e,t),e))}function tail(t){return drop(1,t)}function takeLast(t,e){if(1===arguments.length)return e=>takeLast(t,e);const r=e.length;if(t<0)return e.slice();let n=t>r?r:t;return"string"==typeof e?e.slice(r-n):baseSlice(e,n=r-n,r)}function takeLastWhile(t,e){if(1===arguments.length)return e=>takeLastWhile(t,e);if(0===e.length)return e;let r=!1;const n=[];let o=e.length;for(;!r||0===o;)!1===t(e[--o])?r=!0:r||n.push(e[o]);return _isArray(e)?n.reverse():n.reverse().join("")}function takeWhile(t,e){if(1===arguments.length)return e=>takeWhile(t,e);const r=_isArray(e);if(!r&&"string"!=typeof e)throw new Error("`iterable` is neither list nor a string");let n=!0;const o=[];let i=-1;for(;i++<e.length-1;)t(e[i])?n&&o.push(e[i]):n&&(n=!1);return r?o:o.join("")}function tap(t,e){return 1===arguments.length?e=>tap(t,e):(t(e),e)}function test(t,e){if(1===arguments.length)return e=>test(t,e);if("string"==typeof t)throw new TypeError(`‘test’ requires a value of type RegExp as its first argument; received "${t}"`);return-1!==e.search(t)}function times(t,e){if(1===arguments.length)return e=>times(t,e);if(!Number.isInteger(e)||e<0)throw new RangeError("n must be an integer");return map(t,range(0,e))}function toLower(t){return t.toLowerCase()}function toPairs(t){return Object.entries(t)}function toString(t){return t.toString()}function toUpper(t){return t.toUpperCase()}function transpose(t){return t.reduce((t,e)=>(e.forEach((e,r)=>_isArray(t[r])?t[r].push(e):t.push([e])),t),[])}function trim(t){return t.trim()}function isFunction(t){return["Async","Function"].includes(type(t))}function tryCatch(t,e){if(!isFunction(t))throw new Error(`R.tryCatch | fn '${t}'`);const r=isFunction(e);return(...n)=>{try{return t(...n)}catch(t){return r?e(t,...n):e}}}function union(t,e){if(1===arguments.length)return e=>union(t,e);const r=t.slice();return e.forEach(e=>{includes(e,t)||r.push(e)}),r}function uniqWith(t,e){if(1===arguments.length)return e=>uniqWith(t,e);let r=-1;const n=e.length,o=[];for(;++r<n;){const n=e[r];any(e=>t(n,e),o)||o.push(n)}return o}function unless(t,e){return 1===arguments.length?e=>unless(t,e):r=>t(r)?r:e(r)}function values(t){return"Object"!==type(t)?[]:Object.values(t)}const Const=t=>({x:t,map:e=>Const(t)});function view(t,e){return 1===arguments.length?e=>view(t,e):t(Const)(e).x}function whenFn(t,e,r){return t(r)?e(r):r}const when=curry(whenFn);function where(t,e){if(void 0===e)return e=>where(t,e);let r=!0;for(const n in t){const o=t[n](e[n]);r&&!1===o&&(r=!1)}return r}function whereEq(t,e){if(1===arguments.length)return e=>whereEq(t,e);const r=filter((t,r)=>equals(t,e[r]),t);return Object.keys(r).length===Object.keys(t).length}function without(t,e){return void 0===e?e=>without(t,e):reduce((e,r)=>includesArray(r,t)?e:e.concat(r),[],e)}function xor(t,e){return 1===arguments.length?e=>xor(t,e):Boolean(t)&&!e||Boolean(e)&&!t}function zip(t,e){if(1===arguments.length)return e=>zip(t,e);const r=[],n=Math.min(t.length,e.length);for(let o=0;o<n;o++)r[o]=[t[o],e[o]];return r}function zipObj(t,e){return 1===arguments.length?e=>zipObj(t,e):take(e.length,t).reduce((t,r,n)=>(t[r]=e[n],t),{})}function zipWithFn(t,e,r){return take(e.length>r.length?r.length:e.length,e).map((e,n)=>t(e,r[n]))}const zipWith=curry(zipWithFn);exports.F=F,exports.T=T,exports.add=add,exports.adjust=adjust,exports.all=all,exports.allPass=allPass,exports.always=always,exports.and=and,exports.any=any,exports.anyPass=anyPass,exports.append=append,exports.applySpec=applySpec,exports.assoc=assoc,exports.assocPath=assocPath,exports.both=both,exports.chain=chain,exports.clamp=clamp,exports.clone=clone,exports.complement=complement,exports.compose=compose,exports.concat=concat,exports.cond=cond,exports.converge=converge,exports.curry=curry,exports.curryN=curryN,exports.dec=dec,exports.defaultTo=defaultTo,exports.difference=difference,exports.dissoc=dissoc,exports.divide=divide,exports.drop=drop,exports.dropLast=dropLast,exports.dropLastWhile=dropLastWhile,exports.dropRepeats=dropRepeats,exports.dropRepeatsWith=dropRepeatsWith,exports.dropWhile=dropWhile,exports.either=either,exports.endsWith=endsWith,exports.eqProps=eqProps,exports.equals=equals,exports.evolve=evolve,exports.evolveArray=evolveArray,exports.evolveObject=evolveObject,exports.filter=filter,exports.filterArray=filterArray,exports.filterObject=filterObject,exports.find=find,exports.findIndex=findIndex,exports.findLast=findLast,exports.findLastIndex=findLastIndex,exports.flatten=flatten,exports.flip=flip,exports.forEach=forEach,exports.fromPairs=fromPairs,exports.groupBy=groupBy,exports.groupWith=groupWith,exports.has=has,exports.hasPath=hasPath,exports.head=head,exports.identical=identical,exports.identity=identity,exports.ifElse=ifElse,exports.inc=inc,exports.includes=includes,exports.includesArray=includesArray,exports.indexBy=indexBy,exports.indexOf=indexOf,exports.init=init,exports.intersection=intersection,exports.intersperse=intersperse,exports.is=is,exports.isEmpty=isEmpty,exports.isNil=isNil,exports.join=join,exports.keys=keys,exports.last=last,exports.lastIndexOf=lastIndexOf,exports.length=length,exports.lens=lens,exports.lensIndex=lensIndex,exports.lensPath=lensPath,exports.lensProp=lensProp,exports.map=map,exports.mapArray=mapArray,exports.mapObject=mapObject,exports.match=match,exports.mathMod=mathMod,exports.max=max,exports.maxBy=maxBy,exports.maxByFn=maxByFn,exports.mean=mean,exports.median=median,exports.merge=merge,exports.mergeAll=mergeAll,exports.mergeDeepRight=mergeDeepRight,exports.mergeLeft=mergeLeft,exports.min=min,exports.minBy=minBy,exports.minByFn=minByFn,exports.modulo=modulo,exports.move=move,exports.multiply=multiply,exports.negate=negate,exports.none=none,exports.not=not,exports.nth=nth,exports.of=of,exports.omit=omit,exports.once=once,exports.or=or,exports.over=over,exports.partial=partial,exports.partition=partition,exports.partitionArray=partitionArray,exports.partitionObject=partitionObject,exports.path=path,exports.pathEq=pathEq,exports.pathOr=pathOr,exports.paths=paths,exports.pick=pick,exports.pickAll=pickAll,exports.pipe=pipe,exports.pluck=pluck,exports.prepend=prepend,exports.product=product,exports.prop=prop,exports.propEq=propEq,exports.propIs=propIs,exports.propOr=propOr,exports.props=props,exports.range=range,exports.reduce=reduce,exports.reject=reject,exports.repeat=repeat,exports.replace=replace,exports.reverse=reverse,exports.set=set,exports.slice=slice,exports.sort=sort,exports.sortBy=sortBy,exports.split=split,exports.splitAt=splitAt,exports.splitEvery=splitEvery,exports.splitWhen=splitWhen,exports.startsWith=startsWith,exports.subtract=subtract,exports.sum=sum,exports.symmetricDifference=symmetricDifference,exports.tail=tail,exports.take=take,exports.takeLast=takeLast,exports.takeLastWhile=takeLastWhile,exports.takeWhile=takeWhile,exports.tap=tap,exports.test=test,exports.times=times,exports.toLower=toLower,exports.toPairs=toPairs,exports.toString=toString,exports.toUpper=toUpper,exports.transpose=transpose,exports.trim=trim,exports.tryCatch=tryCatch,exports.type=type,exports.union=union,exports.uniq=uniq,exports.uniqWith=uniqWith,exports.unless=unless,exports.update=update,exports.values=values,exports.view=view,exports.when=when,exports.where=where,exports.whereEq=whereEq,exports.without=without,exports.xor=xor,exports.zip=zip,exports.zipObj=zipObj,exports.zipWith=zipWith;