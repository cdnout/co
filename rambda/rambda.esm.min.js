function F(){return!1}function T(){return!0}function add(t,n){return 1===arguments.length?n=>add(t,n):Number(t)+Number(n)}function curry(t,n=[]){return(...r)=>(n=>n.length>=t.length?t(...n):curry(t,n))([...n,...r])}function adjustFn(t,n,r){const e=t<0?r.length+t:t;if(t>=r.length||e<0)return r;const i=r.slice();return i[e]=n(i[e]),i}const adjust=curry(adjustFn);function all(t,n){if(1===arguments.length)return n=>all(t,n);for(let r=0;r<n.length;r++)if(!t(n[r]))return!1;return!0}function allPass(t){return n=>{let r=0;for(;r<t.length;){if(!t[r](n))return!1;r++}return!0}}function always(t){return()=>t}function and(t,n){return 1===arguments.length?n=>and(t,n):t&&n}function any(t,n){if(1===arguments.length)return n=>any(t,n);let r=0;for(;r<n.length;){if(t(n[r],r))return!0;r++}return!1}function anyPass(t){return n=>{let r=0;for(;r<t.length;){if(t[r](n))return!0;r++}return!1}}function append(t,n){if(1===arguments.length)return n=>append(t,n);if("string"==typeof n)return n.split("").concat(t);const r=n.slice();return r.push(t),r}const _isArray=Array.isArray;function __findHighestArity(t,n=0){for(const r in t)!1!==t.hasOwnProperty(r)&&"constructor"!==r&&("object"==typeof t[r]&&(n=Math.max(n,__findHighestArity(t[r]))),"function"==typeof t[r]&&(n=Math.max(n,t[r].length)));return n}function __filterUndefined(){const t=[];let n=0;const r=arguments.length;for(;n<r&&void 0!==arguments[n];)t[n]=arguments[n],n++;return t}function __applySpecWithArity(t,n,r){const e=n-r.length;if(1===e)return e=>__applySpecWithArity(t,n,__filterUndefined(...r,e));if(2===e)return(e,i)=>__applySpecWithArity(t,n,__filterUndefined(...r,e,i));if(3===e)return(e,i,o)=>__applySpecWithArity(t,n,__filterUndefined(...r,e,i,o));if(4===e)return(e,i,o,u)=>__applySpecWithArity(t,n,__filterUndefined(...r,e,i,o,u));if(e>4)return(...e)=>__applySpecWithArity(t,n,__filterUndefined(...r,...e));if(_isArray(t)){const e=[];let i=0;const o=t.length;for(;i<o;i++)("object"==typeof t[i]||_isArray(t[i]))&&(e[i]=__applySpecWithArity(t[i],n,r)),"function"==typeof t[i]&&(e[i]=t[i](...r));return e}const i={};for(const e in t)!1!==t.hasOwnProperty(e)&&"constructor"!==e&&("object"!=typeof t[e]?"function"==typeof t[e]&&(i[e]=t[e](...r)):i[e]=__applySpecWithArity(t[e],n,r));return i}function applySpec(t,...n){const r=__findHighestArity(t);return 0===r?()=>({}):__applySpecWithArity(t,r,n)}function assocFn(t,n,r){return Object.assign({},r,{[t]:n})}const assoc=curry(assocFn);function _isInteger(t){return t<<0===t}var _isInteger$1=Number.isInteger||_isInteger;function assocPathFn(t,n,r){const e="string"==typeof t?t.split(".").map(t=>_isInteger(Number(t))?Number(t):t):t;if(0===e.length)return n;const i=e[0];if(e.length>1){const t="object"!=typeof r||null===r||!r.hasOwnProperty(i)?_isInteger(e[1])?[]:{}:r[i];n=assocPathFn(Array.prototype.slice.call(e,1),n,t)}if(_isInteger(i)&&_isArray(r)){const t=r.slice();return t[i]=n,t}return assoc(i,n,r)}const assocPath=curry(assocPathFn);function both(t,n){return 1===arguments.length?n=>both(t,n):(...r)=>t(...r)&&n(...r)}function chain(t,n){return 1===arguments.length?n=>chain(t,n):[].concat(...n.map(t))}function clampFn(t,n,r){if(t>n)throw new Error("min must not be greater than max in clamp(min, max, value)");return r>=t&&r<=n?r:r>n?n:r<t?t:void 0}const clamp=curry(clampFn);function clone(t){const n=_isArray(t)?Array(t.length):{};if(t&&t.getTime)return new Date(t.getTime());for(const r in t){const e=t[r];n[r]="object"==typeof e&&null!==e?e.getTime?new Date(e.getTime()):clone(e):e}return n}function complement(t){return(...n)=>!t(...n)}function compose(...t){if(0===t.length)throw new Error("compose requires at least one argument");return(...n)=>{const r=t.slice();if(r.length>0){let t=r.pop()(...n);for(;r.length>0;)t=r.pop()(t);return t}}}function concat(t,n){return 1===arguments.length?n=>concat(t,n):"string"==typeof t?`${t}${n}`:[...t,...n]}function cond(t){return n=>{let r,e=!1;return t.forEach(([t,i])=>{!e&&t(n)&&(e=!0,r=i(n))}),r}}function _curryN(t,n,r){return function(){let e=0,i=0;const o=n.length,u=arguments.length,c=new Array(o+u);for(;e<o;)c[e]=n[e],e++;for(;i<u;)c[o+i]=arguments[i],i++;const s=t-c.length;return c.length>=t?r.apply(this,c):_arity(s,_curryN(t,c,r))}}function _arity(t,n){switch(t){case 0:return function(){return n.apply(this,arguments)};case 1:return function(t){return n.apply(this,arguments)};case 2:return function(t,r){return n.apply(this,arguments)};case 3:return function(t,r,e){return n.apply(this,arguments)};case 4:return function(t,r,e,i){return n.apply(this,arguments)};case 5:return function(t,r,e,i,o){return n.apply(this,arguments)};case 6:return function(t,r,e,i,o,u){return n.apply(this,arguments)};case 7:return function(t,r,e,i,o,u,c){return n.apply(this,arguments)};case 8:return function(t,r,e,i,o,u,c,s){return n.apply(this,arguments)};case 9:return function(t,r,e,i,o,u,c,s,l){return n.apply(this,arguments)};default:return function(t,r,e,i,o,u,c,s,l,f){return n.apply(this,arguments)}}}function curryN(t,n){if(1===arguments.length)return n=>curryN(t,n);if(t>10)throw new Error("First argument to _arity must be a non-negative integer no greater than ten");return _arity(t,_curryN(t,[],n))}const _keys=Object.keys;function mapArray(t,n,r=!1){let e=0;const i=Array(n.length);for(;e<n.length;)i[e]=r?t(n[e],e):t(n[e]),e++;return i}function mapObject(t,n){let r=0;const e=_keys(n),i=e.length,o={};for(;r<i;){const i=e[r];o[i]=t(n[i],i,n),r++}return o}function map(t,n){return 1===arguments.length?n=>map(t,n):void 0===n?[]:_isArray(n)?mapArray(t,n):mapObject(t,n)}function max(t,n){return 1===arguments.length?n=>max(t,n):n>t?n:t}function reduceFn(t,n,r){if(!_isArray(r))throw new TypeError("reduce: list must be array or iterable");let e=0;const i=r.length;for(;e<i;)n=t(n,r[e],e,r),e++;return n}const reduce=curry(reduceFn);function converge(t,n){if(1===arguments.length)return n=>converge(t,n);return curryN(reduce((t,n)=>max(t,n.length),0,n),function(){return t.apply(this,map(t=>t.apply(this,arguments),n))})}const dec=t=>t-1;function isFalsy(t){return null==t||!0===Number.isNaN(t)}function defaultTo(t,n){return 1===arguments.length?n=>defaultTo(t,n):isFalsy(n)?t:n}function type(t){const n=typeof t;if(null===t)return"Null";if(void 0===t)return"Undefined";if("boolean"===n)return"Boolean";if("number"===n)return Number.isNaN(t)?"NaN":"Number";if("string"===n)return"String";if(_isArray(t))return"Array";if("symbol"===n)return"Symbol";if(t instanceof RegExp)return"RegExp";const r=t&&t.toString?t.toString():"";return["true","false"].includes(r)?"Boolean":Number.isNaN(Number(r))?r.startsWith("async")?"Async":"[object Promise]"===r?"Promise":"function"===n?"Function":t instanceof String?"String":"Object":"Number"}function parseError(t){const n=t.__proto__.toString();return["Error","TypeError"].includes(n)?[n,t.message]:[]}function parseDate(t){return t.toDateString?[!0,t.getTime()]:[!1]}function parseRegex(t){return t.constructor!==RegExp?[!1]:[!0,t.toString()]}function equals(t,n){if(1===arguments.length)return n=>equals(t,n);const r=type(t);if(r!==type(n))return!1;if("Function"===r)return void 0!==t.name&&t.name===n.name;if(["NaN","Undefined","Null"].includes(r))return!0;if("Number"===r)return Object.is(-0,t)===Object.is(-0,n)&&t.toString()===n.toString();if(["String","Boolean"].includes(r))return t.toString()===n.toString();if("Array"===r){const r=Array.from(t),e=Array.from(n);if(r.toString()!==e.toString())return!1;let i=!0;return r.forEach((t,n)=>{i&&(t===e[n]||equals(t,e[n])||(i=!1))}),i}const e=parseRegex(t),i=parseRegex(n);if(e[0])return!!i[0]&&e[1]===i[1];if(i[0])return!1;const o=parseDate(t),u=parseDate(n);if(o[0])return!!u[0]&&o[1]===u[1];if(u[0])return!1;const c=parseError(t),s=parseError(n);if(c[0])return!!s[0]&&(c[0]===s[0]&&c[1]===s[1]);if("Object"===r){const r=Object.keys(t);if(r.length!==Object.keys(n).length)return!1;let e=!0;return r.forEach(r=>{if(e){const i=t[r],o=n[r];i===o||equals(i,o)||(e=!1)}}),e}return!1}function includesArray(t,n){let r=-1;for(;++r<n.length;)if(equals(n[r],t))return!0;return!1}function includes(t,n){if(1===arguments.length)return n=>includes(t,n);if("string"==typeof n)return n.includes(t);if(!n)throw new TypeError(`Cannot read property 'indexOf' of ${n}`);return!!_isArray(n)&&includesArray(t,n)}function uniq(t){let n=-1;const r=[];for(;++n<t.length;){const e=t[n];includes(e,r)||r.push(e)}return r}function difference(t,n){return 1===arguments.length?n=>difference(t,n):uniq(t).filter(t=>!includes(t,n))}function dissoc(t,n){if(1===arguments.length)return n=>dissoc(t,n);if(null==n)return{};const r={};for(const t in n)r[t]=n[t];return delete r[t],r}function divide(t,n){return 1===arguments.length?n=>divide(t,n):t/n}function drop(t,n){return 1===arguments.length?n=>drop(t,n):n.slice(t>0?t:0)}function dropLast(t,n){return 1===arguments.length?n=>dropLast(t,n):t>0?n.slice(0,-t):n.slice()}function dropLastWhile(t,n){if(1===arguments.length)return n=>dropLastWhile(t,n);if(0===n.length)return n;const r=_isArray(n);if("function"!=typeof t)throw new Error(`'predicate' is from wrong type ${typeof t}`);if(!r&&"string"!=typeof n)throw new Error(`'iterable' is from wrong type ${typeof n}`);let e=!1;const i=[];let o=n.length;for(;o>0;)o--,e||!1!==t(n[o])?e&&i.push(n[o]):(e=!0,i.push(n[o]));return r?i.reverse():i.reverse().join("")}function dropRepeats(t){if(!_isArray(t))throw new Error(`${t} is not a list`);const n=[];return t.reduce((t,r)=>(equals(t,r)||n.push(r),r),void 0),n}function dropRepeatsWith(t,n){if(1===arguments.length)return n=>dropRepeatsWith(t,n);if(!_isArray(n))throw new Error(`${n} is not a list`);const r=[];return n.reduce((n,e)=>void 0===n?(r.push(e),e):(t(n,e)||r.push(e),e),void 0),r}function dropWhile(t,n){if(1===arguments.length)return n=>dropWhile(t,n);const r=_isArray(n);if(!r&&"string"!=typeof n)throw new Error("`iterable` is neither list nor a string");let e=!1;const i=[];let o=-1;for(;o++<n.length-1;)e?i.push(n[o]):t(n[o])||(e||(e=!0),i.push(n[o]));return r?i:i.join("")}function either(t,n){return 1===arguments.length?n=>either(t,n):(...r)=>Boolean(t(...r)||n(...r))}function endsWith(t,n){return 1===arguments.length?n=>endsWith(t,n):n.endsWith(t)}function eqPropsFn(t,n,r){if(!n||!r)throw new Error("wrong object inputs are passed to R.eqProps");return equals(n[t],r[t])}const eqProps=curry(eqPropsFn);function evolveArray(t,n){return mapArray((n,r)=>"Function"===type(t[r])?t[r](n):n,n,!0)}function evolveObject(t,n){return mapObject((n,r)=>{if("Object"===type(n)){const e=type(t[r]);return"Function"===e?t[r](n):"Object"===e?evolve(t[r],n):n}return"Function"===type(t[r])?t[r](n):n},n)}function evolve(t,n){if(1===arguments.length)return n=>evolve(t,n);const r=type(t),e=type(n);if(e!==r)throw new Error("iterableType !== rulesType");if(!["Object","Array"].includes(r))throw new Error(`'iterable' and 'rules' are from wrong type ${r}`);return"Object"===e?evolveObject(t,n):evolveArray(t,n)}function filterObject(t,n){const r={};for(const e in n)t(n[e],e,n)&&(r[e]=n[e]);return r}function filterArray(t,n,r=!1){let e=0;const i=n.length,o=[];for(;e<i;){(r?t(n[e],e):t(n[e]))&&o.push(n[e]),e++}return o}function filter(t,n){return 1===arguments.length?n=>filter(t,n):n?_isArray(n)?filterArray(t,n):filterObject(t,n):[]}function find(t,n){if(1===arguments.length)return n=>find(t,n);let r=0;const e=n.length;for(;r<e;){const e=n[r];if(t(e))return e;r++}}function findIndex(t,n){if(1===arguments.length)return n=>findIndex(t,n);const r=n.length;let e=-1;for(;++e<r;)if(t(n[e]))return e;return-1}function findLast(t,n){if(1===arguments.length)return n=>findLast(t,n);let r=n.length;for(;--r>=0;)if(t(n[r]))return n[r]}function findLastIndex(t,n){if(1===arguments.length)return n=>findLastIndex(t,n);let r=n.length;for(;--r>=0;)if(t(n[r]))return r;return-1}function flatten(t,n){const r=void 0===n?[]:n;for(let n=0;n<t.length;n++)_isArray(t[n])?flatten(t[n],r):r.push(t[n]);return r}function flipFn(t){return(...n)=>{if(1===n.length)return r=>t(r,n[0]);if(2===n.length)return t(n[1],n[0]);if(3===n.length)return t(n[1],n[0],n[2]);if(4===n.length)return t(n[1],n[0],n[2],n[3]);throw new Error("R.flip doesn't work with arity > 4")}}function flip(t){return flipFn(t)}function forEach(t,n){if(1===arguments.length)return n=>forEach(t,n);if(void 0!==n){if(_isArray(n)){let r=0;const e=n.length;for(;r<e;)t(n[r]),r++}else{let r=0;const e=_keys(n),i=e.length;for(;r<i;){const i=e[r];t(n[i],i,n),r++}}return n}}function fromPairs(t){const n={};return t.forEach(([t,r])=>n[t]=r),n}function groupBy(t,n){if(1===arguments.length)return n=>groupBy(t,n);const r={};for(let e=0;e<n.length;e++){const i=n[e],o=t(i);r[o]||(r[o]=[]),r[o].push(i)}return r}function groupWith(t,n){if(!_isArray(n))throw new TypeError("list.reduce is not a function");const r=n.slice();if(1===n.length)return[r];const e=[];let i=[];return r.reduce((r,o,u)=>{if(0===u)return o;const c=t(r,o),s=0===i.length,l=u===n.length-1;return c?(s&&i.push(r),i.push(o),l&&e.push(i),o):s?(e.push([r]),l&&e.push([o]),o):(e.push(i),l&&e.push([o]),i=[],o)},void 0),e}function has(t,n){return 1===arguments.length?n=>has(t,n):!!n&&void 0!==n[t]}function path(t,n){if(1===arguments.length)return n=>path(t,n);if(null==n)return;let r=n,e=0;const i="string"==typeof t?t.split("."):t;for(;e<i.length;){if(null==r)return;r=r[i[e]],e++}return r}function hasPath(t,n){return 1===arguments.length?n=>hasPath(t,n):void 0!==path(t,n)}function head(t){return"string"==typeof t?t[0]||"":t[0]}function _objectIs(t,n){return t===n?0!==t||1/t==1/n:t!=t&&n!=n}var _objectIs$1=Object.is||_objectIs;function identical(t,n){return 1===arguments.length?n=>identical(t,n):_objectIs$1(t,n)}function identity(t){return t}function ifElseFn(t,n,r){return(...e)=>{return!0===("boolean"==typeof t?t:t(...e))?n(...e):r(...e)}}const ifElse=curry(ifElseFn),inc=t=>t+1;function indexByPath(t,n){const r={};for(let e=0;e<n.length;e++){const i=n[e];r[path(t,i)]=i}return r}function indexBy(t,n){if(1===arguments.length)return n=>indexBy(t,n);if("string"==typeof t)return indexByPath(t,n);const r={};for(let e=0;e<n.length;e++){const i=n[e];r[t(i)]=i}return r}function indexOf(t,n){if(1===arguments.length)return n=>indexOf(t,n);let r=-1;const{length:e}=n;for(;++r<e;)if(n[r]===t)return r;return-1}function baseSlice(t,n,r){let e=-1,{length:i}=t;(r=r>i?i:r)<0&&(r+=i),i=n>r?0:r-n>>>0,n>>>=0;const o=Array(i);for(;++e<i;)o[e]=t[e+n];return o}function init(t){return"string"==typeof t?t.slice(0,-1):t.length?baseSlice(t,0,-1):[]}function intersection(t,n){return 1===arguments.length?n=>intersection(t,n):filter(t=>includes(t,n),t)}function intersperse(t,n){if(1===arguments.length)return n=>intersperse(t,n);let r=-1;const e=n.length,i=[];for(;++r<e;)r===e-1?i.push(n[r]):i.push(n[r],t);return i}function is(t,n){return 1===arguments.length?n=>is(t,n):null!=n&&n.constructor===t||n instanceof t}function isEmpty(t){const n=type(t);return!["Undefined","NaN","Number","Null"].includes(n)&&(!t||("Object"===n?0===Object.keys(t).length:"Array"===n&&0===t.length))}function isNil(t){return null==t}function join(t,n){return 1===arguments.length?n=>join(t,n):n.join(t)}function keys(t){return Object.keys(t)}function last(t){return"string"==typeof t?t[t.length-1]||"":t[t.length-1]}function lastIndexOf(t,n){if(1===arguments.length)return n=>lastIndexOf(t,n);let r=n.length;for(;--r>0;)if(equals(n[r],t))return r;return-1}function length(t){return!t&&""!==t||void 0===t.length?NaN:t.length}function lens(t,n){return function(r){return function(e){return r(t(e)).map(t=>n(t,e))}}}function nth(t,n){if(1===arguments.length)return n=>nth(t,n);const r=t<0?n.length+t:t;return"[object String]"===Object.prototype.toString.call(n)?n.charAt(r):n[r]}function updateFn(t,n,r){return r.slice().fill(n,t,t+1)}const update=curry(updateFn);function lensIndex(t){return lens(nth(t),update(t))}function lensPath(t){return lens(path(t),assocPath(t))}function prop(t,n){return 1===arguments.length?n=>prop(t,n):n?n[t]:void 0}function lensProp(t){return lens(prop(t),assoc(t))}function match(t,n){if(1===arguments.length)return n=>match(t,n);const r=n.match(t);return null===r?[]:r}function mathMod(t,n){return 1===arguments.length?n=>mathMod(t,n):!_isInteger$1(t)||!_isInteger$1(n)||n<1?NaN:(t%n+n)%n}function maxByFn(t,n,r){return t(r)>t(n)?r:n}const maxBy=curry(maxByFn);function sum(t){return t.reduce((t,n)=>t+n,0)}function mean(t){return sum(t)/t.length}function median(t){const n=t.length;if(0===n)return NaN;const r=2-n%2,e=(n-r)/2;return mean(Array.prototype.slice.call(t,0).sort((t,n)=>t===n?0:t<n?-1:1).slice(e,e+r))}function merge(t,n){return 1===arguments.length?n=>merge(t,n):Object.assign({},t||{},n||{})}function mergeAll(t){let n={};return map(t=>{n=merge(n,t)},t),n}function mergeDeepRight(t,n){if(1===arguments.length)return n=>mergeDeepRight(t,n);const r=JSON.parse(JSON.stringify(t));return Object.keys(n).forEach(e=>{"Object"===type(n[e])&&"Object"===type(t[e])?r[e]=mergeDeepRight(t[e],n[e]):r[e]=n[e]}),r}function mergeLeft(t,n){return 1===arguments.length?n=>mergeLeft(t,n):merge(n,t)}function min(t,n){return 1===arguments.length?n=>min(t,n):n<t?n:t}function minByFn(t,n,r){return t(r)<t(n)?r:n}const minBy=curry(minByFn);function modulo(t,n){return 1===arguments.length?n=>modulo(t,n):t%n}function moveFn(t,n,r){if(t<0||n<0)throw new Error("Rambda.move does not support negative indexes");if(t>r.length-1||n>r.length-1)return r;const e=r.slice();return e[t]=r[n],e[n]=r[t],e}const move=curry(moveFn);function multiply(t,n){return 1===arguments.length?n=>multiply(t,n):t*n}function negate(t){return-t}function none(t,n){if(1===arguments.length)return n=>none(t,n);for(let r=0;r<n.length;r++)if(!t(n[r]))return!0;return!1}function not(t){return!t}function of(t){return[t]}function omit(t,n){if(1===arguments.length)return n=>omit(t,n);if(null==n)return;const r="string"==typeof t?t.split(","):t,e={};for(const t in n)r.includes(t)||(e[t]=n[t]);return e}function onceFn(t,n){let r;return function(){return t&&(r=t.apply(n||this,arguments),t=null),r}}function once(t,n){if(1===arguments.length){return curry(onceFn(t,n))}return onceFn(t,n)}function or(t,n){return 1===arguments.length?n=>or(t,n):t||n}const Identity=t=>({x:t,map:n=>Identity(n(t))});function overFn(t,n,r){return t(t=>Identity(n(t)))(r).x}const over=curry(overFn);function partial(t,...n){const r=t.length;return(...e)=>n.length+e.length>=r?t(...n,...e):partial(t,...[...n,...e])}function partitionObject(t,n){const r={},e={};return Object.entries(n).forEach(([n,i])=>{t(i,n)?r[n]=i:e[n]=i}),[r,e]}function partitionArray(t,n){const r=[],e=[];let i=-1;for(;i++<n.length-1;)t(n[i])?r.push(n[i]):e.push(n[i]);return[r,e]}function partition(t,n){return 1===arguments.length?n=>partition(t,n):_isArray(n)?partitionArray(t,n):partitionObject(t,n)}function pathEqFn(t,n,r){return equals(path(t,r),n)}const pathEq=curry(pathEqFn);function pathOrFn(t,n,r){return defaultTo(t,path(n,r))}const pathOr=curry(pathOrFn);function paths(t,n){return 1===arguments.length?n=>paths(t,n):t.map(t=>path(t,n))}function pick(t,n){if(1===arguments.length)return n=>pick(t,n);if(null==n)return;const r="string"==typeof t?t.split(","):t,e={};let i=0;for(;i<r.length;)r[i]in n&&(e[r[i]]=n[r[i]]),i++;return e}function pickAll(t,n){if(1===arguments.length)return n=>pickAll(t,n);if(null==n)return;const r="string"==typeof t?t.split(","):t,e={};let i=0;for(;i<r.length;)r[i]in n?e[r[i]]=n[r[i]]:e[r[i]]=void 0,i++;return e}function pipe(...t){if(0===t.length)throw new Error("pipe requires at least one argument");return(...n)=>{const r=t.slice();if(r.length>0){let t=r.shift()(...n);for(;r.length>0;)t=r.shift()(t);return t}}}function pluck(t,n){if(1===arguments.length)return n=>pluck(t,n);const r=[];return map(n=>{void 0!==n[t]&&r.push(n[t])},n),r}function prepend(t,n){return 1===arguments.length?n=>prepend(t,n):[t].concat("string"==typeof n?n.split(""):n)}const product=reduce(multiply,1);function propEqFn(t,n,r){return!!r&&r[t]===n}const propEq=curry(propEqFn);function propIsFn(t,n,r){return is(t,r[n])}const propIs=curry(propIsFn);function propOrFn(t,n,r){return r?defaultTo(t,r[n]):t}const propOr=curry(propOrFn);function props(t,n){if(1===arguments.length)return n=>props(t,n);if(!_isArray(t))throw new Error("propsToPick is not a list");return mapArray(t=>n[t],t)}function range(t,n){if(1===arguments.length)return n=>range(t,n);if(Number.isNaN(Number(t))||Number.isNaN(Number(n)))throw new TypeError("Both arguments to range must be numbers");if(n<t)return[];const r=n-t,e=Array(r);for(let n=0;n<r;n++)e[n]=t+n;return e}function reject(t,n){return 1===arguments.length?n=>reject(t,n):filter(n=>!t(n),n)}function repeat(t,n){return 1===arguments.length?n=>repeat(t,n):Array(n).fill(t)}function replaceFn(t,n,r){return r.replace(t,n)}const replace=curry(replaceFn);function reverse(t){if("string"==typeof t)return t.split("").reverse().join("");return t.slice().reverse()}function setFn(t,n,r){return over(t,always(n),r)}const set=curry(setFn);function sliceFn(t,n,r){return r.slice(t,n)}const slice=curry(sliceFn);function sort(t,n){if(1===arguments.length)return n=>sort(t,n);return n.slice().sort(t)}function sortBy(t,n){if(1===arguments.length)return n=>sortBy(t,n);return n.slice().sort((n,r)=>{const e=t(n),i=t(r);return e===i?0:e<i?-1:1})}function split(t,n){return 1===arguments.length?n=>split(t,n):n.split(t)}function maybe(t,n,r){const e=t&&"Function"===type(n)?n():n,i=t||"Function"!==type(r)?r:r();return t?e:i}function take(t,n){return 1===arguments.length?n=>take(t,n):t<0?n.slice():"string"==typeof n?n.slice(0,t):baseSlice(n,0,t)}function splitAt(t,n){if(1===arguments.length)return n=>splitAt(t,n);if(!n)throw new TypeError(`Cannot read property 'slice' of ${n}`);if(!_isArray(n)&&"string"!=typeof n)return[[],[]];const r=maybe(t<0,n.length+t<0?0:n.length+t,t);return[take(r,n),drop(r,n)]}function splitEvery(t,n){if(1===arguments.length)return n=>splitEvery(t,n);if(t<1)throw new Error("First argument to splitEvery must be a positive integer");const r=[];let e=0;for(;e<n.length;)r.push(n.slice(e,e+=t));return r}function splitWhen(t,n){if(1===arguments.length)return n=>splitWhen(t,n);if(!n)throw new TypeError(`Cannot read property 'length' of ${n}`);const r=[],e=[];let i=!1,o=-1;for(;o++<n.length-1;)i?e.push(n[o]):t(n[o])?(e.push(n[o]),i=!0):r.push(n[o]);return[r,e]}function startsWith(t,n){return 1===arguments.length?n=>startsWith(t,n):n.startsWith(t)}function subtract(t,n){return 1===arguments.length?n=>subtract(t,n):t-n}function symmetricDifference(t,n){return 1===arguments.length?n=>symmetricDifference(t,n):concat(filter(t=>!includes(t,n),t),filter(n=>!includes(n,t),n))}function tail(t){return drop(1,t)}function takeLast(t,n){if(1===arguments.length)return n=>takeLast(t,n);const r=n.length;if(t<0)return n.slice();let e=t>r?r:t;return"string"==typeof n?n.slice(r-e):baseSlice(n,e=r-e,r)}function takeLastWhile(t,n){if(1===arguments.length)return n=>takeLastWhile(t,n);if(0===n.length)return n;let r=!1;const e=[];let i=n.length;for(;!r||0===i;)!1===t(n[--i])?r=!0:r||e.push(n[i]);return _isArray(n)?e.reverse():e.reverse().join("")}function takeWhile(t,n){if(1===arguments.length)return n=>takeWhile(t,n);const r=_isArray(n);if(!r&&"string"!=typeof n)throw new Error("`iterable` is neither list nor a string");let e=!0;const i=[];let o=-1;for(;o++<n.length-1;)t(n[o])?e&&i.push(n[o]):e&&(e=!1);return r?i:i.join("")}function tap(t,n){return 1===arguments.length?n=>tap(t,n):(t(n),n)}function test(t,n){if(1===arguments.length)return n=>test(t,n);if("string"==typeof t)throw new TypeError(`‘test’ requires a value of type RegExp as its first argument; received "${t}"`);return-1!==n.search(t)}function times(t,n){if(1===arguments.length)return n=>times(t,n);if(!Number.isInteger(n)||n<0)throw new RangeError("n must be an integer");return map(t,range(0,n))}function toLower(t){return t.toLowerCase()}function toPairs(t){return Object.entries(t)}function toString(t){return t.toString()}function toUpper(t){return t.toUpperCase()}function transpose(t){return t.reduce((t,n)=>(n.forEach((n,r)=>_isArray(t[r])?t[r].push(n):t.push([n])),t),[])}function trim(t){return t.trim()}function isFunction(t){return["Async","Function"].includes(type(t))}function tryCatch(t,n){if(!isFunction(t))throw new Error(`R.tryCatch | fn '${t}'`);const r=isFunction(n);return(...e)=>{try{return t(...e)}catch(t){return r?n(t,...e):n}}}function union(t,n){if(1===arguments.length)return n=>union(t,n);const r=t.slice();return n.forEach(n=>{includes(n,t)||r.push(n)}),r}function uniqWith(t,n){if(1===arguments.length)return n=>uniqWith(t,n);let r=-1;const e=n.length,i=[];for(;++r<e;){const e=n[r];any(n=>t(e,n),i)||i.push(e)}return i}function unless(t,n){return 1===arguments.length?n=>unless(t,n):r=>t(r)?r:n(r)}function values(t){return"Object"!==type(t)?[]:Object.values(t)}const Const=t=>({x:t,map:n=>Const(t)});function view(t,n){return 1===arguments.length?n=>view(t,n):t(Const)(n).x}function whenFn(t,n,r){return t(r)?n(r):r}const when=curry(whenFn);function where(t,n){if(void 0===n)return n=>where(t,n);let r=!0;for(const e in t){const i=t[e](n[e]);r&&!1===i&&(r=!1)}return r}function whereEq(t,n){if(1===arguments.length)return n=>whereEq(t,n);const r=filter((t,r)=>equals(t,n[r]),t);return Object.keys(r).length===Object.keys(t).length}function without(t,n){return void 0===n?n=>without(t,n):reduce((n,r)=>includesArray(r,t)?n:n.concat(r),[],n)}function xor(t,n){return 1===arguments.length?n=>xor(t,n):Boolean(t)&&!n||Boolean(n)&&!t}function zip(t,n){if(1===arguments.length)return n=>zip(t,n);const r=[],e=Math.min(t.length,n.length);for(let i=0;i<e;i++)r[i]=[t[i],n[i]];return r}function zipObj(t,n){return 1===arguments.length?n=>zipObj(t,n):take(n.length,t).reduce((t,r,e)=>(t[r]=n[e],t),{})}function zipWithFn(t,n,r){return take(n.length>r.length?r.length:n.length,n).map((n,e)=>t(n,r[e]))}const zipWith=curry(zipWithFn);export{F,T,add,adjust,all,allPass,always,and,any,anyPass,append,applySpec,assoc,assocPath,both,chain,clamp,clone,complement,compose,concat,cond,converge,curry,curryN,dec,defaultTo,difference,dissoc,divide,drop,dropLast,dropLastWhile,dropRepeats,dropRepeatsWith,dropWhile,either,endsWith,eqProps,equals,evolve,evolveArray,evolveObject,filter,filterArray,filterObject,find,findIndex,findLast,findLastIndex,flatten,flip,forEach,fromPairs,groupBy,groupWith,has,hasPath,head,identical,identity,ifElse,inc,includes,includesArray,indexBy,indexOf,init,intersection,intersperse,is,isEmpty,isNil,join,keys,last,lastIndexOf,length,lens,lensIndex,lensPath,lensProp,map,mapArray,mapObject,match,mathMod,max,maxBy,maxByFn,mean,median,merge,mergeAll,mergeDeepRight,mergeLeft,min,minBy,minByFn,modulo,move,multiply,negate,none,not,nth,of,omit,once,or,over,partial,partition,partitionArray,partitionObject,path,pathEq,pathOr,paths,pick,pickAll,pipe,pluck,prepend,product,prop,propEq,propIs,propOr,props,range,reduce,reject,repeat,replace,reverse,set,slice,sort,sortBy,split,splitAt,splitEvery,splitWhen,startsWith,subtract,sum,symmetricDifference,tail,take,takeLast,takeLastWhile,takeWhile,tap,test,times,toLower,toPairs,toString,toUpper,transpose,trim,tryCatch,type,union,uniq,uniqWith,unless,update,values,view,when,where,whereEq,without,xor,zip,zipObj,zipWith};