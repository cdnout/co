"use strict";var __importDefault=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(exports,"__esModule",{value:!0});const clamp_1=__importDefault(require("clamp")),linspace_1=__importDefault(require("linspace")),utils_1=__importDefault(require("../utils")),eval_1=require("../helpers/eval");function checkAsymptote(t,e,n,l,r){if(!r)return{asymptote:!0,d0:t,d1:e};const s=t[0],a=e[0],u=linspace_1.default(s,a,10);let i,o;for(let t=0;t<10;t+=1){const e=u[t],s=eval_1.builtIn(n,"fn",{x:e});if(t&&i){const t=s-i;if(utils_1.default.sgn(t)===l)return checkAsymptote([o,i],[e,s],n,l,r-1)}i=s,o=e}return{asymptote:!1,d0:t,d1:e}}function split(t,e,n){let l,r,s,a=[];const u=[],i=t.meta.yScale.domain(),o=i[0],p=i[1];function c(t){return t[1]=Math.min(t[1],p),t[1]=Math.max(t[1],o),t}for(n[0]&&(a.push(n[0]),s=n[1][0]-n[0][0],r=utils_1.default.sgn(n[1][1]-n[0][1])),l=1;l<n.length;){const t=n[l-1][1],i=n[l][1]-t,o=utils_1.default.sgn(i);if(r!==o&&Math.abs(i/s)>1){const t=checkAsymptote(n[l-1],n[l],e,o,3);t.asymptote&&(a.push(c(t.d0)),u.push(a),a=[c(t.d1)])}r=o,a.push(n[l]),++l}return a.length&&u.push(a),u}function linear(t,e,n,l){const r=utils_1.default.space(t,n,l),s=t.meta.yScale.domain(),a=s[1]-s[0],u=s[0]-1e5*a,i=s[1]+1e5*a;let o=[];for(let t=0;t<r.length;t+=1){const n=r[t],l=eval_1.builtIn(e,"fn",{x:n});utils_1.default.isValidNumber(n)&&utils_1.default.isValidNumber(l)&&o.push([n,clamp_1.default(l,u,i)])}return o=split(t,e,o)}function parametric(t,e,n,l){const r=e.range||[0,2*Math.PI],s=utils_1.default.space(t,r,l),a=[];for(let t=0;t<s.length;t+=1){const n=s[t],l=eval_1.builtIn(e,"x",{t:n}),r=eval_1.builtIn(e,"y",{t:n});a.push([l,r])}return[a]}function polar(t,e,n,l){const r=e.range||[-Math.PI,Math.PI],s=utils_1.default.space(t,r,l),a=[];for(let t=0;t<s.length;t+=1){const n=s[t],l=eval_1.builtIn(e,"r",{theta:n}),r=l*Math.cos(n),u=l*Math.sin(n);a.push([r,u])}return[a]}function points(t,e,n,l){return[e.points]}function vector(t,e,n,l){return e.offset=e.offset||[0,0],[[e.offset,[e.vector[0]+e.offset[0],e.vector[1]+e.offset[1]]]]}const sampler=function(t,e,n,l){const r={parametric:parametric,polar:polar,points:points,vector:vector,linear:linear};if(!(e.fnType in r))throw Error(e.fnType+" is not supported in the `builtIn` sampler");return r[e.fnType].apply(null,arguments)};exports.default=sampler;