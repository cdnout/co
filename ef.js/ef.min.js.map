{"version":3,"file":"ef.min.js","sources":["../node_modules/eft-parser/src/escape-parser.js","../node_modules/eft-parser/src/eft-parser.js","../node_modules/ef-core/src/lib/utils/type-of.js","../node_modules/ef-core/src/lib/utils/literals-mix.js","../node_modules/ef-core/src/lib/utils/array-helper.js","../node_modules/ef-core/src/lib/render-queue.js","../node_modules/ef-core/src/lib/utils/polyfills.js","../node_modules/ef-core/src/lib/resolver.js","../node_modules/ef-core/src/lib/utils/isnan.js","../node_modules/ef-core/src/lib/utils/debug.js","../node_modules/ef-core/src/lib/binding.js","../node_modules/ef-core/src/lib/utils/fast-instance-of.js","../node_modules/ef-core/src/lib/utils/buble-fix.js","../node_modules/ef-core/src/lib/utils/is-browser.js","../node_modules/ef-core/src/lib/utils/global-shared.js","../node_modules/ef-core/src/lib/utils/dom-helper.js","../node_modules/ef-core/src/lib/utils/event-helper.js","../node_modules/ef-core/src/lib/utils/namespaces.js","../node_modules/ef-core/src/lib/element-creator.js","../node_modules/ef-core/src/lib/utils/dom-arr-helper.js","../node_modules/ef-core/src/mount-options.js","../node_modules/ef-core/src/lib/creator.js","../node_modules/ef-core/src/lib/map-attrs.js","../node_modules/ef-core/src/lib/renderer.js","../node_modules/ef-core/src/lib/jsx-create-element.js","../node_modules/ef-core/src/ef-core.js","../src/ef.js","../src/lib/parser.js","../node_modules/ef-core/src/lib/utils/scoped-component.js"],"sourcesContent":["// Set the escape character\nconst char = '&'\nconst doubleChar = char + char\n\n// Initlize RegExp\nconst oct = new RegExp(`\\\\${char}[0-7]{1,3}`, 'g')\nconst ucp = new RegExp(`\\\\${char}u\\\\[.*?\\\\]`, 'g')\nconst uni = new RegExp(`\\\\${char}u.{0,4}`, 'g')\nconst hex = new RegExp(`\\\\${char}x.{0,2}`, 'g')\nconst esc = new RegExp(`\\\\${char}`, 'g')\nconst b = new RegExp(`\\\\${char}b`, 'g')\nconst t = new RegExp(`\\\\${char}t`, 'g')\nconst n = new RegExp(`\\\\${char}n`, 'g')\nconst v = new RegExp(`\\\\${char}v`, 'g')\nconst f = new RegExp(`\\\\${char}f`, 'g')\nconst r = new RegExp(`\\\\${char}r`, 'g')\n\n// Escape octonary sequence\nconst O2C = () => {\n\tthrow new SyntaxError('Octal escape sequences are not allowed in EFML.')\n}\n\n// Escape unicode code point sequence\nconst UC2C = (val) => {\n\tval = val.substr(3, val.length - 4)\n\tval = parseInt(val, 16)\n\tif (!val) throw new SyntaxError('Invalid Unicode escape sequence')\n\ttry {\n\t\treturn String.fromCodePoint(val)\n\t} catch (err) {\n\t\tthrow new SyntaxError('Undefined Unicode code-point')\n\t}\n}\n\n// Escape unicode sequence\nconst U2C = (val) => {\n\tval = val.substring(2)\n\tval = parseInt(val, 16)\n\tif (!val) throw new SyntaxError('Invalid Unicode escape sequence')\n\treturn String.fromCharCode(val)\n}\n\n// Escape hexadecimal sequence\nconst X2C = (val) => {\n\tval = `00${val.substring(2)}`\n\tval = parseInt(val, 16)\n\tif (!val) throw new SyntaxError('Invalid hexadecimal escape sequence')\n\treturn String.fromCharCode(val)\n}\n\nconst efEscape = (string) => {\n\t// Split strings\n\tconst splitArr = string.split(doubleChar)\n\tconst escaped = []\n\n\t// Escape all known escape characters\n\tfor (let i of splitArr) {\n\t\tconst escapedStr = i\n\t\t\t.replace(oct, O2C)\n\t\t\t.replace(ucp, UC2C)\n\t\t\t.replace(uni, U2C)\n\t\t\t.replace(hex, X2C)\n\t\t\t.replace(b, '\\b')\n\t\t\t.replace(t, '\\t')\n\t\t\t.replace(n, '\\n')\n\t\t\t.replace(v, '\\v')\n\t\t\t.replace(f, '\\f')\n\t\t\t.replace(r, '\\r')\n\t\t\t// Remove all useless escape characters\n\t\t\t.replace(esc, '')\n\t\tescaped.push(escapedStr)\n\t}\n\t// Return escaped string\n\treturn escaped.join(char)\n}\n\nconst checkEscape = string => string[string.length - 1] === char\n\nconst splitWith = (string, char) => {\n\tconst splitArr = string.split(char)\n\tconst escapedSplit = []\n\tlet escaped = false\n\tfor (let i of splitArr) {\n\t\tif (escaped) escapedSplit[escapedSplit.length - 1] += `${char}${i}`\n\t\telse escapedSplit.push(i)\n\t\tescaped = checkEscape(i)\n\t}\n\treturn escapedSplit\n}\n\nconst splitBy = (string, char) => {\n\tconst splitArr = string.split(doubleChar)\n\tconst escaped = splitWith(splitArr.shift(), char)\n\tfor (let i of splitArr) {\n\t\tconst escapedSplit = splitWith(i, char)\n\t\tescaped[escaped.length - 1] += `${doubleChar}${escapedSplit.shift()}`\n\t\tescaped.push(...escapedSplit)\n\t}\n\treturn escaped\n}\n\nexport { efEscape, splitBy }\n","import { efEscape, splitBy } from './escape-parser.js'\n\nconst typeSymbols = '>#%@.-+'\nconst reserved = [\n\t'$ctx', '$refs', '$data', '$methods', '$mount', '$umount', '$subscribe', '$unsubscribe', '$update',\n\t'$dispatch', '$emit', '$on', '$off', '$destroy', '__DIRECTMOUNT__'\n]\nconst mustache = /\\{\\{.+?\\}\\}/g\nconst spaceIndent = /^(\\t*)( *).*/\nconst hashref = /#([^}]|}[^}])*$/\n\nconst getErrorMsg = (msg, line = -2) => `Failed to parse eft template: ${msg}. at line ${line + 1}`\n\nconst isEmpty = string => !string.replace(/\\s/, '')\n\nconst checkValidType = obj => ['number', 'boolean', 'string'].indexOf(typeof obj) > -1\n\nconst ESCAPE = (string) => {\n\tif (!string) return [string, false]\n\ttry {\n\t\tconst parsed = JSON.parse(string)\n\t\tif (['number', 'boolean'].indexOf(typeof parsed) === -1) return [efEscape(string), true]\n\t\treturn [parsed, false]\n\t} catch (e) {\n\t\treturn [efEscape(string), true]\n\t}\n}\n\nconst getOffset = (string, parsingInfo) => {\n\tif (parsingInfo.offset !== null) return\n\tparsingInfo.offset = string.match(/\\s*/)[0]\n\tif (parsingInfo.offset) parsingInfo.offsetReg = parsingInfo.offset\n}\n\nconst removeOffset = (string, parsingInfo, i) => {\n\tif (parsingInfo.offsetReg) {\n\t\tlet removed = false\n\t\tstring = string.replace(parsingInfo.offsetReg, () => {\n\t\t\tremoved = true\n\t\t\treturn ''\n\t\t})\n\t\tif (!removed) throw new SyntaxError(getErrorMsg(`Expected indent to be grater than 0 and less than ${parsingInfo.prevDepth + 1}, but got -1`, i))\n\t}\n\treturn string\n}\n\nconst getIndent = (string, parsingInfo) => {\n\tif (parsingInfo.indentReg) return\n\tconst spaces = string.match(spaceIndent)[2]\n\tif (spaces) {\n\t\tparsingInfo.indentReg = new RegExp(spaces, 'g')\n\t}\n}\n\nconst getDepth = (string, parsingInfo, i) => {\n\tlet depth = 0\n\tif (parsingInfo.indentReg) string = string.replace(/^\\s*/, str => str.replace(parsingInfo.indentReg, '\\t'))\n\tconst content = string.replace(/^\\t*/, (str) => {\n\t\tdepth = str.length\n\t\treturn ''\n\t})\n\tif ((/^\\s/).test(content)) throw new SyntaxError(getErrorMsg('Bad indent', i))\n\treturn { depth, content }\n}\n\nconst resolveDepth = (ast, depth) => {\n\tlet currentNode = ast\n\tfor (let i = 0; i < depth; i++) currentNode = currentNode[currentNode.length - 1]\n\treturn currentNode\n}\n\nconst splitDefault = (string) => {\n\tstring = string.slice(2, string.length - 2)\n\tconst [_path, ..._default] = splitBy(string, '=')\n\tconst pathArr = splitBy(_path.trim(), '.').map(efEscape)\n\tconst [defaultVal, escaped] = ESCAPE(_default.join('=').trim())\n\tif (checkValidType(defaultVal) && (escaped || (!escaped && defaultVal !== ''))) return [pathArr, defaultVal]\n\treturn [pathArr]\n}\n\nconst splitLiterals = (string) => {\n\tconst strs = string.split(mustache)\n\tif (strs.length === 1) return ESCAPE(string)[0]\n\tconst tmpl = []\n\tif (strs.length === 2 && !strs[0] && !strs[1]) tmpl.push(0)\n\telse tmpl.push(strs.map(efEscape))\n\tconst mustaches = string.match(mustache)\n\tif (mustaches) tmpl.push(...mustaches.map(splitDefault))\n\treturn tmpl\n}\n\nconst pushStr = (textArr, str) => {\n\tif (str) textArr.push(str)\n}\n\nconst parseText = (string) => {\n\tconst result = splitLiterals(string)\n\tif (checkValidType(result)) return [`${result}`]\n\tconst [strs, ...exprs] = result\n\tconst textArr = []\n\tfor (let i = 0; i < exprs.length; i++) {\n\t\tpushStr(textArr, strs[i])\n\t\ttextArr.push(exprs[i])\n\t}\n\tpushStr(textArr, strs[strs.length - 1])\n\treturn textArr\n}\n\nconst dotToSpace = val => val.replace(/\\./g, ' ')\n\nconst parseTag = (string) => {\n\tconst tagInfo = {}\n\tconst [tag, ...content] = splitBy(string.replace(hashref, (val) => {\n\t\ttagInfo.ref = val.slice(1)\n\t\treturn ''\n\t}), '.')\n\ttagInfo.tag = efEscape(tag)\n\ttagInfo.class = splitLiterals(content.join('.'))\n\tif (typeof tagInfo.class === 'string') tagInfo.class = dotToSpace(tagInfo.class).trim()\n\telse if (tagInfo.class[0]) tagInfo.class[0] = tagInfo.class[0].map(dotToSpace)\n\treturn tagInfo\n}\n\nconst parseNodeAttrs = (string) => {\n\tconst splitted = splitBy(string, '=')\n\treturn {\n\t\tname: efEscape(splitted.shift().trim()),\n\t\tvalue: splitLiterals(splitted.join('=').trim())\n\t}\n}\n\nconst parseNodeProps = (string) => {\n\tconst splitted = splitBy(string, '=')\n\treturn {\n\t\tpropPath: splitBy(splitted.shift().trim(), '.').map(efEscape),\n\t\tvalue: splitLiterals(splitted.join('=').trim())\n\t}\n}\n\nconst parseEvent = (string) => {\n\tconst splitted = splitBy(string, '=')\n\treturn {\n\t\tname: splitted.shift().trim(),\n\t\tvalue: splitted.join('=').trim()\n\t}\n}\n\nconst setOption = (options, option) => {\n\tswitch (option) {\n\t\tcase 'stop': {\n\t\t\toptions.s = 1\n\t\t\tbreak\n\t\t}\n\t\tcase 'stopImmediate': {\n\t\t\toptions.i = 1\n\t\t\tbreak\n\t\t}\n\t\tcase 'prevent': {\n\t\t\toptions.p = 1\n\t\t\tbreak\n\t\t}\n\t\tcase 'shift': {\n\t\t\toptions.h = 1\n\t\t\tbreak\n\t\t}\n\t\tcase 'alt': {\n\t\t\toptions.a = 1\n\t\t\tbreak\n\t\t}\n\t\tcase 'ctrl': {\n\t\t\toptions.c = 1\n\t\t\tbreak\n\t\t}\n\t\tcase 'meta': {\n\t\t\toptions.t = 1\n\t\t\tbreak\n\t\t}\n\t\tcase 'capture': {\n\t\t\toptions.u = 1\n\t\t\tbreak\n\t\t}\n\t\tdefault: {\n\t\t\tconsole.warn(`Abandoned unsupported eft event option '${option}'.`)\n\t\t}\n\t}\n}\n\nconst getOption = (options, keys, option) => {\n\tconst keyCode = parseInt(option, 10)\n\tif (isNaN(keyCode)) return setOption(options, efEscape(option))\n\tkeys.push(keyCode)\n}\n\nconst getEventOptions = (name) => {\n\tconst options = {}\n\tconst keys = []\n\tconst [listener, ...ops] = splitBy(name, '.')\n\toptions.l = efEscape(listener)\n\tfor (let i of ops) getOption(options, keys, i)\n\tif (keys.length > 0) options.k = keys\n\treturn options\n}\n\nconst splitEvents = (string) => {\n\tconst [name, ...value] = splitBy(string, ':')\n\tconst content = value.join(':')\n\tconst escapedName = efEscape(name.trim())\n\tif (content) return [escapedName, splitLiterals(content)]\n\treturn [escapedName]\n}\n\nconst parseLine = ({line, ast, parsingInfo, i}) => {\n\tif (isEmpty(line)) return\n\tgetOffset(line, parsingInfo)\n\n\tconst trimmedLine = removeOffset(line, parsingInfo, i)\n\tgetIndent(trimmedLine, parsingInfo)\n\n\tlet { depth, content } = getDepth(trimmedLine, parsingInfo, i)\n\n\tif (content) {\n\t\tif (depth < 0 || depth - parsingInfo.prevDepth > 1 || (depth - parsingInfo.prevDepth === 1 && ['comment', 'tag'].indexOf(parsingInfo.prevType) === -1) || (parsingInfo.prevType !== 'comment' && depth === 0 && parsingInfo.topExists)) throw new SyntaxError(getErrorMsg(`Expected indent to be grater than 0 and less than ${parsingInfo.prevDepth + 1}, but got ${depth}`, i))\n\t\tconst type = content[0]\n\t\tcontent = content.slice(1)\n\t\tif (!content && typeSymbols.indexOf(type) >= 0) throw new SyntaxError(getErrorMsg('Empty content', i))\n\t\t// Jump back to upper level\n\t\tif (depth < parsingInfo.prevDepth || (depth === parsingInfo.prevDepth && parsingInfo.prevType === 'tag')) parsingInfo.currentNode = resolveDepth(ast, depth)\n\t\tparsingInfo.prevDepth = depth\n\n\t\tswitch (type) {\n\t\t\tcase '>': {\n\t\t\t\tconst info = parseTag(content)\n\t\t\t\tconst newNode = [{\n\t\t\t\t\tt: info.tag\n\t\t\t\t}]\n\t\t\t\tif (info.class) {\n\t\t\t\t\tnewNode[0].a = {}\n\t\t\t\t\tnewNode[0].a.class = info.class\n\t\t\t\t}\n\t\t\t\tif (info.ref) newNode[0].r = info.ref\n\t\t\t\tparsingInfo.currentNode.push(newNode)\n\t\t\t\tparsingInfo.currentNode = newNode\n\t\t\t\tparsingInfo.prevType = 'tag'\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase '#': {\n\t\t\t\tconst { name, value } = parseNodeAttrs(content)\n\t\t\t\tif (!parsingInfo.currentNode[0].a) parsingInfo.currentNode[0].a = {}\n\t\t\t\tparsingInfo.currentNode[0].a[name] = value\n\t\t\t\tparsingInfo.prevType = 'attr'\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase '%': {\n\t\t\t\tconst { propPath, value } = parseNodeProps(content)\n\t\t\t\tif (!parsingInfo.currentNode[0].p) parsingInfo.currentNode[0].p = []\n\t\t\t\tparsingInfo.currentNode[0].p.push([propPath, value])\n\t\t\t\tparsingInfo.prevType = 'prop'\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase '@': {\n\t\t\t\tconst { name, value } = parseEvent(content)\n\t\t\t\tif (!parsingInfo.currentNode[0].e) parsingInfo.currentNode[0].e = []\n\t\t\t\tconst options = getEventOptions(name)\n\t\t\t\tconst [method, _value] = splitEvents(value)\n\t\t\t\toptions.m = method\n\t\t\t\tif (_value) options.v = _value\n\t\t\t\tparsingInfo.currentNode[0].e.push(options)\n\t\t\t\tparsingInfo.prevType = 'event'\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase '.': {\n\t\t\t\tparsingInfo.currentNode.push(...parseText(content))\n\t\t\t\tparsingInfo.prevType = 'text'\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase '|': {\n\t\t\t\tif (parsingInfo.currentNode.length > 1) content = `\\n${content}`\n\t\t\t\tparsingInfo.currentNode.push(...parseText(content))\n\t\t\t\tparsingInfo.prevType = 'multiline-text'\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase '-': {\n\t\t\t\tif (reserved.indexOf(content) !== -1) throw new SyntaxError(getErrorMsg(`Reserved name '${content}' should not be used`, i))\n\t\t\t\tparsingInfo.currentNode.push({\n\t\t\t\t\tn: content,\n\t\t\t\t\tt: 0\n\t\t\t\t})\n\t\t\t\tparsingInfo.prevType = 'node'\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase '+': {\n\t\t\t\tparsingInfo.currentNode.push({\n\t\t\t\t\tn: content,\n\t\t\t\t\tt: 1\n\t\t\t\t})\n\t\t\t\tparsingInfo.prevType = 'list'\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tparsingInfo.prevType = 'comment'\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst parseEft = (template) => {\n\tif (!template) throw new TypeError(getErrorMsg('Template required, but nothing given'))\n\tconst tplType = typeof template\n\tif (tplType !== 'string') throw new TypeError(getErrorMsg(`Expected a string, but got a(n) ${tplType}`))\n\tconst lines = template.split(/\\r?\\n/)\n\tconst ast = [{t: 0}]\n\tconst parsingInfo = {\n\t\tindentReg: null,\n\t\tprevDepth: 0,\n\t\toffset: null,\n\t\toffsetReg: null,\n\t\tprevType: 'comment',\n\t\tcurrentNode: ast,\n\t\ttopExists: false,\n\t}\n\tfor (let i = 0; i < lines.length; i++) parseLine({line: lines[i], ast, parsingInfo, i})\n\n\tif (ast.length <= 1) throw new SyntaxError(getErrorMsg('Nothing to be parsed', lines.length - 1))\n\tif (ast.length === 2 && Array.isArray(ast[1]) && Object.hasOwnProperty.call(ast[1][0], 't')) return ast[1]\n\treturn ast\n}\n\nexport default parseEft\n","const typeOf = (obj) => {\n\tif (Array.isArray(obj)) return 'array'\n\treturn typeof obj\n}\n\nexport default typeOf\n","const mixStr = (strs, ...exprs) => {\n\tlet string = ''\n\tfor (let i = 0; i < exprs.length; i++) {\n\t\tif (typeof exprs[i] === 'undefined') string += strs[i]\n\t\telse string += (strs[i] + exprs[i])\n\t}\n\treturn string + strs[strs.length - 1]\n}\n\nconst getVal = ({dataNode, _key}) => {\n\tconst data = dataNode[_key]\n\tif (typeof data === 'undefined') return ''\n\treturn data\n}\n\nconst mixVal = (strs, ...exprs) => {\n\tif (!strs) return getVal(exprs[0])\n\tconst template = [strs]\n\ttemplate.push(...exprs.map(getVal))\n\treturn mixStr(...template)\n}\n\nexport {mixStr, mixVal}\n","const proto = Array.prototype\n\nconst ARR = {\n\tcopy(arr) {\n\t\treturn proto.slice.call(arr, 0)\n\t},\n\tempty(arr) {\n\t\tarr.length = 0\n\t\treturn arr\n\t},\n\tequals(left, right) {\n\t\tif (!Array.isArray(right)) return false\n\t\tif (left === right) return true\n\t\tif (left.length !== right.length) return false\n\t\tfor (let i = 0, l = left.length; i < l; i++) {\n\t\t\tif (left[i] !== right[i]) return false\n\t\t}\n\t\treturn true\n\t},\n\tpop(arr) {\n\t\treturn proto.pop.call(arr)\n\t},\n\tpush(arr, ...items) {\n\t\treturn proto.push.apply(arr, items)\n\t},\n\tremove(arr, item) {\n\t\tconst index = proto.indexOf.call(arr, item)\n\t\tif (index > -1) {\n\t\t\tproto.splice.call(arr, index, 1)\n\t\t\treturn item\n\t\t}\n\t},\n\treverse(arr) {\n\t\treturn proto.reverse.call(arr)\n\t},\n\trightUnique(arr) {\n\t\tconst newArr = []\n\t\tfor (let i = 0; i < arr.length; i++) {\n\t\t\tfor (let j = i + 1; j < arr.length; j++) if (arr[i] === arr[j]) j = i += 1\n\t\t\tnewArr.push(arr[i])\n\t\t}\n\t\treturn newArr\n\t},\n\tshift(arr) {\n\t\treturn proto.shift.call(arr)\n\t},\n\tslice(arr, index, length) {\n\t\treturn proto.slice.call(arr, index, length)\n\t},\n\tsort(arr, fn) {\n\t\treturn proto.sort.call(arr, fn)\n\t},\n\tsplice(arr, ...args) {\n\t\treturn proto.splice.apply(arr, args)\n\t},\n\tunshift(arr, ...items) {\n\t\treturn proto.unshift.apply(arr, items)\n\t}\n}\n\nif (typeof Set !== 'undefined' && Array.from) ARR.unique = arr => Array.from(new Set(arr))\nelse ARR.unique = ARR.rightUnique\n\nexport default ARR\n","import ARR from './utils/array-helper.js'\n\nconst modificationQueue = []\nconst domQueue = []\nconst userQueue = []\nlet count = 0\n\nconst queue = handlers => modificationQueue.push(...handlers)\nconst queueDom = handler => domQueue.push(handler)\nconst onNextRender = handler => userQueue.push(handler)\n\n/**\n * @returns {boolean} - Is render paused\n */\nconst isPaused = () => count > 0\n\n/**\n * Add 1 to render count down.\n * When countdown becomes 0, render will be triggered.\n * @returns {number} - Render count down\n */\nconst inform = () => {\n\tcount += 1\n\treturn count\n}\n\nconst execModifications = () => {\n\tif (modificationQueue.length === 0) return\n\tconst renderQueue = ARR.unique(modificationQueue)\n\tARR.empty(modificationQueue)\n\tfor (let i of renderQueue) i()\n}\n\nconst execDomModifications = () => {\n\tif (domQueue.length === 0) return\n\tconst domRenderQueue = ARR.rightUnique(domQueue)\n\tARR.empty(domQueue)\n\tfor (let i of domRenderQueue) i()\n}\n\nconst execUserQueue = () => {\n\tif (userQueue.length === 0) return\n\tconst userFnQueue = ARR.unique(userQueue)\n\tARR.empty(userQueue)\n\tfor (let i of userFnQueue) i()\n}\n\n/**\n * Minus 1 to render count down.\n * When countdown becomes 0, render will be triggered.\n * @param {boolean} immediate - Render immediately, will force countdown become 0\n * @returns {number} - Render count down\n */\nconst exec = (immediate) => {\n\tif (!immediate && (count -= 1) > 0) return count\n\tcount = 0\n\n\tif (modificationQueue.length > 0) execModifications()\n\n\tif (domQueue.length > 0) execDomModifications()\n\n\t// Execute user queue after DOM update\n\tif (userQueue.length > 0) setTimeout(execUserQueue, 0)\n\n\treturn count\n}\n\n/**\n * Run callback in a safe way, without worrying about unhandled errors may break rendering.\n * @param {Function} cb - Callback function to be executed safly\n * @returns {(void|Error)} - Error that happens when executing callback\n */\nconst bundle = (cb) => {\n\tinform()\n\ttry {\n\t\t// eslint-disable-next-line callback-return\n\t\texec(cb(inform, exec))\n\t} catch (e) {\n\t\texec()\n\t\treturn e\n\t}\n}\n\nexport { queue, queueDom, onNextRender, inform, exec, bundle, isPaused }\n","// Enough for ef's usage, so no need for a full polyfill\nconst legacyAssign = (ee, er) => {\n\tfor (let i in er) ee[i] = er[i]\n\treturn ee\n}\n\nconst assign = Object.assign || legacyAssign\n\nexport {assign, legacyAssign}\n","import {inform, exec} from './render-queue.js'\nimport {assign} from './utils/polyfills.js'\n\nconst resolveAllPath = ({_path, handlers, subscribers, innerData}) => {\n\tfor (let i of _path) {\n\t\tif (!handlers[i]) handlers[i] = {}\n\t\tif (!subscribers[i]) subscribers[i] = {}\n\t\tif (!innerData[i]) innerData[i] = {}\n\t\thandlers = handlers[i]\n\t\tsubscribers = subscribers[i]\n\t\tinnerData = innerData[i]\n\t}\n\treturn {\n\t\thandlerNode: handlers,\n\t\tsubscriberNode: subscribers,\n\t\tdataNode: innerData\n\t}\n}\n\n// Workaround for the third bug of buble:\n// https://github.com/bublejs/buble/issues/106\nconst defineNode = (key, obj) => {\n\tconst node = {}\n\tObject.defineProperty(obj, key, {\n\t\tget() {\n\t\t\treturn node\n\t\t},\n\t\tset(data) {\n\t\t\tinform()\n\t\t\tassign(node, data)\n\t\t\texec()\n\t\t},\n\t\tconfigurable: false,\n\t\tenumerable: true\n\t})\n\treturn node\n}\n\nconst resolveReactivePath = (_path, obj) => {\n\tfor (let i of _path) {\n\t\tif (obj[i]) obj = obj[i]\n\t\telse obj = defineNode(i, obj)\n\t}\n\treturn obj\n}\n\nconst resolvePath = (_path, obj) => {\n\tfor (let i of _path) {\n\t\tif (!obj[i]) obj[i] = {}\n\t\tobj = obj[i]\n\t}\n\treturn obj\n}\n\nconst resolve = ({_path, _key, data, handlers, subscribers, innerData}) => {\n\tconst parentNode = resolveReactivePath(_path, data)\n\tconst {handlerNode, subscriberNode, dataNode} = resolveAllPath({_path, handlers, subscribers, innerData})\n\tif (!handlerNode[_key]) handlerNode[_key] = []\n\tif (!subscriberNode[_key]) subscriberNode[_key] = []\n\t/* eslint no-undefined: \"off\" */\n\tif (!Object.prototype.hasOwnProperty.call(dataNode, _key)) dataNode[_key] = undefined\n\treturn {parentNode, handlerNode: handlerNode[_key], subscriberNode: subscriberNode[_key], dataNode}\n}\n\nconst resolveSubscriber = (_path, subscribers) => {\n\tconst pathArr = _path.split('.')\n\tconst key = pathArr.pop()\n\tfor (let i of pathArr) {\n\t\tif (!subscribers[i]) subscribers[i] = {}\n\t\tsubscribers = subscribers[i]\n\t}\n\treturn subscribers[key]\n}\n\nexport {resolveReactivePath, resolvePath, resolve, resolveSubscriber}\n","/* eslint-disable no-self-compare */\nconst isnan = obj => obj !== obj\n\nexport default isnan\n","// Wrap console functions for `[EF]` prefix\nconst strTpl = '[EF] %s'\nconst dbg = {\n\tlog: console.log.bind(console, strTpl),\n\tinfo: console.info.bind(console, strTpl),\n\twarn: console.warn.bind(console, strTpl),\n\terror: console.error.bind(console, strTpl)\n}\n\nexport default dbg\n","import {resolve} from './resolver.js'\nimport {inform, exec, queue} from './render-queue.js'\nimport ARR from './utils/array-helper.js'\nimport isnan from './utils/isnan.js'\nimport dbg from './utils/debug.js'\n\nconst initDataNode = ({parentNode, dataNode, handlerNode, subscriberNode, ctx, _key}) => {\n\tlet subscriberExecuting = false\n\tObject.defineProperty(parentNode, _key, {\n\t\tget() {\n\t\t\treturn dataNode[_key]\n\t\t},\n\t\tset(value) {\n\t\t\tif (subscriberExecuting) return\n\t\t\t// Comparing NaN is like eating a cake and suddenly encounter a grain of sand\n\t\t\tif (dataNode[_key] === value || (isnan(dataNode[_key]) && isnan(value))) return\n\t\t\tdataNode[_key] = value\n\t\t\tinform()\n\t\t\tqueue(handlerNode)\n\t\t\texec()\n\t\t\tif (subscriberNode.length > 0) {\n\t\t\t\tsubscriberExecuting = true\n\t\t\t\tinform()\n\t\t\t\ttry {\n\t\t\t\t\tfor (const subscriber of subscriberNode) subscriber({state: ctx.state, value})\n\t\t\t\t} catch (e) {\n\t\t\t\t\tdbg.error('Error caught when executing subscribers:\\n', e)\n\t\t\t\t}\n\t\t\t\texec()\n\t\t\t\tsubscriberExecuting = false\n\t\t\t}\n\t\t},\n\t\tenumerable: true\n\t})\n}\n\nconst initBinding = ({bind, ctx, handlers, subscribers, innerData}) => {\n\tconst _path = ARR.copy(bind[0])\n\tconst _key = _path.pop()\n\tconst {parentNode, handlerNode, subscriberNode, dataNode} = resolve({\n\t\t_path,\n\t\t_key,\n\t\tdata: ctx.data,\n\t\thandlers,\n\t\tsubscribers,\n\t\tinnerData\n\t})\n\n\t// Initlize data binding node if not exist\n\tif (!Object.prototype.hasOwnProperty.call(parentNode, _key)) initDataNode({parentNode, dataNode, handlerNode, subscriberNode, ctx, _key})\n\t// Update default value\n\t// bind[1] is the default value for this node\n\tif (bind.length > 1) parentNode[_key] = bind[1]\n\n\treturn {dataNode, parentNode, handlerNode, subscriberNode, _key}\n}\n\nexport default initBinding\n","const isInstance = (er, ee) => er.constructor === ee\n\nexport default isInstance\n","import ARR from './array-helper.js'\n\n// https://github.com/bublejs/buble/issues/197\nconst enumerableFalse = (classObj, keys) => {\n\tfor (let i of keys) Object.defineProperty(classObj.prototype, i, {enumerable: false})\n\treturn classObj\n}\n\n// https://github.com/bublejs/buble/issues/131\nconst prepareArgs = (self, node) => {\n\tconst args = ARR.copy(self)\n\tARR.unshift(args, node)\n\treturn args\n}\n\nexport {enumerableFalse, prepareArgs}\n","import dbg from './debug.js'\n\nconst isBrowser = typeof document !== 'undefined' && typeof Node !== 'undefined'\n\nif (process.env.NODE_ENV !== 'production') {\n\tif (isBrowser) dbg.info('Running in browser mode.')\n\telse dbg.info('Running in non-browser mode, please be sure to set a DOM simulation using `setDOMImpl`.')\n}\n\nexport default isBrowser\n","const shared = {}\n\nexport default shared\n","// import ARR from './array-helper.js'\nimport isInstance from './fast-instance-of.js'\nimport {assign} from './polyfills.js'\nimport {prepareArgs} from './buble-fix.js'\nimport dbg from './debug.js'\nimport isBrowser from './is-browser.js'\nimport ARR from './array-helper.js'\nimport {inform, exec} from '../render-queue.js'\n\nimport shared from './global-shared.js'\n\n// Will require a weakmap polyfill for IE10 and below\nconst mountingPointStore = new WeakMap()\n\nconst DOM = {}\n\nconst EFFragment = class {\n\tconstructor() {\n\t\tthis.$children = []\n\t\tthis.$safeZone = DOM.document.createDocumentFragment()\n\t}\n\n\tappend(...args) {\n\t\tDOM.append.apply(null, prepareArgs(args, this.$safeZone))\n\t\treturn this.$children.push(...args)\n\t}\n\n\tappendTo(node) {\n\t\tDOM.append.apply(null, prepareArgs(this.$children, node))\n\t}\n\n\tremoveChild(node) {\n\t\tDOM.remove(node)\n\t\tARR.remove(this.$children, node)\n\t}\n\n\tremove() {\n\t\tfor (let i of this.$children) DOM.append(this.$safeZone, i)\n\t}\n}\n\nconst appendNode = (node, tempFragment) => {\n\tconst {element, placeholder} = node.$ctx.nodeInfo\n\tDOM.append(tempFragment, element, placeholder)\n}\n\nconst handleMountingPoint = (element, tempFragment) => {\n\tif (element.nodeType !== 3) return\n\n\tconst mountingPoint = mountingPointStore.get(element)\n\tif (!mountingPoint) return\n\n\tconst {node} = mountingPoint\n\tif (!node) return\n\tif (Array.isArray(node)) {\n\t\tfor (let i of node) appendNode(i, tempFragment)\n\t} else appendNode(node, tempFragment)\n}\n\nDOM.before = (node, ...nodes) => {\n\tconst tempFragment = DOM.document.createDocumentFragment()\n\tinform()\n\tfor (let i of nodes) {\n\t\tif (i instanceof shared.EFBaseComponent) {\n\t\t\ti.$mount({target: tempFragment})\n\t\t} else if (isInstance(i, EFFragment)) i.appendTo(tempFragment)\n\t\telse {\n\t\t\tDOM.Node.prototype.appendChild.call(tempFragment, i)\n\t\t\thandleMountingPoint(i, tempFragment)\n\t\t}\n\t}\n\tDOM.Node.prototype.insertBefore.call(node.parentNode, tempFragment, node)\n\texec()\n}\n\nDOM.after = (node, ...nodes) => {\n\tconst tempFragment = DOM.document.createDocumentFragment()\n\tinform()\n\tfor (let i of nodes) {\n\t\tif (i instanceof shared.EFBaseComponent) {\n\t\t\ti.$mount({target: tempFragment})\n\t\t} else if (isInstance(i, EFFragment)) i.appendTo(tempFragment)\n\t\telse DOM.Node.prototype.appendChild.call(tempFragment, i)\n\t}\n\tif (node.nextSibling) DOM.Node.prototype.insertBefore.call(node.parentNode, tempFragment, node.nextSibling)\n\telse DOM.Node.prototype.appendChild.call(node.parentNode, tempFragment)\n\texec()\n}\n\nDOM.append = (node, ...nodes) => {\n\t// Handle fragment\n\tif (isInstance(node, EFFragment)) return node.append(...nodes)\n\t// Handle EFComponent\n\tif (node instanceof shared.EFBaseComponent) {\n\t\tif (!(Array.isArray(node.children))) {\n\t\t\tif (process.env.NODE_ENV !== 'production') dbg.warn(node, 'has no `children` list mount point! Child nodes are all ignored!')\n\t\t\treturn\n\t\t}\n\n\t\tinform()\n\t\tfor (let i of nodes) {\n\t\t\ti = new shared.toEFComponent(i)\n\t\t\tnode.children.push(i)\n\t\t}\n\t\texec()\n\n\t\treturn\n\t}\n\n\tif ([1,9,11].indexOf(node.nodeType) === -1) return\n\tconst tempFragment = DOM.document.createDocumentFragment()\n\tfor (let i of nodes) {\n\t\tif (isInstance(i, EFFragment)) i.appendTo(tempFragment)\n\t\telse if (i instanceof DOM.Node) {\n\t\t\tDOM.Node.prototype.appendChild.call(tempFragment, i)\n\t\t\thandleMountingPoint(i, tempFragment)\n\t\t} else if (i instanceof shared.EFBaseComponent) {\n\t\t\ti.$mount({target: tempFragment})\n\t\t}\n\t}\n\tDOM.Node.prototype.appendChild.call(node, tempFragment)\n}\n\nDOM.remove = (node) => {\n\tif (isInstance(node, EFFragment)) node.remove()\n\telse if (node instanceof shared.EFBaseComponent) node.$umount()\n\telse DOM.Node.prototype.removeChild.call(node.parentNode, node)\n}\n\n// addClass(node, className) {\n// \tconst classes = className.split(' ')\n// \tnode.classList.add(...classes)\n// },\n\n// removeClass(node, className) {\n// \tconst classes = className.split(' ')\n// \tnode.classList.remove(...classes)\n// },\n\n// toggleClass(node, className) {\n// \tconst classes = className.split(' ')\n// \tconst classArr = node.className.split(' ')\n// \tfor (let i of classes) {\n// \t\tconst classIndex = classArr.indexOf(i)\n// \t\tif (classIndex > -1) {\n// \t\t\tclassArr.splice(classIndex, 1)\n// \t\t} else {\n// \t\t\tclassArr.push(i)\n// \t\t}\n// \t}\n// \tnode.className = classArr.join(' ').trim()\n// },\n\n// replaceWith(node, newNode) {\n// \tconst parent = node.parentNode\n// \tif (parent) DOM.Node.prototype.replaceChild.call(parent, newNode, node)\n// },\n\n// swap(node, newNode) {\n// \tconst nodeParent = node.parentNode\n// \tconst newNodeParent = newNode.parentNode\n// \tconst nodeSibling = node.nextSibling\n// \tconst newNodeSibling = newNode.nextSibling\n// \tif (nodeParent && newNodeParent) {\n// \t\tDOM.Node.prototype.insertBefore.call(nodeParent, newNode, nodeSibling)\n// \t\tDOM.Node.prototype.insertBefore.call(newNodeParent, node, newNodeSibling)\n// \t}\n// },\n\n// prepend(node, ...nodes) {\n// \tif ([1,9,11].indexOf(node.nodeType) === -1) {\n// \t\treturn\n// \t}\n// \tconst tempFragment = DOM.document.createDocumentFragment()\n// \tnodes.reverse()\n// \tfor (let i of nodes) {\n// \t\tDOM.Node.prototype.appendChild.call(tempFragment, i)\n// \t}\n// \tif (node.firstChild) {\n// \t\tDOM.Node.prototype.insertBefore.call(node, tempFragment, node.firstChild)\n// \t} else {\n// \t\tDOM.Node.prototype.appendChild.call(node, tempFragment)\n// \t}\n// },\n\n// appendTo(node, newNode) {\n// \tDOM.Node.prototype.appendChild.call(newNode, node)\n// },\n\n// prependTo(node, newNode) {\n// \tif (newNode.firstChild) {\n// \t\tDOM.Node.prototype.insertBefore.call(newNode, node, node.firstChild)\n// \t} else {\n// \t\tDOM.Node.prototype.appendChild.call(newNode, node)\n// \t}\n// },\n\n// empty(node) {\n// \tnode.innerHTML = ''\n// },\n\nconst setDOMImpl = sim => assign(DOM, sim)\n\nif (isBrowser) setDOMImpl({Node, document})\n\nexport {DOM, EFFragment, mountingPointStore, setDOMImpl}\n","import {DOM} from './dom-helper.js'\n\n/**\n * @typedef {{bubbles: boolean, cancelable: boolean}} EFEventOptions\n */\n\n/* Get new events that works in all target browsers\n * though a little bit old-fashioned\n */\nconst getEvent = (name, {bubbles, cancelable} = {\n\tbubbles: false,\n\tcancelable: false\n}) => {\n\tconst event = DOM.document.createEvent('CustomEvent')\n\tevent.initEvent(name, bubbles, cancelable)\n\treturn event\n}\n\nexport default getEvent\n","const namespaces = {\n\thtml: 'http://www.w3.org/1999/xhtml',\n\tsvg: 'http://www.w3.org/2000/svg',\n\tmath: 'http://www.w3.org/1998/Math/MathML',\n\txlink: 'http://www.w3.org/1999/xlink'\n}\n\n/**\n * Get declared namespaceURI using it's prefix\n * @param {string} prefix - Perfix for the namespaceURI\n * @returns {string} NamespaceURI defined by the prefix\n */\nconst getNamespace = (prefix) => {\n\tif (namespaces[prefix]) return namespaces[prefix]\n\n\tthrow new Error(`[EF] Namespace \"${prefix}\" has not been declared.`)\n}\n\n/**\n * Declare namespaceURI with a prefix\n * @param {string} prefix - Perfix for the namespaceURI\n * @param {string} namespaceURI - NamespaceURI associated with the prefix\n * @returns {void}\n */\nconst declareNamespace = (prefix, namespaceURI) => {\n\tif (namespaces[prefix]) {\n\t\tthrow new Error(`[EF] Namespace \"${prefix}\" has already been declared as \"${namespaces[prefix]}\".`)\n\t}\n\n\tnamespaces[prefix] = namespaceURI\n}\n\nexport {getNamespace, declareNamespace}\n","import initBinding from './binding.js'\nimport {queue, inform, exec} from './render-queue.js'\nimport {resolvePath} from './resolver.js'\nimport ARR from './utils/array-helper.js'\nimport {DOM, EFFragment} from './utils/dom-helper.js'\nimport getEvent from './utils/event-helper.js'\nimport {mixVal} from './utils/literals-mix.js'\nimport {getNamespace} from './utils/namespaces.js'\nimport dbg from './utils/debug.js'\n\nconst typeValid = obj => ['number', 'boolean', 'string'].indexOf(typeof obj) > -1\n\nconst createByTag = ({tagName, tagContent, attrs, namespace}) => {\n\tconst tagType = typeof tagContent\n\n\tswitch (tagType) {\n\t\tcase 'string': {\n\t\t\tconst creationOption = {}\n\t\t\tif (tagName === tagContent && attrs && attrs.is && typeof attrs.is === 'string') creationOption.is = attrs.is\n\t\t\t// if (tagContent.indexOf(':') > -1) [, tagContent] = tagContent.split(':')\n\t\t\t// Namespaced\n\t\t\tif (namespace) return DOM.document.createElementNS(namespace, tagContent, creationOption)\n\t\t\t// Then basic HTMLElements\n\t\t\treturn DOM.document.createElement(tagContent, creationOption)\n\t\t}\n\t\tcase 'function': {\n\t\t\t// Then custom component or class based custom component\n\t\t\treturn new tagContent()\n\t\t}\n\t\tdefault: {\n\t\t\t// Then overriden basic element\n\t\t\tif (tagContent.tag) tagName = tagContent.tag\n\t\t\t// if (tagName.indexOf(':') > -1) [, tagName] = tagName.split(':')\n\t\t\tif (namespace) {\n\t\t\t\treturn DOM.document.createElementNS(namespace, tagName, {is: tagContent.is})\n\t\t\t}\n\n\t\t\treturn DOM.document.createElement(tagName, {is: tagContent.is})\n\t\t}\n\t}\n}\n\nconst getElement = ({tagName, tagContent, attrs, ref, refs, namespace}) => {\n\tconst element = createByTag({tagName, tagContent, attrs, namespace})\n\tif (ref) Object.defineProperty(refs, ref, {\n\t\tvalue: element,\n\t\tenumerable: true\n\t})\n\treturn element\n}\n\nconst regTmpl = ({val, ctx, handlers, subscribers, innerData, handler}) => {\n\tif (Array.isArray(val)) {\n\t\tconst [strs, ...exprs] = val\n\t\tconst tmpl = [strs]\n\n\t\tconst _handler = () => handler(mixVal(...tmpl))\n\n\t\ttmpl.push(...exprs.map((item) => {\n\t\t\tconst {dataNode, handlerNode, _key} = initBinding({bind: item, ctx, handlers, subscribers, innerData})\n\t\t\thandlerNode.push(_handler)\n\t\t\treturn {dataNode, _key}\n\t\t}))\n\n\t\treturn _handler\n\t}\n\treturn () => val\n}\n\nconst addValListener = ({ctx, handlers, subscribers, innerData, element, key, expr, custom}) => {\n\tconst addListener = custom && '$on' || 'addEventListener'\n\tconst dispatch = custom && '$dispatch' || 'dispatchEvent'\n\tconst {parentNode, _key} = initBinding({bind: expr, ctx, handlers, subscribers, innerData})\n\tconst _update = () => {\n\t\tinform()\n\t\tif (custom) parentNode[_key] = element.$data.value\n\t\telse parentNode[_key] = element.value\n\t\texec()\n\t}\n\tif (key === 'value') {\n\t\t// Listen to input, keyup and change events in order to work in most browsers.\n\t\telement[addListener]('input', _update, true)\n\t\telement[addListener]('keyup', _update, true)\n\t\telement[addListener]('change', _update, true)\n\t\t// // Remove keyup and change listener if browser supports input event correctly\n\t\t// const removeListener = () => {\n\t\t// \telement.removeEventListener('input', removeListener, true)\n\t\t// \telement.removeEventListener('keyup', _update, true)\n\t\t// \telement.removeEventListener('change', _update, true)\n\t\t// }\n\t\t// element[addListener]('input', removeListener, true)\n\t} else {\n\t\telement[addListener]('change', () => {\n\t\t\t// Trigger change to the element it-self\n\t\t\telement[dispatch](getEvent('ef-change-event'), {bubbles: true, canceoable: false})\n\t\t\tif (element.tagName === 'INPUT' && element.type === 'radio' && element.name !== '') {\n\t\t\t\t// Trigger change to the the same named radios\n\t\t\t\tconst radios = DOM.document.querySelectorAll(`input[name=${element.name}][type=radio]`)\n\t\t\t\tif (radios) {\n\t\t\t\t\tconst selected = ARR.copy(radios)\n\t\t\t\t\tARR.remove(selected, element)\n\n\t\t\t\t\t/* Event triggering could cause unwanted render triggers\n\t\t\t\t\t * no better ways came up at the moment\n\t\t\t\t\t */\n\t\t\t\t\tfor (let i of selected) i.dispatchEvent(getEvent('ef-change-event'))\n\t\t\t\t}\n\t\t\t}\n\t\t}, true)\n\t\t// Use custom event to avoid loops and conflicts\n\t\telement[addListener]('ef-change-event', () => {\n\t\t\tinform()\n\t\t\tif (custom) parentNode[_key] = element.$data.checked\n\t\t\telse parentNode[_key] = element.checked\n\t\t\texec()\n\t\t})\n\t}\n}\n\nconst getAttrHandler = ({element, key, custom, ctx}) => {\n\t// Pass directly to custom component\n\tif (custom) return (val) => {\n\t\telement[key] = val\n\t}\n\n\t// Beautify class name\n\tif (key === 'class') return (val) => {\n\t\tval = `${val}`.replace(/\\s+/g, ' ').trim()\n\t\t// Remove attribute when value is empty\n\t\tif (!val) return element.removeAttribute(key)\n\t\telement.setAttribute(key, val)\n\t}\n\n\t// Handle namespace\n\tif (key.indexOf(':') > -1) {\n\t\tconst [prefix] = key.split(':')\n\t\tconst namespace = ctx.localNamespaces[prefix] || getNamespace(prefix)\n\t\treturn (val) => {\n\t\t\t// Remove attribute when value is empty\n\t\t\tif (val === '') return element.removeAttributeNS(namespace, key)\n\t\t\telement.setAttributeNS(namespace, key, val)\n\t\t}\n\t}\n\n\treturn (val) => {\n\t\t// Remove attribute when value is empty\n\t\tif (val === '') return element.removeAttribute(key)\n\t\telement.setAttribute(key, val)\n\t}\n}\n\nconst addAttr = ({element, attr, key, ctx, handlers, subscribers, innerData, custom}) => {\n\tif (typeValid(attr)) {\n\t\tif (custom) {\n\t\t\tif (attr === '') element[key] = true\n\t\t\telse element[key] = attr\n\t\t\treturn\n\t\t}\n\t\t// Do not set or `is` again\n\t\tif (key === 'is') return\n\t\t// Handle namespaces\n\t\tif (key.indexOf(':') > -1) {\n\t\t\tconst [prefix] = key.split(':')\n\t\t\tif (prefix !== 'xmlns') return element.setAttributeNS(ctx.localNamespaces[prefix] || getNamespace(prefix), key, attr)\n\t\t}\n\t\treturn element.setAttribute(key, attr)\n\t}\n\n\tconst handler = getAttrHandler({element, key, custom, ctx})\n\tqueue([regTmpl({val: attr, ctx, handlers, subscribers, innerData, handler})])\n}\n\nconst addProp = ({element, propPath, value, ctx, handlers, subscribers, innerData, custom}) => {\n\tconst keyPath = ARR.copy(propPath)\n\tconst lastKey = keyPath.pop()\n\tif (custom) keyPath.unshift('$data')\n\tconst lastNode = resolvePath(keyPath, element)\n\tif (typeValid(value)) lastNode[lastKey] = value\n\telse {\n\t\tconst handler = (val) => {\n\t\t\tlastNode[lastKey] = val\n\t\t}\n\t\tconst _handler = regTmpl({val: value, ctx, handlers, subscribers, innerData, handler})\n\t\tif (propPath.length === 1 && ((lastKey === 'value' ||\n\t\t\tlastKey === 'checked')) &&\n\t\t\t!value[0]) addValListener({ctx, handlers, subscribers, innerData, element, key: lastKey, expr: value[1], custom})\n\t\tqueue([_handler])\n\t}\n}\n\n\nconst rawHandler = val => val\n\nconst addEvent = ({element, event, ctx, handlers, subscribers, innerData, custom}) => {\n\tconst addListener = custom && '$on' || 'addEventListener'\n\n\t/*\n\t *  l: listener                 : string\n\t *  m: method                   : string\n\t *  s: stopPropagation          : number/undefined\n\t *  i: stopImmediatePropagation : number/undefined\n\t *  p: preventDefault           : number/undefined\n\t *  h: shiftKey                 : number/undefined\n\t *  a: altKey                   : number/undefined\n\t *  c: ctrlKey                  : number/undefined\n\t *  t: metaKey                  : number/undefined\n\t *  u: capture                  : number/undefined\n\t *  k: keyCodes                 : array/undefined\n\t *  v: value                    : string/array/undefined\n\t */\n\tconst {l, m, s, i, p, h, a, c, t, u, k, v} = event\n\tconst _handler = regTmpl({val: v, ctx, handlers, subscribers, innerData, handler: rawHandler})\n\n\telement[addListener](l, (e) => {\n\t\tif (!!h !== !!e.shiftKey ||\n\t\t\t!!a !== !!e.altKey ||\n\t\t\t!!c !== !!e.ctrlKey ||\n\t\t\t!!t !== !!e.metaKey ||\n\t\t\t(k && k.indexOf(e.which) === -1)) return\n\t\tif (s) e.stopPropagation()\n\t\tif (i) e.stopImmediatePropagation()\n\t\tif (p) e.preventDefault()\n\t\tif (ctx.methods[m]) ctx.methods[m]({e, value: _handler(), state: ctx.state})\n\t\telse if (process.env.NODE_ENV !== 'production') dbg.warn(`Method named '${m}' not found! Value been passed is:`, _handler())\n\t}, !!u)\n}\n\nconst createElement = ({info, ctx, innerData, refs, handlers, subscribers, namespace, fragment, custom}) => {\n\tif (fragment) return new EFFragment()\n\n\t/*\n\t *  t: tag       : class | string | int, 0 means fragment\n\t *  a: attr      : object\n\t *  p: prop      : object\n\t *  e: event     : array\n\t *  r: reference : string\n\t */\n\tconst {t, a, p, e, r} = info\n\tconst tagName = t\n\tconst tagContent = ctx.scope[t] || t\n\tconst element = getElement({tagName, tagContent, attrs: a, ref: r, refs, namespace})\n\tif (a) for (let key in a) addAttr({element, custom, attr: a[key], key, ctx, handlers, subscribers, innerData})\n\tif (p) for (let [propPath, value] of p) addProp({element, custom, value, propPath, ctx, handlers, subscribers, innerData})\n\tif (e) for (let event of e) addEvent({element, custom, event, ctx, handlers, subscribers, innerData})\n\n\treturn element\n}\n\nexport {createElement, typeValid}\n","import {DOM} from './dom-helper.js'\nimport ARR from './array-helper.js'\nimport {inform, exec} from '../render-queue.js'\nimport shared from './global-shared.js'\n\nconst DOMARR = {\n\tempty() {\n\t\tinform()\n\t\tfor (let i of ARR.copy(this)) i.$destroy()\n\t\texec()\n\t\tARR.empty(this)\n\t},\n\tclear() {\n\t\tinform()\n\t\tfor (let i of ARR.copy(this)) i.$umount()\n\t\texec()\n\t\tARR.empty(this)\n\t},\n\tpop() {\n\t\tif (this.length === 0) return\n\t\tconst poped = ARR.pop(this)\n\t\tpoped.$umount()\n\t\treturn poped\n\t},\n\tpush({ctx, key, anchor}, ...items) {\n\t\titems = items.map(shared.toEFComponent)\n\t\tconst elements = []\n\t\tinform()\n\t\tfor (let i of items) ARR.push(elements, i.$mount({parent: ctx.state, key}))\n\t\tif (this.length === 0) DOM.after(anchor, ...elements)\n\t\telse DOM.after(this[this.length - 1].$ctx.nodeInfo.placeholder, ...elements)\n\t\texec()\n\t\treturn ARR.push(this, ...items)\n\t},\n\tremove(item) {\n\t\tif (this.indexOf(item) === -1) return\n\t\titem.$umount()\n\t\treturn item\n\t},\n\treverse({ctx, key, anchor}) {\n\t\tif (this.length === 0) return this\n\t\tconst tempArr = ARR.copy(this)\n\t\tconst elements = []\n\t\tinform()\n\t\tfor (let i = tempArr.length - 1; i >= 0; i--) {\n\t\t\ttempArr[i].$umount()\n\t\t\tARR.push(elements, tempArr[i].$mount({parent: ctx.state, key}))\n\t\t}\n\t\tARR.push(this, ...ARR.reverse(tempArr))\n\t\tDOM.after(anchor, ...elements)\n\t\texec()\n\t\treturn this\n\t},\n\tshift() {\n\t\tif (this.length === 0) return\n\t\tconst shifted = ARR.shift(this)\n\t\tshifted.$umount()\n\t\treturn shifted\n\t},\n\tsort({ctx, key, anchor}, fn) {\n\t\tif (this.length === 0) return this\n\t\tconst sorted = ARR.copy(ARR.sort(this, fn))\n\t\tconst elements = []\n\t\tinform()\n\t\tfor (let i of sorted) {\n\t\t\ti.$umount()\n\t\t\tARR.push(elements, i.$mount({parent: ctx.state, key}))\n\t\t}\n\t\tARR.push(this, ...sorted)\n\t\tDOM.after(anchor, ...elements)\n\t\texec()\n\t\treturn this\n\t},\n\tsplice(...args) {\n\t\tif (this.length === 0) return this\n\t\tconst spliced = ARR.splice(ARR.copy(this), ...args)\n\t\tinform()\n\t\tfor (let i of spliced) i.$umount()\n\t\texec()\n\t\treturn spliced\n\t},\n\tunshift({ctx, key, anchor}, ...items) {\n\t\tif (this.length === 0) return this.push(...items).length\n\t\titems = items.map(shared.toEFComponent)\n\t\tconst elements = []\n\t\tinform()\n\t\tfor (let i of items) ARR.push(elements, i.$mount({parent: ctx.state, key}))\n\t\tDOM.after(anchor, ...elements)\n\t\texec()\n\t\treturn ARR.unshift(this, ...items)\n\t}\n}\n\nconst defineArr = (arr, info) => {\n\tObject.defineProperties(arr, {\n\t\tempty: {value: DOMARR.empty},\n\t\tclear: {value: DOMARR.clear},\n\t\tpop: {value: DOMARR.pop},\n\t\tpush: {value: DOMARR.push.bind(arr, info)},\n\t\tremove: {value: DOMARR.remove},\n\t\treverse: {value: DOMARR.reverse.bind(arr, info)},\n\t\tshift: {value: DOMARR.shift},\n\t\tsort: {value: DOMARR.sort.bind(arr, info)},\n\t\tsplice: {value: DOMARR.splice},\n\t\tunshift: {value: DOMARR.unshift.bind(arr, info)}\n\t})\n\treturn arr\n}\n\nexport default defineArr\n","/**\n * @typedef {string} EFMountOption\n * @typedef {{BEFORE: EFMountOption, AFTER: EFMountOption, APPEND: EFMountOption, REPLACE: EFMountOption}} EFMountConfig\n */\n\n/**\n * @type {EFMountConfig}\n */\nconst mountOptions = {\n\tBEFORE: 'before',\n\tAFTER: 'after',\n\tAPPEND: 'append',\n\tREPLACE: 'replace'\n}\n\nexport default mountOptions\n","import {createElement, typeValid} from './element-creator.js'\nimport {queue, inform, exec} from './render-queue.js'\nimport {DOM, mountingPointStore} from './utils/dom-helper.js'\nimport {getNamespace} from './utils/namespaces.js'\nimport defineArr from './utils/dom-arr-helper.js'\nimport ARR from './utils/array-helper.js'\nimport typeOf from './utils/type-of.js'\nimport initBinding from './binding.js'\nimport mountOptions from '../mount-options.js'\n\nimport shared from './utils/global-shared.js'\n\nconst svgNS = getNamespace('svg')\nconst mathNS = getNamespace('math')\nconst htmlNS = getNamespace('html')\n\nconst nullComponent = Object.create(null)\n\nconst checkDestroyed = (state) => {\n\tif (!state.$ctx) throw new Error('[EF] This component has been destroyed!')\n}\n\nconst bindTextNode = ({node, ctx, handlers, subscribers, innerData, element}) => {\n\t// Data binding text node\n\tconst textNode = DOM.document.createTextNode('')\n\tconst { dataNode, handlerNode, _key } = initBinding({bind: node, ctx, handlers, subscribers, innerData})\n\tconst handler = () => {\n\t\tconst value = dataNode[_key]\n\t\tif (typeof value === 'undefined') {\n\t\t\ttextNode.textContent = ''\n\t\t\treturn\n\t\t}\n\t\ttextNode.textContent = value\n\t}\n\thandlerNode.push(handler)\n\tqueue([handler])\n\n\t// Append element to the component\n\tDOM.append(element, textNode)\n}\n\nconst updateMountingNode = ({ctx, key, value}) => {\n\tconst {children} = ctx\n\tconst child = children[key]\n\tconst {anchor, node} = child\n\tif (node === value) return\n\n\tvalue = shared.toEFComponent(value)\n\n\tinform()\n\t// Update component\n\tif (node) {\n\t\tif (value === nullComponent) value = null\n\t\telse node.$umount()\n\t}\n\t// Update stored value\n\tchild.node = value\n\tif (value) value.$mount({target: anchor, parent: ctx.state, option: mountOptions.BEFORE, key})\n\texec()\n}\n\nconst updateMountingList = ({ctx, key, value}) => {\n\tconst {children} = ctx\n\tconst {anchor, node} = children[key]\n\tif (ARR.equals(node, value)) return\n\tif (value) value = ARR.copy(value)\n\telse value = []\n\tconst fragment = DOM.document.createDocumentFragment()\n\t// Update components\n\tinform()\n\tif (node) {\n\t\tnode.clear()\n\t\tfor (let item of value) {\n\t\t\titem = shared.toEFComponent(item)\n\n\t\t\tif (item.$ctx.nodeInfo.parent) item.$umount()\n\t\t\tDOM.append(fragment, item.$mount({parent: ctx.state, key}))\n\t\t}\n\t} else for (let item of value) DOM.append(fragment, item.$mount({parent: ctx.state, key}))\n\t// Update stored value\n\tnode.length = 0\n\tARR.push(node, ...value)\n\t// Append to current component\n\tDOM.after(anchor, fragment)\n\texec()\n}\n\nconst mountingPointUpdaters = [\n\tupdateMountingNode,\n\tupdateMountingList\n]\n\nconst applyMountingPoint = (type, key, tpl) => {\n\tObject.defineProperty(tpl.prototype, key, {\n\t\tget() {\n\t\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\t\treturn this.$ctx.children[key].node\n\t\t},\n\t\tset(value) {\n\t\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\t\tconst ctx = this.$ctx\n\t\t\tmountingPointUpdaters[type]({ctx, key, value})\n\t\t},\n\t\tenumerable: true\n\t})\n}\n\nconst bindMountingNode = ({ctx, key, anchor}) => {\n\tconst {children, isFragment} = ctx\n\tchildren[key] = {anchor}\n\tmountingPointStore.set(anchor, children[key])\n\tif (isFragment) DOM.append(ctx.safeZone, anchor)\n}\n\nconst bindMountingList = ({ctx, key, anchor}) => {\n\tconst {children, isFragment} = ctx\n\tchildren[key] = {\n\t\tnode: defineArr([], {ctx, key, anchor}),\n\t\tanchor\n\t}\n\tmountingPointStore.set(anchor, children[key])\n\tif (isFragment) DOM.append(ctx.safeZone, anchor)\n}\n\n// Walk through the AST to perform proper actions\nconst resolveAST = ({node, nodeType, element, ctx, innerData, refs, handlers, subscribers, namespace, create}) => {\n\tif (node instanceof DOM.Node) {\n\t\tDOM.append(element, node)\n\t\treturn\n\t}\n\tswitch (nodeType) {\n\t\t// Static text node\n\t\tcase 'string': {\n\t\t\tDOM.append(element, DOM.document.createTextNode(node))\n\t\t\tbreak\n\t\t}\n\t\t// Child element or a dynamic text node\n\t\tcase 'array': {\n\t\t\t// Recursive call for child element\n\t\t\tif (typeOf(node[0]) === 'object') DOM.append(element, create({node, ctx, innerData, refs, handlers, subscribers, namespace}))\n\t\t\t// Dynamic text node\n\t\t\telse bindTextNode({node, ctx, handlers, subscribers, innerData, element})\n\t\t\tbreak\n\t\t}\n\t\t// Mounting points\n\t\tcase 'object': {\n\t\t\tconst anchor = DOM.document.createTextNode('')\n\t\t\t// Single node mounting point\n\t\t\tif (node.t === 0) bindMountingNode({ctx, key: node.n, anchor})\n\t\t\t// Multi node mounting point\n\t\t\telse bindMountingList({ctx, key: node.n, anchor})\n\t\t\t// Append anchor\n\t\t\tif (process.env.NODE_ENV !== 'production') DOM.append(element, DOM.document.createComment(`EF MOUNTING POINT '${node.n}' START`))\n\t\t\tDOM.append(element, anchor)\n\t\t\tif (process.env.NODE_ENV !== 'production') DOM.append(element, DOM.document.createComment(`EF MOUNTING POINT '${node.n}' END`))\n\t\t\tbreak\n\t\t}\n\t\tdefault:\n\t}\n}\n\n// Create elements based on description from AST\n/* eslint {\"complexity\": \"off\"} */\nconst create = ({node, ctx, innerData, refs, handlers, subscribers, namespace}) => {\n\tconst [info, ...childNodes] = node\n\tconst previousNamespace = namespace\n\n\tlet tagName = info.t\n\tlet isLocalPrefix = false\n\n\tconst fragment = tagName === 0\n\tconst custom = Object.isPrototypeOf.call(shared.EFBaseComponent, ctx.scope[tagName] || tagName)\n\n\t// Check if element needs a namespace\n\tif (!fragment && !custom) {\n\t\tif (ctx.scope[tagName]) {\n\t\t\tconst scoped = ctx.scope[tagName]\n\t\t\tif (typeof scoped === 'string') tagName = scoped\n\t\t\telse if (scoped.tag) {\n\t\t\t\ttagName = scoped.tag\n\t\t\t\tif (scoped.namespaceURI) namespace = scoped.namespaceURI\n\t\t\t}\n\t\t}\n\t\tif (tagName.indexOf(':') > -1) {\n\t\t\tconst [prefix, unprefixedTagName] = tagName.split(':')\n\t\t\tif (ctx.localNamespaces[prefix]) {\n\t\t\t\tnamespace = ctx.localNamespaces[prefix]\n\t\t\t\tisLocalPrefix = true\n\t\t\t} else {\n\t\t\t\tnamespace = getNamespace(prefix)\n\t\t\t}\n\t\t\ttagName = unprefixedTagName\n\t\t} else if (info.a && info.a.xmlns && typeValid(info.a.xmlns)) {\n\t\t\tnamespace = info.a.xmlns\n\t\t} else if (!namespace) {\n\t\t\ttagName = tagName.toLowerCase()\n\t\t\tswitch (tagName) {\n\t\t\t\tcase 'svg': {\n\t\t\t\t\tnamespace = svgNS\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase 'math': {\n\t\t\t\t\tnamespace = mathNS\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t}\n\t\t}\n\t}\n\n\tif (namespace === htmlNS) namespace = ''\n\n\t// First create an element according to the description\n\tconst element = createElement({info, ctx, innerData, refs, handlers, subscribers, namespace, fragment, custom})\n\tif (fragment && process.env.NODE_ENV !== 'production') element.append(DOM.document.createComment('EF FRAGMENT START'))\n\n\t// Leave SVG mode if tag is `foreignObject`\n\tif (namespace && namespace === svgNS && ['foreignobject', 'desc', 'title'].indexOf(tagName.toLowerCase()) > -1) namespace = ''\n\n\t// restore previous namespace if namespace is defined locally\n\tif (isLocalPrefix) namespace = previousNamespace\n\n\t// Append child nodes\n\tfor (let node of childNodes) {\n\t\tif (node instanceof shared.EFBaseComponent) node.$mount({target: element})\n\t\telse resolveAST({node, nodeType: typeOf(node), element, ctx, innerData, refs, handlers, subscribers, namespace, create})\n\t}\n\tif (fragment && process.env.NODE_ENV !== 'production') element.append(DOM.document.createComment('EF FRAGMENT END'))\n\n\treturn element\n}\n\nexport {create, nullComponent, checkDestroyed, applyMountingPoint}\n","const getGetter = ({base, key}, {checkTrue, get, set}) => {\n\tif (get) {\n\t\tif (!set) throw new Error('[EF] Setter must be defined when getter exists')\n\t\treturn get\n\t}\n\n\tif (checkTrue) return function() {\n\t\treturn checkTrue(base(this)[key], this)\n\t}\n\n\treturn function() {\n\t\treturn base(this)[key]\n\t}\n}\n\nconst getSetter = ({base, key}, {checkTrue, trueVal, falseVal, get, set}) => {\n\tif (set) {\n\t\tif (!get) throw new Error('[EF] Getter must be defined when setter exists')\n\t\treturn set\n\t}\n\n\tif (checkTrue) return function(val) {\n\t\tconst baseNode = base(this)\n\t\tconst _trueVal = trueVal\n\t\tconst _falseVal = falseVal\n\n\t\tif (typeof trueVal !== 'function') trueVal = () => _trueVal\n\t\tif (typeof falseVal !== 'function') falseVal = () => _falseVal\n\n\t\tif (val) baseNode[key] = trueVal(this)\n\t\telse baseNode[key] = falseVal(this)\n\t}\n\n\treturn function(val) {\n\t\tbase(this)[key] = val\n\t}\n}\n\nconst defaultRoot = state => state.$data\nconst getBase = (root) => {\n\tif (!root) return defaultRoot\n\tif (typeof root === 'function') return root\n\tif (typeof root === 'string') root = root.split('.')\n\treturn (base) => {\n\t\tfor (let key of root) base = base[key]\n\t\treturn base\n\t}\n}\n\n/**\n * @typedef {import('./renderer.js').EFBaseClass} EFBaseClass\n */\n\n/**\n * Definition of an attribute mapping\n * @typedef {Object} AttrDef\n * @property {string=} key - key to be accessed on base, default to `attr`\n * @property {Function=} base - a function that returns the base of the key, default returns $data\n * @property {bool=} checkTrue - a function returns true or false based on input value\n * @property {*=} trueVal - value when true, only used when checkTrue is set\n * @property {*=} falseVal - value when false, only used when checkTrue is set\n * @property {Function=} get - getter, will ignore all other settings except set\n * @property {Function=} set - setter, will ignore all other settings except get\n */\n\n/**\n * Data to attribute mapping helper\n * @template {EFBaseClass} T\n * @param {T} tpl - Component class to be mapped\n * @param {Object.<string,AttrDef>} attrMap - Attributes to be mapped\n * @returns {T} - Mapped component class\n */\nconst mapAttrs = (tpl, attrMap) => {\n\tfor (let attr in attrMap) {\n\t\tconst options = attrMap[attr]\n\n\t\tconst base = getBase(options.base)\n\t\tconst key = options.key || attr\n\n\t\tconst basicProperty = {base, key}\n\n\t\tconst get = getGetter(basicProperty, options)\n\t\tconst set = getSetter(basicProperty, options)\n\n\t\tObject.defineProperty(tpl.prototype, attr, {\n\t\t\tget,\n\t\t\tset,\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false\n\t\t})\n\t}\n\n\treturn tpl\n}\n\nexport default mapAttrs\n","import {create, nullComponent, checkDestroyed} from './creator.js'\nimport initBinding from './binding.js'\nimport {queueDom, inform, exec} from './render-queue.js'\nimport {resolveSubscriber} from './resolver.js'\nimport mapAttrs from './map-attrs.js'\nimport {DOM, EFFragment, mountingPointStore} from './utils/dom-helper.js'\nimport ARR from './utils/array-helper.js'\nimport {assign, legacyAssign} from './utils/polyfills.js'\nimport isInstance from './utils/fast-instance-of.js'\nimport typeOf from './utils/type-of.js'\nimport {enumerableFalse} from './utils/buble-fix.js'\nimport dbg from './utils/debug.js'\nimport getEvent from './utils/event-helper.js'\nimport mountOptions from '../mount-options.js'\n\nimport shared from './utils/global-shared.js'\n\nconst unsubscribe = (pathStr, fn, subscribers) => {\n\tconst subscriberNode = resolveSubscriber(pathStr, subscribers)\n\tARR.remove(subscriberNode, fn)\n}\n\n/**\n * @typedef {Array} EFAST\n * @typedef {Object.<string,EFBaseComponent>} EFTemplateScope\n */\n\n/**\n * @typedef {Object} EFSubscriberHandlerArg\n * @property {EFBaseComponent} ctx - The component who calls the handler\n * @property {*} value - Value been subscribed\n */\n\n/**\n * @event Event\n */\n\n/**\n * @typedef {Object} EFEventHandlerArg\n * @property {EFBaseComponent} ctx - The component who calls the handler\n * @property {*} value - Value been passed to the event handler\n * @property {Event} event - Event object that has been triggered\n */\n\n/**\n * @typedef {Function} EFSubscriberHandlerMethod\n * @param {EFSubscriberHandlerArg} arg\n * @returns {void}\n */\n\n/**\n * @typedef {Function} EFEventHandlerMethod\n * @param {EFEventHandlerArg} arg\n * @returns {void}\n */\n\n/**\n * The very basic ef component\n * @class EFBaseComponent\n * @param {EFAST} ast - ast for the component\n * @param {EFTemplateScope} scope - scope which contains custom components\n * @private {Object} $ctx - Inner component data, DO NOT TOUCH\n * @property {Object} $data - Data on component\n * @property {Object.<string,EFEventHandlerMethod>} $methods - Methods on component\n * @property {Object.<string,(EFBaseComponent|Node)>} $refs - References on component\n */\nconst EFBaseComponent = class {\n\n\t/**\n\t * Create an EFBaseComponent with ef AST\n\t * @param {EFAST} ast - ast for the component\n\t * @param {EFTemplateScope=} scope - scope which contains custom components\n\t */\n\tconstructor(ast, scope = {}) {\n\t\tconst children = {}\n\t\tconst refs = {}\n\t\tconst data = {}\n\t\tconst innerData = {}\n\t\tconst methods = {}\n\t\tconst handlers = {}\n\t\tconst subscribers = {}\n\t\tconst nodeInfo = {\n\t\t\tplaceholder: null,\n\t\t\treplace: [],\n\t\t\tparent: null,\n\t\t\tkey: null\n\t\t}\n\n\t\t/* Detatched components will be put in the safe zone.\n\t\t * Split safe zone to each component in order to make\n\t\t * the component memory recycleable when lost reference\n\t\t */\n\t\tconst safeZone = DOM.document.createDocumentFragment()\n\n\t\tif (process.env.NODE_ENV === 'production') nodeInfo.placeholder = DOM.document.createTextNode('')\n\t\telse nodeInfo.placeholder = DOM.document.createComment('EF COMPONENT PLACEHOLDER')\n\n\t\tconst mount = () => {\n\t\t\tif (nodeInfo.replace.length > 0) {\n\t\t\t\tfor (let i of nodeInfo.replace) DOM.remove(i)\n\t\t\t\tARR.empty(nodeInfo.replace)\n\t\t\t}\n\t\t\tDOM.before(nodeInfo.placeholder, nodeInfo.element)\n\t\t}\n\n\t\tconst ctx = {\n\t\t\tscope, mount, refs, data, innerData, methods,\n\t\t\thandlers, subscribers, nodeInfo, safeZone,\n\t\t\tchildren, state: this, isFragment: ast[0].t === 0,\n\t\t\tlocalNamespaces: this.constructor.__local_namespaces\n\t\t}\n\n\t\tObject.defineProperty(this, '$ctx', {\n\t\t\tvalue: ctx,\n\t\t\tenumerable: false,\n\t\t\tconfigurable: true\n\t\t})\n\n\t\tinform()\n\n\t\tnodeInfo.element = create({node: ast, ctx, innerData, refs, handlers, subscribers, namespace: ''})\n\t\tDOM.append(safeZone, nodeInfo.placeholder)\n\t\tqueueDom(mount)\n\t\texec()\n\t}\n\n\tget $data() {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\treturn this.$ctx.data\n\t}\n\n\tset $data(newData) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\tinform()\n\t\tassign(this.$ctx.data, newData)\n\t\texec()\n\t}\n\n\tget $methods() {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\treturn this.$ctx.methods\n\t}\n\n\n\tset $methods(newMethods) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\tthis.$ctx.methods = newMethods\n\t}\n\n\tget $refs() {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\treturn this.$ctx.refs\n\t}\n\n\t/**\n\t * @typedef {import('../mount-options.js').EFMountConfig} EFMountConfig\n\t */\n\n\t/**\n\t * Mount component to a specitic position\n\t * @param {EFMountConfig} config - Mount contigurations\n\t * @returns {number} - Render count down\n\t */\n\t$mount({target, option, parent, key}) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\tconst { nodeInfo, mount } = this.$ctx\n\t\tif (typeof target === 'string') target = document.querySelector(target)\n\n\t\tinform()\n\t\tif (nodeInfo.parent) {\n\t\t\tthis.$umount()\n\t\t\tif (process.env.NODE_ENV !== 'production') dbg.warn('Component detached from previous mounting point.')\n\t\t}\n\n\t\tif (!parent) parent = target\n\t\tif (!key) key = '__DIRECTMOUNT__'\n\t\tnodeInfo.parent = parent\n\t\tnodeInfo.key = key\n\t\tqueueDom(mount)\n\n\t\tif (!target) {\n\t\t\texec()\n\t\t\treturn nodeInfo.placeholder\n\t\t}\n\n\t\tswitch (option) {\n\t\t\tcase mountOptions.BEFORE: {\n\t\t\t\tDOM.before(target, nodeInfo.placeholder)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase mountOptions.AFTER: {\n\t\t\t\tDOM.after(target, nodeInfo.placeholder)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase mountOptions.REPLACE: {\n\t\t\t\tDOM.before(target, nodeInfo.placeholder)\n\t\t\t\tnodeInfo.replace.push(target)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase mountOptions.APPEND:\n\t\t\tdefault: {\n\t\t\t\t// Parent is EFFragment should only happen when using jsx\n\t\t\t\tif (isInstance(parent, EFFragment)) DOM.append(target, nodeInfo.element)\n\t\t\t\telse DOM.append(target, nodeInfo.placeholder)\n\t\t\t}\n\t\t}\n\t\treturn exec()\n\t}\n\n\t/**\n\t * @returns {number} - Render count down\n\t */\n\t$umount() {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\tconst { nodeInfo, safeZone, mount } = this.$ctx\n\t\tconst { parent, key } = nodeInfo\n\t\tnodeInfo.parent = null\n\t\tnodeInfo.key = null\n\n\t\tinform()\n\t\tif (parent) {\n\t\t\tif (key !== '__DIRECTMOUNT__') {\n\t\t\t\tif (parent[key]) {\n\t\t\t\t\tif (Array.isArray(parent[key])) {\n\t\t\t\t\t\t// Remove self from parent list mounting point\n\t\t\t\t\t\tARR.remove(parent[key], this)\n\t\t\t\t\t} else parent[key] = nullComponent\n\t\t\t\t}\n\t\t\t// Else Remove elements from fragment parent\n\t\t\t} else if (isInstance(parent, EFFragment)) parent.$ctx.nodeInfo.element.removeChild(nodeInfo.element)\n\t\t}\n\t\tDOM.append(safeZone, nodeInfo.placeholder)\n\t\tqueueDom(mount)\n\t\treturn exec()\n\t}\n\n\t/**\n\t * Subscribe a value's changing\n\t * @param {string} pathStr - Path string to the subribed value based on `$data`, splitted by `.`\n\t * @param {EFSubscriberHandlerMethod} subscriber - Subscription event handler to be added\n\t * @returns {void}\n\t */\n\t$subscribe(pathStr, subscriber) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\tconst ctx = this.$ctx\n\t\tconst { handlers, subscribers, innerData } = ctx\n\t\tconst _path = pathStr.split('.')\n\t\tconst { dataNode, subscriberNode, _key } = initBinding({bind: [_path], ctx, handlers, subscribers, innerData})\n\t\tinform()\n\t\t// Execute the subscriber function immediately\n\t\ttry {\n\t\t\tsubscriber({state: this, value: dataNode[_key]})\n\t\t\t// Put the subscriber inside the subscriberNode\n\t\t\tsubscriberNode.push(subscriber)\n\t\t} catch (e) {\n\t\t\tdbg.error('Error caught when registering subscriber:\\n', e)\n\t\t}\n\t\texec()\n\t}\n\n\t/**\n\t * Unsubscribe a value's changing\n\t * @param {string} pathStr - Path string to the subribed value based on `$data`, splitted by `.`\n\t * @param {EFSubscriberHandlerMethod} subscriber - Subscription event handler to be removed\n\t * @returns {void}\n\t */\n\t$unsubscribe(pathStr, subscriber) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\tconst { subscribers } = this.$ctx\n\t\tunsubscribe(pathStr, subscriber, subscribers)\n\t}\n\n\t/**\n\t * Update the component's state with a new state\n\t * @param {Object} newState - New state to be set on this component\n\t * @returns {void}\n\t */\n\t$update(newState) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\tinform()\n\t\tlegacyAssign(this, newState)\n\t\texec()\n\t}\n\n\t/**\n\t * Fire a custom event using an Event object on this component\n\t * @param {Event} event - Event object to be dispatched on this component\n\t * @returns {*} - Same as the return of Node.dispatchEvent\n\t */\n\t$dispatch(event) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\treturn this.$ctx.nodeInfo.placeholder.dispatchEvent(event)\n\t}\n\n\t/**\n\t * @typedef {import('./utils/event-helper.js').EFEventOptions} EFEventOptions\n\t */\n\n\t/**\n\t * Fire a custom event using event name on this component\n\t * @param {string} eventName - Name of the custom event\n\t * @param {EFEventOptions} options - Event Options\n\t * @returns {*} - Same as the return of Node.dispatchEvent\n\t */\n\t$emit(eventName, options) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\treturn this.$dispatch(getEvent(eventName, options))\n\t}\n\n\t/**\n\t * Add custom event listener on this component\n\t * @param {...*} args - Same as Node.addEventListener\n\t * @returns {*} - Same as the return of Node.addEventListener\n\t */\n\t$on(...args) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\treturn this.$ctx.nodeInfo.placeholder.addEventListener(...args)\n\t}\n\n\t/**\n\t * Remove custom event listener on this component\n\t * @param {...*} args - Same as Node.removeEventListener\n\t * @returns {*} - Same as the return of Node.removeEventListener\n\t */\n\t$off(...args) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\treturn this.$ctx.nodeInfo.placeholder.removeEventListener(...args)\n\t}\n\n\t/**\n\t * Destroy this component\n\t * @returns {number} - Render count down\n\t */\n\t$destroy() {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\tconst { nodeInfo, children } = this.$ctx\n\t\tinform()\n\t\tthis.$umount()\n\t\tfor (let i in children) mountingPointStore.delete(children[i].anchor)\n\t\t// Detatch all mounted components\n\t\tfor (let i in this) {\n\t\t\tif (typeOf(this[i]) === 'array') this[i].clear()\n\t\t\telse this[i] = null\n\t\t}\n\t\t// Remove context\n\t\tdelete this.$ctx\n\t\t// Push DOM removement operation to query\n\t\tqueueDom(() => {\n\t\t\tDOM.remove(nodeInfo.element)\n\t\t\tDOM.remove(nodeInfo.placeholder)\n\t\t})\n\t\t// Render\n\t\treturn exec()\n\t}\n}\n\n/**\n * @typedef {typeof EFBaseComponent} EFBaseClass\n */\n\nconst fragmentAST = [{t: 0}]\n\n/**\n * ef component node wrapper\n * Better using this than Fragments if wrapping only HTML elements.\n * @class EFNodeWrapper\n * @extends EFBaseComponent\n * @param {...Node} nodes - Nodes to be wrapped\n * @property {Array<Node>} - Nodes that are wrapped\n */\nconst EFNodeWrapper = class extends EFBaseComponent {\n\n\t/**\n\t * Wrap given nodes into an ef component\n\t * @param  {...Node} nodes - Nodes to be wrapped\n\t */\n\tconstructor(...nodes) {\n\t\tsuper(fragmentAST)\n\n\t\tconst element = this.$ctx.nodeInfo.element\n\t\tconst childrenArr = element.$children\n\t\telement.append(...nodes)\n\n\t\tif (process.env.NODE_ENV !== 'production') element.append(ARR.remove(childrenArr, childrenArr[1]))\n\n\t\tthis.$ctx.elements = nodes\n\t}\n\n\tget $el() {\n\t\treturn this.$ctx.elements\n\t}\n}\n\n/**\n * Component fragment wrapper\n * @class Fragment\n * @extends EFBaseComponent\n * @param {...*} children - Things to be wrapped into an ef component\n */\nconst Fragment = class extends EFBaseComponent {\n\tconstructor(...children) {\n\t\tsuper([{t: 0}, ...children])\n\t}\n}\n\nconst textFragmentAst = [{t: 0},[['text']]]\n\n/**\n * ef component text wrapper\n * @class EFTextFragment\n * @extends EFBaseComponent\n * @param {string} text - String to be wrapped\n * @property {string} text - Text on the fragment component\n */\nconst EFTextFragment = class extends EFBaseComponent {\n\n\t/**\n\t * Wrap given text into an ef component\n\t * @param {string} text - String to be wrapped\n\t */\n\tconstructor(text) {\n\t\tinform()\n\t\tsuper(textFragmentAst)\n\t\tthis.text = text\n\t\texec()\n\t}\n}\nmapAttrs(EFTextFragment, {text: {}})\n\nenumerableFalse(EFBaseComponent, ['$mount', '$umount', '$subscribe', '$unsubscribe', '$update', '$dispatch', '$emit', '$on', '$off', '$destroy'])\nenumerableFalse(EFNodeWrapper, ['$el'])\n\n/**\n * Transform almost anyting into ef component\n * @template {value} T\n * @param {T} value - Things to be transformed into ef component\n * @returns {(EFNodeWrapper|EFTextFragment|T)} - Wrapped component or value it self if not supports converting\n */\nconst toEFComponent = (value) => {\n\tif (value === null || typeof value === 'undefined' || value instanceof EFBaseComponent) return value\n\n\tif (value !== nullComponent) {\n\t\tif (value instanceof Node) return new EFNodeWrapper(value)\n\t\telse if (typeof value === 'string') return new EFTextFragment(value)\n\t\telse return new EFTextFragment(JSON.stringify(value))\n\t}\n}\n\nshared.EFBaseComponent = EFBaseComponent\nshared.toEFComponent = toEFComponent\n\nexport {EFBaseComponent, EFNodeWrapper, EFTextFragment, Fragment, toEFComponent}\n","import {EFBaseComponent, Fragment, toEFComponent} from './renderer.js'\nimport {assign} from './utils/polyfills.js'\n\nconst flatten = (prev, item) => {\n\tif (Array.isArray(item)) prev.push(...item.map(toEFComponent))\n\telse prev.push(toEFComponent(item))\n\n\treturn prev\n}\n\n/**\n * @typedef {import('./renderer.js').EFBaseComponent} EFBaseComponent\n * @typedef {import('./renderer.js').EFBaseClass} EFBaseClass\n */\n\n// eslint-disable-next-line valid-jsdoc\n/**\n * Create ef component from JSX\n * @template {EFBaseClass} T\n * @param {(string|T)} tag - JSX tag\n * @param {Object.<string,*>} attrs - JSX attributes\n * @param  {...*} children - JSX children\n * @returns {(EFBaseComponent|T extends {new (...args: any): infer R} ? R : never)} ef component created from JSX\n */\nconst createElement = (tag, attrs, ...children) => {\n\t// Create special component for fragment\n\tif (tag === Fragment) return new Fragment(...children)\n\n\t// Create an instance if tag is an ef class\n\tif (Object.isPrototypeOf.call(EFBaseComponent, tag)) {\n\t\tif (children.length <= 0) return new tag(attrs)\n\t\treturn new tag(assign({children: children.reduce(flatten, [])}, attrs || {}))\n\t}\n\n\t// Else return the generated basic component\n\t// Transform all label only attributes to ef-supported style\n\tconst transformedAttrs = assign({}, attrs)\n\tfor (let i in transformedAttrs) {\n\t\tif (transformedAttrs[i] === true) transformedAttrs[i] = ''\n\t}\n\n\treturn new EFBaseComponent([\n\t\t{\n\t\t\tt: tag,\n\t\t\ta: transformedAttrs\n\t\t},\n\t\t...children\n\t])\n}\n\nexport default createElement\n","// Import everything\nimport {EFBaseComponent, EFNodeWrapper, EFTextFragment, Fragment, toEFComponent} from './lib/renderer.js'\nimport {applyMountingPoint} from './lib/creator.js'\nimport mountOptions from './mount-options.js'\nimport createElement from './lib/jsx-create-element.js'\nimport mapAttrs from './lib/map-attrs.js'\nimport {onNextRender, inform, exec, bundle, isPaused} from './lib/render-queue.js'\nimport dbg from './lib/utils/debug.js'\nimport typeOf from './lib/utils/type-of.js'\nimport scoped from './lib/utils/scoped-component.js'\nimport {setDOMImpl} from './lib/utils/dom-helper.js'\nimport {declareNamespace} from './lib/utils/namespaces.js'\nimport {version} from '../package.json'\n\nconst registerNS = (attrs, component) => {\n\tfor (let i in attrs) {\n\t\tif (i.indexOf('xmlns:') === 0) {\n\t\t\tconst [, prefix] = i.split(':')\n\t\t\tcomponent.__local_namespaces[prefix] = attrs[i]\n\t\t}\n\t}\n}\n\n// Iintialize components\nconst initComponent = (node, component) => {\n\tconst nodeType = typeOf(node)\n\tswitch (nodeType) {\n\t\tcase 'array': {\n\t\t\tconst [info, ...childNodes] = node\n\t\t\tif (typeOf(info) === 'object') {\n\t\t\t\tif (info.a) registerNS(info.a, component)\n\t\t\t\tfor (let i of childNodes) initComponent(i, component)\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t\tcase 'object': {\n\t\t\tif (node.t > 1) throw new TypeError(`[EF] Not a standard ef.js AST: Unknown mounting point type '${node.t}'`)\n\t\t\tapplyMountingPoint(node.t, node.n, component)\n\t\t\tbreak\n\t\t}\n\t\tcase 'string': {\n\t\t\tbreak\n\t\t}\n\t\tdefault: {\n\t\t\tthrow new TypeError(`[EF] Not a standard ef.js AST: Unknown node type '${nodeType}'`)\n\t\t}\n\t}\n}\n\n/**\n * @typedef {import('./mount-options.js').EFMountOption} EFMountOption\n * @typedef {import('./mount-options.js').EFMountConfig} EFMountConfig\n * @typedef {import('./lib/renderer.js').EFAST} EFAST\n * @typedef {import('./lib/renderer.js').EFBaseClass} EFBaseClass\n * @typedef {import('./lib/renderer.js').EFEventHandlerArg} EFEventHandlerArg\n * @typedef {import('./lib/renderer.js').EFEventHandlerMethod} EFEventHandlerMethod\n * @typedef {import('./lib/renderer.js').EFSubscriberHandlerArg} EFSubscriberHandlerArg\n * @typedef {import('./lib/renderer.js').EFSubscriberHandlerMethod} EFSubscriberHandlerMethod\n * @typedef {import('./lib/renderer.js').EFTemplateScope} EFTemplateScope\n * @typedef {import('./lib/renderer.js').Fragment} Fragment\n * @typedef {import('./lib/renderer.js').EFNodeWrapper} EFNodeWrapper\n * @typedef {import('./lib/renderer.js').EFTextFragment} EFTextFragment\n * @typedef {import('./lib/utils/event-helper.js').EFEventOptions} EFEventOptions\n */\n\n// eslint-disable-next-line valid-jsdoc\n/**\n * Create a brand new component class for the new component\n * @param {EFAST} ast - AST for the component\n */\nconst create = (ast) => {\n\n\t/**\n\t * The very basic component which users can use\n\t * @class EFComponent\n\t * @param {Object=} initState - Initial state for the component to create with\n\t * @param {EFTemplateScope=} scope - Scope for the component to render template with\n\t */\n\tconst EFComponent = class extends EFBaseComponent {\n\n\t\t/**\n\t\t * Create an EFComponent with initial state\n\t\t * @param {Object=} initState - Initial state for the component to create with\n\t\t * @param {EFTemplateScope=} scope - Scope for the component to render template with\n\t\t */\n\t\tconstructor(initState, scope) {\n\t\t\tinform()\n\t\t\tsuper(ast, scope)\n\t\t\tif (initState) this.$update(initState)\n\t\t\texec()\n\t\t}\n\t}\n\n\t// Workaround for a bug of buble\n\t// https://github.com/bublejs/buble/issues/197\n\tObject.defineProperty(EFComponent.prototype, 'constructor', {enumerable: false})\n\n\tObject.defineProperty(EFComponent, '__local_namespaces', {enumerable: false, value: {}})\n\tinitComponent(ast, EFComponent)\n\treturn EFComponent\n}\n\nexport {\n\tcreate,\n\tmapAttrs,\n\tcreateElement,\n\tEFNodeWrapper,\n\tEFTextFragment,\n\tFragment,\n\ttoEFComponent,\n\tscoped,\n\tonNextRender,\n\tinform,\n\texec,\n\tbundle,\n\tisPaused,\n\tmountOptions,\n\tsetDOMImpl,\n\tdeclareNamespace,\n\tversion\n}\n\nif (process.env.NODE_ENV !== 'production') dbg.info(`ef-core v${version} initialized!`)\n","// Import everything\nimport parse from './lib/parser.js'\nimport typeOf from 'ef-core/src/lib/utils/type-of.js'\nimport { mixStr } from 'ef-core/src/lib/utils/literals-mix.js'\nimport parseEft from 'eft-parser'\nimport { version } from '../package.json'\n// Import core components\nimport {\n\tcreate as createComponent,\n\tcreateElement,\n\tmapAttrs,\n\tEFNodeWrapper,\n\tEFTextFragment,\n\tFragment,\n\tscoped,\n\tonNextRender,\n\tinform,\n\texec,\n\tbundle,\n\tisPaused,\n\tsetDOMImpl,\n\tdeclareNamespace,\n\tmountOptions\n} from 'ef-core'\n\n// Set parser\nlet parser = parseEft\n\n/**\n * @typedef {import('ef-core/src/ef-core.js').EFMountOption} EFMountOption\n * @typedef {import('ef-core/src/ef-core.js').EFMountConfig} EFMountConfig\n * @typedef {import('ef-core/src/ef-core.js').EFAST} EFAST\n * @typedef {import('ef-core/src/ef-core.js').EFBaseClass} EFBaseClass\n * @typedef {import('ef-core/src/ef-core.js').EFEventHandlerArg} EFEventHandlerArg\n * @typedef {import('ef-core/src/ef-core.js').EFEventHandlerMethod} EFEventHandlerMethod\n * @typedef {import('ef-core/src/ef-core.js').EFSubscriberHandlerArg} EFSubscriberHandlerArg\n * @typedef {import('ef-core/src/ef-core.js').EFSubscriberHandlerMethod} EFSubscriberHandlerMethod\n * @typedef {import('ef-core/src/ef-core.js').EFTemplateScope} EFTemplateScope\n * @typedef {import('ef-core/src/ef-core.js').Fragment} Fragment\n * @typedef {import('ef-core/src/ef-core.js').EFNodeWrapper} EFNodeWrapper\n * @typedef {import('ef-core/src/ef-core.js').EFTextFragment} EFTextFragment\n * @typedef {import('ef-core/src/ef-core.js').EFEventOptions} EFEventOptions\n */\n\n// eslint-disable-next-line valid-jsdoc\n/**\n * Return a brand new class for the new component\n * @param {string|EFAST} value - Template or AST for the component\n */\nconst create = (value) => {\n\tconst valType = typeOf(value)\n\tif (valType === 'string') value = parse(value, parser)\n\telse if (valType !== 'array') throw new TypeError('Cannot create new component without proper template or AST!')\n\n\treturn createComponent(value)\n}\n\n/**\n * Change parser\n * @param {Function} newParser - Parser you want to change with\n * @returns {void}\n */\nconst setParser = (newParser) => {\n\tparser = newParser\n}\n\n// eslint-disable-next-line valid-jsdoc\n/**\n * Tagged template to quickly create an inline ef component class\n * @param {...*} args - String literal\n */\nconst t = (...args) => create(mixStr(...args))\n\nexport {\n\tt,\n\tcreate,\n\tcreateElement,\n\tmapAttrs,\n\tEFNodeWrapper,\n\tEFTextFragment,\n\tFragment,\n\tscoped,\n\tonNextRender,\n\tinform,\n\texec,\n\tbundle,\n\tisPaused,\n\tsetParser,\n\tparseEft,\n\tmountOptions,\n\tsetDOMImpl,\n\tdeclareNamespace,\n\tversion\n}\n\nif (process.env.NODE_ENV !== 'production') console.info(`[EF] ef.js v${version} initialized!`)\n","import eftParser from 'eft-parser'\n\nconst parse = (template, parser) => {\n\tif (!parser) parser = eftParser\n\treturn parser(template)\n}\n\nexport default parse\n","import {assign} from './polyfills.js'\n\n/**\n * @typedef {import('../renderer.js').EFBaseClass} EFBaseClass\n * @typedef {import('../renderer.js').EFTemplateScope} EFTemplateScope\n */\n\n/**\n * Attach a default scope to the component class\n * @template {component} T\n * @param {EFBaseClass} component - Component class to be scoped\n * @param {EFTemplateScope} initScope - Scope to be bond on the component class\n * @returns {T} - Scoped component class\n */\nconst scoped = (component, initScope) => class extends component {\n\tconstructor(state, scope = {}) {\n\t\tconst _scope = assign({}, initScope)\n\t\tsuper(state, assign(_scope, scope))\n\t}\n}\n\nexport default scoped\n"],"names":["const","char","doubleChar","oct","RegExp","ucp","uni","hex","esc","b","t","n","v","f","r","O2C","SyntaxError","UC2C","val","substr","length","parseInt","String","fromCodePoint","err","U2C","substring","fromCharCode","X2C","efEscape","string","escaped","split","let","escapedStr","replace","push","join","checkEscape","splitWith","escapedSplit","i","splitBy","splitArr","shift","reserved","mustache","spaceIndent","hashref","getErrorMsg","msg","line","checkValidType","obj","indexOf","ESCAPE","parsed","JSON","parse","e","splitDefault","slice","pathArr","_path","trim","map","_default","defaultVal","splitLiterals","strs","tmpl","mustaches","match","pushStr","textArr","str","parseText","result","exprs","dotToSpace","getOption","options","keys","option","keyCode","isNaN","s","p","h","a","c","u","console","warn","setOption","parseLine","parsingInfo","offset","offsetReg","getOffset","trimmedLine","removed","prevDepth","removeOffset","indentReg","spaces","getIndent","depth","content","test","getDepth","prevType","topExists","type","currentNode","ast","resolveDepth","info","tagInfo","ref","tag","class","parseTag","newNode","splitted","name","value","parseNodeAttrs","propPath","parseNodeProps","parseEvent","l","listener","ops","k","getEventOptions","escapedName","splitEvents","m","method","_value","parseEft","template","TypeError","tplType","lines","Array","isArray","Object","hasOwnProperty","call","typeOf","mixStr","getVal","data","mixVal","proto","prototype","ARR","copy","arr","empty","equals","left","right","pop","apply","items","remove","item","index","splice","reverse","rightUnique","newArr","j","sort","fn","args","unshift","Set","from","unique","modificationQueue","domQueue","userQueue","count","queue","handlers","queueDom","handler","inform","execUserQueue","userFnQueue","exec","immediate","renderQueue","execModifications","domRenderQueue","execDomModifications","setTimeout","legacyAssign","ee","er","assign","defineNode","key","node","defineProperty","get","set","configurable","enumerable","resolve","parentNode","resolveReactivePath","subscribers","innerData","handlerNode","subscriberNode","dataNode","resolveAllPath","_key","undefined","isnan","strTpl","dbg","log","bind","error","initBinding","ctx","subscriberExecuting","subscriber","state","initDataNode","isInstance","constructor","enumerableFalse","classObj","prepareArgs","self","isBrowser","document","Node","shared","mountingPointStore","WeakMap","DOM","EFFragment","this","$children","$safeZone","createDocumentFragment","append","appendTo","removeChild","appendNode","tempFragment","$ctx","nodeInfo","element","placeholder","handleMountingPoint","nodeType","mountingPoint","before","nodes","EFBaseComponent","$mount","target","appendChild","insertBefore","after","nextSibling","children","toEFComponent","$umount","setDOMImpl","sim","getEvent","bubbles","cancelable","event","createEvent","initEvent","namespaces","html","svg","math","xlink","getNamespace","prefix","Error","typeValid","getElement","tagContent","creationOption","tagName","attrs","is","namespace","createElementNS","createElement","createByTag","refs","regTmpl","_handler","addAttr","attr","custom","setAttributeNS","localNamespaces","setAttribute","removeAttribute","removeAttributeNS","getAttrHandler","addProp","keyPath","lastKey","lastNode","resolvePath","addListener","dispatch","expr","_update","$data","canceoable","radios","querySelectorAll","selected","dispatchEvent","checked","addValListener","rawHandler","addEvent","shiftKey","altKey","ctrlKey","metaKey","which","stopPropagation","stopImmediatePropagation","preventDefault","methods","DOMARR","$destroy","clear","poped","elements","parent","anchor","tempArr","shifted","sorted","spliced","mountOptions","BEFORE","AFTER","APPEND","REPLACE","svgNS","mathNS","htmlNS","nullComponent","create","mountingPointUpdaters","child","fragment","resolveAST","createTextNode","textNode","textContent","bindTextNode","isFragment","safeZone","bindMountingNode","defineProperties","bindMountingList","previousNamespace","isLocalPrefix","isPrototypeOf","scope","scoped","namespaceURI","unprefixedTagName","xmlns","toLowerCase","childNodes","getGetter","checkTrue","base","getSetter","baseNode","_trueVal","trueVal","_falseVal","falseVal","defaultRoot","getBase","root","mapAttrs","tpl","attrMap","basicProperty","mount","__local_namespaces","prototypeAccessors","newData","$methods","newMethods","$refs","querySelector","$subscribe","pathStr","$unsubscribe","resolveSubscriber","unsubscribe","$update","newState","$dispatch","$emit","eventName","$on","addEventListener","$off","removeEventListener","delete","fragmentAST","EFNodeWrapper","super","prototypeAccessors$1","$el","Fragment","textFragmentAst","EFTextFragment","text","stringify","flatten","prev","initComponent","component","registerNS","parser","EFComponent","valType","eftParser","initState","cb","reduce","transformedAttrs","initScope","_scope","newParser"],"mappings":"0OACAA,IAAMC,EAAO,IACPC,EAAaD,KAGbE,EAAM,IAAIC,uBAA8B,KACxCC,EAAM,IAAID,uBAA8B,KACxCE,EAAM,IAAIF,oBAA2B,KACrCG,EAAM,IAAIH,oBAA2B,KACrCI,EAAM,IAAIJ,aAAoB,KAC9BK,EAAI,IAAIL,cAAqB,KAC7BM,EAAI,IAAIN,cAAqB,KAC7BO,EAAI,IAAIP,cAAqB,KAC7BQ,EAAI,IAAIR,cAAqB,KAC7BS,EAAI,IAAIT,cAAqB,KAC7BU,EAAI,IAAIV,cAAqB,KAG7BW,aACL,MAAM,IAAIC,YAAY,oDAIjBC,WAAQC,GAGb,GAFAA,EAAMA,EAAIC,OAAO,EAAGD,EAAIE,OAAS,KACjCF,EAAMG,SAASH,EAAK,KACV,MAAM,IAAIF,YAAY,mCAChC,IACC,OAAOM,OAAOC,cAAcL,GAC3B,MAAOM,GACR,MAAM,IAAIR,YAAY,kCAKlBS,WAAOP,GAGZ,GAFAA,EAAMA,EAAIQ,UAAU,KACpBR,EAAMG,SAASH,EAAK,KACV,MAAM,IAAIF,YAAY,mCAChC,OAAOM,OAAOK,aAAaT,IAItBU,WAAOV,GAGZ,GAFAA,EAAM,KAAKA,EAAIQ,UAAU,KACzBR,EAAMG,SAASH,EAAK,KACV,MAAM,IAAIF,YAAY,uCAChC,OAAOM,OAAOK,aAAaT,IAGtBW,WAAYC,GAMjB,IAJA9B,IACM+B,EAAU,SADCD,EAAOE,MAAM9B,mBAIN,CAAnB+B,IACEC,OACJC,QAAQhC,EAAKY,GACboB,QAAQ9B,EAAKY,GACbkB,QAAQ7B,EAAKmB,GACbU,QAAQ5B,EAAKqB,GACbO,QAAQ1B,EAAG,MACX0B,QAAQzB,EAAG,MACXyB,QAAQxB,EAAG,MACXwB,QAAQvB,EAAG,MACXuB,QAAQtB,EAAG,MACXsB,QAAQrB,EAAG,MAEXqB,QAAQ3B,EAAK,IACfuB,EAAQK,KAAKF,GAGd,OAAOH,EAAQM,KAAKpC,IAGfqC,WAAcR,UAAUA,EAAOA,EAAOV,OAAS,KAAOnB,GAEtDsC,WAAaT,EAAQ7B,GAI1B,IAHAD,IACMwC,EAAe,GACjBT,GAAU,QAFGD,EAAOE,MAAM/B,mBAGN,CAAnBgC,IAAIQ,OACJV,EAASS,EAAaA,EAAapB,OAAS,IAAM,GAAGnB,EAAOwC,EAC3DD,EAAaJ,KAAKK,GACvBV,EAAUO,EAAYG,GAEvB,OAAOD,GAGFE,WAAWZ,EAAQ7B,GAGxB,IAFAD,IAAM2C,EAAWb,EAAOE,MAAM9B,GACxB6B,EAAUQ,EAAUI,EAASC,QAAS3C,SAC9B0C,kBAAU,CAAnBV,IAAIQ,OACFD,EAAeD,EAAUE,EAAGxC,GAClC8B,EAAQA,EAAQX,OAAS,IAAM,KAAgBoB,EAAaI,QAC5Db,EAAQK,aAAQI,GAEjB,OAAOT,GC/FFc,EAAW,CAChB,OAAQ,QAAS,QAAS,WAAY,SAAU,UAAW,aAAc,eAAgB,UACzF,YAAa,QAAS,MAAO,OAAQ,WAAY,mBAE5CC,EAAW,eACXC,EAAc,eACdC,EAAU,kBAEVC,WAAeC,EAAKC,0BAAQ,oCAAuCD,gBAAgBC,EAAO,IAI1FC,WAAiBC,SAAO,CAAC,SAAU,UAAW,UAAUC,eAAeD,IAAQ,GAE/EE,WAAUzB,GACf,IAAKA,EAAQ,MAAO,CAACA,GAAQ,GAC7B,IACC9B,IAAMwD,EAASC,KAAKC,MAAM5B,GAC1B,OAAsD,IAAlD,CAAC,SAAU,WAAWwB,eAAeE,GAAuB,CAAC3B,EAASC,IAAS,GAC5E,CAAC0B,GAAQ,GACf,MAAOG,GACR,MAAO,CAAC9B,EAASC,IAAS,KA+CtB8B,WAAgB9B,GACrBA,EAASA,EAAO+B,MAAM,EAAG/B,EAAOV,OAAS,SACZsB,EAAQZ,EAAQ,yBACvCgC,EAAUpB,EAAQqB,EAAMC,OAAQ,KAAKC,IAAIpC,KACjB0B,EAAOW,EAAS7B,KAAK,KAAK2B,sBACxD,OAAIZ,EAAee,KAAgBpC,IAAaA,GAA0B,KAAfoC,GAA4B,CAACL,EAASK,GAC1F,CAACL,IAGHM,WAAiBtC,GACtB9B,IAAMqE,EAAOvC,EAAOE,MAAMc,GAC1B,GAAoB,IAAhBuB,EAAKjD,OAAc,OAAOmC,EAAOzB,GAAQ,GAC7C9B,IAAMsE,EAAO,GACO,IAAhBD,EAAKjD,QAAiBiD,EAAK,IAAOA,EAAK,GACtCC,EAAKlC,KAAKiC,EAAKJ,IAAIpC,IADuByC,EAAKlC,KAAK,GAEzDpC,IAAMuE,EAAYzC,EAAO0C,MAAM1B,GAE/B,OADIyB,GAAWD,EAAKlC,aAAQmC,EAAUN,IAAIL,IACnCU,GAGFG,WAAWC,EAASC,GACrBA,GAAKD,EAAQtC,KAAKuC,IAGjBC,WAAa9C,GAClB9B,IAAM6E,EAAST,EAActC,GAC7B,GAAIsB,EAAeyB,GAAS,MAAO,IAAIA,GAGvC,IAFO,wBACDH,EAAU,GACPjC,EAAI,EAAGA,EAAIqC,EAAM1D,OAAQqB,IACjCgC,EAAQC,EAASL,EAAK5B,IACtBiC,EAAQtC,KAAK0C,EAAMrC,IAGpB,OADAgC,EAAQC,EAASL,EAAKA,EAAKjD,OAAS,IAC7BsD,GAGFK,WAAa7D,UAAOA,EAAIiB,QAAQ,MAAO,MA+EvC6C,WAAaC,EAASC,EAAMC,GACjCnF,IAAMoF,EAAU/D,SAAS8D,EAAQ,IACjC,GAAIE,MAAMD,GAAU,gBA1CFH,EAASE,GAC3B,OAAQA,GACP,IAAK,OACJF,EAAQK,EAAI,EACZ,MAED,IAAK,gBACJL,EAAQxC,EAAI,EACZ,MAED,IAAK,UACJwC,EAAQM,EAAI,EACZ,MAED,IAAK,QACJN,EAAQO,EAAI,EACZ,MAED,IAAK,MACJP,EAAQQ,EAAI,EACZ,MAED,IAAK,OACJR,EAAQS,EAAI,EACZ,MAED,IAAK,OACJT,EAAQvE,EAAI,EACZ,MAED,IAAK,UACJuE,EAAQU,EAAI,EACZ,MAED,QACCC,QAAQC,gDAAgDV,SAO/BW,CAAUb,EAASpD,EAASsD,IACvDD,EAAK9C,KAAKgD,IAqBLW,6DACL,GAAY5C,EAvMqBhB,QAAQ,KAAM,IAuM/C,WAxLkBL,EAAQkE,GACC,OAAvBA,EAAYC,SAChBD,EAAYC,OAASnE,EAAO0C,MAAM,OAAO,GACrCwB,EAAYC,SAAQD,EAAYE,UAAYF,EAAYC,SAsL5DE,CAAUhD,EAAM6C,GAEhBhG,IAAMoG,WArLetE,EAAQkE,EAAavD,GAC1C,GAAIuD,EAAYE,UAAW,CAC1BjE,IAAIoE,GAAU,EAKd,GAJAvE,EAASA,EAAOK,QAAQ6D,EAAYE,sBAEnC,OADAG,GAAU,EACH,OAEHA,EAAS,MAAM,IAAIrF,YAAYiC,wDAAiE+C,EAAYM,UAAY,kBAAiB7D,IAE/I,OAAOX,EA4KayE,CAAapD,EAAM6C,EAAavD,aAzKlCX,EAAQkE,GAC1B,IAAIA,EAAYQ,UAAhB,CACAxG,IAAMyG,EAAS3E,EAAO0C,MAAMzB,GAAa,GACrC0D,IACHT,EAAYQ,UAAY,IAAIpG,OAAOqG,EAAQ,OAsK5CC,CAAUN,EAAaJ,kBAlKNlE,EAAQkE,EAAavD,GACtCR,IAAI0E,EAAQ,EACRX,EAAYQ,YAAW1E,EAASA,EAAOK,QAAQ,iBAAQwC,UAAOA,EAAIxC,QAAQ6D,EAAYQ,UAAW,UACrGxG,IAAM4G,EAAU9E,EAAOK,QAAQ,iBAASwC,GAEvC,OADAgC,EAAQhC,EAAIvD,OACL,MAER,GAAI,MAAQyF,KAAKD,GAAU,MAAM,IAAI5F,YAAYiC,EAAY,aAAcR,IAC3E,MAAO,OAAEkE,UAAOC,GA4JSE,CAASV,EAAaJ,EAAavD,yBAE5D,GAAImE,EAAS,CACZ,GAAID,EAAQ,GAAKA,EAAQX,EAAYM,UAAY,GAAMK,EAAQX,EAAYM,WAAc,IAA2D,IAAtD,CAAC,UAAW,OAAOhD,QAAQ0C,EAAYe,WAA+C,YAAzBf,EAAYe,UAAoC,IAAVJ,GAAeX,EAAYgB,UAAY,MAAM,IAAIhG,YAAYiC,wDAAiE+C,EAAYM,UAAY,gBAAcK,EAASlE,IAC9WzC,IAAMiH,EAAOL,EAAQ,GAErB,KADAA,EAAUA,EAAQ/C,MAAM,KA7NN,UA8NUP,QAAQ2D,IAAS,EAAG,MAAM,IAAIjG,YAAYiC,EAAY,gBAAiBR,IAKnG,QAHIkE,EAAQX,EAAYM,WAAcK,IAAUX,EAAYM,WAAsC,QAAzBN,EAAYe,YAAqBf,EAAYkB,qBAjKlGC,EAAKR,GAE1B,IADA1E,IAAIiF,EAAcC,EACT1E,EAAI,EAAGA,EAAIkE,EAAOlE,IAAKyE,EAAcA,EAAYA,EAAY9F,OAAS,GAC/E,OAAO8F,EA8J8HE,CAAaD,EAAKR,IACtJX,EAAYM,UAAYK,EAEhBM,GACP,IAAK,IACJjH,IAAMqH,WAzHQvF,GACjB9B,IAAMsH,EAAU,KACU5E,EAAQZ,EAAOK,QAAQa,YAAU9B,GAE1D,OADAoG,EAAQC,IAAMrG,EAAI2C,MAAM,GACjB,MACJ,yBAKJ,OAJAyD,EAAQE,IAAM3F,EAAS2F,GACvBF,EAAQG,MAAQrD,EAAcwC,EAAQvE,KAAK,MACd,iBAAlBiF,EAAQG,MAAoBH,EAAQG,MAAQ1C,EAAWuC,EAAQG,OAAOzD,OACxEsD,EAAQG,MAAM,KAAIH,EAAQG,MAAM,GAAKH,EAAQG,MAAM,GAAGxD,IAAIc,IAC5DuC,EA+GSI,CAASd,GAChBe,EAAU,CAAC,CAChBjH,EAAG2G,EAAKG,MAELH,EAAKI,QACRE,EAAQ,GAAGlC,EAAI,GACfkC,EAAQ,GAAGlC,EAAEgC,MAAQJ,EAAKI,OAEvBJ,EAAKE,MAAKI,EAAQ,GAAG7G,EAAIuG,EAAKE,KAClCvB,EAAYkB,YAAY9E,KAAKuF,GAC7B3B,EAAYkB,YAAcS,EAC1B3B,EAAYe,SAAW,MACvB,MAED,IAAK,mBA1HgBjF,GACvB9B,IAAM4H,EAAWlF,EAAQZ,EAAQ,KACjC,MAAO,CACN+F,KAAMhG,EAAS+F,EAAShF,QAAQoB,QAChC8D,MAAO1D,EAAcwD,EAASvF,KAAK,KAAK2B,SAuHd+D,CAAenB,sBAClCZ,EAAYkB,YAAY,GAAGzB,IAAGO,EAAYkB,YAAY,GAAGzB,EAAI,IAClEO,EAAYkB,YAAY,GAAGzB,EAAEoC,GAAQC,EACrC9B,EAAYe,SAAW,OACvB,MAED,IAAK,mBAzHgBjF,GACvB9B,IAAM4H,EAAWlF,EAAQZ,EAAQ,KACjC,MAAO,CACNkG,SAAUtF,EAAQkF,EAAShF,QAAQoB,OAAQ,KAAKC,IAAIpC,GACpDiG,MAAO1D,EAAcwD,EAASvF,KAAK,KAAK2B,SAsHViE,CAAerB,0BACtCZ,EAAYkB,YAAY,GAAG3B,IAAGS,EAAYkB,YAAY,GAAG3B,EAAI,IAClES,EAAYkB,YAAY,GAAG3B,EAAEnD,KAAK,CAAC4F,EAAUF,IAC7C9B,EAAYe,SAAW,OACvB,MAED,IAAK,mBAxHYjF,GACnB9B,IAAM4H,EAAWlF,EAAQZ,EAAQ,KACjC,MAAO,CACN+F,KAAMD,EAAShF,QAAQoB,OACvB8D,MAAOF,EAASvF,KAAK,KAAK2B,QAqHAkE,CAAWtB,sBAC9BZ,EAAYkB,YAAY,GAAGvD,IAAGqC,EAAYkB,YAAY,GAAGvD,EAAI,IAClE3D,IAAMiF,WArEe4C,GACxB7H,IAAMiF,EAAU,GACVC,EAAO,KACcxC,EAAQmF,EAAM,yBACzC5C,EAAQkD,EAAItG,EAASuG,GACrB,cAAcC,mBAATpG,IAAIQ,OAAUuC,EAAUC,EAASC,EAAMzC,GAE5C,OADIyC,EAAK9D,OAAS,IAAG6D,EAAQqD,EAAIpD,GAC1BD,EA8DYsD,CAAgBV,cA3Df/F,SACKY,EAAQZ,EAAQ,YACnC8E,aAAgBvE,KAAK,KACrBmG,EAAc3G,EAASgG,EAAK7D,QAClC,OAAI4C,EAAgB,CAAC4B,EAAapE,EAAcwC,IACzC,CAAC4B,GAuDoBC,CAAYX,iBACrC7C,EAAQyD,EAAIC,EACRC,IAAQ3D,EAAQrE,EAAIgI,GACxB5C,EAAYkB,YAAY,GAAGvD,EAAEvB,KAAK6C,GAClCe,EAAYe,SAAW,QACvB,MAED,IAAK,OACJf,EAAYkB,aAAY9E,aAAQwC,EAAUgC,IAC1CZ,EAAYe,SAAW,OACvB,MAED,IAAK,IACAf,EAAYkB,YAAY9F,OAAS,IAAGwF,EAAU,KAAKA,MACvDZ,EAAYkB,aAAY9E,aAAQwC,EAAUgC,IAC1CZ,EAAYe,SAAW,iBACvB,MAED,IAAK,IACJ,IAAmC,IAA/BlE,EAASS,QAAQsD,GAAiB,MAAM,IAAI5F,YAAYiC,oBAA8B2D,yBAA+BnE,IACzHuD,EAAYkB,YAAY9E,KAAK,CAC5BzB,EAAGiG,EACHlG,EAAG,IAEJsF,EAAYe,SAAW,OACvB,MAED,IAAK,IACJf,EAAYkB,YAAY9E,KAAK,CAC5BzB,EAAGiG,EACHlG,EAAG,IAEJsF,EAAYe,SAAW,OACvB,MAED,QACCf,EAAYe,SAAW,cAMrB8B,WAAYC,GACjB,IAAKA,EAAU,MAAM,IAAIC,UAAU9F,EAAY,yCAC/CjD,IAAMgJ,SAAiBF,EACvB,GAAgB,WAAZE,EAAsB,MAAM,IAAID,UAAU9F,qCAA+C+F,IAY7F,IAXAhJ,IAAMiJ,EAAQH,EAAS9G,MAAM,SACvBmF,EAAM,CAAC,CAACzG,EAAG,IACXsF,EAAc,CACnBQ,UAAW,KACXF,UAAW,EACXL,OAAQ,KACRC,UAAW,KACXa,SAAU,UACVG,YAAaC,EACbH,WAAW,GAEHvE,EAAI,EAAGA,EAAIwG,EAAM7H,OAAQqB,IAAKsD,EAAU,CAAC5C,KAAM8F,EAAMxG,OAAI0E,cAAKnB,IAAavD,IAEpF,GAAI0E,EAAI/F,QAAU,EAAG,MAAM,IAAIJ,YAAYiC,EAAY,uBAAwBgG,EAAM7H,OAAS,IAC9F,OAAmB,IAAf+F,EAAI/F,QAAgB8H,MAAMC,QAAQhC,EAAI,KAAOiC,OAAOC,eAAeC,KAAKnC,EAAI,GAAG,GAAI,KAAaA,EAAI,GACjGA,GCpUFoC,WAAUlG,GACf,OAAI6F,MAAMC,QAAQ9F,GAAa,eACjBA,GCFTmG,WAAUnF,iEAEf,IADApC,IAAIH,EAAS,GACJW,EAAI,EAAGA,EAAIqC,EAAM1D,OAAQqB,SACT,IAAbqC,EAAMrC,GAAoBX,GAAUuC,EAAK5B,GAC/CX,GAAWuC,EAAK5B,GAAKqC,EAAMrC,GAEjC,OAAOX,EAASuC,EAAKA,EAAKjD,OAAS,IAG9BqI,kBACCC,qBACN,YAAoB,IAATA,EAA6B,GACjCA,GAGFC,WAAUtF,iEACf,IAAKA,EAAM,OAAOoF,EAAO3E,EAAM,IAC/B9E,IAAM8I,EAAW,CAACzE,GAElB,OADAyE,EAAS1G,aAAQ0C,EAAMb,IAAIwF,IACpBD,eAAUV,ICnBZc,EAAQV,MAAMW,UAEdC,EAAM,CACXC,cAAKC,GACJ,OAAOJ,EAAM/F,MAAMyF,KAAKU,EAAK,IAE9BC,eAAMD,GAEL,OADAA,EAAI5I,OAAS,EACN4I,GAERE,gBAAOC,EAAMC,GACZ,IAAKlB,MAAMC,QAAQiB,GAAQ,OAAO,EAClC,GAAID,IAASC,EAAO,OAAO,EAC3B,GAAID,EAAK/I,SAAWgJ,EAAMhJ,OAAQ,OAAO,EACzC,IAAKa,IAAIQ,EAAI,EAAG0F,EAAIgC,EAAK/I,OAAQqB,EAAI0F,EAAG1F,IACvC,GAAI0H,EAAK1H,KAAO2H,EAAM3H,GAAI,OAAO,EAElC,OAAO,GAER4H,aAAIL,GACH,OAAOJ,EAAMS,IAAIf,KAAKU,IAEvB5H,cAAK4H,iEACJ,OAAOJ,EAAMxH,KAAKkI,MAAMN,EAAKO,IAE9BC,gBAAOR,EAAKS,GACXzK,IAAM0K,EAAQd,EAAMtG,QAAQgG,KAAKU,EAAKS,GACtC,GAAIC,GAAS,EAEZ,OADAd,EAAMe,OAAOrB,KAAKU,EAAKU,EAAO,GACvBD,GAGTG,iBAAQZ,GACP,OAAOJ,EAAMgB,QAAQtB,KAAKU,IAE3Ba,qBAAYb,GAEX,IADAhK,IAAM8K,EAAS,GACNrI,EAAI,EAAGA,EAAIuH,EAAI5I,OAAQqB,IAAK,CACpC,IAAKR,IAAI8I,EAAItI,EAAI,EAAGsI,EAAIf,EAAI5I,OAAQ2J,IAASf,EAAIvH,KAAOuH,EAAIe,KAAIA,EAAItI,GAAK,GACzEqI,EAAO1I,KAAK4H,EAAIvH,IAEjB,OAAOqI,GAERlI,eAAMoH,GACL,OAAOJ,EAAMhH,MAAM0G,KAAKU,IAEzBnG,eAAMmG,EAAKU,EAAOtJ,GACjB,OAAOwI,EAAM/F,MAAMyF,KAAKU,EAAKU,EAAOtJ,IAErC4J,cAAKhB,EAAKiB,GACT,OAAOrB,EAAMoB,KAAK1B,KAAKU,EAAKiB,IAE7BN,gBAAOX,iEACN,OAAOJ,EAAMe,OAAOL,MAAMN,EAAKkB,IAEhCC,iBAAQnB,iEACP,OAAOJ,EAAMuB,QAAQb,MAAMN,EAAKO,KAIf,oBAARa,KAAuBlC,MAAMmC,KAAMvB,EAAIwB,gBAAStB,UAAOd,MAAMmC,KAAK,IAAID,IAAIpB,KAChFF,EAAIwB,OAASxB,EAAIe,YC3DtB7K,IAAMuL,EAAoB,GACpBC,EAAW,GACXC,EAAY,GACdC,EAAQ,EAENC,WAAQC,UAAYL,EAAkBnJ,aAAQwJ,IAC9CC,WAAWC,UAAWN,EAASpJ,KAAK0J,IAapCC,aAEL,OADAL,GAAS,GAkBJM,aACL,GAAyB,IAArBP,EAAUrK,OAAd,CACApB,IAAMiM,EAAcnC,EAAIwB,OAAOG,GAC/B3B,EAAIG,MAAMwB,GACV,cAAcQ,oBAAaxJ,aAStByJ,WAAQC,GACb,OAAKA,IAAcT,GAAS,GAAK,IACjCA,EAAQ,EAEJH,EAAkBnK,OAAS,cA9B/B,GAAiC,IAA7BmK,EAAkBnK,OAAtB,CACApB,IAAMoM,EAActC,EAAIwB,OAAOC,GAC/BzB,EAAIG,MAAMsB,GACV,cAAca,mBAAa3J,WA2BO4J,GAE9Bb,EAASpK,OAAS,cAzBtB,GAAwB,IAApBoK,EAASpK,OAAb,CACApB,IAAMsM,EAAiBxC,EAAIe,YAAYW,GACvC1B,EAAIG,MAAMuB,GACV,cAAcc,mBAAgB7J,WAsBL8J,GAGrBd,EAAUrK,OAAS,GAAGoL,WAAWR,EAAe,IARTN,GCrDtCe,WAAgBC,EAAIC,GACzB,IAAK1K,IAAIQ,KAAKkK,EAAID,EAAGjK,GAAKkK,EAAGlK,GAC7B,OAAOiK,GAGFE,EAASxD,OAAOwD,QAAUH,ECe1BI,YAAcC,EAAKzJ,GACxBrD,IAAM+M,EAAO,GAab,OAZA3D,OAAO4D,eAAe3J,EAAKyJ,EAAK,CAC/BG,eACC,OAAOF,GAERG,aAAIxD,GACHqC,IACAa,EAAOG,EAAMrD,GACbwC,KAEDiB,cAAc,EACdC,YAAY,IAENL,GAmBFM,0FACCC,WAjBsBvJ,EAAOV,GACnC,cAAcU,kBAAO,CAAhB9B,IAAIQ,OACIY,EAARA,EAAIZ,GAAUY,EAAIZ,GACXoK,GAAWpK,EAAGY,GAE1B,OAAOA,EAYYkK,CAAoBxJ,EAAO2F,iBAnD9C,mEAAc3F,kBAAO,CAAhB9B,IAAIQ,OACHmJ,EAASnJ,KAAImJ,EAASnJ,GAAK,IAC3B+K,EAAY/K,KAAI+K,EAAY/K,GAAK,IACjCgL,EAAUhL,KAAIgL,EAAUhL,GAAK,IAClCmJ,EAAWA,EAASnJ,GACpB+K,EAAcA,EAAY/K,GAC1BgL,EAAYA,EAAUhL,GAEvB,MAAO,CACNiL,YAAa9B,EACb+B,eAAgBH,EAChBI,SAAUH,GAyCqCI,CAAe,OAAC9J,WAAO6H,cAAU4B,YAAaC,oDAK9F,OAJKC,EAAYI,KAAOJ,EAAYI,GAAQ,IACvCH,EAAeG,KAAOH,EAAeG,GAAQ,IAE7C1E,OAAOS,UAAUR,eAAeC,KAAKsE,EAAUE,KAAOF,EAASE,QAAQC,GACrE,YAACT,EAAYI,YAAaA,EAAYI,GAAOH,eAAgBA,EAAeG,YAAOF,IC5DrFI,YAAQ3K,UAAOA,GAAQA,GCAvB4K,GAAS,UACTC,GAAM,CACXC,IAAKvI,QAAQuI,IAAIC,KAAKxI,QAASqI,IAC/B5G,KAAMzB,QAAQyB,KAAK+G,KAAKxI,QAASqI,IACjCpI,KAAMD,QAAQC,KAAKuI,KAAKxI,QAASqI,IACjCI,MAAOzI,QAAQyI,MAAMD,KAAKxI,QAASqI,KC8B9BK,+EACCvK,EAAQ+F,EAAIC,KAAKqE,EAAK,IACtBN,EAAO/J,EAAMsG,QACyCgD,GAAQ,OACnEtJ,OACA+J,EACApE,KAAM6E,EAAI7E,cACVkC,cACA4B,YACAC,mEASD,OALKrE,OAAOS,UAAUR,eAAeC,KAAKgE,EAAYQ,oGA1ClDU,GAAsB,EAC1BpF,OAAO4D,eAAeM,EAAYQ,EAAM,CACvCb,eACC,OAAOW,EAASE,IAEjBZ,aAAIpF,GACH,IAAI0G,KAEAZ,EAASE,KAAUhG,GAAUkG,GAAMJ,EAASE,KAAUE,GAAMlG,MAChE8F,EAASE,GAAQhG,EACjBiE,IACAJ,EAAM+B,GACNxB,IACIyB,EAAevM,OAAS,GAAG,CAC9BoN,GAAsB,EACtBzC,IACA,IACC,cAAyB4B,mBAAgBc,QAAW,CAACC,MAAOH,EAAIG,YAAO5G,IACtE,MAAOnE,GACRuK,GAAIG,MAAM,6CAA8C1K,GAEzDuI,IACAsC,GAAsB,IAGxBpB,YAAY,IAiBgDuB,CAAa,YAACrB,WAAYM,cAAUF,iBAAaC,MAAgBY,OAAKT,IAG/HM,EAAKhN,OAAS,IAAGkM,EAAWQ,GAAQM,EAAK,IAEtC,UAACR,aAAUN,cAAYI,iBAAaC,OAAgBG,ICtDtDc,YAAcjC,EAAID,UAAOC,EAAGkC,cAAgBnC,GCG5CoC,YAAmBC,EAAU7J,GAClC,cAAcA,mBAATjD,IAAIQ,OAAW2G,OAAO4D,eAAe+B,EAASlF,UAAWpH,EAAG,CAAC2K,YAAY,IAC9E,OAAO2B,GAIFC,YAAeC,EAAMlC,GAC1B/M,IAAMkL,EAAOpB,EAAIC,KAAKkF,GAEtB,OADAnF,EAAIqB,QAAQD,EAAM6B,GACX7B,GCVFgE,GAAgC,oBAAbC,UAA4C,oBAATC,KCFtDC,GAAS,GCYTC,GAAqB,IAAIC,QAEzBC,GAAM,GAENC,cACL,aACCC,KAAKC,UAAY,GACjBD,KAAKE,UAAYJ,GAAIL,SAASU,4CAG/BC,2EAEC,OADAN,GAAIM,OAAOxF,MAAM,KAAM0E,GAAY9D,EAAMwE,KAAKE,eACvCF,KAAKC,WAAUvN,aAAQ8I,gBAG/B6E,kBAAShD,GACRyC,GAAIM,OAAOxF,MAAM,KAAM0E,GAAYU,KAAKC,UAAW5C,iBAGpDiD,qBAAYjD,GACXyC,GAAIhF,OAAOuC,GACXjD,EAAIU,OAAOkF,KAAKC,UAAW5C,gBAG5BvC,kBACC,cAAckF,KAAKC,2BAAd1N,IAAIQ,OAAqB+M,GAAIM,OAAOJ,KAAKE,UAAWnN,UAIrDwN,YAAclD,EAAMmD,SACMnD,EAAKoD,KAAKC,qCACzCZ,GAAIM,OAAOI,EAAcG,EAASC,IAG7BC,YAAuBF,EAASH,GACrC,GAAyB,IAArBG,EAAQG,SAAZ,CAEAxQ,IAAMyQ,EAAgBnB,GAAmBrC,IAAIoD,GAC7C,GAAKI,EAAL,CAEO,aACP,GAAK1D,EACL,GAAI7D,MAAMC,QAAQ4D,GACjB,cAAcA,mBAAT9K,IAAIQ,OAAWwN,GAAWxN,EAAGyN,QAC5BD,GAAWlD,EAAMmD,MAGzBV,GAAIkB,gBAAU3D,iEACb/M,IAAMkQ,EAAeV,GAAIL,SAASU,yBAClC9D,IACA,cAAc4E,kBAAO,CAAhB1O,IAAIQ,OACJA,aAAa4M,GAAOuB,gBACvBnO,EAAEoO,OAAO,CAACC,OAAQZ,IACRtB,GAAWnM,EAAGgN,IAAahN,EAAEsN,SAASG,IAEhDV,GAAIJ,KAAKvF,UAAUkH,YAAYzH,KAAK4G,EAAczN,GAClD8N,GAAoB9N,EAAGyN,IAGzBV,GAAIJ,KAAKvF,UAAUmH,aAAa1H,KAAKyD,EAAKO,WAAY4C,EAAcnD,GACpEb,KAGDsD,GAAIyB,eAASlE,iEACZ/M,IAAMkQ,EAAeV,GAAIL,SAASU,yBAClC9D,IACA,cAAc4E,kBAAO,CAAhB1O,IAAIQ,OACJA,aAAa4M,GAAOuB,gBACvBnO,EAAEoO,OAAO,CAACC,OAAQZ,IACRtB,GAAWnM,EAAGgN,IAAahN,EAAEsN,SAASG,GAC5CV,GAAIJ,KAAKvF,UAAUkH,YAAYzH,KAAK4G,EAAczN,GAEpDsK,EAAKmE,YAAa1B,GAAIJ,KAAKvF,UAAUmH,aAAa1H,KAAKyD,EAAKO,WAAY4C,EAAcnD,EAAKmE,aAC1F1B,GAAIJ,KAAKvF,UAAUkH,YAAYzH,KAAKyD,EAAKO,WAAY4C,GAC1DhE,KAGDsD,GAAIM,gBAAU/C,iEAEb,GAAI6B,GAAW7B,EAAM0C,IAAa,OAAO1C,EAAK+C,eAAUa,GAExD,GAAI5D,aAAgBsC,GAAOuB,gBAA3B,CACC,IAAM1H,MAAMC,QAAQ4D,EAAKoE,UAExB,OAGDpF,IACA,cAAc4E,kBAAO,CAAhB1O,IAAIQ,OACRA,EAAI,IAAI4M,GAAO+B,cAAc3O,GAC7BsK,EAAKoE,SAAS/O,KAAKK,GAEpByJ,SAKD,IAAyC,IAArC,CAAC,EAAE,EAAE,IAAI5I,QAAQyJ,EAAKyD,UAA1B,CAEA,IADAxQ,IAAMkQ,EAAeV,GAAIL,SAASU,+BACpBc,kBAAO,CAAhB1O,IAAIQ,OACJmM,GAAWnM,EAAGgN,IAAahN,EAAEsN,SAASG,GACjCzN,aAAa+M,GAAIJ,MACzBI,GAAIJ,KAAKvF,UAAUkH,YAAYzH,KAAK4G,EAAczN,GAClD8N,GAAoB9N,EAAGyN,IACbzN,aAAa4M,GAAOuB,iBAC9BnO,EAAEoO,OAAO,CAACC,OAAQZ,IAGpBV,GAAIJ,KAAKvF,UAAUkH,YAAYzH,KAAKyD,EAAMmD,KAG3CV,GAAIhF,gBAAUuC,GACT6B,GAAW7B,EAAM0C,IAAa1C,EAAKvC,SAC9BuC,aAAgBsC,GAAOuB,gBAAiB7D,EAAKsE,UACjD7B,GAAIJ,KAAKvF,UAAUmG,YAAY1G,KAAKyD,EAAKO,WAAYP,QA2ErDuE,YAAaC,UAAO3E,EAAO4C,GAAK+B,IAElCrC,IAAWoC,GAAW,MAAClC,cAAMD,WClMjCnP,IAAMwR,YAAY3J,oBAA8B,CAC/C4J,SAAS,EACTC,YAAY,mCAENC,EAAQnC,GAAIL,SAASyC,YAAY,eAEvC,OADAD,EAAME,UAAUhK,EAAM4J,EAASC,GACxBC,GCfFG,GAAa,CAClBC,KAAM,+BACNC,IAAK,6BACLC,KAAM,qCACNC,MAAO,gCAQFC,YAAgBC,GACrB,GAAIN,GAAWM,GAAS,OAAON,GAAWM,GAE1C,MAAM,IAAIC,yBAAyBD,+BCL9BE,YAAYjP,SAAO,CAAC,SAAU,UAAW,UAAUC,eAAeD,IAAQ,GAgC1EkP,yEACClC,qEA5BN,cAFuBmC,GAGtB,IAAK,SACJxS,IAAMyS,EAAiB,GAIvB,OAHIC,IAAYF,GAAcG,GAASA,EAAMC,IAA0B,iBAAbD,EAAMC,KAAiBH,EAAeG,GAAKD,EAAMC,IAGvGC,EAAkBrD,GAAIL,SAAS2D,gBAAgBD,EAAWL,EAAYC,GAEnEjD,GAAIL,SAAS4D,cAAcP,EAAYC,GAE/C,IAAK,WAEJ,OAAO,IAAID,EAEZ,QAIC,OAFIA,EAAWhL,MAAKkL,EAAUF,EAAWhL,KAErCqL,EACIrD,GAAIL,SAAS2D,gBAAgBD,EAAWH,EAAS,CAACE,GAAIJ,EAAWI,KAGlEpD,GAAIL,SAAS4D,cAAcL,EAAS,CAACE,GAAIJ,EAAWI,MAM7CI,CAAY,SAACN,aAASF,QAAYG,0BAKlD,OAJIpL,GAAK6B,OAAO4D,eAAeiG,EAAM1L,EAAK,CACzCO,MAAOuI,EACPjD,YAAY,IAENiD,GAGF6C,0FACL,GAAIhK,MAAMC,QAAQjI,GAAM,CAChB,wBACDoD,EAAO,CAACD,GAER8O,oBAAiBrH,EAAQnC,eAAUrF,KAQzC,OANAA,EAAKlC,aAAQ0C,EAAMb,cAAKwG,SACe6D,GAAY,CAACF,KAAM3D,MAAM8D,WAAK3C,cAAU4B,YAAaC,0CAE3F,OADAC,EAAYtL,KAAK+Q,GACV,UAACvF,OAAUE,OAGZqF,EAER,yBAAajS,IAqFRkS,8GACL,GAAId,GAAUe,GAAO,CACpB,GAAIC,EAGH,YAFiBjD,EAAQvD,GAAZ,KAATuG,GACgBA,GAIrB,GAAY,OAARvG,EAAc,OAElB,GAAIA,EAAIxJ,QAAQ,MAAQ,EAAG,OACTwJ,EAAI9K,MAAM,QAC3B,GAAe,UAAXoQ,EAAoB,OAAO/B,EAAQkD,eAAehF,EAAIiF,gBAAgBpB,IAAWD,GAAaC,GAAStF,EAAKuG,GAEjH,OAAOhD,EAAQoD,aAAa3G,EAAKuG,GAGlCrT,IAAM8L,yDA/CN,GAAIwH,EAAQ,gBAAQpS,GACnBmP,EAAQvD,GAAO5L,GAIhB,GAAY,UAAR4L,EAAiB,gBAAQ5L,GAG5B,KAFAA,MAASA,GAAMiB,QAAQ,OAAQ,KAAK6B,QAE1B,OAAOqM,EAAQqD,gBAAgB5G,GACzCuD,EAAQoD,aAAa3G,EAAK5L,IAI3B,GAAI4L,EAAIxJ,QAAQ,MAAQ,EAAG,OACTwJ,EAAI9K,MAAM,QACrB6Q,EAAYtE,EAAIiF,gBAAgBpB,IAAWD,GAAaC,GAC9D,gBAAQlR,GAEP,GAAY,KAARA,EAAY,OAAOmP,EAAQsD,kBAAkBd,EAAW/F,GAC5DuD,EAAQkD,eAAeV,EAAW/F,EAAK5L,IAIzC,gBAAQA,GAEP,GAAY,KAARA,EAAY,OAAOmP,EAAQqD,gBAAgB5G,GAC/CuD,EAAQoD,aAAa3G,EAAK5L,IAqBX0S,CAAe,SAACvD,MAASvD,SAAKwG,MAAQ/E,IACtD5C,EAAM,CAACuH,GAAQ,CAAChS,IAAKmS,MAAM9E,WAAK3C,cAAU4B,YAAaC,UAAW3B,OAG7D+H,oHACCC,EAAUhK,EAAIC,KAAK/B,GACnB+L,EAAUD,EAAQzJ,MACpBiJ,GAAQQ,EAAQ3I,QAAQ,SAC5BnL,IAAMgU,WXlIcjQ,EAAOV,GAC3B,cAAcU,kBAAO,CAAhB9B,IAAIQ,OACHY,EAAIZ,KAAIY,EAAIZ,GAAK,IACtBY,EAAMA,EAAIZ,GAEX,OAAOY,EW6HU4Q,CAAYH,EAASzD,GACtC,GAAIiC,GAAUxK,GAAQkM,EAASD,GAAWjM,MACrC,CACJ9H,IAGMmT,EAAWD,GAAQ,CAAChS,IAAK4G,MAAOyG,WAAK3C,cAAU4B,YAAaC,mBAHjDvM,GAChB8S,EAASD,GAAW7S,KAGG,IAApB8G,EAAS5G,QAA8B,UAAZ2S,GAClB,YAAZA,GACCjM,EAAM,+GAnHHoM,EAAcZ,EAAU,MAAS,mBACjCa,EAAWb,EAAU,YAAe,kBACfhF,GAAY,CAACF,KAAMgG,MAAM7F,WAAK3C,cAAU4B,YAAaC,4BAC1E4G,aACLtI,IACYuB,EAAWQ,GAAnBwF,EAA2BjD,EAAQiE,MAAMxM,MACrBuI,EAAQvI,MAChCoE,KAEW,UAARY,GAEHuD,EAAQ6D,GAAa,QAASG,GAAS,GACvChE,EAAQ6D,GAAa,QAASG,GAAS,GACvChE,EAAQ6D,GAAa,SAAUG,GAAS,KASxChE,EAAQ6D,GAAa,qBAGpB,GADA7D,EAAQ8D,GAAU3C,GAAS,mBAAoB,CAACC,SAAS,EAAM8C,YAAY,IACnD,UAApBlE,EAAQqC,SAAwC,UAAjBrC,EAAQpJ,MAAqC,KAAjBoJ,EAAQxI,KAAa,CAEnF7H,IAAMwU,EAAShF,GAAIL,SAASsF,+BAA+BpE,wBAC3D,GAAImE,EAAQ,CACXxU,IAAM0U,EAAW5K,EAAIC,KAAKyK,GAC1B1K,EAAIU,OAAOkK,EAAUrE,GAKrB,cAAcqE,uBAAYC,cAAcnD,GAAS,yBAGjD,GAEHnB,EAAQ6D,GAAa,8BACpBnI,IACYuB,EAAWQ,GAAnBwF,EAA2BjD,EAAQiE,MAAMM,QACrBvE,EAAQuE,QAChC1I,QAuEW2I,CAAe,KAACtG,WAAK3C,cAAU4B,YAAaC,UAAW4C,EAASvD,IAAKiH,EAASK,KAAMtM,EAAM,UAAIwL,IAC1G3H,EAAM,CAACwH,MAKH2B,YAAa5T,UAAOA,GAEpB6T,4FACCb,WAAwB,MAAS,2FAiBjCf,EAAWD,GAAQ,CAAChS,IAAKN,MAAG2N,WAAK3C,cAAU4B,YAAaC,EAAW3B,QAASgJ,KAElFzE,EAAQ6D,GAAa/L,YAAIxE,KAClB6B,KAAQ7B,EAAEqR,YACbvP,KAAQ9B,EAAEsR,UACVvP,KAAQ/B,EAAEuR,WACVxU,KAAQiD,EAAEwR,SACX7M,IAA6B,IAAxBA,EAAEhF,QAAQK,EAAEyR,SACf9P,GAAG3B,EAAE0R,kBACL5S,GAAGkB,EAAE2R,2BACL/P,GAAG5B,EAAE4R,iBACLhH,EAAIiH,QAAQ9M,IAAI6F,EAAIiH,QAAQ9M,GAAG,GAAC/E,EAAGmE,MAAOqL,IAAYzE,MAAOH,EAAIG,aAEjE/I,IC3NA8P,GAAS,CACdxL,iBACC8B,IACA,cAAcjC,EAAIC,KAAK2F,4BAASgG,WAChCxJ,IACApC,EAAIG,MAAMyF,OAEXiG,iBACC5J,IACA,cAAcjC,EAAIC,KAAK2F,4BAAS2B,UAChCnF,IACApC,EAAIG,MAAMyF,OAEXrF,eACC,GAAoB,IAAhBqF,KAAKtO,OAAT,CACApB,IAAM4V,EAAQ9L,EAAIO,IAAIqF,MAEtB,OADAkG,EAAMvE,UACCuE,IAERxT,0GACCmI,EAAQA,EAAMtG,IAAIoL,GAAO+B,eACzBpR,IAAM6V,EAAW,GACjB9J,IACA,cAAcxB,mBAATtI,IAAIQ,OAAYqH,EAAI1H,KAAKyT,EAAUpT,EAAEoO,OAAO,CAACiF,OAAQvH,EAAIG,UAAO5B,KAIrE,OAHoB,IAAhB4C,KAAKtO,OAAcoO,GAAIyB,gBAAM8E,UAAWF,IACvCrG,GAAIyB,gBAAMvB,KAAKA,KAAKtO,OAAS,GAAG+O,KAAKC,SAASE,oBAAgBuF,IACnE3J,IACOpC,EAAI1H,cAAKsN,aAASnF,KAE1BC,gBAAOC,GACN,IAA4B,IAAxBiF,KAAKpM,QAAQmH,GAEjB,OADAA,EAAK4G,UACE5G,GAERG,mDACC,GAAoB,IAAhB8E,KAAKtO,OAAc,OAAOsO,KAC9B1P,IAAMgW,EAAUlM,EAAIC,KAAK2F,MACnBmG,EAAW,GACjB9J,IACA,IAAK9J,IAAIQ,EAAIuT,EAAQ5U,OAAS,EAAGqB,GAAK,EAAGA,IACxCuT,EAAQvT,GAAG4O,UACXvH,EAAI1H,KAAKyT,EAAUG,EAAQvT,GAAGoO,OAAO,CAACiF,OAAQvH,EAAIG,UAAO5B,KAK1D,OAHAhD,EAAI1H,cAAKsN,aAAS5F,EAAIc,QAAQoL,KAC9BxG,GAAIyB,gBAAM8E,UAAWF,IACrB3J,IACOwD,MAER9M,iBACC,GAAoB,IAAhB8M,KAAKtO,OAAT,CACApB,IAAMiW,EAAUnM,EAAIlH,MAAM8M,MAE1B,OADAuG,EAAQ5E,UACD4E,IAERjL,gBAAyBC,kCACxB,GAAoB,IAAhByE,KAAKtO,OAAc,OAAOsO,KAC9B1P,IAAMkW,EAASpM,EAAIC,KAAKD,EAAIkB,KAAK0E,KAAMzE,IACjC4K,EAAW,GACjB9J,IACA,cAAcmK,kBAAQ,CAAjBjU,IAAIQ,OACRA,EAAE4O,UACFvH,EAAI1H,KAAKyT,EAAUpT,EAAEoO,OAAO,CAACiF,OAAQvH,EAAIG,UAAO5B,KAKjD,OAHAhD,EAAI1H,cAAKsN,aAASwG,IAClB1G,GAAIyB,gBAAM8E,UAAWF,IACrB3J,IACOwD,MAER/E,yEACC,GAAoB,IAAhB+E,KAAKtO,OAAc,OAAOsO,KAC9B1P,IAAMmW,EAAUrM,EAAIa,gBAAOb,EAAIC,KAAK2F,cAAUxE,IAC9Ca,IACA,cAAcoK,mBAATlU,IAAIQ,OAAcA,EAAE4O,UAEzB,OADAnF,IACOiK,GAERhL,+GACC,GAAoB,IAAhBuE,KAAKtO,OAAc,SAAOsO,MAAKtN,aAAQmI,GAAOnJ,OAClDmJ,EAAQA,EAAMtG,IAAIoL,GAAO+B,eACzBpR,IAAM6V,EAAW,GACjB9J,IACA,cAAcxB,mBAATtI,IAAIQ,OAAYqH,EAAI1H,KAAKyT,EAAUpT,EAAEoO,OAAO,CAACiF,OAAQvH,EAAIG,UAAO5B,KAGrE,OAFA0C,GAAIyB,gBAAM8E,UAAWF,IACrB3J,IACOpC,EAAIqB,iBAAQuE,aAASnF,MCjFxB6L,GAAe,CACpBC,OAAQ,SACRC,MAAO,QACPC,OAAQ,SACRC,QAAS,WCAJC,GAAQtE,GAAa,OACrBuE,GAASvE,GAAa,QACtBwE,GAASxE,GAAa,QAEtByE,GAAgBxN,OAAOyN,OAAO,MAuE9BC,GAAwB,2CA5CvBC,aAAiBjK,uBAEnBC,IAASjF,IAEbA,EAAQuH,GAAO+B,cAActJ,GAE7BiE,IAEIgB,IACCjF,IAAU8O,GAAe9O,EAAQ,KAChCiF,EAAKsE,WAGX0F,EAAMhK,KAAOjF,EACTA,GAAOA,EAAM+I,OAAO,CAACC,OAAQiF,EAAQD,OAAQvH,EAAIG,MAAOvJ,OAAQiR,GAAaC,WAAQvJ,IACzFZ,6DAKgCY,uBAChC,IAAIhD,EAAII,OAAO6C,EAAMjF,GAArB,CACWA,EAAPA,EAAegC,EAAIC,KAAKjC,GACf,GACb9H,IAAMgX,EAAWxH,GAAIL,SAASU,yBAG9B,GADA9D,IACIgB,EAAM,CACTA,EAAK4I,QACL,cAAiB7N,kBAAO,CAAnB7F,IAAIwI,QACRA,EAAO4E,GAAO+B,cAAc3G,IAEnB0F,KAAKC,SAAS0F,QAAQrL,EAAK4G,UACpC7B,GAAIM,OAAOkH,EAAUvM,EAAKoG,OAAO,CAACiF,OAAQvH,EAAIG,UAAO5B,WAEhD,cAAiBhF,mBAAZ7F,IAAIwI,OAAe+E,GAAIM,OAAOkH,EAAUvM,EAAKoG,OAAO,CAACiF,OAAQvH,EAAIG,UAAO5B,KAEpFC,EAAK3L,OAAS,EACd0I,EAAI1H,cAAK2K,UAASjF,IAElB0H,GAAIyB,MAAM8E,EAAQiB,GAClB9K,OAyCK+K,0IACL,GAAIlK,aAAgByC,GAAIJ,KACvBI,GAAIM,OAAOO,EAAStD,QAGrB,OAAQyD,GAEP,IAAK,SACJhB,GAAIM,OAAOO,EAASb,GAAIL,SAAS+H,eAAenK,IAChD,MAGD,IAAK,QAEoB,WAApBxD,EAAOwD,EAAK,IAAkByC,GAAIM,OAAOO,EAASwG,EAAO,MAAC9J,MAAMwB,YAAKd,OAAWwF,WAAMrH,cAAU4B,YAAaqF,6FAnH7GsE,EAAW3H,GAAIL,SAAS+H,eAAe,MACL5I,GAAY,CAACF,KAAMrB,MAAMwB,WAAK3C,cAAU4B,YAAaC,0CACvF3B,aACL9L,IAAM8H,EAAQ8F,EAASE,GAKvBqJ,EAASC,iBAJY,IAAVtP,EAIYA,EAHC,IAKzB4F,EAAYtL,KAAK0J,GACjBH,EAAM,CAACG,IAGP0D,GAAIM,OAAOO,EAAS8G,GAuGbE,CAAa,MAACtK,MAAMwB,WAAK3C,cAAU4B,YAAaC,UAAW4C,IAChE,MAGD,IAAK,SACJrQ,IAAM+V,EAASvG,GAAIL,SAAS+H,eAAe,IAE5B,IAAXnK,EAAKrM,yEAvCXyQ,EAASrE,GAAO,QAACiJ,GACjBzG,GAAmBpC,IAAI6I,EAAQ5E,EAASrE,IACpCwK,GAAY9H,GAAIM,OAAOvB,EAAIgJ,SAAUxB,GAqCrByB,CAAiB,KAACjJ,EAAKzB,IAAKC,EAAKpM,SAAGoV,oBFvDtC/L,EAAK3C,yDEuBvB8J,EAASrE,GAAO,CACfC,MFxBiB/C,EEwBD,GFxBM3C,EEwBF,KAACkH,MAAKzB,SAAKiJ,GFvBhC3M,OAAOqO,iBAAiBzN,EAAK,CAC5BC,MAAO,CAACnC,MAAO2N,GAAOxL,OACtB0L,MAAO,CAAC7N,MAAO2N,GAAOE,OACtBtL,IAAK,CAACvC,MAAO2N,GAAOpL,KACpBjI,KAAM,CAAC0F,MAAO2N,GAAOrT,KAAKgM,KAAKpE,EAAK3C,IACpCmD,OAAQ,CAAC1C,MAAO2N,GAAOjL,QACvBI,QAAS,CAAC9C,MAAO2N,GAAO7K,QAAQwD,KAAKpE,EAAK3C,IAC1CzE,MAAO,CAACkF,MAAO2N,GAAO7S,OACtBoI,KAAM,CAAClD,MAAO2N,GAAOzK,KAAKoD,KAAKpE,EAAK3C,IACpCsD,OAAQ,CAAC7C,MAAO2N,GAAO9K,QACvBQ,QAAS,CAACrD,MAAO2N,GAAOtK,QAAQiD,KAAKpE,EAAK3C,MAEpC2C,UEYN+L,GAEDzG,GAAmBpC,IAAI6I,EAAQ5E,EAASrE,IACpCwK,GAAY9H,GAAIM,OAAOvB,EAAIgJ,SAAUxB,GA6BlC2B,CAAiB,KAACnJ,EAAKzB,IAAKC,EAAKpM,SAAGoV,IAGzCvG,GAAIM,OAAOO,EAAS0F,KAUjBc,0HAECc,EAAoB9E,EAEtBH,EAAUrL,EAAK3G,EACfkX,GAAgB,EAEdZ,EAAuB,IAAZtE,EACXY,EAASlK,OAAOyO,cAAcvO,KAAK+F,GAAOuB,gBAAiBrC,EAAIuJ,MAAMpF,IAAYA,GAGvF,IAAKsE,IAAa1D,EAAQ,CACzB,GAAI/E,EAAIuJ,MAAMpF,GAAU,CACvB1S,IAAM+X,EAASxJ,EAAIuJ,MAAMpF,GACH,iBAAXqF,EAAqBrF,EAAUqF,EACjCA,EAAOvQ,MACfkL,EAAUqF,EAAOvQ,IACbuQ,EAAOC,eAAcnF,EAAYkF,EAAOC,eAG9C,GAAItF,EAAQpP,QAAQ,MAAQ,EAAG,OACMoP,EAAQ1Q,MAAM,mBAC9CuM,EAAIiF,gBAAgBpB,IACvBS,EAAYtE,EAAIiF,gBAAgBpB,GAChCwF,GAAgB,GAEhB/E,EAAYV,GAAaC,GAE1BM,EAAUuF,OACJ,GAAI5Q,EAAK5B,GAAK4B,EAAK5B,EAAEyS,OAAS5F,GAAUjL,EAAK5B,EAAEyS,OACrDrF,EAAYxL,EAAK5B,EAAEyS,WACb,IAAKrF,EAEX,OADAH,EAAUA,EAAQyF,eAEjB,IAAK,MACJtF,EAAY4D,GACZ,MAED,IAAK,OACJ5D,EAAY6D,IAQZ7D,IAAc8D,KAAQ9D,EAAY,IAGtC7S,IAAMqQ,6HHeN,GAAI2G,EAAU,OAAO,IAAIvH,GASlB,kCACDiD,EAAUhS,EACV8R,EAAajE,EAAIuJ,MAAMpX,IAAMA,EAC7B2P,EAAUkC,GAAW,SAACG,aAASF,EAAYG,MAAOlN,EAAG8B,IAAKzG,OAAGmS,YAAMJ,IACzE,GAAIpN,EAAG,IAAKxD,IAAI6K,KAAOrH,EAAG2N,GAAQ,SAAC/C,SAASiD,EAAQD,KAAM5N,EAAEqH,OAAMA,MAAKyB,WAAK3C,cAAU4B,YAAaC,IACnG,GAAIlI,EAAG,cAA8BA,mBAAzBtD,yBAA4B4R,GAAQ,SAACxD,SAASiD,QAAQxL,WAAOE,MAAUuG,WAAK3C,cAAU4B,YAAaC,IAC/G,GAAI9J,EAAG,cAAkBA,mBAAb1B,IAAI0P,OAAYoD,GAAS,SAAC1E,SAASiD,QAAQ3B,MAAOpD,WAAK3C,cAAU4B,YAAaC,IAE1F,OAAO4C,EGhCS0C,CAAc,MAAC1L,MAAMkH,YAAKd,OAAWwF,WAAMrH,cAAU4B,YAAaqF,WAAWmE,SAAU1D,IAInGT,GAAaA,IAAc4D,IAAS,CAAC,gBAAiB,OAAQ,SAASnT,QAAQoP,EAAQyF,gBAAkB,IAAGtF,EAAY,IAGxH+E,IAAe/E,EAAY8E,GAG/B,cAAiBS,kBAAY,CAAxBnW,IAAI8K,OACJA,aAAgBsC,GAAOuB,gBAAiB7D,EAAK8D,OAAO,CAACC,OAAQT,IAC5D4G,GAAW,MAAClK,EAAMyD,SAAUjH,EAAOwD,WAAOsD,MAAS9B,YAAKd,OAAWwF,WAAMrH,cAAU4B,YAAaqF,SAAWgE,KAIjH,OAAOxG,GCrOFgI,oEACL,GAAIpL,EAAK,CACR,IAAKC,EAAK,MAAM,IAAImF,MAAM,kDAC1B,OAAOpF,EAGR,OAAIqL,EAAkB,WACrB,OAAOA,EAAUC,EAAK7I,MAAM5C,GAAM4C,OAG5B,WACN,OAAO6I,EAAK7I,MAAM5C,KAId0L,6FACL,GAAItL,EAAK,CACR,IAAKD,EAAK,MAAM,IAAIoF,MAAM,kDAC1B,OAAOnF,EAGR,OAAIoL,EAAkB,SAASpX,GAC9BlB,IAAMyY,EAAWF,EAAK7I,MAChBgJ,EAAWC,EACXC,EAAYC,EAEK,mBAAZF,IAAwBA,oBAAgBD,IAC3B,mBAAbG,IAAyBA,oBAAiBD,IAE5CH,EAAS3L,GAAd5L,EAAqByX,EAAQjJ,MACZmJ,EAASnJ,OAGxB,SAASxO,GACfqX,EAAK7I,MAAM5C,GAAO5L,IAId4X,YAAcpK,UAASA,EAAM4F,OAC7ByE,YAAWC,GAChB,OAAKA,EACe,mBAATA,EAA4BA,GACnB,iBAATA,IAAmBA,EAAOA,EAAKhX,MAAM,eACxCuW,GACP,cAAgBS,mBAAMT,EAAOA,QAC7B,OAAOA,IALUO,IAgCbG,YAAYC,EAAKC,GACtB,IAAKlX,IAAIoR,KAAQ8F,EAAS,CACzBnZ,IAAMiF,EAAUkU,EAAQ9F,GAKlB+F,EAAgB,MAHTL,GAAQ9T,EAAQsT,UACjBtT,EAAQ6H,KAAOuG,GAIrBpG,EAAMoL,GAAUe,EAAenU,GAC/BiI,EAAMsL,GAAUY,EAAenU,GAErCmE,OAAO4D,eAAekM,EAAIrP,UAAWwJ,EAAM,KAC1CpG,MACAC,EACAE,YAAY,EACZD,cAAc,IAIhB,OAAO+L,GC1BFtI,cAOL,WAAYzJ,EAAK2Q,kBAAQ,IACxB9X,IACMiT,EAAO,GAEPxF,EAAY,GAEZ7B,EAAW,GACX4B,EAAc,GACd4C,EAAW,CAChBE,YAAa,KACbnO,QAAS,GACT2T,OAAQ,KACRhJ,IAAK,MAOAyK,EAAW/H,GAAIL,SAASU,yBAEaO,EAASE,YAAcd,GAAIL,SAAS+H,eAAe,IAG9FlX,IAAMqZ,aACL,GAAIjJ,EAASjO,QAAQf,OAAS,EAAG,CAChC,cAAcgP,EAASjO,yBAAlBF,IAAIQ,OAAuB+M,GAAIhF,OAAO/H,GAC3CqH,EAAIG,MAAMmG,EAASjO,SAEpBqN,GAAIkB,OAAON,EAASE,YAAaF,EAASC,UAGrC9B,EAAM,OACXuJ,QAAOuB,OAAOpG,OA9BF,aA8BcxF,UA5BX,YA6Bf7B,cAAU4B,WAAa4C,WAAUmH,WAjCjB,GAkCN7I,MAAOgB,KAAM4H,WAAyB,IAAbnQ,EAAI,GAAGzG,EAC1C8S,gBAAiB9D,KAAKb,YAAYyK,oBAGnClQ,OAAO4D,eAAe0C,KAAM,OAAQ,CACnC5H,MAAOyG,EACPnB,YAAY,EACZD,cAAc,IAGfpB,IAEAqE,EAASC,QAAUwG,GAAO,CAAC9J,KAAM5F,MAAKoH,YAAKd,OAAWwF,WAAMrH,cAAU4B,EAAaqF,UAAW,KAC9FrD,GAAIM,OAAOyH,EAAUnH,EAASE,aAC9BzE,EAASwN,GACTnN,8FAGDqN,EAAIjF,qBAEH,OAAO5E,KAAKS,KAAKzG,MAGlB6P,EAAIjF,mBAAMkF,GAETzN,IACAa,EAAO8C,KAAKS,KAAKzG,KAAM8P,GACvBtN,KAGDqN,EAAIE,wBAEH,OAAO/J,KAAKS,KAAKqF,SAIlB+D,EAAIE,sBAASC,GAEZhK,KAAKS,KAAKqF,QAAUkE,GAGrBH,EAAII,qBAEH,OAAOjK,KAAKS,KAAK8C,kBAYlBpC,kEAE6BnB,KAAKS,4BAejC,GAdsB,iBAAXW,IAAqBA,EAAS3B,SAASyK,cAAc9I,IAEhE/E,IACIqE,EAAS0F,QACZpG,KAAK2B,UAIDyE,IAAQA,EAAShF,GACjBhE,IAAKA,EAAM,mBAChBsD,EAAS0F,OAASA,EAClB1F,EAAStD,IAAMA,EACfjB,EAASwN,IAEJvI,EAEJ,OADA5E,IACOkE,EAASE,YAGjB,OAAQnL,GACP,KAAKiR,GAAaC,OACjB7G,GAAIkB,OAAOI,EAAQV,EAASE,aAC5B,MAED,KAAK8F,GAAaE,MACjB9G,GAAIyB,MAAMH,EAAQV,EAASE,aAC3B,MAED,KAAK8F,GAAaI,QACjBhH,GAAIkB,OAAOI,EAAQV,EAASE,aAC5BF,EAASjO,QAAQC,KAAK0O,GACtB,MAED,KAAKsF,GAAaG,OAClB,QAEK3H,GAAWkH,EAAQrG,IAAaD,GAAIM,OAAOgB,EAAQV,EAASC,SAC3Db,GAAIM,OAAOgB,EAAQV,EAASE,aAGnC,OAAOpE,iBAMRmF,yBAEuC3B,KAAKS,4DAmB3C,OAjBAC,EAAS0F,OAAS,KAClB1F,EAAStD,IAAM,KAEff,IACI+J,IACS,oBAARhJ,EACCgJ,EAAOhJ,KACN5D,MAAMC,QAAQ2M,EAAOhJ,IAExBhD,EAAIU,OAAOsL,EAAOhJ,GAAM4C,MAClBoG,EAAOhJ,GAAO8J,IAGZhI,GAAWkH,EAAQrG,KAAaqG,EAAO3F,KAAKC,SAASC,QAAQL,YAAYI,EAASC,UAE9Fb,GAAIM,OAAOyH,EAAUnH,EAASE,aAC9BzE,EAASwN,GACFnN,iBASR2N,oBAAWC,EAASrL,GAEnBzO,IAAMuO,EAAMmB,KAAKS,gDAEXpM,EAAQ+V,EAAQ9X,MAAM,OACesM,GAAY,CAACF,KAAM,CAACrK,OAAQwK,WAAK3C,cAAU4B,YAAaC,6CACnG1B,IAEA,IACC0C,EAAW,CAACC,MAAOgB,KAAM5H,MAAO8F,EAASE,KAEzCH,EAAevL,KAAKqM,GACnB,MAAO9K,GACRuK,GAAIG,MAAM,8CAA+C1K,GAE1DuI,iBASD6N,sBAAaD,EAASrL,aAzPFqL,EAAS7O,EAAIuC,GACjCxN,IAAM2N,WhB8CoB5J,EAAOyJ,GAGjC,IAFAxN,IAAM8D,EAAUC,EAAM/B,MAAM,KACtB8K,EAAMhJ,EAAQuG,YACNvG,kBAAS,CAAlB7B,IAAIQ,OACH+K,EAAY/K,KAAI+K,EAAY/K,GAAK,IACtC+K,EAAcA,EAAY/K,GAE3B,OAAO+K,EAAYV,GgBrDIkN,CAAkBF,EAAStM,GAClD1D,EAAIU,OAAOmD,EAAgB1C,GA0P1BgP,CAAYH,EAASrL,EADGiB,KAAKS,+BAS9B+J,iBAAQC,GAEPpO,IACAU,EAAaiD,KAAMyK,GACnBjO,iBAQDkO,mBAAUzI,GAET,OAAOjC,KAAKS,KAAKC,SAASE,YAAYqE,cAAchD,gBAarD0I,eAAMC,EAAWrV,GAEhB,OAAOyK,KAAK0K,UAAU5I,GAAS8I,EAAWrV,iBAQ3CsV,wEAEC,SAAO7K,KAAKS,KAAKC,SAASE,aAAYkK,yBAAoBtP,gBAQ3DuP,yEAEC,SAAO/K,KAAKS,KAAKC,SAASE,aAAYoK,4BAAuBxP,gBAO9DwK,0BAEgChG,KAAKS,+BAGpC,IAAKlO,IAAIQ,KAFTsJ,IACA2D,KAAK2B,UACSF,EAAU7B,GAAmBqL,OAAOxJ,EAAS1O,GAAGsT,QAE9D,IAAK9T,IAAIQ,KAAKiN,KACW,UAApBnG,EAAOmG,KAAKjN,IAAiBiN,KAAKjN,GAAGkT,QACpCjG,KAAKjN,GAAK,KAUhB,cAPOiN,KAAKS,KAEZtE,cACC2D,GAAIhF,OAAO4F,EAASC,SACpBb,GAAIhF,OAAO4F,EAASE,gBAGdpE,iDAQH0O,GAAc,CAAC,CAACla,EAAG,IAUnBma,eAML,oEACCC,YAAMF,IAEN5a,IAAMqQ,EAAUX,KAAKS,KAAKC,SAASC,QACfA,EAAQV,UAC5BU,EAAQP,eAAUa,GAIlBjB,KAAKS,KAAK0F,SAAWlF,8HAGtBoK,EAAIC,mBACH,OAAOtL,KAAKS,KAAK0F,wDAUboF,eACL,oEACCH,YAAM,CAAC,CAACpa,EAAG,WAAOyQ,yGAId+J,GAAkB,CAAC,CAACxa,EAAG,GAAG,CAAC,CAAC,UAS5Bya,eAML,WAAYC,GACXrP,IACA+O,YAAMI,IACNxL,KAAK0L,KAAOA,EACZlP,yGAGF+M,GAASkC,GAAgB,CAACC,KAAM,KAEhCtM,GAAgB8B,GAAiB,CAAC,SAAU,UAAW,aAAc,eAAgB,UAAW,YAAa,QAAS,MAAO,OAAQ,aACrI9B,GAAgB+L,GAAe,CAAC,QAQhC7a,IAAMoR,YAAiBtJ,GACtB,OAAIA,MAAAA,GAAkDA,aAAiB8I,GAAwB9I,EAE3FA,IAAU8O,GACT9O,aAAiBsH,KAAa,IAAIyL,GAAc/S,GACT,IAAIqT,GAArB,iBAAVrT,EAA8CA,EAC/BrE,KAAK4X,UAAUvT,SAH/C,GAODuH,GAAOuB,gBAAkBA,GACzBvB,GAAO+B,cAAgBA,GC9bvBpR,IAAMsb,YAAWC,EAAM9Q,GAItB,OAHIvB,MAAMC,QAAQsB,GAAO8Q,EAAKnZ,aAAQqI,EAAKxG,IAAImN,KAC1CmK,EAAKnZ,KAAKgP,GAAc3G,IAEtB8Q,GCiBFC,YAAiBzO,EAAM0O,GAC5Bzb,IJmE2BiH,EAAM6F,EAAKoM,EInEhC1I,EAAWjH,EAAOwD,GACxB,OAAQyD,GACP,IAAK,QACG,wBACP,GAAqB,WAAjBjH,EAAOlC,GAAoB,CAC1BA,EAAK5B,YAhBOkN,EAAO8I,GAC1B,IAAKxZ,IAAIQ,KAAKkQ,EACb,GAA4B,IAAxBlQ,EAAEa,QAAQ,UAAiB,OACXb,EAAET,MAAM,QAC3ByZ,EAAUnC,mBAAmBlH,GAAUO,EAAMlQ,IAYhCiZ,CAAWrU,EAAK5B,EAAGgW,GAC/B,cAAcrD,mBAATnW,IAAIQ,OAAiB+Y,GAAc/Y,EAAGgZ,IAE5C,MAED,IAAK,SACJ,GAAI1O,EAAKrM,EAAI,EAAG,MAAM,IAAIqI,yEAAyEgE,SJwD1E9F,EIvDN8F,EAAKrM,EJuDOoM,EIvDJC,EAAKpM,EJuDIuY,EIvDDuC,EJwDrCrS,OAAO4D,eAAekM,EAAIrP,UAAWiD,EAAK,CACzCG,eAEC,OAAOyC,KAAKS,KAAKgB,SAASrE,GAAKC,MAEhCG,aAAIpF,GAEH9H,IAAMuO,EAAMmB,KAAKS,KACjB2G,GAAsB7P,GAAM,KAACsH,MAAKzB,QAAKhF,KAExCsF,YAAY,IIjEX,MAED,IAAK,SACJ,MAED,QACC,MAAM,IAAIrE,+DAA+DyH,SClBxEmL,GAAS9S,EAuBPgO,YAAU/O,GACf9H,IDoBemH,EAQTyU,EC5BAC,EAAUtS,EAAOzB,GACvB,GAAgB,WAAZ+T,EAAsB/T,WCjDZgB,EAAU6S,GAExB,OADKA,IAAQA,EAASG,GACfH,EAAO7S,GD+CoBpF,CAAMoE,EAAO6T,SAC1C,GAAgB,UAAZE,EAAqB,MAAM,IAAI9S,UAAU,+DAElD,ODgBe5B,EChBQW,EDwBjB8T,cAOL,WAAYG,EAAWjE,GACtB/L,IACA+O,YAAM3T,EAAK2Q,GACPiE,GAAWrM,KAAKwK,QAAQ6B,GAC5B7P,yGAMF9C,OAAO4D,eAAe4O,EAAY/R,UAAW,cAAe,CAACuD,YAAY,IAEzEhE,OAAO4D,eAAe4O,EAAa,qBAAsB,CAACxO,YAAY,EAAOtF,MAAO,KACpF0T,GAAcrU,EAAKyU,GACZA,0EpB3BQI,GACfjQ,IACA,IAECG,EAAK8P,EAAGjQ,EAAQG,IACf,MAAOvI,GAER,OADAuI,IACOvI,yCmBvDc6D,EAAKmL,iEAE3B,GAAInL,IAAQyT,GAAU,OAAO,kCAAIA,iBAAY9J,KAG7C,GAAI/H,OAAOyO,cAAcvO,KAAKsH,GAAiBpJ,GAC9C,OAAI2J,EAAS/P,QAAU,EAAU,IAAIoG,EAAImL,GAClC,IAAInL,EAAIoF,EAAO,CAACuE,SAAUA,EAAS8K,OAAOX,GAAS,KAAM3I,GAAS,KAK1E3S,IAAMkc,EAAmBtP,EAAO,GAAI+F,GACpC,IAAK1Q,IAAIQ,KAAKyZ,GACe,IAAxBA,EAAiBzZ,KAAayZ,EAAiBzZ,GAAK,IAGzD,OAAO,IAAImO,GAAgB,CAC1B,CACClQ,EAAG8G,EACH/B,EAAGyW,WAED/K,iCPtBqBiB,EAAQ4F,GACjC,GAAIlG,GAAWM,GACd,MAAM,IAAIC,yBAAyBD,qCAAyCN,GAAWM,SAGxFN,GAAWM,GAAU4F,oDZfCtM,EAAQ,2DALVI,UAAWL,EAAUrJ,KAAK0J,mCuBK/B2P,EAAWU,sBAC1B,WAAYzN,EAAOoJ,kBAAQ,IAC1B9X,IAAMoc,EAASxP,EAAO,GAAIuP,GAC1BrB,YAAMpM,EAAO9B,EAAOwP,EAAQtE,8IF6CXuE,GAClBV,GAASU,gFAQaxF,GAAOrN,eAAU0B"}