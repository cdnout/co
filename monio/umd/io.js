/*! Monio: io.js
    v0.15.0 (c) 2021 Kyle Simpson
    MIT License: http://getify.mit-license.org
*/
!function UMD(t,n,e,r){"function"==typeof define&&define.amd?(e=Object.values(e),define(t,e,r)):"undefined"!=typeof module&&module.exports?(e=Object.keys(e).map((t=>require(t))),module.exports=r(...e)):(e=Object.values(e).map((t=>n[t])),n[t]=r(...e))}("IO","undefined"!=typeof globalThis?globalThis:"undefined"!=typeof global?global:"undefined"!=typeof window?window:"undefined"!=typeof self?self:new Function("return this")(),{"./lib/util.js":"MonioUtil","./either.js":"Either"},(function DEF(t,n){"use strict";var{isFunction:e,isPromise:r,getMonadFlatMap:i}=t,o={};let a={};function IO(t){var n={map:function map(n){return IO((e=>{var i=t(e);return r(i)?i.then(n):n(i)}))},chain:chain,flatMap:chain,bind:chain,ap:function ap(n){return n.map(t)},concat:function concat(n){return IO((e=>{var i=t(e),o=n.run(e);return r(i)||r(o)?Promise.all([i,o]).then((([t,n])=>t.concat(n))):i.concat(o)}))},run:function run(n){return t(n)},_inspect:function _inspect(){return`${n[Symbol.toStringTag]}(${e(t)?t.name||"anonymous function":t&&e(t._inspect)?t._inspect():val})`},_is:function _is(t){return t===o},[Symbol.toStringTag]:"IO"};return n;function chain(n){return IO((e=>{var i=t(e);return r(i)?i.then(n).then((t=>t.run(e))):n(i).run(e)}))}}function processNext(t,e,o,a=!1){return new Promise((async function c(u,f){try{let s=function monadFlatMap(t,n){return i(t).call(t,n)}(r(e)?await e:e,(n=>IO((()=>t(n).then(u,f)))));IO.is(s)?await s.run(o):a&&n.Left.is(s)?f(s):u(s)}catch(t){f(t)}}))}function getIterator(t,n){return e(t)?t(n):t&&"object"==typeof t&&e(t.next)?t:void 0}return a=Object.assign(IO,{of:function of(t){return IO((()=>t))},is:function is(t){return t&&e(t._is)&&t._is(o)},do:function $do(t){return IO((n=>{var e=getIterator(t,n);return async function next(t){var i=e.next(r(t)?await t:t);return(i=r(i)?await i:i).done?i.value:processNext(next,i.value,n,!1)}()}))},doEither:function doEither(t){return IO((e=>{var i=getIterator(t,e);return async function next(t){try{t=r(t)?await t:t;let o=n.Left.is(t)?t.fold((t=>i.throw(t)),(()=>{})):i.next(t);o=r(o)?await o:o;let a=o.done&&r(o.value)?await o.value:o.value;if(o.done){if(n.Left.is(a))throw a;return n.Right.is(a)?a:n.Right(a)}return processNext(next,a,e,!0).catch(next)}catch(t){throw n.Left.is(t)?t:n.Left(t)}}()}))}}),a.RIO=IO,a.Reader=IO,a}));