import{assign}from"../obj.js";import{abstract}from"../util.js";import{get as getProjection,equivalent as equivalentProjection,transformExtent}from"../proj.js";import Units from"../proj/Units.js";class FeatureFormat{constructor(){this.dataProjection=null,this.defaultFeatureProjection=null}getReadOptions(e,r){let o;if(r){let t=r.dataProjection?getProjection(r.dataProjection):this.readProjection(e);r.extent&&t&&t.getUnits()===Units.TILE_PIXELS&&(t=getProjection(t)).setWorldExtent(r.extent),o={dataProjection:t,featureProjection:r.featureProjection}}return this.adaptOptions(o)}adaptOptions(t){return assign({dataProjection:this.dataProjection,featureProjection:this.defaultFeatureProjection},t)}getType(){return abstract()}readFeature(t,e){return abstract()}readFeatures(t,e){return abstract()}readGeometry(t,e){return abstract()}readProjection(t){return abstract()}writeFeature(t,e){return abstract()}writeFeatures(t,e){return abstract()}writeGeometry(t,e){return abstract()}}export default FeatureFormat;function transformGeometryWithOptions(t,e,r){var o=r?getProjection(r.featureProjection):null,n=r?getProjection(r.dataProjection):null;let a;if(a=o&&n&&!equivalentProjection(o,n)?(e?t.clone():t).transform(e?o:n,e?n:o):t,e&&r&&void 0!==r.decimals){const i=Math.pow(10,r.decimals);(a=a===t?t.clone():a).applyTransform(function(r){for(let t=0,e=r.length;t<e;++t)r[t]=Math.round(r[t]*i)/i;return r})}return a}function transformExtentWithOptions(t,e){var r=e?getProjection(e.featureProjection):null,e=e?getProjection(e.dataProjection):null;return r&&e&&!equivalentProjection(r,e)?transformExtent(t,e,r):t}export{transformGeometryWithOptions,transformExtentWithOptions};