import{getChangeEventType}from"../Object.js";import{createCanvasContext2D}from"../dom.js";import VectorLayer from"./Vector.js";import{assign}from"../obj.js";import WebGLPointsLayerRenderer from"../renderer/webgl/PointsLayer.js";const Property={BLUR:"blur",GRADIENT:"gradient",RADIUS:"radius"},DEFAULT_GRADIENT=["#00f","#0ff","#0f0","#ff0","#f00"];class Heatmap extends VectorLayer{constructor(e){e=e||{};const t=assign({},e),r=(delete t.gradient,delete t.radius,delete t.blur,delete t.weight,super(t),this.gradient_=null,this.addEventListener(getChangeEventType(Property.GRADIENT),this.handleGradientChanged_),this.setGradient(e.gradient||DEFAULT_GRADIENT),this.setBlur(void 0!==e.blur?e.blur:15),this.setRadius(void 0!==e.radius?e.radius:8),e.weight||"weight");"string"==typeof r?this.weightFunction_=function(e){return e.get(r)}:this.weightFunction_=r,this.setRenderOrder(null)}getBlur(){return this.get(Property.BLUR)}getGradient(){return this.get(Property.GRADIENT)}getRadius(){return this.get(Property.RADIUS)}handleGradientChanged_(){this.gradient_=createGradient(this.getGradient())}setBlur(e){this.set(Property.BLUR,e)}setGradient(e){this.set(Property.GRADIENT,e)}setRadius(e){this.set(Property.RADIUS,e)}createRenderer(){return new WebGLPointsLayerRenderer(this,{vertexShader:`
        precision mediump float;
        attribute vec2 a_position;
        attribute vec2 a_texCoord;
        attribute vec2 a_offsets;
        attribute float a_opacity;

        uniform mat4 u_projectionMatrix;
        uniform mat4 u_offsetScaleMatrix;
        uniform float u_size;

        varying vec2 v_texCoord;
        varying float v_opacity;

        void main(void) {
          vec4 offsets = u_offsetScaleMatrix * vec4(a_offsets, 0.0, 0.0);
          gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets * u_size;
          v_texCoord = a_texCoord;
          v_opacity = a_opacity;
        }`,fragmentShader:`
        precision mediump float;
        uniform float u_blurSlope;

        varying vec2 v_texCoord;
        varying float v_opacity;

        void main(void) {
          vec2 texCoord = v_texCoord * 2.0 - vec2(1.0, 1.0);
          float sqRadius = texCoord.x * texCoord.x + texCoord.y * texCoord.y;
          float value = (1.0 - sqrt(sqRadius)) * u_blurSlope;
          float alpha = smoothstep(0.0, 1.0, value) * v_opacity;
          gl_FragColor = vec4(alpha, alpha, alpha, alpha);
        }`,uniforms:{u_size:function(){return 2*(this.get(Property.RADIUS)+this.get(Property.BLUR))}.bind(this),u_blurSlope:function(){return this.get(Property.RADIUS)/Math.max(1,this.get(Property.BLUR))}.bind(this)},postProcesses:[{fragmentShader:`
            precision mediump float;

            uniform sampler2D u_image;
            uniform sampler2D u_gradientTexture;

            varying vec2 v_texCoord;

            void main() {
              vec4 color = texture2D(u_image, v_texCoord);
              gl_FragColor.a = color.a;
              gl_FragColor.rgb = texture2D(u_gradientTexture, vec2(0.5, color.a)).rgb;
              gl_FragColor.rgb *= gl_FragColor.a;
            }`,uniforms:{u_gradientTexture:this.gradient_}}],opacityCallback:this.weightFunction_})}}function createGradient(r){const e=createCanvasContext2D(1,256),o=e.createLinearGradient(0,0,1,256);var i=1/(r.length-1);for(let e=0,t=r.length;e<t;++e)o.addColorStop(e*i,r[e]);return e.fillStyle=o,e.fillRect(0,0,1,256),e.canvas}export default Heatmap;