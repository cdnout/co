import{extend}from"../array.js";import{closestSquaredDistanceXY}from"../extent.js";import GeometryLayout from"./GeometryLayout.js";import GeometryType from"./GeometryType.js";import MultiPoint from"./MultiPoint.js";import Polygon from"./Polygon.js";import SimpleGeometry from"./SimpleGeometry.js";import{linearRingss as linearRingssArea}from"./flat/area.js";import{linearRingss as linearRingssCenter}from"./flat/center.js";import{assignClosestMultiArrayPoint,multiArrayMaxSquaredDelta}from"./flat/closest.js";import{linearRingssContainsXY}from"./flat/contains.js";import{deflateMultiCoordinatesArray}from"./flat/deflate.js";import{inflateMultiCoordinatesArray}from"./flat/inflate.js";import{getInteriorPointsOfMultiArray}from"./flat/interiorpoint.js";import{intersectsLinearRingMultiArray}from"./flat/intersectsextent.js";import{linearRingssAreOriented,orientLinearRingsArray}from"./flat/orient.js";import{quantizeMultiArray}from"./flat/simplify.js";class MultiPolygon extends SimpleGeometry{constructor(t,e,s){if(super(),this.endss_=[],this.flatInteriorPointsRevision_=-1,this.flatInteriorPoints_=null,this.maxDelta_=-1,this.maxDeltaRevision_=-1,this.orientedRevision_=-1,this.orientedFlatCoordinates_=null,!s&&!Array.isArray(t[0])){let i=this.getLayout();var r=t,n=[];const a=[];for(let t=0,e=r.length;t<e;++t){const l=r[t];0===t&&(i=l.getLayout());var o=n.length;const h=l.getEnds();for(let t=0,e=h.length;t<e;++t)h[t]+=o;extend(n,l.getFlatCoordinates()),a.push(h)}e=i,t=n,s=a}void 0!==e&&s?(this.setFlatCoordinates(e,t),this.endss_=s):this.setCoordinates(t,e)}appendPolygon(i){let s;if(this.flatCoordinates){var r=this.flatCoordinates.length;extend(this.flatCoordinates,i.getFlatCoordinates());for(let t=0,e=(s=i.getEnds().slice()).length;t<e;++t)s[t]+=r}else this.flatCoordinates=i.getFlatCoordinates().slice(),s=i.getEnds().slice(),this.endss_.push();this.endss_.push(s),this.changed()}clone(){var e=this.endss_.length;const i=new Array(e);for(let t=0;t<e;++t)i[t]=this.endss_[t].slice();return new MultiPolygon(this.flatCoordinates.slice(),this.layout,i)}closestPointXY(t,e,i,s){return s<closestSquaredDistanceXY(this.getExtent(),t,e)?s:(this.maxDeltaRevision_!=this.getRevision()&&(this.maxDelta_=Math.sqrt(multiArrayMaxSquaredDelta(this.flatCoordinates,0,this.endss_,this.stride,0)),this.maxDeltaRevision_=this.getRevision()),assignClosestMultiArrayPoint(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,this.maxDelta_,!0,t,e,i,s))}containsXY(t,e){return linearRingssContainsXY(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,t,e)}getArea(){return linearRingssArea(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride)}getCoordinates(t){let e;return void 0!==t?(e=this.getOrientedFlatCoordinates().slice(),orientLinearRingsArray(e,0,this.endss_,this.stride,t)):e=this.flatCoordinates,inflateMultiCoordinatesArray(e,0,this.endss_,this.stride)}getEndss(){return this.endss_}getFlatInteriorPoints(){var t;return this.flatInteriorPointsRevision_!=this.getRevision()&&(t=linearRingssCenter(this.flatCoordinates,0,this.endss_,this.stride),this.flatInteriorPoints_=getInteriorPointsOfMultiArray(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,t),this.flatInteriorPointsRevision_=this.getRevision()),this.flatInteriorPoints_}getInteriorPoints(){return new MultiPoint(this.getFlatInteriorPoints().slice(),GeometryLayout.XYM)}getOrientedFlatCoordinates(){if(this.orientedRevision_!=this.getRevision()){const t=this.flatCoordinates;linearRingssAreOriented(t,0,this.endss_,this.stride)?this.orientedFlatCoordinates_=t:(this.orientedFlatCoordinates_=t.slice(),this.orientedFlatCoordinates_.length=orientLinearRingsArray(this.orientedFlatCoordinates_,0,this.endss_,this.stride)),this.orientedRevision_=this.getRevision()}return this.orientedFlatCoordinates_}getSimplifiedGeometryInternal(t){const e=[];var i=[];return e.length=quantizeMultiArray(this.flatCoordinates,0,this.endss_,this.stride,Math.sqrt(t),e,0,i),new MultiPolygon(e,GeometryLayout.XY,i)}getPolygon(t){if(t<0||this.endss_.length<=t)return null;let i;i=0===t?0:(e=this.endss_[t-1])[e.length-1];const s=this.endss_[t].slice();var e=s[s.length-1];if(0!==i)for(let t=0,e=s.length;t<e;++t)s[t]-=i;return new Polygon(this.flatCoordinates.slice(i,e),this.layout,s)}getPolygons(){var i=this.layout;const s=this.flatCoordinates,r=this.endss_,n=[];let o=0;for(let t=0,e=r.length;t<e;++t){const h=r[t].slice();var a=h[h.length-1];if(0!==o)for(let t=0,e=h.length;t<e;++t)h[t]-=o;var l=new Polygon(s.slice(o,a),i,h);n.push(l),o=a}return n}getType(){return GeometryType.MULTI_POLYGON}intersectsExtent(t){return intersectsLinearRingMultiArray(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,t)}setCoordinates(t,e){this.setLayout(e,t,3),this.flatCoordinates||(this.flatCoordinates=[]);e=deflateMultiCoordinatesArray(this.flatCoordinates,0,t,this.stride,this.endss_);0===e.length?this.flatCoordinates.length=0:(t=e[e.length-1],this.flatCoordinates.length=0===t.length?0:t[t.length-1]),this.changed()}}export default MultiPolygon;