import{extend}from"../array.js";import{closestSquaredDistanceXY}from"../extent.js";import GeometryLayout from"./GeometryLayout.js";import GeometryType from"./GeometryType.js";import LineString from"./LineString.js";import SimpleGeometry from"./SimpleGeometry.js";import{assignClosestArrayPoint,arrayMaxSquaredDelta}from"./flat/closest.js";import{deflateCoordinatesArray}from"./flat/deflate.js";import{inflateCoordinatesArray}from"./flat/inflate.js";import{interpolatePoint,lineStringsCoordinateAtM}from"./flat/interpolate.js";import{intersectsLineStringArray}from"./flat/intersectsextent.js";import{douglasPeuckerArray}from"./flat/simplify.js";class MultiLineString extends SimpleGeometry{constructor(t,e,i){if(super(),this.ends_=[],this.maxDelta_=-1,this.maxDeltaRevision_=-1,Array.isArray(t[0]))this.setCoordinates(t,e);else if(void 0!==e&&i)this.setFlatCoordinates(e,t),this.ends_=i;else{let i=this.getLayout();var s=t,r=[];const n=[];for(let t=0,e=s.length;t<e;++t){const o=s[t];0===t&&(i=o.getLayout()),extend(r,o.getFlatCoordinates()),n.push(r.length)}this.setFlatCoordinates(i,r),this.ends_=n}}appendLineString(t){this.flatCoordinates?extend(this.flatCoordinates,t.getFlatCoordinates().slice()):this.flatCoordinates=t.getFlatCoordinates().slice(),this.ends_.push(this.flatCoordinates.length),this.changed()}clone(){return new MultiLineString(this.flatCoordinates.slice(),this.layout,this.ends_.slice())}closestPointXY(t,e,i,s){return s<closestSquaredDistanceXY(this.getExtent(),t,e)?s:(this.maxDeltaRevision_!=this.getRevision()&&(this.maxDelta_=Math.sqrt(arrayMaxSquaredDelta(this.flatCoordinates,0,this.ends_,this.stride,0)),this.maxDeltaRevision_=this.getRevision()),assignClosestArrayPoint(this.flatCoordinates,0,this.ends_,this.stride,this.maxDelta_,!1,t,e,i,s))}getCoordinateAtM(t,e,i){return this.layout!=GeometryLayout.XYM&&this.layout!=GeometryLayout.XYZM||0===this.flatCoordinates.length?null:lineStringsCoordinateAtM(this.flatCoordinates,0,this.ends_,this.stride,t,void 0!==e&&e,void 0!==i&&i)}getCoordinates(){return inflateCoordinatesArray(this.flatCoordinates,0,this.ends_,this.stride)}getEnds(){return this.ends_}getLineString(t){return t<0||this.ends_.length<=t?null:new LineString(this.flatCoordinates.slice(0===t?0:this.ends_[t-1],this.ends_[t]),this.layout)}getLineStrings(){const i=this.flatCoordinates;var s=this.ends_,r=this.layout;const n=[];let o=0;for(let t=0,e=s.length;t<e;++t){var a=s[t],l=new LineString(i.slice(o,a),r);n.push(l),o=a}return n}getFlatMidpoints(){var i=[],s=this.flatCoordinates;let r=0;var n=this.ends_,o=this.stride;for(let t=0,e=n.length;t<e;++t){var a=n[t],l=interpolatePoint(s,r,a,o,.5);extend(i,l),r=a}return i}getSimplifiedGeometryInternal(t){const e=[];var i=[];return e.length=douglasPeuckerArray(this.flatCoordinates,0,this.ends_,this.stride,t,e,0,i),new MultiLineString(e,GeometryLayout.XY,i)}getType(){return GeometryType.MULTI_LINE_STRING}intersectsExtent(t){return intersectsLineStringArray(this.flatCoordinates,0,this.ends_,this.stride,t)}setCoordinates(t,e){this.setLayout(e,t,2),this.flatCoordinates||(this.flatCoordinates=[]);e=deflateCoordinatesArray(this.flatCoordinates,0,t,this.stride,this.ends_);this.flatCoordinates.length=0===e.length?0:e[e.length-1],this.changed()}}export default MultiLineString;