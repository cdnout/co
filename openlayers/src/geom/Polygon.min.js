import{extend}from"../array.js";import{closestSquaredDistanceXY,getCenter}from"../extent.js";import GeometryLayout from"./GeometryLayout.js";import GeometryType from"./GeometryType.js";import LinearRing from"./LinearRing.js";import Point from"./Point.js";import SimpleGeometry from"./SimpleGeometry.js";import{offset as sphereOffset}from"../sphere.js";import{linearRings as linearRingsArea}from"./flat/area.js";import{assignClosestArrayPoint,arrayMaxSquaredDelta}from"./flat/closest.js";import{linearRingsContainsXY}from"./flat/contains.js";import{deflateCoordinatesArray}from"./flat/deflate.js";import{inflateCoordinatesArray}from"./flat/inflate.js";import{getInteriorPointOfArray}from"./flat/interiorpoint.js";import{intersectsLinearRingArray}from"./flat/intersectsextent.js";import{linearRingsAreOriented,orientLinearRings}from"./flat/orient.js";import{quantizeArray}from"./flat/simplify.js";import{modulo}from"../math.js";class Polygon extends SimpleGeometry{constructor(t,e,i){super(),this.ends_=[],this.flatInteriorPointRevision_=-1,this.flatInteriorPoint_=null,this.maxDelta_=-1,this.maxDeltaRevision_=-1,this.orientedRevision_=-1,this.orientedFlatCoordinates_=null,void 0!==e&&i?(this.setFlatCoordinates(e,t),this.ends_=i):this.setCoordinates(t,e)}appendLinearRing(t){this.flatCoordinates?extend(this.flatCoordinates,t.getFlatCoordinates()):this.flatCoordinates=t.getFlatCoordinates().slice(),this.ends_.push(this.flatCoordinates.length),this.changed()}clone(){return new Polygon(this.flatCoordinates.slice(),this.layout,this.ends_.slice())}closestPointXY(t,e,i,r){return r<closestSquaredDistanceXY(this.getExtent(),t,e)?r:(this.maxDeltaRevision_!=this.getRevision()&&(this.maxDelta_=Math.sqrt(arrayMaxSquaredDelta(this.flatCoordinates,0,this.ends_,this.stride,0)),this.maxDeltaRevision_=this.getRevision()),assignClosestArrayPoint(this.flatCoordinates,0,this.ends_,this.stride,this.maxDelta_,!0,t,e,i,r))}containsXY(t,e){return linearRingsContainsXY(this.getOrientedFlatCoordinates(),0,this.ends_,this.stride,t,e)}getArea(){return linearRingsArea(this.getOrientedFlatCoordinates(),0,this.ends_,this.stride)}getCoordinates(t){let e;return void 0!==t?(e=this.getOrientedFlatCoordinates().slice(),orientLinearRings(e,0,this.ends_,this.stride,t)):e=this.flatCoordinates,inflateCoordinatesArray(e,0,this.ends_,this.stride)}getEnds(){return this.ends_}getFlatInteriorPoint(){var t;return this.flatInteriorPointRevision_!=this.getRevision()&&(t=getCenter(this.getExtent()),this.flatInteriorPoint_=getInteriorPointOfArray(this.getOrientedFlatCoordinates(),0,this.ends_,this.stride,t,0),this.flatInteriorPointRevision_=this.getRevision()),this.flatInteriorPoint_}getInteriorPoint(){return new Point(this.getFlatInteriorPoint(),GeometryLayout.XYM)}getLinearRingCount(){return this.ends_.length}getLinearRing(t){return t<0||this.ends_.length<=t?null:new LinearRing(this.flatCoordinates.slice(0===t?0:this.ends_[t-1],this.ends_[t]),this.layout)}getLinearRings(){var i=this.layout;const r=this.flatCoordinates;var s=this.ends_;const n=[];let o=0;for(let t=0,e=s.length;t<e;++t){var a=s[t],l=new LinearRing(r.slice(o,a),i);n.push(l),o=a}return n}getOrientedFlatCoordinates(){if(this.orientedRevision_!=this.getRevision()){const t=this.flatCoordinates;linearRingsAreOriented(t,0,this.ends_,this.stride)?this.orientedFlatCoordinates_=t:(this.orientedFlatCoordinates_=t.slice(),this.orientedFlatCoordinates_.length=orientLinearRings(this.orientedFlatCoordinates_,0,this.ends_,this.stride)),this.orientedRevision_=this.getRevision()}return this.orientedFlatCoordinates_}getSimplifiedGeometryInternal(t){const e=[];var i=[];return e.length=quantizeArray(this.flatCoordinates,0,this.ends_,this.stride,Math.sqrt(t),e,0,i),new Polygon(e,GeometryLayout.XY,i)}getType(){return GeometryType.POLYGON}intersectsExtent(t){return intersectsLinearRingArray(this.getOrientedFlatCoordinates(),0,this.ends_,this.stride,t)}setCoordinates(t,e){this.setLayout(e,t,2),this.flatCoordinates||(this.flatCoordinates=[]);e=deflateCoordinatesArray(this.flatCoordinates,0,t,this.stride,this.ends_);this.flatCoordinates.length=0===e.length?0:e[e.length-1],this.changed()}}export default Polygon;function circular(e,i,t,r){var s=t||32;const n=[];for(let t=0;t<s;++t)extend(n,sphereOffset(e,i,2*Math.PI*t/s,r));return n.push(n[0],n[1]),new Polygon(n,GeometryLayout.XY,[n.length])}function fromExtent(t){var e=t[0],i=t[1],r=t[2],t=t[3],t=[e,i,e,t,r,t,r,i,e,i];return new Polygon(t,GeometryLayout.XY,[t.length])}function fromCircle(t,e,i){var e=e||32,r=t.getStride(),s=t.getLayout(),n=t.getCenter(),o=r*(e+1);const a=new Array(o);for(let e=0;e<o;e+=r){a[e]=0,a[e+1]=0;for(let t=2;t<r;t++)a[e+t]=n[t]}e=[a.length],s=new Polygon(a,s,e);return makeRegular(s,n,t.getRadius(),i),s}function makeRegular(t,e,i,r){const s=t.getFlatCoordinates();var n=t.getStride(),o=s.length/n-1,a=r||0;for(let t=0;t<=o;++t){var l=t*n,h=a+2*modulo(t,o)*Math.PI/o;s[l]=e[0]+i*Math.cos(h),s[1+l]=e[1]+i*Math.sin(h)}t.changed()}export{circular,fromExtent,fromCircle,makeRegular};