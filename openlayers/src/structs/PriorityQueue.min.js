import{assert}from"../asserts.js";import{clear}from"../obj.js";const DROP=1/0;class PriorityQueue{constructor(e,t){this.priorityFunction_=e,this.keyFunction_=t,this.elements_=[],this.priorities_=[],this.queuedElements_={}}clear(){this.elements_.length=0,this.priorities_.length=0,clear(this.queuedElements_)}dequeue(){const e=this.elements_,t=this.priorities_;var i=e[0],s=(1==e.length?(e.length=0,t.length=0):(e[0]=e.pop(),t[0]=t.pop(),this.siftUp_(0)),this.keyFunction_(i));return delete this.queuedElements_[s],i}enqueue(e){assert(!(this.keyFunction_(e)in this.queuedElements_),31);var t=this.priorityFunction_(e);return t!=DROP&&(this.elements_.push(e),this.priorities_.push(t),this.queuedElements_[this.keyFunction_(e)]=!0,this.siftDown_(0,this.elements_.length-1),!0)}getCount(){return this.elements_.length}getLeftChildIndex_(e){return 2*e+1}getRightChildIndex_(e){return 2*e+2}getParentIndex_(e){return e-1>>1}heapify_(){let e;for(e=(this.elements_.length>>1)-1;0<=e;e--)this.siftUp_(e)}isEmpty(){return 0===this.elements_.length}isKeyQueued(e){return e in this.queuedElements_}isQueued(e){return this.isKeyQueued(this.keyFunction_(e))}siftUp_(e){const t=this.elements_,i=this.priorities_;for(var s=t.length,n=t[e],r=i[e],h=e;e<s>>1;){var u=this.getLeftChildIndex_(e),_=this.getRightChildIndex_(e),_=_<s&&i[_]<i[u]?_:u;t[e]=t[_],i[e]=i[_],e=_}t[e]=n,i[e]=r,this.siftDown_(h,e)}siftDown_(e,t){const i=this.elements_,s=this.priorities_;for(var n=i[t],r=s[t];e<t;){var h=this.getParentIndex_(t);if(!(s[h]>r))break;i[t]=i[h],s[t]=s[h],t=h}i[t]=n,s[t]=r}reprioritize(){const e=this.priorityFunction_,t=this.elements_,i=this.priorities_;let s=0;var n=t.length;let r,h,u;for(h=0;h<n;++h)r=t[h],(u=e(r))==DROP?delete this.queuedElements_[this.keyFunction_(r)]:(i[s]=u,t[s++]=r);t.length=s,i.length=s,this.heapify_()}}export default PriorityQueue;export{DROP};