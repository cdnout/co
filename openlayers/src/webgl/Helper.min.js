import{getUid}from"../util.js";import Disposable from"../Disposable.js";import{clear}from"../obj.js";import ContextEventType from"../webgl/ContextEventType.js";import{compose as composeTransform,create as createTransform,reset as resetTransform,rotate as rotateTransform,scale as scaleTransform}from"../transform.js";import{create,fromTransform}from"../vec/mat4.js";import WebGLPostProcessingPass from"./PostProcessingPass.js";import{getContext,getSupportedExtensions}from"../webgl.js";import{includes}from"../array.js";import{assert}from"../asserts.js";const ShaderType={FRAGMENT_SHADER:35632,VERTEX_SHADER:35633},DefaultUniform={PROJECTION_MATRIX:"u_projectionMatrix",OFFSET_SCALE_MATRIX:"u_offsetScaleMatrix",OFFSET_ROTATION_MATRIX:"u_offsetRotateMatrix"},DefaultAttrib={POSITION:"a_position",TEX_COORD:"a_texCoord",OPACITY:"a_opacity",ROTATE_WITH_VIEW:"a_rotateWithView",OFFSETS:"a_offsets",COLOR:"a_color"};class WebGLHelper extends Disposable{constructor(e){super();const t=e||{},r=(this.boundHandleWebGLContextLost_=this.handleWebGLContextLost.bind(this),this.boundHandleWebGLContextRestored_=this.handleWebGLContextRestored.bind(this),this.canvas_=document.createElement("canvas"),this.canvas_.style.position="absolute",this.gl_=getContext(this.canvas_),this.getGL());if(this.bufferCache_={},this.shaderCache_=[],this.programCache_=[],this.currentProgram_=null,assert(includes(getSupportedExtensions(),"OES_element_index_uint"),63),r.getExtension("OES_element_index_uint"),this.canvas_.addEventListener(ContextEventType.LOST,this.boundHandleWebGLContextLost_),this.canvas_.addEventListener(ContextEventType.RESTORED,this.boundHandleWebGLContextRestored_),this.offsetRotateMatrix_=createTransform(),this.offsetScaleMatrix_=createTransform(),this.tmpMat4_=create(),this.uniformLocations_={},this.attribLocations_={},this.uniforms_=[],t.uniforms)for(const s in t.uniforms)this.uniforms_.push({name:s,value:t.uniforms[s]});this.postProcessPasses_=t.postProcesses?t.postProcesses.map(function(e){return new WebGLPostProcessingPass({webGlContext:r,scaleRatio:e.scaleRatio,vertexShader:e.vertexShader,fragmentShader:e.fragmentShader,uniforms:e.uniforms})}):[new WebGLPostProcessingPass({webGlContext:r})],this.shaderCompileErrors_=null}bindBuffer(e){const t=this.getGL();var r,s=getUid(e);let a=this.bufferCache_[s];a||(r=t.createBuffer(),a=this.bufferCache_[s]={buffer:e,webGlBuffer:r}),t.bindBuffer(e.getType(),a.webGlBuffer)}flushBufferData(e){const t=this.getGL();this.bindBuffer(e),t.bufferData(e.getType(),e.getArray(),e.getUsage())}deleteBuffer(e){const t=this.getGL();var e=getUid(e),r=this.bufferCache_[e];t.isContextLost()||t.deleteBuffer(r.buffer),delete this.bufferCache_[e]}disposeInternal(){this.canvas_.removeEventListener(ContextEventType.LOST,this.boundHandleWebGLContextLost_),this.canvas_.removeEventListener(ContextEventType.RESTORED,this.boundHandleWebGLContextRestored_);const e=this.getGL();if(!e.isContextLost()){for(const t in this.bufferCache_)e.deleteBuffer(this.bufferCache_[t].buffer);for(const r in this.programCache_)e.deleteProgram(this.programCache_[r]);for(const s in this.shaderCache_)e.deleteShader(this.shaderCache_[s])}}prepareDraw(t){const e=this.getGL(),r=this.getCanvas();var s=t.size,a=t.pixelRatio;r.width=s[0]*a,r.height=s[1]*a,r.style.width=s[0]+"px",r.style.height=s[1]+"px",e.useProgram(this.currentProgram_);for(let e=this.postProcessPasses_.length-1;0<=e;e--)this.postProcessPasses_[e].init(t);e.bindTexture(e.TEXTURE_2D,null),e.clearColor(0,0,0,0),e.clear(e.COLOR_BUFFER_BIT),e.enable(e.BLEND),e.blendFunc(e.ONE,e.ONE_MINUS_SRC_ALPHA),e.useProgram(this.currentProgram_),this.applyFrameState(t),this.applyUniforms(t)}prepareDrawToRenderTarget(e,t,r){const s=this.getGL();s.bindFramebuffer(s.FRAMEBUFFER,t.getFramebuffer()),s.viewport(0,0,e.size[0],e.size[1]),s.bindTexture(s.TEXTURE_2D,t.getTexture()),s.clearColor(0,0,0,0),s.clear(s.COLOR_BUFFER_BIT),s.enable(s.BLEND),s.blendFunc(s.ONE,r?s.ZERO:s.ONE_MINUS_SRC_ALPHA),s.useProgram(this.currentProgram_),this.applyFrameState(e),this.applyUniforms(e)}drawElements(e,t){const r=this.getGL();var s=r.UNSIGNED_INT;r.drawElements(r.TRIANGLES,t-e,s,4*e)}finalizeDraw(t){for(let e=0;e<this.postProcessPasses_.length;e++)this.postProcessPasses_[e].apply(t,this.postProcessPasses_[e+1]||null)}getCanvas(){return this.canvas_}getGL(){return this.gl_}applyFrameState(e){var t=e.size,e=e.viewState.rotation,r=resetTransform(this.offsetScaleMatrix_),t=(scaleTransform(r,2/t[0],2/t[1]),resetTransform(this.offsetRotateMatrix_));0!==e&&rotateTransform(t,-e),this.setUniformMatrixValue(DefaultUniform.OFFSET_SCALE_MATRIX,fromTransform(this.tmpMat4_,r)),this.setUniformMatrixValue(DefaultUniform.OFFSET_ROTATION_MATRIX,fromTransform(this.tmpMat4_,t))}applyUniforms(t){const r=this.getGL();let s,a=0;this.uniforms_.forEach(function(e){if((s="function"==typeof e.value?e.value(t):e.value)instanceof HTMLCanvasElement||s instanceof HTMLImageElement||s instanceof ImageData)e.texture||(e.texture=r.createTexture()),r.activeTexture(r["TEXTURE"+a]),r.bindTexture(r.TEXTURE_2D,e.texture),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MIN_FILTER,r.LINEAR),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_S,r.CLAMP_TO_EDGE),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_T,r.CLAMP_TO_EDGE),s instanceof HTMLImageElement&&!s.complete||r.texImage2D(r.TEXTURE_2D,0,r.RGBA,r.RGBA,r.UNSIGNED_BYTE,s),r.uniform1i(this.getUniformLocation(e.name),a++);else if(Array.isArray(s)&&6===s.length)this.setUniformMatrixValue(e.name,fromTransform(this.tmpMat4_,s));else if(Array.isArray(s)&&s.length<=4)switch(s.length){case 2:return void r.uniform2f(this.getUniformLocation(e.name),s[0],s[1]);case 3:return void r.uniform3f(this.getUniformLocation(e.name),s[0],s[1],s[2]);case 4:return void r.uniform4f(this.getUniformLocation(e.name),s[0],s[1],s[2],s[3]);default:return}else"number"==typeof s&&r.uniform1f(this.getUniformLocation(e.name),s)}.bind(this))}useProgram(e){if(e==this.currentProgram_)return!1;{const t=this.getGL();return t.useProgram(e),this.currentProgram_=e,this.uniformLocations_={},this.attribLocations_={},!0}}compileShader(e,t){const r=this.getGL();t=r.createShader(t);return r.shaderSource(t,e),r.compileShader(t),this.shaderCache_.push(t),t}getProgram(e,t){const r=this.getGL();var e=this.compileShader(e,r.FRAGMENT_SHADER),t=this.compileShader(t,r.VERTEX_SHADER),s=(this.shaderCompileErrors_=null,r.getShaderInfoLog(e)&&(this.shaderCompileErrors_=`Fragment shader compilation failed:
`+r.getShaderInfoLog(e)),r.getShaderInfoLog(t)&&(this.shaderCompileErrors_=(this.shaderCompileErrors_||"")+(`Vertex shader compilation failed:
`+r.getShaderInfoLog(t))),r.createProgram());return r.attachShader(s,e),r.attachShader(s,t),r.linkProgram(s),this.programCache_.push(s),s}getShaderCompileErrors(){return this.shaderCompileErrors_}getUniformLocation(e){return void 0===this.uniformLocations_[e]&&(this.uniformLocations_[e]=this.getGL().getUniformLocation(this.currentProgram_,e)),this.uniformLocations_[e]}getAttributeLocation(e){return void 0===this.attribLocations_[e]&&(this.attribLocations_[e]=this.getGL().getAttribLocation(this.currentProgram_,e)),this.attribLocations_[e]}makeProjectionTransform(e,t){var r=e.size,s=e.viewState.rotation,a=e.viewState.resolution,e=e.viewState.center;return resetTransform(t),composeTransform(t,0,0,2/(a*r[0]),2/(a*r[1]),-s,-e[0],-e[1]),t}setUniformFloatValue(e,t){this.getGL().uniform1f(this.getUniformLocation(e),t)}setUniformMatrixValue(e,t){this.getGL().uniformMatrix4fv(this.getUniformLocation(e),!1,t)}enableAttributeArray(e,t,r,s,a){e=this.getAttributeLocation(e);e<0||(this.getGL().enableVertexAttribArray(e),this.getGL().vertexAttribPointer(e,t,r,!1,s,a))}handleWebGLContextLost(){clear(this.bufferCache_),clear(this.shaderCache_),clear(this.programCache_),this.currentProgram_=null}handleWebGLContextRestored(){}createTexture(e,t,r){const s=this.getGL();var r=r||s.createTexture(),a=s.RGBA,o=s.RGBA,i=s.UNSIGNED_BYTE;return s.bindTexture(s.TEXTURE_2D,r),t?s.texImage2D(s.TEXTURE_2D,0,a,o,i,t):s.texImage2D(s.TEXTURE_2D,0,a,e[0],e[1],0,o,i,null),s.texParameteri(s.TEXTURE_2D,s.TEXTURE_MIN_FILTER,s.LINEAR),s.texParameteri(s.TEXTURE_2D,s.TEXTURE_WRAP_S,s.CLAMP_TO_EDGE),s.texParameteri(s.TEXTURE_2D,s.TEXTURE_WRAP_T,s.CLAMP_TO_EDGE),r}}export default WebGLHelper;export{ShaderType,DefaultUniform,DefaultAttrib};