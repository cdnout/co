import WebGLArrayBuffer from"../../webgl/Buffer.js";import{DYNAMIC_DRAW,ARRAY_BUFFER,ELEMENT_ARRAY_BUFFER,FLOAT}from"../../webgl.js";import{DefaultAttrib,DefaultUniform}from"../../webgl/Helper.js";import GeometryType from"../../geom/GeometryType.js";import WebGLLayerRenderer,{colorDecodeId,colorEncodeId,getBlankImageData,POINT_INSTRUCTIONS_COUNT,POINT_VERTEX_STRIDE,WebGLWorkerMessageType,writePointFeatureInstructions}from"./Layer.js";import ViewHint from"../../ViewHint.js";import{createEmpty,equals}from"../../extent.js";import{create as createTransform,makeInverse as makeInverseTransform,multiply as multiplyTransform,apply as applyTransform}from"../../transform.js";import{create as createWebGLWorker}from"../../worker/webgl.js";import{getUid}from"../../util.js";import WebGLRenderTarget from"../../webgl/RenderTarget.js";const VERTEX_SHADER=`
  precision mediump float;
  attribute vec2 a_position;
  attribute vec2 a_texCoord;
  attribute float a_rotateWithView;
  attribute vec2 a_offsets;
  attribute float a_opacity;
  attribute vec4 a_color;

  uniform mat4 u_projectionMatrix;
  uniform mat4 u_offsetScaleMatrix;
  uniform mat4 u_offsetRotateMatrix;

  varying vec2 v_texCoord;
  varying float v_opacity;
  varying vec4 v_color;

  void main(void) {
    mat4 offsetMatrix = u_offsetScaleMatrix;
    if (a_rotateWithView == 1.0) {
      offsetMatrix = u_offsetScaleMatrix * u_offsetRotateMatrix;
    }
    vec4 offsets = offsetMatrix * vec4(a_offsets, 0.0, 0.0);
    gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;
    v_texCoord = a_texCoord;
    v_opacity = a_opacity;
    v_color = a_color;
  }`,FRAGMENT_SHADER=`
  precision mediump float;

  uniform sampler2D u_texture;

  varying vec2 v_texCoord;
  varying float v_opacity;
  varying vec4 v_color;

  void main(void) {
    if (v_opacity == 0.0) {
      discard;
    }
    vec4 textureColor = texture2D(u_texture, v_texCoord);
    gl_FragColor = v_color * textureColor;
    gl_FragColor.a *= v_opacity;
    gl_FragColor.rgb *= gl_FragColor.a;
  }`,HIT_FRAGMENT_SHADER=`
  precision mediump float;

  uniform sampler2D u_texture;

  varying vec2 v_texCoord;
  varying float v_opacity;
  varying vec4 v_color;

  void main(void) {
    if (v_opacity == 0.0) {
      discard;
    }
    vec4 textureColor = texture2D(u_texture, v_texCoord);
    if (textureColor.a < 0.1) {
      discard;
    }
    gl_FragColor = v_color;
  }`;class WebGLPointsLayerRenderer extends WebGLLayerRenderer{constructor(e,r){r=r||{};const t=r.uniforms||{};t.u_texture=r.texture||getBlankImageData();var i=createTransform();t[DefaultUniform.PROJECTION_MATRIX]=i,super(e,{uniforms:t,postProcesses:r.postProcesses}),this.sourceRevision_=-1,this.verticesBuffer_=new WebGLArrayBuffer(ARRAY_BUFFER,DYNAMIC_DRAW),this.hitVerticesBuffer_=new WebGLArrayBuffer(ARRAY_BUFFER,DYNAMIC_DRAW),this.indicesBuffer_=new WebGLArrayBuffer(ELEMENT_ARRAY_BUFFER,DYNAMIC_DRAW),this.program_=this.helper.getProgram(r.fragmentShader||FRAGMENT_SHADER,r.vertexShader||VERTEX_SHADER),this.hitProgram_=this.helper.getProgram(HIT_FRAGMENT_SHADER,VERTEX_SHADER),this.sizeCallback_=r.sizeCallback||function(){return 1},this.coordCallback_=r.coordCallback||function(e,r){const t=e.getGeometry();return t.getCoordinates()[r]},this.opacityCallback_=r.opacityCallback||function(){return 1},this.texCoordCallback_=r.texCoordCallback||function(e,r){return r<2?0:1},this.colorArray_=[1,1,1,1],this.colorCallback_=r.colorCallback||function(e,r){return this.colorArray_},this.rotateWithViewCallback_=r.rotateWithViewCallback||function(){return!1},this.previousExtent_=createEmpty(),this.currentTransform_=i,this.renderTransform_=createTransform(),this.invertRenderTransform_=createTransform(),this.renderInstructions_=new Float32Array(0),this.hitRenderInstructions_=new Float32Array(0),this.hitRenderTarget_=new WebGLRenderTarget(this.helper),this.worker_=createWebGLWorker(),this.worker_.addEventListener("message",function(e){var r,t=e.data;t.type===WebGLWorkerMessageType.GENERATE_BUFFERS&&(r=t.projectionTransform,t.hitDetection?(this.hitVerticesBuffer_.fromArrayBuffer(t.vertexBuffer),this.helper.flushBufferData(this.hitVerticesBuffer_)):(this.verticesBuffer_.fromArrayBuffer(t.vertexBuffer),this.helper.flushBufferData(this.verticesBuffer_)),this.indicesBuffer_.fromArrayBuffer(t.indexBuffer),this.helper.flushBufferData(this.indicesBuffer_),this.renderTransform_=r,makeInverseTransform(this.invertRenderTransform_,this.renderTransform_),t.hitDetection?this.hitRenderInstructions_=new Float32Array(e.data.renderInstructions):this.renderInstructions_=new Float32Array(e.data.renderInstructions),this.getLayer().changed())}.bind(this))}renderFrame(e){var r=this.indicesBuffer_.getSize();this.helper.drawElements(0,r),this.helper.finalizeDraw(e);const t=this.helper.getCanvas();r=e.layerStatesArray[e.layerIndex].opacity;return r!==parseFloat(t.style.opacity)&&(t.style.opacity=r),this.renderHitDetection(e),this.hitRenderTarget_.clearCachedData(),t}prepareFrame(e){const r=this.getLayer(),t=r.getSource();var i=e.viewState,a=POINT_VERTEX_STRIDE,o=this.sourceRevision_<t.getRevision(),i=(o&&(this.sourceRevision_=t.getRevision(),s=i.projection,i=i.resolution,t.loadFeatures([-1/0,-1/0,1/0,1/0],i,s)),!e.viewHints[ViewHint.ANIMATING]&&!e.viewHints[ViewHint.INTERACTING]),s=!equals(this.previousExtent_,e.extent),o=((o||s)&&i&&(this.rebuildBuffers_(e),this.previousExtent_=e.extent.slice()),this.helper.makeProjectionTransform(e,this.currentTransform_),multiplyTransform(this.currentTransform_,this.invertRenderTransform_),this.helper.useProgram(this.program_),this.helper.prepareDraw(e),this.helper.bindBuffer(this.verticesBuffer_),this.helper.bindBuffer(this.indicesBuffer_),Float32Array.BYTES_PER_ELEMENT);return this.helper.enableAttributeArray(DefaultAttrib.POSITION,2,FLOAT,o*a,0),this.helper.enableAttributeArray(DefaultAttrib.OFFSETS,2,FLOAT,o*a,2*o),this.helper.enableAttributeArray(DefaultAttrib.TEX_COORD,2,FLOAT,o*a,4*o),this.helper.enableAttributeArray(DefaultAttrib.OPACITY,1,FLOAT,o*a,6*o),this.helper.enableAttributeArray(DefaultAttrib.ROTATE_WITH_VIEW,1,FLOAT,o*a,7*o),this.helper.enableAttributeArray(DefaultAttrib.COLOR,4,FLOAT,o*a,8*o),!0}rebuildBuffers_(e){const r=this.getLayer(),t=r.getSource();var i=createTransform(),a=(this.helper.makeProjectionTransform(e,i),t.getFeatures()),e=POINT_INSTRUCTIONS_COUNT*a.length;this.renderInstructions_&&this.renderInstructions_.length===e||(this.renderInstructions_=new Float32Array(e)),this.hitRenderInstructions_&&this.hitRenderInstructions_.length===e||(this.hitRenderInstructions_=new Float32Array(e));let o;const s=[];var n,l,f,h,c,u,_,d,p=[];let T=0;for(let e=0;e<a.length;e++)(o=a[e]).getGeometry()&&o.getGeometry().getType()===GeometryType.POINT&&(s[0]=this.coordCallback_(o,0),s[1]=this.coordCallback_(o,1),applyTransform(i,s),n=this.texCoordCallback_(o,0),l=this.texCoordCallback_(o,1),f=this.texCoordCallback_(o,2),h=this.texCoordCallback_(o,3),c=this.sizeCallback_(o),u=this.opacityCallback_(o),_=this.rotateWithViewCallback_(o),d=this.colorCallback_(o,this.colorArray_),writePointFeatureInstructions(this.renderInstructions_,T,s[0],s[1],n,l,f,h,c,u,_,d),T=writePointFeatureInstructions(this.hitRenderInstructions_,T,s[0],s[1],n,l,f,h,c,0<u?Number(getUid(o)):0,_,colorEncodeId(T+7,p)));const m={type:WebGLWorkerMessageType.GENERATE_BUFFERS,renderInstructions:this.renderInstructions_.buffer},A=(m.projectionTransform=i,this.worker_.postMessage(m,[this.renderInstructions_.buffer]),this.renderInstructions_=null,{type:WebGLWorkerMessageType.GENERATE_BUFFERS,renderInstructions:this.hitRenderInstructions_.buffer});A.projectionTransform=i,A.hitDetection=!0,this.worker_.postMessage(A,[this.hitRenderInstructions_.buffer]),this.hitRenderInstructions_=null}forEachFeatureAtCoordinate(e,r,t,i,a){if(this.hitRenderInstructions_){r=applyTransform(r.coordinateToPixelTransform,e.slice()),e=this.hitRenderTarget_.readPixel(r[0],r[1]),r=[e[0]/255,e[1]/255,e[2]/255,e[3]/255],e=colorDecodeId(r),r=this.hitRenderInstructions_[e],e=Math.floor(r).toString();const o=this.getLayer().getSource();r=o.getFeatureByUid(e);return r?i(r,this.getLayer()):void 0}}renderHitDetection(e){var r;this.hitVerticesBuffer_.getSize()===this.verticesBuffer_.getSize()&&(this.hitRenderTarget_.setSize(e.size),this.helper.useProgram(this.hitProgram_),this.helper.prepareDrawToRenderTarget(e,this.hitRenderTarget_,!0),this.helper.bindBuffer(this.hitVerticesBuffer_),this.helper.bindBuffer(this.indicesBuffer_),e=POINT_VERTEX_STRIDE,r=Float32Array.BYTES_PER_ELEMENT,this.helper.enableAttributeArray(DefaultAttrib.POSITION,2,FLOAT,r*e,0),this.helper.enableAttributeArray(DefaultAttrib.OFFSETS,2,FLOAT,r*e,2*r),this.helper.enableAttributeArray(DefaultAttrib.TEX_COORD,2,FLOAT,r*e,4*r),this.helper.enableAttributeArray(DefaultAttrib.OPACITY,1,FLOAT,r*e,6*r),this.helper.enableAttributeArray(DefaultAttrib.ROTATE_WITH_VIEW,1,FLOAT,r*e,7*r),this.helper.enableAttributeArray(DefaultAttrib.COLOR,4,FLOAT,r*e,8*r),e=this.indicesBuffer_.getSize(),this.helper.drawElements(0,e))}}export default WebGLPointsLayerRenderer;