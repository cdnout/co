import{getUid}from"../../util.js";import{fromUserExtent}from"../../proj.js";import TileRange from"../../TileRange.js";import TileState from"../../TileState.js";import{createEmpty,equals,getIntersection,getTopLeft}from"../../extent.js";import CanvasLayerRenderer from"./Layer.js";import{apply as applyTransform,compose as composeTransform,makeInverse,toString as transformToString}from"../../transform.js";import{numberSafeCompareFunction}from"../../array.js";class CanvasTileLayerRenderer extends CanvasLayerRenderer{constructor(e){super(e),this.extentChanged=!0,this.renderedExtent_=null,this.renderedRevision,this.renderedTiles=[],this.newTiles_=!1,this.tmpExtent=createEmpty(),this.tmpTileRange_=new TileRange(0,0,0,0)}isDrawableTile(e){const t=this.getLayer();var e=e.getState(),i=t.getUseInterimTilesOnError();return e==TileState.LOADED||e==TileState.EMPTY||e==TileState.ERROR&&!i}getTile(e,t,i,r){var n=r.pixelRatio,r=r.viewState.projection;const a=this.getLayer(),s=a.getSource();let o=s.getTile(e,t,i,n,r);return o.getState()==TileState.ERROR&&(a.getUseInterimTilesOnError()?0<a.getPreload()&&(this.newTiles_=!0):o.setState(TileState.LOADED)),o=this.isDrawableTile(o)?o:o.getInterimTile()}loadedTileCallback(e,t,i){return!!this.isDrawableTile(i)&&super.loadedTileCallback(e,t,i)}prepareFrame(e){return!!this.getLayer().getSource()}renderFrame(r,O){var t=r.layerStatesArray[r.layerIndex],e=r.viewState,i=e.projection,P=e.resolution,n=e.center,e=e.rotation,a=r.pixelRatio;const k=this.getLayer(),s=k.getSource();var z=s.getRevision();const o=s.getTileGridForProjection(i);var l=o.getZForResolution(P,s.zDirection),d=o.getResolution(l);let h=r.extent;var q=t.extent&&fromUserExtent(t.extent,i),T=(q&&(h=getIntersection(h,fromUserExtent(t.extent,i))),s.getTilePixelRatio(a));let g=Math.round(r.size[0]*T),m=Math.round(r.size[1]*T);e&&(D=Math.round(Math.sqrt(g*g+m*m)),g=m=D);const c=d*g/2/T,p=d*m/2/T;var u=[n[0]-c,n[1]-p,n[0]+c,n[1]+p],f=o.getTileRangeForExtentAndZ(h,l);const x={},Y=(x[l]={},this.createLoadedTileFinder(s,i,x));var Z=this.tmpExtent,K=this.tmpTileRange_;this.newTiles_=!1;for(let i=f.minX;i<=f.maxX;++i)for(let t=f.minY;t<=f.maxY;++t){const F=this.getTile(l,i,t,r);if(this.isDrawableTile(F)){var X=getUid(this);if(F.getState()==TileState.LOADED&&(v=(x[l][F.tileCoord.toString()]=F).inTransition(X),this.newTiles_||!v&&-1!==this.renderedTiles.indexOf(F)||(this.newTiles_=!0)),1===F.getAlpha(X,r.time))continue}var v=o.getTileCoordChildTileRange(F.tileCoord,K,Z);let e=!1;(e=v?Y(l+1,v):e)||o.forEachTileCoordParentTileRange(F.tileCoord,Y,K,Z)}var R=d/P;composeTransform(this.pixelTransform,r.size[0]/2,r.size[1]/2,1/T,1/T,e,-g/2,-m/2),this.useContainer(O,this.pixelTransform,t.opacity);const y=this.context,C=y.canvas;makeInverse(this.inversePixelTransform,this.pixelTransform),composeTransform(this.tempTransform_,g/2,m/2,R,R,0,-g/2,-m/2),C.width!=g||C.height!=m?(C.width=g,C.height=m):this.containerReused||y.clearRect(0,0,g,m),q&&this.clipUnrotated(y,r,q),this.preRender(y,r),this.renderedTiles.length=0;let S=Object.keys(x).map(Number);S.sort(numberSafeCompareFunction);let E,G,w;1!==t.opacity||this.containerReused&&!s.getOpaque(r.viewState.projection)?(E=[],G=[]):S=S.reverse();for(let e=S.length-1;0<=e;--e){var j=S[e],L=s.getTilePixelSize(j,a,i),Q=o.getResolution(j)/d;const c=L[0]*Q*R,p=L[1]*Q*R;var W=o.getTileCoordForCoordAndZ(getTopLeft(u),j),L=o.getTileCoordExtent(W),N=applyTransform(this.tempTransform_,[T*(L[0]-u[0])/d,T*(u[3]-L[3])/d]),B=T*s.getGutterForProjection(i),H=x[j];for(const $ in H){const M=H[$];var b,I=M.tileCoord,U=N[0]-(W[1]-I[1])*c,_=Math.round(U+c),I=N[1]-(W[2]-I[2])*p,A=Math.round(I+p),U=Math.round(U),I=Math.round(I),_=_-U,A=A-I,J=l===j,V=J&&1!==M.getAlpha(getUid(this),r.time);if(!V)if(E){y.save(),w=[U,I,U+_,I,U+_,I+A,U,I+A];for(let e=0,t=E.length;e<t;++e)l!==j&&j<G[e]&&(b=E[e],y.beginPath(),y.moveTo(w[0],w[1]),y.lineTo(w[2],w[3]),y.lineTo(w[4],w[5]),y.lineTo(w[6],w[7]),y.moveTo(b[6],b[7]),y.lineTo(b[4],b[5]),y.lineTo(b[2],b[3]),y.lineTo(b[0],b[1]),y.clip());E.push(w),G.push(j)}else y.clearRect(U,I,_,A);this.drawTileImage(M,r,U,I,_,A,B,J,t.opacity),E&&!V&&y.restore(),this.renderedTiles.push(M),this.updateUsedTiles(r.usedTiles,s,M)}}this.renderedRevision=z,this.renderedResolution=d,this.extentChanged=!this.renderedExtent_||!equals(this.renderedExtent_,u),this.renderedExtent_=u,this.manageTilePyramid(r,s,o,a,i,h,l,k.getPreload()),this.updateCacheSize_(r,s),this.scheduleExpireCache(r,s),this.postRender(y,r),t.extent&&y.restore();var D=transformToString(this.pixelTransform);return D!==C.style.transform&&(C.style.transform=D),this.container}drawTileImage(e,t,i,r,n,a,s,o,l){var d,h,T,g=this.getTileImage(e);g&&(d=getUid(this),(T=(h=l*(l=o?e.getAlpha(d,t.time):1))!==this.context.globalAlpha)&&(this.context.save(),this.context.globalAlpha=h),this.context.drawImage(g,s,s,g.width-2*s,g.height-2*s,i,r,n,a),T&&this.context.restore(),1!==l?t.animate=!0:o&&e.endTransition(d))}getImage(){var e=this.context;return e?e.canvas:null}getTileImage(e){return e.getImage()}scheduleExpireCache(e,t){t.canExpireCache()&&(t=function(e,t,i){var r=getUid(e);r in i.usedTiles&&e.expireCache(i.viewState.projection,i.usedTiles[r])}.bind(null,t),e.postRenderFunctions.push(t))}updateUsedTiles(e,t,i){t=getUid(t);t in e||(e[t]={}),e[t][i.getKey()]=!0}updateCacheSize_(e,t){var i=getUid(t);let r=0;i in e.usedTiles&&(r+=Object.keys(e.usedTiles[i]).length),i in e.wantedTiles&&(r+=Object.keys(e.wantedTiles[i]).length);const n=t.tileCache;n.highWaterMark<r&&(n.highWaterMark=r)}manageTilePyramid(e,t,i,r,n,a,s,o,l){var d=getUid(t);d in e.wantedTiles||(e.wantedTiles[d]={});const h=e.wantedTiles[d],T=e.tileQueue;e=i.getMinZoom();let g,m,c,p,u,f;for(f=e;f<=s;++f)for(m=i.getTileRangeForExtentAndZ(a,f,m),c=i.getResolution(f),p=m.minX;p<=m.maxX;++p)for(u=m.minY;u<=m.maxY;++u)s-f<=o?((g=t.getTile(f,p,u,r,n)).getState()==TileState.IDLE&&(h[g.getKey()]=!0,T.isKeyQueued(g.getKey())||T.enqueue([g,d,i.getTileCoordCenter(g.tileCoord),c])),void 0!==l&&l(g)):t.useTile(f,p,u,n)}}CanvasTileLayerRenderer.prototype.getLayer;export default CanvasTileLayerRenderer;