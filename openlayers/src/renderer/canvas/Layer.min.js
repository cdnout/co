import{getBottomLeft,getBottomRight,getTopLeft,getTopRight}from"../../extent.js";import{createCanvasContext2D}from"../../dom.js";import RenderEvent from"../../render/Event.js";import RenderEventType from"../../render/EventType.js";import{rotateAtOffset}from"../../render/canvas.js";import LayerRenderer from"../Layer.js";import{create as createTransform,apply as applyTransform,compose as composeTransform,toString as transformToString}from"../../transform.js";class CanvasLayerRenderer extends LayerRenderer{constructor(e){super(e),this.container=null,this.renderedResolution,this.tempTransform_=createTransform(),this.pixelTransform=createTransform(),this.inversePixelTransform=createTransform(),this.context=null,this.containerReused=!1}useContainer(e,t,r){var o=this.getLayer().getClassName();let n,a;if(e&&""===e.style.opacity&&e.className===o){const s=e.firstElementChild;s instanceof HTMLCanvasElement&&(a=s.getContext("2d"))}if(a&&a.canvas.style.transform===transformToString(t)?(this.container=e,this.context=a,this.containerReused=!0):this.containerReused&&(this.container=null,this.context=null,this.containerReused=!1),!this.container){(n=document.createElement("div")).className=o;let e=n.style;e.position="absolute",e.width="100%",e.height="100%";t=(a=createCanvasContext2D()).canvas;n.appendChild(t),(e=t.style).position="absolute",e.transformOrigin="top left",this.container=n,this.context=a}}clip(e,t,r){var o=t.pixelRatio,n=t.size[0]*o/2,a=t.size[1]*o/2,s=t.viewState.rotation,i=getTopLeft(r),m=getTopRight(r),l=getBottomRight(r),r=getBottomLeft(r);applyTransform(t.coordinateToPixelTransform,i),applyTransform(t.coordinateToPixelTransform,m),applyTransform(t.coordinateToPixelTransform,l),applyTransform(t.coordinateToPixelTransform,r),e.save(),rotateAtOffset(e,-s,n,a),e.beginPath(),e.moveTo(i[0]*o,i[1]*o),e.lineTo(m[0]*o,m[1]*o),e.lineTo(l[0]*o,l[1]*o),e.lineTo(r[0]*o,r[1]*o),e.clip(),rotateAtOffset(e,s,n,a)}clipUnrotated(e,t,r){var o=getTopLeft(r),n=getTopRight(r),a=getBottomRight(r),r=getBottomLeft(r),t=(applyTransform(t.coordinateToPixelTransform,o),applyTransform(t.coordinateToPixelTransform,n),applyTransform(t.coordinateToPixelTransform,a),applyTransform(t.coordinateToPixelTransform,r),this.inversePixelTransform);applyTransform(t,o),applyTransform(t,n),applyTransform(t,a),applyTransform(t,r),e.save(),e.beginPath(),e.moveTo(Math.round(o[0]),Math.round(o[1])),e.lineTo(Math.round(n[0]),Math.round(n[1])),e.lineTo(Math.round(a[0]),Math.round(a[1])),e.lineTo(Math.round(r[0]),Math.round(r[1])),e.clip()}dispatchRenderEvent_(e,t,r){const o=this.getLayer();o.hasListener(e)&&(e=new RenderEvent(e,this.inversePixelTransform,r,t),o.dispatchEvent(e))}preRender(e,t){this.dispatchRenderEvent_(RenderEventType.PRERENDER,e,t)}postRender(e,t){this.dispatchRenderEvent_(RenderEventType.POSTRENDER,e,t)}getRenderTransform(e,t,r,o){var n=e.viewState,e=e.pixelRatio/n.resolution,o=-n.center[0]+o,a=-n.center[1];return composeTransform(this.tempTransform_,t/2,r/2,e,-e,-n.rotation,o,a)}getDataAtPixel(e,t,r){e=applyTransform(this.inversePixelTransform,e.slice());const o=this.context;let n;try{n=o.getImageData(Math.round(e[0]),Math.round(e[1]),1,1).data}catch(e){return"SecurityError"===e.name?new Uint8Array:n}return 0===n[3]?null:n}}export default CanvasLayerRenderer;