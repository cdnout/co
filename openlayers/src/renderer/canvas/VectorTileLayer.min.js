import{getUid}from"../../util.js";import{createCanvasContext2D}from"../../dom.js";import TileState from"../../TileState.js";import ViewHint from"../../ViewHint.js";import{listen,unlistenByKey}from"../../events.js";import EventType from"../../events/EventType.js";import{buffer,containsCoordinate,equals,getIntersection,intersects}from"../../extent.js";import VectorTileRenderType from"../../layer/VectorTileRenderType.js";import ReplayType from"../../render/canvas/BuilderType.js";import CanvasBuilderGroup from"../../render/canvas/BuilderGroup.js";import CanvasTileLayerRenderer from"./TileLayer.js";import{getSquaredTolerance as getSquaredRenderTolerance,renderFeature}from"../vector.js";import{apply as applyTransform,create as createTransform,reset as resetTransform,scale as scaleTransform,translate as translateTransform,toString as transformToString,makeScale,makeInverse}from"../../transform.js";import CanvasExecutorGroup,{replayDeclutter}from"../../render/canvas/ExecutorGroup.js";import{clear}from"../../obj.js";const IMAGE_REPLAYS={image:[ReplayType.POLYGON,ReplayType.CIRCLE,ReplayType.LINE_STRING,ReplayType.IMAGE,ReplayType.TEXT],hybrid:[ReplayType.POLYGON,ReplayType.LINE_STRING]},VECTOR_REPLAYS={image:[ReplayType.DEFAULT],hybrid:[ReplayType.IMAGE,ReplayType.TEXT,ReplayType.DEFAULT]};class CanvasVectorTileLayerRenderer extends CanvasTileLayerRenderer{constructor(e){super(e),this.boundHandleStyleImageChange_=this.handleStyleImageChange_.bind(this),this.overlayContext_=null,this.overlayContextUid_,this.overlayPixelTransform_=createTransform(),this.inverseOverlayPixelTransform_=createTransform(),this.dirty_=!1,this.renderedLayerRevision_,this.renderTileImageQueue_={},this.tileListenerKeys_={},this.tmpTransform_=createTransform()}useContainer(e,t,r){let i;e&&2===e.childElementCount&&!(i=e.lastElementChild.getContext("2d"))&&(e=null);var n=this.containerReused;if(super.useContainer(e,t,r),n&&(this.overlayContext_=i||null,this.overlayContextUid_=i?getUid(i):void 0),!this.overlayContext_){const i=createCanvasContext2D(),a=i.canvas.style;a.position="absolute",a.transformOrigin="top left",this.overlayContext_=i,this.overlayContextUid_=getUid(i)}1===this.container.childElementCount&&this.container.appendChild(this.overlayContext_.canvas)}prepareTile(e,t,r,i){let n=!1;var a=getUid(e),o=e.getState();return(o===TileState.LOADED&&e.hifi||o===TileState.ERROR||o===TileState.ABORT)&&a in this.tileListenerKeys_&&(unlistenByKey(this.tileListenerKeys_[a]),delete this.tileListenerKeys_[a]),o!==TileState.LOADED&&o!==TileState.ERROR||(this.updateExecutorGroup_(e,t,r),this.tileImageNeedsRender_(e,t,r)&&(n=!0,i&&(this.renderTileImageQueue_[a]=e))),n}getTile(e,t,r,i){const n=super.getTile(e,t,r,i);var a,o,e=i.pixelRatio,t=i.viewState,r=t.resolution,t=t.projection;return n.getState()<TileState.LOADED?(n.wantedResolution=r,(o=getUid(n))in this.tileListenerKeys_||(a=listen(n,EventType.CHANGE,this.prepareTile.bind(this,n,e,t,!0)),this.tileListenerKeys_[o]=a)):(!!((o=i.viewHints)[ViewHint.ANIMATING]||o[ViewHint.INTERACTING])&&n.wantedResolution||(n.wantedResolution=r),this.prepareTile(n,e,t,!1)&&this.renderTileImage_(n,i)),n}isDrawableTile(e){return super.isDrawableTile(e)&&e.hasContext(this.getLayer())}getTileImage(e){return e.getImage(this.getLayer())}prepareFrame(e){const t=e.layerStatesArray[e.layerIndex];t.hasOverlay=!0;var r=this.getLayer().getRevision();return this.renderedLayerRevision_!=r&&(this.renderedTiles.length=0),this.renderedLayerRevision_=r,super.prepareFrame(e)}updateExecutorGroup_(r,i,e){const n=this.getLayer();var t=n.getRevision(),a=n.getRenderOrder()||null;const o=r.wantedResolution,s=r.getReplayState(n);if(s.dirty||s.renderedResolution!==o||s.renderedRevision!=t||s.renderedRenderOrder!=a||s.renderedZ!==r.sourceZ){const p=n.getSource(),y=p.getTileGrid(),m=p.getTileGridForProjection(e);var l=m.getTileCoordExtent(r.wrappedTileCoord),d=p.getSourceTiles(i,e,r),u=getUid(n);const v=r.executorGroups[u];if(v)for(let e=0,t=v.length;e<t;++e)v[e].dispose();r.executorGroups[u]=[];for(let e=0,t=d.length;e<t;++e){const f=d[e];if(f.getState()==TileState.LOADED){var T=f.tileCoord,T=y.getTileCoordExtent(T),c=getIntersection(l,T),g=equals(T,c)?null:buffer(c,n.getRenderBuffer()*o,this.tmpExtent);s.dirty=!1;const R=new CanvasBuilderGroup(0,c,o,i,n.getDeclutter()),C=getSquaredRenderTolerance(o,i);function h(e){let t;const r=e.getStyleFunction()||n.getStyleFunction();(t=r?r(e,o):t)&&(e=this.renderFeature(e,C,t,R),this.dirty_=this.dirty_||e,s.dirty=s.dirty||e)}const _=f.getFeatures();a&&a!==s.renderedRenderOrder&&_.sort(a);for(let e=0,t=_.length;e<t;++e){const x=_[e];g&&!intersects(g,x.getGeometry().getExtent())||h.call(this,x)}T=R.finish(),c=n.getDeclutter()&&1===d.length?null:c,c=new CanvasExecutorGroup(c,o,i,p.getOverlaps(),T,n.getRenderBuffer());r.executorGroups[u].push(c)}}s.renderedRevision=t,s.renderedZ=r.sourceZ,s.renderedRenderOrder=a,s.renderedResolution=o}}forEachFeatureAtCoordinate(r,e,i,n,a){var o=e.viewState.resolution,s=e.viewState.rotation;i=null==i?0:i;const l=this.getLayer();var t=l.getDeclutter();const d=l.getSource(),u=d.getTileGridForProjection(e.viewState.projection),T={};var c=this.renderedTiles;let g,h,p;for(h=0,p=c.length;h<p;++h){var y=c[h],m=u.getTileCoordExtent(y.wrappedTileCoord);const f=containsCoordinate(m,r);if(t||f){var v=y.executorGroups[getUid(l)];for(let e=0,t=v.length;e<t;++e){const R=v[e];g=g||R.forEachFeatureAtCoordinate(r,o,s,i,function(t){if(f||a&&-1!==a.indexOf(t)){let e=t.getId();if(!((e=void 0===e?getUid(t):e)in T))return T[e]=!0,n(t,l)}},l.getDeclutter()?a:null)}}}return g}handleFontsChanged(){clear(this.renderTileImageQueue_);const e=this.getLayer();e.getVisible()&&void 0!==this.renderedLayerRevision_&&e.changed()}handleStyleImageChange_(e){this.renderIfReadyAndVisible()}renderFrame(t,e){var r=t.viewHints,n=!(r[ViewHint.ANIMATING]||r[ViewHint.INTERACTING]);this.renderQueuedTileImages_(n,t),super.renderFrame(t,e);const a=this.getLayer();r=a.getRenderMode();if(r===VectorTileRenderType.IMAGE)return this.container;const i=a.getSource();var o=t.usedTiles[getUid(i)];for(const S in this.renderTileImageQueue_)o&&S in o||delete this.renderTileImageQueue_[S];const s=this.overlayContext_;var l=a.getDeclutter()?{}:null,d=VECTOR_REPLAYS[r],e=t.pixelRatio,u=t.viewState.rotation,r=t.size;makeScale(this.overlayPixelTransform_,1/e,1/e),makeInverse(this.inverseOverlayPixelTransform_,this.overlayPixelTransform_);const T=s.canvas;var c=Math.round(r[0]*e),g=Math.round(r[1]*e),h=(T.width!=c||T.height!=g?(T.width=c,T.height=g,r=transformToString(this.overlayPixelTransform_),T.style.transform!==r&&(T.style.transform=r)):getUid(s)===this.overlayContextUid_&&s.clearRect(0,0,c,g),this.renderedTiles);const p=i.getTileGridForProjection(t.viewState.projection),y=[],m=[];for(let e=h.length-1;0<=e;--e){const E=h[e];if(E.getState()!=TileState.ABORT){var v=E.tileCoord,f=p.getTileCoordExtent(E.wrappedTileCoord),v=p.getTileCoordExtent(v,this.tmpExtent)[0]-f[0],R=this.getRenderTransform(t,c,g,v),C=E.executorGroups[getUid(a)];let i=!1;for(let e=0,t=C.length;e<t;++e){const I=C[e];if(I.hasExecutors(d)){var _=E.tileCoord[0];let r;if(!l&&!i){r=I.getClipCoords(R),s.save();for(let e=0,t=y.length;e<t;++e){var x=y[e];_<m[e]&&(s.beginPath(),s.moveTo(r[0],r[1]),s.lineTo(r[2],r[3]),s.lineTo(r[4],r[5]),s.lineTo(r[6],r[7]),s.moveTo(x[6],x[7]),s.lineTo(x[4],x[5]),s.lineTo(x[2],x[3]),s.lineTo(x[0],x[1]),s.clip())}}I.execute(s,R,u,n,d,l),l||i||(s.restore(),y.push(r),m.push(_),i=!0)}}}}return l&&(e=t.layerStatesArray[t.layerIndex],replayDeclutter(l,s,u,e.opacity,n,t.declutterItems)),this.container}renderQueuedTileImages_(e,t){for(const i in this.renderTileImageQueue_){if(!e&&8<Date.now()-t.time){t.animate=!0;break}var r=this.renderTileImageQueue_[i];delete this.renderTileImageQueue_[i],this.renderTileImage_(r,t)}}renderFeature(r,i,n,a){if(!n)return!1;let o=!1;if(Array.isArray(n))for(let e=0,t=n.length;e<t;++e)o=renderFeature(a,r,n[e],i,this.boundHandleStyleImageChange_)||o;else o=renderFeature(a,r,n,i,this.boundHandleStyleImageChange_);return o}tileImageNeedsRender_(e,t,r){const i=this.getLayer();var n=e.getReplayState(i),a=i.getRevision(),o=e.sourceZ,e=e.wantedResolution;return n.renderedTileResolution!==e||n.renderedTileRevision!==a||n.renderedTileZ!==o}renderTileImage_(e,t){const r=this.getLayer(),i=e.getReplayState(r);var n=r.getRevision(),a=e.executorGroups[getUid(r)],n=(i.renderedTileRevision=n,i.renderedTileZ=e.sourceZ,e.wrappedTileCoord),o=n[0];const s=r.getSource();var l=t.pixelRatio,d=t.viewState.projection;const u=s.getTileGridForProjection(d);var T=u.getResolution(e.tileCoord[0]),t=t.pixelRatio/e.wantedResolution*T,T=u.getResolution(o);const c=e.getContext(r);var l=Math.max(l,t/l),o=s.getTilePixelSize(o,l,d),d=(c.canvas.width=o[0],c.canvas.height=o[1],l/t),l=(1!=d&&(o=resetTransform(this.tmpTransform_),scaleTransform(o,d,d),c.setTransform.apply(c,o)),u.getTileCoordExtent(n,this.tmpExtent)),d=t/T,g=resetTransform(this.tmpTransform_);scaleTransform(g,d,-d),translateTransform(g,-l[0],-l[3]);for(let e=0,t=a.length;e<t;++e){const h=a[e];h.execute(c,g,0,!0,IMAGE_REPLAYS[r.getRenderMode()])}i.renderedTileResolution=e.wantedResolution}getDataAtPixel(e,t,r){let i=super.getDataAtPixel(e,t,r);if(i)return i;t=applyTransform(this.inverseOverlayPixelTransform_,e.slice());const n=this.overlayContext_;try{i=n.getImageData(Math.round(t[0]),Math.round(t[1]),1,1).data}catch(e){return"SecurityError"===e.name?new Uint8Array:i}return 0===i[3]?null:i}}export default CanvasVectorTileLayerRenderer;