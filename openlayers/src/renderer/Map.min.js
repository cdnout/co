import{abstract}from"../util.js";import Disposable from"../Disposable.js";import{getWidth}from"../extent.js";import{TRUE}from"../functions.js";import{inView}from"../layer/Layer.js";import{shared as iconImageCache}from"../style/IconImageCache.js";import{compose as composeTransform,makeInverse}from"../transform.js";import{renderDeclutterItems}from"../render.js";class MapRenderer extends Disposable{constructor(e){super(),this.map_=e,this.declutterTree_=null}dispatchRenderEvent(e,r){abstract()}calculateMatrices2D(e){var r=e.viewState,t=e.coordinateToPixelTransform,a=e.pixelToCoordinateTransform;composeTransform(t,e.size[0]/2,e.size[1]/2,1/r.resolution,-1/r.resolution,-r.rotation,-r.center[0],-r.center[1]),makeInverse(a,t)}forEachFeatureAtCoordinate(e,r,t,a,o,n,i){let s;var c,l,m=r.viewState;function u(e,r,t){if(e)return a.call(o,r,t)}const p=m.projection;let d=e;p.canWrapX()&&(l=p.getExtent(),c=getWidth(l),((f=e[0])<l[0]||f>l[2])&&(l=Math.ceil((l[0]-f)/c),d=[f+c*l,e[1]]));var h=r.layerStatesArray,f=h.length;let g;this.declutterTree_&&(g=this.declutterTree_.all().map(function(e){return e.value}));let C;for(C=f-1;0<=C;--C){var T=h[C];const x=T.layer;if(x.hasRenderer()&&inView(T,m)&&n.call(i,x)){const I=x.getRenderer(),v=x.getSource();if(I&&v){const a=u.bind(null,T.managed);s=I.forEachFeatureAtCoordinate(v.getWrapX()?d:e,r,t,a,g)}if(s)return s}}}forEachLayerAtPixel(e,r,t,a,o){return abstract()}hasFeatureAtCoordinate(e,r,t,a,o){return void 0!==this.forEachFeatureAtCoordinate(e,r,t,TRUE,this,a,o)}getMap(){return this.map_}renderFrame(e){this.declutterTree_=renderDeclutterItems(e,this.declutterTree_)}scheduleExpireIconCache(e){iconImageCache.canExpireCache()&&e.postRenderFunctions.push(expireIconCache)}}function expireIconCache(e,r){iconImageCache.expire()}export default MapRenderer;