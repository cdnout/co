import{getUid}from"../util.js";import{assert}from"../asserts.js";import Feature from"../Feature.js";import GeometryType from"../geom/GeometryType.js";import{scale as scaleCoordinate,add as addCoordinate}from"../coordinate.js";import EventType from"../events/EventType.js";import{buffer,createEmpty,createOrUpdateFromCoordinate}from"../extent.js";import Point from"../geom/Point.js";import VectorSource from"./Vector.js";class Cluster extends VectorSource{constructor(e){super({attributions:e.attributions,wrapX:e.wrapX}),this.resolution=void 0,this.distance=void 0!==e.distance?e.distance:20,this.features=[],this.geometryFunction=e.geometryFunction||function(e){const t=e.getGeometry();return assert(t.getType()==GeometryType.POINT,10),t},this.source=e.source,this.source.addEventListener(EventType.CHANGE,this.refresh.bind(this))}getDistance(){return this.distance}getSource(){return this.source}loadFeatures(e,t,r){this.source.loadFeatures(e,t,r),t!==this.resolution&&(this.clear(),this.resolution=t,this.cluster(),this.addFeatures(this.features))}setDistance(e){this.distance=e,this.refresh()}refresh(){this.clear(),this.cluster(),this.addFeatures(this.features)}cluster(){if(void 0!==this.resolution){this.features.length=0;var r=createEmpty(),s=this.distance*this.resolution,o=this.source.getFeatures();const n={};for(let e=0,t=o.length;e<t;e++){var i=o[e];if(!(getUid(i)in n)){const a=this.geometryFunction(i);if(a){i=a.getCoordinates();createOrUpdateFromCoordinate(i,r),buffer(r,s,r);let e=this.source.getFeaturesInExtent(r);e=e.filter(function(e){e=getUid(e);return!(e in n)&&(n[e]=!0)}),this.features.push(this.createCluster(e))}}}}}createCluster(t){var r=[0,0];for(let e=t.length-1;0<=e;--e){const s=this.geometryFunction(t[e]);s?addCoordinate(r,s.getCoordinates()):t.splice(e,1)}scaleCoordinate(r,1/t.length);const e=new Feature(new Point(r));return e.set("features",t),e}}export default Cluster;