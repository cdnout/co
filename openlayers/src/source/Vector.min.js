import{getUid}from"../util.js";import Collection from"../Collection.js";import CollectionEventType from"../CollectionEventType.js";import ObjectEventType from"../ObjectEventType.js";import{extend}from"../array.js";import{assert}from"../asserts.js";import{listen,unlistenByKey}from"../events.js";import Event from"../events/Event.js";import EventType from"../events/EventType.js";import{containsExtent,equals}from"../extent.js";import{xhr}from"../featureloader.js";import{TRUE,VOID}from"../functions.js";import{all as allStrategy}from"../loadingstrategy.js";import{isEmpty,getValues}from"../obj.js";import Source from"./Source.js";import SourceState from"./State.js";import VectorEventType from"./VectorEventType.js";import RBush from"../structs/RBush.js";class VectorSourceEvent extends Event{constructor(e,t){super(e),this.feature=t}}class VectorSource extends Source{constructor(e){var e=e||{},t=(super({attributions:e.attributions,projection:void 0,state:SourceState.READY,wrapX:void 0===e.wrapX||e.wrapX}),this.loader_=VOID,this.format_=e.format,this.overlaps_=null==e.overlaps||e.overlaps,this.url_=e.url,void 0!==e.loader?this.loader_=e.loader:void 0!==this.url_&&(assert(this.format_,7),this.loader_=xhr(this.url_,this.format_)),this.strategy_=void 0!==e.strategy?e.strategy:allStrategy,void 0===e.useSpatialIndex||e.useSpatialIndex);this.featuresRtree_=t?new RBush:null,this.loadedExtentsRtree_=new RBush,this.nullGeometryFeatures_={},this.idIndex_={},this.uidIndex_={},this.featureChangeKeys_={},this.featuresCollection_=null;let r,s;Array.isArray(e.features)?s=e.features:e.features&&(r=e.features,s=r.getArray()),t||void 0!==r||(r=new Collection(s)),void 0!==s&&this.addFeaturesInternal(s),void 0!==r&&this.bindFeaturesCollection_(r)}addFeature(e){this.addFeatureInternal(e),this.changed()}addFeatureInternal(e){var t,r=getUid(e);if(this.addToIndex_(r,e)){this.setupChangeEvents_(r,e);const s=e.getGeometry();s?(t=s.getExtent(),this.featuresRtree_&&this.featuresRtree_.insert(t,e)):this.nullGeometryFeatures_[r]=e,this.dispatchEvent(new VectorSourceEvent(VectorEventType.ADDFEATURE,e))}else this.featuresCollection_&&this.featuresCollection_.remove(e)}setupChangeEvents_(e,t){this.featureChangeKeys_[e]=[listen(t,EventType.CHANGE,this.handleFeatureChange_,this),listen(t,ObjectEventType.PROPERTYCHANGE,this.handleFeatureChange_,this)]}addToIndex_(e,t){let r=!0;const s=t.getId();return void 0!==s&&(s.toString()in this.idIndex_?r=!1:this.idIndex_[s.toString()]=t),r&&(assert(!(e in this.uidIndex_),30),this.uidIndex_[e]=t),r}addFeatures(e){this.addFeaturesInternal(e),this.changed()}addFeaturesInternal(r){const s=[],n=[],i=[];for(let e=0,t=r.length;e<t;e++){var o=r[e],a=getUid(o);this.addToIndex_(a,o)&&n.push(o)}for(let e=0,t=n.length;e<t;e++){const l=n[e];var u,h=getUid(l);this.setupChangeEvents_(h,l);const d=l.getGeometry();d?(u=d.getExtent(),s.push(u),i.push(l)):this.nullGeometryFeatures_[h]=l}this.featuresRtree_&&this.featuresRtree_.load(s,i);for(let e=0,t=n.length;e<t;e++)this.dispatchEvent(new VectorSourceEvent(VectorEventType.ADDFEATURE,n[e]))}bindFeaturesCollection_(t){let r=!1;this.addEventListener(VectorEventType.ADDFEATURE,function(e){r||(r=!0,t.push(e.feature),r=!1)}),this.addEventListener(VectorEventType.REMOVEFEATURE,function(e){r||(r=!0,t.remove(e.feature),r=!1)}),t.addEventListener(CollectionEventType.ADD,function(e){r||(r=!0,this.addFeature(e.element),r=!1)}.bind(this)),t.addEventListener(CollectionEventType.REMOVE,function(e){r||(r=!0,this.removeFeature(e.element),r=!1)}.bind(this)),this.featuresCollection_=t}clear(e){if(e){for(const t in this.featureChangeKeys_){const r=this.featureChangeKeys_[t];r.forEach(unlistenByKey)}this.featuresCollection_||(this.featureChangeKeys_={},this.idIndex_={},this.uidIndex_={})}else if(this.featuresRtree_){this.featuresRtree_.forEach(this.removeFeatureInternal.bind(this));for(const s in this.nullGeometryFeatures_)this.removeFeatureInternal(this.nullGeometryFeatures_[s])}this.featuresCollection_&&this.featuresCollection_.clear(),this.featuresRtree_&&this.featuresRtree_.clear(),this.nullGeometryFeatures_={};e=new VectorSourceEvent(VectorEventType.CLEAR);this.dispatchEvent(e),this.changed()}forEachFeature(e){if(this.featuresRtree_)return this.featuresRtree_.forEach(e);this.featuresCollection_&&this.featuresCollection_.forEach(e)}forEachFeatureAtCoordinateDirect(r,s){var e=[r[0],r[1],r[0],r[1]];return this.forEachFeatureInExtent(e,function(e){const t=e.getGeometry();if(t.intersectsCoordinate(r))return s(e)})}forEachFeatureInExtent(e,t){if(this.featuresRtree_)return this.featuresRtree_.forEachInExtent(e,t);this.featuresCollection_&&this.featuresCollection_.forEach(t)}forEachFeatureIntersectingExtent(r,s){return this.forEachFeatureInExtent(r,function(e){const t=e.getGeometry();if(t.intersectsExtent(r)){e=s(e);if(e)return e}})}getFeaturesCollection(){return this.featuresCollection_}getFeatures(){let e;return this.featuresCollection_?e=this.featuresCollection_.getArray():this.featuresRtree_&&(e=this.featuresRtree_.getAll(),isEmpty(this.nullGeometryFeatures_)||extend(e,getValues(this.nullGeometryFeatures_))),e}getFeaturesAtCoordinate(e){const t=[];return this.forEachFeatureAtCoordinateDirect(e,function(e){t.push(e)}),t}getFeaturesInExtent(e){return this.featuresRtree_.getInExtent(e)}getClosestFeatureToCoordinate(e,t){const s=e[0],n=e[1];let i=null;const o=[NaN,NaN];let a=1/0;const u=[-1/0,-1/0,1/0,1/0],h=t||TRUE;return this.featuresRtree_.forEachInExtent(u,function(e){if(h(e)){const r=e.getGeometry();var t=a;(a=r.closestPointXY(s,n,o,a))<t&&(i=e,t=Math.sqrt(a),u[0]=s-t,u[1]=n-t,u[2]=s+t,u[3]=n+t)}}),i}getExtent(e){return this.featuresRtree_.getExtent(e)}getFeatureById(e){e=this.idIndex_[e.toString()];return void 0!==e?e:null}getFeatureByUid(e){e=this.uidIndex_[e];return void 0!==e?e:null}getFormat(){return this.format_}getOverlaps(){return this.overlaps_}getUrl(){return this.url_}handleFeatureChange_(e){const t=e.target;var r,e=getUid(t);const s=t.getGeometry(),n=(s?(r=s.getExtent(),e in this.nullGeometryFeatures_?(delete this.nullGeometryFeatures_[e],this.featuresRtree_&&this.featuresRtree_.insert(r,t)):this.featuresRtree_&&this.featuresRtree_.update(r,t)):e in this.nullGeometryFeatures_||(this.featuresRtree_&&this.featuresRtree_.remove(t),this.nullGeometryFeatures_[e]=t),t.getId());void 0!==n?(r=n.toString(),this.idIndex_[r]!==t&&(this.removeFromIdIndex_(t),this.idIndex_[r]=t)):(this.removeFromIdIndex_(t),this.uidIndex_[e]=t),this.changed(),this.dispatchEvent(new VectorSourceEvent(VectorEventType.CHANGEFEATURE,t))}hasFeature(e){var t=e.getId();return void 0!==t?t in this.idIndex_:getUid(e)in this.uidIndex_}isEmpty(){return this.featuresRtree_.isEmpty()&&isEmpty(this.nullGeometryFeatures_)}loadFeatures(e,r,s){const n=this.loadedExtentsRtree_;var i=this.strategy_(e,r);this.loading=!1;for(let e=0,t=i.length;e<t;++e){const o=i[e];n.forEachInExtent(o,function(e){return containsExtent(e.extent,o)})||(this.loader_.call(this,o,r,s),n.insert(o,{extent:o.slice()}),this.loading=this.loader_!==VOID)}}refresh(){this.clear(!0),this.loadedExtentsRtree_.clear(),super.refresh()}removeLoadedExtent(t){const e=this.loadedExtentsRtree_;let r;e.forEachInExtent(t,function(e){if(equals(e.extent,t))return r=e,!0}),r&&e.remove(r)}removeFeature(e){var t=getUid(e);t in this.nullGeometryFeatures_?delete this.nullGeometryFeatures_[t]:this.featuresRtree_&&this.featuresRtree_.remove(e),this.removeFeatureInternal(e),this.changed()}removeFeatureInternal(e){var t=getUid(e);this.featureChangeKeys_[t].forEach(unlistenByKey),delete this.featureChangeKeys_[t];const r=e.getId();void 0!==r&&delete this.idIndex_[r.toString()],delete this.uidIndex_[t],this.dispatchEvent(new VectorSourceEvent(VectorEventType.REMOVEFEATURE,e))}removeFromIdIndex_(e){let t=!1;for(const r in this.idIndex_)if(this.idIndex_[r]===e){delete this.idIndex_[r],t=!0;break}return t}setLoader(e){this.loader_=e}setUrl(e){assert(this.format_,7),this.setLoader(xhr(e,this.format_))}}export default VectorSource;export{VectorSourceEvent};