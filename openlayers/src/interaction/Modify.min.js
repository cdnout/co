import{getUid}from"../util.js";import Collection from"../Collection.js";import CollectionEventType from"../CollectionEventType.js";import Feature from"../Feature.js";import MapBrowserEventType from"../MapBrowserEventType.js";import{equals}from"../array.js";import{equals as coordinatesEqual,distance as coordinateDistance,squaredDistance as squaredCoordinateDistance,squaredDistanceToSegment,closestOnSegment}from"../coordinate.js";import Event from"../events/Event.js";import EventType from"../events/EventType.js";import{always,primaryAction,altKeyOnly,singleClick}from"../events/condition.js";import{boundingExtent,buffer,createOrUpdateFromCoordinate}from"../extent.js";import GeometryType from"../geom/GeometryType.js";import Point from"../geom/Point.js";import PointerInteraction from"./Pointer.js";import VectorLayer from"../layer/Vector.js";import VectorSource from"../source/Vector.js";import VectorEventType from"../source/VectorEventType.js";import RBush from"../structs/RBush.js";import{createEditingStyle}from"../style/Style.js";const CIRCLE_CENTER_INDEX=0,CIRCLE_CIRCUMFERENCE_INDEX=1,ModifyEventType={MODIFYSTART:"modifystart",MODIFYEND:"modifyend"};class ModifyEvent extends Event{constructor(e,t,r){super(e),this.features=t,this.mapBrowserEvent=r}}class Modify extends PointerInteraction{constructor(e){super(e),this.boundHandleFeatureChange_=this.handleFeatureChange_.bind(this),this.condition_=e.condition||primaryAction,this.defaultDeleteCondition_=function(e){return altKeyOnly(e)&&singleClick(e)},this.deleteCondition_=e.deleteCondition||this.defaultDeleteCondition_,this.insertVertexCondition_=e.insertVertexCondition||always,this.vertexFeature_=null,this.vertexSegments_=null,this.lastPixel_=[0,0],this.ignoreNextSingleClick_=!1,this.modified_=!1,this.rBush_=new RBush,this.pixelTolerance_=void 0!==e.pixelTolerance?e.pixelTolerance:10,this.snappedToVertex_=!1,this.changingFeature_=!1,this.dragSegments_=[],this.overlay_=new VectorLayer({source:new VectorSource({useSpatialIndex:!1,wrapX:!!e.wrapX}),style:e.style||getDefaultStyleFunction(),updateWhileAnimating:!0,updateWhileInteracting:!0}),this.SEGMENT_WRITERS_={Point:this.writePointGeometry_,LineString:this.writeLineStringGeometry_,LinearRing:this.writeLineStringGeometry_,Polygon:this.writePolygonGeometry_,MultiPoint:this.writeMultiPointGeometry_,MultiLineString:this.writeMultiLineStringGeometry_,MultiPolygon:this.writeMultiPolygonGeometry_,Circle:this.writeCircleGeometry_,GeometryCollection:this.writeGeometryCollectionGeometry_},this.source_=null;let t;if(e.source?(this.source_=e.source,t=new Collection(this.source_.getFeatures()),this.source_.addEventListener(VectorEventType.ADDFEATURE,this.handleSourceAdd_.bind(this)),this.source_.addEventListener(VectorEventType.REMOVEFEATURE,this.handleSourceRemove_.bind(this))):t=e.features,!t)throw new Error("The modify interaction requires features or a source");this.features_=t,this.features_.forEach(this.addFeature_.bind(this)),this.features_.addEventListener(CollectionEventType.ADD,this.handleFeatureAdd_.bind(this)),this.features_.addEventListener(CollectionEventType.REMOVE,this.handleFeatureRemove_.bind(this)),this.lastPointerEvent_=null}addFeature_(e){const t=e.getGeometry(),r=(t&&t.getType()in this.SEGMENT_WRITERS_&&this.SEGMENT_WRITERS_[t.getType()].call(this,e,t),this.getMap());r&&r.isRendered()&&this.getActive()&&this.handlePointerAtPixel_(this.lastPixel_,r),e.addEventListener(EventType.CHANGE,this.boundHandleFeatureChange_)}willModifyFeatures_(e){this.modified_||(this.modified_=!0,this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYSTART,this.features_,e)))}removeFeature_(e){this.removeFeatureSegmentData_(e),this.vertexFeature_&&0===this.features_.getLength()&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null),e.removeEventListener(EventType.CHANGE,this.boundHandleFeatureChange_)}removeFeatureSegmentData_(t){const r=this.rBush_,i=[];r.forEach(function(e){t===e.feature&&i.push(e)});for(let e=i.length-1;0<=e;--e){var n=i[e];for(let e=this.dragSegments_.length-1;0<=e;--e)this.dragSegments_[e][0]===n&&this.dragSegments_.splice(e,1);r.remove(n)}}setActive(e){this.vertexFeature_&&!e&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null),super.setActive(e)}setMap(e){this.overlay_.setMap(e),super.setMap(e)}getOverlay(){return this.overlay_}handleSourceAdd_(e){e.feature&&this.features_.push(e.feature)}handleSourceRemove_(e){e.feature&&this.features_.remove(e.feature)}handleFeatureAdd_(e){this.addFeature_(e.element)}handleFeatureChange_(e){this.changingFeature_||(e=e.target,this.removeFeature_(e),this.addFeature_(e))}handleFeatureRemove_(e){e=e.element;this.removeFeature_(e)}writePointGeometry_(e,t){var r=t.getCoordinates(),e={feature:e,geometry:t,segment:[r,r]};this.rBush_.insert(t.getExtent(),e)}writeMultiPointGeometry_(r,i){var n=i.getCoordinates();for(let e=0,t=n.length;e<t;++e){var s=n[e],s={feature:r,geometry:i,depth:[e],index:e,segment:[s,s]};this.rBush_.insert(i.getExtent(),s)}}writeLineStringGeometry_(r,i){const n=i.getCoordinates();for(let e=0,t=n.length-1;e<t;++e){var s=n.slice(e,e+2),o={feature:r,geometry:i,index:e,segment:s};this.rBush_.insert(boundingExtent(s),o)}}writeMultiLineStringGeometry_(i,n){var t=n.getCoordinates();for(let r=0,e=t.length;r<e;++r){const a=t[r];for(let e=0,t=a.length-1;e<t;++e){var s=a.slice(e,e+2),o={feature:i,geometry:n,depth:[r],index:e,segment:s};this.rBush_.insert(boundingExtent(s),o)}}}writePolygonGeometry_(i,n){var t=n.getCoordinates();for(let r=0,e=t.length;r<e;++r){const a=t[r];for(let e=0,t=a.length-1;e<t;++e){var s=a.slice(e,e+2),o={feature:i,geometry:n,depth:[r],index:e,segment:s};this.rBush_.insert(boundingExtent(s),o)}}}writeMultiPolygonGeometry_(n,s){var t=s.getCoordinates();for(let i=0,e=t.length;i<e;++i){var o=t[i];for(let r=0,e=o.length;r<e;++r){const d=o[r];for(let e=0,t=d.length-1;e<t;++e){var a=d.slice(e,e+2),h={feature:n,geometry:s,depth:[r,i],index:e,segment:a};this.rBush_.insert(boundingExtent(a),h)}}}}writeCircleGeometry_(e,t){var r=t.getCenter();const i={feature:e,geometry:t,index:CIRCLE_CENTER_INDEX,segment:[r,r]},n={feature:e,geometry:t,index:CIRCLE_CIRCUMFERENCE_INDEX,segment:[r,r]};e=[i,n];i.featureSegments=n.featureSegments=e,this.rBush_.insert(createOrUpdateFromCoordinate(r),i),this.rBush_.insert(t.getExtent(),n)}writeGeometryCollectionGeometry_(t,e){const r=e.getGeometriesArray();for(let e=0;e<r.length;++e)this.SEGMENT_WRITERS_[r[e].getType()].call(this,t,r[e])}createOrUpdateVertexFeature_(e){let t=this.vertexFeature_;if(t){const r=t.getGeometry();r.setCoordinates(e)}else t=new Feature(new Point(e)),this.vertexFeature_=t,this.overlay_.getSource().addFeature(t);return t}handleEvent(e){if(!e.pointerEvent)return!0;let t;return(this.lastPointerEvent_=e).map.getView().getInteracting()||e.type!=MapBrowserEventType.POINTERMOVE||this.handlingDownUpSequence||this.handlePointerMove_(e),this.vertexFeature_&&this.deleteCondition_(e)&&(t=!(e.type!=MapBrowserEventType.SINGLECLICK||!this.ignoreNextSingleClick_)||this.removePoint()),e.type==MapBrowserEventType.SINGLECLICK&&(this.ignoreNextSingleClick_=!1),super.handleEvent(e)&&!t}handleDragEvent(e){this.ignoreNextSingleClick_=!1,this.willModifyFeatures_(e);const r=e.coordinate;for(let t=0,e=this.dragSegments_.length;t<e;++t){var i=this.dragSegments_[t],n=i[0],s=n.depth;const a=n.geometry;let e;const h=n.segment;for(var o=i[1];r.length<a.getStride();)r.push(h[o][r.length]);switch(a.getType()){case GeometryType.POINT:e=r,h[0]=h[1]=r;break;case GeometryType.MULTI_POINT:(e=a.getCoordinates())[n.index]=r,h[0]=h[1]=r;break;case GeometryType.LINE_STRING:(e=a.getCoordinates())[n.index+o]=r,h[o]=r;break;case GeometryType.MULTI_LINE_STRING:case GeometryType.POLYGON:(e=a.getCoordinates())[s[0]][n.index+o]=r,h[o]=r;break;case GeometryType.MULTI_POLYGON:(e=a.getCoordinates())[s[1]][s[0]][n.index+o]=r,h[o]=r;break;case GeometryType.CIRCLE:h[0]=h[1]=r,n.index===CIRCLE_CENTER_INDEX?(this.changingFeature_=!0,a.setCenter(r)):(this.changingFeature_=!0,a.setRadius(coordinateDistance(a.getCenter(),r))),this.changingFeature_=!1}e&&this.setGeometryCoordinates_(a,e)}this.createOrUpdateVertexFeature_(r)}handleDownEvent(r){if(!this.condition_(r))return!1;this.handlePointerAtPixel_(r.pixel,r.map);var i=r.map.getCoordinateFromPixel(r.pixel);this.dragSegments_.length=0,this.modified_=!1;const e=this.vertexFeature_;if(e){const a=[],h=e.getGeometry();var n=h.getCoordinates(),t=boundingExtent([n]);const d=this.rBush_.getInExtent(t),g={};d.sort(compareIndexes);for(let t=0,e=d.length;t<e;++t){const l=d[t];var s,o=l.segment;let e=getUid(l.feature);const u=l.depth;u&&(e+="-"+u.join("-")),g[e]||(g[e]=new Array(2)),l.geometry.getType()===GeometryType.CIRCLE&&l.index===CIRCLE_CIRCUMFERENCE_INDEX?(s=closestOnSegmentData(i,l),coordinatesEqual(s,n)&&!g[e][0]&&(this.dragSegments_.push([l,0]),g[e][0]=l)):coordinatesEqual(o[0],n)&&!g[e][0]?(this.dragSegments_.push([l,0]),g[e][0]=l):coordinatesEqual(o[1],n)&&!g[e][1]?(l.geometry.getType()===GeometryType.LINE_STRING||l.geometry.getType()===GeometryType.MULTI_LINE_STRING)&&g[e][0]&&0===g[e][0].index||(this.dragSegments_.push([l,1]),g[e][1]=l):getUid(o)in this.vertexSegments_&&!g[e][0]&&!g[e][1]&&this.insertVertexCondition_(r)&&a.push([l,n])}a.length&&this.willModifyFeatures_(r);for(let e=a.length-1;0<=e;--e)this.insertVertex_.apply(this,a[e])}return!!this.vertexFeature_}handleUpEvent(e){for(let e=this.dragSegments_.length-1;0<=e;--e){var t=this.dragSegments_[e][0];const i=t.geometry;if(i.getType()===GeometryType.CIRCLE){var r=i.getCenter();const n=t.featureSegments[0],s=t.featureSegments[1];n.segment[0]=n.segment[1]=r,s.segment[0]=s.segment[1]=r,this.rBush_.update(createOrUpdateFromCoordinate(r),n),this.rBush_.update(i.getExtent(),s)}else this.rBush_.update(boundingExtent(t.segment),t)}return this.modified_&&(this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYEND,this.features_,e)),this.modified_=!1),!1}handlePointerMove_(e){this.lastPixel_=e.pixel,this.handlePointerAtPixel_(e.pixel,e.map)}handlePointerAtPixel_(t,r){const i=r.getCoordinateFromPixel(t);var n=buffer(createOrUpdateFromCoordinate(i),r.getView().getResolution()*this.pixelTolerance_);const e=this.rBush_,s=e.getInExtent(n);if(0<s.length){s.sort(function(e,t){return pointDistanceToSegmentDataSquared(i,e)-pointDistanceToSegmentDataSquared(i,t)});const h=s[0];var o=h.segment;let e=closestOnSegmentData(i,h);n=r.getPixelFromCoordinate(e);if(coordinateDistance(t,n)<=this.pixelTolerance_){const d={};if(h.geometry.getType()===GeometryType.CIRCLE&&h.index===CIRCLE_CIRCUMFERENCE_INDEX)this.snappedToVertex_=!0,this.createOrUpdateVertexFeature_(e);else{t=r.getPixelFromCoordinate(o[0]),r=r.getPixelFromCoordinate(o[1]),t=squaredCoordinateDistance(n,t),n=squaredCoordinateDistance(n,r),r=Math.sqrt(Math.min(t,n));this.snappedToVertex_=r<=this.pixelTolerance_,this.snappedToVertex_&&(e=n<t?o[1]:o[0]),this.createOrUpdateVertexFeature_(e);for(let e=1,t=s.length;e<t;++e){var a=s[e].segment;if(!(coordinatesEqual(o[0],a[0])&&coordinatesEqual(o[1],a[1])||coordinatesEqual(o[0],a[1])&&coordinatesEqual(o[1],a[0])))break;d[getUid(a)]=!0}}return d[getUid(o)]=!0,void(this.vertexSegments_=d)}}this.vertexFeature_&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null)}insertVertex_(e,t){var r=e.segment,i=e.feature;const n=e.geometry;var s=e.depth,o=e.index;let a;for(;t.length<n.getStride();)t.push(0);switch(n.getType()){case GeometryType.MULTI_LINE_STRING:case GeometryType.POLYGON:(a=n.getCoordinates())[s[0]].splice(o+1,0,t);break;case GeometryType.MULTI_POLYGON:(a=n.getCoordinates())[s[1]][s[0]].splice(o+1,0,t);break;case GeometryType.LINE_STRING:(a=n.getCoordinates()).splice(o+1,0,t);break;default:return}this.setGeometryCoordinates_(n,a);const h=this.rBush_;h.remove(e),this.updateSegmentIndices_(n,o,s,1);e={segment:[r[0],t],feature:i,geometry:n,depth:s,index:o},h.insert(boundingExtent(e.segment),e),this.dragSegments_.push([e,1]),e={segment:[t,r[1]],feature:i,geometry:n,depth:s,index:o+1};h.insert(boundingExtent(e.segment),e),this.dragSegments_.push([e,0]),this.ignoreNextSingleClick_=!0}removePoint(){var e,t;return!(!this.lastPointerEvent_||this.lastPointerEvent_.type==MapBrowserEventType.POINTERDRAG)&&(e=this.lastPointerEvent_,this.willModifyFeatures_(e),t=this.removeVertex_(),this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYEND,this.features_,e)),this.modified_=!1,t)}removeVertex_(){const e=this.dragSegments_,t={};let r=!1,i,n,s,o,a,h,d,g,l,u,m;for(a=e.length-1;0<=a;--a)s=e[a],u=s[0],m=getUid(u.feature),u.depth&&(m+="-"+u.depth.join("-")),m in t||(t[m]={}),0===s[1]?(t[m].right=u,t[m].index=u.index):1==s[1]&&(t[m].left=u,t[m].index=u.index+1);for(m in t){switch(l=t[m].right,d=t[m].left,h=t[m].index,g=h-1,u=void 0!==d?d:l,g<0&&(g=0),o=u.geometry,n=o.getCoordinates(),i=n,r=!1,o.getType()){case GeometryType.MULTI_LINE_STRING:2<n[u.depth[0]].length&&(n[u.depth[0]].splice(h,1),r=!0);break;case GeometryType.LINE_STRING:2<n.length&&(n.splice(h,1),r=!0);break;case GeometryType.MULTI_POLYGON:i=i[u.depth[1]];case GeometryType.POLYGON:4<(i=i[u.depth[0]]).length&&(h==i.length-1&&(h=0),i.splice(h,1),r=!0,0===h&&(i.pop(),i.push(i[0]),g=i.length-1))}if(r){this.setGeometryCoordinates_(o,n);const c=[];var _;void 0!==d&&(this.rBush_.remove(d),c.push(d.segment[0])),void 0!==l&&(this.rBush_.remove(l),c.push(l.segment[1])),void 0!==d&&void 0!==l&&(_={depth:u.depth,feature:u.feature,geometry:u.geometry,index:g,segment:c},this.rBush_.insert(boundingExtent(_.segment),_)),this.updateSegmentIndices_(o,h,u.depth,-1),this.vertexFeature_&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null),e.length=0}}return r}setGeometryCoordinates_(e,t){this.changingFeature_=!0,e.setCoordinates(t),this.changingFeature_=!1}updateSegmentIndices_(t,r,i,n){this.rBush_.forEachInExtent(t.getExtent(),function(e){e.geometry===t&&(void 0===i||void 0===e.depth||equals(e.depth,i))&&e.index>r&&(e.index+=n)})}}function compareIndexes(e,t){return e.index-t.index}function pointDistanceToSegmentDataSquared(e,t){const r=t.geometry;if(r.getType()===GeometryType.CIRCLE){const n=r;var i;if(t.index===CIRCLE_CIRCUMFERENCE_INDEX)return i=squaredCoordinateDistance(n.getCenter(),e),(i=Math.sqrt(i)-n.getRadius())*i}return squaredDistanceToSegment(e,t.segment)}function closestOnSegmentData(e,t){const r=t.geometry;return r.getType()===GeometryType.CIRCLE&&t.index===CIRCLE_CIRCUMFERENCE_INDEX?r.getClosestPoint(e):closestOnSegment(e,t.segment)}function getDefaultStyleFunction(){const r=createEditingStyle();return function(e,t){return r[GeometryType.POINT]}}export default Modify;export{ModifyEvent};