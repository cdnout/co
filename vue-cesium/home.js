/**
 * vue-cesium - https://github.com/zouyaoji/vue-cesium
 * Vue 2.x components for CesiumJS.
 *
 * @package VueCesium
 * @author zouyaoji <370681295@qq.com>
 * @version 2.2.0
 * @license MIT
 * @homepage https://zouyaoji.top/vue-cesium
 * @copyright (c) 2018-2021, zouyaoji <370681295@qq.com>
 */
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('vue')) :
	typeof define === 'function' && define.amd ? define('VueCesium', ['vue'], factory) :
	(global = global || self, global.VueCesium = factory(global.Vue));
}(this, (function (Vue) { 'use strict';

	var global = typeof self !== undefined ? self : this;

	Vue = Vue && Vue.hasOwnProperty('default') ? Vue['default'] : Vue;

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function unwrapExports (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var _global = createCommonjsModule(function (module) {
	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self
	  // eslint-disable-next-line no-new-func
	  : Function('return this')();
	if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef
	});

	var _core = createCommonjsModule(function (module) {
	var core = module.exports = { version: '2.6.10' };
	if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef
	});
	var _core_1 = _core.version;

	var _aFunction = function (it) {
	  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
	  return it;
	};

	// optional / simple context binding

	var _ctx = function (fn, that, length) {
	  _aFunction(fn);
	  if (that === undefined) return fn;
	  switch (length) {
	    case 1: return function (a) {
	      return fn.call(that, a);
	    };
	    case 2: return function (a, b) {
	      return fn.call(that, a, b);
	    };
	    case 3: return function (a, b, c) {
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function (/* ...args */) {
	    return fn.apply(that, arguments);
	  };
	};

	var _isObject = function (it) {
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

	var _anObject = function (it) {
	  if (!_isObject(it)) throw TypeError(it + ' is not an object!');
	  return it;
	};

	var _fails = function (exec) {
	  try {
	    return !!exec();
	  } catch (e) {
	    return true;
	  }
	};

	// Thank's IE8 for his funny defineProperty
	var _descriptors = !_fails(function () {
	  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
	});

	var document$1 = _global.document;
	// typeof document.createElement is 'object' in old IE
	var is = _isObject(document$1) && _isObject(document$1.createElement);
	var _domCreate = function (it) {
	  return is ? document$1.createElement(it) : {};
	};

	var _ie8DomDefine = !_descriptors && !_fails(function () {
	  return Object.defineProperty(_domCreate('div'), 'a', { get: function () { return 7; } }).a != 7;
	});

	// 7.1.1 ToPrimitive(input [, PreferredType])

	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	var _toPrimitive = function (it, S) {
	  if (!_isObject(it)) return it;
	  var fn, val;
	  if (S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
	  if (typeof (fn = it.valueOf) == 'function' && !_isObject(val = fn.call(it))) return val;
	  if (!S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
	  throw TypeError("Can't convert object to primitive value");
	};

	var dP = Object.defineProperty;

	var f = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {
	  _anObject(O);
	  P = _toPrimitive(P, true);
	  _anObject(Attributes);
	  if (_ie8DomDefine) try {
	    return dP(O, P, Attributes);
	  } catch (e) { /* empty */ }
	  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
	  if ('value' in Attributes) O[P] = Attributes.value;
	  return O;
	};

	var _objectDp = {
		f: f
	};

	var _propertyDesc = function (bitmap, value) {
	  return {
	    enumerable: !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable: !(bitmap & 4),
	    value: value
	  };
	};

	var _hide = _descriptors ? function (object, key, value) {
	  return _objectDp.f(object, key, _propertyDesc(1, value));
	} : function (object, key, value) {
	  object[key] = value;
	  return object;
	};

	var hasOwnProperty = {}.hasOwnProperty;
	var _has = function (it, key) {
	  return hasOwnProperty.call(it, key);
	};

	var PROTOTYPE = 'prototype';

	var $export = function (type, name, source) {
	  var IS_FORCED = type & $export.F;
	  var IS_GLOBAL = type & $export.G;
	  var IS_STATIC = type & $export.S;
	  var IS_PROTO = type & $export.P;
	  var IS_BIND = type & $export.B;
	  var IS_WRAP = type & $export.W;
	  var exports = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});
	  var expProto = exports[PROTOTYPE];
	  var target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] : (_global[name] || {})[PROTOTYPE];
	  var key, own, out;
	  if (IS_GLOBAL) source = name;
	  for (key in source) {
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    if (own && _has(exports, key)) continue;
	    // export native or passed
	    out = own ? target[key] : source[key];
	    // prevent global pollution for namespaces
	    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
	    // bind timers to global for call from export context
	    : IS_BIND && own ? _ctx(out, _global)
	    // wrap global constructors for prevent change them in library
	    : IS_WRAP && target[key] == out ? (function (C) {
	      var F = function (a, b, c) {
	        if (this instanceof C) {
	          switch (arguments.length) {
	            case 0: return new C();
	            case 1: return new C(a);
	            case 2: return new C(a, b);
	          } return new C(a, b, c);
	        } return C.apply(this, arguments);
	      };
	      F[PROTOTYPE] = C[PROTOTYPE];
	      return F;
	    // make static versions for prototype methods
	    })(out) : IS_PROTO && typeof out == 'function' ? _ctx(Function.call, out) : out;
	    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
	    if (IS_PROTO) {
	      (exports.virtual || (exports.virtual = {}))[key] = out;
	      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
	      if (type & $export.R && expProto && !expProto[key]) _hide(expProto, key, out);
	    }
	  }
	};
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library`
	var _export = $export;

	// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
	_export(_export.S + _export.F * !_descriptors, 'Object', { defineProperty: _objectDp.f });

	var $Object = _core.Object;
	var defineProperty = function defineProperty(it, key, desc) {
	  return $Object.defineProperty(it, key, desc);
	};

	var defineProperty$1 = defineProperty;

	var toString = {}.toString;

	var _cof = function (it) {
	  return toString.call(it).slice(8, -1);
	};

	// fallback for non-array-like ES3 and non-enumerable old V8 strings

	// eslint-disable-next-line no-prototype-builtins
	var _iobject = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
	  return _cof(it) == 'String' ? it.split('') : Object(it);
	};

	// 7.2.1 RequireObjectCoercible(argument)
	var _defined = function (it) {
	  if (it == undefined) throw TypeError("Can't call method on  " + it);
	  return it;
	};

	// to indexed object, toObject with fallback for non-array-like ES3 strings


	var _toIobject = function (it) {
	  return _iobject(_defined(it));
	};

	// 7.1.4 ToInteger
	var ceil = Math.ceil;
	var floor = Math.floor;
	var _toInteger = function (it) {
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

	// 7.1.15 ToLength

	var min = Math.min;
	var _toLength = function (it) {
	  return it > 0 ? min(_toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};

	var max = Math.max;
	var min$1 = Math.min;
	var _toAbsoluteIndex = function (index, length) {
	  index = _toInteger(index);
	  return index < 0 ? max(index + length, 0) : min$1(index, length);
	};

	// false -> Array#indexOf
	// true  -> Array#includes



	var _arrayIncludes = function (IS_INCLUDES) {
	  return function ($this, el, fromIndex) {
	    var O = _toIobject($this);
	    var length = _toLength(O.length);
	    var index = _toAbsoluteIndex(fromIndex, length);
	    var value;
	    // Array#includes uses SameValueZero equality algorithm
	    // eslint-disable-next-line no-self-compare
	    if (IS_INCLUDES && el != el) while (length > index) {
	      value = O[index++];
	      // eslint-disable-next-line no-self-compare
	      if (value != value) return true;
	    // Array#indexOf ignores holes, Array#includes - not
	    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
	      if (O[index] === el) return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

	var _library = true;

	var _shared = createCommonjsModule(function (module) {
	var SHARED = '__core-js_shared__';
	var store = _global[SHARED] || (_global[SHARED] = {});

	(module.exports = function (key, value) {
	  return store[key] || (store[key] = value !== undefined ? value : {});
	})('versions', []).push({
	  version: _core.version,
	  mode:  'pure' ,
	  copyright: '© 2019 Denis Pushkarev (zloirock.ru)'
	});
	});

	var id = 0;
	var px = Math.random();
	var _uid = function (key) {
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

	var shared = _shared('keys');

	var _sharedKey = function (key) {
	  return shared[key] || (shared[key] = _uid(key));
	};

	var arrayIndexOf = _arrayIncludes(false);
	var IE_PROTO = _sharedKey('IE_PROTO');

	var _objectKeysInternal = function (object, names) {
	  var O = _toIobject(object);
	  var i = 0;
	  var result = [];
	  var key;
	  for (key in O) if (key != IE_PROTO) _has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while (names.length > i) if (_has(O, key = names[i++])) {
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};

	// IE 8- don't enum bug keys
	var _enumBugKeys = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)



	var _objectKeys = Object.keys || function keys(O) {
	  return _objectKeysInternal(O, _enumBugKeys);
	};

	var _objectDps = _descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
	  _anObject(O);
	  var keys = _objectKeys(Properties);
	  var length = keys.length;
	  var i = 0;
	  var P;
	  while (length > i) _objectDp.f(O, P = keys[i++], Properties[P]);
	  return O;
	};

	// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
	_export(_export.S + _export.F * !_descriptors, 'Object', { defineProperties: _objectDps });

	var $Object$1 = _core.Object;
	var defineProperties = function defineProperties(T, D) {
	  return $Object$1.defineProperties(T, D);
	};

	var defineProperties$1 = defineProperties;

	// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)

	var hiddenKeys = _enumBugKeys.concat('length', 'prototype');

	var f$1 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
	  return _objectKeysInternal(O, hiddenKeys);
	};

	var _objectGopn = {
		f: f$1
	};

	var f$2 = Object.getOwnPropertySymbols;

	var _objectGops = {
		f: f$2
	};

	// all object keys, includes non-enumerable and symbols



	var Reflect = _global.Reflect;
	var _ownKeys = Reflect && Reflect.ownKeys || function ownKeys(it) {
	  var keys = _objectGopn.f(_anObject(it));
	  var getSymbols = _objectGops.f;
	  return getSymbols ? keys.concat(getSymbols(it)) : keys;
	};

	var f$3 = {}.propertyIsEnumerable;

	var _objectPie = {
		f: f$3
	};

	var gOPD = Object.getOwnPropertyDescriptor;

	var f$4 = _descriptors ? gOPD : function getOwnPropertyDescriptor(O, P) {
	  O = _toIobject(O);
	  P = _toPrimitive(P, true);
	  if (_ie8DomDefine) try {
	    return gOPD(O, P);
	  } catch (e) { /* empty */ }
	  if (_has(O, P)) return _propertyDesc(!_objectPie.f.call(O, P), O[P]);
	};

	var _objectGopd = {
		f: f$4
	};

	var _createProperty = function (object, index, value) {
	  if (index in object) _objectDp.f(object, index, _propertyDesc(0, value));
	  else object[index] = value;
	};

	// https://github.com/tc39/proposal-object-getownpropertydescriptors






	_export(_export.S, 'Object', {
	  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
	    var O = _toIobject(object);
	    var getDesc = _objectGopd.f;
	    var keys = _ownKeys(O);
	    var result = {};
	    var i = 0;
	    var key, desc;
	    while (keys.length > i) {
	      desc = getDesc(O, key = keys[i++]);
	      if (desc !== undefined) _createProperty(result, key, desc);
	    }
	    return result;
	  }
	});

	var getOwnPropertyDescriptors = _core.Object.getOwnPropertyDescriptors;

	var getOwnPropertyDescriptors$1 = getOwnPropertyDescriptors;

	// most Object methods by ES6 should accept primitives



	var _objectSap = function (KEY, exec) {
	  var fn = (_core.Object || {})[KEY] || Object[KEY];
	  var exp = {};
	  exp[KEY] = exec(fn);
	  _export(_export.S + _export.F * _fails(function () { fn(1); }), 'Object', exp);
	};

	// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)

	var $getOwnPropertyDescriptor = _objectGopd.f;

	_objectSap('getOwnPropertyDescriptor', function () {
	  return function getOwnPropertyDescriptor(it, key) {
	    return $getOwnPropertyDescriptor(_toIobject(it), key);
	  };
	});

	var $Object$2 = _core.Object;
	var getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
	  return $Object$2.getOwnPropertyDescriptor(it, key);
	};

	var getOwnPropertyDescriptor$1 = getOwnPropertyDescriptor;

	var _redefine = _hide;

	var _meta = createCommonjsModule(function (module) {
	var META = _uid('meta');


	var setDesc = _objectDp.f;
	var id = 0;
	var isExtensible = Object.isExtensible || function () {
	  return true;
	};
	var FREEZE = !_fails(function () {
	  return isExtensible(Object.preventExtensions({}));
	});
	var setMeta = function (it) {
	  setDesc(it, META, { value: {
	    i: 'O' + ++id, // object ID
	    w: {}          // weak collections IDs
	  } });
	};
	var fastKey = function (it, create) {
	  // return primitive with prefix
	  if (!_isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if (!_has(it, META)) {
	    // can't set metadata to uncaught frozen object
	    if (!isExtensible(it)) return 'F';
	    // not necessary to add metadata
	    if (!create) return 'E';
	    // add missing metadata
	    setMeta(it);
	  // return object ID
	  } return it[META].i;
	};
	var getWeak = function (it, create) {
	  if (!_has(it, META)) {
	    // can't set metadata to uncaught frozen object
	    if (!isExtensible(it)) return true;
	    // not necessary to add metadata
	    if (!create) return false;
	    // add missing metadata
	    setMeta(it);
	  // return hash weak collections IDs
	  } return it[META].w;
	};
	// add metadata on freeze-family methods calling
	var onFreeze = function (it) {
	  if (FREEZE && meta.NEED && isExtensible(it) && !_has(it, META)) setMeta(it);
	  return it;
	};
	var meta = module.exports = {
	  KEY: META,
	  NEED: false,
	  fastKey: fastKey,
	  getWeak: getWeak,
	  onFreeze: onFreeze
	};
	});
	var _meta_1 = _meta.KEY;
	var _meta_2 = _meta.NEED;
	var _meta_3 = _meta.fastKey;
	var _meta_4 = _meta.getWeak;
	var _meta_5 = _meta.onFreeze;

	var _wks = createCommonjsModule(function (module) {
	var store = _shared('wks');

	var Symbol = _global.Symbol;
	var USE_SYMBOL = typeof Symbol == 'function';

	var $exports = module.exports = function (name) {
	  return store[name] || (store[name] =
	    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : _uid)('Symbol.' + name));
	};

	$exports.store = store;
	});

	var def = _objectDp.f;

	var TAG = _wks('toStringTag');

	var _setToStringTag = function (it, tag, stat) {
	  if (it && !_has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
	};

	var f$5 = _wks;

	var _wksExt = {
		f: f$5
	};

	var defineProperty$2 = _objectDp.f;
	var _wksDefine = function (name) {
	  var $Symbol = _core.Symbol || (_core.Symbol =  {} );
	  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty$2($Symbol, name, { value: _wksExt.f(name) });
	};

	// all enumerable object keys, includes symbols



	var _enumKeys = function (it) {
	  var result = _objectKeys(it);
	  var getSymbols = _objectGops.f;
	  if (getSymbols) {
	    var symbols = getSymbols(it);
	    var isEnum = _objectPie.f;
	    var i = 0;
	    var key;
	    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
	  } return result;
	};

	// 7.2.2 IsArray(argument)

	var _isArray = Array.isArray || function isArray(arg) {
	  return _cof(arg) == 'Array';
	};

	// 7.1.13 ToObject(argument)

	var _toObject = function (it) {
	  return Object(_defined(it));
	};

	var document$2 = _global.document;
	var _html = document$2 && document$2.documentElement;

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])



	var IE_PROTO$1 = _sharedKey('IE_PROTO');
	var Empty = function () { /* empty */ };
	var PROTOTYPE$1 = 'prototype';

	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var createDict = function () {
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = _domCreate('iframe');
	  var i = _enumBugKeys.length;
	  var lt = '<';
	  var gt = '>';
	  var iframeDocument;
	  iframe.style.display = 'none';
	  _html.appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
	  iframeDocument.close();
	  createDict = iframeDocument.F;
	  while (i--) delete createDict[PROTOTYPE$1][_enumBugKeys[i]];
	  return createDict();
	};

	var _objectCreate = Object.create || function create(O, Properties) {
	  var result;
	  if (O !== null) {
	    Empty[PROTOTYPE$1] = _anObject(O);
	    result = new Empty();
	    Empty[PROTOTYPE$1] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO$1] = O;
	  } else result = createDict();
	  return Properties === undefined ? result : _objectDps(result, Properties);
	};

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window

	var gOPN = _objectGopn.f;
	var toString$1 = {}.toString;

	var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];

	var getWindowNames = function (it) {
	  try {
	    return gOPN(it);
	  } catch (e) {
	    return windowNames.slice();
	  }
	};

	var f$6 = function getOwnPropertyNames(it) {
	  return windowNames && toString$1.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(_toIobject(it));
	};

	var _objectGopnExt = {
		f: f$6
	};

	// ECMAScript 6 symbols shim





	var META = _meta.KEY;





















	var gOPD$1 = _objectGopd.f;
	var dP$1 = _objectDp.f;
	var gOPN$1 = _objectGopnExt.f;
	var $Symbol = _global.Symbol;
	var $JSON = _global.JSON;
	var _stringify = $JSON && $JSON.stringify;
	var PROTOTYPE$2 = 'prototype';
	var HIDDEN = _wks('_hidden');
	var TO_PRIMITIVE = _wks('toPrimitive');
	var isEnum = {}.propertyIsEnumerable;
	var SymbolRegistry = _shared('symbol-registry');
	var AllSymbols = _shared('symbols');
	var OPSymbols = _shared('op-symbols');
	var ObjectProto = Object[PROTOTYPE$2];
	var USE_NATIVE = typeof $Symbol == 'function' && !!_objectGops.f;
	var QObject = _global.QObject;
	// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
	var setter = !QObject || !QObject[PROTOTYPE$2] || !QObject[PROTOTYPE$2].findChild;

	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDesc = _descriptors && _fails(function () {
	  return _objectCreate(dP$1({}, 'a', {
	    get: function () { return dP$1(this, 'a', { value: 7 }).a; }
	  })).a != 7;
	}) ? function (it, key, D) {
	  var protoDesc = gOPD$1(ObjectProto, key);
	  if (protoDesc) delete ObjectProto[key];
	  dP$1(it, key, D);
	  if (protoDesc && it !== ObjectProto) dP$1(ObjectProto, key, protoDesc);
	} : dP$1;

	var wrap = function (tag) {
	  var sym = AllSymbols[tag] = _objectCreate($Symbol[PROTOTYPE$2]);
	  sym._k = tag;
	  return sym;
	};

	var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
	  return typeof it == 'symbol';
	} : function (it) {
	  return it instanceof $Symbol;
	};

	var $defineProperty = function defineProperty(it, key, D) {
	  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
	  _anObject(it);
	  key = _toPrimitive(key, true);
	  _anObject(D);
	  if (_has(AllSymbols, key)) {
	    if (!D.enumerable) {
	      if (!_has(it, HIDDEN)) dP$1(it, HIDDEN, _propertyDesc(1, {}));
	      it[HIDDEN][key] = true;
	    } else {
	      if (_has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
	      D = _objectCreate(D, { enumerable: _propertyDesc(0, false) });
	    } return setSymbolDesc(it, key, D);
	  } return dP$1(it, key, D);
	};
	var $defineProperties = function defineProperties(it, P) {
	  _anObject(it);
	  var keys = _enumKeys(P = _toIobject(P));
	  var i = 0;
	  var l = keys.length;
	  var key;
	  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
	  return it;
	};
	var $create = function create(it, P) {
	  return P === undefined ? _objectCreate(it) : $defineProperties(_objectCreate(it), P);
	};
	var $propertyIsEnumerable = function propertyIsEnumerable(key) {
	  var E = isEnum.call(this, key = _toPrimitive(key, true));
	  if (this === ObjectProto && _has(AllSymbols, key) && !_has(OPSymbols, key)) return false;
	  return E || !_has(this, key) || !_has(AllSymbols, key) || _has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
	};
	var $getOwnPropertyDescriptor$1 = function getOwnPropertyDescriptor(it, key) {
	  it = _toIobject(it);
	  key = _toPrimitive(key, true);
	  if (it === ObjectProto && _has(AllSymbols, key) && !_has(OPSymbols, key)) return;
	  var D = gOPD$1(it, key);
	  if (D && _has(AllSymbols, key) && !(_has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
	  return D;
	};
	var $getOwnPropertyNames = function getOwnPropertyNames(it) {
	  var names = gOPN$1(_toIobject(it));
	  var result = [];
	  var i = 0;
	  var key;
	  while (names.length > i) {
	    if (!_has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
	  } return result;
	};
	var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
	  var IS_OP = it === ObjectProto;
	  var names = gOPN$1(IS_OP ? OPSymbols : _toIobject(it));
	  var result = [];
	  var i = 0;
	  var key;
	  while (names.length > i) {
	    if (_has(AllSymbols, key = names[i++]) && (IS_OP ? _has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
	  } return result;
	};

	// 19.4.1.1 Symbol([description])
	if (!USE_NATIVE) {
	  $Symbol = function Symbol() {
	    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
	    var tag = _uid(arguments.length > 0 ? arguments[0] : undefined);
	    var $set = function (value) {
	      if (this === ObjectProto) $set.call(OPSymbols, value);
	      if (_has(this, HIDDEN) && _has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
	      setSymbolDesc(this, tag, _propertyDesc(1, value));
	    };
	    if (_descriptors && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
	    return wrap(tag);
	  };
	  _redefine($Symbol[PROTOTYPE$2], 'toString', function toString() {
	    return this._k;
	  });

	  _objectGopd.f = $getOwnPropertyDescriptor$1;
	  _objectDp.f = $defineProperty;
	  _objectGopn.f = _objectGopnExt.f = $getOwnPropertyNames;
	  _objectPie.f = $propertyIsEnumerable;
	  _objectGops.f = $getOwnPropertySymbols;

	  if (_descriptors && !_library) {
	    _redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
	  }

	  _wksExt.f = function (name) {
	    return wrap(_wks(name));
	  };
	}

	_export(_export.G + _export.W + _export.F * !USE_NATIVE, { Symbol: $Symbol });

	for (var es6Symbols = (
	  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
	  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
	).split(','), j = 0; es6Symbols.length > j;)_wks(es6Symbols[j++]);

	for (var wellKnownSymbols = _objectKeys(_wks.store), k = 0; wellKnownSymbols.length > k;) _wksDefine(wellKnownSymbols[k++]);

	_export(_export.S + _export.F * !USE_NATIVE, 'Symbol', {
	  // 19.4.2.1 Symbol.for(key)
	  'for': function (key) {
	    return _has(SymbolRegistry, key += '')
	      ? SymbolRegistry[key]
	      : SymbolRegistry[key] = $Symbol(key);
	  },
	  // 19.4.2.5 Symbol.keyFor(sym)
	  keyFor: function keyFor(sym) {
	    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
	    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
	  },
	  useSetter: function () { setter = true; },
	  useSimple: function () { setter = false; }
	});

	_export(_export.S + _export.F * !USE_NATIVE, 'Object', {
	  // 19.1.2.2 Object.create(O [, Properties])
	  create: $create,
	  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
	  defineProperty: $defineProperty,
	  // 19.1.2.3 Object.defineProperties(O, Properties)
	  defineProperties: $defineProperties,
	  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor$1,
	  // 19.1.2.7 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // 19.1.2.8 Object.getOwnPropertySymbols(O)
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});

	// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
	// https://bugs.chromium.org/p/v8/issues/detail?id=3443
	var FAILS_ON_PRIMITIVES = _fails(function () { _objectGops.f(1); });

	_export(_export.S + _export.F * FAILS_ON_PRIMITIVES, 'Object', {
	  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
	    return _objectGops.f(_toObject(it));
	  }
	});

	// 24.3.2 JSON.stringify(value [, replacer [, space]])
	$JSON && _export(_export.S + _export.F * (!USE_NATIVE || _fails(function () {
	  var S = $Symbol();
	  // MS Edge converts symbol values to JSON as {}
	  // WebKit converts symbol values to JSON as null
	  // V8 throws on boxed symbols
	  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
	})), 'JSON', {
	  stringify: function stringify(it) {
	    var args = [it];
	    var i = 1;
	    var replacer, $replacer;
	    while (arguments.length > i) args.push(arguments[i++]);
	    $replacer = replacer = args[1];
	    if (!_isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
	    if (!_isArray(replacer)) replacer = function (key, value) {
	      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
	      if (!isSymbol(value)) return value;
	    };
	    args[1] = replacer;
	    return _stringify.apply($JSON, args);
	  }
	});

	// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
	$Symbol[PROTOTYPE$2][TO_PRIMITIVE] || _hide($Symbol[PROTOTYPE$2], TO_PRIMITIVE, $Symbol[PROTOTYPE$2].valueOf);
	// 19.4.3.5 Symbol.prototype[@@toStringTag]
	_setToStringTag($Symbol, 'Symbol');
	// 20.2.1.9 Math[@@toStringTag]
	_setToStringTag(Math, 'Math', true);
	// 24.3.3 JSON[@@toStringTag]
	_setToStringTag(_global.JSON, 'JSON', true);

	var getOwnPropertySymbols = _core.Object.getOwnPropertySymbols;

	var getOwnPropertySymbols$1 = getOwnPropertySymbols;

	// 19.1.2.14 Object.keys(O)



	_objectSap('keys', function () {
	  return function keys(it) {
	    return _objectKeys(_toObject(it));
	  };
	});

	var keys = _core.Object.keys;

	var keys$1 = keys;

	function _defineProperty(obj, key, value) {
	  if (key in obj) {
	    defineProperty$1(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }

	  return obj;
	}

	var _iterStep = function (done, value) {
	  return { value: value, done: !!done };
	};

	var _iterators = {};

	var IteratorPrototype = {};

	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	_hide(IteratorPrototype, _wks('iterator'), function () { return this; });

	var _iterCreate = function (Constructor, NAME, next) {
	  Constructor.prototype = _objectCreate(IteratorPrototype, { next: _propertyDesc(1, next) });
	  _setToStringTag(Constructor, NAME + ' Iterator');
	};

	// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)


	var IE_PROTO$2 = _sharedKey('IE_PROTO');
	var ObjectProto$1 = Object.prototype;

	var _objectGpo = Object.getPrototypeOf || function (O) {
	  O = _toObject(O);
	  if (_has(O, IE_PROTO$2)) return O[IE_PROTO$2];
	  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectProto$1 : null;
	};

	var ITERATOR = _wks('iterator');
	var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
	var FF_ITERATOR = '@@iterator';
	var KEYS = 'keys';
	var VALUES = 'values';

	var returnThis = function () { return this; };

	var _iterDefine = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
	  _iterCreate(Constructor, NAME, next);
	  var getMethod = function (kind) {
	    if (!BUGGY && kind in proto) return proto[kind];
	    switch (kind) {
	      case KEYS: return function keys() { return new Constructor(this, kind); };
	      case VALUES: return function values() { return new Constructor(this, kind); };
	    } return function entries() { return new Constructor(this, kind); };
	  };
	  var TAG = NAME + ' Iterator';
	  var DEF_VALUES = DEFAULT == VALUES;
	  var VALUES_BUG = false;
	  var proto = Base.prototype;
	  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
	  var $default = $native || getMethod(DEFAULT);
	  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
	  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
	  var methods, key, IteratorPrototype;
	  // Fix native
	  if ($anyNative) {
	    IteratorPrototype = _objectGpo($anyNative.call(new Base()));
	    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
	      // Set @@toStringTag to native iterators
	      _setToStringTag(IteratorPrototype, TAG, true);
	    }
	  }
	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if (DEF_VALUES && $native && $native.name !== VALUES) {
	    VALUES_BUG = true;
	    $default = function values() { return $native.call(this); };
	  }
	  // Define iterator
	  if (( FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
	    _hide(proto, ITERATOR, $default);
	  }
	  // Plug for library
	  _iterators[NAME] = $default;
	  _iterators[TAG] = returnThis;
	  if (DEFAULT) {
	    methods = {
	      values: DEF_VALUES ? $default : getMethod(VALUES),
	      keys: IS_SET ? $default : getMethod(KEYS),
	      entries: $entries
	    };
	    if (FORCED) for (key in methods) {
	      if (!(key in proto)) _redefine(proto, key, methods[key]);
	    } else _export(_export.P + _export.F * (BUGGY || VALUES_BUG), NAME, methods);
	  }
	  return methods;
	};

	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	var es6_array_iterator = _iterDefine(Array, 'Array', function (iterated, kind) {
	  this._t = _toIobject(iterated); // target
	  this._i = 0;                   // next index
	  this._k = kind;                // kind
	// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function () {
	  var O = this._t;
	  var kind = this._k;
	  var index = this._i++;
	  if (!O || index >= O.length) {
	    this._t = undefined;
	    return _iterStep(1);
	  }
	  if (kind == 'keys') return _iterStep(0, index);
	  if (kind == 'values') return _iterStep(0, O[index]);
	  return _iterStep(0, [index, O[index]]);
	}, 'values');

	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	_iterators.Arguments = _iterators.Array;

	var TO_STRING_TAG = _wks('toStringTag');

	var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
	  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
	  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
	  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
	  'TextTrackList,TouchList').split(',');

	for (var i = 0; i < DOMIterables.length; i++) {
	  var NAME = DOMIterables[i];
	  var Collection = _global[NAME];
	  var proto = Collection && Collection.prototype;
	  if (proto && !proto[TO_STRING_TAG]) _hide(proto, TO_STRING_TAG, NAME);
	  _iterators[NAME] = _iterators.Array;
	}

	// true  -> String#at
	// false -> String#codePointAt
	var _stringAt = function (TO_STRING) {
	  return function (that, pos) {
	    var s = String(_defined(that));
	    var i = _toInteger(pos);
	    var l = s.length;
	    var a, b;
	    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	      ? TO_STRING ? s.charAt(i) : a
	      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};

	var $at = _stringAt(true);

	// 21.1.3.27 String.prototype[@@iterator]()
	_iterDefine(String, 'String', function (iterated) {
	  this._t = String(iterated); // target
	  this._i = 0;                // next index
	// 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function () {
	  var O = this._t;
	  var index = this._i;
	  var point;
	  if (index >= O.length) return { value: undefined, done: true };
	  point = $at(O, index);
	  this._i += point.length;
	  return { value: point, done: false };
	});

	// getting tag from 19.1.3.6 Object.prototype.toString()

	var TAG$1 = _wks('toStringTag');
	// ES3 wrong here
	var ARG = _cof(function () { return arguments; }()) == 'Arguments';

	// fallback for IE11 Script Access Denied error
	var tryGet = function (it, key) {
	  try {
	    return it[key];
	  } catch (e) { /* empty */ }
	};

	var _classof = function (it) {
	  var O, T, B;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (T = tryGet(O = Object(it), TAG$1)) == 'string' ? T
	    // builtinTag case
	    : ARG ? _cof(O)
	    // ES3 arguments fallback
	    : (B = _cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
	};

	var ITERATOR$1 = _wks('iterator');

	var core_getIteratorMethod = _core.getIteratorMethod = function (it) {
	  if (it != undefined) return it[ITERATOR$1]
	    || it['@@iterator']
	    || _iterators[_classof(it)];
	};

	var core_getIterator = _core.getIterator = function (it) {
	  var iterFn = core_getIteratorMethod(it);
	  if (typeof iterFn != 'function') throw TypeError(it + ' is not iterable!');
	  return _anObject(iterFn.call(it));
	};

	var getIterator = core_getIterator;

	var getIterator$1 = getIterator;

	var runtime_1 = createCommonjsModule(function (module) {
	/**
	 * Copyright (c) 2014-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	var runtime = (function (exports) {

	  var Op = Object.prototype;
	  var hasOwn = Op.hasOwnProperty;
	  var undefined$1; // More compressible than void 0.
	  var $Symbol = typeof Symbol === "function" ? Symbol : {};
	  var iteratorSymbol = $Symbol.iterator || "@@iterator";
	  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
	  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

	  function wrap(innerFn, outerFn, self, tryLocsList) {
	    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
	    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
	    var generator = Object.create(protoGenerator.prototype);
	    var context = new Context(tryLocsList || []);

	    // The ._invoke method unifies the implementations of the .next,
	    // .throw, and .return methods.
	    generator._invoke = makeInvokeMethod(innerFn, self, context);

	    return generator;
	  }
	  exports.wrap = wrap;

	  // Try/catch helper to minimize deoptimizations. Returns a completion
	  // record like context.tryEntries[i].completion. This interface could
	  // have been (and was previously) designed to take a closure to be
	  // invoked without arguments, but in all the cases we care about we
	  // already have an existing method we want to call, so there's no need
	  // to create a new function object. We can even get away with assuming
	  // the method takes exactly one argument, since that happens to be true
	  // in every case, so we don't have to touch the arguments object. The
	  // only additional allocation required is the completion record, which
	  // has a stable shape and so hopefully should be cheap to allocate.
	  function tryCatch(fn, obj, arg) {
	    try {
	      return { type: "normal", arg: fn.call(obj, arg) };
	    } catch (err) {
	      return { type: "throw", arg: err };
	    }
	  }

	  var GenStateSuspendedStart = "suspendedStart";
	  var GenStateSuspendedYield = "suspendedYield";
	  var GenStateExecuting = "executing";
	  var GenStateCompleted = "completed";

	  // Returning this object from the innerFn has the same effect as
	  // breaking out of the dispatch switch statement.
	  var ContinueSentinel = {};

	  // Dummy constructor functions that we use as the .constructor and
	  // .constructor.prototype properties for functions that return Generator
	  // objects. For full spec compliance, you may wish to configure your
	  // minifier not to mangle the names of these two functions.
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}

	  // This is a polyfill for %IteratorPrototype% for environments that
	  // don't natively support it.
	  var IteratorPrototype = {};
	  IteratorPrototype[iteratorSymbol] = function () {
	    return this;
	  };

	  var getProto = Object.getPrototypeOf;
	  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
	  if (NativeIteratorPrototype &&
	      NativeIteratorPrototype !== Op &&
	      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
	    // This environment has a native %IteratorPrototype%; use it instead
	    // of the polyfill.
	    IteratorPrototype = NativeIteratorPrototype;
	  }

	  var Gp = GeneratorFunctionPrototype.prototype =
	    Generator.prototype = Object.create(IteratorPrototype);
	  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
	  GeneratorFunctionPrototype.constructor = GeneratorFunction;
	  GeneratorFunctionPrototype[toStringTagSymbol] =
	    GeneratorFunction.displayName = "GeneratorFunction";

	  // Helper for defining the .next, .throw, and .return methods of the
	  // Iterator interface in terms of a single ._invoke method.
	  function defineIteratorMethods(prototype) {
	    ["next", "throw", "return"].forEach(function(method) {
	      prototype[method] = function(arg) {
	        return this._invoke(method, arg);
	      };
	    });
	  }

	  exports.isGeneratorFunction = function(genFun) {
	    var ctor = typeof genFun === "function" && genFun.constructor;
	    return ctor
	      ? ctor === GeneratorFunction ||
	        // For the native GeneratorFunction constructor, the best we can
	        // do is to check its .name property.
	        (ctor.displayName || ctor.name) === "GeneratorFunction"
	      : false;
	  };

	  exports.mark = function(genFun) {
	    if (Object.setPrototypeOf) {
	      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
	    } else {
	      genFun.__proto__ = GeneratorFunctionPrototype;
	      if (!(toStringTagSymbol in genFun)) {
	        genFun[toStringTagSymbol] = "GeneratorFunction";
	      }
	    }
	    genFun.prototype = Object.create(Gp);
	    return genFun;
	  };

	  // Within the body of any async function, `await x` is transformed to
	  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
	  // `hasOwn.call(value, "__await")` to determine if the yielded value is
	  // meant to be awaited.
	  exports.awrap = function(arg) {
	    return { __await: arg };
	  };

	  function AsyncIterator(generator) {
	    function invoke(method, arg, resolve, reject) {
	      var record = tryCatch(generator[method], generator, arg);
	      if (record.type === "throw") {
	        reject(record.arg);
	      } else {
	        var result = record.arg;
	        var value = result.value;
	        if (value &&
	            typeof value === "object" &&
	            hasOwn.call(value, "__await")) {
	          return Promise.resolve(value.__await).then(function(value) {
	            invoke("next", value, resolve, reject);
	          }, function(err) {
	            invoke("throw", err, resolve, reject);
	          });
	        }

	        return Promise.resolve(value).then(function(unwrapped) {
	          // When a yielded Promise is resolved, its final value becomes
	          // the .value of the Promise<{value,done}> result for the
	          // current iteration.
	          result.value = unwrapped;
	          resolve(result);
	        }, function(error) {
	          // If a rejected Promise was yielded, throw the rejection back
	          // into the async generator function so it can be handled there.
	          return invoke("throw", error, resolve, reject);
	        });
	      }
	    }

	    var previousPromise;

	    function enqueue(method, arg) {
	      function callInvokeWithMethodAndArg() {
	        return new Promise(function(resolve, reject) {
	          invoke(method, arg, resolve, reject);
	        });
	      }

	      return previousPromise =
	        // If enqueue has been called before, then we want to wait until
	        // all previous Promises have been resolved before calling invoke,
	        // so that results are always delivered in the correct order. If
	        // enqueue has not been called before, then it is important to
	        // call invoke immediately, without waiting on a callback to fire,
	        // so that the async generator function has the opportunity to do
	        // any necessary setup in a predictable way. This predictability
	        // is why the Promise constructor synchronously invokes its
	        // executor callback, and why async functions synchronously
	        // execute code before the first await. Since we implement simple
	        // async functions in terms of async generators, it is especially
	        // important to get this right, even though it requires care.
	        previousPromise ? previousPromise.then(
	          callInvokeWithMethodAndArg,
	          // Avoid propagating failures to Promises returned by later
	          // invocations of the iterator.
	          callInvokeWithMethodAndArg
	        ) : callInvokeWithMethodAndArg();
	    }

	    // Define the unified helper method that is used to implement .next,
	    // .throw, and .return (see defineIteratorMethods).
	    this._invoke = enqueue;
	  }

	  defineIteratorMethods(AsyncIterator.prototype);
	  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
	    return this;
	  };
	  exports.AsyncIterator = AsyncIterator;

	  // Note that simple async functions are implemented on top of
	  // AsyncIterator objects; they just return a Promise for the value of
	  // the final result produced by the iterator.
	  exports.async = function(innerFn, outerFn, self, tryLocsList) {
	    var iter = new AsyncIterator(
	      wrap(innerFn, outerFn, self, tryLocsList)
	    );

	    return exports.isGeneratorFunction(outerFn)
	      ? iter // If outerFn is a generator, return the full iterator.
	      : iter.next().then(function(result) {
	          return result.done ? result.value : iter.next();
	        });
	  };

	  function makeInvokeMethod(innerFn, self, context) {
	    var state = GenStateSuspendedStart;

	    return function invoke(method, arg) {
	      if (state === GenStateExecuting) {
	        throw new Error("Generator is already running");
	      }

	      if (state === GenStateCompleted) {
	        if (method === "throw") {
	          throw arg;
	        }

	        // Be forgiving, per 25.3.3.3.3 of the spec:
	        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
	        return doneResult();
	      }

	      context.method = method;
	      context.arg = arg;

	      while (true) {
	        var delegate = context.delegate;
	        if (delegate) {
	          var delegateResult = maybeInvokeDelegate(delegate, context);
	          if (delegateResult) {
	            if (delegateResult === ContinueSentinel) continue;
	            return delegateResult;
	          }
	        }

	        if (context.method === "next") {
	          // Setting context._sent for legacy support of Babel's
	          // function.sent implementation.
	          context.sent = context._sent = context.arg;

	        } else if (context.method === "throw") {
	          if (state === GenStateSuspendedStart) {
	            state = GenStateCompleted;
	            throw context.arg;
	          }

	          context.dispatchException(context.arg);

	        } else if (context.method === "return") {
	          context.abrupt("return", context.arg);
	        }

	        state = GenStateExecuting;

	        var record = tryCatch(innerFn, self, context);
	        if (record.type === "normal") {
	          // If an exception is thrown from innerFn, we leave state ===
	          // GenStateExecuting and loop back for another invocation.
	          state = context.done
	            ? GenStateCompleted
	            : GenStateSuspendedYield;

	          if (record.arg === ContinueSentinel) {
	            continue;
	          }

	          return {
	            value: record.arg,
	            done: context.done
	          };

	        } else if (record.type === "throw") {
	          state = GenStateCompleted;
	          // Dispatch the exception by looping back around to the
	          // context.dispatchException(context.arg) call above.
	          context.method = "throw";
	          context.arg = record.arg;
	        }
	      }
	    };
	  }

	  // Call delegate.iterator[context.method](context.arg) and handle the
	  // result, either by returning a { value, done } result from the
	  // delegate iterator, or by modifying context.method and context.arg,
	  // setting context.delegate to null, and returning the ContinueSentinel.
	  function maybeInvokeDelegate(delegate, context) {
	    var method = delegate.iterator[context.method];
	    if (method === undefined$1) {
	      // A .throw or .return when the delegate iterator has no .throw
	      // method always terminates the yield* loop.
	      context.delegate = null;

	      if (context.method === "throw") {
	        // Note: ["return"] must be used for ES3 parsing compatibility.
	        if (delegate.iterator["return"]) {
	          // If the delegate iterator has a return method, give it a
	          // chance to clean up.
	          context.method = "return";
	          context.arg = undefined$1;
	          maybeInvokeDelegate(delegate, context);

	          if (context.method === "throw") {
	            // If maybeInvokeDelegate(context) changed context.method from
	            // "return" to "throw", let that override the TypeError below.
	            return ContinueSentinel;
	          }
	        }

	        context.method = "throw";
	        context.arg = new TypeError(
	          "The iterator does not provide a 'throw' method");
	      }

	      return ContinueSentinel;
	    }

	    var record = tryCatch(method, delegate.iterator, context.arg);

	    if (record.type === "throw") {
	      context.method = "throw";
	      context.arg = record.arg;
	      context.delegate = null;
	      return ContinueSentinel;
	    }

	    var info = record.arg;

	    if (! info) {
	      context.method = "throw";
	      context.arg = new TypeError("iterator result is not an object");
	      context.delegate = null;
	      return ContinueSentinel;
	    }

	    if (info.done) {
	      // Assign the result of the finished delegate to the temporary
	      // variable specified by delegate.resultName (see delegateYield).
	      context[delegate.resultName] = info.value;

	      // Resume execution at the desired location (see delegateYield).
	      context.next = delegate.nextLoc;

	      // If context.method was "throw" but the delegate handled the
	      // exception, let the outer generator proceed normally. If
	      // context.method was "next", forget context.arg since it has been
	      // "consumed" by the delegate iterator. If context.method was
	      // "return", allow the original .return call to continue in the
	      // outer generator.
	      if (context.method !== "return") {
	        context.method = "next";
	        context.arg = undefined$1;
	      }

	    } else {
	      // Re-yield the result returned by the delegate method.
	      return info;
	    }

	    // The delegate iterator is finished, so forget it and continue with
	    // the outer generator.
	    context.delegate = null;
	    return ContinueSentinel;
	  }

	  // Define Generator.prototype.{next,throw,return} in terms of the
	  // unified ._invoke helper method.
	  defineIteratorMethods(Gp);

	  Gp[toStringTagSymbol] = "Generator";

	  // A Generator should always return itself as the iterator object when the
	  // @@iterator function is called on it. Some browsers' implementations of the
	  // iterator prototype chain incorrectly implement this, causing the Generator
	  // object to not be returned from this call. This ensures that doesn't happen.
	  // See https://github.com/facebook/regenerator/issues/274 for more details.
	  Gp[iteratorSymbol] = function() {
	    return this;
	  };

	  Gp.toString = function() {
	    return "[object Generator]";
	  };

	  function pushTryEntry(locs) {
	    var entry = { tryLoc: locs[0] };

	    if (1 in locs) {
	      entry.catchLoc = locs[1];
	    }

	    if (2 in locs) {
	      entry.finallyLoc = locs[2];
	      entry.afterLoc = locs[3];
	    }

	    this.tryEntries.push(entry);
	  }

	  function resetTryEntry(entry) {
	    var record = entry.completion || {};
	    record.type = "normal";
	    delete record.arg;
	    entry.completion = record;
	  }

	  function Context(tryLocsList) {
	    // The root entry object (effectively a try statement without a catch
	    // or a finally block) gives us a place to store values thrown from
	    // locations where there is no enclosing try statement.
	    this.tryEntries = [{ tryLoc: "root" }];
	    tryLocsList.forEach(pushTryEntry, this);
	    this.reset(true);
	  }

	  exports.keys = function(object) {
	    var keys = [];
	    for (var key in object) {
	      keys.push(key);
	    }
	    keys.reverse();

	    // Rather than returning an object with a next method, we keep
	    // things simple and return the next function itself.
	    return function next() {
	      while (keys.length) {
	        var key = keys.pop();
	        if (key in object) {
	          next.value = key;
	          next.done = false;
	          return next;
	        }
	      }

	      // To avoid creating an additional object, we just hang the .value
	      // and .done properties off the next function object itself. This
	      // also ensures that the minifier will not anonymize the function.
	      next.done = true;
	      return next;
	    };
	  };

	  function values(iterable) {
	    if (iterable) {
	      var iteratorMethod = iterable[iteratorSymbol];
	      if (iteratorMethod) {
	        return iteratorMethod.call(iterable);
	      }

	      if (typeof iterable.next === "function") {
	        return iterable;
	      }

	      if (!isNaN(iterable.length)) {
	        var i = -1, next = function next() {
	          while (++i < iterable.length) {
	            if (hasOwn.call(iterable, i)) {
	              next.value = iterable[i];
	              next.done = false;
	              return next;
	            }
	          }

	          next.value = undefined$1;
	          next.done = true;

	          return next;
	        };

	        return next.next = next;
	      }
	    }

	    // Return an iterator with no values.
	    return { next: doneResult };
	  }
	  exports.values = values;

	  function doneResult() {
	    return { value: undefined$1, done: true };
	  }

	  Context.prototype = {
	    constructor: Context,

	    reset: function(skipTempReset) {
	      this.prev = 0;
	      this.next = 0;
	      // Resetting context._sent for legacy support of Babel's
	      // function.sent implementation.
	      this.sent = this._sent = undefined$1;
	      this.done = false;
	      this.delegate = null;

	      this.method = "next";
	      this.arg = undefined$1;

	      this.tryEntries.forEach(resetTryEntry);

	      if (!skipTempReset) {
	        for (var name in this) {
	          // Not sure about the optimal order of these conditions:
	          if (name.charAt(0) === "t" &&
	              hasOwn.call(this, name) &&
	              !isNaN(+name.slice(1))) {
	            this[name] = undefined$1;
	          }
	        }
	      }
	    },

	    stop: function() {
	      this.done = true;

	      var rootEntry = this.tryEntries[0];
	      var rootRecord = rootEntry.completion;
	      if (rootRecord.type === "throw") {
	        throw rootRecord.arg;
	      }

	      return this.rval;
	    },

	    dispatchException: function(exception) {
	      if (this.done) {
	        throw exception;
	      }

	      var context = this;
	      function handle(loc, caught) {
	        record.type = "throw";
	        record.arg = exception;
	        context.next = loc;

	        if (caught) {
	          // If the dispatched exception was caught by a catch block,
	          // then let that catch block handle the exception normally.
	          context.method = "next";
	          context.arg = undefined$1;
	        }

	        return !! caught;
	      }

	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        var record = entry.completion;

	        if (entry.tryLoc === "root") {
	          // Exception thrown outside of any try block that could handle
	          // it, so set the completion value of the entire function to
	          // throw the exception.
	          return handle("end");
	        }

	        if (entry.tryLoc <= this.prev) {
	          var hasCatch = hasOwn.call(entry, "catchLoc");
	          var hasFinally = hasOwn.call(entry, "finallyLoc");

	          if (hasCatch && hasFinally) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            } else if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }

	          } else if (hasCatch) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            }

	          } else if (hasFinally) {
	            if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }

	          } else {
	            throw new Error("try statement without catch or finally");
	          }
	        }
	      }
	    },

	    abrupt: function(type, arg) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc <= this.prev &&
	            hasOwn.call(entry, "finallyLoc") &&
	            this.prev < entry.finallyLoc) {
	          var finallyEntry = entry;
	          break;
	        }
	      }

	      if (finallyEntry &&
	          (type === "break" ||
	           type === "continue") &&
	          finallyEntry.tryLoc <= arg &&
	          arg <= finallyEntry.finallyLoc) {
	        // Ignore the finally entry if control is not jumping to a
	        // location outside the try/catch block.
	        finallyEntry = null;
	      }

	      var record = finallyEntry ? finallyEntry.completion : {};
	      record.type = type;
	      record.arg = arg;

	      if (finallyEntry) {
	        this.method = "next";
	        this.next = finallyEntry.finallyLoc;
	        return ContinueSentinel;
	      }

	      return this.complete(record);
	    },

	    complete: function(record, afterLoc) {
	      if (record.type === "throw") {
	        throw record.arg;
	      }

	      if (record.type === "break" ||
	          record.type === "continue") {
	        this.next = record.arg;
	      } else if (record.type === "return") {
	        this.rval = this.arg = record.arg;
	        this.method = "return";
	        this.next = "end";
	      } else if (record.type === "normal" && afterLoc) {
	        this.next = afterLoc;
	      }

	      return ContinueSentinel;
	    },

	    finish: function(finallyLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.finallyLoc === finallyLoc) {
	          this.complete(entry.completion, entry.afterLoc);
	          resetTryEntry(entry);
	          return ContinueSentinel;
	        }
	      }
	    },

	    "catch": function(tryLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc === tryLoc) {
	          var record = entry.completion;
	          if (record.type === "throw") {
	            var thrown = record.arg;
	            resetTryEntry(entry);
	          }
	          return thrown;
	        }
	      }

	      // The context.catch method must only be called with a location
	      // argument that corresponds to a known catch block.
	      throw new Error("illegal catch attempt");
	    },

	    delegateYield: function(iterable, resultName, nextLoc) {
	      this.delegate = {
	        iterator: values(iterable),
	        resultName: resultName,
	        nextLoc: nextLoc
	      };

	      if (this.method === "next") {
	        // Deliberately forget the last sent value so that we don't
	        // accidentally pass it on to the delegate.
	        this.arg = undefined$1;
	      }

	      return ContinueSentinel;
	    }
	  };

	  // Regardless of whether this script is executing as a CommonJS module
	  // or not, return the runtime object so that we can declare the variable
	  // regeneratorRuntime in the outer scope, which allows this module to be
	  // injected easily by `bin/regenerator --include-runtime script.js`.
	  return exports;

	}(
	  // If this script is executing as a CommonJS module, use module.exports
	  // as the regeneratorRuntime namespace. Otherwise create a new empty
	  // object. Either way, the resulting object will be used to initialize
	  // the regeneratorRuntime variable at the top of this file.
	   module.exports 
	));

	try {
	  regeneratorRuntime = runtime;
	} catch (accidentalStrictMode) {
	  // This module should not be running in strict mode, so the above
	  // assignment should always work unless something is misconfigured. Just
	  // in case runtime.js accidentally runs in strict mode, we can escape
	  // strict mode using a global Function call. This could conceivably fail
	  // if a Content Security Policy forbids using Function, but in that case
	  // the proper solution is to fix the accidental strict mode problem. If
	  // you've misconfigured your bundler to force strict mode and applied a
	  // CSP to forbid Function, and you're not willing to fix either of those
	  // problems, please detail your unique predicament in a GitHub issue.
	  Function("r", "regeneratorRuntime = r")(runtime);
	}
	});

	var regenerator = runtime_1;

	var _anInstance = function (it, Constructor, name, forbiddenField) {
	  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
	    throw TypeError(name + ': incorrect invocation!');
	  } return it;
	};

	// call something on iterator step with safe closing on error

	var _iterCall = function (iterator, fn, value, entries) {
	  try {
	    return entries ? fn(_anObject(value)[0], value[1]) : fn(value);
	  // 7.4.6 IteratorClose(iterator, completion)
	  } catch (e) {
	    var ret = iterator['return'];
	    if (ret !== undefined) _anObject(ret.call(iterator));
	    throw e;
	  }
	};

	// check on default Array iterator

	var ITERATOR$2 = _wks('iterator');
	var ArrayProto = Array.prototype;

	var _isArrayIter = function (it) {
	  return it !== undefined && (_iterators.Array === it || ArrayProto[ITERATOR$2] === it);
	};

	var _forOf = createCommonjsModule(function (module) {
	var BREAK = {};
	var RETURN = {};
	var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
	  var iterFn = ITERATOR ? function () { return iterable; } : core_getIteratorMethod(iterable);
	  var f = _ctx(fn, that, entries ? 2 : 1);
	  var index = 0;
	  var length, step, iterator, result;
	  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
	  // fast case for arrays with default iterator
	  if (_isArrayIter(iterFn)) for (length = _toLength(iterable.length); length > index; index++) {
	    result = entries ? f(_anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
	    if (result === BREAK || result === RETURN) return result;
	  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
	    result = _iterCall(iterator, f, step.value, entries);
	    if (result === BREAK || result === RETURN) return result;
	  }
	};
	exports.BREAK = BREAK;
	exports.RETURN = RETURN;
	});

	// 7.3.20 SpeciesConstructor(O, defaultConstructor)


	var SPECIES = _wks('species');
	var _speciesConstructor = function (O, D) {
	  var C = _anObject(O).constructor;
	  var S;
	  return C === undefined || (S = _anObject(C)[SPECIES]) == undefined ? D : _aFunction(S);
	};

	// fast apply, http://jsperf.lnkit.com/fast-apply/5
	var _invoke = function (fn, args, that) {
	  var un = that === undefined;
	  switch (args.length) {
	    case 0: return un ? fn()
	                      : fn.call(that);
	    case 1: return un ? fn(args[0])
	                      : fn.call(that, args[0]);
	    case 2: return un ? fn(args[0], args[1])
	                      : fn.call(that, args[0], args[1]);
	    case 3: return un ? fn(args[0], args[1], args[2])
	                      : fn.call(that, args[0], args[1], args[2]);
	    case 4: return un ? fn(args[0], args[1], args[2], args[3])
	                      : fn.call(that, args[0], args[1], args[2], args[3]);
	  } return fn.apply(that, args);
	};

	var process = _global.process;
	var setTask = _global.setImmediate;
	var clearTask = _global.clearImmediate;
	var MessageChannel = _global.MessageChannel;
	var Dispatch = _global.Dispatch;
	var counter = 0;
	var queue = {};
	var ONREADYSTATECHANGE = 'onreadystatechange';
	var defer, channel, port;
	var run = function () {
	  var id = +this;
	  // eslint-disable-next-line no-prototype-builtins
	  if (queue.hasOwnProperty(id)) {
	    var fn = queue[id];
	    delete queue[id];
	    fn();
	  }
	};
	var listener = function (event) {
	  run.call(event.data);
	};
	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if (!setTask || !clearTask) {
	  setTask = function setImmediate(fn) {
	    var args = [];
	    var i = 1;
	    while (arguments.length > i) args.push(arguments[i++]);
	    queue[++counter] = function () {
	      // eslint-disable-next-line no-new-func
	      _invoke(typeof fn == 'function' ? fn : Function(fn), args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clearTask = function clearImmediate(id) {
	    delete queue[id];
	  };
	  // Node.js 0.8-
	  if (_cof(process) == 'process') {
	    defer = function (id) {
	      process.nextTick(_ctx(run, id, 1));
	    };
	  // Sphere (JS game engine) Dispatch API
	  } else if (Dispatch && Dispatch.now) {
	    defer = function (id) {
	      Dispatch.now(_ctx(run, id, 1));
	    };
	  // Browsers with MessageChannel, includes WebWorkers
	  } else if (MessageChannel) {
	    channel = new MessageChannel();
	    port = channel.port2;
	    channel.port1.onmessage = listener;
	    defer = _ctx(port.postMessage, port, 1);
	  // Browsers with postMessage, skip WebWorkers
	  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if (_global.addEventListener && typeof postMessage == 'function' && !_global.importScripts) {
	    defer = function (id) {
	      _global.postMessage(id + '', '*');
	    };
	    _global.addEventListener('message', listener, false);
	  // IE8-
	  } else if (ONREADYSTATECHANGE in _domCreate('script')) {
	    defer = function (id) {
	      _html.appendChild(_domCreate('script'))[ONREADYSTATECHANGE] = function () {
	        _html.removeChild(this);
	        run.call(id);
	      };
	    };
	  // Rest old browsers
	  } else {
	    defer = function (id) {
	      setTimeout(_ctx(run, id, 1), 0);
	    };
	  }
	}
	var _task = {
	  set: setTask,
	  clear: clearTask
	};

	var macrotask = _task.set;
	var Observer = _global.MutationObserver || _global.WebKitMutationObserver;
	var process$1 = _global.process;
	var Promise$1 = _global.Promise;
	var isNode = _cof(process$1) == 'process';

	var _microtask = function () {
	  var head, last, notify;

	  var flush = function () {
	    var parent, fn;
	    if (isNode && (parent = process$1.domain)) parent.exit();
	    while (head) {
	      fn = head.fn;
	      head = head.next;
	      try {
	        fn();
	      } catch (e) {
	        if (head) notify();
	        else last = undefined;
	        throw e;
	      }
	    } last = undefined;
	    if (parent) parent.enter();
	  };

	  // Node.js
	  if (isNode) {
	    notify = function () {
	      process$1.nextTick(flush);
	    };
	  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
	  } else if (Observer && !(_global.navigator && _global.navigator.standalone)) {
	    var toggle = true;
	    var node = document.createTextNode('');
	    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
	    notify = function () {
	      node.data = toggle = !toggle;
	    };
	  // environments with maybe non-completely correct, but existent Promise
	  } else if (Promise$1 && Promise$1.resolve) {
	    // Promise.resolve without an argument throws an error in LG WebOS 2
	    var promise = Promise$1.resolve(undefined);
	    notify = function () {
	      promise.then(flush);
	    };
	  // for other environments - macrotask based on:
	  // - setImmediate
	  // - MessageChannel
	  // - window.postMessag
	  // - onreadystatechange
	  // - setTimeout
	  } else {
	    notify = function () {
	      // strange IE + webpack dev server bug - use .call(global)
	      macrotask.call(_global, flush);
	    };
	  }

	  return function (fn) {
	    var task = { fn: fn, next: undefined };
	    if (last) last.next = task;
	    if (!head) {
	      head = task;
	      notify();
	    } last = task;
	  };
	};

	// 25.4.1.5 NewPromiseCapability(C)


	function PromiseCapability(C) {
	  var resolve, reject;
	  this.promise = new C(function ($$resolve, $$reject) {
	    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject = $$reject;
	  });
	  this.resolve = _aFunction(resolve);
	  this.reject = _aFunction(reject);
	}

	var f$7 = function (C) {
	  return new PromiseCapability(C);
	};

	var _newPromiseCapability = {
		f: f$7
	};

	var _perform = function (exec) {
	  try {
	    return { e: false, v: exec() };
	  } catch (e) {
	    return { e: true, v: e };
	  }
	};

	var navigator$1 = _global.navigator;

	var _userAgent = navigator$1 && navigator$1.userAgent || '';

	var _promiseResolve = function (C, x) {
	  _anObject(C);
	  if (_isObject(x) && x.constructor === C) return x;
	  var promiseCapability = _newPromiseCapability.f(C);
	  var resolve = promiseCapability.resolve;
	  resolve(x);
	  return promiseCapability.promise;
	};

	var _redefineAll = function (target, src, safe) {
	  for (var key in src) {
	    if (safe && target[key]) target[key] = src[key];
	    else _hide(target, key, src[key]);
	  } return target;
	};

	var SPECIES$1 = _wks('species');

	var _setSpecies = function (KEY) {
	  var C = typeof _core[KEY] == 'function' ? _core[KEY] : _global[KEY];
	  if (_descriptors && C && !C[SPECIES$1]) _objectDp.f(C, SPECIES$1, {
	    configurable: true,
	    get: function () { return this; }
	  });
	};

	var ITERATOR$3 = _wks('iterator');
	var SAFE_CLOSING = false;

	try {
	  var riter = [7][ITERATOR$3]();
	  riter['return'] = function () { SAFE_CLOSING = true; };
	  // eslint-disable-next-line no-throw-literal
	  Array.from(riter, function () { throw 2; });
	} catch (e) { /* empty */ }

	var _iterDetect = function (exec, skipClosing) {
	  if (!skipClosing && !SAFE_CLOSING) return false;
	  var safe = false;
	  try {
	    var arr = [7];
	    var iter = arr[ITERATOR$3]();
	    iter.next = function () { return { done: safe = true }; };
	    arr[ITERATOR$3] = function () { return iter; };
	    exec(arr);
	  } catch (e) { /* empty */ }
	  return safe;
	};

	var task = _task.set;
	var microtask = _microtask();




	var PROMISE = 'Promise';
	var TypeError$1 = _global.TypeError;
	var process$2 = _global.process;
	var versions = process$2 && process$2.versions;
	var v8 = versions && versions.v8 || '';
	var $Promise = _global[PROMISE];
	var isNode$1 = _classof(process$2) == 'process';
	var empty = function () { /* empty */ };
	var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
	var newPromiseCapability = newGenericPromiseCapability = _newPromiseCapability.f;

	var USE_NATIVE$1 = !!function () {
	  try {
	    // correct subclassing with @@species support
	    var promise = $Promise.resolve(1);
	    var FakePromise = (promise.constructor = {})[_wks('species')] = function (exec) {
	      exec(empty, empty);
	    };
	    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
	    return (isNode$1 || typeof PromiseRejectionEvent == 'function')
	      && promise.then(empty) instanceof FakePromise
	      // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
	      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
	      // we can't detect it synchronously, so just check versions
	      && v8.indexOf('6.6') !== 0
	      && _userAgent.indexOf('Chrome/66') === -1;
	  } catch (e) { /* empty */ }
	}();

	// helpers
	var isThenable = function (it) {
	  var then;
	  return _isObject(it) && typeof (then = it.then) == 'function' ? then : false;
	};
	var notify = function (promise, isReject) {
	  if (promise._n) return;
	  promise._n = true;
	  var chain = promise._c;
	  microtask(function () {
	    var value = promise._v;
	    var ok = promise._s == 1;
	    var i = 0;
	    var run = function (reaction) {
	      var handler = ok ? reaction.ok : reaction.fail;
	      var resolve = reaction.resolve;
	      var reject = reaction.reject;
	      var domain = reaction.domain;
	      var result, then, exited;
	      try {
	        if (handler) {
	          if (!ok) {
	            if (promise._h == 2) onHandleUnhandled(promise);
	            promise._h = 1;
	          }
	          if (handler === true) result = value;
	          else {
	            if (domain) domain.enter();
	            result = handler(value); // may throw
	            if (domain) {
	              domain.exit();
	              exited = true;
	            }
	          }
	          if (result === reaction.promise) {
	            reject(TypeError$1('Promise-chain cycle'));
	          } else if (then = isThenable(result)) {
	            then.call(result, resolve, reject);
	          } else resolve(result);
	        } else reject(value);
	      } catch (e) {
	        if (domain && !exited) domain.exit();
	        reject(e);
	      }
	    };
	    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
	    promise._c = [];
	    promise._n = false;
	    if (isReject && !promise._h) onUnhandled(promise);
	  });
	};
	var onUnhandled = function (promise) {
	  task.call(_global, function () {
	    var value = promise._v;
	    var unhandled = isUnhandled(promise);
	    var result, handler, console;
	    if (unhandled) {
	      result = _perform(function () {
	        if (isNode$1) {
	          process$2.emit('unhandledRejection', value, promise);
	        } else if (handler = _global.onunhandledrejection) {
	          handler({ promise: promise, reason: value });
	        } else if ((console = _global.console) && console.error) {
	          console.error('Unhandled promise rejection', value);
	        }
	      });
	      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
	      promise._h = isNode$1 || isUnhandled(promise) ? 2 : 1;
	    } promise._a = undefined;
	    if (unhandled && result.e) throw result.v;
	  });
	};
	var isUnhandled = function (promise) {
	  return promise._h !== 1 && (promise._a || promise._c).length === 0;
	};
	var onHandleUnhandled = function (promise) {
	  task.call(_global, function () {
	    var handler;
	    if (isNode$1) {
	      process$2.emit('rejectionHandled', promise);
	    } else if (handler = _global.onrejectionhandled) {
	      handler({ promise: promise, reason: promise._v });
	    }
	  });
	};
	var $reject = function (value) {
	  var promise = this;
	  if (promise._d) return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  promise._v = value;
	  promise._s = 2;
	  if (!promise._a) promise._a = promise._c.slice();
	  notify(promise, true);
	};
	var $resolve = function (value) {
	  var promise = this;
	  var then;
	  if (promise._d) return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  try {
	    if (promise === value) throw TypeError$1("Promise can't be resolved itself");
	    if (then = isThenable(value)) {
	      microtask(function () {
	        var wrapper = { _w: promise, _d: false }; // wrap
	        try {
	          then.call(value, _ctx($resolve, wrapper, 1), _ctx($reject, wrapper, 1));
	        } catch (e) {
	          $reject.call(wrapper, e);
	        }
	      });
	    } else {
	      promise._v = value;
	      promise._s = 1;
	      notify(promise, false);
	    }
	  } catch (e) {
	    $reject.call({ _w: promise, _d: false }, e); // wrap
	  }
	};

	// constructor polyfill
	if (!USE_NATIVE$1) {
	  // 25.4.3.1 Promise(executor)
	  $Promise = function Promise(executor) {
	    _anInstance(this, $Promise, PROMISE, '_h');
	    _aFunction(executor);
	    Internal.call(this);
	    try {
	      executor(_ctx($resolve, this, 1), _ctx($reject, this, 1));
	    } catch (err) {
	      $reject.call(this, err);
	    }
	  };
	  // eslint-disable-next-line no-unused-vars
	  Internal = function Promise(executor) {
	    this._c = [];             // <- awaiting reactions
	    this._a = undefined;      // <- checked in isUnhandled reactions
	    this._s = 0;              // <- state
	    this._d = false;          // <- done
	    this._v = undefined;      // <- value
	    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
	    this._n = false;          // <- notify
	  };
	  Internal.prototype = _redefineAll($Promise.prototype, {
	    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
	    then: function then(onFulfilled, onRejected) {
	      var reaction = newPromiseCapability(_speciesConstructor(this, $Promise));
	      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
	      reaction.fail = typeof onRejected == 'function' && onRejected;
	      reaction.domain = isNode$1 ? process$2.domain : undefined;
	      this._c.push(reaction);
	      if (this._a) this._a.push(reaction);
	      if (this._s) notify(this, false);
	      return reaction.promise;
	    },
	    // 25.4.5.1 Promise.prototype.catch(onRejected)
	    'catch': function (onRejected) {
	      return this.then(undefined, onRejected);
	    }
	  });
	  OwnPromiseCapability = function () {
	    var promise = new Internal();
	    this.promise = promise;
	    this.resolve = _ctx($resolve, promise, 1);
	    this.reject = _ctx($reject, promise, 1);
	  };
	  _newPromiseCapability.f = newPromiseCapability = function (C) {
	    return C === $Promise || C === Wrapper
	      ? new OwnPromiseCapability(C)
	      : newGenericPromiseCapability(C);
	  };
	}

	_export(_export.G + _export.W + _export.F * !USE_NATIVE$1, { Promise: $Promise });
	_setToStringTag($Promise, PROMISE);
	_setSpecies(PROMISE);
	Wrapper = _core[PROMISE];

	// statics
	_export(_export.S + _export.F * !USE_NATIVE$1, PROMISE, {
	  // 25.4.4.5 Promise.reject(r)
	  reject: function reject(r) {
	    var capability = newPromiseCapability(this);
	    var $$reject = capability.reject;
	    $$reject(r);
	    return capability.promise;
	  }
	});
	_export(_export.S + _export.F * (_library ), PROMISE, {
	  // 25.4.4.6 Promise.resolve(x)
	  resolve: function resolve(x) {
	    return _promiseResolve( this === Wrapper ? $Promise : this, x);
	  }
	});
	_export(_export.S + _export.F * !(USE_NATIVE$1 && _iterDetect(function (iter) {
	  $Promise.all(iter)['catch'](empty);
	})), PROMISE, {
	  // 25.4.4.1 Promise.all(iterable)
	  all: function all(iterable) {
	    var C = this;
	    var capability = newPromiseCapability(C);
	    var resolve = capability.resolve;
	    var reject = capability.reject;
	    var result = _perform(function () {
	      var values = [];
	      var index = 0;
	      var remaining = 1;
	      _forOf(iterable, false, function (promise) {
	        var $index = index++;
	        var alreadyCalled = false;
	        values.push(undefined);
	        remaining++;
	        C.resolve(promise).then(function (value) {
	          if (alreadyCalled) return;
	          alreadyCalled = true;
	          values[$index] = value;
	          --remaining || resolve(values);
	        }, reject);
	      });
	      --remaining || resolve(values);
	    });
	    if (result.e) reject(result.v);
	    return capability.promise;
	  },
	  // 25.4.4.4 Promise.race(iterable)
	  race: function race(iterable) {
	    var C = this;
	    var capability = newPromiseCapability(C);
	    var reject = capability.reject;
	    var result = _perform(function () {
	      _forOf(iterable, false, function (promise) {
	        C.resolve(promise).then(capability.resolve, reject);
	      });
	    });
	    if (result.e) reject(result.v);
	    return capability.promise;
	  }
	});

	_export(_export.P + _export.R, 'Promise', { 'finally': function (onFinally) {
	  var C = _speciesConstructor(this, _core.Promise || _global.Promise);
	  var isFunction = typeof onFinally == 'function';
	  return this.then(
	    isFunction ? function (x) {
	      return _promiseResolve(C, onFinally()).then(function () { return x; });
	    } : onFinally,
	    isFunction ? function (e) {
	      return _promiseResolve(C, onFinally()).then(function () { throw e; });
	    } : onFinally
	  );
	} });

	// https://github.com/tc39/proposal-promise-try




	_export(_export.S, 'Promise', { 'try': function (callbackfn) {
	  var promiseCapability = _newPromiseCapability.f(this);
	  var result = _perform(callbackfn);
	  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
	  return promiseCapability.promise;
	} });

	var promise = _core.Promise;

	var promise$1 = promise;

	/**
	 * @const {Array} Cesium 事件集合。
	 */
	var Events = {
	  'vc-viewer': ['selectedEntityChanged', 'trackedEntityChanged'],
	  'viewer-property-events': [{
	    // viewer.imageryLayers
	    name: 'imageryLayers',
	    events: ['layerAdded', 'layerMoved', 'layerRemoved', 'layerShownOrHidden']
	  }, {
	    // viewer.dataSources
	    name: 'dataSources',
	    events: ['dataSourceAdded', 'dataSourceMoved', 'dataSourceRemoved']
	  }, {
	    // viewer.entities
	    name: 'entities',
	    events: ['collectionChanged']
	  }, {
	    // viewer.scene
	    name: 'scene',
	    events: ['morphComplete', 'morphStart', 'postRender', 'postUpdate', 'preRender', 'preUpdate', 'renderError', 'terrainProviderChanged']
	  }, {
	    // viewer.camera
	    name: 'camera',
	    events: ['changed', 'moveEnd', 'moveStart']
	  }, {
	    // viewer.clock
	    name: 'clock',
	    events: ['onStop', 'onTick']
	  }, {
	    // viewer.terrainProvider
	    name: 'terrainProvider',
	    events: ['errorEvent']
	  }, {
	    // viewer.infoBox.viewModel
	    name: ['infoBox', 'viewModel'],
	    events: ['cameraClicked', 'closeClicked']
	  }],
	  'viewer-mouse-events': ['LEFT_CLICK', 'LEFT_DOUBLE_CLICK', 'LEFT_DOWN', 'LEFT_UP', 'MIDDLE_CLICK', 'MIDDLE_DOWN', 'MIDDLE_UP', 'MOUSE_MOVE', 'PINCH_END', 'PINCH_MOVE', 'PINCH_START', 'RIGHT_CLICK', 'RIGHT_DOWN', 'RIGHT_UP', 'WHEEL'],
	  'vc-primitive-tileset': ['allTilesLoaded', 'initialTilesLoaded', 'loadProgress', 'tileFailed', 'tileLoad', 'tileUnload', 'tileVisible'],
	  'vc-primitive-particle': ['complete'],
	  'imagery-layer-events': ['errorEvent'],
	  'entity-events': ['definitionChanged'],
	  'datasource-events': ['changedEvent', 'errorEvent', 'loadingEvent'],
	  'datasource-property-events': [{
	    name: 'clock',
	    events: ['definitionChanged']
	  }, {
	    name: 'clustering',
	    events: ['clusterEvent']
	  }, {
	    name: 'entities',
	    events: ['collectionChanged']
	  }],
	  'mouse-events': ['mousedown', 'mouseup', 'click', 'clickout', 'dblclick', 'mousemove', 'mouseover', 'mouseout']
	};

	var iterator = _wksExt.f('iterator');

	var iterator$1 = iterator;

	_wksDefine('asyncIterator');

	_wksDefine('observable');

	var symbol = _core.Symbol;

	var symbol$1 = symbol;

	function _typeof2(obj) { if (typeof symbol$1 === "function" && typeof iterator$1 === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof symbol$1 === "function" && obj.constructor === symbol$1 && obj !== symbol$1.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

	function _typeof(obj) {
	  if (typeof symbol$1 === "function" && _typeof2(iterator$1) === "symbol") {
	    _typeof = function _typeof(obj) {
	      return _typeof2(obj);
	    };
	  } else {
	    _typeof = function _typeof(obj) {
	      return obj && typeof symbol$1 === "function" && obj.constructor === symbol$1 && obj !== symbol$1.prototype ? "symbol" : _typeof2(obj);
	    };
	  }

	  return _typeof(obj);
	}

	var toString$2 = Object.prototype.toString;
	var toKebabCase = function toKebabCase(str) {
	  return str.replace(/[A-Z]/g, function (letter) {
	    return "-".concat(letter.toLowerCase());
	  }).replace(/^-/, '');
	};
	var clone = function clone(object, deep) {
	  if (object === null || _typeof(object) !== 'object') {
	    return object;
	  }

	  deep = deep || false;
	  var result = new object.constructor();

	  for (var propertyName in object) {
	    if (Object.prototype.hasOwnProperty.call(object, propertyName)) {
	      var value = object[propertyName];

	      if (deep) {
	        value = clone(value, deep);
	      }

	      result[propertyName] = value;
	    }
	  }

	  return result;
	};
	function isEmptyObj(o) {
	  if (isUndefined(o)) {
	    return true;
	  }

	  if (o instanceof Element) {
	    return false;
	  }

	  var arr = keys$1(o);

	  return arr.length === 0;
	}
	/**
	 * Determine if a value is an Array
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an Array, otherwise false
	 */

	function isArray(val) {
	  return toString$2.call(val) === '[object Array]';
	}
	/**
	 * Determine if a value is an Object
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an Object, otherwise false
	 */

	function isObject(val) {
	  return val !== null && _typeof(val) === 'object';
	}
	/**
	 * Determine if a value is a String
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a String, otherwise false
	 */

	function isString(val) {
	  return typeof val === 'string';
	}
	/**
	 * Determine if a value is undefined
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if the value is undefined, otherwise false
	 */

	function isUndefined(val) {
	  return typeof val === 'undefined';
	}
	/**
	 * Determine if a value is a Function
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Function, otherwise false
	 */

	function isFunction(val) {
	  return toString$2.call(val) === '[object Function]';
	}
	/**
	 * 验证是否是经纬度。
	 * @param {Number} longitude
	 * @param {Number} latitude
	 * @returns {Boolean}
	 */

	function lnglatValidator(longitude, latitude) {
	  // 经度，整数部分为0-180小数部分为0到6位
	  var longreg = /^(-|\+)?(((\d|[1-9]\d|1[0-7]\d|0{1,3})\.\d{0,15})|(\d|[1-9]\d|1[0-7]\d|0{1,3})|180\.0{0,15}|180)$/;

	  if (!longreg.test(longitude)) {
	    return false;
	  } // 纬度,整数部分为0-90小数部分为0到6位


	  var latreg = /^(-|\+)?([0-8]?\d{1}\.\d{0,15}|90\.0{0,15}|[0-8]?\d{1}|90)$/;

	  if (!latreg.test(latitude)) {
	    return false;
	  }

	  return true;
	}
	function dirname(path) {
	  if (typeof path !== 'string') path = path + '';
	  if (path.length === 0) return '.';
	  var code = path.charCodeAt(0);
	  var hasRoot = code === 47;
	  /* / */

	  var end = -1;
	  var matchedSlash = true;

	  for (var i = path.length - 1; i >= 1; --i) {
	    code = path.charCodeAt(i);

	    if (code === 47
	    /* / */
	    ) {
	        if (!matchedSlash) {
	          end = i;
	          break;
	        }
	      } else {
	      // We saw the first non-path separator
	      matchedSlash = false;
	    }
	  }

	  if (end === -1) return hasRoot ? '/' : '.';

	  if (hasRoot && end === 1) {
	    // return '//';
	    // Backwards-compat fix:
	    return '/';
	  }

	  return path.slice(0, end);
	}
	function Platform() {
	  var ua = navigator.userAgent;
	  var isWindowsPhone = /(?:Windows Phone)/.test(ua);
	  var isSymbian = /(?:SymbianOS)/.test(ua) || isWindowsPhone;
	  var isAndroid = /(?:Android)/.test(ua);
	  var isFireFox = /(?:Firefox)/.test(ua);
	  var isChrome = /(?:Chrome|CriOS)/.test(ua);
	  var isTablet = /(?:iPad|PlayBook)/.test(ua) || isAndroid && !/(?:Mobile)/.test(ua) || isFireFox && /(?:Tablet)/.test(ua);
	  var isPhone = /(?:iPhone)/.test(ua) && !isTablet;
	  var isPc = !isPhone && !isAndroid && !isSymbian;
	  return {
	    isTablet: isTablet,
	    isPhone: isPhone,
	    isAndroid: isAndroid,
	    isPc: isPc,
	    isChrome: isChrome
	  };
	}
	function captureScreenshot(viewer) {
	  var _Cesium = Cesium,
	      when = _Cesium.when;
	  var deferred = when.defer();
	  var scene = viewer.scene;
	  var removeCallback = scene.postRender.addEventListener(function () {
	    removeCallback();

	    try {
	      var cesiumCanvas = viewer.scene.canvas; // If we're using the splitter, draw the split position as a vertical white line.

	      var canvas = cesiumCanvas; // if (showSplitter) {
	      //   canvas = document.createElement('canvas')
	      //   canvas.width = cesiumCanvas.width
	      //   canvas.height = cesiumCanvas.height
	      //   const context = canvas.getContext('2d')
	      //   context.drawImage(cesiumCanvas, 0, 0)
	      //   const x = viewer.splitPosition * cesiumCanvas.width
	      //   context.strokeStyle = this.terria.baseMapContrastColor
	      //   context.beginPath()
	      //   context.moveTo(x, 0)
	      //   context.lineTo(x, cesiumCanvas.height)
	      //   context.stroke()
	      // }

	      deferred.resolve(canvas.toDataURL('image/png'));
	    } catch (e) {
	      deferred.reject(e);
	    }
	  }, this);
	  scene.render(viewer.clock.currentTime);
	  return deferred.promise;
	}
	function getAllAttribution(viewer) {
	  var credits = viewer.scene.frameState.creditDisplay._currentFrameCredits.screenCredits.values.concat(viewer.scene.frameState.creditDisplay._currentFrameCredits.lightboxCredits.values);

	  return credits.map(function (credit) {
	    return credit.html;
	  });
	}

	/**
	 * 将 Cesium 对象事件注册为 Vue 组件事件。
	 * @param {Object} instance Cesium 对象。
	 * @param {Array} eventList 该 Cesium 对象的事件数组。
	 * @param {Boolean} flag true 注册事件，false 注销事件。
	 */

	function bindEvents (instance, eventList) {
	  var _this = this;

	  var flag = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
	  var ev = eventList || Events[toKebabCase(this.$options.name)];
	  ev && ev.forEach(function (eventName) {
	    if (instance[eventName]) {
	      var listener = _this.$listeners[eventName] || _this.$listeners[eventName.toLowerCase()];

	      var methodName = flag ? 'addEventListener' : 'removeEventListener';
	      listener && instance[eventName][methodName](listener.fns);
	    }
	  });
	}

	/*!
	 * merge-descriptors
	 * Copyright(c) 2014 Jonathan Ong
	 * Copyright(c) 2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	/**
	 * Module exports.
	 * @public
	 */

	var mergeDescriptors = merge;

	/**
	 * Module variables.
	 * @private
	 */

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	/**
	 * Merge the property descriptors of `src` into `dest`
	 *
	 * @param {object} dest Object to add descriptors to
	 * @param {object} src Object to clone descriptors from
	 * @param {boolean} [redefine=true] Redefine `dest` properties with `src` properties
	 * @returns {object} Reference to dest
	 * @public
	 */

	function merge(dest, src, redefine) {
	  if (!dest) {
	    throw new TypeError('argument dest is required')
	  }

	  if (!src) {
	    throw new TypeError('argument src is required')
	  }

	  if (redefine === undefined) {
	    // Default to true
	    redefine = true;
	  }

	  Object.getOwnPropertyNames(src).forEach(function forEachOwnPropertyName(name) {
	    if (!redefine && hasOwnProperty$1.call(dest, name)) {
	      // Skip desriptor
	      return
	    }

	    // Copy descriptor
	    var descriptor = Object.getOwnPropertyDescriptor(src, name);
	    Object.defineProperty(dest, name, descriptor);
	  });

	  return dest
	}

	/**
	 * @param {...Object} args
	 * @returns {Object}
	 */

	function multiMergeDescriptors() {
	  var redefine;

	  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	    args[_key] = arguments[_key];
	  }

	  if (_typeof(args[args.length - 1]) !== 'object') {
	    redefine = args.pop();
	  }

	  return args.slice(1).reduce(function (dest, src, i) {
	    return mergeDescriptors(dest, src, redefine);
	  }, args[0]);
	}

	var SERVICES_PROP = 'services';
	/**
	 * 全局注入 provider 的数据
	 */

	var services = {
	  inject: {
	    $services: SERVICES_PROP
	  },
	  provide: function provide() {
	    return _defineProperty({}, SERVICES_PROP, this.getServices());
	  },
	  methods: {
	    /**
	     *  获取注入数据。
	     * @returns {Object}
	     * @protected
	     */
	    getServices: function getServices() {
	      return multiMergeDescriptors({}, this.$services || {});
	    },

	    /**
	     * 移除对象中的空值。
	     * @param {*} o
	     * @param {*} arr
	     * @param {*} i
	     * @returns {Object}
	     */
	    removeNullItem: removeNullItem,

	    /**
	     * 判断是否是空对象。
	     * @param {*} o
	     * @returns {Boolean}
	     */
	    isEmptyObj: isEmptyObj
	  },
	  beforeCreate: function beforeCreate() {
	    var source = this.$parent;

	    while (source) {
	      if (source._provided != null && source._provided[SERVICES_PROP] != null) {
	        break;
	      }

	      source = source.$parent;
	    }

	    if (source == null || source._provided[SERVICES_PROP] == null) {
	      delete this.$options.inject.$services;
	    }
	  }
	};
	/**
	 * 处理对象。
	 * @param {*} o
	 */

	function proccessObject(o) {
	  for (var attr in o) {
	    if (o[attr] === null || o[attr] === undefined) delete o[attr];else if (_typeof(o[attr]) === 'object') {
	      // this.removeNullItem(o[attr])
	      if (isEmptyObj(o[attr])) delete o[attr];
	    }
	  }
	}
	/**
	 * 处理数组。
	 * @param {*} arr
	 */


	function processArray(arr) {
	  for (var i = arr.length - 1; i >= 0; i--) {
	    /* if (arr[i] === null || arr[i] === undefined) arr.splice(i, 1);
	            else */
	    if (_typeof(arr[i]) === 'object') {
	      removeNullItem(arr[i]);
	    }
	  }

	  return arr.length === 0;
	}
	/**
	  * 移除对象中的空值。
	  * @param {*} o
	  * @param {*} arr
	  * @param {*} i
	  * @returns {Object}
	  */


	function removeNullItem(o, arr, i) {
	  var s = {}.toString.call(o);

	  if (s === '[object Array]') {
	    if (processArray(o) === true) ;
	  } else if (s === '[object Object]') {
	    proccessObject(o); // if (arr&&isEmptyObj(o)) arr.splice(i, 1);
	  }
	}

	var script = {
	  name: 'vc-viewer',
	  mixins: [services],
	  props: {
	    cesiumPath: String,
	    animation: {
	      type: Boolean,
	      default: false
	    },
	    baseLayerPicker: {
	      type: Boolean,
	      default: false
	    },
	    fullscreenButton: {
	      type: Boolean,
	      default: false
	    },
	    vrButton: {
	      type: Boolean,
	      default: false
	    },
	    geocoder: {
	      type: Boolean,
	      default: false
	    },
	    homeButton: {
	      type: Boolean,
	      default: false
	    },
	    infoBox: {
	      type: Boolean,
	      default: true
	    },
	    sceneModePicker: {
	      type: Boolean,
	      default: false
	    },
	    selectionIndicator: {
	      type: Boolean,
	      default: true
	    },
	    timeline: {
	      type: Boolean,
	      default: false
	    },
	    navigationHelpButton: {
	      type: Boolean,
	      default: false
	    },
	    navigationInstructionsInitiallyVisible: {
	      type: Boolean,
	      default: false
	    },
	    scene3DOnly: {
	      type: Boolean,
	      default: false
	    },
	    shouldAnimate: {
	      type: Boolean,
	      default: false
	    },
	    clockViewModel: Object,
	    selectedImageryProviderViewModel: Object,
	    imageryProviderViewModels: Object,
	    selectedTerrainProviderViewModel: Object,
	    terrainProviderViewModels: Object,
	    imageryProvider: Object,
	    terrainProvider: Object,
	    skyBox: Object,
	    skyAtmosphere: Object,
	    fullscreenElement: {
	      type: [Element, String]
	    },
	    useDefaultRenderLoop: {
	      type: Boolean,
	      default: true
	    },
	    targetFrameRate: Number,
	    showRenderLoopErrors: {
	      type: Boolean,
	      default: true
	    },
	    automaticallyTrackDataSourceClocks: {
	      type: Boolean,
	      default: true
	    },
	    contextOptions: Object,
	    sceneMode: {
	      type: Number,
	      default: 3
	    },
	    mapProjection: Object,
	    globe: Object,
	    orderIndependentTranslucency: {
	      type: Boolean,
	      default: true
	    },
	    creditContainer: String,
	    creditViewport: String,
	    dataSources: Object,
	    terrainExaggeration: {
	      type: Number,
	      default: 1.0
	    },
	    shadows: {
	      type: Boolean,
	      default: false
	    },
	    terrainShadows: {
	      type: Number,
	      default: 3
	    },
	    mapMode2D: {
	      type: Number,
	      default: 1
	    },
	    projectionPicker: {
	      type: Boolean,
	      default: false
	    },
	    requestRenderMode: {
	      type: Boolean,
	      default: false
	    },
	    maximumRenderTimeChange: {
	      type: Number,
	      default: 0.0
	    },
	    logo: {
	      type: Boolean,
	      default: true
	    },
	    accessToken: String,
	    camera: {
	      type: Object,
	      default: function _default() {
	        return {
	          position: {
	            lng: 105,
	            lat: 29.999999999999993,
	            height: 19059568.497290563
	          },
	          heading: 360,
	          pitch: -90,
	          roll: 0
	        };
	      }
	    },
	    navigation: {
	      // for supermap
	      type: Boolean,
	      default: false
	    },
	    TZcode: {
	      type: String,
	      default: new Date().getTimezoneOffset() === 0 ? 'UTC' : 'UTC' + '+' + -(new Date().getTimezoneOffset() / 60)
	    },
	    UTCoffset: {
	      type: Number,
	      default: -new Date().getTimezoneOffset()
	    },
	    removeCesiumScript: {
	      type: Boolean,
	      default: true
	    },
	    autoSortImageryLayers: {
	      type: Boolean,
	      default: true
	    }
	  },
	  watch: {
	    selectionIndicator: function selectionIndicator(val) {
	      var viewer = this.viewer,
	          viewerContainer = this.viewerContainer;

	      if (Cesium.defined(viewer.selectionIndicator) && !viewer.selectionIndicator.isDestroyed() && !val) {
	        var selectionIndicatorContainer = viewer.selectionIndicator.container;
	        viewerContainer.removeChild(selectionIndicatorContainer);
	        viewer.selectionIndicator.destroy();
	        viewer._selectionIndicator = undefined;
	      } else if (!Cesium.defined(viewer.selectionIndicator) || viewer.selectionIndicator.isDestroyed()) {
	        var _selectionIndicatorContainer = document.createElement('div');

	        _selectionIndicatorContainer.className = 'cesium-viewer-selectionIndicatorContainer';
	        viewerContainer.appendChild(_selectionIndicatorContainer);
	        var selectionIndicator = new Cesium.SelectionIndicator(_selectionIndicatorContainer, viewer.scene);
	        viewer._selectionIndicator = selectionIndicator;
	      }

	      viewer.widgetResized.raiseEvent();
	    },
	    infoBox: function infoBox(val) {
	      var viewer = this.viewer,
	          viewerContainer = this.viewerContainer;

	      if (Cesium.defined(viewer.infoBox) && !viewer.infoBox.isDestroyed() && !val) {
	        var infoBoxContainer = viewer.infoBox.container;
	        viewerContainer.removeChild(infoBoxContainer);
	        viewer.infoBox.destroy();
	        viewer._infoBox = undefined;
	      } else if (!Cesium.defined(viewer.infoBox) || viewer.infoBox.isDestroyed()) {
	        var _infoBoxContainer = document.createElement('div');

	        _infoBoxContainer.className = 'cesium-viewer-infoBoxContainer';
	        viewerContainer.appendChild(_infoBoxContainer);
	        var infoBox = new Cesium.InfoBox(_infoBoxContainer);
	        var infoBoxViewModel = infoBox.viewModel;

	        viewer._eventHelper.add(infoBoxViewModel.cameraClicked, viewer._onInfoBoxCameraClicked, viewer);

	        viewer._eventHelper.add(infoBoxViewModel.closeClicked, viewer._onInfoBoxClockClicked, viewer);

	        var events = ['cameraClicked', 'closeClicked'];
	        infoBoxViewModel && bindEvents.call(this, infoBoxViewModel, events, true);
	        viewer._infoBox = infoBox;
	      }

	      viewer.forceResize();
	      viewer.widgetResized.raiseEvent();
	    },
	    geocoder: function geocoder(val) {
	      var viewer = this.viewer,
	          resizeToolbar = this.resizeToolbar;
	      var toolbar = viewer._toolbar;

	      if (Cesium.defined(viewer.geocoder) && !viewer.geocoder.isDestroyed() && !val) {
	        var geocoderContainer = viewer.geocoder.container;
	        toolbar.removeChild(geocoderContainer);
	        viewer.geocoder.destroy();
	        viewer._geocoder = undefined;
	      } else if (!Cesium.defined(viewer.geocoder) || viewer.geocoder.isDestroyed()) {
	        var _geocoderContainer = document.createElement('div');

	        _geocoderContainer.className = 'cesium-viewer-geocoderContainer';
	        toolbar.appendChild(_geocoderContainer);
	        var geocoder = new Cesium.Geocoder({
	          container: _geocoderContainer,
	          geocoderServices: Cesium.defined(this.geocoder) ? Cesium.isArray(this.geocoder) ? this.geocoder : [this.geocoder] : undefined,
	          scene: viewer.scene,
	          viewer: viewer
	        });

	        viewer._eventHelper.add(geocoder.viewModel.search.beforeExecute, viewer._clearObjects, viewer);

	        viewer._geocoder = geocoder;
	        resizeToolbar(toolbar, _geocoderContainer);
	      }

	      viewer.widgetResized.raiseEvent();
	    },
	    homeButton: function homeButton(val) {
	      var viewer = this.viewer,
	          resizeToolbar = this.resizeToolbar;
	      var toolbar = viewer._toolbar;

	      if (Cesium.defined(viewer.homeButton) && !viewer.homeButton.isDestroyed() && !val) {
	        viewer.homeButton.destroy();
	        viewer._homeButton = undefined;
	      } else if (!Cesium.defined(viewer.homeButton) || viewer.homeButton.isDestroyed()) {
	        var homeButton = new Cesium.HomeButton(toolbar, viewer.scene);

	        if (Cesium.defined(viewer.geocoder)) {
	          viewer._eventHelper.add(homeButton.viewModel.command.afterExecute, function () {
	            var viewModel = viewer.geocoder.viewModel;
	            viewModel.searchText = '';

	            if (viewModel.isSearchInProgress) {
	              viewModel.search();
	            }
	          });
	        }

	        viewer._eventHelper.add(homeButton.viewModel.command.beforeExecute, viewer._clearTrackedObject, viewer);

	        viewer._homeButton = homeButton;
	        resizeToolbar(toolbar, homeButton);
	      }

	      viewer.widgetResized.raiseEvent();
	    },
	    sceneModePicker: function sceneModePicker(val) {
	      var viewer = this.viewer,
	          resizeToolbar = this.resizeToolbar;
	      var toolbar = viewer._toolbar;

	      if (Cesium.defined(viewer.sceneModePicker) && !viewer.sceneModePicker.isDestroyed() && !val) {
	        viewer.sceneModePicker.destroy();
	        viewer._sceneModePicker = undefined;
	      } else if (!Cesium.defined(viewer.sceneModePicker) || viewer.sceneModePicker.isDestroyed()) {
	        if (this.sceneModePicker === true && this.scene3DOnly) {
	          throw new Cesium.DeveloperError('options.sceneModePicker is not available when options.scene3DOnly is set to true.');
	        }

	        if (!this.scene3DOnly && this.sceneModePicker === true) {
	          var sceneModePicker = new Cesium.SceneModePicker(toolbar, viewer.scene);
	          viewer._sceneModePicker = sceneModePicker;
	          resizeToolbar(toolbar, sceneModePicker);
	        }
	      }

	      viewer.widgetResized.raiseEvent();
	    },
	    projectionPicker: function projectionPicker(val) {
	      var viewer = this.viewer,
	          resizeToolbar = this.resizeToolbar;
	      var toolbar = viewer._toolbar;

	      if (Cesium.defined(viewer.projectionPicker) && !viewer.projectionPicker.isDestroyed() && !val) {
	        viewer.projectionPicker.destroy();
	        viewer._projectionPicker = undefined;
	      } else if (!Cesium.defined(viewer.projectionPicker) || viewer.projectionPicker.isDestroyed()) {
	        var projectionPicker = new Cesium.ProjectionPicker(toolbar, viewer.scene);
	        viewer._projectionPicker = projectionPicker;
	        resizeToolbar(toolbar, projectionPicker);
	      }

	      viewer.widgetResized.raiseEvent();
	    },
	    baseLayerPicker: function baseLayerPicker(val) {
	      var viewer = this.viewer,
	          resizeToolbar = this.resizeToolbar;
	      var toolbar = viewer._toolbar;

	      if (Cesium.defined(viewer.baseLayerPicker) && !viewer.baseLayerPicker.isDestroyed() && !val) {
	        viewer.baseLayerPicker.destroy();
	        viewer._baseLayerPicker = undefined;
	        viewer.imageryLayers.remove(viewer.imageryLayers.get(viewer.imageryLayers.length - 1));
	      } else if (!Cesium.defined(viewer.baseLayerPicker) || viewer.baseLayerPicker.isDestroyed()) {
	        var createBaseLayerPicker = (!Cesium.defined(viewer.globe) || this.globe !== false) && (!Cesium.defined(viewer.baseLayerPicker) || this.baseLayerPicker !== false);

	        if (createBaseLayerPicker && Cesium.defined(this.imageryProvider)) {
	          throw new Cesium.DeveloperError("options.imageryProvider is not available when using the BaseLayerPicker widget.\nEither specify options.selectedImageryProviderViewModel instead or set options.baseLayerPicker to false.");
	        }

	        if (!createBaseLayerPicker && Cesium.defined(this.selectedImageryProviderViewModel)) {
	          throw new Cesium.DeveloperError("options.selectedImageryProviderViewModel is not available when not using the BaseLayerPicker widget.\nEither specify options.imageryProvider instead or set options.baseLayerPicker to true.");
	        }

	        if (createBaseLayerPicker && Cesium.defined(this.terrainProvider)) {
	          throw new Cesium.DeveloperError("options.terrainProvider is not available when using the BaseLayerPicker widget.\nEither specify options.selectedTerrainProviderViewModel instead or set options.baseLayerPicker to false.");
	        }

	        if (!createBaseLayerPicker && Cesium.defined(this.selectedTerrainProviderViewModel)) {
	          throw new Cesium.DeveloperError("options.selectedTerrainProviderViewModel is not available when not using the BaseLayerPicker widget.\nEither specify options.terrainProvider instead or set options.baseLayerPicker to true.");
	        }

	        if (createBaseLayerPicker) {
	          var imageryProviderViewModels = Cesium.defaultValue(this.imageryProviderViewModels, Cesium.createDefaultImageryProviderViewModels());
	          var terrainProviderViewModels = Cesium.defaultValue(this.terrainProviderViewModels, Cesium.createDefaultTerrainProviderViewModels());
	          var baseLayerPicker = new Cesium.BaseLayerPicker(toolbar, {
	            globe: viewer.scene.globe,
	            imageryProviderViewModels: imageryProviderViewModels,
	            selectedImageryProviderViewModel: imageryProviderViewModels[0],
	            terrainProviderViewModels: terrainProviderViewModels,
	            selectedTerrainProviderViewModel: terrainProviderViewModels[0]
	          });
	          var elements = toolbar.getElementsByClassName('cesium-baseLayerPicker-dropDown');
	          var baseLayerPickerDropDown = elements[0];
	          viewer._baseLayerPickerDropDown = baseLayerPickerDropDown;
	          viewer._baseLayerPicker = baseLayerPicker;
	          viewer.imageryLayers.raiseToTop(viewer.imageryLayers.get(0));
	          resizeToolbar(toolbar, baseLayerPicker);
	        }
	      }

	      viewer.widgetResized.raiseEvent();
	    },
	    navigationHelpButton: function navigationHelpButton(val) {
	      var viewer = this.viewer,
	          resizeToolbar = this.resizeToolbar;
	      var toolbar = viewer._toolbar;

	      if (Cesium.defined(viewer.navigationHelpButton) && !viewer.navigationHelpButton.isDestroyed() && !val) {
	        viewer.navigationHelpButton.destroy();
	        viewer._navigationHelpButton = undefined;
	      } else if (!Cesium.defined(viewer.navigationHelpButton) || viewer.navigationHelpButton.isDestroyed()) {
	        var showNavHelp = true;

	        try {
	          if (Cesium.defined(window.localStorage)) {
	            var hasSeenNavHelp = window.localStorage.getItem('cesium-hasSeenNavHelp');

	            if (Cesium.defined(hasSeenNavHelp) && Boolean(hasSeenNavHelp)) {
	              showNavHelp = false;
	            } else {
	              window.localStorage.setItem('cesium-hasSeenNavHelp', 'true');
	            }
	          }
	        } catch (e) {}

	        var navigationHelpButton = new Cesium.NavigationHelpButton({
	          container: toolbar,
	          instructionsInitiallyVisible: Cesium.defaultValue(this.navigationInstructionsInitiallyVisible, showNavHelp)
	        });
	        viewer._navigationHelpButton = navigationHelpButton;
	        resizeToolbar(toolbar, navigationHelpButton);
	      }

	      viewer.widgetResized.raiseEvent();
	    },
	    animation: function animation(val) {
	      var viewer = this.viewer,
	          viewerContainer = this.viewerContainer;

	      if (Cesium.defined(viewer.animation) && !viewer.animation.isDestroyed() && !val) {
	        var animationContainer = viewer.animation.container;
	        viewerContainer.removeChild(animationContainer);
	        viewer.animation.destroy();
	        viewer._animation = undefined;
	      } else if (!Cesium.defined(viewer.animation) || viewer.animation.isDestroyed()) {
	        var _animationContainer = document.createElement('div');

	        _animationContainer.className = 'cesium-viewer-animationContainer';
	        this.viewerContainer.appendChild(_animationContainer);
	        var animation = new Cesium.Animation(_animationContainer, new Cesium.AnimationViewModel(viewer.clockViewModel));
	        animation.viewModel.dateFormatter = this.localeDateTimeFormatter;
	        animation.viewModel.timeFormatter = this.localeTimeFormatter;
	        viewer._animation = animation;
	      }

	      viewer.forceResize();
	      viewer.widgetResized.raiseEvent();
	    },
	    timeline: function timeline(val) {
	      var viewer = this.viewer,
	          viewerContainer = this.viewerContainer,
	          onTimelineScrubfunction = this.onTimelineScrubfunction;

	      if (Cesium.defined(viewer.timeline) && !viewer.timeline.isDestroyed() && !val) {
	        var timelineContainer = viewer.timeline.container;
	        viewerContainer.removeChild(timelineContainer);
	        viewer.timeline.destroy();
	        viewer._timeline = undefined;
	      } else if (!Cesium.defined(viewer.timeline) || viewer.timeline.isDestroyed()) {
	        var _timelineContainer = document.createElement('div');

	        _timelineContainer.className = 'cesium-viewer-timelineContainer';
	        viewerContainer.appendChild(_timelineContainer);
	        var timeline = new Cesium.Timeline(_timelineContainer, viewer.clock);
	        var that = this;

	        timeline.makeLabel = function (time) {
	          return that.localeDateTimeFormatter(time);
	        };

	        timeline.addEventListener('settime', onTimelineScrubfunction, false);
	        timeline.zoomTo(viewer.clock.startTime, viewer.clock.stopTime);
	        viewer._timeline = timeline;
	      }

	      viewer.forceResize();
	      viewer.widgetResized.raiseEvent();
	    },
	    fullscreenButton: function fullscreenButton(val) {
	      var viewer = this.viewer,
	          viewerContainer = this.viewerContainer;

	      if (Cesium.defined(viewer.fullscreenButton) && !viewer.fullscreenButton.isDestroyed() && !val) {
	        var fullscreenContainer = viewer.fullscreenButton.container;
	        viewerContainer.removeChild(fullscreenContainer);
	        viewer.fullscreenButton.destroy();
	        viewer._fullscreenButton = undefined;
	      } else if (!Cesium.defined(viewer.fullscreenButton) || viewer.fullscreenButton.isDestroyed()) {
	        var _fullscreenContainer = document.createElement('div');

	        _fullscreenContainer.className = 'cesium-viewer-fullscreenContainer';
	        viewerContainer.appendChild(_fullscreenContainer);
	        var fullscreenButton = new Cesium.FullscreenButton(_fullscreenContainer, this.$refs.viewer);
	        viewer._fullscreenButton = fullscreenButton;
	      }

	      viewer.forceResize();
	      viewer.widgetResized.raiseEvent();
	    },
	    fullscreenElement: function fullscreenElement(val) {
	      var viewer = this.viewer;

	      if (!Cesium.defined(viewer.fullscreenButton)) {
	        return;
	      }

	      if (Cesium.defined(val)) {
	        this.viewer.fullscreenButton.viewModel.fullscreenElement = val;
	      }
	    },
	    vrButton: function vrButton(val) {
	      var viewer = this.viewer,
	          enableVRUI = this.enableVRUI,
	          viewerContainer = this.viewerContainer;

	      if (Cesium.defined(viewer.vrButton) && !viewer.vrButton.isDestroyed() && !val) {
	        var vrContainer = viewer.vrButton.container;
	        viewerContainer.removeChild(vrContainer);
	        viewer.vrButton.destroy();
	        viewer._vrButton = undefined;
	      } else if (!Cesium.defined(viewer.vrButton) || viewer.vrButton.isDestroyed()) {
	        var _vrContainer = document.createElement('div');

	        _vrContainer.className = 'cesium-viewer-vrContainer';
	        viewerContainer.appendChild(_vrContainer);
	        var vrButton = new Cesium.VRButton(_vrContainer, viewer.scene, viewerContainer);
	        var viewModelCommand = vrButton.viewModel._command;

	        vrButton.viewModel._command = function (VRButtonViewModel) {
	          viewModelCommand();
	          enableVRUI(viewer, VRButtonViewModel.isVRMode);
	        };

	        viewer._vrButton = vrButton;
	      }

	      viewer.forceResize();
	      viewer.widgetResized.raiseEvent();
	    },
	    useDefaultRenderLoop: function useDefaultRenderLoop(val) {
	      this.viewer.useDefaultRenderLoop = val;
	    },
	    sceneMode: function sceneMode(val) {
	      var viewer = this.viewer;

	      if (Cesium.SceneMode.COLUMBUS_VIEW === val || Cesium.SceneMode.MORPHING === val || Cesium.SceneMode.SCENE2D === val || Cesium.SceneMode.SCENE3D === val) {
	        viewer.scene.mode = val;
	      }
	    },
	    shouldAnimate: function shouldAnimate(val) {
	      var viewer = this.viewer;
	      viewer.clock.shouldAnimate = val;
	    },
	    terrainExaggeration: function terrainExaggeration(val) {
	      var viewer = this.viewer;
	      viewer.scene._terrainExaggeration = val;
	    },
	    shadows: function shadows(val) {
	      var viewer = this.viewer;
	      viewer.scene.shadowMap.enabled = val;
	    },
	    terrainProvider: function terrainProvider(val) {
	      var viewer = this.viewer;
	      viewer.terrainProvider = val;
	    },
	    camera: {
	      handler: function handler(val) {
	        this.setCamera(val);
	      },
	      deep: true
	    },
	    imageryProvider: function imageryProvider(val, oldvalue) {
	      var viewer = this.viewer;

	      if (Cesium.defined(val)) {
	        for (var i = 0; i < viewer.imageryLayers.length; i++) {
	          viewer.imageryLayers[i].imageryProvider === oldvalue && viewer.imageryLayers.remove(viewer.imageryLayers[i]);
	        }

	        viewer.imageryLayers.addImageryProvider(val);
	      }
	    }
	  },
	  methods: {
	    onTimelineScrubfunction: function onTimelineScrubfunction(e) {
	      var clock = e.clock;
	      clock.currentTime = e.timeJulian;
	      clock.shouldAnimate = false;
	    },
	    resizeToolbar: function resizeToolbar(parent, child) {
	      Array.prototype.slice.call(parent.children).forEach(function (element) {
	        switch (element.className) {
	          case 'cesium-viewer-geocoderContainer':
	            element.customIndex = 1;
	            break;

	          case 'cesium-button cesium-toolbar-button cesium-home-button':
	            element.customIndex = 2;
	            break;

	          case 'cesium-sceneModePicker-wrapper cesium-toolbar-button':
	            element.customIndex = 3;
	            break;

	          case 'cesium-projectionPicker-wrapper cesium-toolbar-button':
	            element.customIndex = 4;
	            break;

	          case 'cesium-button cesium-toolbar-button':
	          case 'cesium-baseLayerPicker-dropDown':
	            element.customIndex = 5;
	            break;

	          case 'cesium-navigationHelpButton-wrapper':
	            element.customIndex = 6;
	            break;
	        }
	      });
	      var arr = [];
	      Array.prototype.slice.call(parent.children).forEach(function (element) {
	        arr.push(element);
	      });
	      arr.sort(function (a, b) {
	        return a.customIndex - b.customIndex;
	      });

	      for (var i = 0; i < arr.length; i++) {
	        parent.appendChild(arr[i]);
	      }
	    },
	    enableVRUI: function enableVRUI(viewer, enabled) {
	      var geocoder = viewer._geocoder;
	      var homeButton = viewer._homeButton;
	      var sceneModePicker = viewer._sceneModePicker;
	      var projectionPicker = viewer._projectionPicker;
	      var baseLayerPicker = viewer._baseLayerPicker;
	      var animation = viewer._animation;
	      var timeline = viewer._timeline;
	      var fullscreenButton = viewer._fullscreenButton;
	      var infoBox = viewer._infoBox;
	      var selectionIndicator = viewer._selectionIndicator;
	      var visibility = enabled ? 'hidden' : 'visible';

	      if (Cesium.defined(geocoder)) {
	        geocoder.container.style.visibility = visibility;
	      }

	      if (Cesium.defined(homeButton)) {
	        homeButton.container.style.visibility = visibility;
	      }

	      if (Cesium.defined(sceneModePicker)) {
	        sceneModePicker.container.style.visibility = visibility;
	      }

	      if (Cesium.defined(projectionPicker)) {
	        projectionPicker.container.style.visibility = visibility;
	      }

	      if (Cesium.defined(baseLayerPicker)) {
	        baseLayerPicker.container.style.visibility = visibility;
	      }

	      if (Cesium.defined(animation)) {
	        animation.container.style.visibility = visibility;
	      }

	      if (Cesium.defined(timeline)) {
	        timeline.container.style.visibility = visibility;
	      }

	      if (Cesium.defined(fullscreenButton) && fullscreenButton.viewModel.isFullscreenEnabled) {
	        fullscreenButton.container.style.visibility = visibility;
	      }

	      if (Cesium.defined(infoBox)) {
	        infoBox.container.style.visibility = visibility;
	      }

	      if (Cesium.defined(selectionIndicator)) {
	        selectionIndicator.container.style.visibility = visibility;
	      }

	      if (viewer._container) {
	        var right = enabled || !Cesium.defined(fullscreenButton) ? 0 : fullscreenButton.container.clientWidth;
	        viewer._vrButton.container.style.right = right + 'px';
	        viewer.forceResize();
	      }
	    },
	    init: function init() {
	      if (this._mounted) {
	        return false;
	      }

	      this.Cesium = Cesium;
	      var $el = this.$refs.viewer;
	      var accessToken = this.accessToken ? this.accessToken : typeof this._Cesium !== 'undefined' && Object.prototype.hasOwnProperty.call(this._Cesium(), 'accessToken') ? this._Cesium().accessToken : this.accessToken;
	      Cesium.Ion.defaultAccessToken = accessToken;
	      var animation = this.animation,
	          baseLayerPicker = this.baseLayerPicker,
	          fullscreenButton = this.fullscreenButton,
	          vrButton = this.vrButton,
	          geocoder = this.geocoder,
	          homeButton = this.homeButton,
	          infoBox = this.infoBox,
	          sceneModePicker = this.sceneModePicker,
	          selectionIndicator = this.selectionIndicator,
	          timeline = this.timeline,
	          navigationHelpButton = this.navigationHelpButton,
	          navigationInstructionsInitiallyVisible = this.navigationInstructionsInitiallyVisible,
	          scene3DOnly = this.scene3DOnly,
	          shouldAnimate = this.shouldAnimate,
	          clockViewModel = this.clockViewModel,
	          selectedImageryProviderViewModel = this.selectedImageryProviderViewModel,
	          imageryProviderViewModels = this.imageryProviderViewModels,
	          selectedTerrainProviderViewModel = this.selectedTerrainProviderViewModel,
	          terrainProviderViewModels = this.terrainProviderViewModels,
	          imageryProvider = this.imageryProvider,
	          terrainProvider = this.terrainProvider,
	          skyBox = this.skyBox,
	          skyAtmosphere = this.skyAtmosphere,
	          fullscreenElement = this.fullscreenElement,
	          useDefaultRenderLoop = this.useDefaultRenderLoop,
	          targetFrameRate = this.targetFrameRate,
	          showRenderLoopErrors = this.showRenderLoopErrors,
	          automaticallyTrackDataSourceClocks = this.automaticallyTrackDataSourceClocks,
	          contextOptions = this.contextOptions,
	          sceneMode = this.sceneMode,
	          mapProjection = this.mapProjection,
	          globe = this.globe,
	          orderIndependentTranslucency = this.orderIndependentTranslucency,
	          creditContainer = this.creditContainer,
	          creditViewport = this.creditViewport,
	          dataSources = this.dataSources,
	          terrainExaggeration = this.terrainExaggeration,
	          shadows = this.shadows,
	          terrainShadows = this.terrainShadows,
	          mapMode2D = this.mapMode2D,
	          projectionPicker = this.projectionPicker,
	          requestRenderMode = this.requestRenderMode,
	          maximumRenderTimeChange = this.maximumRenderTimeChange,
	          navigation = this.navigation,
	          registerEvents = this.registerEvents;
	      var url = Cesium.buildModuleUrl('Assets/Textures/NaturalEarthII');
	      var options = {
	        animation: animation,
	        baseLayerPicker: baseLayerPicker,
	        fullscreenButton: fullscreenButton,
	        vrButton: vrButton,
	        geocoder: geocoder,
	        homeButton: homeButton,
	        infoBox: infoBox,
	        sceneModePicker: sceneModePicker,
	        selectionIndicator: selectionIndicator,
	        timeline: timeline,
	        navigationHelpButton: navigationHelpButton,
	        navigationInstructionsInitiallyVisible: navigationInstructionsInitiallyVisible,
	        scene3DOnly: scene3DOnly,
	        shouldAnimate: shouldAnimate,
	        clockViewModel: clockViewModel,
	        selectedImageryProviderViewModel: selectedImageryProviderViewModel,
	        imageryProviderViewModels: imageryProviderViewModels,
	        selectedTerrainProviderViewModel: selectedTerrainProviderViewModel,
	        terrainProviderViewModels: terrainProviderViewModels,
	        imageryProvider: this.isEmptyObj(imageryProvider) ? Cesium.defined(Cesium.TileMapServiceImageryProvider) ? new Cesium.TileMapServiceImageryProvider({
	          url: url
	        }) : Cesium.createTileMapServiceImageryProvider({
	          url: url
	        }) : imageryProvider,
	        terrainProvider: terrainProvider,
	        skyBox: skyBox,
	        skyAtmosphere: skyAtmosphere,
	        fullscreenElement: this.isEmptyObj(fullscreenElement) ? this.$refs.viewer : fullscreenElement,
	        useDefaultRenderLoop: useDefaultRenderLoop,
	        targetFrameRate: targetFrameRate,
	        showRenderLoopErrors: showRenderLoopErrors,
	        automaticallyTrackDataSourceClocks: automaticallyTrackDataSourceClocks,
	        contextOptions: contextOptions,
	        sceneMode: sceneMode,
	        mapProjection: mapProjection,
	        globe: globe,
	        orderIndependentTranslucency: orderIndependentTranslucency,
	        creditContainer: creditContainer,
	        creditViewport: creditViewport,
	        dataSources: dataSources,
	        terrainExaggeration: terrainExaggeration,
	        shadows: shadows,
	        terrainShadows: terrainShadows,
	        mapMode2D: mapMode2D,
	        projectionPicker: projectionPicker,
	        requestRenderMode: requestRenderMode,
	        maximumRenderTimeChange: maximumRenderTimeChange,
	        navigation: navigation
	      };
	      this.removeNullItem(options);
	      var viewer = {};

	      if (!global.XE) {
	        viewer = new Cesium.Viewer($el, options);
	      } else {
	        this.earth = new global.XE.Earth($el, options);
	        viewer = this.earth.czm.viewer;
	      }

	      this.viewer = viewer;

	      if (Cesium.defined(this.camera)) {
	        this.setCamera(this.camera);
	      }

	      var that = this;
	      viewer.camera.changed.addEventListener(function () {
	        var listener = that.$listeners['update:camera'];
	        var cartographic = viewer.camera.positionCartographic;
	        var camera;

	        if (that.camera.position.lng) {
	          camera = {
	            position: {
	              lng: Cesium.Math.toDegrees(cartographic.longitude),
	              lat: Cesium.Math.toDegrees(cartographic.latitude),
	              height: cartographic.height
	            },
	            heading: Cesium.Math.toDegrees(viewer.camera.heading),
	            pitch: Cesium.Math.toDegrees(viewer.camera.pitch),
	            roll: Cesium.Math.toDegrees(viewer.camera.roll)
	          };
	        } else {
	          camera = {
	            position: {
	              x: viewer.camera.position.x,
	              y: viewer.camera.position.y,
	              z: viewer.camera.position.z
	            },
	            heading: viewer.camera.heading,
	            pitch: viewer.camera.pitch,
	            roll: viewer.camera.roll
	          };
	        }

	        if (listener) {
	          that.$emit('update:camera', camera);
	        }
	      });

	      if (Cesium.defined(viewer.animation)) {
	        viewer.animation.viewModel.dateFormatter = this.localeDateTimeFormatter;
	        viewer.animation.viewModel.timeFormatter = this.localeTimeFormatter;
	      }

	      if (Cesium.defined(viewer.timeline)) {
	        viewer.timeline.makeLabel = function (time) {
	          return that.localeDateTimeFormatter(time);
	        };

	        viewer.timeline.zoomTo(viewer.clock.startTime, viewer.clock.stopTime);
	      }

	      this.viewerContainer = viewer._element;

	      if (Cesium.defined(Cesium.SuperMapImageryProvider) && !this.logo) {
	        var credit = viewer.scene.frameState.creditDisplay;
	        credit.container.removeChild(credit._imageContainer);
	      }

	      if (!this.logo) {
	        viewer.cesiumWidget.creditContainer.style.display = 'none';
	      }

	      viewer.widgetResized = new Cesium.Event();
	      viewer.imageryLayers.layerAdded.addEventListener(this.layerAdded);
	      registerEvents(true);
	      global.XE ? this.$emit('ready', {
	        Cesium: Cesium,
	        viewer: viewer,
	        earth: this.earth
	      }) : this.$emit('ready', {
	        Cesium: Cesium,
	        viewer: viewer
	      });
	      this._mounted = true;

	      this._resolve({
	        Cesium: Cesium,
	        viewer: viewer
	      });

	      return {
	        Cesium: Cesium,
	        viewer: viewer
	      };
	    },
	    setCamera: function setCamera(val) {
	      var viewer = this.viewer;
	      var position = val.position;

	      if (position.lng && position.lat) {
	        viewer.camera.setView({
	          destination: Cesium.Cartesian3.fromDegrees(position.lng, position.lat, position.height || 0),
	          orientation: {
	            heading: Cesium.Math.toRadians(val.heading || 360),
	            pitch: Cesium.Math.toRadians(val.pitch || -90),
	            roll: Cesium.Math.toRadians(val.roll || 0)
	          }
	        });
	      } else if (position.x && position.y && position.z) {
	        viewer.camera.setView({
	          destination: new Cesium.Cartesian3(position.x, position.y, position.z),
	          orientation: {
	            heading: val.heading || 2 * Math.PI,
	            pitch: val.pitch || -Math.PI / 2,
	            roll: val.roll || 0
	          }
	        });
	      }
	    },
	    layerAdded: function layerAdded(layer) {
	      var viewer = this.viewer,
	          autoSortImageryLayers = this.autoSortImageryLayers;

	      if (viewer.baseLayerPicker) {
	        viewer.imageryLayers.raiseToTop(layer);
	      } // 维护影像图层顺序


	      if (autoSortImageryLayers) {
	        layer.sortOrder = Cesium.defined(layer.sortOrder) ? layer.sortOrder : 9999;

	        viewer.imageryLayers._layers.sort(function (a, b) {
	          return a.sortOrder - b.sortOrder;
	        });

	        viewer.imageryLayers._update();
	      }
	    },
	    localeDateTimeFormatter: function localeDateTimeFormatter(datetime, viewModel, ignoredate) {
	      if (this.UTCoffset) {
	        datetime = Cesium.JulianDate.addMinutes(datetime, this.UTCoffset, {});
	      }

	      var gregorianDT = Cesium.JulianDate.toGregorianDate(datetime);
	      var objDT;

	      if (ignoredate) {
	        objDT = '';
	      } else {
	        objDT = new Date(gregorianDT.year, gregorianDT.month - 1, gregorianDT.day);

	        if (this.$vc.lang.isoName === 'zh-hans') {
	          objDT = gregorianDT.year + '年' + objDT.toLocaleString(this.$vc.lang.isoName, {
	            month: 'short'
	          }) + gregorianDT.day + '日';
	        } else {
	          objDT = gregorianDT.day + ' ' + objDT.toLocaleString(this.$vc.lang.isoName, {
	            month: 'short'
	          }) + ' ' + gregorianDT.year;
	        }

	        if (viewModel || gregorianDT.hour + gregorianDT.minute === 0) {
	          return objDT;
	        }

	        objDT += ' ';
	      }

	      return objDT + Cesium.sprintf('%02d:%02d:%02d ' + this.TZcode, gregorianDT.hour, gregorianDT.minute, gregorianDT.second);
	    },
	    localeTimeFormatter: function localeTimeFormatter(time, viewModel) {
	      return this.localeDateTimeFormatter(time, viewModel, true);
	    },
	    registerEvents: function registerEvents(flag) {
	      var viewer = this.viewer;
	      bindEvents.call(this, viewer, undefined, flag);
	      var that = this;
	      Events['viewer-property-events'].forEach(function (eventName) {
	        var instance = isArray(eventName.name) && viewer[eventName.name[0]] ? viewer[eventName.name[0]][eventName.name[1]] : viewer[eventName.name];
	        instance && bindEvents.call(that, instance, eventName.events, flag);
	      });
	      var handler = new Cesium.ScreenSpaceEventHandler(viewer.canvas);
	      Events['viewer-mouse-events'].forEach(function (eventName) {
	        var listener = that.$listeners[eventName] || that.$listeners[eventName.toLowerCase()];

	        if (flag) {
	          listener && handler.setInputAction(listener.fns, Cesium.ScreenSpaceEventType[eventName]);
	        } else {
	          listener && handler.removeInputAction(Cesium.ScreenSpaceEventType[eventName]);
	        }
	      });
	    },
	    getServices: function getServices() {
	      var vm = this;
	      return multiMergeDescriptors({}, {
	        get viewerContainer() {
	          return vm;
	        },

	        get Cesium() {
	          return vm.Cesium;
	        },

	        get viewer() {
	          return vm.viewer;
	        },

	        get dataSources() {
	          return vm.dataSources;
	        },

	        get entities() {
	          return vm.entities;
	        },

	        get imageryLayers() {
	          return vm.imageryLayers;
	        },

	        get primitives() {
	          return vm.primitives;
	        },

	        get groundPrimitives() {
	          return vm.groundPrimitives;
	        },

	        get postProcessStages() {
	          return vm.postProcessStages;
	        }

	      });
	    },
	    getCesiumScript: function getCesiumScript() {
	      if (!global.Cesium) {
	        var cesiumPath = this.cesiumPath ? this.cesiumPath : typeof this._Cesium !== 'undefined' && Object.prototype.hasOwnProperty.call(this._Cesium(), 'cesiumPath') ? this._Cesium().cesiumPath : 'https://unpkg.com/cesium/Build/Cesium/Cesium.js';
	        var dirName = dirname(cesiumPath); // 引入样式 earthsdk 会自动引 不用引入了

	        if (cesiumPath.indexOf('/XbsjEarth.js') === -1) {
	          var $link = document.createElement('link');
	          $link.rel = 'stylesheet';
	          global.document.head.appendChild($link);
	          $link.href = "".concat(dirName, "/Widgets/widgets.css");
	        }

	        var $script = document.createElement('script');
	        global.document.body.appendChild($script);
	        $script.src = cesiumPath;
	        return new promise$1(function (resolve, reject) {
	          $script.onload = function () {
	            if (global.Cesium) {
	              // 超图WebGL3D需要引入zlib.min.js
	              if (Cesium.SuperMapImageryProvider && Number(Cesium.VERSION) < 1.54) {
	                var $scriptZlib = document.createElement('script');
	                global.document.body.appendChild($scriptZlib);
	                $scriptZlib.src = "".concat(dirName, "/Workers/zlib.min.js");
	              }

	              resolve(global.Cesium);
	            } else if (global.XE) {
	              // 兼容 cesiumlab earthsdk
	              global.XE.ready().then(function () {
	                resolve(global.Cesium);
	              });
	            } else {
	              reject(new Error('[VueCesium] ERROR: ' + 'Error loading CesiumJS!'));
	            }
	          };
	        });
	      } else {
	        return promise$1.resolve(global.Cesium);
	      }
	    },
	    beforeInit: function beforeInit() {
	      return regenerator.async(function beforeInit$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              // Make sure to add only one CesiumJS script tag
	              // 保证只添加一个CesiumJS标签
	              this.$vc.scriptPromise = this.$vc.scriptPromise || this.getCesiumScript();
	              _context.next = 3;
	              return regenerator.awrap(this.$vc.scriptPromise);

	            case 3:
	            case "end":
	              return _context.stop();
	          }
	        }
	      }, null, this);
	    }
	  },
	  mounted: function mounted() {
	    var _this = this;

	    var init = this.init,
	        beforeInit = this.beforeInit;
	    var that = this;
	    beforeInit().then(function () {
	      var listener = that.$listeners.cesiumReady;
	      listener && _this.$emit('cesiumReady', Cesium);
	      that.$nextTick(function () {
	        init();
	      });
	    }); // .catch((e) => _reject(new Error(`[VueCesium] ERROR: ` + 'An error occurred during the initialization of the Viewer!')))
	  },
	  created: function created() {
	    var _this2 = this;

	    this._mounted = false; // this._createPromise = Promise.resolve(this.beforeInit())
	    // 注释上面方法，测试发现在切换路由时，实测 Vue 生命周期是先触发新组件的 created，再触发旧组件的 destroyed，再触发新组件的 mounted 。
	    // 逻辑就是先创建新的 然后销毁旧的，但虽然销毁的是旧的 还是会把新的给影响。
	    // 因此 viewer 组件的加载方式还是放 mounted，这样就先销毁旧的再加载新的。
	    // 但为了外部能取得 createPromise，_createPromise的初始化还是要放created中。

	    var that = this;
	    this._createPromise = new promise$1(function (resolve, reject) {
	      that._resolve = resolve;
	      that._reject = reject;
	    });

	    defineProperties$1(this, {
	      createPromise: {
	        enumerable: true,
	        get: function get() {
	          return _this2._createPromise;
	        }
	      },
	      cesiumObject: {
	        enumerable: true,
	        get: function get() {
	          return _this2.viewer;
	        }
	      },
	      dataSources: {
	        enumerable: true,
	        get: function get() {
	          return _this2.viewer && _this2.viewer.dataSources;
	        }
	      },
	      entities: {
	        enumerable: true,
	        get: function get() {
	          return _this2.viewer && _this2.viewer.entities;
	        }
	      },
	      imageryLayers: {
	        enumerable: true,
	        get: function get() {
	          return _this2.viewer && _this2.viewer.imageryLayers;
	        }
	      },
	      primitives: {
	        enumerable: true,
	        get: function get() {
	          return _this2.viewer && _this2.viewer.scene.primitives;
	        }
	      },
	      groundPrimitives: {
	        enumerable: true,
	        get: function get() {
	          return _this2.viewer && _this2.viewer.scene.groundPrimitives;
	        }
	      },
	      postProcessStages: {
	        enumerable: true,
	        get: function get() {
	          return _this2.viewer && _this2.viewer.scene.postProcessStages;
	        }
	      }
	    });
	  },
	  destroyed: function destroyed() {
	    var viewer = this.viewer,
	        removeCesiumScript = this.removeCesiumScript,
	        earth = this.earth,
	        registerEvents = this.registerEvents;
	    registerEvents(false);
	    this.$vc._screenSpaceEventHandler && this.$vc._screenSpaceEventHandler.destroy();
	    global.XE ? earth && earth.destroy() : viewer && viewer.destroy();
	    this.viewer = undefined;
	    this._mounted = false;
	    this.$vc._screenSpaceEventHandler = undefined;

	    if (removeCesiumScript && global.Cesium) {
	      var scripts = document.getElementsByTagName('script');
	      var removeScripts = [];
	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;

	      try {
	        for (var _iterator = getIterator$1(scripts), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var script = _step.value;
	          script.src.indexOf('/Cesium.js') > -1 && removeScripts.push(script);
	          script.src.indexOf('/Workers/zlib.min.js') > -1 && removeScripts.push(script);

	          if (global.XE) {
	            script.src.indexOf('/rxjs.umd.min.js') > -1 && removeScripts.push(script);
	            script.src.indexOf('/XbsjCesium.js') > -1 && removeScripts.push(script);
	            script.src.indexOf('/viewerCesiumNavigationMixin.js') > -1 && removeScripts.push(script);
	            script.src.indexOf('/XbsjEarth.js') > -1 && removeScripts.push(script);
	          }
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return != null) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }

	      removeScripts.forEach(function (script) {
	        script.parentNode.removeChild(script);
	      });
	      var links = document.getElementsByTagName('link');
	      var _iteratorNormalCompletion2 = true;
	      var _didIteratorError2 = false;
	      var _iteratorError2 = undefined;

	      try {
	        for (var _iterator2 = getIterator$1(links), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	          var link = _step2.value;

	          if (link.href.indexOf('Widgets/widgets.css') > -1) {
	            document.getElementsByTagName('head')[0].removeChild(link);
	          }
	        }
	      } catch (err) {
	        _didIteratorError2 = true;
	        _iteratorError2 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
	            _iterator2.return();
	          }
	        } finally {
	          if (_didIteratorError2) {
	            throw _iteratorError2;
	          }
	        }
	      }

	      global.Cesium && (global.Cesium = undefined);
	      global.XbsjCesium && (global.XbsjCesium = undefined);
	      global.XbsjEarth && (global.XbsjEarth = undefined);
	      global.XE && (global.XE = undefined);
	      this.$vc.scriptPromise = undefined;
	    }
	  }
	};

	/* script */
	var __vue_script__ = script;
	/* template */

	var __vue_render__ = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('div', {
	    ref: "viewer",
	    staticStyle: {
	      "width": "100%",
	      "height": "100%"
	    },
	    attrs: {
	      "id": "cesiumContainer"
	    }
	  }, [_vm._t("default")], 2);
	};

	var __vue_staticRenderFns__ = [];
	/* style */

	var __vue_inject_styles__ = undefined;
	/* scoped */

	var __vue_scope_id__ = undefined;
	/* functional template */

	var __vue_is_functional_template__ = false;
	/* component normalizer */

	function __vue_normalize__(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "Viewer.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var Viewer = __vue_normalize__({
	  render: __vue_render__,
	  staticRenderFns: __vue_staticRenderFns__
	}, __vue_inject_styles__, __vue_script__, __vue_scope_id__, __vue_is_functional_template__);

	var langZh = {
	  isoName: 'zh-hans',
	  nativeName: '中文(简体)',
	  measure: {
	    distance: '距离',
	    area: '面积',
	    horizontalDistance: '水平距离',
	    spaceDistance: '空间距离',
	    verticalHeight: '垂直高度'
	  },
	  draw: {
	    drawingTip1: '单击左键绘制起点。',
	    drawingTip2: '单击左键绘制下一个点，单击右键结束绘制。',
	    drawingTip3: '单击结束编辑。',
	    editingMove: '移动节点',
	    editingInsert: '插入节点',
	    editingDelete: '删除节点'
	  },
	  navigation: {
	    compass: {
	      description: '拖拽罗盘外环: 旋转视图。\n拖拽罗盘陀螺仪: 翻转视图。\n双击罗盘: 重置视图。\n提示: 您也可以通过按住Ctrl键的同时拖拽地图来改变地图倾角。',
	      title: '旋转相机'
	    },
	    zoomCotrol: {
	      zoomIn: '放大',
	      zoomReset: '重置视图',
	      zoomOut: '缩小'
	    },
	    legend: {
	      lat: '纬度',
	      lon: '经度',
	      zone: '带号',
	      e: 'X',
	      n: 'Y',
	      elev: '高程',
	      cameraHeight: '相机高度'
	    },
	    printView: '打印分享',
	    centreMap: '定位您的位置'
	  },
	  overviewmap: {
	    show: '显示鹰眼',
	    hidden: '隐藏鹰眼'
	  }
	};

	var lang = {
	  install: function install($vc, lang) {
	    var _this = this;

	    this.set = function () {
	      var lang = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : langZh;
	      lang.set = _this.set;
	      lang.getLocale = _this.getLocale;
	      lang.rtl = lang.rtl === true || false;
	      var el = document.documentElement;
	      el.setAttribute('dir', lang.rtl ? 'rtl' : 'ltr');
	      el.setAttribute('lang', lang.isoName);

	      if ($vc.lang !== undefined) {
	        $vc.lang = lang;
	      } else {
	        Vue.util.defineReactive($vc, 'lang', lang);
	      }

	      _this.isoName = lang.isoName;
	      _this.nativeName = lang.nativeName;
	      _this.props = lang;
	    };

	    this.set(lang);
	  },
	  getLocale: function getLocale() {
	    var val = navigator.language || navigator.languages[0] || navigator.browserLanguage || navigator.userLanguage || navigator.systemLanguage;

	    if (val) {
	      return val.toLowerCase();
	    }
	  }
	};

	function plugin(Vue) {
	  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	  if (plugin.installed) {
	    return;
	  }

	  var $vc = {
	    VERSION: '2.2.0'
	  };
	  Vue.prototype.$vc = Vue.prototype.$vc || $vc;

	  if (!Vue.prototype.$vc.lang) {
	    lang.install($vc, options.lang);
	  }

	  plugin.installed = true;

	  Vue.prototype._Cesium = function () {
	    return options;
	  };

	  Vue.component(Viewer.name, Viewer);
	}

	var Viewer$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin,
		Viewer: Viewer,
		install: plugin
	});

	// 19.1.2.1 Object.assign(target, source, ...)






	var $assign = Object.assign;

	// should work with symbols and should have deterministic property order (V8 bug)
	var _objectAssign = !$assign || _fails(function () {
	  var A = {};
	  var B = {};
	  // eslint-disable-next-line no-undef
	  var S = Symbol();
	  var K = 'abcdefghijklmnopqrst';
	  A[S] = 7;
	  K.split('').forEach(function (k) { B[k] = k; });
	  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
	}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
	  var T = _toObject(target);
	  var aLen = arguments.length;
	  var index = 1;
	  var getSymbols = _objectGops.f;
	  var isEnum = _objectPie.f;
	  while (aLen > index) {
	    var S = _iobject(arguments[index++]);
	    var keys = getSymbols ? _objectKeys(S).concat(getSymbols(S)) : _objectKeys(S);
	    var length = keys.length;
	    var j = 0;
	    var key;
	    while (length > j) {
	      key = keys[j++];
	      if (!_descriptors || isEnum.call(S, key)) T[key] = S[key];
	    }
	  } return T;
	} : $assign;

	// 19.1.3.1 Object.assign(target, source)


	_export(_export.S + _export.F, 'Object', { assign: _objectAssign });

	var assign = _core.Object.assign;

	var assign$1 = assign;

	/**
	 * 将对象或数组转换为 Cesium.Cartesian2
	 * @param {Object} val
	 * @returns {Cartesian2 | CallbackProperty} 返回 Cartesian2 或者 CallbackProperty
	 * @example
	 * const options = [100, 100]
	 * // const options = [x: 100, y: 100]
	 * const position = makeCartesian2(options)
	 */

	function makeCartesian2(val) {
	  var isConstant = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	  var _Cesium = Cesium,
	      Cartesian2 = _Cesium.Cartesian2,
	      CallbackProperty = _Cesium.CallbackProperty;

	  if (val instanceof Cartesian2) {
	    return val;
	  }

	  if (isObject(val) && Object.prototype.hasOwnProperty.call(val, 'x')) {
	    return new Cartesian2(val.x, val.y);
	  }

	  if (isArray(val)) {
	    return new Cartesian2(val[0], val[1]);
	  }

	  if (isFunction(val)) {
	    return new CallbackProperty(val, isConstant);
	  }

	  return val;
	}
	/**
	 * 将对象或者数组转换为 Cesium.Cartesian3
	 * @param {Object} val 传入的对象或数组
	 * @param {Boolean} isConstant 传入function时生效，true 代表回调 function 每时每刻都返回值， false 代表改变才会返回值。默认false。
	 * @returns 返回 Cartesian3 或者 CallbackProperty
	 * @example
	 * const options = {
	 *  lng: 108,
	 *  lat: 35,
	 *  height: 1000
	 * }
	 * // const options = [108, 35, 1000]
	 * const position = makeCartesian3 (options) // return Cesium.Cartesian3
	 */

	function makeCartesian3(val) {
	  var isConstant = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	  var _Cesium2 = Cesium,
	      CallbackProperty = _Cesium2.CallbackProperty,
	      Cartesian3 = _Cesium2.Cartesian3;

	  if (val instanceof Cartesian3) {
	    return val;
	  }

	  if (isObject(val)) {
	    if (Object.prototype.hasOwnProperty.call(val, 'x')) {
	      return new Cartesian3(val.x, val.y, val.z || 0);
	    } else if (Object.prototype.hasOwnProperty.call(val, 'lng')) {
	      return Cartesian3.fromDegrees(val.lng, val.lat, val.height || 0);
	    }
	  }

	  if (isArray(val)) {
	    return new Cartesian3(val[0], val[1], val[2] || 0);
	  }

	  if (isFunction(val)) {
	    return new CallbackProperty(val, isConstant);
	  }

	  return val;
	}
	/**
	 * 将数组 [lng, lat, height, ……，lng, lat, height] 转换为 Cesium.Cartesian3 数组
	 * @param {Array} val
	 * @returns {Array<Cartesian3>}
	 */

	function makeCartesian3Array(vals) {
	  var isConstant = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	  var _Cesium3 = Cesium,
	      CallbackProperty = _Cesium3.CallbackProperty,
	      Cartesian3 = _Cesium3.Cartesian3;

	  if (isArray(vals)) {
	    if (vals[0] instanceof Cartesian3 || vals._callback) {
	      return vals;
	    }

	    if (isArray(vals[0])) {
	      var coordinates = [];

	      for (var i = 0; i < vals.length; i++) {
	        coordinates.push(vals[i][0]);
	        coordinates.push(vals[i][1]);
	        coordinates.push(vals[i][2] || 0);
	      }

	      return Cartesian3.fromRadiansArrayHeights(coordinates);
	    } else if (isObject(vals[0])) {
	      var _coordinates = [];

	      if (vals[0].lng) {
	        vals.forEach(function (item) {
	          _coordinates.push(item.lng);

	          _coordinates.push(item.lat);

	          _coordinates.push(item.height || 0);
	        });
	        return Cartesian3.fromDegreesArrayHeights(_coordinates);
	      } else {
	        if (vals[0].x) {
	          vals.forEach(function (item) {
	            _coordinates.push(item.x);

	            _coordinates.push(item.y);

	            _coordinates.push(item.z || 0);
	          });
	          return Cartesian3.fromRadiansArrayHeights(_coordinates);
	        }
	      }
	    }

	    return Cartesian3.fromDegreesArrayHeights(vals);
	  }

	  if (isFunction(vals)) {
	    return new CallbackProperty(vals, isConstant);
	  }

	  return vals;
	}
	/**
	 * 将形如 [lng, lat, ……，lng, lat] 数组转换为 Cesium.Cartesian2 数组
	 * @param {Array} vals
	 * @returns {Array<Cartesian2>}
	 */

	function makeCartesian2Array(vals, isConstant) {
	  var _Cesium4 = Cesium,
	      CallbackProperty = _Cesium4.CallbackProperty,
	      Cartesian2 = _Cesium4.Cartesian2;

	  if (isArray(vals)) {
	    if (vals[0] instanceof Cartesian2 || vals._callback) {
	      return vals;
	    }

	    if (isObject(vals[0])) {
	      var cartesian2Array = [];
	      vals.forEach(function (item) {
	        cartesian2Array.push(new Cartesian2(item.x, item.y));
	      });
	      return cartesian2Array;
	    }
	  }

	  if (isFunction(vals)) {
	    return new CallbackProperty(vals, isConstant);
	  }

	  return vals;
	}
	/**
	 * 将对象或数组 转换为 Cesium.Quaternion
	 * @param {Object} val
	 * @example
	 * const options = {x: 0, y: 0, z: 0, w: 0}
	 * // const options = [0, 0, 0, 0]
	 * const orientation = makeQuaternion(options) // returns Cesium.Quaternion
	 */

	function makeQuaternion(val) {
	  var isConstant = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	  var _Cesium5 = Cesium,
	      CallbackProperty = _Cesium5.CallbackProperty,
	      Quaternion = _Cesium5.Quaternion;

	  if (val instanceof Quaternion) {
	    return val;
	  }

	  if (isObject(val) && Object.prototype.hasOwnProperty.call(val, 'x')) {
	    return new Quaternion(val.x, val.y, val.z, val.w);
	  }

	  if (isArray(val)) {
	    return new Quaternion(val[0], val[1], val[2], val[3]);
	  }

	  if (isFunction(val)) {
	    return new CallbackProperty(val, isConstant);
	  }

	  return val;
	}
	/**
	 * 解析 HierarchyJson
	 * @param {Object} val
	 */

	function parsePolygonHierarchyJson(val) {
	  val.forEach(function (element) {
	    element.positions = makeCartesian3Array(element.positions);

	    if (element.holes) {
	      parsePolygonHierarchyJson(element.holes);
	    }
	  });
	}
	/**
	 * 普通数组或对象转 Cesium.PolygonHierarchy 对象。
	 * @param {Object|Array} val
	 */


	function makePolygonHierarchy(val) {
	  var isConstant = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	  var _Cesium6 = Cesium,
	      PolygonHierarchy = _Cesium6.PolygonHierarchy,
	      CallbackProperty = _Cesium6.CallbackProperty;

	  if (val instanceof PolygonHierarchy) {
	    return val;
	  }

	  if (isFunction(val)) {
	    return new CallbackProperty(val, isConstant);
	  }

	  if (isArray(val) && val.length >= 3) {
	    return new PolygonHierarchy(makeCartesian3Array(val));
	  }

	  if (Cesium.defined(val.positions)) {
	    val.positions = makeCartesian3Array(val.positions);
	    parsePolygonHierarchyJson(val.holes);
	  }

	  return val;
	}
	/**
	 * 对象或数组转 Cesium.NearFarScalar。
	 * @param {Object} val
	 * @returns {NearFarScalar}
	 * @example
	 * const options = {near: 1000, nearValue: 1.0, far: 10000, farValue: 0.5}
	 * // const options = [1000, 1.0, 10000, 1.5]
	 * const nearFarScalar = makeNearFarScalar(options)
	 */

	function makeNearFarScalar(val) {
	  var isConstant = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	  var _Cesium7 = Cesium,
	      NearFarScalar = _Cesium7.NearFarScalar,
	      CallbackProperty = _Cesium7.CallbackProperty;

	  if (val instanceof NearFarScalar) {
	    return val;
	  }

	  if (isObject(val) && Object.prototype.hasOwnProperty.call(val, 'near')) {
	    return new NearFarScalar(val.near, val.nearValue, val.far, val.farValue);
	  }

	  if (isArray(val)) {
	    return new NearFarScalar(val[0], val[1], val[2], val[3]);
	  }

	  if (isFunction(val)) {
	    return new CallbackProperty(val, isConstant);
	  }

	  return val;
	}
	/**
	 * 对象或数组转 Cesium.DistanceDisplayCondition。
	 * @param {Object} val
	 * @returns {DistanceDisplayCondition}
	 * @example
	 * const options = [0, 1000]
	 * // const options = {near: 0, far: 1000}
	 * const distanceDisplayCondition = makeDistanceDisplayCondition(options) // return Cesium.DistanceDisplayCondition
	 */

	function makeDistanceDisplayCondition(val) {
	  var isConstant = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	  var _Cesium8 = Cesium,
	      DistanceDisplayCondition = _Cesium8.DistanceDisplayCondition,
	      CallbackProperty = _Cesium8.CallbackProperty;

	  if (val instanceof DistanceDisplayCondition) {
	    return val;
	  }

	  if (isObject(val) && Object.prototype.hasOwnProperty.call(val, 'near')) {
	    return new DistanceDisplayCondition(val.near, val.far);
	  }

	  if (isArray(val)) {
	    return new DistanceDisplayCondition(val[0], val[1]);
	  }

	  if (isFunction(val)) {
	    return new CallbackProperty(val, isConstant);
	  }

	  return val;
	}
	/**
	 * 普通对象、数组或字符串转 Cesium.Color。
	 * @param {String|Array|Object|Function} val
	 * @returns {Color}
	 * @example
	 * const options = 'red'
	 * // const options = [1, 0, 0, 1.0] // r g b a
	 * // const options = {red: 255, green: 0, bule: 0, alpha: 255}
	 * const color = makeColor(options) // return Cesium.Color
	 */

	function makeColor(val) {
	  var isConstant = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	  var _Cesium9 = Cesium,
	      Color = _Cesium9.Color,
	      CallbackProperty = _Cesium9.CallbackProperty;

	  if (val instanceof Color) {
	    return val;
	  }

	  if (isString(val)) {
	    return Color.fromCssColorString(val);
	  }

	  if (isObject(val) && Object.prototype.hasOwnProperty.call(val, 'red')) {
	    return Color.fromBytes(val.red, val.green, val.blue, val.alpha || 255);
	  }

	  if (isArray(val)) {
	    return new Cesium.Color(val[0], val[1], val[2], val[3] || 1.0);
	  }

	  if (isFunction(val)) {
	    return new CallbackProperty(val, isConstant);
	  }
	}
	/**
	 * 普通对象或数组 [r, g, b, a] 或字符串转 MaterialProperty
	 * @param {String|Array|Object} val
	 */

	function makeMaterialProperty(val) {
	  var isConstant = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	  var _Cesium10 = Cesium,
	      CallbackProperty = _Cesium10.CallbackProperty,
	      Color = _Cesium10.Color,
	      Resource = _Cesium10.Resource,
	      ColorMaterialProperty = _Cesium10.ColorMaterialProperty,
	      ImageMaterialProperty = _Cesium10.ImageMaterialProperty,
	      PolylineArrowMaterialProperty = _Cesium10.PolylineArrowMaterialProperty,
	      PolylineDashMaterialProperty = _Cesium10.PolylineDashMaterialProperty,
	      PolylineGlowMaterialProperty = _Cesium10.PolylineGlowMaterialProperty,
	      PolylineOutlineMaterialProperty = _Cesium10.PolylineOutlineMaterialProperty,
	      CheckerboardMaterialProperty = _Cesium10.CheckerboardMaterialProperty,
	      GridMaterialProperty = _Cesium10.GridMaterialProperty,
	      StripeMaterialProperty = _Cesium10.StripeMaterialProperty;

	  if (/(.*)\.(jpg|bmp|gif|ico|pcx|jpeg|tif|png|raw|tga)$/.test(val) || val instanceof Resource || val instanceof HTMLCanvasElement || val instanceof HTMLVideoElement) {
	    var result = new ImageMaterialProperty({
	      image: val,
	      repeat: makeCartesian2({
	        x: 1.0,
	        y: 1.0
	      }),
	      color: Color.WHITE,
	      transparent: true
	    });
	    result.image = val;
	    return result;
	  }

	  if (isArray(val) || isString(val)) {
	    return new ColorMaterialProperty(makeColor(val));
	  }

	  if (isObject(val) && Object.prototype.hasOwnProperty.call(val, 'fabric')) {
	    switch (val.fabric.type) {
	      case 'Image':
	        return new ImageMaterialProperty({
	          image: val.fabric.uniforms.image,
	          repeat: val.fabric.uniforms.repeat || makeCartesian2({
	            x: 1.0,
	            y: 1.0
	          }),
	          color: makeColor(val.fabric.uniforms.color) || Color.WHITE,
	          transparent: val.fabric.uniforms.transparent || false
	        });

	      case 'Color':
	        return new ColorMaterialProperty(makeColor(val.fabric.uniforms.color || Color.WHITE));

	      case 'PolylineArrow':
	        return new PolylineArrowMaterialProperty(makeColor(val.fabric.uniforms.color || Color.WHITE));

	      case 'PolylineDash':
	        return new PolylineDashMaterialProperty({
	          color: makeColor(val.fabric.uniforms.color) || Color.WHITE,
	          gapColor: val.fabric.uniforms.gapColor || Color.TRANSPARENT,
	          dashLength: val.fabric.uniforms.taperPower || 16.0,
	          dashPattern: val.fabric.uniforms.taperPower || 255.0
	        });

	      case 'PolylineGlow':
	        return new PolylineGlowMaterialProperty({
	          color: makeColor(val.fabric.uniforms.color) || Color.WHITE,
	          glowPower: val.fabric.uniforms.glowPower || 0.25,
	          taperPower: val.fabric.uniforms.taperPower || 1.0
	        });

	      case 'PolylineOutline':
	        return new PolylineOutlineMaterialProperty({
	          color: makeColor(val.fabric.uniforms.color) || Color.WHITE,
	          outlineColor: val.fabric.uniforms.outlineColor || Color.BLACK,
	          outlineWidth: val.fabric.uniforms.outlineWidth || 1.0
	        });

	      case 'Checkerboard':
	        return new CheckerboardMaterialProperty({
	          evenColor: makeColor(val.fabric.uniforms.evenColor) || Color.WHITE,
	          oddColor: val.fabric.uniforms.oddColor || Color.BLACK,
	          repeat: val.fabric.uniforms.repeat || makeCartesian2({
	            x: 2,
	            y: 2
	          })
	        });

	      case 'Grid':
	        return new GridMaterialProperty({
	          color: makeColor(val.fabric.uniforms.color) || Color.WHITE,
	          cellAlpha: val.fabric.uniforms.cellAlpha || 0.1,
	          lineCount: val.fabric.uniforms.lineCount || makeCartesian2({
	            x: 8,
	            y: 8
	          }),
	          lineThickness: val.fabric.uniforms.lineThickness || makeCartesian2({
	            x: 1,
	            y: 1
	          }),
	          lineOffset: val.fabric.uniforms.lineOffset || makeCartesian2({
	            x: 0,
	            y: 0
	          })
	        });

	      case 'Stripe':
	        return new StripeMaterialProperty({
	          orientation: makeColor(val.fabric.uniforms.orientation) || 0,
	          evenColor: val.fabric.uniforms.evenColor || Color.WHITE,
	          oddColor: val.fabric.uniforms.oddColor || Color.BLACK,
	          offset: val.fabric.uniforms.offset || 0,
	          repeat: val.fabric.uniforms.repeat || 1
	        });
	    }
	  }

	  if (isFunction(val)) {
	    return new CallbackProperty(val, isConstant);
	  }

	  return val;
	}
	/**
	 * 转 Material
	 * @param {String|Array|Object} val
	 */

	function makeMaterial(val) {
	  var cmpName = this.$options.name;

	  if (cmpName && cmpName.indexOf('graphics') !== -1) {
	    return makeMaterialProperty(val);
	  }

	  if (isObject(val) && Object.prototype.hasOwnProperty.call(val, 'fabric')) {
	    var f = function f(obj) {
	      for (var i in obj) {
	        if (!isArray(obj[i]) && isObject(obj[i])) {
	          f(obj[i]);
	        } else {
	          if (i.toLocaleLowerCase().indexOf('color') !== -1 && !isEmptyObj(obj[i])) {
	            var result = makeColor(obj[i]); // Cesium 通过对象属性个数判断具体材质类型的，通过 Cesium.combine 移除 vue 传的一些属性

	            obj[i] = Cesium.combine(result, result, true);
	          }
	        }
	      }
	    };

	    f(val);
	    return new Cesium.Material(val);
	  }

	  return val;
	}
	/**
	 * 将对象 {west: number, south: number, east: number, north: number} 或者[west, south, east, north]数组 转 Cesium.Rectangle 对象。
	 * @param {Object} val
	 * @returns {Rectangle}
	 */

	function makeRectangle(val) {
	  var isConstant = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	  var _Cesium11 = Cesium,
	      Rectangle = _Cesium11.Rectangle,
	      RectangleGraphics = _Cesium11.RectangleGraphics,
	      CallbackProperty = _Cesium11.CallbackProperty; // Entiy 的 rectangle 属性不能调用这个方法

	  if (val instanceof RectangleGraphics) {
	    return val;
	  }

	  if (val instanceof Rectangle) {
	    return val;
	  }

	  if (isArray(val)) {
	    return Rectangle.fromDegrees(val[0], val[1], val[2], val[3]);
	  }

	  if (isObject(val) && Object.prototype.hasOwnProperty.call(val, 'west')) {
	    return Rectangle.fromDegrees(val.west, val.south, val.east, val.north);
	  }

	  if (isFunction(val)) {
	    return new CallbackProperty(val, isConstant);
	  }

	  return val;
	}
	/**
	 * 对象或数组转 Cesium.BoundingRectangle。
	 * @param {Object} val
	 * @returns {Cesium.BoundingRectangle}
	 * @example
	 * const options = [0, 0, 100, 100]
	 * // const options = {x: 0, y: 0, width: 100, height: 100}
	 * const boundingRectangle = makeBoundingRectangle(options)
	 */

	function makeBoundingRectangle(val) {
	  var isConstant = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	  var _Cesium12 = Cesium,
	      BoundingRectangle = _Cesium12.BoundingRectangle,
	      CallbackProperty = _Cesium12.CallbackProperty;

	  if (val instanceof BoundingRectangle) {
	    return val;
	  }

	  if (isObject(val) && Object.prototype.hasOwnProperty.call(val, 'x')) {
	    return new BoundingRectangle(val.x, val.y, val.width, val.height);
	  }

	  if (isArray) {
	    return new BoundingRectangle(val[0], val[1], val[2], val[3]);
	  }

	  if (isFunction(val)) {
	    return new CallbackProperty(val, isConstant);
	  }

	  return val;
	}
	/**
	 * 普通对象 {normal: number, distance: number} 转 Cesium.Plane 对象。
	 * @param {Object} val
	 * @returns {Plane}
	 */

	function makePlane(val) {
	  var isConstant = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	  var _Cesium13 = Cesium,
	      Cartesian3 = _Cesium13.Cartesian3,
	      Plane = _Cesium13.Plane,
	      PlaneGraphics = _Cesium13.PlaneGraphics,
	      CallbackProperty = _Cesium13.CallbackProperty; // Entiy 和 PlaneGraphics 都有个 plane 属性 要区别一下

	  if (val instanceof PlaneGraphics) {
	    return val;
	  }

	  if (val instanceof Plane) {
	    return val;
	  }

	  if (isObject(val) && Object.prototype.hasOwnProperty.call(val, 'normal')) {
	    Cartesian3.normalize(makeCartesian3(val.normal), val.normal);
	    return new Plane(val.normal, val.distance);
	  }

	  if (isFunction(val)) {
	    return new CallbackProperty(val, isConstant);
	  }

	  return val;
	}
	/**
	 * 普通对象转平移、旋转、缩放变换对象。
	 * @param {*} val
	 */

	function makeTranslationRotationScale(val) {
	  if (isObject(val) && Object.prototype.hasOwnProperty.call(val, 'translation')) {
	    return new Cesium.TranslationRotationScale(makeCartesian3(val.translation), makeQuaternion(val.rotation), makeCartesian3(val.scale));
	  }

	  return val;
	}
	function makeOptions(val) {
	  var cmpName = this.$options.name;
	  var result = {};

	  switch (cmpName) {
	    case 'vc-datasource-geojson':
	      assign$1(result, val);

	      result && result.markerColor && (result.markerColor = makeColor(result.markerColor));
	      result && result.stroke && (result.stroke = makeColor(result.stroke));
	      result && result.fill && (result.fill = makeColor(result.fill));
	      return result;
	  }

	  return val;
	}

	// Entity start

	/**
	 * @const {Object, Array, Function}  position mixin
	 * 坐标位置属性。
	 * @example
	 * :position = { lng: number, lat: number, height: number }
	 * :position = { x: number, y: number, z: number }
	 * :position = [number, number, number]
	 */

	var position = {
	  props: {
	    position: {
	      type: [Object, Array, Function],
	      validator: function validator(val) {
	        return val && Object.prototype.hasOwnProperty.call(val, 'lng') ? lnglatValidator(val.lng, val.lat) : true;
	      },
	      watcherOptions: {
	        cesiumObjectBuilder: makeCartesian3
	      }
	    }
	  }
	};
	/**
	 * @const {Object, Array, Function} orientation mixin
	 */

	var orientation$1 = {
	  props: {
	    orientation: {
	      type: [Object, Array, Function],
	      watcherOptions: {
	        cesiumObjectBuilder: makeQuaternion
	      }
	    }
	  }
	}; // Entity end
	// BillboardGraphics start

	/**
	 * @const {Object, Array, Function} alignedAxis mixin
	 */

	var alignedAxis = {
	  props: {
	    alignedAxis: {
	      type: [Object, Array, Function],
	      default: function _default() {
	        return {
	          x: 0,
	          y: 0,
	          z: 0
	        };
	      },
	      watcherOptions: {
	        cesiumObjectBuilder: makeCartesian3
	      }
	    }
	  }
	};
	/**
	 * @const {Object, String, Array, Function} color mixin
	 */

	var color = {
	  props: {
	    color: {
	      type: [Object, String, Array, Function],
	      default: 'white',
	      watcherOptions: {
	        cesiumObjectBuilder: makeColor
	      }
	    }
	  }
	};
	/**
	 * @const {Number, Object, Function} disableDepthTestDistance mixin
	 */

	var disableDepthTestDistance = {
	  props: {
	    disableDepthTestDistance: [Number, Object, Function]
	  }
	};
	/**
	 * @const {Object, Array, Function}  distanceDisplayCondition mixin
	 */

	var distanceDisplayCondition = {
	  props: {
	    distanceDisplayCondition: {
	      type: [Object, Array, Function],
	      watcherOptions: {
	        cesiumObjectBuilder: makeDistanceDisplayCondition
	      }
	    }
	  }
	};
	/**
	 * @const {Object, Array, Function}  eyeOffset mixin
	 */

	var eyeOffset = {
	  props: {
	    eyeOffset: {
	      type: [Object, Array, Function],
	      default: function _default() {
	        return {
	          x: 0,
	          y: 0,
	          z: 0
	        };
	      },
	      watcherOptions: {
	        cesiumObjectBuilder: makeCartesian3
	      }
	    }
	  }
	};
	/**
	 * @const {Number, Object, Function} height mixin
	 */

	var height = {
	  props: {
	    height: [Number, Object, Function]
	  }
	};
	/**
	 * @const {Number, Object, Function} heightReference mixin
	 */

	var heightReference = {
	  props: {
	    heightReference: [Number, Object, Function],
	    default: 0
	  }
	};
	/**
	 * @const {Number, Object, Function} horizontalOrigin mixin
	 */

	var horizontalOrigin = {
	  props: {
	    horizontalOrigin: {
	      type: [Number, Object, Function],
	      default: 0
	    }
	  }
	};
	/**
	 * @const {String, Object, HTMLCanvasElement, Function} image mixin
	 */

	var image = {
	  props: {
	    image: [String, Object, HTMLCanvasElement, Function]
	  }
	};
	/**
	 * @const {Object, Array, Function} imageSubRegion mixin
	 */

	var imageSubRegion = {
	  props: {
	    imageSubRegion: {
	      type: [Object, Array, Function],
	      watcherOptions: {
	        cesiumObjectBuilder: makeBoundingRectangle
	      }
	    }
	  }
	};
	/**
	 * @const {Object, Array, Function}  pixelOffset mixin
	 */

	var pixelOffset = {
	  props: {
	    pixelOffset: {
	      type: [Object, Array, Function],
	      default: function _default() {
	        return {
	          x: 0,
	          y: 0
	        };
	      },
	      watcherOptions: {
	        cesiumObjectBuilder: makeCartesian2
	      }
	    }
	  }
	};
	/**
	 * @const {Object, Array, Function} pixelOffsetScaleByDistance mixin
	 */

	var pixelOffsetScaleByDistance = {
	  props: {
	    pixelOffsetScaleByDistance: {
	      type: [Object, Array, Function],
	      watcherOptions: {
	        cesiumObjectBuilder: makeNearFarScalar
	      }
	    }
	  }
	};
	/**
	 * @const {Number, Object, Function} rotation mixin
	 */

	var rotation = {
	  props: {
	    rotation: {
	      type: [Number, Object, Function],
	      default: 0
	    }
	  }
	};
	/**
	 * @const {Number, Object, Function} scale mixin
	 */

	var scale = {
	  props: {
	    scale: {
	      type: [Number, Object, Function],
	      default: 1.0
	    }
	  }
	};
	/**
	 * @const {Object, Array, Function} scaleByDistance mixin
	 */

	var scaleByDistance = {
	  props: {
	    scaleByDistance: {
	      type: [Object, Array, Function],
	      watcherOptions: {
	        cesiumObjectBuilder: makeNearFarScalar
	      }
	    }
	  }
	};
	/**
	 * @const {Boolean, Object, Function}  show mixin
	 */

	var show = {
	  props: {
	    show: {
	      type: [Boolean, Object, Function],
	      default: true
	    }
	  }
	};
	/**
	 * @const {Boolean, Object, Function} sizeInMeters mixin
	 */

	var sizeInMeters = {
	  props: {
	    sizeInMeters: [Boolean, Object, Function],
	    default: false
	  }
	};
	/**
	 * @const {Object, Array, Function} translucencyByDistance mixin
	 */

	var translucencyByDistance = {
	  props: {
	    translucencyByDistance: {
	      type: [Object, Array, Function],
	      watcherOptions: {
	        cesiumObjectBuilder: makeNearFarScalar
	      }
	    }
	  }
	};
	/**
	 * @const {Number, Object, Function}  verticalOrigin mixin
	 */

	var verticalOrigin = {
	  props: {
	    verticalOrigin: {
	      type: [Number, Object, Function],
	      default: 0
	    }
	  }
	};
	/**
	 * @const {Number, Object, Function} width mixin
	 */

	var width = {
	  props: {
	    width: [Number, Object, Function]
	  }
	}; // BillboardGraphics end
	// BoxGraphics start

	/**
	 * @const {Object, Array, Function} dimensions mixin
	 * // 和 PlaneGraphics.dimensions 区分
	 */

	var dimensions = {
	  props: {
	    dimensions: {
	      type: [Object, Array, Function],
	      watcherOptions: {
	        cesiumObjectBuilder: makeCartesian3
	      }
	    }
	  }
	};
	/**
	 * @const {Boolean, Object, Function} fill mixin
	 */

	var fill = {
	  props: {
	    fill: {
	      type: [Boolean, Object, Function],
	      default: true
	    }
	  }
	};
	/**
	 * @const {Object, String, Array, Function} material mixin
	 */

	var material = {
	  props: {
	    material: {
	      type: [Object, String, Array, Function],
	      default: 'white',
	      watcherOptions: {
	        cesiumObjectBuilder: makeMaterial
	      }
	    }
	  }
	};
	/**
	 * @const {Boolean, Object, Function} outline mixin
	 */

	var outline = {
	  props: {
	    outline: {
	      type: [Boolean, Object, Function],
	      default: false
	    }
	  }
	};
	/**
	 * @const {Object, String, Array, Function} outlineColor mixin
	 */

	var outlineColor = {
	  props: {
	    outlineColor: {
	      type: [Object, String, Array, Function],
	      default: 'black',
	      watcherOptions: {
	        cesiumObjectBuilder: makeColor
	      }
	    }
	  }
	};
	/**
	 * @const {Number, Object, Function} outlineWidth mixin
	 */

	var outlineWidth = {
	  props: {
	    outlineWidth: {
	      type: [Number, Object, Function],
	      default: 1.0
	    }
	  }
	};
	/**
	 * @const {Number, Object, Function} shadows mixin
	 */

	var shadows = {
	  props: {
	    shadows: [Number, Object, Function]
	  }
	}; // BoxGraphics end
	// CorridorGraphics start

	/**
	 * @const {Array, Object, Function} positions mixin
	 */

	var positions = {
	  props: {
	    type: [Array, Object, Function],
	    positions: {
	      watcherOptions: {
	        cesiumObjectBuilder: makeCartesian3Array,
	        exclude: '_callback'
	      }
	    }
	  }
	};
	/**
	 * @const {Number, Object, Function} extrudedHeight mixin
	 */

	var extrudedHeight = {
	  props: {
	    extrudedHeight: [Number, Object, Function]
	  }
	};
	/**
	 * @const {Number, Object, Function} extrudedHeightReference mixin
	 */

	var extrudedHeightReference = {
	  props: {
	    extrudedHeightReference: [Number, Object, Function]
	  }
	};
	/**
	 * @const {Number, Object, Function} cornerType mixin
	 */

	var cornerType = {
	  props: {
	    cornerType: {
	      type: [Number, Object, Function],
	      default: 0
	    }
	  }
	};
	/**
	 * @const {Number, Object, Function} granularity mixin
	 */

	var granularity = {
	  props: {
	    granularity: [Number, Object, Function]
	  }
	};
	/**
	 * @const {Number, Object, Function} classificationType mixin
	 */

	var classificationType = {
	  props: {
	    classificationType: {
	      type: [Number, Object, Function]
	    }
	  }
	};
	/**
	 * @const {Number, Object, Function} zIndex mixin
	 */

	var zIndex = {
	  props: {
	    zIndex: [Number, Object, Function]
	  }
	}; // CorridorGraphics end
	// CylinderGraphics start

	/**
	 * @const {Number, Object, Function} length mixin
	 */

	var length = {
	  props: {
	    length: [Number, Object, Function]
	  }
	};
	/**
	 * @const {Number, Object, Function} topRadius mixin
	 */

	var topRadius = {
	  props: {
	    topRadius: [Number, Object, Function]
	  }
	};
	/**
	 * @const {Number, Object, Function} bottomRadius mixin
	 */

	var bottomRadius = {
	  props: {
	    bottomRadius: [Number, Object, Function]
	  }
	};
	/**
	 * @const {Number, Object, Function} numberOfVerticalLines mixin
	 */

	var numberOfVerticalLines = {
	  props: {
	    numberOfVerticalLines: {
	      type: [Number, Object, Function],
	      default: 16
	    }
	  }
	};
	/**
	 * @const {Number, Object, Function} slices mixin
	 */

	var slices = {
	  props: {
	    slices: {
	      type: [Number, Object, Function],
	      default: 128
	    }
	  }
	}; // CylinderGraphics end
	// EllipseGraphics start

	/**
	 * @const {Number, Object, Function} semiMajorAxis mixin
	 */

	var semiMajorAxis = {
	  props: {
	    semiMajorAxis: [Number, Object, Function]
	  }
	};
	/**
	 * @const {Number, Object, Function} semiMinorAxis mixin
	 */

	var semiMinorAxis = {
	  props: {
	    semiMinorAxis: [Number, Object, Function]
	  }
	};
	/**
	 * @const {Number, Object, Function} stRotation mixin
	 */

	var stRotation = {
	  props: {
	    stRotation: {
	      type: [Number, Object, Function],
	      default: 0.0
	    }
	  }
	}; // EllipseGraphics end
	// EllipsoidGraphics start

	/**
	 * @const {Number, Object, Function} radii mixin
	 */

	var radii = {
	  props: {
	    radii: {
	      type: [Object, Array, Function],
	      watcherOptions: {
	        cesiumObjectBuilder: makeCartesian3
	      }
	    }
	  }
	};
	/**
	 * @const {Object, Array, Function} innerRadii mixin
	 */

	var innerRadii = {
	  props: {
	    innerRadii: {
	      type: [Object, Array, Function],
	      watcherOptions: {
	        cesiumObjectBuilder: makeCartesian3
	      }
	    }
	  }
	};
	/**
	 * @const {Number, Object, Function} minimumClock mixin
	 */

	var minimumClock = {
	  props: {
	    minimumClock: {
	      type: [Number, Object, Function],
	      default: 0.0
	    }
	  }
	};
	/**
	 * @const {Number, Object, Function} maximumClock mixin
	 */

	var maximumClock = {
	  props: {
	    maximumClock: {
	      type: [Number, Object, Function],
	      default: 2 * Math.PI
	    }
	  }
	};
	/**
	 * @const {Number, Object, Function} minimumCone mixin
	 */

	var minimumCone = {
	  props: {
	    minimumCone: {
	      type: [Number, Object, Function],
	      default: 0.0
	    }
	  }
	};
	/**
	 * @const {Number, Object, Function} maximumCone mixin
	 */

	var maximumCone = {
	  props: {
	    maximumCone: {
	      type: [Number, Object, Function],
	      default: Math.PI
	    }
	  }
	};
	/**
	 * @const {Number, Object, Function} stackPartitions mixin
	 */

	var stackPartitions = {
	  props: {
	    stackPartitions: {
	      type: [Number, Object, Function],
	      default: 64
	    }
	  }
	};
	/**
	 * @const {Number, Object, Function} slicePartitions mixin
	 */

	var slicePartitions = {
	  props: {
	    slicePartitions: {
	      type: [Number, Object, Function],
	      default: 64
	    }
	  }
	};
	/**
	 * @const {Number, Object, Function} subdivisions mixin
	 */

	var subdivisions = {
	  props: {
	    subdivisions: {
	      type: [Number, Object, Function],
	      default: 128
	    }
	  }
	}; // EllipsoidGraphics end
	// LabelGraphics start

	/**
	 * @const {String, Object, Function} text mixin
	 */

	var text = {
	  props: {
	    text: [String, Object, Function]
	  }
	};
	/**
	 * @const {String, Object, Function} font mixin
	 */

	var font = {
	  props: {
	    font: {
	      type: [String, Object, Function],
	      default: '30px sans-serif'
	    }
	  }
	};
	/**
	 * @const {Number, Object, Function} labelStyle mixin
	 */

	var labelStyle = {
	  props: {
	    labelStyle: {
	      type: [Number, Object, Function],
	      default: 0
	    }
	  }
	};
	/**
	 * @const {Boolean, Object, Function} showBackground mixin
	 */

	var showBackground = {
	  props: {
	    showBackground: {
	      type: [Boolean, Object, Function],
	      default: false
	    }
	  }
	};
	/**
	 * @const {Object, String, Array, Function} backgroundColor mixin
	 */

	var backgroundColor = {
	  props: {
	    backgroundColor: {
	      type: [Object, String, Array, Function],
	      default: function _default() {
	        return [0.165, 0.165, 0.165, 0.8];
	      },
	      watcherOptions: {
	        cesiumObjectBuilder: makeColor
	      }
	    }
	  }
	};
	/**
	 * @const {Object, Array, Function} backgroundPadding mixin
	 */

	var backgroundPadding = {
	  props: {
	    backgroundPadding: {
	      type: [Object, Array, Function],
	      default: function _default() {
	        return {
	          x: 7,
	          y: 5
	        };
	      },
	      watcherOptions: {
	        cesiumObjectBuilder: makeCartesian2
	      }
	    }
	  }
	};
	/**
	 * @const {Object, String, Array, Function} fillColor mixin
	 */

	var fillColor = {
	  props: {
	    fillColor: {
	      type: [Object, String, Array, Function],
	      default: 'white',
	      watcherOptions: {
	        cesiumObjectBuilder: makeColor
	      }
	    }
	  }
	}; // LabelGraphics end
	// ModelGraphics start

	/**
	 * @const {String, Object, Function} uri mixin
	 */

	var uri = {
	  props: {
	    uri: [String, Object, Function]
	  }
	};
	/**
	 * @const {Number, Object, Function} minimumPixelSize mixin
	 */

	var minimumPixelSize = {
	  props: {
	    minimumPixelSize: {
	      type: [Number, Object, Function],
	      default: 0.0
	    }
	  }
	};
	/**
	 * @const {Number, Object, Function} maximumScale mixin
	 */

	var maximumScale = {
	  props: {
	    maximumScale: [Number, Object, Function]
	  }
	};
	/**
	 * @const {Boolean, Object, Function} incrementallyLoadTextures mixin
	 */

	var incrementallyLoadTextures = {
	  props: {
	    incrementallyLoadTextures: {
	      type: [Boolean, Object, Function],
	      default: true
	    }
	  }
	};
	/**
	 * @const {Boolean, Object, Function} clampAnimations mixin
	 */

	var runAnimations = {
	  props: {
	    clampAnimations: {
	      type: [Boolean, Object, Function],
	      default: true
	    }
	  }
	};
	/**
	 * @const {Boolean, Object, Function} clampAnimations mixin
	 */

	var clampAnimations = {
	  props: {
	    clampAnimations: {
	      type: [Boolean, Object, Function],
	      default: true
	    }
	  }
	};
	/**
	 * @const {Object, String, Array, Function} silhouetteColor mixin
	 */

	var silhouetteColor = {
	  props: {
	    silhouetteColor: {
	      typy: [Object, String, Array, Function],
	      watcherOptions: {
	        cesiumObjectBuilder: makeColor
	      }
	    }
	  }
	};
	/**
	 * @const {Number, Object, Function} silhouetteSize mixin
	 */

	var silhouetteSize = {
	  props: {
	    silhouetteSize: {
	      type: [Number, Object, Function],
	      default: 0.0
	    }
	  }
	};
	/**
	 * @const {Number, Object, Function} colorBlendMode mixin
	 */

	var colorBlendMode = {
	  props: {
	    colorBlendMode: {
	      type: [Number, Object, Function],
	      default: 0
	    }
	  }
	};
	/**
	 * @const {Number, Object, Function} colorBlendAmount mixin
	 */

	var colorBlendAmount = {
	  props: {
	    colorBlendAmount: {
	      type: [Number, Object, Function],
	      default: 0.5
	    }
	  }
	};
	/**
	 * @const {Object, Array, Function} imageBasedLightingFactor mixin
	 */

	var imageBasedLightingFactor = {
	  props: {
	    imageBasedLightingFactor: {
	      type: [Object, Array, Function],
	      watcherOptions: {
	        cesiumObjectBuilder: makeCartesian2
	      }
	    }
	  }
	};
	/**
	 * @const {Object, String, Array, Function} lightColor mixin
	 * 注意区别 Cesium3DTileset 的 lightColor
	 */

	var lightColor = {
	  props: {
	    lightColor: {
	      typy: [Object, String, Array, Function],
	      watcherOptions: {
	        cesiumObjectBuilder: makeColor
	      }
	    }
	  }
	};
	/**
	 * @const {Object, Function} nodeTransformations mixin
	 */

	var nodeTransformations = {
	  props: {
	    nodeTransformations: {
	      type: [Object, Function],
	      watcherOptions: {
	        cesiumObjectBuilder: makeTranslationRotationScale
	      }
	    }
	  }
	};
	/**
	 * @const {Object, Function} articulations mixin
	 */

	var articulations = {
	  props: {
	    articulations: [Object, Function]
	  }
	};
	/**
	 * @const {Object} clippingPlanes mixin
	 */

	var clippingPlanes = {
	  props: {
	    clippingPlanes: Object
	  }
	}; // ModelGraphics end
	// PathGraphics start
	// PathGraphics end
	// PlaneGraphics start

	/**
	 * @const {Object, Array, Function} plane mixin
	 */

	var plane = {
	  props: {
	    plane: {
	      type: [Object, Array, Function],
	      watcherOptions: {
	        cesiumObjectBuilder: makePlane
	      }
	    }
	  }
	}; // PlaneGraphics end
	// PointGraphics start

	/**
	 * @const {Number, Object, Function} pixelSize mixin
	 */

	var pixelSize = {
	  props: {
	    pixelSize: {
	      type: [Number, Object, Function],
	      default: 1
	    }
	  }
	}; // PointGraphics end
	// PolygonGraphics start

	/**
	 * @const {Object, Array, Function} hierarchy mixin
	 */

	var hierarchy = {
	  props: {
	    hierarchy: {
	      type: [Object, Array, Function],
	      watcherOptions: {
	        cesiumObjectBuilder: makePolygonHierarchy,
	        exclude: '_callback'
	      }
	    }
	  }
	};
	/**
	 * @const {Boolean, Object, Function} perPositionHeight mixin
	 */

	var perPositionHeight = {
	  props: {
	    perPositionHeight: {
	      type: [Boolean, Object, Function],
	      default: false
	    }
	  }
	};
	/**
	 * @const {Boolean, Object, Function} closeTop mixin
	 */

	var closeTop = {
	  props: {
	    closeTop: {
	      type: [Boolean, Object, Function],
	      default: true
	    }
	  }
	};
	/**
	 * @const {Boolean, Object, Function} closeBottom mixin
	 */

	var closeBottom = {
	  props: {
	    closeBottom: {
	      type: [Boolean, Object, Function],
	      default: true
	    }
	  }
	};
	/**
	 * @const {Number, Object, Function} arcType mixin
	 */

	var arcType = {
	  props: {
	    arcType: {
	      type: [Number, Object, Function],
	      default: 1
	    }
	  }
	}; // PolygonGraphics end
	// PolylineGraphics start

	/**
	 * @const {Object, String, Array, Function} depthFailMaterial  mixin
	 */

	var depthFailMaterial = {
	  props: {
	    depthFailMaterial: {
	      type: [Object, String, Array, Function],
	      watcherOptions: {
	        cesiumObjectBuilder: makeMaterial
	      }
	    }
	  }
	};
	/**
	 * @const {Boolean, Object, Function} clampToGround mixin
	 */

	var clampToGround = {
	  props: {
	    clampToGround: {
	      type: [Boolean, Object, Function],
	      default: false
	    }
	  }
	}; // PolylineGraphics end
	// PolylineVolumeGraphics start

	/**
	 * @const {Array, Object, Function} shape mixin
	 */

	var shape = {
	  props: {
	    shape: {
	      type: [Array, Object, Function],
	      watcherOptions: {
	        cesiumObjectBuilder: makeCartesian2Array
	      }
	    }
	  }
	}; // PolylineVolumeGraphics end
	// RectangleGraphics start

	/**
	 * @const {Object, Array, Function} coordinates mixin
	 */

	var coordinates = {
	  props: {
	    coordinates: {
	      type: [Object, Array, Function],
	      watcherOptions: {
	        cesiumObjectBuilder: makeRectangle
	      }
	    }
	  }
	}; // RectangleGraphics end
	// Cesium3DTilesetGraphics start

	/**
	 * @const {Number, Object, Function} maximumScreenSpaceError mixin
	 */

	var maximumScreenSpaceError = {
	  props: {
	    maximumScreenSpaceError: {
	      type: [Number, Object, Function],
	      default: 16
	    }
	  }
	}; // Cesium3DTilesetGraphics end
	// WallGraphics start

	/**
	 * @const {Array, Object, Function} minimumHeights mixin
	 */

	var minimumHeights = {
	  props: {
	    minimumHeights: [Array, Object, Function]
	  }
	};
	/**
	 * @const {Array, Object, Function} maximumHeights mixin
	 */

	var maximumHeights = {
	  props: {
	    maximumHeights: [Array, Object, Function]
	  }
	}; // WallGraphics end
	// Entity end
	// ImageryLayer start

	/**
	 * @const {Object, Array} cutoutRectangle mixin
	 */

	var cutoutRectangle = {
	  props: {
	    cutoutRectangle: {
	      type: [Object, Array],
	      watcherOptions: {
	        cesiumObjectBuilder: makeRectangle
	      }
	    }
	  }
	};
	/**
	 * @const {Object, String, Array} colorToAlpha mixin
	 */

	var colorToAlpha = {
	  props: {
	    colorToAlpha: {
	      type: [Object, String, Array],
	      watcherOptions: {
	        cesiumObjectBuilder: makeColor
	      }
	    }
	  }
	}; // ImageryLayer end
	// imageryProvider

	/**
	 * @const {String, Object} url mixin
	 */

	var url = {
	  props: {
	    url: [String, Object]
	  }
	};
	/**
	 * @const {String} token mixin
	 */

	var token = {
	  props: {
	    token: String
	  }
	};
	/**
	 * @const {Object} tileDiscardPolicy mixin
	 */

	var tileDiscardPolicy = {
	  props: {
	    tileDiscardPolicy: Object
	  }
	};
	/**
	 * @const {String} layers mixin
	 */

	var layers = {
	  props: {
	    layers: String
	  }
	};
	/**
	 * @const {Boolean} enablePickFeatures mixin
	 */

	var enablePickFeatures = {
	  props: {
	    enablePickFeatures: {
	      type: Boolean,
	      default: true
	    }
	  }
	};
	/**
	 * @const {Object, Array} rectangle mixin
	 */

	var rectangle = {
	  props: {
	    rectangle: {
	      type: [Object, Array],
	      watcherOptions: {
	        cesiumObjectBuilder: makeRectangle
	      }
	    }
	  }
	};
	/**
	 * @const {Object} tilingScheme mixin
	 */

	var tilingScheme = {
	  props: {
	    tilingScheme: Object
	  }
	};
	/**
	 * @const {Object} ellipsoid mixin
	 */

	var ellipsoid = {
	  props: {
	    ellipsoid: Object
	  }
	};
	/**
	 * @const {String, Object} credit mixin
	 */

	var credit = {
	  props: {
	    credit: {
	      type: [String, Object],
	      default: ''
	    }
	  }
	};
	/**
	 * @const {Number} tileWidth mixin
	 */

	var tileWidth = {
	  props: {
	    tileWidth: {
	      type: Number,
	      default: 256
	    }
	  }
	};
	/**
	 * @const {Number} tileHeight mixin
	 */

	var tileHeight = {
	  props: {
	    tileHeight: {
	      type: Number,
	      default: 256
	    }
	  }
	};
	/**
	 * @const {Number} maximumLevel mixin
	 */

	var maximumLevel = {
	  props: {
	    maximumLevel: Number
	  }
	};
	/**
	 * @const {Number} minimumLevel mixin
	 */

	var minimumLevel = {
	  props: {
	    minimumLevel: {
	      type: Number,
	      default: 0
	    }
	  }
	};
	/**
	 * @const {String} fileExtension mixin
	 */

	var fileExtension = {
	  props: {
	    fileExtension: {
	      type: String,
	      default: 'png'
	    }
	  }
	};
	/**
	 * @const {String} accessToken mixin
	 */

	var accessToken = {
	  props: {
	    accessToken: String
	  }
	};
	/**
	 * @const {String} format mixin
	 */

	var format = {
	  props: {
	    format: {
	      type: String,
	      default: 'png'
	    }
	  }
	};
	/**
	 * @const {String, Array} subdomains mixin
	 */

	var subdomains = {
	  props: {
	    subdomains: [String, Array]
	  }
	};
	/**
	 * @const {Array} getFeatureInfoFormats mixin
	 */

	var getFeatureInfoFormats = {
	  props: {
	    getFeatureInfoFormats: Array
	  }
	};
	/**
	 * @const {Object} clock mixin
	 */

	var clock = {
	  props: {
	    clock: Object
	  }
	};
	/**
	 * @const {Object} times mixin
	 */

	var times = {
	  props: {
	    times: Object
	  }
	}; // primitive 相关

	/**
	 * @const {Boolean}
	 * allowPicking
	 * asynchronous
	 */

	var aaMixin = {
	  props: {
	    allowPicking: {
	      type: Boolean,
	      default: true
	    },
	    asynchronous: {
	      type: Boolean,
	      default: true
	    }
	  }
	};
	/**
	 * @const {Boolean} debugShowShadowVolume mixin
	 */

	var debugShowShadowVolume = {
	  props: {
	    debugShowShadowVolume: {
	      type: Boolean,
	      default: false
	    }
	  }
	};
	/**
	 * @const {Boolean} releaseGeometryInstances mixin
	 */

	var releaseGeometryInstances = {
	  props: {
	    releaseGeometryInstances: {
	      type: Boolean,
	      default: true
	    }
	  }
	};
	/**
	 * @const {Boolean} interleave mixin
	 */

	var interleave = {
	  props: {
	    interleave: {
	      type: Boolean,
	      default: false
	    }
	  }
	};
	/**
	 * @const {Object} appearance mixin
	 */

	var appearance = {
	  props: {
	    appearance: Object
	  }
	};
	/**
	 * @const {Array, Object} geometryInstances mixin
	 */

	var geometryInstances = {
	  props: {
	    geometryInstances: [Array, Object]
	  }
	};
	/**
	 * @const {Boolean}
	 * vertexCacheOptimize
	 * compressVertices
	 */

	var vcMixin = {
	  props: {
	    vertexCacheOptimize: {
	      type: Boolean,
	      default: false
	    },
	    compressVertices: {
	      type: Boolean,
	      default: true
	    }
	  }
	};
	/**
	 * @const {Object} modelMatrix mixin
	 */

	var modelMatrix = {
	  props: {
	    modelMatrix: Object
	  }
	};
	/**
	 * @const {Boolean} debugShowBoundingVolume mixin
	 */

	var debugShowBoundingVolume = {
	  props: {
	    debugShowBoundingVolume: {
	      tyep: Boolean,
	      default: false
	    }
	  }
	};
	/**
	 * @const {Object} scene mixin
	 */

	var scene = {
	  props: {
	    scene: Object
	  }
	};
	/**
	 * @const {Number} blendOption mixin
	 */

	var blendOption = {
	  props: {
	    blendOption: {
	      type: Number,
	      default: 2
	    }
	  }
	};
	/**
	 * @const {*} id mixin
	 */

	var id$1 = {
	  props: {
	    id: null
	  }
	};
	/**
	 * @const {Boolean} loop mixin
	 */

	var loop = {
	  props: {
	    loop: {
	      type: Boolean,
	      default: false
	    }
	  }
	};
	/**
	 * @const {Boolean} debugWireframe mixin
	 */

	var debugWireframe = {
	  props: {
	    debugWireframe: {
	      type: Boolean,
	      default: false
	    }
	  }
	}; // geometry 相关

	/**
	 * @const {Object} vertexFormat mixin
	 */

	var vertexFormat = {
	  props: {
	    vertexFormat: Object
	  }
	};
	/**
	 * @const {Object, Array} center mixin
	 */

	var center = {
	  props: {
	    center: {
	      type: [Object, Array],
	      watcherOptions: {
	        cesiumObjectBuilder: makeCartesian3
	      }
	    }
	  }
	};
	/**
	 * @const {Object} radius mixin
	 */

	var radius = {
	  props: {
	    radius: Number
	  }
	};
	/**
	 * @const {Object} frustum mixin
	 */

	var frustum = {
	  props: {
	    frustum: Object
	  }
	};
	/**
	 * @const {Object, Array} origin mixin
	 */

	var origin = {
	  props: {
	    origin: {
	      type: [Object, Array],
	      watcherOptions: {
	        cesiumObjectBuilder: makeCartesian3
	      }
	    }
	  }
	};
	/**
	 * @const {Object} polygonHierarchy mixin
	 */

	var polygonHierarchy = {
	  props: {
	    polygonHierarchy: {
	      type: [Object, Array],
	      watcherOptions: {
	        cesiumObjectBuilder: makePolygonHierarchy
	      }
	    }
	  }
	};
	/**
	 * @const {Object, String, Array} startColor mixin
	 */

	var startColor = {
	  props: {
	    startColor: {
	      type: [Object, String, Array],
	      watcherOptions: {
	        cesiumObjectBuilder: makeColor
	      }
	    }
	  }
	};
	/**
	 * @const {Object, String, Array} endColor mixin
	 */

	var endColor = {
	  props: {
	    endColor: {
	      type: [Object, String, Array],
	      watcherOptions: {
	        cesiumObjectBuilder: makeColor
	      }
	    }
	  }
	};
	/**
	 * @const {Object, Array} minimumImageSize mixin
	 */

	var minimumImageSize = {
	  props: {
	    minimumImageSize: {
	      type: [Object, Array],
	      watcherOptions: {
	        cesiumObjectBuilder: makeCartesian2
	      }
	    }
	  }
	};
	/**
	 * @const {Object, Array} maximumImageSize mixin
	 */

	var maximumImageSize = {
	  props: {
	    maximumImageSize: {
	      type: [Object, Array],
	      watcherOptions: {
	        cesiumObjectBuilder: makeCartesian2
	      }
	    }
	  }
	};
	/**
	 * @const {Object, Array} imageSize mixin
	 */

	var imageSize = {
	  props: {
	    imageSize: {
	      type: [Object, Array],
	      watcherOptions: {
	        cesiumObjectBuilder: makeCartesian2
	      }
	    }
	  }
	};
	/**
	 * @const {Array} shapePositions mixin
	 */

	var shapePositions = {
	  props: {
	    shapePositions: {
	      type: Array,
	      watcherOptions: {
	        cesiumObjectBuilder: makeCartesian2Array
	      }
	    }
	  }
	};
	/**
	 * @const {Array} polylinePositions mixin
	 */

	var polylinePositions = {
	  props: {
	    polylinePositions: {
	      type: Array,
	      watcherOptions: {
	        cesiumObjectBuilder: makeCartesian3Array
	      }
	    }
	  }
	};
	/**
	 * @const {Object, String, Array} lightColor2 mixin
	 * 用于 Cesium3DTileset 和 Model
	 */

	var lightColor2 = {
	  props: {
	    lightColor: {
	      type: [Object, Array],
	      watcherOptions: {
	        cesiumObjectBuilder: makeCartesian3
	      }
	    }
	  }
	};
	/**
	 * @const {Number} luminanceAtZenith mixin
	 */

	var luminanceAtZenith = {
	  props: {
	    luminanceAtZenith: {
	      type: Number,
	      default: 0.2
	    }
	  }
	};
	/**
	 * @const {Array, Object} sphericalHarmonicCoefficients mixin
	 */

	var sphericalHarmonicCoefficients = {
	  props: {
	    sphericalHarmonicCoefficients: {
	      type: [Array, Object],
	      watcherOptions: {
	        cesiumObjectBuilder: makeCartesian3Array
	      }
	    }
	  }
	};
	/**
	 * @const {String} specularEnvironmentMaps mixin
	 */

	var specularEnvironmentMaps = {
	  props: {
	    specularEnvironmentMaps: String
	  }
	};
	/**
	 * @const {Boolean} backFaceCulling mixin
	 */

	var backFaceCulling = {
	  props: {
	    backFaceCulling: {
	      type: Boolean,
	      default: true
	    }
	  }
	}; // datasouce

	/**
	 * @const {String, Object} data mixin
	 */

	var data = {
	  props: {
	    data: {
	      type: [String, Object],
	      required: true
	    }
	  }
	};
	/**
	 * @const {Object} options mixin
	 */

	var options = {
	  props: {
	    options: {
	      type: Object,
	      watcherOptions: {
	        cesiumObjectBuilder: makeOptions,
	        deep: true
	      }
	    }
	  }
	}; // PostProcessStage start

	/**
	 * @const {String, Array, Object} glowColor mixin
	 */

	var glowColor = {
	  props: {
	    glowColor: {
	      type: [String, Array, Object],
	      default: function _default() {
	        return [0.0, 1.0, 0.0, 0.05];
	      },
	      watcherOptions: {
	        cesiumObjectBuilder: makeColor
	      }
	    }
	  }
	};
	/**
	 * @const {String, Array, Object} clearColor mixin
	 */

	var clearColor = {
	  props: {
	    clearColor: {
	      type: [String, Array, Object],
	      watcherOptions: {
	        cesiumObjectBuilder: makeColor
	      }
	    }
	  }
	};
	/**
	 * @const {Object, Array} scissorRectangle mixin
	 */

	var scissorRectangle = {
	  props: {
	    scissorRectangle: {
	      type: [Object, Array],
	      watcherOptions: {
	        cesiumObjectBuilder: makeBoundingRectangle
	      }
	    }
	  }
	}; // PostProcessStage end

	var allProps = /*#__PURE__*/Object.freeze({
		__proto__: null,
		backFaceCulling: backFaceCulling,
		specularEnvironmentMaps: specularEnvironmentMaps,
		sphericalHarmonicCoefficients: sphericalHarmonicCoefficients,
		luminanceAtZenith: luminanceAtZenith,
		maximumScreenSpaceError: maximumScreenSpaceError,
		runAnimations: runAnimations,
		articulations: articulations,
		scissorRectangle: scissorRectangle,
		clearColor: clearColor,
		glowColor: glowColor,
		options: options,
		data: data,
		imageSubRegion: imageSubRegion,
		coordinates: coordinates,
		nodeTransformations: nodeTransformations,
		hierarchy: hierarchy,
		plane: plane,
		colorToAlpha: colorToAlpha,
		cutoutRectangle: cutoutRectangle,
		polylinePositions: polylinePositions,
		shapePositions: shapePositions,
		imageSize: imageSize,
		maximumImageSize: maximumImageSize,
		minimumImageSize: minimumImageSize,
		endColor: endColor,
		startColor: startColor,
		shape: shape,
		lightColor: lightColor,
		lightColor2: lightColor2,
		imageBasedLightingFactor: imageBasedLightingFactor,
		polygonHierarchy: polygonHierarchy,
		orientation: orientation$1,
		origin: origin,
		frustum: frustum,
		maximumCone: maximumCone,
		minimumCone: minimumCone,
		maximumClock: maximumClock,
		minimumClock: minimumClock,
		innerRadii: innerRadii,
		radius: radius,
		center: center,
		debugWireframe: debugWireframe,
		vertexFormat: vertexFormat,
		position: position,
		loop: loop,
		geometryInstances: geometryInstances,
		appearance: appearance,
		interleave: interleave,
		releaseGeometryInstances: releaseGeometryInstances,
		debugShowShadowVolume: debugShowShadowVolume,
		id: id$1,
		aaMixin: aaMixin,
		vcMixin: vcMixin,
		modelMatrix: modelMatrix,
		debugShowBoundingVolume: debugShowBoundingVolume,
		scene: scene,
		blendOption: blendOption,
		maximumHeights: maximumHeights,
		minimumHeights: minimumHeights,
		arcType: arcType,
		clampToGround: clampToGround,
		closeBottom: closeBottom,
		closeTop: closeTop,
		perPositionHeight: perPositionHeight,
		pixelSize: pixelSize,
		clippingPlanes: clippingPlanes,
		colorBlendAmount: colorBlendAmount,
		colorBlendMode: colorBlendMode,
		silhouetteSize: silhouetteSize,
		silhouetteColor: silhouetteColor,
		clampAnimations: clampAnimations,
		incrementallyLoadTextures: incrementallyLoadTextures,
		maximumScale: maximumScale,
		minimumPixelSize: minimumPixelSize,
		uri: uri,
		fillColor: fillColor,
		backgroundPadding: backgroundPadding,
		backgroundColor: backgroundColor,
		showBackground: showBackground,
		labelStyle: labelStyle,
		font: font,
		text: text,
		subdivisions: subdivisions,
		slicePartitions: slicePartitions,
		stackPartitions: stackPartitions,
		radii: radii,
		stRotation: stRotation,
		semiMinorAxis: semiMinorAxis,
		semiMajorAxis: semiMajorAxis,
		slices: slices,
		numberOfVerticalLines: numberOfVerticalLines,
		bottomRadius: bottomRadius,
		topRadius: topRadius,
		length: length,
		zIndex: zIndex,
		classificationType: classificationType,
		granularity: granularity,
		cornerType: cornerType,
		extrudedHeightReference: extrudedHeightReference,
		extrudedHeight: extrudedHeight,
		positions: positions,
		image: image,
		scale: scale,
		pixelOffset: pixelOffset,
		eyeOffset: eyeOffset,
		horizontalOrigin: horizontalOrigin,
		verticalOrigin: verticalOrigin,
		heightReference: heightReference,
		color: color,
		rotation: rotation,
		alignedAxis: alignedAxis,
		sizeInMeters: sizeInMeters,
		width: width,
		height: height,
		scaleByDistance: scaleByDistance,
		translucencyByDistance: translucencyByDistance,
		pixelOffsetScaleByDistance: pixelOffsetScaleByDistance,
		disableDepthTestDistance: disableDepthTestDistance,
		dimensions: dimensions,
		fill: fill,
		depthFailMaterial: depthFailMaterial,
		material: material,
		outline: outline,
		outlineColor: outlineColor,
		outlineWidth: outlineWidth,
		shadows: shadows,
		distanceDisplayCondition: distanceDisplayCondition,
		show: show,
		times: times,
		clock: clock,
		getFeatureInfoFormats: getFeatureInfoFormats,
		subdomains: subdomains,
		format: format,
		accessToken: accessToken,
		fileExtension: fileExtension,
		minimumLevel: minimumLevel,
		maximumLevel: maximumLevel,
		tileHeight: tileHeight,
		url: url,
		token: token,
		tileDiscardPolicy: tileDiscardPolicy,
		layers: layers,
		enablePickFeatures: enablePickFeatures,
		rectangle: rectangle,
		tilingScheme: tilingScheme,
		ellipsoid: ellipsoid,
		credit: credit,
		tileWidth: tileWidth
	});

	// 19.1.2.9 Object.getPrototypeOf(O)



	_objectSap('getPrototypeOf', function () {
	  return function getPrototypeOf(it) {
	    return _objectGpo(_toObject(it));
	  };
	});

	var getPrototypeOf = _core.Object.getPrototypeOf;

	var getPrototypeOf$1 = getPrototypeOf;

	/**
	 * Vue 组件名对应的 Cesium 类。
	 * @const {Object}
	 */
	var nameClassMap = {
	  // 二、三维视图
	  'vc-viewer': 'Viewer',
	  // 影像
	  'vc-layer-imagery': 'ImageryLayer',
	  'vc-provider-imagery-arcgis-mapserver': 'ArcGisMapServerImageryProvider',
	  'vc-provider-imagery-bingmaps': 'BingMapsImageryProvider',
	  'vc-provider-imagery-googleearth-enterprise': 'GoogleEarthEnterpriseImageryProvider',
	  'vc-provider-imagery-grid': 'GridImageryProvider',
	  'vc-provider-imagery-ion': 'IonImageryProvider',
	  'vc-provider-imagery-mapbox': 'MapboxImageryProvider',
	  'vc-provider-imagery-style-mapbox': 'MapboxStyleImageryProvider',
	  'vc-provider-imagery-openstreetmap': 'OpenStreetMapImageryProvider',
	  'vc-provider-imagery-tile-single': 'SingleTileImageryProvider',
	  'vc-provider-imagery-tile-coordinates': 'TileCoordinatesImageryProvider',
	  'vc-provider-imagery-tile-mapservice': 'TileMapServiceImageryProvider',
	  'vc-provider-imagery-urltemplate': 'UrlTemplateImageryProvider',
	  'vc-provider-imagery-wms': 'WebMapServiceImageryProvider',
	  'vc-provider-imagery-wmts': 'WebMapTileServiceImageryProvider',
	  'vc-provider-imagery-tianditu': 'TiandituImageryProvider',
	  'vc-provider-imagery-supermap': 'SuperMapImageryProvider',
	  'vc-provider-imagery-tiledcache': 'UrlTemplateImageryProvider',
	  'vc-provider-imagery-baidumap': 'BaiduMapImageryProvider',
	  // 地形
	  'vc-provider-terrain-arcgis-tiled-elevation': 'ArcGISTiledElevationTerrainProvider',
	  'vc-provider-terrain-cesium': 'CesiumTerrainProvider',
	  // 实体
	  'vc-entity': 'Entity',
	  'vc-graphics-billboard': 'BillboardGraphics',
	  'vc-graphics-box': 'BoxGraphics',
	  'vc-graphics-corridor': 'CorridorGraphics',
	  'vc-graphics-cylinder': 'CylinderGraphics',
	  'vc-graphics-ellipse': 'EllipseGraphics',
	  'vc-graphics-ellipsoid': 'EllipsoidGraphics',
	  'vc-graphics-label': 'LabelGraphics',
	  'vc-graphics-model': 'ModelGraphics',
	  'vc-graphics-tileset': 'Cesium3DTilesetGraphics',
	  'vc-graphics-path': 'PathGraphics',
	  'vc-graphics-plane': 'PlaneGraphics',
	  'vc-graphics-point': 'PointGraphics',
	  'vc-graphics-polygon': 'PolygonGraphics',
	  'vc-graphics-polyline': 'PolylineGraphics',
	  'vc-graphics-polyline-volume': 'PolylineVolumeGraphics',
	  'vc-graphics-rectangle': 'RectangleGraphics',
	  'vc-graphics-wall': 'WallGraphics',
	  // 数据源
	  'vc-datasource-custom': 'CustomDataSource',
	  'vc-datasource-czml': 'CzmlDataSource',
	  'vc-datasource-geojson': 'GeoJsonDataSource',
	  'vc-datasource-kml': 'KmlDataSource',
	  // 图元集合
	  'vc-collection-primitive': 'PrimitiveCollection',
	  'vc-collection-primitive-billboard': 'BillboardCollection',
	  'vc-collection-primitive-label': 'LabelCollection',
	  'vc-collection-primitive-point': 'PointPrimitiveCollection',
	  'vc-collection-primitive-polyline': 'PolylineCollection',
	  // 图元
	  'vc-primitive': 'Primitive',
	  'vc-primitive-classification': 'ClassificationPrimitive',
	  'vc-primitive-ground': 'GroundPrimitive',
	  'vc-primitive-billboard': 'Billboard',
	  'vc-primitive-label': 'Label',
	  'vc-primitive-point': 'PointPrimitive',
	  'vc-primitive-polyline': 'Polyline',
	  'vc-primitive-polyline-ground': 'GroundPolylinePrimitive',
	  'vc-primitive-model': 'Model',
	  'vc-primitive-tileset': 'Cesium3DTileset',
	  'vc-primitive-particle': 'ParticleSystem',
	  // 几何体
	  'vc-instance-geometry': 'GeometryInstance',
	  'vc-geometry-box': 'BoxGeometry',
	  'vc-geometry-outline-box': 'BoxOutlineGeometry',
	  'vc-geometry-circle': 'CircleGeometry',
	  'vc-geometry-outline-circle': 'CircleOutlineGeometry',
	  'vc-geometry-polygon-coplanar': 'CoplanarPolygonGeometry',
	  'vc-geometry-outline-polygon-coplanar': 'CoplanarPolygonOutlineGeometry',
	  'vc-geometry-corridor': 'CorridorGeometry',
	  'vc-geometry-outline-corridor': 'CorridorOutlineGeometry',
	  'vc-geometry-cylinder': 'CylinderGeometry',
	  'vc-geometry-outline-cylinder': 'CylinderOutlineGeometry',
	  'vc-geometry-ellipse': 'EllipseGeometry',
	  'vc-geometry-outline-ellipse': 'EllipseOutlineGeometry',
	  'vc-geometry-ellipsoid': 'EllipsoidGeometry',
	  'vc-geometry-outline-ellipsoid': 'EllipsoidOutlineGeometry',
	  'vc-geometry-frustum': 'FrustumGeometry',
	  'vc-geometry-outline-frustum': 'FrustumOutlineGeometry',
	  'vc-geometry-polyline-ground': 'GroundPolylineGeometry',
	  'vc-geometry-plane': 'PlaneGeometry',
	  'vc-geometry-outline-plane': 'PlaneOutlineGeometry',
	  'vc-geometry-polygon': 'PolygonGeometry',
	  'vc-geometry-outline-polygon': 'PolygonOutlineGeometry',
	  'vc-geometry-polyline': 'PolylineGeometry',
	  'vc-geometry-polyline-volume': 'PolylineVolumeGeometry',
	  'vc-geometry-outline-polyline-volume': 'PolylineVolumeOutlineGeometry',
	  'vc-geometry-rectangle': 'RectangleGeometry',
	  'vc-geometry-outline-rectangle': 'RectangleOutlineGeometry',
	  'vc-geometry-polyline-simple': 'SimplePolylineGeometry',
	  'vc-geometry-sphere': 'SphereGeometry',
	  'vc-geometry-outline-sphere': 'SphereOutlineGeometry',
	  'vc-geometry-wall': 'WallGeometry',
	  'vc-geometry-outline-wall': 'WallOutlineGeometry',
	  // stage
	  'vc-stage-process-post': 'PostProcessStage',
	  'vc-collection-stage-process-post': 'PostProcessStageCollection'
	};

	var VM_PROP = 'vm';
	var graphics = ['billboard', 'box', 'corridor', 'cylinder', 'ellipse', 'ellipsoid', 'label', 'model', 'tileset', 'path', 'plane', 'point', 'polygon', 'polyline', 'polylineVolume', 'rectangle', 'wall'];
	/**
	 * Get the parent component. 获取 vc-viewer 组件。
	 * @param {VueComponent} $component.
	 */

	var getParent = function getParent($component) {
	  return !$component.cesiumClass && $component.$options.name !== 'vc-viewer' ? getParent($component.$parent) : $component;
	};
	/**
	 * @vueMethods
	 */


	var methods = {
	  /**
	   * Load components asynchronously. 异步加载组件。
	   * @returns {Promise<Object>} { Cesium, viewer, cesiumObject }
	   */
	  load: function load() {
	    var createCesiumObject, mount, setPropWatchers, $parent, Cesium, viewer, that;
	    return regenerator.async(function load$(_context2) {
	      while (1) {
	        switch (_context2.prev = _context2.next) {
	          case 0:
	            if (!this._mounted) {
	              _context2.next = 2;
	              break;
	            }

	            return _context2.abrupt("return", false);

	          case 2:
	            createCesiumObject = this.createCesiumObject, mount = this.mount, setPropWatchers = this.setPropWatchers;
	            $parent = getParent(this.$parent);
	            Cesium = this.Cesium = $parent.Cesium;
	            viewer = this.viewer = $parent.viewer; // If you call the unload method to unload the component, the Cesium object of the parent component may be unloaded. You need to load the parent component first.
	            // 如果调用过 unload 方法卸载组件，父组件的 Cesium 对象可能会被卸载 需要先加载父组件。

	            if ($parent.cesiumObject) {
	              _context2.next = 8;
	              break;
	            }

	            return _context2.abrupt("return", $parent.load());

	          case 8:
	            // Register vue Watchers. 注册 Vue 侦听器。
	            setPropWatchers(true);
	            that = this;
	            return _context2.abrupt("return", createCesiumObject().then(function _callee(cesiumObject) {
	              return regenerator.async(function _callee$(_context) {
	                while (1) {
	                  switch (_context.prev = _context.next) {
	                    case 0:
	                      that.originInstance = cesiumObject; // Load the created Cesium object. 加载创建的 Cesium 对象。

	                      return _context.abrupt("return", mount().then(function () {
	                        that._mounted = true; // Trigger the component's 'ready' event. 触发该组件的 'ready' 事件。

	                        that.$emit('ready', {
	                          Cesium: Cesium,
	                          viewer: viewer,
	                          cesiumObject: cesiumObject,
	                          vm: that
	                        });
	                        return {
	                          Cesium: Cesium,
	                          viewer: viewer,
	                          cesiumObject: cesiumObject,
	                          vm: that
	                        };
	                      }));

	                    case 2:
	                    case "end":
	                      return _context.stop();
	                  }
	                }
	              });
	            }));

	          case 11:
	          case "end":
	            return _context2.stop();
	        }
	      }
	    }, null, this);
	  },

	  /**
	   * Unloading components asynchronously. 异步卸载组件。
	   * @returns {Promise<Boolean>} returns true on success and false on failure. 成功返回 true，失败返回 false。
	   */
	  unload: function unload() {
	    var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, $node, that;

	    return regenerator.async(function unload$(_context4) {
	      while (1) {
	        switch (_context4.prev = _context4.next) {
	          case 0:
	            // If the component has subcomponents, you need to remove the subcomponents first. 如果该组件带有子组件，需要先移除子组件。
	            _iteratorNormalCompletion = true;
	            _didIteratorError = false;
	            _iteratorError = undefined;
	            _context4.prev = 3;
	            _iterator = getIterator$1((this.$slots.default || []).map(function (vnode) {
	              return vnode.componentInstance;
	            }).filter(function (cmp) {
	              return !!cmp;
	            }));

	          case 5:
	            if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
	              _context4.next = 12;
	              break;
	            }

	            $node = _step.value;
	            _context4.next = 9;
	            return regenerator.awrap($node.unload());

	          case 9:
	            _iteratorNormalCompletion = true;
	            _context4.next = 5;
	            break;

	          case 12:
	            _context4.next = 18;
	            break;

	          case 14:
	            _context4.prev = 14;
	            _context4.t0 = _context4["catch"](3);
	            _didIteratorError = true;
	            _iteratorError = _context4.t0;

	          case 18:
	            _context4.prev = 18;
	            _context4.prev = 19;

	            if (!_iteratorNormalCompletion && _iterator.return != null) {
	              _iterator.return();
	            }

	          case 21:
	            _context4.prev = 21;

	            if (!_didIteratorError) {
	              _context4.next = 24;
	              break;
	            }

	            throw _iteratorError;

	          case 24:
	            return _context4.finish(21);

	          case 25:
	            return _context4.finish(18);

	          case 26:
	            that = this;
	            return _context4.abrupt("return", this._mounted ? this.unmount().then(function _callee2() {
	              return regenerator.async(function _callee2$(_context3) {
	                while (1) {
	                  switch (_context3.prev = _context3.next) {
	                    case 0:
	                      // Teardown the watchers. 注销 Vue 侦听器。
	                      that.setPropWatchers(false);
	                      that.originInstance = undefined;
	                      that._mounted = false; // If the component cannot be rendered without the parent component, the parent component needs to be removed.
	                      // 如果该组件的渲染和父组件是绑定在一起的，需要移除父组件。

	                      return _context3.abrupt("return", that.renderByParent ? that.$parent.unload() : true);

	                    case 4:
	                    case "end":
	                      return _context3.stop();
	                  }
	                }
	              });
	            }) : false);

	          case 28:
	          case "end":
	            return _context4.stop();
	        }
	      }
	    }, null, this, [[3, 14, 18, 26], [19,, 21, 25]]);
	  },

	  /**
	   * Reload components asynchronously. 异步重载组件.
	   * @returns {Promise<Boolean>} returns true on success and false on failure. 成功返回 true，失败返回 false。
	   */
	  reload: function reload() {
	    var that;
	    return regenerator.async(function reload$(_context5) {
	      while (1) {
	        switch (_context5.prev = _context5.next) {
	          case 0:
	            that = this;
	            return _context5.abrupt("return", this.unload().then(function () {
	              return that.load();
	            }));

	          case 2:
	          case "end":
	            return _context5.stop();
	        }
	      }
	    }, null, this);
	  },

	  /**
	   * Create Cesium objects asynchronously. 异步创建 Cesium 对象。
	   * @returns {Promise<Object>} return the Cesium object.
	   */
	  createCesiumObject: function createCesiumObject() {
	    var $props, cesiumClass, transformProps, options;
	    return regenerator.async(function createCesiumObject$(_context6) {
	      while (1) {
	        switch (_context6.prev = _context6.next) {
	          case 0:
	            $props = this.$props, cesiumClass = this.cesiumClass, transformProps = this.transformProps;
	            options = transformProps($props);
	            return _context6.abrupt("return", new Cesium[cesiumClass](options));

	          case 3:
	          case "end":
	            return _context6.stop();
	        }
	      }
	    }, null, this);
	  },

	  /**
	   * Register or unregister the vue watchers.
	   * @param {Boolean} register
	   */
	  setPropWatchers: function setPropWatchers(register) {
	    if (register) {
	      var cesiumClass = this.cesiumClass,
	          transformProp = this.transformProp;

	      if (!cesiumClass || !Cesium[cesiumClass]) {
	        return;
	      }

	      var that = this;
	      that.$options.props && keys$1(that.$options.props).forEach(function (vueProp) {
	        var cesiumProp = vueProp;

	        if (vueProp === 'labelStyle' || vueProp === 'wmtsStyle') {
	          cesiumProp = 'style';
	        } else if (vueProp === 'bmKey') {
	          cesiumProp = 'key';
	        } // 如果在vue文件中已经监听了改 props 这儿不再监听了
	        // If you have listened to the props in the vue file, you will not add any more listeners here.


	        if (that.$options.watch && that.$options.watch[vueProp]) {
	          return;
	        }

	        var watcherOptions = that.$options.props[vueProp].watcherOptions; // returns an unwatch function that stops firing the callback

	        var unwatch = that.$watch(vueProp, function _callee3(val) {
	          var cesiumObject, pd, pdProto, hasSetter, newVal;
	          return regenerator.async(function _callee3$(_context7) {
	            while (1) {
	              switch (_context7.prev = _context7.next) {
	                case 0:
	                  _context7.next = 2;
	                  return regenerator.awrap(that.createPromise);

	                case 2:
	                  cesiumObject = that.cesiumObject; // Get the writability of the current cesiumobject or the props on its prototype chain to
	                  // detect whether the component property responds dynamically or reloads the component when the property changes.
	                  // 通过 cesiumObject 对象或它原型链上的 prop 的可写性，以检测属性改变时组件属性是动态响应还是重载组件。

	                  pd = cesiumObject && getOwnPropertyDescriptor$1(cesiumObject, cesiumProp);
	                  pdProto = cesiumObject && getOwnPropertyDescriptor$1(getPrototypeOf$1(cesiumObject), cesiumProp);
	                  hasSetter = pd && (pd.writable || pd.set) || pdProto && (pdProto.writable || pdProto.set);

	                  if (!hasSetter) {
	                    _context7.next = 11;
	                    break;
	                  }

	                  // Attributes are writable and directly respond to changes in attributes.
	                  // 属性可写，直接动态响应属性的改变。
	                  if (watcherOptions && watcherOptions.cesiumObjectBuilder) {
	                    newVal = watcherOptions.cesiumObjectBuilder.call(that, val); // If an exclude condition has been defined for the object, such as "_callback", Cesium will automatically handle it internally and no longer need to be assigned.
	                    // 如果对象已经定义了 exclude 条件，如已经定义了“_callback”，Cesium 内部会自动处理的 不用再赋值了。

	                    if (!(Cesium.defined(cesiumObject[cesiumProp]) && Cesium.defined(cesiumObject[cesiumProp]._callback))) {
	                      cesiumObject[cesiumProp] = newVal;
	                    }
	                  } else {
	                    cesiumObject[cesiumProp] = transformProp(cesiumProp, val);
	                  }

	                  return _context7.abrupt("return", true);

	                case 11:
	                  return _context7.abrupt("return", that.reload());

	                case 12:
	                case "end":
	                  return _context7.stop();
	              }
	            }
	          });
	        }, {
	          deep: watcherOptions && watcherOptions.deep
	        });
	        that.unwatchFns.push(unwatch);
	      });
	    } else {
	      // Stops firing the callback.
	      // 注销 watchers。
	      this.unwatchFns.forEach(function (item) {
	        return item();
	      });
	      this.unwatchFns = [];
	    }
	  },

	  /**
	   * Mount Cesium objects asynchronously. 异步挂载 Cesium 对象，即将 Cesium 对象添加到 viewer 中。虚方法，在各 vue 组件中实现。
	   * @returns {Promise<Boolean>} 操作成功返回 true，失败返回 false。
	   */
	  mount: function mount() {
	    return regenerator.async(function mount$(_context8) {
	      while (1) {
	        switch (_context8.prev = _context8.next) {
	          case 0:
	            return _context8.abrupt("return", true);

	          case 1:
	          case "end":
	            return _context8.stop();
	        }
	      }
	    });
	  },

	  /**
	   * Unmount Cesium objects asynchronously. 异步卸载 Cesium 对象，即将 Cesium 对象从 viewer 移除。虚方法，在各 vue 组件中实现。
	   * @returns {Promise<Boolean>} 操作成功返回 true，失败返回 false。
	   */
	  unmount: function unmount() {
	    return regenerator.async(function unmount$(_context9) {
	      while (1) {
	        switch (_context9.prev = _context9.next) {
	          case 0:
	            return _context9.abrupt("return", true);

	          case 1:
	          case "end":
	            return _context9.stop();
	        }
	      }
	    });
	  },

	  /**
	   * Get the injected object. 获取注入的对象。主要是为了获取父组件和父组件的 Cesium 对象。
	   * @returns {Object}
	   */
	  getServices: function getServices() {
	    return services.methods.getServices.call(this);
	  },

	  /**
	   * 将 props 转换为 Cesium 对象
	   * @param {Object} props
	   */
	  transformProps: function transformProps(props) {
	    var cesiumClass = this.cesiumClass;
	    var options = {};
	    var that = this;
	    props && keys$1(props).forEach(function (vueProp) {
	      var cesiumProp = vueProp; // The properties of the following Cesium instance objects are HTML or Vue reserved words and require special handling.
	      // 以下 Cesium 实例对象的属性是 HTML 或 Vue 保留字，需要特别处理一下。

	      if (vueProp === 'labelStyle' || vueProp === 'wmtsStyle') {
	        cesiumProp = 'style';
	      } else if (vueProp === 'bmKey') {
	        cesiumProp = 'key';
	      }

	      if (graphics.indexOf(cesiumProp) !== -1 && getClassName(props[vueProp]) !== 'undefined' && getClassName(props[vueProp]).indexOf('Graphics') === -1 && (cesiumClass === 'Entity' || cesiumClass.indexOf('DataSource') !== -1)) {
	        options[cesiumProp] = that.transformProps(props[vueProp]);
	      } else {
	        options[cesiumProp] = that.transformProp(vueProp, props[vueProp]);
	      }
	    }); // Remove empty objects to avoid initialization errors when Cesium objects are initialized with null values.
	    // 移除空对象，避免 Cesium 对象初始化时传入空值导致初始化报错。

	    this.removeNullItem(options);
	    return options;
	  },
	  transformProp: function transformProp(prop, value) {
	    var isEmptyObj = this.isEmptyObj,
	        cesiumClass = this.cesiumClass;

	    if (graphics.indexOf(prop) !== -1 && getClassName(value) !== 'undefined' && getClassName(value).indexOf('Graphics') === -1 && (cesiumClass === 'Entity' || cesiumClass.indexOf('DataSource') !== -1)) {
	      return this.transformProps(value);
	    } else {
	      var cmpName = this.$options.name;
	      var propOptions = allProps[prop] && allProps[prop].props[prop];
	      return propOptions && propOptions.watcherOptions && !isEmptyObj(value) ? propOptions.watcherOptions.cesiumObjectBuilder.call(this, value) : isFunction(value) && cmpName && (cmpName.indexOf('graphics') !== -1 || cmpName === 'vc-entity') ? new Cesium.CallbackProperty(value, false) : value;
	    }
	  },

	  /**
	   * The action before the component is loaded. 组件加载前的操作。
	   */
	  beforeLoad: function beforeLoad() {
	    return regenerator.async(function beforeLoad$(_context10) {
	      while (1) {
	        switch (_context10.prev = _context10.next) {
	          case 0:
	            if (!this.$parent.nowaiting) {
	              _context10.next = 4;
	              break;
	            }

	            return _context10.abrupt("return", true);

	          case 4:
	            _context10.next = 6;
	            return regenerator.awrap(this.$parent.createPromise);

	          case 6:
	          case "end":
	            return _context10.stop();
	        }
	      }
	    }, null, this);
	  },

	  /**
	   * 获取 vc-viewer 组件
	   */
	  getParent: getParent
	};
	/**
	 * VueCesium common minxin
	 */

	var common = {
	  VM_PROP: VM_PROP,
	  mixins: [services],
	  methods: methods,
	  data: function data() {
	    return {
	      unwatchFns: []
	    };
	  },
	  created: function created() {
	    var _this = this;

	    this._mounted = false;
	    this.cesiumClass = nameClassMap[this.$options.name];
	    var beforeLoad = this.beforeLoad,
	        load = this.load;
	    var $parent = getParent(this.$parent); // this._createPromise = Promise.resolve(beforeLoad()).then(() => load())

	    this._createPromise = promise$1.resolve(beforeLoad()).then(function () {
	      return new promise$1(function (resolve, reject) {
	        var viewer = $parent.viewer;
	        viewer && resolve(load());
	        $parent.$on('ready', function () {
	          resolve(load()); // .then(val => resolve(val))
	          // .catch((error) => reject(new Error(`[VueCesium] ERROR: An error occurred during the initialization of the ${this.cesiumClass}!` + error)))
	        });
	      });
	    });

	    defineProperties$1(this, {
	      createPromise: {
	        enumerable: true,
	        get: function get() {
	          return _this._createPromise;
	        }
	      },
	      cesiumObject: {
	        enumerable: true,
	        get: function get() {
	          return _this.originInstance;
	        }
	      },
	      mounted: {
	        enumerable: true,
	        get: function get() {
	          return _this._mounted;
	        }
	      }
	    });
	  },
	  destroyed: function destroyed() {
	    var _this2 = this;

	    this.unload().then(function () {
	      _this2.$emit('destroyed', _this2);
	    });
	  }
	};

	function getClassName(objClass) {
	  if (objClass && objClass.constructor) {
	    var strFun = objClass.constructor.toString();
	    var className = strFun.substr(0, strFun.indexOf('('));
	    className = className.replace('function', '');
	    return className.replace(/(^\s*)|(\s*$)/gi, '');
	  }

	  return _typeof(objClass);
	}

	function extractChildren(slots) {
	  var slotNames = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
	  return keys$1(slots).reduce(function (all, name) {
	    if (!slotNames.length || slotNames.includes(name)) {
	      all = all.concat(slots[name]);
	    }

	    return all;
	  }, []);
	}

	/**
	 * Renders stub VNode for component.
	 */

	var stubVNode = {
	  /**
	   * @param {function} h
	   * @returns {VNode}
	   */
	  render: function render(h) {
	    var options = this.$options.stubVNode || {}; // render as HTML comment

	    if (options.empty) {
	      var vnode = h();

	      if (typeof options.empty === 'string') {
	        vnode.text = options.empty;
	      } else if (typeof options.empty === 'function') {
	        vnode.text = options.empty.call(this);
	      }

	      return vnode;
	    }

	    var children;

	    if (options.slots === false) {
	      children = undefined;
	    } else {
	      children = extractChildren(this.$slots, options.slots);
	    }

	    var attrs = typeof options.attrs === 'function' ? options.attrs.call(this) : options.attrs;
	    var data = {
	      attrs: attrs,
	      style: {
	        display: 'none !important'
	      }
	    };
	    return h(options.tag || 'i', data, children);
	  }
	};

	/**
	 * VueCesium 的基础虚拟组件，mixin 注入需要实现以下方法。
	 */

	var cmp = {
	  mixins: [stubVNode, common],
	  methods: {
	    /**
	     * 获取注入对象。
	     * @returns {Object}
	     */
	    getServices: function getServices() {
	      return common.methods.getServices.call(this);
	    },

	    /**
	     * 加载组件。
	     * @returns {Promise}
	     */
	    load: function load() {
	      return common.methods.load.call(this);
	    },

	    /**
	     * 重载组件。
	     * @returns {Promise}
	     */
	    reload: function reload() {
	      return common.methods.reload.call(this);
	    },

	    /**
	     * 卸载组件。
	     * @return {Promise}
	     */
	    unload: function unload() {
	      return common.methods.unload.call(this);
	    }
	  }
	};

	var script$1 = {
	  name: 'vc-layer-imagery',
	  mixins: [cmp, cutoutRectangle, colorToAlpha],
	  props: {
	    imageryProvider: Object,
	    rectangle: Object,
	    alpha: {
	      type: [Number, Function],
	      default: 1.0
	    },
	    brightness: {
	      type: [Number, Function],
	      default: 1.0
	    },
	    contrast: {
	      type: [Number, Function],
	      default: 1.0
	    },
	    hue: {
	      type: [Number, Function],
	      default: 0.0
	    },
	    saturation: {
	      type: [Number, Function],
	      default: 1.0
	    },
	    gamma: {
	      type: [Number, Function],
	      default: 1.0
	    },
	    splitDirection: Number,
	    minificationFilter: Number,
	    magnificationFilter: Number,
	    show: {
	      type: Boolean,
	      default: true
	    },
	    maximumAnisotropy: Number,
	    minimumTerrainLevel: Number,
	    maximumTerrainLevel: Number,
	    colorToAlphaThreshold: {
	      type: Number,
	      default: 0.004
	    },
	    sortOrder: Number
	  },
	  methods: {
	    /**
	     * ImageryLayer 初始化方式较为特殊，这儿覆盖重写 createCesiumObject 方法。
	     */
	    createCesiumObject: function createCesiumObject() {
	      var $props, transformProps, requiredArg, options;
	      return regenerator.async(function createCesiumObject$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              $props = this.$props, transformProps = this.transformProps, requiredArg = this.requiredArg;
	              options = transformProps($props);
	              return _context.abrupt("return", new Cesium.ImageryLayer(requiredArg || {}, options));

	            case 3:
	            case "end":
	              return _context.stop();
	          }
	        }
	      }, null, this);
	    },
	    mount: function mount() {
	      var viewer, imageryLayer, sortOrder;
	      return regenerator.async(function mount$(_context2) {
	        while (1) {
	          switch (_context2.prev = _context2.next) {
	            case 0:
	              viewer = this.viewer, imageryLayer = this.imageryLayer, sortOrder = this.sortOrder;
	              imageryLayer.sortOrder = sortOrder;
	              viewer.imageryLayers.add(imageryLayer);
	              return _context2.abrupt("return", !this.viewer.isDestroyed() && viewer.imageryLayers.contains(imageryLayer));

	            case 4:
	            case "end":
	              return _context2.stop();
	          }
	        }
	      }, null, this);
	    },
	    unmount: function unmount() {
	      var viewer, imageryLayer;
	      return regenerator.async(function unmount$(_context3) {
	        while (1) {
	          switch (_context3.prev = _context3.next) {
	            case 0:
	              viewer = this.viewer, imageryLayer = this.imageryLayer;
	              return _context3.abrupt("return", !viewer.isDestroyed() && viewer.imageryLayers.remove(imageryLayer));

	            case 2:
	            case "end":
	              return _context3.stop();
	          }
	        }
	      }, null, this);
	    },
	    refresh: function refresh() {
	      var _this = this;

	      return regenerator.async(function refresh$(_context4) {
	        while (1) {
	          switch (_context4.prev = _context4.next) {
	            case 0:
	              return _context4.abrupt("return", this.unmount().then(function () {
	                return _this.createCesiumObject().then(function (cesiumObject) {
	                  _this.originInstance = cesiumObject;
	                  return _this.mount();
	                });
	              }));

	            case 1:
	            case "end":
	              return _context4.stop();
	          }
	        }
	      }, null, this);
	    },
	    setProvider: function setProvider(provider) {
	      if (provider !== this._provider) {
	        this._provider = provider;
	        provider && this.refresh();
	        var listener = this.$listeners['update:imageryProvider'];
	        if (listener) this.$emit('update:imageryProvider', provider);
	      }
	    },
	    getServices: function getServices() {
	      var vm = this;
	      return multiMergeDescriptors(cmp.methods.getServices.call(this), {
	        get imageryLayer() {
	          return vm.imageryLayer;
	        },

	        get providerContainer() {
	          return vm;
	        }

	      });
	    }
	  },
	  stubVNode: {
	    attrs: function attrs() {
	      return {
	        class: this.$options.name
	      };
	    }
	  },
	  created: function created() {
	    var _this2 = this;

	    this._provider = undefined;

	    defineProperties$1(this, {
	      imageryLayer: {
	        enumerable: true,
	        get: function get() {
	          return _this2.cesiumObject;
	        }
	      },
	      requiredArg: {
	        enumerable: true,
	        get: function get() {
	          return _this2.imageryProvider || _this2._provider;
	        }
	      }
	    });
	  }
	};

	/* script */
	var __vue_script__$1 = script$1;
	/* template */

	/* style */

	var __vue_inject_styles__$1 = undefined;
	/* scoped */

	var __vue_scope_id__$1 = undefined;
	/* functional template */

	var __vue_is_functional_template__$1 = undefined;
	/* component normalizer */

	function __vue_normalize__$1(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "ImageryLayer.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var ImageryLayer = __vue_normalize__$1({}, __vue_inject_styles__$1, __vue_script__$1, __vue_scope_id__$1, __vue_is_functional_template__$1);

	function plugin$1(Vue) {

	  if (plugin$1.installed) {
	    return;
	  }

	  plugin$1.installed = true;
	  Vue.component(ImageryLayer.name, ImageryLayer);
	}

	var ImageryLayer$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$1,
		ImageryLayer: ImageryLayer,
		install: plugin$1
	});

	var coordtransform = require('coordtransform');

	var methods$1 = {
	  mount: function mount() {
	    var _this = this;

	    var imageryProvider, providerContainer, projectionTransforms, ignoreTransforms, _Cesium, WebMercatorTilingScheme, Cartographic, CesiumMath, tilingScheme, projection, nativeProject, nativeUnProject, projectMethods, unprojectMethods;

	    return regenerator.async(function mount$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            imageryProvider = this.imageryProvider, providerContainer = this.providerContainer, projectionTransforms = this.projectionTransforms;
	            imageryProvider.readyPromise.then(function () {
	              var listener = _this.$listeners.readyPromise;
	              listener && _this.$emit('readyPromise', imageryProvider);
	            }).otherwise(function (error) {
	              throw new Cesium.DeveloperError(error);
	            });

	            if (projectionTransforms && projectionTransforms.from !== projectionTransforms.to) {
	              ignoreTransforms = this.$options.name === 'vc-provider-imagery-baidumap' || this.$options.name === 'vc-provider-imagery-tianditu' && imageryProvider._epsgCode === '4490';

	              if (!ignoreTransforms) {
	                _Cesium = Cesium, WebMercatorTilingScheme = _Cesium.WebMercatorTilingScheme, Cartographic = _Cesium.Cartographic, CesiumMath = _Cesium.Math;
	                tilingScheme = new WebMercatorTilingScheme();
	                projection = tilingScheme.projection;
	                nativeProject = projection.project;
	                nativeUnProject = projection.unproject;

	                if (projectionTransforms.to.toUpperCase() === 'WGS84') {
	                  projectMethods = 'wgs84togcj02';
	                  unprojectMethods = 'gcj02towgs84';
	                } else if (projectionTransforms.to.toUpperCase() === 'GCJ02') {
	                  projectMethods = 'gcj02towgs84';
	                  unprojectMethods = 'wgs84togcj02';
	                }

	                if (projectMethods && unprojectMethods) {
	                  projection.project = function (cartographic, result) {
	                    result = result || {};
	                    result = coordtransform[projectMethods](CesiumMath.toDegrees(cartographic.longitude), CesiumMath.toDegrees(cartographic.latitude));
	                    return nativeProject.call(this, new Cartographic(CesiumMath.toRadians(result[0]), CesiumMath.toRadians(result[1])));
	                  };

	                  projection.unproject = function (cartesian2, result) {
	                    result = result || {};
	                    var cartographic = nativeUnProject.call(this, cartesian2);
	                    result = coordtransform[unprojectMethods](CesiumMath.toDegrees(cartographic.longitude), CesiumMath.toDegrees(cartographic.latitude));
	                    return new Cartographic(CesiumMath.toRadians(result[0]), CesiumMath.toRadians(result[1]));
	                  };

	                  imageryProvider._tilingScheme = tilingScheme;
	                }
	              }
	            }

	            bindEvents.call(this, imageryProvider, Events['imagery-layer-events'], true);
	            return _context.abrupt("return", providerContainer && providerContainer.setProvider(imageryProvider));

	          case 5:
	          case "end":
	            return _context.stop();
	        }
	      }
	    }, null, this);
	  },
	  unmount: function unmount() {
	    var imageryProvider, providerContainer;
	    return regenerator.async(function unmount$(_context2) {
	      while (1) {
	        switch (_context2.prev = _context2.next) {
	          case 0:
	            imageryProvider = this.imageryProvider, providerContainer = this.providerContainer;
	            bindEvents.call(this, imageryProvider, Events['imagery-layer-events'], false);
	            return _context2.abrupt("return", providerContainer && providerContainer.setProvider(undefined));

	          case 3:
	          case "end":
	            return _context2.stop();
	        }
	      }
	    }, null, this);
	  }
	};
	var mixinImageryProvider = {
	  mixins: [cmp],
	  methods: methods$1,
	  stubVNode: {
	    empty: function empty() {
	      return this.$options.name;
	    }
	  },
	  props: {
	    projectionTransforms: {
	      type: Boolean | Object,
	      default: false
	    }
	  },
	  created: function created() {
	    var _this2 = this;

	    this.renderByParent = true;

	    defineProperties$1(this, {
	      imageryProvider: {
	        enumerable: true,
	        get: function get() {
	          return _this2.cesiumObject;
	        }
	      },
	      providerContainer: {
	        enumerable: true,
	        get: function get() {
	          return _this2.$services && _this2.$services.providerContainer;
	        }
	      }
	    });
	  }
	};

	var script$2 = {
	  name: 'vc-provider-imagery-arcgis-mapserver',
	  mixins: [url, token, tileDiscardPolicy, layers, enablePickFeatures, rectangle, tilingScheme, ellipsoid, credit, tileWidth, tileHeight, maximumLevel, mixinImageryProvider],
	  props: {
	    usePreCachedTilesIfAvailable: {
	      type: Boolean,
	      default: true
	    }
	  }
	};

	/* script */
	var __vue_script__$2 = script$2;
	/* template */

	/* style */

	var __vue_inject_styles__$2 = undefined;
	/* scoped */

	var __vue_scope_id__$2 = undefined;
	/* functional template */

	var __vue_is_functional_template__$2 = undefined;
	/* component normalizer */

	function __vue_normalize__$2(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "ArcGisMapServerImageryProvider.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var ArcGisMapServerImageryProvider = __vue_normalize__$2({}, __vue_inject_styles__$2, __vue_script__$2, __vue_scope_id__$2, __vue_is_functional_template__$2);

	function plugin$2(Vue) {

	  if (plugin$2.installed) {
	    return;
	  }

	  plugin$2.installed = true;
	  Vue.component(ArcGisMapServerImageryProvider.name, ArcGisMapServerImageryProvider);
	}

	var ArcGisMapServerImageryProvider$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$2,
		ArcGisMapServerImageryProvider: ArcGisMapServerImageryProvider,
		install: plugin$2
	});

	var script$3 = {
	  name: 'vc-provider-imagery-bingmaps',
	  mixins: [url, ellipsoid, tileDiscardPolicy, mixinImageryProvider],
	  props: {
	    bmKey: String,
	    tileProtocol: String,
	    mapStyle: {
	      type: String,
	      default: 'Aerial'
	    },
	    culture: {
	      type: String,
	      default: ''
	    }
	  }
	};

	/* script */
	var __vue_script__$3 = script$3;
	/* template */

	/* style */

	var __vue_inject_styles__$3 = undefined;
	/* scoped */

	var __vue_scope_id__$3 = undefined;
	/* functional template */

	var __vue_is_functional_template__$3 = undefined;
	/* component normalizer */

	function __vue_normalize__$3(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "BingMapsImageryProvider.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var BingMapsImageryProvider = __vue_normalize__$3({}, __vue_inject_styles__$3, __vue_script__$3, __vue_scope_id__$3, __vue_is_functional_template__$3);

	function plugin$3(Vue) {

	  if (plugin$3.installed) {
	    return;
	  }

	  plugin$3.installed = true;
	  Vue.component(BingMapsImageryProvider.name, BingMapsImageryProvider);
	}

	var BingMapsImageryProvider$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$3,
		BingMapsImageryProvider: BingMapsImageryProvider,
		install: plugin$3
	});

	var script$4 = {
	  name: 'vc-provider-imagery-googleearth-enterprise',
	  mixins: [url, ellipsoid, tileDiscardPolicy, credit, mixinImageryProvider],
	  props: {
	    metadata: Object
	  }
	};

	/* script */
	var __vue_script__$4 = script$4;
	/* template */

	/* style */

	var __vue_inject_styles__$4 = undefined;
	/* scoped */

	var __vue_scope_id__$4 = undefined;
	/* functional template */

	var __vue_is_functional_template__$4 = undefined;
	/* component normalizer */

	function __vue_normalize__$4(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "GoogleEarthEnterpriseImageryProvider.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var GoogleEarthEnterpriseImageryProvider = __vue_normalize__$4({}, __vue_inject_styles__$4, __vue_script__$4, __vue_scope_id__$4, __vue_is_functional_template__$4);

	function plugin$4(Vue) {

	  if (plugin$4.installed) {
	    return;
	  }

	  plugin$4.installed = true;
	  Vue.component(GoogleEarthEnterpriseImageryProvider.name, GoogleEarthEnterpriseImageryProvider);
	}

	var GoogleEarthEnterpriseImageryProvider$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$4,
		GoogleEarthEnterpriseImageryProvider: GoogleEarthEnterpriseImageryProvider,
		install: plugin$4
	});

	var script$5 = {
	  name: 'vc-provider-imagery-grid',
	  mixins: [tilingScheme, ellipsoid, tileWidth, tileHeight, glowColor, mixinImageryProvider],
	  props: {
	    cells: {
	      type: Number,
	      default: 8
	    },
	    color: {
	      type: [String, Object, Array],
	      default: function _default() {
	        return [1.0, 1.0, 1.0, 0.4];
	      },
	      watcherOptions: {
	        cesiumObjectBuilder: makeColor
	      }
	    },
	    glowWidth: {
	      type: Number,
	      default: 6
	    },
	    backgroundColor: {
	      type: [String, Array, Object],
	      default: function _default() {
	        return [0.0, 0.5, 0.0, 0.2];
	      },
	      watcherOptions: {
	        cesiumObjectBuilder: makeColor
	      }
	    },
	    canvasSize: {
	      type: Number,
	      default: 256
	    }
	  }
	};

	/* script */
	var __vue_script__$5 = script$5;
	/* template */

	/* style */

	var __vue_inject_styles__$5 = undefined;
	/* scoped */

	var __vue_scope_id__$5 = undefined;
	/* functional template */

	var __vue_is_functional_template__$5 = undefined;
	/* component normalizer */

	function __vue_normalize__$5(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "GridImageryProvider.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var GridImageryProvider = __vue_normalize__$5({}, __vue_inject_styles__$5, __vue_script__$5, __vue_scope_id__$5, __vue_is_functional_template__$5);

	function plugin$5(Vue) {

	  if (plugin$5.installed) {
	    return;
	  }

	  plugin$5.installed = true;
	  Vue.component(GridImageryProvider.name, GridImageryProvider);
	}

	var GridImageryProvider$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$5,
		GridImageryProvider: GridImageryProvider,
		install: plugin$5
	});

	var script$6 = {
	  name: 'vc-provider-imagery-ion',
	  mixins: [accessToken, mixinImageryProvider],
	  props: {
	    assetId: Number,
	    server: [String, Object]
	  }
	};

	/* script */
	var __vue_script__$6 = script$6;
	/* template */

	/* style */

	var __vue_inject_styles__$6 = undefined;
	/* scoped */

	var __vue_scope_id__$6 = undefined;
	/* functional template */

	var __vue_is_functional_template__$6 = undefined;
	/* component normalizer */

	function __vue_normalize__$6(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "IonImageryProvider.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var IonImageryProvider = __vue_normalize__$6({}, __vue_inject_styles__$6, __vue_script__$6, __vue_scope_id__$6, __vue_is_functional_template__$6);

	function plugin$6(Vue) {

	  if (plugin$6.installed) {
	    return;
	  }

	  plugin$6.installed = true;
	  Vue.component(IonImageryProvider.name, IonImageryProvider);
	}

	var IonImageryProvider$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$6,
		IonImageryProvider: IonImageryProvider,
		install: plugin$6
	});

	var script$7 = {
	  name: 'vc-provider-imagery-mapbox',
	  mixins: [accessToken, format, ellipsoid, minimumLevel, maximumLevel, rectangle, credit, mixinImageryProvider],
	  props: {
	    url: {
	      type: String,
	      default: 'https://api.mapbox.com/v4/'
	    },
	    mapId: String
	  }
	};

	/* script */
	var __vue_script__$7 = script$7;
	/* template */

	/* style */

	var __vue_inject_styles__$7 = undefined;
	/* scoped */

	var __vue_scope_id__$7 = undefined;
	/* functional template */

	var __vue_is_functional_template__$7 = undefined;
	/* component normalizer */

	function __vue_normalize__$7(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "MapboxImageryProvider.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var MapboxImageryProvider = __vue_normalize__$7({}, __vue_inject_styles__$7, __vue_script__$7, __vue_scope_id__$7, __vue_is_functional_template__$7);

	function plugin$7(Vue) {

	  if (plugin$7.installed) {
	    return;
	  }

	  plugin$7.installed = true;
	  Vue.component(MapboxImageryProvider.name, MapboxImageryProvider);
	}

	var MapboxImageryProvider$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$7,
		MapboxImageryProvider: MapboxImageryProvider,
		install: plugin$7
	});

	var script$8 = {
	  name: 'vc-provider-imagery-style-mapbox',
	  mixins: [accessToken, ellipsoid, minimumLevel, maximumLevel, rectangle, credit, mixinImageryProvider],
	  props: {
	    url: {
	      type: String,
	      default: 'https://api.mapbox.com/styles/v1/'
	    },
	    username: {
	      type: String,
	      default: 'mapbox'
	    },
	    styleId: String,
	    tilesize: {
	      type: Number,
	      default: 512
	    },
	    scaleFactor: Boolean
	  }
	};

	/* script */
	var __vue_script__$8 = script$8;
	/* template */

	/* style */

	var __vue_inject_styles__$8 = undefined;
	/* scoped */

	var __vue_scope_id__$8 = undefined;
	/* functional template */

	var __vue_is_functional_template__$8 = undefined;
	/* component normalizer */

	function __vue_normalize__$8(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "MapboxStyleImageryProvider.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var MapboxStyleImageryProvider = __vue_normalize__$8({}, __vue_inject_styles__$8, __vue_script__$8, __vue_scope_id__$8, __vue_is_functional_template__$8);

	function plugin$8(Vue) {

	  if (plugin$8.installed) {
	    return;
	  }

	  plugin$8.installed = true;
	  Vue.component(MapboxStyleImageryProvider.name, MapboxStyleImageryProvider);
	}

	var MapboxStyleImageryProvider$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$8,
		MapboxStyleImageryProvider: MapboxStyleImageryProvider,
		install: plugin$8
	});

	var script$9 = {
	  name: 'vc-provider-imagery-openstreetmap',
	  mixins: [mixinImageryProvider, fileExtension, rectangle, minimumLevel, maximumLevel, ellipsoid],
	  props: {
	    url: {
	      type: String,
	      default: 'https://a.tile.openstreetmap.org'
	    },
	    credit: {
	      type: [String, Object],
	      default: 'MapQuest, Open Street Map and contributors, CC-BY-SA'
	    }
	  }
	};

	/* script */
	var __vue_script__$9 = script$9;
	/* template */

	/* style */

	var __vue_inject_styles__$9 = undefined;
	/* scoped */

	var __vue_scope_id__$9 = undefined;
	/* functional template */

	var __vue_is_functional_template__$9 = undefined;
	/* component normalizer */

	function __vue_normalize__$9(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "OpenStreetMapImageryProvider.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var OpenStreetMapImageryProvider = __vue_normalize__$9({}, __vue_inject_styles__$9, __vue_script__$9, __vue_scope_id__$9, __vue_is_functional_template__$9);

	function plugin$9(Vue) {

	  if (plugin$9.installed) {
	    return;
	  }

	  plugin$9.installed = true;
	  Vue.component(OpenStreetMapImageryProvider.name, OpenStreetMapImageryProvider);
	}

	var OpenStreetMapImageryProvider$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$9,
		OpenStreetMapImageryProvider: OpenStreetMapImageryProvider,
		install: plugin$9
	});

	var script$a = {
	  name: 'vc-provider-imagery-tile-single',
	  mixins: [url, rectangle, credit, ellipsoid, mixinImageryProvider]
	};

	/* script */
	var __vue_script__$a = script$a;
	/* template */

	/* style */

	var __vue_inject_styles__$a = undefined;
	/* scoped */

	var __vue_scope_id__$a = undefined;
	/* functional template */

	var __vue_is_functional_template__$a = undefined;
	/* component normalizer */

	function __vue_normalize__$a(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "SingleTileImageryProvider.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var SingleTileImageryProvider = __vue_normalize__$a({}, __vue_inject_styles__$a, __vue_script__$a, __vue_scope_id__$a, __vue_is_functional_template__$a);

	function plugin$a(Vue) {

	  if (plugin$a.installed) {
	    return;
	  }

	  plugin$a.installed = true;
	  Vue.component(SingleTileImageryProvider.name, SingleTileImageryProvider);
	}

	var SingleTileImageryProvider$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$a,
		SingleTileImageryProvider: SingleTileImageryProvider,
		install: plugin$a
	});

	var script$b = {
	  name: 'vc-provider-imagery-tile-coordinates',
	  mixins: [tilingScheme, ellipsoid, tileWidth, tileHeight, mixinImageryProvider],
	  props: {
	    color: {
	      type: [Object, String, Array],
	      default: 'YELLOW'
	    }
	  }
	};

	/* script */
	var __vue_script__$b = script$b;
	/* template */

	/* style */

	var __vue_inject_styles__$b = undefined;
	/* scoped */

	var __vue_scope_id__$b = undefined;
	/* functional template */

	var __vue_is_functional_template__$b = undefined;
	/* component normalizer */

	function __vue_normalize__$b(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "TileCoordinatesImageryProvider.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var TileCoordinatesImageryProvider = __vue_normalize__$b({}, __vue_inject_styles__$b, __vue_script__$b, __vue_scope_id__$b, __vue_is_functional_template__$b);

	function plugin$b(Vue) {

	  if (plugin$b.installed) {
	    return;
	  }

	  plugin$b.installed = true;
	  Vue.component(TileCoordinatesImageryProvider.name, TileCoordinatesImageryProvider);
	}

	var TileCoordinatesImageryProvider$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$b,
		TileCoordinatesImageryProvider: TileCoordinatesImageryProvider,
		install: plugin$b
	});

	var script$c = {
	  name: 'vc-provider-imagery-tile-mapservice',
	  mixins: [url, fileExtension, credit, minimumLevel, maximumLevel, rectangle, tilingScheme, ellipsoid, tileWidth, tileHeight, mixinImageryProvider],
	  props: {
	    flipXY: Boolean
	  }
	};

	/* script */
	var __vue_script__$c = script$c;
	/* template */

	/* style */

	var __vue_inject_styles__$c = undefined;
	/* scoped */

	var __vue_scope_id__$c = undefined;
	/* functional template */

	var __vue_is_functional_template__$c = undefined;
	/* component normalizer */

	function __vue_normalize__$c(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "TileMapServiceImageryProvider.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var TileMapServiceImageryProvider = __vue_normalize__$c({}, __vue_inject_styles__$c, __vue_script__$c, __vue_scope_id__$c, __vue_is_functional_template__$c);

	function plugin$c(Vue) {

	  if (plugin$c.installed) {
	    return;
	  }

	  plugin$c.installed = true;
	  Vue.component(TileMapServiceImageryProvider.name, TileMapServiceImageryProvider);
	}

	var TileMapServiceImageryProvider$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$c,
		TileMapServiceImageryProvider: TileMapServiceImageryProvider,
		install: plugin$c
	});

	var script$d = {
	  name: 'vc-provider-imagery-urltemplate',
	  mixins: [url, subdomains, credit, minimumLevel, maximumLevel, rectangle, tilingScheme, ellipsoid, tileWidth, tileHeight, getFeatureInfoFormats, enablePickFeatures, mixinImageryProvider],
	  props: {
	    pickFeaturesUrl: [String, Object],
	    urlSchemeZeroPadding: Object,
	    hasAlphaChannel: {
	      type: Boolean,
	      default: true
	    },
	    customTags: Object
	  }
	};

	/* script */
	var __vue_script__$d = script$d;
	/* template */

	/* style */

	var __vue_inject_styles__$d = undefined;
	/* scoped */

	var __vue_scope_id__$d = undefined;
	/* functional template */

	var __vue_is_functional_template__$d = undefined;
	/* component normalizer */

	function __vue_normalize__$d(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "UrlTemplateImageryProvider.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var UrlTemplateImageryProvider = __vue_normalize__$d({}, __vue_inject_styles__$d, __vue_script__$d, __vue_scope_id__$d, __vue_is_functional_template__$d);

	function plugin$d(Vue) {

	  if (plugin$d.installed) {
	    return;
	  }

	  plugin$d.installed = true;
	  Vue.component(UrlTemplateImageryProvider.name, UrlTemplateImageryProvider);
	}

	var UrlTemplateImageryProvider$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$d,
		UrlTemplateImageryProvider: UrlTemplateImageryProvider,
		install: plugin$d
	});

	var script$e = {
	  name: 'vc-provider-imagery-wms',
	  mixins: [url, layers, enablePickFeatures, getFeatureInfoFormats, rectangle, tilingScheme, ellipsoid, tileWidth, tileHeight, minimumLevel, maximumLevel, credit, subdomains, clock, times, token, mixinImageryProvider],
	  props: {
	    parameters: Object,
	    getFeatureInfoParameters: Object,
	    crs: String,
	    srs: String
	  }
	};

	/* script */
	var __vue_script__$e = script$e;
	/* template */

	/* style */

	var __vue_inject_styles__$e = undefined;
	/* scoped */

	var __vue_scope_id__$e = undefined;
	/* functional template */

	var __vue_is_functional_template__$e = undefined;
	/* component normalizer */

	function __vue_normalize__$e(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "WebMapServiceImageryProvider.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var WebMapServiceImageryProvider = __vue_normalize__$e({}, __vue_inject_styles__$e, __vue_script__$e, __vue_scope_id__$e, __vue_is_functional_template__$e);

	function plugin$e(Vue) {

	  if (plugin$e.installed) {
	    return;
	  }

	  plugin$e.installed = true;
	  Vue.component(WebMapServiceImageryProvider.name, WebMapServiceImageryProvider);
	}

	var WebMapServiceImageryProvider$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$e,
		WebMapServiceImageryProvider: WebMapServiceImageryProvider,
		install: plugin$e
	});

	var script$f = {
	  name: 'vc-provider-imagery-wmts',
	  mixins: [url, clock, times, tileWidth, tileHeight, tilingScheme, rectangle, minimumLevel, maximumLevel, ellipsoid, credit, subdomains, dimensions, token, mixinImageryProvider],
	  props: {
	    format: {
	      type: String,
	      default: 'image/jpeg'
	    },
	    layer: String,
	    wmtsStyle: String,
	    tileMatrixSetID: String,
	    tileMatrixLabels: Array
	  },
	  methods: {
	    createCesiumObject: function createCesiumObject() {
	      var $props, transformProps, options;
	      return regenerator.async(function createCesiumObject$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              $props = this.$props, transformProps = this.transformProps;
	              options = transformProps($props);
	              options.url = typeof options.token !== 'undefined' ? options.url + '&tk=' + options.token : options.url;
	              return _context.abrupt("return", new Cesium.WebMapTileServiceImageryProvider(options));

	            case 4:
	            case "end":
	              return _context.stop();
	          }
	        }
	      }, null, this);
	    }
	  }
	};

	/* script */
	var __vue_script__$f = script$f;
	/* template */

	/* style */

	var __vue_inject_styles__$f = undefined;
	/* scoped */

	var __vue_scope_id__$f = undefined;
	/* functional template */

	var __vue_is_functional_template__$f = undefined;
	/* component normalizer */

	function __vue_normalize__$f(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "WebMapTileServiceImageryProvider.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var WebMapTileServiceImageryProvider = __vue_normalize__$f({}, __vue_inject_styles__$f, __vue_script__$f, __vue_scope_id__$f, __vue_is_functional_template__$f);

	function plugin$f(Vue) {

	  if (plugin$f.installed) {
	    return;
	  }

	  plugin$f.installed = true;
	  Vue.component(WebMapTileServiceImageryProvider.name, WebMapTileServiceImageryProvider);
	}

	var WebMapTileServiceImageryProvider$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$f,
		WebMapTileServiceImageryProvider: WebMapTileServiceImageryProvider,
		install: plugin$f
	});

	// 19.1.2.5 Object.freeze(O)

	var meta = _meta.onFreeze;

	_objectSap('freeze', function ($freeze) {
	  return function freeze(it) {
	    return $freeze && _isObject(it) ? $freeze(meta(it)) : it;
	  };
	});

	var freeze = _core.Object.freeze;

	var freeze$1 = freeze;

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	function _defineProperties(target, props) {
	  for (var i = 0; i < props.length; i++) {
	    var descriptor = props[i];
	    descriptor.enumerable = descriptor.enumerable || false;
	    descriptor.configurable = true;
	    if ("value" in descriptor) descriptor.writable = true;

	    defineProperty$1(target, descriptor.key, descriptor);
	  }
	}

	function _createClass(Constructor, protoProps, staticProps) {
	  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
	  if (staticProps) _defineProperties(Constructor, staticProps);
	  return Constructor;
	}

	var TiandituMapsStyle = {
	  IMG_W: 'img_w',
	  IMG_C: 'img_c',
	  CIA_W: 'cia_w',
	  CIA_C: 'cia_c',
	  VEC_W: 'vec_w',
	  VEC_C: 'vec_c',
	  TER_W: 'ter_w',
	  TER_C: 'ter_c',
	  CVA_W: 'cva_w',
	  CVA_C: 'cva_c',
	  CTA_W: 'cta_w',
	  CTA_C: 'cta_c',
	  EIA_W: 'eia_w',
	  EIA_C: 'eia_c',
	  EVA_W: 'eva_w',
	  EVA_C: 'eva_c'
	};

	var TiandituMapsStyleUrl = {};
	var TiandituMapsStyleLayer = {};
	var TiandituMapsStyleID = {};
	var TiandituMapsStyleFormat = {};
	var TiandituMapsStyleEPSG = {};
	var TiandituMapsStyleLabels = {};

	var TiandituImageryProvider =
	/*#__PURE__*/
	function () {
	  function TiandituImageryProvider(options) {
	    _classCallCheck(this, TiandituImageryProvider);

	    keys$1(TiandituMapsStyle).forEach(function (key) {
	      TiandituMapsStyleUrl[TiandituMapsStyle[key]] = options.protocol + '://{s}.tianditu.gov.cn/' + TiandituMapsStyle[key] + '/wmts';
	      TiandituMapsStyleLayer[TiandituMapsStyle[key]] = TiandituMapsStyle[key].slice(0, 3);
	      TiandituMapsStyleID[TiandituMapsStyle[key]] = TiandituMapsStyle[key].slice(4);
	      TiandituMapsStyleFormat[TiandituMapsStyle[key]] = 'tiles';

	      if (TiandituMapsStyleID[TiandituMapsStyle[key]] === 'w') {
	        TiandituMapsStyleEPSG[TiandituMapsStyle[key]] = '900913';
	      } else {
	        TiandituMapsStyleEPSG[TiandituMapsStyle[key]] = '4490';
	      }

	      switch (TiandituMapsStyle[key]) {
	        case 'img_w':
	        case 'img_c':
	        case 'cia_w':
	        case 'cia_c':
	        case 'cta_w':
	        case 'cta_c':
	          TiandituMapsStyleLabels[TiandituMapsStyle[key]] = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18'];
	          break;

	        case 'vec_w':
	        case 'vec_c':
	        case 'cva_w':
	        case 'cva_c':
	          TiandituMapsStyleLabels[TiandituMapsStyle[key]] = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19'];
	          break;

	        case 'ter_w':
	        case 'ter_c':
	          TiandituMapsStyleLabels[TiandituMapsStyle[key]] = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14'];
	          break;

	        case 'eia_w':
	        case 'eia_c':
	        case 'eva_w':
	        case 'eva_c':
	          TiandituMapsStyleLabels[TiandituMapsStyle[key]] = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10'];
	          break;
	      }
	    });

	    var _Cesium = Cesium,
	        Credit = _Cesium.Credit,
	        defaultValue = _Cesium.defaultValue,
	        Event = _Cesium.Event,
	        GeographicTilingScheme = _Cesium.GeographicTilingScheme,
	        WebMercatorTilingScheme = _Cesium.WebMercatorTilingScheme,
	        when = _Cesium.when;
	    options = defaultValue(options, {});
	    this._mapStyle = defaultValue(options.mapStyle, TiandituMapsStyle.IMG_W);
	    this._url = options.url || defaultValue(options.url, TiandituMapsStyleUrl[this._mapStyle]);
	    this._token = options.token;
	    this._layer = defaultValue(options.layer, TiandituMapsStyleLayer[this._mapStyle]);
	    this._style = defaultValue(options.style, 'default');
	    this._tileMatrixSetID = defaultValue(options.tileMatrixSetID, TiandituMapsStyleID[this._mapStyle]);
	    this._tileMatrixLabels = defaultValue(options.tileMatrixLabels, TiandituMapsStyleLabels[this._mapStyle]);
	    this._format = defaultValue(options.format, TiandituMapsStyleFormat[this._mapStyle]);
	    this._epsgCode = TiandituMapsStyleEPSG[this._mapStyle];
	    this._tilingScheme = this._epsgCode === '900913' ? new WebMercatorTilingScheme() : new GeographicTilingScheme();
	    this._tileWidth = defaultValue(options.tileWidth, 256);
	    this._tileHeight = defaultValue(options.tileHeight, 256);
	    this._minimumLevel = defaultValue(options.minimumLevel, 0);
	    this._maximumLevel = defaultValue(options.maximumLevel, TiandituMapsStyleLabels[this._mapStyle].length);
	    this._rectangle = defaultValue(options.rectangle, this.tilingScheme.rectangle);
	    this._readyPromise = when.resolve(true);
	    this._errorEvent = new Event();
	    var credit = defaultValue(options.credit, '天地图全球影像服务');
	    this._credit = typeof credit === 'string' ? new Credit(credit) : credit;
	    this._subdomains = defaultValue(options.subdomains, ['t0', 't1', 't2', 't3', 't4', 't5', 't6', 't7']);
	    this._tileDiscardPolicy = options.tileDiscardPolicy;
	  }

	  _createClass(TiandituImageryProvider, [{
	    key: "requestImage",
	    value: function requestImage(x, y, level) {
	      var url = buildImageResource.call(this, x, y, level);
	      return Cesium.ImageryProvider.loadImage(this, url);
	    }
	  }, {
	    key: "pickFeatures",
	    value: function pickFeatures() {}
	  }, {
	    key: "url",
	    get: function get() {
	      return this._url;
	    }
	  }, {
	    key: "mapStyle",
	    get: function get() {
	      return this._mapStyle;
	    }
	  }, {
	    key: "tileWidth",
	    get: function get() {
	      return this._tileWidth;
	    }
	  }, {
	    key: "tileHeight",
	    get: function get() {
	      return this._tileHeight;
	    }
	  }, {
	    key: "maximumLevel",
	    get: function get() {
	      return this._maximumLevel;
	    }
	  }, {
	    key: "minimumLevel",
	    get: function get() {
	      return this._minimumLevel;
	    }
	  }, {
	    key: "tilingScheme",
	    get: function get() {
	      return this._tilingScheme;
	    }
	  }, {
	    key: "rectangle",
	    get: function get() {
	      return this._rectangle;
	    }
	  }, {
	    key: "errorEvent",
	    get: function get() {
	      return this._errorEvent;
	    }
	  }, {
	    key: "ready",
	    get: function get() {
	      return true;
	    }
	  }, {
	    key: "readyPromise",
	    get: function get() {
	      return this._readyPromise;
	    }
	  }, {
	    key: "credit",
	    get: function get() {
	      return this._credit;
	    }
	  }, {
	    key: "hasAlphaChannel",
	    get: function get() {
	      return true;
	    }
	  }, {
	    key: "tileDiscardPolicy",
	    get: function get() {
	      return this._tileDiscardPolicy;
	    }
	  }]);

	  return TiandituImageryProvider;
	}();
	/**
	 * 构建天地图影像服务url, 调用时需要改变 this 指向为 TiandituImageryProvider
	 * @param {number} x
	 * @param {number} y
	 * @param {number} level
	 * @private
	 */


	function buildImageResource(x, y, level) {
	  var _Cesium2 = Cesium,
	      combine = _Cesium2.combine,
	      defined = _Cesium2.defined,
	      defaultValue = _Cesium2.defaultValue,
	      queryToObject = _Cesium2.queryToObject,
	      objectToQuery = _Cesium2.objectToQuery,
	      Uri = _Cesium2.Uri;

	  var freezeObject = freeze$1 || function () {};

	  var options = freezeObject({
	    service: 'WMTS',
	    version: '1.0.0',
	    request: 'GetTile'
	  });
	  this._epsgCode === '900913' && (level -= 1);
	  var tileMatrixLabels = this._tileMatrixLabels;
	  var tileMatrixLabel = defined(tileMatrixLabels) ? tileMatrixLabels[level] : level.toString();
	  var subdomains = this._subdomains;

	  var url = this._url.replace('{s}', subdomains[(x + y + level) % subdomains.length]);

	  var uri = new Uri(url);
	  var obj = queryToObject(defaultValue(uri.query, ''));
	  obj = combine(options, obj);
	  obj.tilematrix = tileMatrixLabel;
	  obj.layer = this._layer;
	  obj.style = this._style;
	  obj.tilerow = y;
	  obj.tilecol = x;
	  obj.tilematrixset = this._tileMatrixSetID;
	  obj.format = this._format;
	  uri.query = objectToQuery(obj);
	  url = uri.toString();
	  defined(this._proxy) && (url = this._proxy.getURL(url));
	  defined(this._token) && (url += '&tk=' + this._token);
	  return url;
	}

	var script$g = {
	  name: 'vc-provider-imagery-tianditu',
	  mixins: [minimumLevel, maximumLevel, mixinImageryProvider],
	  props: {
	    mapStyle: String,
	    token: String,
	    protocol: {
	      type: String,
	      default: 'https'
	    }
	  },
	  methods: {
	    createCesiumObject: function createCesiumObject() {
	      var $props, transformProps, setPropWatchers, unwatchFns, options;
	      return regenerator.async(function createCesiumObject$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              $props = this.$props, transformProps = this.transformProps, setPropWatchers = this.setPropWatchers, unwatchFns = this.unwatchFns;
	              options = transformProps($props);
	              Cesium.TiandituImageryProvider = TiandituImageryProvider; // 之前注册时 TiandituImageryProvider 可能还不存在，导致注册失败，这儿需要再注册 Vue 侦听器。
	              // 这种情况下会导致在`vc-viewer`组件的ready事件中对 'vc-provider-imagery-tianditu' 属性赋值失败。
	              // 原因是 `vc-viewer` 组件ready事件触发时，'vc-provider-imagery-tianditu'侦听器还没被创建呢。

	              if (unwatchFns.length === 0) {
	                setPropWatchers(true);
	              }

	              return _context.abrupt("return", new Cesium.TiandituImageryProvider(options));

	            case 5:
	            case "end":
	              return _context.stop();
	          }
	        }
	      }, null, this);
	    }
	  }
	};

	/* script */
	var __vue_script__$g = script$g;
	/* template */

	/* style */

	var __vue_inject_styles__$g = undefined;
	/* scoped */

	var __vue_scope_id__$g = undefined;
	/* functional template */

	var __vue_is_functional_template__$g = undefined;
	/* component normalizer */

	function __vue_normalize__$g(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "TiandituImageryProvider.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var TiandituImageryProvider$1 = __vue_normalize__$g({}, __vue_inject_styles__$g, __vue_script__$g, __vue_scope_id__$g, __vue_is_functional_template__$g);

	function plugin$g(Vue) {

	  if (plugin$g.installed) {
	    return;
	  }

	  plugin$g.installed = true;
	  Vue.component(TiandituImageryProvider$1.name, TiandituImageryProvider$1);
	}

	var TiandituImageryProvider$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$g,
		TiandituImageryProvider: TiandituImageryProvider$1,
		install: plugin$g
	});

	var _stringWs = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
	  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

	var space = '[' + _stringWs + ']';
	var non = '\u200b\u0085';
	var ltrim = RegExp('^' + space + space + '*');
	var rtrim = RegExp(space + space + '*$');

	var exporter = function (KEY, exec, ALIAS) {
	  var exp = {};
	  var FORCE = _fails(function () {
	    return !!_stringWs[KEY]() || non[KEY]() != non;
	  });
	  var fn = exp[KEY] = FORCE ? exec(trim) : _stringWs[KEY];
	  if (ALIAS) exp[ALIAS] = fn;
	  _export(_export.P + _export.F * FORCE, 'String', exp);
	};

	// 1 -> String#trimLeft
	// 2 -> String#trimRight
	// 3 -> String#trim
	var trim = exporter.trim = function (string, TYPE) {
	  string = String(_defined(string));
	  if (TYPE & 1) string = string.replace(ltrim, '');
	  if (TYPE & 2) string = string.replace(rtrim, '');
	  return string;
	};

	var _stringTrim = exporter;

	var $parseFloat = _global.parseFloat;
	var $trim = _stringTrim.trim;

	var _parseFloat = 1 / $parseFloat(_stringWs + '-0') !== -Infinity ? function parseFloat(str) {
	  var string = $trim(String(str), 3);
	  var result = $parseFloat(string);
	  return result === 0 && string.charAt(0) == '-' ? -0 : result;
	} : $parseFloat;

	// 18.2.4 parseFloat(string)
	_export(_export.G + _export.F * (parseFloat != _parseFloat), { parseFloat: _parseFloat });

	var _parseFloat$1 = _core.parseFloat;

	var _parseFloat$2 = _parseFloat$1;

	var $parseInt = _global.parseInt;
	var $trim$1 = _stringTrim.trim;

	var hex = /^[-+]?0[xX]/;

	var _parseInt = $parseInt(_stringWs + '08') !== 8 || $parseInt(_stringWs + '0x16') !== 22 ? function parseInt(str, radix) {
	  var string = $trim$1(String(str), 3);
	  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
	} : $parseInt;

	// 18.2.5 parseInt(string, radix)
	_export(_export.G + _export.F * (parseInt != _parseInt), { parseInt: _parseInt });

	var _parseInt$1 = _core.parseInt;

	var _parseInt$2 = _parseInt$1;

	/**
	 * 操作状态。
	 */
	var Status = {
	  NONE: 0,
	  STORING: 1,
	  STORED: 2,
	  FAILED: 3
	};
	/**
	 * 操作浏览器数据库 IndexedDB 类
	 */

	var IndexedDBScheduler =
	/*#__PURE__*/
	function () {
	  /**
	   *
	   * @param {Object} options
	   */
	  function IndexedDBScheduler(options) {
	    _classCallCheck(this, IndexedDBScheduler);

	    if (!Cesium.defined(options.name)) {
	      throw new Cesium.DeveloperError('options.name is required.');
	    }

	    var deferred = Cesium.when.defer();
	    this.dbname = options.name;
	    var dbRequest = window.indexedDB.open(this.dbname);
	    var that = this;

	    dbRequest.onsuccess = function (event) {
	      that.db = event.target.result;
	      that.version = that.db.version;
	      that.cachestatus = that.cachestatus || {};
	      deferred.resolve(that);
	    };

	    dbRequest.onupgradeneeded = function (event) {
	      that.db = event.target.result;
	      that.version = that.db.version;
	      deferred.resolve(that);
	    };

	    dbRequest.onerror = function (event) {
	      that.db = null;
	      deferred.reject('create database fail, error code : ' + event.target.errorcode);
	    };

	    this.layer = options.layer || null;
	    this.storageType = options.storageType || 'arrayBuffer';
	    this.creatingTable = !1;
	    this.cachestatus = {};
	    return deferred.promise;
	  }
	  /**
	   * 检查对象仓库是否存在。
	   * @param {String} storeName 对象仓库（表）名称
	   */


	  _createClass(IndexedDBScheduler, [{
	    key: "checkObjectStoreExist",
	    value: function checkObjectStoreExist(storeName) {
	      return Cesium.defined(this.db) ? this.db.objectStoreNames.contains(storeName) : false;
	    }
	    /**
	    *  创建 IndexedDB 浏对象仓库，IndexedDB 是浏览器提供的本地数据库
	    * @param {String} storeName 对象仓库（表）名称
	    * @returns {Promise}
	    */

	  }, {
	    key: "createObjectStore",
	    value: function createObjectStore(storeName) {
	      var deferred = Cesium.when.defer();

	      if (this.creatingTable) {
	        deferred.reject(false);
	      } else {
	        if (this.db.objectStoreNames.contains(storeName)) {
	          deferred.reject(false);
	          return deferred.promise;
	        }

	        this.creatingTable = true;

	        var version = _parseInt$2(this.db.version);

	        this.db.close();
	        var that = this; // 打开或新建 IndexedDB 数据库

	        var dbRequest = window.indexedDB.open(this.dbname, version + 1);

	        dbRequest.onupgradeneeded = function (event) {
	          var db = event.target.result;
	          that.db = db; // 创建对象仓库（表）

	          var objectStore = db.createObjectStore(storeName, {
	            keyPath: 'id'
	          });

	          if (Cesium.defined(objectStore)) {
	            // 创建索引
	            objectStore.createIndex('value', 'value', {
	              unique: false
	            });
	            that.creatingTable = false;
	            that.cachestatus = that.cachestatus || {};
	            that.cachestatus[storeName] = {};
	            that.db.close();

	            var _dbRequest = window.indexedDB.open(that.dbname);

	            _dbRequest.onsuccess = function (event) {
	              that.db = event.target.result;
	              deferred.resolve(true);
	            };
	          } else {
	            that.creatingTable = false;
	            deferred.resolve(false);
	          }
	        };

	        dbRequest.onsuccess = function (event) {
	          event.target.result.close();
	          deferred.resolve(true);
	        };

	        dbRequest.onerror = function (event) {
	          that.creatingTable = false;
	          deferred.reject(false);
	        };
	      }

	      return deferred.promise;
	    }
	    /**
	     * 向对象仓库写入数据记录。
	     * @param {String} storeName 对象仓库（表）名称
	     * @param {Number} id 主键
	     * @param {*} value 值
	     * @returns {Promise}
	     */

	  }, {
	    key: "putElementInDB",
	    value: function putElementInDB(storeName, id, value) {
	      var deferred = Cesium.when.defer();

	      if (!Cesium.defined(this.db)) {
	        deferred.reject(false);
	        return deferred.promise;
	      }

	      var cachestatus = this.cachestatus,
	          db = this.db;

	      if (Cesium.defined(cachestatus[storeName]) && Cesium.defined(cachestatus[storeName][id] && (cachestatus[storeName][id] === Status.STORING || cachestatus[storeName][id] === Status.STORED))) {
	        deferred.resolve(false);
	        return deferred.promise;
	      }

	      if (db.objectStoreNames.contains(storeName)) {
	        cachestatus[storeName] = cachestatus[storeName] || {};

	        try {
	          var request = db.transaction([storeName], 'readwrite').objectStore(storeName).add({
	            id: id,
	            value: value
	          });
	          cachestatus[storeName][id] = Status.STORING;

	          request.onsuccess = function (event) {
	            cachestatus[storeName][id] = Status.STORED;
	            deferred.resolve(true);
	          };

	          request.onerror = function (event) {
	            cachestatus[storeName][id] = Status.FAILED;
	            deferred.resolve(false);
	          };
	        } catch (error) {
	          deferred.reject(null);
	          return deferred.promise;
	        }
	      } else {
	        this.createObjectStore(storeName).then(function () {
	          var request = db.transaction([storeName], 'readwrite').objectStore(storeName).add({
	            id: id,
	            value: value
	          });

	          request.onsuccess = function (e) {
	            deferred.resolve(true);
	          };

	          request.onerror = function (e) {
	            deferred.reject(false);
	          };
	        }, function () {
	          deferred.reject(false);
	        });
	      }

	      return deferred.promise;
	    }
	    /**
	     * 向对象仓库读取数据。
	     * @param {String} storeName 对象仓库（表）名称
	     * @param {Number} id 主键
	     * @returns {Promise}
	     */

	  }, {
	    key: "getElementFromDB",
	    value: function getElementFromDB(storeName, id) {
	      var deferred = Cesium.when.defer();
	      var db = this.db;

	      if (!Cesium.defined(db)) {
	        return null;
	      }

	      if (!db.objectStoreNames.contains(storeName)) {
	        return null;
	      }

	      try {
	        var transaction = db.transaction([storeName]);
	        var objectStore = transaction.objectStore(storeName);
	        var request = objectStore.get(id);

	        request.onsuccess = function (e) {
	          return Cesium.defined(e.target.result) ? deferred.resolve(e.target.result.value) : deferred.reject(null);
	        };

	        request.onerror = function (e) {
	          deferred.reject(null);
	        };
	      } catch (error) {
	        deferred.reject(null);
	      }

	      return deferred.promise;
	    }
	    /**
	     * 更新数据。
	     * @param {String} storeName
	     * @param {Number} id
	     * @param {*} value
	     * @returns {Promise}
	     */

	  }, {
	    key: "updateElementInDB",
	    value: function updateElementInDB(storeName, id, value) {
	      var deferred = Cesium.when.defer();
	      var db = this.db;

	      if (!Cesium.defined(db)) {
	        deferred.resolve(false);
	        return deferred.promise;
	      }

	      if (!db.objectStoreNames.contains(storeName)) {
	        deferred.resolve(false);
	        return deferred.promise;
	      }

	      try {
	        var request = db.transaction([storeName], 'readwrite').objectStore(storeName).put({
	          id: id,
	          value: value
	        });

	        request.onsuccess = function () {
	          deferred.resolve(true);
	        };

	        request.onerror = function () {
	          deferred.resolve(false);
	        };
	      } catch (e) {
	        deferred.resolve(false);
	      }

	      return deferred.promise;
	    }
	    /**
	     * 移除数据。
	     * @param {String} storeName
	     * @param {Number} id
	     * @returns {Promise}
	     */

	  }, {
	    key: "removeElementFromDB",
	    value: function removeElementFromDB(storeName, id) {
	      var deferred = Cesium.when.defer();
	      var db = this.db;

	      if (!Cesium.defined(db)) {
	        deferred.resolve(false);
	        return deferred.promise;
	      }

	      if (!db.objectStoreNames.contains(storeName)) {
	        deferred.resolve(false);
	        return deferred.promise;
	      }

	      try {
	        var request = db.transaction([storeName], 'readwrite').objectStore(storeName).delete(id);

	        request.onsuccess = function () {
	          deferred.resolve(true);
	        };

	        request.onerror = function () {
	          deferred.resolve(false);
	        };
	      } catch (e) {
	        deferred.resolve(false);
	      }

	      return deferred.promise;
	    }
	    /**
	     *  清空对象仓库
	     * @param {String} storeName
	     */

	  }, {
	    key: "clear",
	    value: function clear(storeName) {
	      var deferred = Cesium.when.defer();
	      var db = this.db;

	      if (!Cesium.defined(db)) {
	        deferred.resolve(false);
	        return deferred.promise;
	      }

	      if (!db.objectStoreNames.contains(storeName)) {
	        deferred.resolve(false);
	        return deferred.promise;
	      }

	      try {
	        var request = db.transaction([storeName], 'readwrite').objectStore(storeName).clear();

	        request.onsuccess = function () {
	          deferred.resolve(true);
	        };

	        request.onerror = function () {
	          deferred.resolve(false);
	        };
	      } catch (e) {
	        deferred.resolve(false);
	      }

	      return deferred.promise;
	    }
	  }]);

	  return IndexedDBScheduler;
	}();

	var SuperMapImageryProvider =
	/*#__PURE__*/
	function () {
	  function SuperMapImageryProvider(options) {
	    _classCallCheck(this, SuperMapImageryProvider);

	    var _Cesium = Cesium,
	        appendForwardSlash = _Cesium.appendForwardSlash,
	        Credit = _Cesium.Credit,
	        defaultValue = _Cesium.defaultValue,
	        defined = _Cesium.defined,
	        DeveloperError = _Cesium.DeveloperError,
	        Event = _Cesium.Event,
	        Resource = _Cesium.Resource,
	        when = _Cesium.when,
	        Math = _Cesium.Math;
	    options = defaultValue(options, {});
	    var _options = options,
	        url = _options.url;

	    if (!defined(url)) {
	      throw new DeveloperError('options.url is required.');
	    }

	    var rootNodeUrlRealspace3D = url.substring(0, url.indexOf('datas'));
	    this.tablename = url.substring(0, url.indexOf('datas/') + 6, url.length);
	    var that = this;
	    var dbPromise = new IndexedDBScheduler({
	      name: rootNodeUrlRealspace3D + this.tablename
	    });
	    dbPromise.then(function (e) {
	      that.m_indexedDBScheduler = e;
	    });
	    this.m_indexedDBSetting = {
	      isOpen: false,
	      clear: function clear() {
	        that.m_indexedDBScheduler.clear(that.tablename);
	      }
	    };
	    this.isSci = false;
	    this.isTileMap = false;
	    var forwardSlashUrl = appendForwardSlash(url);

	    if (forwardSlashUrl.indexOf('rest/maps') > -1) {
	      this.isTileMap = true;
	      this.layersID = options.layersID;
	    } else {
	      if (!(forwardSlashUrl.indexOf('rest/realspace') > -1)) {
	        throw new DeveloperError('The url type is not supported!');
	      }

	      this.isSci = true;
	    }

	    this.m_url = forwardSlashUrl;
	    this.m_resource = Resource.createIfNeeded(forwardSlashUrl);
	    this.m_transparent = defaultValue(options.transparent, true);
	    this.m_name = options.name || '';
	    this.m_urlTemplate = undefined;
	    this.m_errorEvent = new Event();
	    this.m_fileExtension = 'png';
	    this.m_tileWidth = 256;
	    this.m_tileHeight = 256;
	    this.m_minimumLevel = defaultValue(options.minimumLevel, 0);
	    this.m_maximumLevel = options.maximumLevel;
	    this.m_rectangle = undefined;
	    this.m_tilingScheme = undefined;
	    this.m_tileDiscardPolicy = options.tileDiscardPolicy;
	    this.m_fRatio = defaultValue(options.ratio, Math.DEGREES_PER_RADIAN / 6378137.0);
	    this.m_scales = [];
	    this.m_coordUnit = 'DEGREE';
	    var credit = defaultValue(options.credit, new Credit('MapQuest, SuperMap iServer Imagery'));

	    if (typeof credit === 'string') {
	      credit = new Credit(credit);
	    }

	    this.m_credit = credit;
	    this.m_ready = false;
	    this.m_readyPromise = when.defer();
	    this.m_options = options;
	    init.call(this);
	  }

	  _createClass(SuperMapImageryProvider, [{
	    key: "getTileCredits",
	    value: function getTileCredits(x, y, level) {
	      if (!this.ready) {
	        throw new Cesium.DeveloperError('getTileCredits must not be called before the imagery provider is ready.');
	      }

	      return undefined;
	    }
	  }, {
	    key: "requestImage",
	    value: function requestImage(x, y, level, request) {
	      var _Cesium2 = Cesium,
	          defined = _Cesium2.defined,
	          DeveloperError = _Cesium2.DeveloperError,
	          ImageryProvider = _Cesium2.ImageryProvider,
	          when = _Cesium2.when;

	      if (!this.ready) {
	        throw new DeveloperError('requestImage must not be called before the imagery provider is ready.')();
	      }

	      var url = buildImageResource$1.call(this, x, y, level);
	      var resource = this.m_resource.getDerivedResource({
	        url: url,
	        request: request
	      });
	      var that = this;

	      if (this.m_indexedDBSetting.isOpen) {
	        if (defined(this.m_indexedDBScheduler)) {
	          var promise = this.m_indexedDBScheduler.getElementFromDB(this.tablename, url);
	          return defined(promise) ? when(promise, function (value) {
	            if (defined(value)) {
	              var image = new Image();
	              image.src = value;
	              return image;
	            }

	            return ImageryProvider.loadImage(that, resource);
	          }, function (e) {
	            return ImageryProvider.loadImage(that, resource);
	          }) : ImageryProvider.loadImage(that, resource);
	        }
	      }

	      return ImageryProvider.loadImage(this, resource);
	    }
	  }, {
	    key: "pickFeatures",
	    value: function pickFeatures() {}
	  }, {
	    key: "url",
	    get: function get() {
	      return this.m_url;
	    }
	  }, {
	    key: "name",
	    get: function get() {
	      return this.m_name;
	    },
	    set: function set(val) {
	      this.m_name = val;
	    }
	  }, {
	    key: "tileWidth",
	    get: function get() {
	      if (!this.m_ready) {
	        throw new Cesium.DeveloperError('tileWidth must not be called before the imagery provider is ready.');
	      }

	      return this.m_tileWidth;
	    }
	  }, {
	    key: "tileHeight",
	    get: function get() {
	      if (!this.m_ready) {
	        throw new Cesium.DeveloperError('tileHeight must not be called before the imagery provider is ready.');
	      }

	      return this.m_tileHeight;
	    }
	  }, {
	    key: "maximumLevel",
	    get: function get() {
	      if (!this.m_ready) {
	        throw new Cesium.DeveloperError('maximumLevel must not be called before the imagery provider is ready.');
	      }

	      return this.m_maximumLevel;
	    }
	  }, {
	    key: "minimumLevel",
	    get: function get() {
	      if (!this.m_ready) {
	        throw new Cesium.DeveloperError('minimumLevel must not be called before the imagery provider is ready.');
	      }

	      return this.m_minimumLevel;
	    }
	  }, {
	    key: "tilingScheme",
	    get: function get() {
	      if (!this.m_ready) {
	        throw new Cesium.DeveloperError('tilingScheme must not be called before the imagery provider is ready.');
	      }

	      return this.m_tilingScheme;
	    }
	  }, {
	    key: "rectangle",
	    get: function get() {
	      if (!this.m_ready) {
	        throw new Cesium.DeveloperError('rectangle must not be called before the imagery provider is ready.');
	      }

	      return this.m_rectangle;
	    }
	  }, {
	    key: "errorEvent",
	    get: function get() {
	      return this.m_errorEvent;
	    }
	  }, {
	    key: "ready",
	    get: function get() {
	      return this.m_ready;
	    }
	  }, {
	    key: "credit",
	    get: function get() {
	      return this.m_credit;
	    }
	  }, {
	    key: "hasAlphaChannel",
	    get: function get() {
	      return true;
	    }
	  }, {
	    key: "readyPromise",
	    get: function get() {
	      return this.m_readyPromise;
	    }
	  }, {
	    key: "ratio",
	    get: function get() {
	      return this.m_fRatio;
	    },
	    set: function set(val) {
	      this.m_fRatio = val;
	    }
	  }, {
	    key: "tileDiscardPolicy",
	    get: function get() {
	      return this.m_tileDiscardPolicy;
	    }
	  }]);

	  return SuperMapImageryProvider;
	}();

	var previousError = {};
	var ScaleTexts = ['1.690163571602655E-9', '3.3803271432053056E-9', '6.760654286410611E-9', '1.3521308572821242E-8', '2.7042617145642484E-8', '5.408523429128511E-8', '1.0817046858256998E-7', '2.1634093716513974E-7', '4.3268187433028044E-7', '8.653637486605571E-7', '1.7307274973211203E-6', '3.4614549946422405E-6', '6.9229099892844565E-6', '1.3845819978568952E-5', '2.7691639957137904E-5', '5.53832799142758E-5', '1.107665598285516E-4', '2.215331196571032E-4', '4.430662393142064E-4', '8.861324786284128E-4', '1.772264957256826E-3', '3.544529914513652E-3'];
	var Scales = [1.690163571602655e-9, 3.3803271432053056e-9, 6.760654286410611e-9, 1.3521308572821242e-8, 2.7042617145642484e-8, 5.408523429128511e-8, 1.0817046858256998e-7, 2.1634093716513974e-7, 4.3268187433028044e-7, 8.653637486605571e-7, 0.0000017307274973211203, 0.0000034614549946422405, 0.0000069229099892844565, 0.000013845819978568952, 0.000027691639957137904, 0.0000553832799142758, 0.0001107665598285516, 0.0002215331196571032, 0.0004430662393142064, 0.0008861324786284128, 0.001772264957256826, 0.003544529914513652];

	function buildImageResource$1(x, y, level) {
	  var url;

	  if (this.isTileMap) {
	    if (this.m_coordUnit === 'DEGREE') {
	      var scaleText = ScaleTexts[level + 1] || ScaleTexts[level];
	      url = this.m_urlTemplate.replace('{x}', x).replace('{y}', y).replace('{scale}', scaleText);
	    } else if (this.m_coordUnit === 'METER') {
	      var _scaleText = ScaleTexts[level];
	      url = this.m_urlTemplate.replace('{x}', x).replace('{y}', y).replace('{scale}', _scaleText);
	    }
	  } else {
	    url = this.m_urlTemplate.replace('{x}', x).replace('{y}', y).replace('{level}', level).replace('{fileExtension}', this.m_fileExtension);
	  }

	  return url;
	}

	function init() {
	  var _Cesium3 = Cesium,
	      Resource = _Cesium3.Resource,
	      when = _Cesium3.when;

	  if (this.isTileMap) {
	    var promise = Resource.fetchJsonp({
	      url: this.m_options.url + '.jsonp',
	      queryParameters: {
	        f: 'json'
	      }
	    });
	    when(promise, onFulfilledTileMap.bind(this), onRejected.bind(this));
	  } else {
	    // r(c.CREDENTIAL) && (o = c.addToken(o)),
	    when(Resource.fetchText({
	      url: this.url + 'config'
	    }), onFulfilledRest3D.bind(this), onRejected.bind(this));
	  }
	}

	function getMaximumLevelbyScale(scale) {
	  for (var t = Scales.length; t--;) {
	    if (scale[t] <= scale) {
	      return t;
	    }
	  }
	}

	function onFulfilledRest3D(xmlText) {
	  var options = parseConfigFromXmlText.call(this, xmlText);
	  var _Cesium4 = Cesium,
	      defaultValue = _Cesium4.defaultValue,
	      defined = _Cesium4.defined,
	      GeographicTilingScheme = _Cesium4.GeographicTilingScheme,
	      Math = _Cesium4.Math,
	      Rectangle = _Cesium4.Rectangle;
	  this.m_fileExtension = defaultValue(options.fileExtentName, 'png');
	  this.m_tileWidth = defaultValue(options.imageSizeWidth, 256);
	  this.m_tileHeight = defaultValue(options.imageSizeHeight, 256);
	  var levels = options.levels;
	  var length = levels.length;
	  this.m_minimumLevel = defaultValue(levels[0], 0);
	  this.m_maximumLevel = defaultValue(levels[length - 1], length - 1);

	  if (!defined(this.m_tilingScheme)) {
	    this.m_tilingScheme = new GeographicTilingScheme({
	      ellipsoid: this.m_options.ellipsoid
	    });
	  }

	  if (!defined(this.m_rectangle)) {
	    if (options.left && options.right && options.top && options.bottom) {
	      var left = Math.toRadians(options.left);
	      var right = Math.toRadians(options.right);
	      var bottom = Math.toRadians(options.bottom);
	      var top = Math.toRadians(options.top);
	      this.m_rectangle = new Rectangle(left, bottom, right, top);
	    }
	  }

	  var tilingScheme = this.m_tilingScheme;
	  this.m_rectangle.west < tilingScheme.rectangle.west && (this.m_rectangle.west = tilingScheme.rectangle.west);
	  this.m_rectangle.east > tilingScheme.rectangle.east && (this.m_rectangle.east = tilingScheme.rectangle.east);
	  this.m_rectangle.south < tilingScheme.rectangle.south && (this.m_rectangle.south = tilingScheme.rectangle.south);
	  this.m_rectangle.north > tilingScheme.rectangle.north && (this.m_rectangle.north = tilingScheme.rectangle.north);
	  var swTile = tilingScheme.positionToTileXY(Rectangle.southwest(this.m_rectangle), this.m_minimumLevel);
	  var neTile = tilingScheme.positionToTileXY(Rectangle.northeast(this.m_rectangle), this.m_minimumLevel);
	  var tileCount = (window.Math.abs(neTile.x - swTile.x) + 1) * (window.Math.abs(neTile.y - swTile.y) + 1);
	  tileCount > 4 && (this.m_minimumLevel = 0);
	  this.m_tilingScheme = tilingScheme;
	  this.m_urlTemplate = this.m_url + 'data/index/{y}/{x}.{fileExtension}?level={level}';
	  this.m_ready = true;
	  this.m_readyPromise.resolve(true);
	}

	function parseConfigFromXmlText(xmlText) {
	  var domParser = new DOMParser();
	  xmlText = domParser.parseFromString(xmlText, 'application/xml');
	  var namespaceURI = 'http://www.supermap.com/SuperMapCache/sci3d';
	  var rootNode = xmlText.childNodes[0]; // let version = queryNumericAttribute(rootNode, 'Version', namespaceURI)

	  var levelsNode = queryFirstNode(rootNode, 'Levels', namespaceURI);
	  var levelsNodes = queryNodes(levelsNode, 'Level', namespaceURI);
	  var levels = [];

	  for (var i = 0; i < levelsNodes.length; i++) {
	    levels.push(_parseInt$2(levelsNodes[i].textContent, 10));
	  }

	  var boundsNode = queryFirstNode(rootNode, 'Bounds', namespaceURI);
	  var left = queryNumericAttribute(boundsNode, 'Left', namespaceURI);
	  var right = queryNumericAttribute(boundsNode, 'Right', namespaceURI);
	  var top = queryNumericAttribute(boundsNode, 'Top', namespaceURI);
	  var bottom = queryNumericAttribute(boundsNode, 'Bottom', namespaceURI);
	  var fileExtentName = queryStringValue(rootNode, 'FileExtentName', namespaceURI);
	  var cellWidth = queryNumericAttribute(rootNode, 'CellWidth', namespaceURI);
	  var cellHeight = queryNumericAttribute(rootNode, 'CellHeight', namespaceURI);
	  var cacheName = queryStringValue(rootNode, 'CacheName', namespaceURI);
	  this.m_name = cacheName || '';
	  return {
	    left: left,
	    right: right,
	    top: top,
	    bottom: bottom,
	    fileExtentName: fileExtentName,
	    levels: levels,
	    imageSizeWidth: cellWidth,
	    imageSizeHeight: cellHeight
	  };
	}

	function queryStringValue(xmlNode, attribute, namespaceURI) {
	  var node = queryFirstNode(xmlNode, attribute, namespaceURI);
	  return Cesium.defined(node) ? node.textContent.trim() : undefined;
	}

	function queryNumericAttribute(xmlNode, attribute, namespaceURI) {
	  var node = queryFirstNode(xmlNode, attribute, namespaceURI);

	  if (Cesium.defined(node)) {
	    var number = _parseFloat$2(node.textContent);

	    return isNaN(number) ? undefined : number;
	  }
	}

	function queryFirstNode(xmlNode, attribute, namespaceURI) {
	  if (Cesium.defined(xmlNode)) {
	    var nodes = xmlNode.childNodes;
	    var length = nodes.length;

	    for (var i = 0; i < length; i++) {
	      var node = nodes[i];

	      if (node.localName === attribute && namespaceURI.indexOf(node.namespaceURI) !== -1) {
	        return node;
	      }
	    }
	  }
	}

	function queryNodes(xmlNode, attribute, namespaceURI) {
	  if (Cesium.defined(xmlNode)) {
	    var nodes = [];
	    var nodeList = xmlNode.getElementsByTagNameNS('*', attribute);
	    var length = nodeList.length;

	    for (var i = 0; i < length; i++) {
	      var node = nodeList[i];
	      node.localName === attribute && namespaceURI.indexOf(node.namespaceURI) !== -1 && nodes.push(node);
	    }

	    return nodes;
	  }
	}

	function onFulfilledTileMap(response) {
	  var _Cesium5 = Cesium,
	      Cartesian3 = _Cesium5.Cartesian3,
	      defaultValue = _Cesium5.defaultValue,
	      defined = _Cesium5.defined,
	      GeographicTilingScheme = _Cesium5.GeographicTilingScheme,
	      Math = _Cesium5.Math,
	      Rectangle = _Cesium5.Rectangle,
	      WebMercatorTilingScheme = _Cesium5.WebMercatorTilingScheme;
	  var coordUnit = response.prjCoordSys.coordUnit;
	  this.m_coordUnit = coordUnit;
	  var bounds = response.bounds;
	  var visibleScales = response.visibleScales;

	  if (defined(visibleScales) && visibleScales.length > 1 && defined(this.m_maximumLevel)) {
	    var lastVisibleScale = visibleScales[visibleScales.length - 1];
	    this.m_maximumLevel = getMaximumLevelbyScale(lastVisibleScale);
	  }

	  if (coordUnit === 'DEGREE') {
	    this.m_tilingScheme = new GeographicTilingScheme();
	    bounds.left = Math.clamp(bounds.left, -180, 180);
	    bounds.bottom = Math.clamp(bounds.bottom, -90, 90);
	    bounds.right = Math.clamp(bounds.right, -180, 180);
	    bounds.top = Math.clamp(bounds.top, -90, 90);
	    this.m_rectangle = Rectangle.fromDegrees(bounds.left, bounds.bottom, bounds.right, bounds.top);
	    this.m_urlTemplate = this.m_url + 'tileImage.png?transparent={transparent}&cacheEnabled=true&width=256&height=256&x={x}&y={y}&scale={scale}&redirect=false&overlapDisplayed=false&origin={"x":-180,"y":90}';
	  } else {
	    var pointLB = new Cartesian3(bounds.left, bounds.bottom, 0);
	    pointLB.x = Math.max(-20037508.342789244, pointLB.x);
	    pointLB.y = Math.max(-20037508.342789244, pointLB.y);
	    var pointRT = new Cartesian3(bounds.right, bounds.top, 0);
	    pointRT.x = Math.min(20037508.342789244, pointRT.x);
	    pointRT.y = Math.min(20037508.342789244, pointRT.y);
	    this.m_tilingScheme = new WebMercatorTilingScheme();
	    var f = this.m_tilingScheme.projection.unproject(pointLB);
	    var p = this.m_tilingScheme.projection.unproject(pointRT);
	    this.m_rectangle = new Rectangle(f.longitude, f.latitude, p.longitude, p.latitude);
	    this.m_urlTemplate = this.m_url + 'tileImage.png?transparent={transparent}&cacheEnabled=true&width=256&height=256&x={x}&y={y}&scale={scale}&redirect=false&overlapDisplayed=false&origin={"x":-20037508.342789248 ,"y":20037508.342789095}';
	  }

	  this.m_urlTemplate = this.m_urlTemplate.replace('{transparent}', this.m_transparent);
	  this.layersID && (this.m_urlTemplate = this.m_urlTemplate + '&layersID=' + this.layersID);
	  this.m_rectangle || (this.m_rectangle = defaultValue(this.m_options.rectangle, this.m_tilingScheme.rectangle));
	  this.m_ready = true;
	  this.m_readyPromise.resolve(true);
	}

	function onRejected() {
	  var _Cesium6 = Cesium,
	      TileProviderError = _Cesium6.TileProviderError,
	      RuntimeError = _Cesium6.RuntimeError;
	  var message = 'An error occurred while accessing ' + this.m_url + '.';
	  previousError = TileProviderError.handleError(previousError, this, this.m_errorEvent, message, undefined, undefined, undefined, init.bind(this));
	  this.m_readyPromise.reject(new RuntimeError(message));
	}

	var script$h = {
	  name: 'vc-provider-imagery-supermap',
	  mixins: [url, minimumLevel, maximumLevel, mixinImageryProvider],
	  props: {
	    name: String,
	    transparent: {
	      type: Boolean,
	      default: true
	    },
	    credit: {
	      type: String,
	      default: 'MapQuest, SuperMap iServer Imagery'
	    }
	  },
	  methods: {
	    createCesiumObject: function createCesiumObject() {
	      var $props, transformProps, setPropWatchers, unwatchFns, options;
	      return regenerator.async(function createCesiumObject$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              $props = this.$props, transformProps = this.transformProps, setPropWatchers = this.setPropWatchers, unwatchFns = this.unwatchFns;
	              options = transformProps($props);
	              Cesium.SuperMapImageryProvider = Cesium.SuperMapImageryProvider || SuperMapImageryProvider; // 之前注册时 SuperMapImageryProvider 可能还不存在，导致注册失败，这儿需要再注册 Vue 侦听器。
	              // 这种情况下会导致在`vc-viewer`组件的ready事件中对 'vc-provider-imagery-supermap' 属性赋值失败。
	              // 原因是 `vc-viewer` 组件ready事件触发时，'vc-provider-imagery-supermap'侦听器还没被创建呢。

	              if (unwatchFns.length === 0) {
	                setPropWatchers(true);
	              }

	              return _context.abrupt("return", new Cesium.SuperMapImageryProvider(options));

	            case 5:
	            case "end":
	              return _context.stop();
	          }
	        }
	      }, null, this);
	    }
	  }
	};

	/* script */
	var __vue_script__$h = script$h;
	/* template */

	/* style */

	var __vue_inject_styles__$h = undefined;
	/* scoped */

	var __vue_scope_id__$h = undefined;
	/* functional template */

	var __vue_is_functional_template__$h = undefined;
	/* component normalizer */

	function __vue_normalize__$h(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "SuperMapImageryProvider.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var SuperMapImageryProvider$1 = __vue_normalize__$h({}, __vue_inject_styles__$h, __vue_script__$h, __vue_scope_id__$h, __vue_is_functional_template__$h);

	function plugin$h(Vue) {

	  if (plugin$h.installed) {
	    return;
	  }

	  plugin$h.installed = true;
	  Vue.component(SuperMapImageryProvider$1.name, SuperMapImageryProvider$1);
	}

	var SuperMapImageryProvider$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$h,
		SuperMapImageryProvider: SuperMapImageryProvider$1,
		install: plugin$h
	});

	var script$i = {
	  name: 'vc-provider-imagery-tiledcache',
	  mixins: [url, format, credit, minimumLevel, maximumLevel, rectangle, tilingScheme, ellipsoid, tileWidth, tileHeight, mixinImageryProvider],
	  props: {
	    dir: {
	      type: String,
	      reqiured: true
	    },
	    scales: {
	      type: Array,
	      default: function _default() {
	        return [1 / 295829355, 1 / 147914678, 1 / 73957339, 1 / 36978669, 1 / 18489335, 1 / 9244667, 1 / 4622334, 1 / 2311167, 1 / 1155583, 1 / 577792, 1 / 288896, 1 / 144448, 1 / 72224, 1 / 36112, 1 / 18056, 1 / 9026, 1 / 4514];
	      }
	    }
	  },
	  methods: {
	    createCesiumObject: function createCesiumObject() {
	      var $props, transformProps, padWithZerosIfNecessary, scales, options, _Cesium, Credit, defined, defaultValue, DeveloperError, Ellipsoid, GeographicTilingScheme, Rectangle, Resource, UrlTemplateImageryProvider, url, dir, format, resource, tilingScheme, tileWidth, tileHeight, maximumLevel, minimumLevel, rectangle, swTile, neTile, tileCount, credit;

	      return regenerator.async(function createCesiumObject$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              $props = this.$props, transformProps = this.transformProps, padWithZerosIfNecessary = this.padWithZerosIfNecessary, scales = this.scales;
	              options = transformProps($props);
	              _Cesium = Cesium, Credit = _Cesium.Credit, defined = _Cesium.defined, defaultValue = _Cesium.defaultValue, DeveloperError = _Cesium.DeveloperError, Ellipsoid = _Cesium.Ellipsoid, GeographicTilingScheme = _Cesium.GeographicTilingScheme, Rectangle = _Cesium.Rectangle, Resource = _Cesium.Resource, UrlTemplateImageryProvider = _Cesium.UrlTemplateImageryProvider;
	              url = options.url, dir = options.dir, format = options.format;

	              if (defined(url)) {
	                _context.next = 6;
	                break;
	              }

	              throw new DeveloperError('options.url is required.');

	            case 6:
	              if (defined(dir)) {
	                _context.next = 8;
	                break;
	              }

	              throw new DeveloperError('options.dir is required.');

	            case 8:
	              resource = Resource.createIfNeeded(url);
	              resource.url += "?dir=".concat(dir, "&scale={scale}&col={x}&row={y}&format=").concat(format);
	              tilingScheme = defaultValue(options.tilingScheme, new GeographicTilingScheme({
	                ellipsoid: defaultValue(options.ellipsoid, Ellipsoid.WGS84),
	                numberOfLevelZeroTilesX: 2,
	                numberOfLevelZeroTilesY: 1
	              }));
	              tileWidth = defaultValue(options.tileWidth, 256);
	              tileHeight = defaultValue(options.tileHeight, 256);
	              maximumLevel = options.maximumLevel;
	              minimumLevel = defaultValue(options.minimumLevel, 0);
	              rectangle = defaultValue(options.rectangle, tilingScheme.rectangle); // Check the number of tiles at the minimum level.  If it's more than four,
	              // throw an exception, because starting at the higher minimum
	              // level will cause too many tiles to be downloaded and rendered.

	              swTile = tilingScheme.positionToTileXY(Rectangle.southwest(rectangle), minimumLevel);
	              neTile = tilingScheme.positionToTileXY(Rectangle.northeast(rectangle), minimumLevel);
	              tileCount = (Math.abs(neTile.x - swTile.x) + 1) * (Math.abs(neTile.y - swTile.y) + 1);

	              if (!(tileCount > 4)) {
	                _context.next = 21;
	                break;
	              }

	              throw new DeveloperError('The rectangle and minimumLevel indicate that there are ' + tileCount + ' tiles at the minimum level. Imagery providers with more than four tiles at the minimum level are not supported.');

	            case 21:
	              credit = defaultValue(options.credit, '');

	              if (typeof credit === 'string') {
	                credit = new Credit(credit);
	              }

	              return _context.abrupt("return", new UrlTemplateImageryProvider({
	                url: resource,
	                credit: credit,
	                tilingScheme: tilingScheme,
	                tileWidth: tileWidth,
	                tileHeight: tileHeight,
	                minimumLevel: minimumLevel,
	                maximumLevel: maximumLevel,
	                rectangle: rectangle,
	                customTags: {
	                  scale: function scale(imageryProvider, x, y, level) {
	                    var s = 1 / scales[level];
	                    return padWithZerosIfNecessary(imageryProvider, '{scale}', s);
	                  }
	                }
	              }));

	            case 24:
	            case "end":
	              return _context.stop();
	          }
	        }
	      }, null, this);
	    },
	    padWithZerosIfNecessary: function padWithZerosIfNecessary(imageryProvider, key, value) {
	      if (imageryProvider && imageryProvider.urlSchemeZeroPadding && Object.prototype.hasOwnProperty.call(imageryProvider.urlSchemeZeroPadding, key)) {
	        var paddingTemplate = imageryProvider.urlSchemeZeroPadding[key];

	        if (typeof paddingTemplate === 'string') {
	          var paddingTemplateWidth = paddingTemplate.length;

	          if (paddingTemplateWidth > 1) {
	            value = value.length >= paddingTemplateWidth ? value : new Array(paddingTemplateWidth - value.toString().length + 1).join('0') + value;
	          }
	        }
	      }

	      return value;
	    }
	  }
	};

	/* script */
	var __vue_script__$i = script$i;
	/* template */

	/* style */

	var __vue_inject_styles__$i = undefined;
	/* scoped */

	var __vue_scope_id__$i = undefined;
	/* functional template */

	var __vue_is_functional_template__$i = undefined;
	/* component normalizer */

	function __vue_normalize__$i(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "TiledCacheImageryProvider.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var TiledCacheImageryProvider = __vue_normalize__$i({}, __vue_inject_styles__$i, __vue_script__$i, __vue_scope_id__$i, __vue_is_functional_template__$i);

	function plugin$i(Vue) {

	  if (plugin$i.installed) {
	    return;
	  }

	  plugin$i.installed = true;
	  Vue.component(TiledCacheImageryProvider.name, TiledCacheImageryProvider);
	}

	var TiledCacheImageryProvider$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$i,
		TiledCacheImageryProvider: TiledCacheImageryProvider,
		install: plugin$i
	});

	function _assertThisInitialized(self) {
	  if (self === void 0) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }

	  return self;
	}

	function _possibleConstructorReturn(self, call) {
	  if (call && (_typeof(call) === "object" || typeof call === "function")) {
	    return call;
	  }

	  return _assertThisInitialized(self);
	}

	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */


	var check = function (O, proto) {
	  _anObject(O);
	  if (!_isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
	};
	var _setProto = {
	  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
	    function (test, buggy, set) {
	      try {
	        set = _ctx(Function.call, _objectGopd.f(Object.prototype, '__proto__').set, 2);
	        set(test, []);
	        buggy = !(test instanceof Array);
	      } catch (e) { buggy = true; }
	      return function setPrototypeOf(O, proto) {
	        check(O, proto);
	        if (buggy) O.__proto__ = proto;
	        else set(O, proto);
	        return O;
	      };
	    }({}, false) : undefined),
	  check: check
	};

	// 19.1.3.19 Object.setPrototypeOf(O, proto)

	_export(_export.S, 'Object', { setPrototypeOf: _setProto.set });

	var setPrototypeOf = _core.Object.setPrototypeOf;

	var setPrototypeOf$1 = setPrototypeOf;

	function _getPrototypeOf(o) {
	  _getPrototypeOf = setPrototypeOf$1 ? getPrototypeOf$1 : function _getPrototypeOf(o) {
	    return o.__proto__ || getPrototypeOf$1(o);
	  };
	  return _getPrototypeOf(o);
	}

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	_export(_export.S, 'Object', { create: _objectCreate });

	var $Object$3 = _core.Object;
	var create = function create(P, D) {
	  return $Object$3.create(P, D);
	};

	var create$1 = create;

	function _setPrototypeOf(o, p) {
	  _setPrototypeOf = setPrototypeOf$1 || function _setPrototypeOf(o, p) {
	    o.__proto__ = p;
	    return o;
	  };

	  return _setPrototypeOf(o, p);
	}

	function _inherits(subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function");
	  }

	  subClass.prototype = create$1(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      writable: true,
	      configurable: true
	    }
	  });
	  if (superClass) _setPrototypeOf(subClass, superClass);
	}

	var Projection =
	/*#__PURE__*/
	function () {
	  function Projection() {
	    _classCallCheck(this, Projection);
	  }

	  _createClass(Projection, [{
	    key: "lngLatToPoint",
	    value: function lngLatToPoint() {
	      throw new Error('lngLatToPoint方法未实现');
	    }
	  }, {
	    key: "pointToLngLat",
	    value: function pointToLngLat() {
	      throw new Error('pointToLngLat方法未实现');
	    }
	  }]);

	  return Projection;
	}();

	var Point =
	/*#__PURE__*/
	function () {
	  function Point(lng, lat) {
	    _classCallCheck(this, Point);

	    // 新增base64支持 - by jz
	    if (isNaN(lng)) {
	      // lng = decode64(lng)
	      lng = isNaN(lng) ? 0 : lng;
	    }

	    if (isString$1(lng)) {
	      lng = _parseFloat$2(lng);
	    }

	    if (isNaN(lat)) {
	      // lat = decode64(lat)
	      lat = isNaN(lat) ? 0 : lat;
	    }

	    if (isString$1(lat)) {
	      lat = _parseFloat$2(lat);
	    }

	    this.lng = lng;
	    this.lat = lat;
	  }

	  _createClass(Point, [{
	    key: "equals",
	    value: function equals(other) {
	      return other && this.lat === other.lat && this.lng === other.lng;
	    }
	  }]);

	  return Point;
	}();
	/**
	 * 是否是字符串
	 * @param {Mix}
	 * @returns {Boolean}
	 */


	_defineProperty(Point, "isInRange", function (pt) {
	  return pt && pt.lng <= 180 && pt.lng >= -180 && pt.lat <= 74 && pt.lat >= -74;
	});

	function isString$1(string) {
	  return typeof string === 'string';
	}

	var Pixel =
	/*#__PURE__*/
	function () {
	  function Pixel(x, y) {
	    _classCallCheck(this, Pixel);

	    this.x = x || 0;
	    this.y = y || 0;
	  }

	  _createClass(Pixel, [{
	    key: "equals",
	    value: function equals(other) {
	      return other && other.x === this.x && other.y === this.y;
	    }
	  }]);

	  return Pixel;
	}();

	/**
	 * Projection used by [Baidu Map]{@link https://github.com/openlayers/openlayers/issues/3522}
	 */

	var BaiduMapMercatorProjection =
	/*#__PURE__*/
	function (_Projection) {
	  _inherits(BaiduMapMercatorProjection, _Projection);

	  function BaiduMapMercatorProjection() {
	    _classCallCheck(this, BaiduMapMercatorProjection);

	    return _possibleConstructorReturn(this, _getPrototypeOf(BaiduMapMercatorProjection).apply(this, arguments));
	  }

	  _createClass(BaiduMapMercatorProjection, [{
	    key: "lngLatToMercator",
	    // constructor () {
	    //   super()
	    // }

	    /**
	     * 根据平面直角坐标计算两点间距离;
	     * @param {Point} point1 平面直角点坐标1
	     * @param {Point} point2 平面直角点坐标2;
	     * @return {Number} 返回两点间的距离
	     */

	    /**
	     * 根据经纬度坐标计算两点间距离;
	     * @param {Point} point1 经纬度点坐标1
	     * @param {Point} point2 经纬度点坐标2;
	     * @return {Number} 返回两点间的距离
	     */

	    /**
	     * 平面直角坐标转换成经纬度坐标;
	     * @param {Point} point 平面直角坐标
	     * @return {Point} 返回经纬度坐标
	     */

	    /**
	     * 经纬度坐标转换成平面直角坐标;
	     * @param {Point} point 经纬度坐标
	     * @return {Point} 返回平面直角坐标
	     */

	    /**
	     * 经纬度变换至墨卡托坐标
	     * @param Point 经纬度
	     * @return Point 墨卡托
	     */
	    value: function lngLatToMercator(point) {
	      return BaiduMapMercatorProjection.convertLL2MC(point);
	    }
	    /**
	     * 球面到平面坐标
	     * @param Point 球面坐标
	     * @return Pixel 平面坐标
	     */

	  }, {
	    key: "lngLatToPoint",
	    value: function lngLatToPoint(point) {
	      var mercator = BaiduMapMercatorProjection.convertLL2MC(point);
	      return new Pixel(mercator.lng, mercator.lat);
	    }
	    /**
	     * 墨卡托变换至经纬度
	     * @param Point 墨卡托
	     * @returns Point 经纬度
	     */

	  }, {
	    key: "mercatorToLngLat",
	    value: function mercatorToLngLat(point) {
	      return BaiduMapMercatorProjection.convertMC2LL(point);
	    }
	    /**
	     * 平面到球面坐标
	     * @param Pixel 平面坐标
	     * @returns Point 球面坐标
	     */

	  }, {
	    key: "pointToLngLat",
	    value: function pointToLngLat(point) {
	      var mercator = new Point(point.x, point.y);
	      return BaiduMapMercatorProjection.convertMC2LL(mercator);
	    }
	    /**
	     * 地理坐标转换至像素坐标
	     * @param Point 地理坐标
	     * @param Number 级别
	     * @param Point 地图中心点，注意为了保证没有误差，这里需要传递墨卡托坐标
	     * @param Size 地图容器大小
	     * @return Pixel 像素坐标
	     */

	  }, {
	    key: "pointToPixel",
	    value: function pointToPixel(point, zoom, mapCenter, mapSize, curCity) {
	      if (!point) {
	        return;
	      }

	      point = this.lngLatToMercator(point, curCity);
	      mapCenter = this.lngLatToMercator(mapCenter);
	      var zoomUnits = this.getZoomUnits(zoom);
	      var x = Math.round((point.lng - mapCenter.lng) / zoomUnits + mapSize.width / 2);
	      var y = Math.round((mapCenter.lat - point.lat) / zoomUnits + mapSize.height / 2);
	      return new Pixel(x, y);
	    }
	    /**
	     * 像素坐标转换至地理坐标
	     * @param Pixel 像素坐标
	     * @param Number 级别
	     * @param Point 地图中心点，注意为了保证没有误差，这里需要传递墨卡托坐标
	     * @param Size 地图容器大小
	     * @return Point 地理坐标
	     */

	  }, {
	    key: "pixelToPoint",
	    value: function pixelToPoint(pixel, zoom, mapCenter, mapSize, curCity) {
	      if (!pixel) {
	        return;
	      }

	      var zoomUnits = this.getZoomUnits(zoom);
	      var lng = mapCenter.lng + zoomUnits * (pixel.x - mapSize.width / 2);
	      var lat = mapCenter.lat - zoomUnits * (pixel.y - mapSize.height / 2);
	      var point = new Point(lng, lat);
	      return this.mercatorToLngLat(point, curCity);
	    }
	  }, {
	    key: "getZoomUnits",
	    value: function getZoomUnits(zoom) {
	      return Math.pow(2, 18 - zoom);
	    }
	  }]);

	  return BaiduMapMercatorProjection;
	}(Projection);

	_defineProperty(BaiduMapMercatorProjection, "EARTHRADIUS", 6370996.81);

	_defineProperty(BaiduMapMercatorProjection, "MCBAND", [12890594.86, 8362377.87, 5591021, 3481989.83, 1678043.12, 0]);

	_defineProperty(BaiduMapMercatorProjection, "LLBAND", [75, 60, 45, 30, 15, 0]);

	_defineProperty(BaiduMapMercatorProjection, "MC2LL", [[1.410526172116255e-8, 8.98305509648872e-6, -1.9939833816331, 2.009824383106796e2, -1.872403703815547e2, 91.6087516669843, -23.38765649603339, 2.57121317296198, -0.03801003308653, 1.73379812e7], [-7.435856389565537e-9, 8.983055097726239e-6, -0.78625201886289, 96.32687599759846, -1.85204757529826, -59.36935905485877, 47.40033549296737, -16.50741931063887, 2.28786674699375, 1.026014486e7], [-3.030883460898826e-8, 8.98305509983578e-6, 0.30071316287616, 59.74293618442277, 7.357984074871, -25.38371002664745, 13.45380521110908, -3.29883767235584, 0.32710905363475, 6.85681737e6], [-1.981981304930552e-8, 8.983055099779535e-6, 0.03278182852591, 40.31678527705744, 0.65659298677277, -4.44255534477492, 0.85341911805263, 0.12923347998204, -0.04625736007561, 4.48277706e6], [3.09191371068437e-9, 8.983055096812155e-6, 0.00006995724062, 23.10934304144901, -0.00023663490511, -0.6321817810242, -0.00663494467273, 0.03430082397953, -0.00466043876332, 2.5551644e6], [2.890871144776878e-9, 8.983055095805407e-6, -0.00000003068298, 7.47137025468032, -0.00000353937994, -0.02145144861037, -0.00001234426596, 0.00010322952773, -0.00000323890364, 8.260885e5]]);

	_defineProperty(BaiduMapMercatorProjection, "LL2MC", [[-0.0015702102444, 1.113207020616939e5, 1.704480524535203e15, -1.033898737604234e16, 2.611266785660388e16, -3.51496691766537e16, 2.659570071840392e16, -1.072501245418824e16, 1.800819912950474e15, 82.5], [8.277824516172526e-4, 1.113207020463578e5, // eslint-disable-next-line no-loss-of-precision
	6.477955746671608e8, -4.082003173641316e9, 1.077490566351142e10, -1.517187553151559e10, 1.205306533862167e10, -5.124939663577472e9, 9.133119359512032e8, 67.5], [0.00337398766765, 1.113207020202162e5, 4.481351045890365e6, -2.339375119931662e7, 7.968221547186455e7, -1.159649932797253e8, 9.723671115602145e7, -4.366194633752821e7, 8.477230501135234e6, 52.5], [0.00220636496208, 1.113207020209128e5, 5.175186112841131e4, 3.796837749470245e6, 9.920137397791013e5, -1.22195221711287e6, 1.340652697009075e6, -6.209436990984312e5, 1.444169293806241e5, 37.5], [-3.441963504368392e-4, 1.113207020576856e5, 2.782353980772752e2, 2.485758690035394e6, 6.070750963243378e3, 5.482118345352118e4, 9.540606633304236e3, -2.71055326746645e3, 1.405483844121726e3, 22.5], [-3.218135878613132e-4, 1.113207020701615e5, 0.00369383431289, 8.237256402795718e5, 0.46104986909093, 2.351343141331292e3, 1.58060784298199, 8.77738589078284, 0.37238884252424, 7.45]]);

	_defineProperty(BaiduMapMercatorProjection, "getDistanceByMC", function (point1, point2) {
	  if (!point1 || !point2) return 0;
	  point1 = this.convertMC2LL(point1);
	  if (!point1) return 0;
	  var x1 = this.toRadians(point1.lng);
	  var y1 = this.toRadians(point1.lat);
	  point2 = this.convertMC2LL(point2);
	  if (!point2) return 0;
	  var x2 = this.toRadians(point2.lng);
	  var y2 = this.toRadians(point2.lat);
	  return this.getDistance(x1, x2, y1, y2);
	});

	_defineProperty(BaiduMapMercatorProjection, "getDistanceByLL", function (point1, point2) {
	  if (!point1 || !point2) return 0;
	  point1.lng = this.getLoop(point1.lng, -180, 180);
	  point1.lat = this.getRange(point1.lat, -74, 74);
	  point2.lng = this.getLoop(point2.lng, -180, 180);
	  point2.lat = this.getRange(point2.lat, -74, 74);
	  var x1 = this.toRadians(point1.lng);
	  var y1 = this.toRadians(point1.lat);
	  var x2 = this.toRadians(point2.lng);
	  var y2 = this.toRadians(point2.lat);
	  return this.getDistance(x1, x2, y1, y2);
	});

	_defineProperty(BaiduMapMercatorProjection, "convertMC2LL", function (point) {
	  var factor;
	  var temp = new Point(Math.abs(point.lng), Math.abs(point.lat));

	  for (var i = 0; i < this.MCBAND.length; i++) {
	    if (temp.lat >= this.MCBAND[i]) {
	      factor = this.MC2LL[i];
	      break;
	    }
	  }

	  var lnglat = this.convertor(point, factor);
	  return new Point(lnglat.lng.toFixed(6), lnglat.lat.toFixed(6));
	});

	_defineProperty(BaiduMapMercatorProjection, "convertLL2MC", function (point) {
	  var factor;
	  point.lng = this.getLoop(point.lng, -180, 180);
	  point.lat = this.getRange(point.lat, -74, 74);
	  var temp = new Point(point.lng, point.lat);

	  for (var i = 0; i < this.LLBAND.length; i++) {
	    if (temp.lat >= this.LLBAND[i]) {
	      factor = this.LL2MC[i];
	      break;
	    }
	  }

	  if (!factor) {
	    for (var _i = this.LLBAND.length - 1; _i >= 0; _i--) {
	      if (temp.lat <= -this.LLBAND[_i]) {
	        factor = this.LL2MC[_i];
	        break;
	      }
	    }
	  }

	  var mc = this.convertor(point, factor);
	  return new Point(mc.lng.toFixed(2), mc.lat.toFixed(2));
	});

	_defineProperty(BaiduMapMercatorProjection, "convertor", function (fromPoint, factor) {
	  if (!fromPoint || !factor) {
	    return;
	  }

	  var x = factor[0] + factor[1] * Math.abs(fromPoint.lng);
	  var temp = Math.abs(fromPoint.lat) / factor[9];
	  var y = factor[2] + factor[3] * temp + factor[4] * temp * temp + factor[5] * temp * temp * temp + factor[6] * temp * temp * temp * temp + factor[7] * temp * temp * temp * temp * temp + factor[8] * temp * temp * temp * temp * temp * temp;
	  x *= fromPoint.lng < 0 ? -1 : 1;
	  y *= fromPoint.lat < 0 ? -1 : 1;
	  return new Point(x, y);
	});

	_defineProperty(BaiduMapMercatorProjection, "getDistance", function (x1, x2, y1, y2) {
	  return this.EARTHRADIUS * Math.acos(Math.sin(y1) * Math.sin(y2) + Math.cos(y1) * Math.cos(y2) * Math.cos(x2 - x1));
	});

	_defineProperty(BaiduMapMercatorProjection, "toRadians", function (angdeg) {
	  return Math.PI * angdeg / 180;
	});

	_defineProperty(BaiduMapMercatorProjection, "toDegrees", function (angrad) {
	  return 180 * angrad / Math.PI;
	});

	_defineProperty(BaiduMapMercatorProjection, "getRange", function (v, a, b) {
	  if (a != null) {
	    v = Math.max(v, a);
	  }

	  if (b != null) {
	    v = Math.min(v, b);
	  }

	  return v;
	});

	_defineProperty(BaiduMapMercatorProjection, "getLoop", function (v, a, b) {
	  while (v > b) {
	    v -= b - a;
	  }

	  while (v < a) {
	    v += b - a;
	  }

	  return v;
	});

	var coordtransform$1 = require('coordtransform');
	/**
	 * A tiling scheme for geometry referenced to a BaiduMapMercatorProjection {@link https://cesium.com/docs/cesiumjs-ref-doc/WebMercatorTilingScheme.html}
	 * {@link https://github.com/openlayers/openlayers/issues/3522#issuecomment-570493906}
	 */


	var BaiduMapMercatorTilingScheme =
	/*#__PURE__*/
	function () {
	  function BaiduMapMercatorTilingScheme(options) {
	    _classCallCheck(this, BaiduMapMercatorTilingScheme);

	    var _Cesium = Cesium,
	        defaultValue = _Cesium.defaultValue,
	        Ellipsoid = _Cesium.Ellipsoid,
	        WebMercatorProjection = _Cesium.WebMercatorProjection,
	        Cartesian2 = _Cesium.Cartesian2,
	        Cartographic = _Cesium.Cartographic,
	        CesiumMath = _Cesium.Math,
	        Rectangle = _Cesium.Rectangle;
	    options = options || {};
	    this._ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);
	    this._projection = new WebMercatorProjection(this._ellipsoid);
	    var projection = new BaiduMapMercatorProjection();

	    this._projection.project = function (cartographic, result) {
	      result = result || {};

	      if (options.toWGS84) {
	        result = coordtransform$1.wgs84togcj02(CesiumMath.toDegrees(cartographic.longitude), CesiumMath.toDegrees(cartographic.latitude));
	        result = coordtransform$1.gcj02tobd09(result[0], result[1]);
	      } else {
	        result = coordtransform$1.gcj02tobd09(CesiumMath.toDegrees(cartographic.longitude), CesiumMath.toDegrees(cartographic.latitude));
	      }

	      result[0] = Math.min(result[0], 180);
	      result[0] = Math.max(result[0], -180);
	      result[1] = Math.min(result[1], 74.000022);
	      result[1] = Math.max(result[1], -71.988531);
	      result = projection.lngLatToPoint(new Point(result[0], result[1]));
	      return new Cartesian2(result.x, result.y);
	    };

	    this._projection.unproject = function (cartographic, result) {
	      result = result || {};
	      result = projection.mercatorToLngLat(new Point(cartographic.x, cartographic.y));
	      result[0] = (result[0] + 180) % 360 - 180;

	      if (options.toWGS84) {
	        result = coordtransform$1.bd09togcj02(result.lng, result.lat);
	        result = coordtransform$1.gcj02towgs84(result[0], result[1]);
	      } else {
	        result = coordtransform$1.bd09togcj02(result.lng, result.lat);
	      }

	      return new Cartographic(Cesium.Math.toRadians(result[0]), Cesium.Math.toRadians(result[1]));
	    };

	    this._rectangleSouthwestInMeters = new Cartesian2(-20037726.37, -12474104.17);
	    this._rectangleNortheastInMeters = new Cartesian2(20037726.37, 12474104.17);

	    var rectangleSouthwestInMeters = this._projection.unproject(this._rectangleSouthwestInMeters);

	    var rectangleNortheastInMeters = this._projection.unproject(this._rectangleNortheastInMeters);

	    this._rectangle = new Rectangle(rectangleSouthwestInMeters.longitude, rectangleSouthwestInMeters.latitude, rectangleNortheastInMeters.longitude, rectangleNortheastInMeters.latitude);
	    this.resolutions = [];

	    for (var i = 0; i < 19; i++) {
	      this.resolutions[i] = 256 * Math.pow(2, 18 - i);
	    }
	  }

	  _createClass(BaiduMapMercatorTilingScheme, [{
	    key: "getNumberOfXTilesAtLevel",
	    value: function getNumberOfXTilesAtLevel(level) {
	      return 1 << level;
	    }
	  }, {
	    key: "getNumberOfYTilesAtLevel",
	    value: function getNumberOfYTilesAtLevel(level) {
	      return 1 << level;
	    }
	  }, {
	    key: "rectangleToNativeRectangle",
	    value: function rectangleToNativeRectangle(rectangle, result) {
	      var _Cesium2 = Cesium,
	          defined = _Cesium2.defined,
	          Rectangle = _Cesium2.Rectangle;
	      var projection = this._projection;
	      var southwest = projection.project(Rectangle.southwest(rectangle));
	      var northeast = projection.project(Rectangle.northeast(rectangle));

	      if (!defined(result)) {
	        return new Rectangle(southwest.x, southwest.y, northeast.x, northeast.y);
	      }

	      result.west = southwest.x;
	      result.south = southwest.y;
	      result.east = northeast.x;
	      result.north = northeast.y;
	      return result;
	    }
	  }, {
	    key: "tileXYToNativeRectangle",
	    value: function tileXYToNativeRectangle(x, y, level, result) {
	      var _Cesium3 = Cesium,
	          defined = _Cesium3.defined,
	          Rectangle = _Cesium3.Rectangle;
	      var tileWidth = this.resolutions[level];
	      var west = x * tileWidth;
	      var east = (x + 1) * tileWidth;
	      var north = ((y = -y) + 1) * tileWidth;
	      var south = y * tileWidth;

	      if (!defined(result)) {
	        return new Rectangle(west, south, east, north);
	      }

	      result.west = west;
	      result.south = south;
	      result.east = east;
	      result.north = north;
	      return result;
	    }
	  }, {
	    key: "tileXYToRectangle",
	    value: function tileXYToRectangle(x, y, level, result) {
	      var _Cesium4 = Cesium,
	          Cartesian2 = _Cesium4.Cartesian2;
	      var nativeRectangle = this.tileXYToNativeRectangle(x, y, level, result);
	      var projection = this._projection;
	      var southwest = projection.unproject(new Cartesian2(nativeRectangle.west, nativeRectangle.south));
	      var northeast = projection.unproject(new Cartesian2(nativeRectangle.east, nativeRectangle.north));
	      nativeRectangle.west = southwest.longitude;
	      nativeRectangle.south = southwest.latitude;
	      nativeRectangle.east = northeast.longitude;
	      nativeRectangle.north = northeast.latitude;
	      return nativeRectangle;
	    }
	  }, {
	    key: "positionToTileXY",
	    value: function positionToTileXY(position, level, result) {
	      var _Cesium5 = Cesium,
	          Rectangle = _Cesium5.Rectangle,
	          defined = _Cesium5.defined,
	          Cartesian2 = _Cesium5.Cartesian2;
	      var rectangle = this._rectangle;

	      if (!Rectangle.contains(rectangle, position)) {
	        // outside the bounds of the tiling scheme
	        return undefined;
	      }

	      var projection = this._projection;
	      var webMercatorPosition = projection.project(position);

	      if (!defined(webMercatorPosition)) {
	        return undefined;
	      }

	      var tileWidth = this.resolutions[level];
	      var xTileCoordinate = Math.floor(webMercatorPosition.x / tileWidth);
	      var yTileCoordinate = -Math.floor(webMercatorPosition.y / tileWidth);

	      if (!defined(result)) {
	        return new Cartesian2(xTileCoordinate, yTileCoordinate);
	      }

	      result.x = xTileCoordinate;
	      result.y = yTileCoordinate;
	      return result;
	    }
	  }, {
	    key: "ellipsoid",
	    get: function get() {
	      return this._ellipsoid;
	    }
	  }, {
	    key: "rectangle",
	    get: function get() {
	      return this._rectangle;
	    }
	  }, {
	    key: "projection",
	    get: function get() {
	      return this._projection;
	    }
	  }]);

	  return BaiduMapMercatorTilingScheme;
	}();

	var BaiduMapImageryProvider =
	/*#__PURE__*/
	function () {
	  function BaiduMapImageryProvider(options) {
	    _classCallCheck(this, BaiduMapImageryProvider);

	    var _Cesium = Cesium,
	        Resource = _Cesium.Resource,
	        defaultValue = _Cesium.defaultValue,
	        Credit = _Cesium.Credit,
	        when = _Cesium.when,
	        Event = _Cesium.Event;
	    this._url = options.url || "".concat(options.protocol, "://{s}.map.bdimg.com/onlinelabel/?qt=tile&styles=pl&x={x}&y={y}&z={z}");
	    var resource = Resource.createIfNeeded(this._url);
	    resource.appendForwardSlash();
	    this._ready = false;
	    this._resource = resource;
	    this._tileDiscardPolicy = options.tileDiscardPolicy;
	    this._tileWidth = 256;
	    this._tileHeight = 256;
	    this._minimumLevel = options.maximumLevel || 0;
	    this._maximumLevel = options.maximumLevel || 18;
	    this._tilingScheme = new BaiduMapMercatorTilingScheme(options);
	    this._rectangle = defaultValue(options.rectangle, this._tilingScheme.rectangle);
	    var credit = options.credit;

	    if (typeof credit === 'string') {
	      credit = new Credit(credit);
	    }

	    this._credit = credit;
	    this.enablePickFeatures = defaultValue(options.enablePickFeatures, false);
	    this._hasAlphaChannel = defaultValue(options.hasAlphaChannel, true);
	    this._subdomains = defaultValue(options.subdomains, ['online0', 'online1', 'online2', 'online3', 'online4', 'online5', 'online6', 'online7', 'online8', 'online9']);
	    this._errorEvent = new Event();
	    this._readyPromise = when.defer();
	    this._ready = true;

	    this._readyPromise.resolve(true);
	  }

	  _createClass(BaiduMapImageryProvider, [{
	    key: "getTileCredits",
	    value: function getTileCredits(x, y, level) {
	      if (!this.ready) {
	        throw new Cesium.DeveloperError('getTileCredits must not be called before the imagery provider is ready.');
	      }

	      return undefined;
	    }
	  }, {
	    key: "requestImage",
	    value: function requestImage(x, y, level, request) {
	      if (!this.ready) {
	        throw new Cesium.DeveloperError('requestImage must not be called before the imagery provider is ready.');
	      }

	      return Cesium.ImageryProvider.loadImage(this, buildImageResource$2.call(this, x, y, level, request));
	    }
	  }, {
	    key: "url",
	    get: function get() {
	      return this._resource._url;
	    }
	  }, {
	    key: "proxy",
	    get: function get() {
	      return this._resource.proxy;
	    }
	  }, {
	    key: "tileWidth",
	    get: function get() {
	      if (!this._ready) {
	        throw new Cesium.DeveloperError('tileWidth must not be called before the imagery provider is ready.');
	      }

	      return this._tileWidth;
	    }
	  }, {
	    key: "tileHeight",
	    get: function get() {
	      if (!this._ready) {
	        throw new Cesium.DeveloperError('tileHeight must not be called before the imagery provider is ready.');
	      }

	      return this._tileHeight;
	    }
	  }, {
	    key: "maximumLevel",
	    get: function get() {
	      if (!this._ready) {
	        throw new Cesium.DeveloperError('maximumLevel must not be called before the imagery provider is ready.');
	      }

	      return this._maximumLevel;
	    }
	  }, {
	    key: "minimumLevel",
	    get: function get() {
	      if (!this.ready) {
	        throw new Cesium.DeveloperError('minimumLevel must not be called before the imagery provider is ready.');
	      }

	      return this._minimumLevel;
	    }
	  }, {
	    key: "tilingScheme",
	    get: function get() {
	      if (!this._ready) {
	        throw new Cesium.DeveloperError('tilingScheme must not be called before the imagery provider is ready.');
	      }

	      return this._tilingScheme;
	    }
	  }, {
	    key: "rectangle",
	    get: function get() {
	      if (!this.ready) {
	        throw new Cesium.DeveloperError('rectangle must not be called before the imagery provider is ready.');
	      }

	      return this._rectangle;
	    }
	  }, {
	    key: "tileDiscardPolicy",
	    get: function get() {
	      if (!this.ready) {
	        throw new Cesium.DeveloperError('tileDiscardPolicy must not be called before the imagery provider is ready.');
	      }

	      return this._tileDiscardPolicy;
	    }
	  }, {
	    key: "errorEvent",
	    get: function get() {
	      return this._errorEvent;
	    }
	  }, {
	    key: "ready",
	    get: function get() {
	      return this._ready;
	    }
	  }, {
	    key: "readyPromise",
	    get: function get() {
	      return this._readyPromise.promise;
	    }
	  }, {
	    key: "credit",
	    get: function get() {
	      if (!this.ready) {
	        throw new Cesium.DeveloperError('credit must not be called before the imagery provider is ready.');
	      }

	      return this._credit;
	    }
	  }, {
	    key: "hasAlphaChannel",
	    get: function get() {
	      if (!this.ready) {
	        throw new Cesium.DeveloperError('hasAlphaChannel must not be called before the imagery provider is ready.');
	      }

	      return this._hasAlphaChannel;
	    }
	  }]);

	  return BaiduMapImageryProvider;
	}();

	function buildImageResource$2(x, y, level, request) {
	  var url = this._url;
	  var subdomains = this._subdomains;
	  url = url.replace('{s}', subdomains[(x + y + level) % subdomains.length]).replace('{x}', x).replace('{y}', -y).replace('{z}', level);

	  var resource = this._resource.getDerivedResource({
	    url: url,
	    request: request
	  });

	  return resource;
	}

	var script$j = {
	  name: 'vc-provider-imagery-baidumap',
	  mixins: [url, ellipsoid, tileDiscardPolicy, credit, minimumLevel, maximumLevel, mixinImageryProvider],
	  props: {
	    protocol: {
	      type: String,
	      default: 'http'
	    },
	    props: {
	      projectionTransforms: {
	        type: Boolean | Object,
	        default: function _default() {
	          return {
	            form: 'BD09',
	            to: 'WGS84'
	          };
	        }
	      }
	    }
	  },
	  methods: {
	    createCesiumObject: function createCesiumObject() {
	      var $props, transformProps, setPropWatchers, unwatchFns, projectionTransforms, options;
	      return regenerator.async(function createCesiumObject$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              $props = this.$props, transformProps = this.transformProps, setPropWatchers = this.setPropWatchers, unwatchFns = this.unwatchFns, projectionTransforms = this.projectionTransforms;
	              options = transformProps($props);
	              Cesium.BaiduMapImageryProvider = BaiduMapImageryProvider;

	              if (unwatchFns.length === 0) {
	                setPropWatchers(true);
	              }

	              options.toWGS84 = projectionTransforms && projectionTransforms.from !== projectionTransforms.to && projectionTransforms.to.toUpperCase() === 'WGS84';
	              return _context.abrupt("return", new Cesium.BaiduMapImageryProvider(options));

	            case 6:
	            case "end":
	              return _context.stop();
	          }
	        }
	      }, null, this);
	    }
	  }
	};

	/* script */
	var __vue_script__$j = script$j;
	/* template */

	/* style */

	var __vue_inject_styles__$j = undefined;
	/* scoped */

	var __vue_scope_id__$j = undefined;
	/* functional template */

	var __vue_is_functional_template__$j = undefined;
	/* component normalizer */

	function __vue_normalize__$j(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "BaiduMapImageryProvider.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var BaiduMapImageryProvider$1 = __vue_normalize__$j({}, __vue_inject_styles__$j, __vue_script__$j, __vue_scope_id__$j, __vue_is_functional_template__$j);

	function plugin$j(Vue) {

	  if (plugin$j.installed) {
	    return;
	  }

	  plugin$j.installed = true;
	  Vue.component(BaiduMapImageryProvider$1.name, BaiduMapImageryProvider$1);
	}

	var BaiduMapImageryProvider$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$j,
		BaiduMapImageryProvider: BaiduMapImageryProvider$1,
		install: plugin$j
	});

	var methods$2 = {
	  mount: function mount() {
	    var viewer, terrainProvider;
	    return regenerator.async(function mount$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            viewer = this.viewer, terrainProvider = this.terrainProvider;
	            bindEvents.call(this, terrainProvider, Events['imagery-layer-events'], true);
	            viewer.terrainProvider = terrainProvider;

	          case 3:
	          case "end":
	            return _context.stop();
	        }
	      }
	    }, null, this);
	  },
	  unmount: function unmount() {
	    var viewer, terrainProvider;
	    return regenerator.async(function unmount$(_context2) {
	      while (1) {
	        switch (_context2.prev = _context2.next) {
	          case 0:
	            viewer = this.viewer, terrainProvider = this.terrainProvider;
	            bindEvents.call(this, terrainProvider, Events['imagery-layer-events'], false);
	            viewer.terrainProvider = new Cesium.EllipsoidTerrainProvider();

	          case 3:
	          case "end":
	            return _context2.stop();
	        }
	      }
	    }, null, this);
	  }
	};
	var mixinTerrainProvider = {
	  mixins: [cmp],
	  methods: methods$2,
	  stubVNode: {
	    empty: function empty() {
	      return this.$options.name;
	    }
	  },
	  created: function created() {
	    var _this = this;

	    defineProperties$1(this, {
	      terrainProvider: {
	        enumerable: true,
	        get: function get() {
	          return _this.cesiumObject;
	        }
	      }
	    });
	  }
	};

	var script$k = {
	  name: 'vc-provider-terrain-arcgis-tiled-elevation',
	  mixins: [mixinTerrainProvider],
	  props: {
	    url: {
	      type: [String, Object],
	      default: 'https://elevation3d.arcgis.com/arcgis/rest/services/WorldElevation3D/Terrain3D/ImageServer'
	    },
	    token: String,
	    ellipsoid: Object
	  }
	};

	/* script */
	var __vue_script__$k = script$k;
	/* template */

	/* style */

	var __vue_inject_styles__$k = undefined;
	/* scoped */

	var __vue_scope_id__$k = undefined;
	/* functional template */

	var __vue_is_functional_template__$k = undefined;
	/* component normalizer */

	function __vue_normalize__$k(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "ArcGISTiledElevationTerrainProvider.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var ArcGISTiledElevationTerrainProvider = __vue_normalize__$k({}, __vue_inject_styles__$k, __vue_script__$k, __vue_scope_id__$k, __vue_is_functional_template__$k);

	function plugin$k(Vue) {

	  if (plugin$k.installed) {
	    return;
	  }

	  plugin$k.installed = true;
	  Vue.component(ArcGISTiledElevationTerrainProvider.name, ArcGISTiledElevationTerrainProvider);
	}

	var ArcGISTiledElevationTerrainProvider$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$k,
		ArcGISTiledElevationTerrainProvider: ArcGISTiledElevationTerrainProvider,
		install: plugin$k
	});

	var script$l = {
	  name: 'VcProviderTerrainCesium',
	  mixins: [url, mixinTerrainProvider],
	  props: {
	    requestVertexNormals: Boolean,
	    requestWaterMask: Boolean,
	    requestMetadata: Boolean,
	    ellipsoid: Object,
	    credit: [String, Object]
	  },
	  methods: {
	    /**
	     * 重写 createCesiumObject 方法。
	     */
	    createCesiumObject: function createCesiumObject() {
	      var url, requestVertexNormals, requestWaterMask, requestMetadata, ellipsoid, credit, options;
	      return regenerator.async(function createCesiumObject$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              url = this.url, requestVertexNormals = this.requestVertexNormals, requestWaterMask = this.requestWaterMask, requestMetadata = this.requestMetadata, ellipsoid = this.ellipsoid, credit = this.credit;
	              options = {
	                url: url,
	                requestVertexNormals: requestVertexNormals,
	                requestWaterMask: requestWaterMask,
	                requestMetadata: requestMetadata,
	                ellipsoid: ellipsoid,
	                credit: credit
	              };
	              this.removeNullItem(options);
	              return _context.abrupt("return", options.url ? new Cesium.CesiumTerrainProvider(options) : Cesium.createWorldTerrain({
	                requestVertexNormals: requestVertexNormals,
	                requestWaterMask: requestWaterMask
	              }));

	            case 4:
	            case "end":
	              return _context.stop();
	          }
	        }
	      }, null, this);
	    }
	  }
	};

	/* script */
	var __vue_script__$l = script$l;
	/* template */

	/* style */

	var __vue_inject_styles__$l = undefined;
	/* scoped */

	var __vue_scope_id__$l = undefined;
	/* functional template */

	var __vue_is_functional_template__$l = undefined;
	/* component normalizer */

	function __vue_normalize__$l(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "CesiumTerrainProvider.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var CesiumTerrainProvider = __vue_normalize__$l({}, __vue_inject_styles__$l, __vue_script__$l, __vue_scope_id__$l, __vue_is_functional_template__$l);

	function plugin$l(Vue) {

	  if (plugin$l.installed) {
	    return;
	  }

	  plugin$l.installed = true;
	  Vue.component(CesiumTerrainProvider.name, CesiumTerrainProvider);
	}

	var CesiumTerrainProvider$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$l,
		CesiumTerrainProvider: CesiumTerrainProvider,
		install: plugin$l
	});

	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();

	/** Built-in value references. */
	var Symbol$1 = root.Symbol;

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$2 = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/** Built-in value references. */
	var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;

	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag(value) {
	  var isOwn = hasOwnProperty$2.call(value, symToStringTag),
	      tag = value[symToStringTag];

	  try {
	    value[symToStringTag] = undefined;
	    var unmasked = true;
	  } catch (e) {}

	  var result = nativeObjectToString.call(value);
	  if (unmasked) {
	    if (isOwn) {
	      value[symToStringTag] = tag;
	    } else {
	      delete value[symToStringTag];
	    }
	  }
	  return result;
	}

	/** Used for built-in method references. */
	var objectProto$1 = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString$1 = objectProto$1.toString;

	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString(value) {
	  return nativeObjectToString$1.call(value);
	}

	/** `Object#toString` result references. */
	var nullTag = '[object Null]',
	    undefinedTag = '[object Undefined]';

	/** Built-in value references. */
	var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;

	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  return (symToStringTag$1 && symToStringTag$1 in Object(value))
	    ? getRawTag(value)
	    : objectToString(value);
	}

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return value != null && typeof value == 'object';
	}

	/** `Object#toString` result references. */
	var symbolTag = '[object Symbol]';

	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol$1(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike(value) && baseGetTag(value) == symbolTag);
	}

	/**
	 * A specialized version of `_.map` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */
	function arrayMap(array, iteratee) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      result = Array(length);

	  while (++index < length) {
	    result[index] = iteratee(array[index], index, array);
	  }
	  return result;
	}

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray$1 = Array.isArray;

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0;

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,
	    symbolToString = symbolProto ? symbolProto.toString : undefined;

	/**
	 * The base implementation of `_.toString` which doesn't convert nullish
	 * values to empty strings.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 */
	function baseToString(value) {
	  // Exit early for strings to avoid a performance hit in some environments.
	  if (typeof value == 'string') {
	    return value;
	  }
	  if (isArray$1(value)) {
	    // Recursively convert values (susceptible to call stack limits).
	    return arrayMap(value, baseToString) + '';
	  }
	  if (isSymbol$1(value)) {
	    return symbolToString ? symbolToString.call(value) : '';
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject$1(value) {
	  var type = typeof value;
	  return value != null && (type == 'object' || type == 'function');
	}

	/** Used as references for various `Number` constants. */
	var NAN = 0 / 0;

	/** Used to match leading and trailing whitespace. */
	var reTrim = /^\s+|\s+$/g;

	/** Used to detect bad signed hexadecimal string values. */
	var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

	/** Used to detect binary string values. */
	var reIsBinary = /^0b[01]+$/i;

	/** Used to detect octal string values. */
	var reIsOctal = /^0o[0-7]+$/i;

	/** Built-in method references without a dependency on `root`. */
	var freeParseInt = parseInt;

	/**
	 * Converts `value` to a number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to process.
	 * @returns {number} Returns the number.
	 * @example
	 *
	 * _.toNumber(3.2);
	 * // => 3.2
	 *
	 * _.toNumber(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toNumber(Infinity);
	 * // => Infinity
	 *
	 * _.toNumber('3.2');
	 * // => 3.2
	 */
	function toNumber(value) {
	  if (typeof value == 'number') {
	    return value;
	  }
	  if (isSymbol$1(value)) {
	    return NAN;
	  }
	  if (isObject$1(value)) {
	    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
	    value = isObject$1(other) ? (other + '') : other;
	  }
	  if (typeof value != 'string') {
	    return value === 0 ? value : +value;
	  }
	  value = value.replace(reTrim, '');
	  var isBinary = reIsBinary.test(value);
	  return (isBinary || reIsOctal.test(value))
	    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
	    : (reIsBadHex.test(value) ? NAN : +value);
	}

	/**
	 * This method returns the first argument it receives.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {*} value Any value.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 *
	 * console.log(_.identity(object) === object);
	 * // => true
	 */
	function identity(value) {
	  return value;
	}

	/** `Object#toString` result references. */
	var asyncTag = '[object AsyncFunction]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    proxyTag = '[object Proxy]';

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction$1(value) {
	  if (!isObject$1(value)) {
	    return false;
	  }
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 9 which returns 'object' for typed arrays and other constructors.
	  var tag = baseGetTag(value);
	  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	}

	/** Used to detect overreaching core-js shims. */
	var coreJsData = root['__core-js_shared__'];

	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());

	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}

	/** Used for built-in method references. */
	var funcProto = Function.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to convert.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/** Used for built-in method references. */
	var funcProto$1 = Function.prototype,
	    objectProto$2 = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString$1 = funcProto$1.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty$3 = objectProto$2.hasOwnProperty;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString$1.call(hasOwnProperty$3).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject$1(value) || isMasked(value)) {
	    return false;
	  }
	  var pattern = isFunction$1(value) ? reIsNative : reIsHostCtor;
	  return pattern.test(toSource(value));
	}

	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = getValue(object, key);
	  return baseIsNative(value) ? value : undefined;
	}

	/* Built-in method references that are verified to be native. */
	var WeakMap = getNative(root, 'WeakMap');

	/**
	 * A faster alternative to `Function#apply`, this function invokes `func`
	 * with the `this` binding of `thisArg` and the arguments of `args`.
	 *
	 * @private
	 * @param {Function} func The function to invoke.
	 * @param {*} thisArg The `this` binding of `func`.
	 * @param {Array} args The arguments to invoke `func` with.
	 * @returns {*} Returns the result of `func`.
	 */
	function apply(func, thisArg, args) {
	  switch (args.length) {
	    case 0: return func.call(thisArg);
	    case 1: return func.call(thisArg, args[0]);
	    case 2: return func.call(thisArg, args[0], args[1]);
	    case 3: return func.call(thisArg, args[0], args[1], args[2]);
	  }
	  return func.apply(thisArg, args);
	}

	/** Used to detect hot functions by number of calls within a span of milliseconds. */
	var HOT_COUNT = 800,
	    HOT_SPAN = 16;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeNow = Date.now;

	/**
	 * Creates a function that'll short out and invoke `identity` instead
	 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
	 * milliseconds.
	 *
	 * @private
	 * @param {Function} func The function to restrict.
	 * @returns {Function} Returns the new shortable function.
	 */
	function shortOut(func) {
	  var count = 0,
	      lastCalled = 0;

	  return function() {
	    var stamp = nativeNow(),
	        remaining = HOT_SPAN - (stamp - lastCalled);

	    lastCalled = stamp;
	    if (remaining > 0) {
	      if (++count >= HOT_COUNT) {
	        return arguments[0];
	      }
	    } else {
	      count = 0;
	    }
	    return func.apply(undefined, arguments);
	  };
	}

	/**
	 * Creates a function that returns `value`.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {*} value The value to return from the new function.
	 * @returns {Function} Returns the new constant function.
	 * @example
	 *
	 * var objects = _.times(2, _.constant({ 'a': 1 }));
	 *
	 * console.log(objects);
	 * // => [{ 'a': 1 }, { 'a': 1 }]
	 *
	 * console.log(objects[0] === objects[1]);
	 * // => true
	 */
	function constant(value) {
	  return function() {
	    return value;
	  };
	}

	var defineProperty$3 = (function() {
	  try {
	    var func = getNative(Object, 'defineProperty');
	    func({}, '', {});
	    return func;
	  } catch (e) {}
	}());

	/**
	 * The base implementation of `setToString` without support for hot loop shorting.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var baseSetToString = !defineProperty$3 ? identity : function(func, string) {
	  return defineProperty$3(func, 'toString', {
	    'configurable': true,
	    'enumerable': false,
	    'value': constant(string),
	    'writable': true
	  });
	};

	/**
	 * Sets the `toString` method of `func` to return `string`.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var setToString = shortOut(baseSetToString);

	/**
	 * The base implementation of `_.findIndex` and `_.findLastIndex` without
	 * support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {Function} predicate The function invoked per iteration.
	 * @param {number} fromIndex The index to search from.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function baseFindIndex(array, predicate, fromIndex, fromRight) {
	  var length = array.length,
	      index = fromIndex + (fromRight ? 1 : -1);

	  while ((fromRight ? index-- : ++index < length)) {
	    if (predicate(array[index], index, array)) {
	      return index;
	    }
	  }
	  return -1;
	}

	/**
	 * The base implementation of `_.isNaN` without support for number objects.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
	 */
	function baseIsNaN(value) {
	  return value !== value;
	}

	/**
	 * A specialized version of `_.indexOf` which performs strict equality
	 * comparisons of values, i.e. `===`.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} value The value to search for.
	 * @param {number} fromIndex The index to search from.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function strictIndexOf(array, value, fromIndex) {
	  var index = fromIndex - 1,
	      length = array.length;

	  while (++index < length) {
	    if (array[index] === value) {
	      return index;
	    }
	  }
	  return -1;
	}

	/**
	 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} value The value to search for.
	 * @param {number} fromIndex The index to search from.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function baseIndexOf(array, value, fromIndex) {
	  return value === value
	    ? strictIndexOf(array, value, fromIndex)
	    : baseFindIndex(array, baseIsNaN, fromIndex);
	}

	/**
	 * A specialized version of `_.includes` for arrays without support for
	 * specifying an index to search from.
	 *
	 * @private
	 * @param {Array} [array] The array to inspect.
	 * @param {*} target The value to search for.
	 * @returns {boolean} Returns `true` if `target` is found, else `false`.
	 */
	function arrayIncludes(array, value) {
	  var length = array == null ? 0 : array.length;
	  return !!length && baseIndexOf(array, value, 0) > -1;
	}

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  var type = typeof value;
	  length = length == null ? MAX_SAFE_INTEGER : length;

	  return !!length &&
	    (type == 'number' ||
	      (type != 'symbol' && reIsUint.test(value))) &&
	        (value > -1 && value % 1 == 0 && value < length);
	}

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;

	/**
	 * A specialized version of `baseRest` which transforms the rest array.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @param {Function} transform The rest array transform.
	 * @returns {Function} Returns the new function.
	 */
	function overRest(func, start, transform) {
	  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
	  return function() {
	    var args = arguments,
	        index = -1,
	        length = nativeMax(args.length - start, 0),
	        array = Array(length);

	    while (++index < length) {
	      array[index] = args[start + index];
	    }
	    index = -1;
	    var otherArgs = Array(start + 1);
	    while (++index < start) {
	      otherArgs[index] = args[index];
	    }
	    otherArgs[start] = transform(array);
	    return apply(func, this, otherArgs);
	  };
	}

	/**
	 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @returns {Function} Returns the new function.
	 */
	function baseRest(func, start) {
	  return setToString(overRest(func, start, identity), func + '');
	}

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER$1 = 9007199254740991;

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
	}

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(value.length) && !isFunction$1(value);
	}

	/** Used for built-in method references. */
	var objectProto$3 = Object.prototype;

	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$3;

	  return value === proto;
	}

	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */
	function baseTimes(n, iteratee) {
	  var index = -1,
	      result = Array(n);

	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]';

	/**
	 * The base implementation of `_.isArguments`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 */
	function baseIsArguments(value) {
	  return isObjectLike(value) && baseGetTag(value) == argsTag;
	}

	/** Used for built-in method references. */
	var objectProto$4 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$4 = objectProto$4.hasOwnProperty;

	/** Built-in value references. */
	var propertyIsEnumerable = objectProto$4.propertyIsEnumerable;

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
	  return isObjectLike(value) && hasOwnProperty$4.call(value, 'callee') &&
	    !propertyIsEnumerable.call(value, 'callee');
	};

	/**
	 * This method returns `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {boolean} Returns `false`.
	 * @example
	 *
	 * _.times(2, _.stubFalse);
	 * // => [false, false]
	 */
	function stubFalse() {
	  return false;
	}

	/** Detect free variable `exports`. */
	var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Built-in value references. */
	var Buffer = moduleExports ? root.Buffer : undefined;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

	/**
	 * Checks if `value` is a buffer.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	 * @example
	 *
	 * _.isBuffer(new Buffer(2));
	 * // => true
	 *
	 * _.isBuffer(new Uint8Array(2));
	 * // => false
	 */
	var isBuffer = nativeIsBuffer || stubFalse;

	/** `Object#toString` result references. */
	var argsTag$1 = '[object Arguments]',
	    arrayTag = '[object Array]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag$1 = '[object Function]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    objectTag = '[object Object]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    weakMapTag = '[object WeakMap]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';

	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] =
	typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
	typedArrayTags[errorTag] = typedArrayTags[funcTag$1] =
	typedArrayTags[mapTag] = typedArrayTags[numberTag] =
	typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
	typedArrayTags[setTag] = typedArrayTags[stringTag] =
	typedArrayTags[weakMapTag] = false;

	/**
	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 */
	function baseIsTypedArray(value) {
	  return isObjectLike(value) &&
	    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
	}

	/**
	 * The base implementation of `_.unary` without support for storing metadata.
	 *
	 * @private
	 * @param {Function} func The function to cap arguments for.
	 * @returns {Function} Returns the new capped function.
	 */
	function baseUnary(func) {
	  return function(value) {
	    return func(value);
	  };
	}

	/** Detect free variable `exports`. */
	var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;

	/** Detect free variable `process` from Node.js. */
	var freeProcess = moduleExports$1 && freeGlobal.process;

	/** Used to access faster Node.js helpers. */
	var nodeUtil = (function() {
	  try {
	    // Use `util.types` for Node.js 10+.
	    var types = freeModule$1 && freeModule$1.require && freeModule$1.require('util').types;

	    if (types) {
	      return types;
	    }

	    // Legacy `process.binding('util')` for Node.js < 10.
	    return freeProcess && freeProcess.binding && freeProcess.binding('util');
	  } catch (e) {}
	}());

	/* Node.js helper references. */
	var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

	/** Used for built-in method references. */
	var objectProto$5 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$5 = objectProto$5.hasOwnProperty;

	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys(value, inherited) {
	  var isArr = isArray$1(value),
	      isArg = !isArr && isArguments(value),
	      isBuff = !isArr && !isArg && isBuffer(value),
	      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
	      skipIndexes = isArr || isArg || isBuff || isType,
	      result = skipIndexes ? baseTimes(value.length, String) : [],
	      length = result.length;

	  for (var key in value) {
	    if ((inherited || hasOwnProperty$5.call(value, key)) &&
	        !(skipIndexes && (
	           // Safari 9 has enumerable `arguments.length` in strict mode.
	           key == 'length' ||
	           // Node.js 0.10 has enumerable non-index properties on buffers.
	           (isBuff && (key == 'offset' || key == 'parent')) ||
	           // PhantomJS 2 has enumerable non-index properties on typed arrays.
	           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
	           // Skip index properties.
	           isIndex(key, length)
	        ))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeKeys = overArg(Object.keys, Object);

	/** Used for built-in method references. */
	var objectProto$6 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$6 = objectProto$6.hasOwnProperty;

	/**
	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeys(object) {
	  if (!isPrototype(object)) {
	    return nativeKeys(object);
	  }
	  var result = [];
	  for (var key in Object(object)) {
	    if (hasOwnProperty$6.call(object, key) && key != 'constructor') {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	function keys$2(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
	}

	/** Used to match property names within property paths. */
	var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
	    reIsPlainProp = /^\w*$/;

	/**
	 * Checks if `value` is a property name and not a property path.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	 */
	function isKey(value, object) {
	  if (isArray$1(value)) {
	    return false;
	  }
	  var type = typeof value;
	  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
	      value == null || isSymbol$1(value)) {
	    return true;
	  }
	  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
	    (object != null && value in Object(object));
	}

	/* Built-in method references that are verified to be native. */
	var nativeCreate = getNative(Object, 'create');

	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear() {
	  this.__data__ = nativeCreate ? nativeCreate(null) : {};
	  this.size = 0;
	}

	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function hashDelete(key) {
	  var result = this.has(key) && delete this.__data__[key];
	  this.size -= result ? 1 : 0;
	  return result;
	}

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/** Used for built-in method references. */
	var objectProto$7 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$7 = objectProto$7.hasOwnProperty;

	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(key) {
	  var data = this.__data__;
	  if (nativeCreate) {
	    var result = data[key];
	    return result === HASH_UNDEFINED ? undefined : result;
	  }
	  return hasOwnProperty$7.call(data, key) ? data[key] : undefined;
	}

	/** Used for built-in method references. */
	var objectProto$8 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$8 = objectProto$8.hasOwnProperty;

	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(key) {
	  var data = this.__data__;
	  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty$8.call(data, key);
	}

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet(key, value) {
	  var data = this.__data__;
	  this.size += this.has(key) ? 0 : 1;
	  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;
	  return this;
	}

	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `Hash`.
	Hash.prototype.clear = hashClear;
	Hash.prototype['delete'] = hashDelete;
	Hash.prototype.get = hashGet;
	Hash.prototype.has = hashHas;
	Hash.prototype.set = hashSet;

	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */
	function listCacheClear() {
	  this.__data__ = [];
	  this.size = 0;
	}

	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}

	/** Used for built-in method references. */
	var arrayProto = Array.prototype;

	/** Built-in value references. */
	var splice = arrayProto.splice;

	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  --this.size;
	  return true;
	}

	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  return index < 0 ? undefined : data[index][1];
	}

	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas(key) {
	  return assocIndexOf(this.__data__, key) > -1;
	}

	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet(key, value) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    ++this.size;
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}

	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `ListCache`.
	ListCache.prototype.clear = listCacheClear;
	ListCache.prototype['delete'] = listCacheDelete;
	ListCache.prototype.get = listCacheGet;
	ListCache.prototype.has = listCacheHas;
	ListCache.prototype.set = listCacheSet;

	/* Built-in method references that are verified to be native. */
	var Map = getNative(root, 'Map');

	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear() {
	  this.size = 0;
	  this.__data__ = {
	    'hash': new Hash,
	    'map': new (Map || ListCache),
	    'string': new Hash
	  };
	}

	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
	function isKeyable(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}

	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData(map, key) {
	  var data = map.__data__;
	  return isKeyable(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}

	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete(key) {
	  var result = getMapData(this, key)['delete'](key);
	  this.size -= result ? 1 : 0;
	  return result;
	}

	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet(key) {
	  return getMapData(this, key).get(key);
	}

	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas(key) {
	  return getMapData(this, key).has(key);
	}

	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet(key, value) {
	  var data = getMapData(this, key),
	      size = data.size;

	  data.set(key, value);
	  this.size += data.size == size ? 0 : 1;
	  return this;
	}

	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `MapCache`.
	MapCache.prototype.clear = mapCacheClear;
	MapCache.prototype['delete'] = mapCacheDelete;
	MapCache.prototype.get = mapCacheGet;
	MapCache.prototype.has = mapCacheHas;
	MapCache.prototype.set = mapCacheSet;

	/** Error message constants. */
	var FUNC_ERROR_TEXT = 'Expected a function';

	/**
	 * Creates a function that memoizes the result of `func`. If `resolver` is
	 * provided, it determines the cache key for storing the result based on the
	 * arguments provided to the memoized function. By default, the first argument
	 * provided to the memoized function is used as the map cache key. The `func`
	 * is invoked with the `this` binding of the memoized function.
	 *
	 * **Note:** The cache is exposed as the `cache` property on the memoized
	 * function. Its creation may be customized by replacing the `_.memoize.Cache`
	 * constructor with one whose instances implement the
	 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
	 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to have its output memoized.
	 * @param {Function} [resolver] The function to resolve the cache key.
	 * @returns {Function} Returns the new memoized function.
	 * @example
	 *
	 * var object = { 'a': 1, 'b': 2 };
	 * var other = { 'c': 3, 'd': 4 };
	 *
	 * var values = _.memoize(_.values);
	 * values(object);
	 * // => [1, 2]
	 *
	 * values(other);
	 * // => [3, 4]
	 *
	 * object.a = 2;
	 * values(object);
	 * // => [1, 2]
	 *
	 * // Modify the result cache.
	 * values.cache.set(object, ['a', 'b']);
	 * values(object);
	 * // => ['a', 'b']
	 *
	 * // Replace `_.memoize.Cache`.
	 * _.memoize.Cache = WeakMap;
	 */
	function memoize(func, resolver) {
	  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  var memoized = function() {
	    var args = arguments,
	        key = resolver ? resolver.apply(this, args) : args[0],
	        cache = memoized.cache;

	    if (cache.has(key)) {
	      return cache.get(key);
	    }
	    var result = func.apply(this, args);
	    memoized.cache = cache.set(key, result) || cache;
	    return result;
	  };
	  memoized.cache = new (memoize.Cache || MapCache);
	  return memoized;
	}

	// Expose `MapCache`.
	memoize.Cache = MapCache;

	/** Used as the maximum memoize cache size. */
	var MAX_MEMOIZE_SIZE = 500;

	/**
	 * A specialized version of `_.memoize` which clears the memoized function's
	 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
	 *
	 * @private
	 * @param {Function} func The function to have its output memoized.
	 * @returns {Function} Returns the new memoized function.
	 */
	function memoizeCapped(func) {
	  var result = memoize(func, function(key) {
	    if (cache.size === MAX_MEMOIZE_SIZE) {
	      cache.clear();
	    }
	    return key;
	  });

	  var cache = result.cache;
	  return result;
	}

	/** Used to match property names within property paths. */
	var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

	/** Used to match backslashes in property paths. */
	var reEscapeChar = /\\(\\)?/g;

	/**
	 * Converts `string` to a property path array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the property path array.
	 */
	var stringToPath = memoizeCapped(function(string) {
	  var result = [];
	  if (string.charCodeAt(0) === 46 /* . */) {
	    result.push('');
	  }
	  string.replace(rePropName, function(match, number, quote, subString) {
	    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
	  });
	  return result;
	});

	/**
	 * Converts `value` to a string. An empty string is returned for `null`
	 * and `undefined` values. The sign of `-0` is preserved.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 * @example
	 *
	 * _.toString(null);
	 * // => ''
	 *
	 * _.toString(-0);
	 * // => '-0'
	 *
	 * _.toString([1, 2, 3]);
	 * // => '1,2,3'
	 */
	function toString$3(value) {
	  return value == null ? '' : baseToString(value);
	}

	/**
	 * Casts `value` to a path array if it's not one.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {Array} Returns the cast property path array.
	 */
	function castPath(value, object) {
	  if (isArray$1(value)) {
	    return value;
	  }
	  return isKey(value, object) ? [value] : stringToPath(toString$3(value));
	}

	/** Used as references for various `Number` constants. */
	var INFINITY$1 = 1 / 0;

	/**
	 * Converts `value` to a string key if it's not a string or symbol.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @returns {string|symbol} Returns the key.
	 */
	function toKey(value) {
	  if (typeof value == 'string' || isSymbol$1(value)) {
	    return value;
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY$1) ? '-0' : result;
	}

	/**
	 * The base implementation of `_.get` without support for default values.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @returns {*} Returns the resolved value.
	 */
	function baseGet(object, path) {
	  path = castPath(path, object);

	  var index = 0,
	      length = path.length;

	  while (object != null && index < length) {
	    object = object[toKey(path[index++])];
	  }
	  return (index && index == length) ? object : undefined;
	}

	/**
	 * Gets the value at `path` of `object`. If the resolved value is
	 * `undefined`, the `defaultValue` is returned in its place.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.7.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	 * @returns {*} Returns the resolved value.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	 *
	 * _.get(object, 'a[0].b.c');
	 * // => 3
	 *
	 * _.get(object, ['a', '0', 'b', 'c']);
	 * // => 3
	 *
	 * _.get(object, 'a.b.c', 'default');
	 * // => 'default'
	 */
	function get(object, path, defaultValue) {
	  var result = object == null ? undefined : baseGet(object, path);
	  return result === undefined ? defaultValue : result;
	}

	/**
	 * Appends the elements of `values` to `array`.
	 *
	 * @private
	 * @param {Array} array The array to modify.
	 * @param {Array} values The values to append.
	 * @returns {Array} Returns `array`.
	 */
	function arrayPush(array, values) {
	  var index = -1,
	      length = values.length,
	      offset = array.length;

	  while (++index < length) {
	    array[offset + index] = values[index];
	  }
	  return array;
	}

	/** Built-in value references. */
	var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : undefined;

	/**
	 * Checks if `value` is a flattenable `arguments` object or array.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
	 */
	function isFlattenable(value) {
	  return isArray$1(value) || isArguments(value) ||
	    !!(spreadableSymbol && value && value[spreadableSymbol]);
	}

	/**
	 * The base implementation of `_.flatten` with support for restricting flattening.
	 *
	 * @private
	 * @param {Array} array The array to flatten.
	 * @param {number} depth The maximum recursion depth.
	 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
	 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
	 * @param {Array} [result=[]] The initial result value.
	 * @returns {Array} Returns the new flattened array.
	 */
	function baseFlatten(array, depth, predicate, isStrict, result) {
	  var index = -1,
	      length = array.length;

	  predicate || (predicate = isFlattenable);
	  result || (result = []);

	  while (++index < length) {
	    var value = array[index];
	    if (depth > 0 && predicate(value)) {
	      if (depth > 1) {
	        // Recursively flatten arrays (susceptible to call stack limits).
	        baseFlatten(value, depth - 1, predicate, isStrict, result);
	      } else {
	        arrayPush(result, value);
	      }
	    } else if (!isStrict) {
	      result[result.length] = value;
	    }
	  }
	  return result;
	}

	/**
	 * Removes all key-value entries from the stack.
	 *
	 * @private
	 * @name clear
	 * @memberOf Stack
	 */
	function stackClear() {
	  this.__data__ = new ListCache;
	  this.size = 0;
	}

	/**
	 * Removes `key` and its value from the stack.
	 *
	 * @private
	 * @name delete
	 * @memberOf Stack
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function stackDelete(key) {
	  var data = this.__data__,
	      result = data['delete'](key);

	  this.size = data.size;
	  return result;
	}

	/**
	 * Gets the stack value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Stack
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function stackGet(key) {
	  return this.__data__.get(key);
	}

	/**
	 * Checks if a stack value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Stack
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function stackHas(key) {
	  return this.__data__.has(key);
	}

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;

	/**
	 * Sets the stack `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Stack
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the stack cache instance.
	 */
	function stackSet(key, value) {
	  var data = this.__data__;
	  if (data instanceof ListCache) {
	    var pairs = data.__data__;
	    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
	      pairs.push([key, value]);
	      this.size = ++data.size;
	      return this;
	    }
	    data = this.__data__ = new MapCache(pairs);
	  }
	  data.set(key, value);
	  this.size = data.size;
	  return this;
	}

	/**
	 * Creates a stack cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Stack(entries) {
	  var data = this.__data__ = new ListCache(entries);
	  this.size = data.size;
	}

	// Add methods to `Stack`.
	Stack.prototype.clear = stackClear;
	Stack.prototype['delete'] = stackDelete;
	Stack.prototype.get = stackGet;
	Stack.prototype.has = stackHas;
	Stack.prototype.set = stackSet;

	/**
	 * A specialized version of `_.filter` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {Array} Returns the new filtered array.
	 */
	function arrayFilter(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      resIndex = 0,
	      result = [];

	  while (++index < length) {
	    var value = array[index];
	    if (predicate(value, index, array)) {
	      result[resIndex++] = value;
	    }
	  }
	  return result;
	}

	/**
	 * This method returns a new empty array.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {Array} Returns the new empty array.
	 * @example
	 *
	 * var arrays = _.times(2, _.stubArray);
	 *
	 * console.log(arrays);
	 * // => [[], []]
	 *
	 * console.log(arrays[0] === arrays[1]);
	 * // => false
	 */
	function stubArray() {
	  return [];
	}

	/** Used for built-in method references. */
	var objectProto$9 = Object.prototype;

	/** Built-in value references. */
	var propertyIsEnumerable$1 = objectProto$9.propertyIsEnumerable;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetSymbols = Object.getOwnPropertySymbols;

	/**
	 * Creates an array of the own enumerable symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of symbols.
	 */
	var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
	  if (object == null) {
	    return [];
	  }
	  object = Object(object);
	  return arrayFilter(nativeGetSymbols(object), function(symbol) {
	    return propertyIsEnumerable$1.call(object, symbol);
	  });
	};

	/**
	 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
	 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
	 * symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @param {Function} symbolsFunc The function to get the symbols of `object`.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function baseGetAllKeys(object, keysFunc, symbolsFunc) {
	  var result = keysFunc(object);
	  return isArray$1(object) ? result : arrayPush(result, symbolsFunc(object));
	}

	/**
	 * Creates an array of own enumerable property names and symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function getAllKeys(object) {
	  return baseGetAllKeys(object, keys$2, getSymbols);
	}

	/* Built-in method references that are verified to be native. */
	var DataView = getNative(root, 'DataView');

	/* Built-in method references that are verified to be native. */
	var Promise$2 = getNative(root, 'Promise');

	/* Built-in method references that are verified to be native. */
	var Set = getNative(root, 'Set');

	/** `Object#toString` result references. */
	var mapTag$1 = '[object Map]',
	    objectTag$1 = '[object Object]',
	    promiseTag = '[object Promise]',
	    setTag$1 = '[object Set]',
	    weakMapTag$1 = '[object WeakMap]';

	var dataViewTag$1 = '[object DataView]';

	/** Used to detect maps, sets, and weakmaps. */
	var dataViewCtorString = toSource(DataView),
	    mapCtorString = toSource(Map),
	    promiseCtorString = toSource(Promise$2),
	    setCtorString = toSource(Set),
	    weakMapCtorString = toSource(WeakMap);

	/**
	 * Gets the `toStringTag` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	var getTag = baseGetTag;

	// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
	if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag$1) ||
	    (Map && getTag(new Map) != mapTag$1) ||
	    (Promise$2 && getTag(Promise$2.resolve()) != promiseTag) ||
	    (Set && getTag(new Set) != setTag$1) ||
	    (WeakMap && getTag(new WeakMap) != weakMapTag$1)) {
	  getTag = function(value) {
	    var result = baseGetTag(value),
	        Ctor = result == objectTag$1 ? value.constructor : undefined,
	        ctorString = Ctor ? toSource(Ctor) : '';

	    if (ctorString) {
	      switch (ctorString) {
	        case dataViewCtorString: return dataViewTag$1;
	        case mapCtorString: return mapTag$1;
	        case promiseCtorString: return promiseTag;
	        case setCtorString: return setTag$1;
	        case weakMapCtorString: return weakMapTag$1;
	      }
	    }
	    return result;
	  };
	}

	var getTag$1 = getTag;

	/** Built-in value references. */
	var Uint8Array$1 = root.Uint8Array;

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

	/**
	 * Adds `value` to the array cache.
	 *
	 * @private
	 * @name add
	 * @memberOf SetCache
	 * @alias push
	 * @param {*} value The value to cache.
	 * @returns {Object} Returns the cache instance.
	 */
	function setCacheAdd(value) {
	  this.__data__.set(value, HASH_UNDEFINED$2);
	  return this;
	}

	/**
	 * Checks if `value` is in the array cache.
	 *
	 * @private
	 * @name has
	 * @memberOf SetCache
	 * @param {*} value The value to search for.
	 * @returns {number} Returns `true` if `value` is found, else `false`.
	 */
	function setCacheHas(value) {
	  return this.__data__.has(value);
	}

	/**
	 *
	 * Creates an array cache object to store unique values.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [values] The values to cache.
	 */
	function SetCache(values) {
	  var index = -1,
	      length = values == null ? 0 : values.length;

	  this.__data__ = new MapCache;
	  while (++index < length) {
	    this.add(values[index]);
	  }
	}

	// Add methods to `SetCache`.
	SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
	SetCache.prototype.has = setCacheHas;

	/**
	 * A specialized version of `_.some` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {boolean} Returns `true` if any element passes the predicate check,
	 *  else `false`.
	 */
	function arraySome(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (predicate(array[index], index, array)) {
	      return true;
	    }
	  }
	  return false;
	}

	/**
	 * Checks if a `cache` value for `key` exists.
	 *
	 * @private
	 * @param {Object} cache The cache to query.
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function cacheHas(cache, key) {
	  return cache.has(key);
	}

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/**
	 * A specialized version of `baseIsEqualDeep` for arrays with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Array} array The array to compare.
	 * @param {Array} other The other array to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `array` and `other` objects.
	 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	 */
	function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	      arrLength = array.length,
	      othLength = other.length;

	  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
	    return false;
	  }
	  // Check that cyclic values are equal.
	  var arrStacked = stack.get(array);
	  var othStacked = stack.get(other);
	  if (arrStacked && othStacked) {
	    return arrStacked == other && othStacked == array;
	  }
	  var index = -1,
	      result = true,
	      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

	  stack.set(array, other);
	  stack.set(other, array);

	  // Ignore non-index properties.
	  while (++index < arrLength) {
	    var arrValue = array[index],
	        othValue = other[index];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, arrValue, index, other, array, stack)
	        : customizer(arrValue, othValue, index, array, other, stack);
	    }
	    if (compared !== undefined) {
	      if (compared) {
	        continue;
	      }
	      result = false;
	      break;
	    }
	    // Recursively compare arrays (susceptible to call stack limits).
	    if (seen) {
	      if (!arraySome(other, function(othValue, othIndex) {
	            if (!cacheHas(seen, othIndex) &&
	                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
	              return seen.push(othIndex);
	            }
	          })) {
	        result = false;
	        break;
	      }
	    } else if (!(
	          arrValue === othValue ||
	            equalFunc(arrValue, othValue, bitmask, customizer, stack)
	        )) {
	      result = false;
	      break;
	    }
	  }
	  stack['delete'](array);
	  stack['delete'](other);
	  return result;
	}

	/**
	 * Converts `map` to its key-value pairs.
	 *
	 * @private
	 * @param {Object} map The map to convert.
	 * @returns {Array} Returns the key-value pairs.
	 */
	function mapToArray(map) {
	  var index = -1,
	      result = Array(map.size);

	  map.forEach(function(value, key) {
	    result[++index] = [key, value];
	  });
	  return result;
	}

	/**
	 * Converts `set` to an array of its values.
	 *
	 * @private
	 * @param {Object} set The set to convert.
	 * @returns {Array} Returns the values.
	 */
	function setToArray(set) {
	  var index = -1,
	      result = Array(set.size);

	  set.forEach(function(value) {
	    result[++index] = value;
	  });
	  return result;
	}

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG$1 = 1,
	    COMPARE_UNORDERED_FLAG$1 = 2;

	/** `Object#toString` result references. */
	var boolTag$1 = '[object Boolean]',
	    dateTag$1 = '[object Date]',
	    errorTag$1 = '[object Error]',
	    mapTag$2 = '[object Map]',
	    numberTag$1 = '[object Number]',
	    regexpTag$1 = '[object RegExp]',
	    setTag$2 = '[object Set]',
	    stringTag$1 = '[object String]',
	    symbolTag$1 = '[object Symbol]';

	var arrayBufferTag$1 = '[object ArrayBuffer]',
	    dataViewTag$2 = '[object DataView]';

	/** Used to convert symbols to primitives and strings. */
	var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : undefined,
	    symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : undefined;

	/**
	 * A specialized version of `baseIsEqualDeep` for comparing objects of
	 * the same `toStringTag`.
	 *
	 * **Note:** This function only supports comparing values with tags of
	 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {string} tag The `toStringTag` of the objects to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
	  switch (tag) {
	    case dataViewTag$2:
	      if ((object.byteLength != other.byteLength) ||
	          (object.byteOffset != other.byteOffset)) {
	        return false;
	      }
	      object = object.buffer;
	      other = other.buffer;

	    case arrayBufferTag$1:
	      if ((object.byteLength != other.byteLength) ||
	          !equalFunc(new Uint8Array$1(object), new Uint8Array$1(other))) {
	        return false;
	      }
	      return true;

	    case boolTag$1:
	    case dateTag$1:
	    case numberTag$1:
	      // Coerce booleans to `1` or `0` and dates to milliseconds.
	      // Invalid dates are coerced to `NaN`.
	      return eq(+object, +other);

	    case errorTag$1:
	      return object.name == other.name && object.message == other.message;

	    case regexpTag$1:
	    case stringTag$1:
	      // Coerce regexes to strings and treat strings, primitives and objects,
	      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
	      // for more details.
	      return object == (other + '');

	    case mapTag$2:
	      var convert = mapToArray;

	    case setTag$2:
	      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1;
	      convert || (convert = setToArray);

	      if (object.size != other.size && !isPartial) {
	        return false;
	      }
	      // Assume cyclic values are equal.
	      var stacked = stack.get(object);
	      if (stacked) {
	        return stacked == other;
	      }
	      bitmask |= COMPARE_UNORDERED_FLAG$1;

	      // Recursively compare objects (susceptible to call stack limits).
	      stack.set(object, other);
	      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
	      stack['delete'](object);
	      return result;

	    case symbolTag$1:
	      if (symbolValueOf) {
	        return symbolValueOf.call(object) == symbolValueOf.call(other);
	      }
	  }
	  return false;
	}

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG$2 = 1;

	/** Used for built-in method references. */
	var objectProto$a = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$9 = objectProto$a.hasOwnProperty;

	/**
	 * A specialized version of `baseIsEqualDeep` for objects with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2,
	      objProps = getAllKeys(object),
	      objLength = objProps.length,
	      othProps = getAllKeys(other),
	      othLength = othProps.length;

	  if (objLength != othLength && !isPartial) {
	    return false;
	  }
	  var index = objLength;
	  while (index--) {
	    var key = objProps[index];
	    if (!(isPartial ? key in other : hasOwnProperty$9.call(other, key))) {
	      return false;
	    }
	  }
	  // Check that cyclic values are equal.
	  var objStacked = stack.get(object);
	  var othStacked = stack.get(other);
	  if (objStacked && othStacked) {
	    return objStacked == other && othStacked == object;
	  }
	  var result = true;
	  stack.set(object, other);
	  stack.set(other, object);

	  var skipCtor = isPartial;
	  while (++index < objLength) {
	    key = objProps[index];
	    var objValue = object[key],
	        othValue = other[key];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, objValue, key, other, object, stack)
	        : customizer(objValue, othValue, key, object, other, stack);
	    }
	    // Recursively compare objects (susceptible to call stack limits).
	    if (!(compared === undefined
	          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
	          : compared
	        )) {
	      result = false;
	      break;
	    }
	    skipCtor || (skipCtor = key == 'constructor');
	  }
	  if (result && !skipCtor) {
	    var objCtor = object.constructor,
	        othCtor = other.constructor;

	    // Non `Object` object instances with different constructors are not equal.
	    if (objCtor != othCtor &&
	        ('constructor' in object && 'constructor' in other) &&
	        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	      result = false;
	    }
	  }
	  stack['delete'](object);
	  stack['delete'](other);
	  return result;
	}

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG$3 = 1;

	/** `Object#toString` result references. */
	var argsTag$2 = '[object Arguments]',
	    arrayTag$1 = '[object Array]',
	    objectTag$2 = '[object Object]';

	/** Used for built-in method references. */
	var objectProto$b = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$a = objectProto$b.hasOwnProperty;

	/**
	 * A specialized version of `baseIsEqual` for arrays and objects which performs
	 * deep comparisons and tracks traversed objects enabling objects with circular
	 * references to be compared.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
	  var objIsArr = isArray$1(object),
	      othIsArr = isArray$1(other),
	      objTag = objIsArr ? arrayTag$1 : getTag$1(object),
	      othTag = othIsArr ? arrayTag$1 : getTag$1(other);

	  objTag = objTag == argsTag$2 ? objectTag$2 : objTag;
	  othTag = othTag == argsTag$2 ? objectTag$2 : othTag;

	  var objIsObj = objTag == objectTag$2,
	      othIsObj = othTag == objectTag$2,
	      isSameTag = objTag == othTag;

	  if (isSameTag && isBuffer(object)) {
	    if (!isBuffer(other)) {
	      return false;
	    }
	    objIsArr = true;
	    objIsObj = false;
	  }
	  if (isSameTag && !objIsObj) {
	    stack || (stack = new Stack);
	    return (objIsArr || isTypedArray(object))
	      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
	      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
	  }
	  if (!(bitmask & COMPARE_PARTIAL_FLAG$3)) {
	    var objIsWrapped = objIsObj && hasOwnProperty$a.call(object, '__wrapped__'),
	        othIsWrapped = othIsObj && hasOwnProperty$a.call(other, '__wrapped__');

	    if (objIsWrapped || othIsWrapped) {
	      var objUnwrapped = objIsWrapped ? object.value() : object,
	          othUnwrapped = othIsWrapped ? other.value() : other;

	      stack || (stack = new Stack);
	      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
	    }
	  }
	  if (!isSameTag) {
	    return false;
	  }
	  stack || (stack = new Stack);
	  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
	}

	/**
	 * The base implementation of `_.isEqual` which supports partial comparisons
	 * and tracks traversed objects.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @param {boolean} bitmask The bitmask flags.
	 *  1 - Unordered comparison
	 *  2 - Partial comparison
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 */
	function baseIsEqual(value, other, bitmask, customizer, stack) {
	  if (value === other) {
	    return true;
	  }
	  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
	    return value !== value && other !== other;
	  }
	  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
	}

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG$4 = 1,
	    COMPARE_UNORDERED_FLAG$2 = 2;

	/**
	 * The base implementation of `_.isMatch` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The object to inspect.
	 * @param {Object} source The object of property values to match.
	 * @param {Array} matchData The property names, values, and compare flags to match.
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	 */
	function baseIsMatch(object, source, matchData, customizer) {
	  var index = matchData.length,
	      length = index,
	      noCustomizer = !customizer;

	  if (object == null) {
	    return !length;
	  }
	  object = Object(object);
	  while (index--) {
	    var data = matchData[index];
	    if ((noCustomizer && data[2])
	          ? data[1] !== object[data[0]]
	          : !(data[0] in object)
	        ) {
	      return false;
	    }
	  }
	  while (++index < length) {
	    data = matchData[index];
	    var key = data[0],
	        objValue = object[key],
	        srcValue = data[1];

	    if (noCustomizer && data[2]) {
	      if (objValue === undefined && !(key in object)) {
	        return false;
	      }
	    } else {
	      var stack = new Stack;
	      if (customizer) {
	        var result = customizer(objValue, srcValue, key, object, source, stack);
	      }
	      if (!(result === undefined
	            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$4 | COMPARE_UNORDERED_FLAG$2, customizer, stack)
	            : result
	          )) {
	        return false;
	      }
	    }
	  }
	  return true;
	}

	/**
	 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` if suitable for strict
	 *  equality comparisons, else `false`.
	 */
	function isStrictComparable(value) {
	  return value === value && !isObject$1(value);
	}

	/**
	 * Gets the property names, values, and compare flags of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the match data of `object`.
	 */
	function getMatchData(object) {
	  var result = keys$2(object),
	      length = result.length;

	  while (length--) {
	    var key = result[length],
	        value = object[key];

	    result[length] = [key, value, isStrictComparable(value)];
	  }
	  return result;
	}

	/**
	 * A specialized version of `matchesProperty` for source values suitable
	 * for strict equality comparisons, i.e. `===`.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @param {*} srcValue The value to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function matchesStrictComparable(key, srcValue) {
	  return function(object) {
	    if (object == null) {
	      return false;
	    }
	    return object[key] === srcValue &&
	      (srcValue !== undefined || (key in Object(object)));
	  };
	}

	/**
	 * The base implementation of `_.matches` which doesn't clone `source`.
	 *
	 * @private
	 * @param {Object} source The object of property values to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function baseMatches(source) {
	  var matchData = getMatchData(source);
	  if (matchData.length == 1 && matchData[0][2]) {
	    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
	  }
	  return function(object) {
	    return object === source || baseIsMatch(object, source, matchData);
	  };
	}

	/**
	 * The base implementation of `_.hasIn` without support for deep paths.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {Array|string} key The key to check.
	 * @returns {boolean} Returns `true` if `key` exists, else `false`.
	 */
	function baseHasIn(object, key) {
	  return object != null && key in Object(object);
	}

	/**
	 * Checks if `path` exists on `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @param {Function} hasFunc The function to check properties.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 */
	function hasPath(object, path, hasFunc) {
	  path = castPath(path, object);

	  var index = -1,
	      length = path.length,
	      result = false;

	  while (++index < length) {
	    var key = toKey(path[index]);
	    if (!(result = object != null && hasFunc(object, key))) {
	      break;
	    }
	    object = object[key];
	  }
	  if (result || ++index != length) {
	    return result;
	  }
	  length = object == null ? 0 : object.length;
	  return !!length && isLength(length) && isIndex(key, length) &&
	    (isArray$1(object) || isArguments(object));
	}

	/**
	 * Checks if `path` is a direct or inherited property of `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 * @example
	 *
	 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
	 *
	 * _.hasIn(object, 'a');
	 * // => true
	 *
	 * _.hasIn(object, 'a.b');
	 * // => true
	 *
	 * _.hasIn(object, ['a', 'b']);
	 * // => true
	 *
	 * _.hasIn(object, 'b');
	 * // => false
	 */
	function hasIn(object, path) {
	  return object != null && hasPath(object, path, baseHasIn);
	}

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG$5 = 1,
	    COMPARE_UNORDERED_FLAG$3 = 2;

	/**
	 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
	 *
	 * @private
	 * @param {string} path The path of the property to get.
	 * @param {*} srcValue The value to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function baseMatchesProperty(path, srcValue) {
	  if (isKey(path) && isStrictComparable(srcValue)) {
	    return matchesStrictComparable(toKey(path), srcValue);
	  }
	  return function(object) {
	    var objValue = get(object, path);
	    return (objValue === undefined && objValue === srcValue)
	      ? hasIn(object, path)
	      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$5 | COMPARE_UNORDERED_FLAG$3);
	  };
	}

	/**
	 * The base implementation of `_.property` without support for deep paths.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 */
	function baseProperty(key) {
	  return function(object) {
	    return object == null ? undefined : object[key];
	  };
	}

	/**
	 * A specialized version of `baseProperty` which supports deep paths.
	 *
	 * @private
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 */
	function basePropertyDeep(path) {
	  return function(object) {
	    return baseGet(object, path);
	  };
	}

	/**
	 * Creates a function that returns the value at `path` of a given object.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 * @example
	 *
	 * var objects = [
	 *   { 'a': { 'b': 2 } },
	 *   { 'a': { 'b': 1 } }
	 * ];
	 *
	 * _.map(objects, _.property('a.b'));
	 * // => [2, 1]
	 *
	 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
	 * // => [1, 2]
	 */
	function property(path) {
	  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
	}

	/**
	 * The base implementation of `_.iteratee`.
	 *
	 * @private
	 * @param {*} [value=_.identity] The value to convert to an iteratee.
	 * @returns {Function} Returns the iteratee.
	 */
	function baseIteratee(value) {
	  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
	  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
	  if (typeof value == 'function') {
	    return value;
	  }
	  if (value == null) {
	    return identity;
	  }
	  if (typeof value == 'object') {
	    return isArray$1(value)
	      ? baseMatchesProperty(value[0], value[1])
	      : baseMatches(value);
	  }
	  return property(value);
	}

	/**
	 * Gets the timestamp of the number of milliseconds that have elapsed since
	 * the Unix epoch (1 January 1970 00:00:00 UTC).
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Date
	 * @returns {number} Returns the timestamp.
	 * @example
	 *
	 * _.defer(function(stamp) {
	 *   console.log(_.now() - stamp);
	 * }, _.now());
	 * // => Logs the number of milliseconds it took for the deferred invocation.
	 */
	var now = function() {
	  return root.Date.now();
	};

	/** Error message constants. */
	var FUNC_ERROR_TEXT$1 = 'Expected a function';

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax$1 = Math.max,
	    nativeMin = Math.min;

	/**
	 * Creates a debounced function that delays invoking `func` until after `wait`
	 * milliseconds have elapsed since the last time the debounced function was
	 * invoked. The debounced function comes with a `cancel` method to cancel
	 * delayed `func` invocations and a `flush` method to immediately invoke them.
	 * Provide `options` to indicate whether `func` should be invoked on the
	 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
	 * with the last arguments provided to the debounced function. Subsequent
	 * calls to the debounced function return the result of the last `func`
	 * invocation.
	 *
	 * **Note:** If `leading` and `trailing` options are `true`, `func` is
	 * invoked on the trailing edge of the timeout only if the debounced function
	 * is invoked more than once during the `wait` timeout.
	 *
	 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
	 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
	 *
	 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	 * for details over the differences between `_.debounce` and `_.throttle`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to debounce.
	 * @param {number} [wait=0] The number of milliseconds to delay.
	 * @param {Object} [options={}] The options object.
	 * @param {boolean} [options.leading=false]
	 *  Specify invoking on the leading edge of the timeout.
	 * @param {number} [options.maxWait]
	 *  The maximum time `func` is allowed to be delayed before it's invoked.
	 * @param {boolean} [options.trailing=true]
	 *  Specify invoking on the trailing edge of the timeout.
	 * @returns {Function} Returns the new debounced function.
	 * @example
	 *
	 * // Avoid costly calculations while the window size is in flux.
	 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
	 *
	 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
	 * jQuery(element).on('click', _.debounce(sendMail, 300, {
	 *   'leading': true,
	 *   'trailing': false
	 * }));
	 *
	 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
	 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
	 * var source = new EventSource('/stream');
	 * jQuery(source).on('message', debounced);
	 *
	 * // Cancel the trailing debounced invocation.
	 * jQuery(window).on('popstate', debounced.cancel);
	 */
	function debounce(func, wait, options) {
	  var lastArgs,
	      lastThis,
	      maxWait,
	      result,
	      timerId,
	      lastCallTime,
	      lastInvokeTime = 0,
	      leading = false,
	      maxing = false,
	      trailing = true;

	  if (typeof func != 'function') {
	    throw new TypeError(FUNC_ERROR_TEXT$1);
	  }
	  wait = toNumber(wait) || 0;
	  if (isObject$1(options)) {
	    leading = !!options.leading;
	    maxing = 'maxWait' in options;
	    maxWait = maxing ? nativeMax$1(toNumber(options.maxWait) || 0, wait) : maxWait;
	    trailing = 'trailing' in options ? !!options.trailing : trailing;
	  }

	  function invokeFunc(time) {
	    var args = lastArgs,
	        thisArg = lastThis;

	    lastArgs = lastThis = undefined;
	    lastInvokeTime = time;
	    result = func.apply(thisArg, args);
	    return result;
	  }

	  function leadingEdge(time) {
	    // Reset any `maxWait` timer.
	    lastInvokeTime = time;
	    // Start the timer for the trailing edge.
	    timerId = setTimeout(timerExpired, wait);
	    // Invoke the leading edge.
	    return leading ? invokeFunc(time) : result;
	  }

	  function remainingWait(time) {
	    var timeSinceLastCall = time - lastCallTime,
	        timeSinceLastInvoke = time - lastInvokeTime,
	        timeWaiting = wait - timeSinceLastCall;

	    return maxing
	      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
	      : timeWaiting;
	  }

	  function shouldInvoke(time) {
	    var timeSinceLastCall = time - lastCallTime,
	        timeSinceLastInvoke = time - lastInvokeTime;

	    // Either this is the first call, activity has stopped and we're at the
	    // trailing edge, the system time has gone backwards and we're treating
	    // it as the trailing edge, or we've hit the `maxWait` limit.
	    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
	      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
	  }

	  function timerExpired() {
	    var time = now();
	    if (shouldInvoke(time)) {
	      return trailingEdge(time);
	    }
	    // Restart the timer.
	    timerId = setTimeout(timerExpired, remainingWait(time));
	  }

	  function trailingEdge(time) {
	    timerId = undefined;

	    // Only invoke if we have `lastArgs` which means `func` has been
	    // debounced at least once.
	    if (trailing && lastArgs) {
	      return invokeFunc(time);
	    }
	    lastArgs = lastThis = undefined;
	    return result;
	  }

	  function cancel() {
	    if (timerId !== undefined) {
	      clearTimeout(timerId);
	    }
	    lastInvokeTime = 0;
	    lastArgs = lastCallTime = lastThis = timerId = undefined;
	  }

	  function flush() {
	    return timerId === undefined ? result : trailingEdge(now());
	  }

	  function debounced() {
	    var time = now(),
	        isInvoking = shouldInvoke(time);

	    lastArgs = arguments;
	    lastThis = this;
	    lastCallTime = time;

	    if (isInvoking) {
	      if (timerId === undefined) {
	        return leadingEdge(lastCallTime);
	      }
	      if (maxing) {
	        // Handle invocations in a tight loop.
	        clearTimeout(timerId);
	        timerId = setTimeout(timerExpired, wait);
	        return invokeFunc(lastCallTime);
	      }
	    }
	    if (timerId === undefined) {
	      timerId = setTimeout(timerExpired, wait);
	    }
	    return result;
	  }
	  debounced.cancel = cancel;
	  debounced.flush = flush;
	  return debounced;
	}

	/**
	 * This method is like `_.isArrayLike` except that it also checks if `value`
	 * is an object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array-like object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArrayLikeObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLikeObject(document.body.children);
	 * // => true
	 *
	 * _.isArrayLikeObject('abc');
	 * // => false
	 *
	 * _.isArrayLikeObject(_.noop);
	 * // => false
	 */
	function isArrayLikeObject(value) {
	  return isObjectLike(value) && isArrayLike(value);
	}

	/**
	 * This function is like `arrayIncludes` except that it accepts a comparator.
	 *
	 * @private
	 * @param {Array} [array] The array to inspect.
	 * @param {*} target The value to search for.
	 * @param {Function} comparator The comparator invoked per element.
	 * @returns {boolean} Returns `true` if `target` is found, else `false`.
	 */
	function arrayIncludesWith(array, value, comparator) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (comparator(value, array[index])) {
	      return true;
	    }
	  }
	  return false;
	}

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE$1 = 200;

	/**
	 * The base implementation of methods like `_.difference` without support
	 * for excluding multiple arrays or iteratee shorthands.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {Array} values The values to exclude.
	 * @param {Function} [iteratee] The iteratee invoked per element.
	 * @param {Function} [comparator] The comparator invoked per element.
	 * @returns {Array} Returns the new array of filtered values.
	 */
	function baseDifference(array, values, iteratee, comparator) {
	  var index = -1,
	      includes = arrayIncludes,
	      isCommon = true,
	      length = array.length,
	      result = [],
	      valuesLength = values.length;

	  if (!length) {
	    return result;
	  }
	  if (iteratee) {
	    values = arrayMap(values, baseUnary(iteratee));
	  }
	  if (comparator) {
	    includes = arrayIncludesWith;
	    isCommon = false;
	  }
	  else if (values.length >= LARGE_ARRAY_SIZE$1) {
	    includes = cacheHas;
	    isCommon = false;
	    values = new SetCache(values);
	  }
	  outer:
	  while (++index < length) {
	    var value = array[index],
	        computed = iteratee == null ? value : iteratee(value);

	    value = (comparator || value !== 0) ? value : 0;
	    if (isCommon && computed === computed) {
	      var valuesIndex = valuesLength;
	      while (valuesIndex--) {
	        if (values[valuesIndex] === computed) {
	          continue outer;
	        }
	      }
	      result.push(value);
	    }
	    else if (!includes(values, computed, comparator)) {
	      result.push(value);
	    }
	  }
	  return result;
	}

	/**
	 * Gets the last element of `array`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Array
	 * @param {Array} array The array to query.
	 * @returns {*} Returns the last element of `array`.
	 * @example
	 *
	 * _.last([1, 2, 3]);
	 * // => 3
	 */
	function last(array) {
	  var length = array == null ? 0 : array.length;
	  return length ? array[length - 1] : undefined;
	}

	/**
	 * This method is like `_.difference` except that it accepts `iteratee` which
	 * is invoked for each element of `array` and `values` to generate the criterion
	 * by which they're compared. The order and references of result values are
	 * determined by the first array. The iteratee is invoked with one argument:
	 * (value).
	 *
	 * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Array
	 * @param {Array} array The array to inspect.
	 * @param {...Array} [values] The values to exclude.
	 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	 * @returns {Array} Returns the new array of filtered values.
	 * @example
	 *
	 * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
	 * // => [1.2]
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
	 * // => [{ 'x': 2 }]
	 */
	var differenceBy = baseRest(function(array, values) {
	  var iteratee = last(values);
	  if (isArrayLikeObject(iteratee)) {
	    iteratee = undefined;
	  }
	  return isArrayLikeObject(array)
	    ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), baseIteratee(iteratee))
	    : [];
	});

	var methods$3 = {
	  registerEvents: function registerEvents(flag) {
	    var viewer = this.viewer,
	        cesiumObject = this.cesiumObject,
	        enbaleEvent = this.enbaleEvent;
	    var that = this;

	    if (flag && enbaleEvent) {
	      if (!this.$vc._screenSpaceEventHandler) {
	        this.$vc._screenSpaceEventHandler = new Cesium.ScreenSpaceEventHandler(viewer.canvas);
	        var handler = this.$vc._screenSpaceEventHandler;
	        Events['viewer-mouse-events'].forEach(function (eventName) {
	          handler.setInputAction(action.bind({
	            eventName: eventName,
	            viewer: viewer
	          }), Cesium.ScreenSpaceEventType[eventName]);
	        });
	      }

	      Events['mouse-events'].forEach(function (eventName) {
	        var listener = that.$listeners[eventName];
	        listener && (cesiumObject[eventName] = listener.fns);
	      });
	    } else {
	      Events['mouse-events'].forEach(function (eventName) {
	        var listener = that.$listeners[eventName];
	        listener && delete cesiumObject[eventName];
	      });
	    }
	  }
	};
	var mixinPickEvent = {
	  methods: methods$3
	};

	function action(movement) {
	  var viewer = this.viewer,
	      eventName = this.eventName;
	  var position = movement.position || movement.endPosition;

	  if (!position) {
	    return;
	  }

	  var pickedFeatureAndCallbackNames = [];
	  var callbackName;

	  if (eventName.indexOf('LEFT_DOUBLE_CLICK') !== -1) {
	    callbackName = 'dblclick';
	  } else if (eventName.indexOf('CLICK') !== -1) {
	    callbackName = 'click';
	  } else if (eventName.indexOf('DOWN') !== -1) {
	    callbackName = 'mousedown';
	  } else if (eventName.indexOf('UP') !== -1) {
	    callbackName = 'mouseup';
	  } else if (eventName.indexOf('MOUSE_MOVE') !== -1) {
	    callbackName = 'mousemove';
	  }

	  var callbackNameOut;

	  if (callbackName === 'mousemove') {
	    callbackNameOut = 'mouseout';
	  } else if (callbackName === 'click') {
	    callbackNameOut = 'clickout';
	  }

	  var pickedFeature = viewer.scene.pick(position);

	  if (!Cesium.defined(pickedFeature)) {
	    if (this.pickedFeature) {
	      // 没有拾取到对象，this.pickedFeature又有记录，说明移出了。
	      pickedFeatureAndCallbackNames.push({
	        callbackName: callbackNameOut,
	        pickedFeature: this.pickedFeature
	      });
	    }

	    this.pickedFeature = undefined;
	  } else {
	    if (this.pickedFeature && this.pickedFeature !== pickedFeature) {
	      pickedFeatureAndCallbackNames.push({
	        // 拾取到对象，this.pickedFeature也有记录，两者不同，说明操作到另外一个对象上去了
	        callbackName: callbackNameOut,
	        pickedFeature: this.pickedFeature
	      });
	    }

	    if (callbackName === 'mousemove' && (!this.pickedFeature || this.pickedFeature !== pickedFeature)) {
	      pickedFeatureAndCallbackNames.push({
	        callbackName: 'mouseover',
	        pickedFeature: pickedFeature
	      });
	    }

	    pickedFeatureAndCallbackNames.push({
	      callbackName: callbackName,
	      pickedFeature: pickedFeature
	    });
	  }

	  if (pickedFeatureAndCallbackNames.length === 0) {
	    return;
	  }

	  var intersection;
	  var scene = viewer.scene;

	  if (scene.mode === Cesium.SceneMode.SCENE3D) {
	    var ray = scene.camera.getPickRay(position);
	    intersection = scene.globe.pick(ray, scene);
	  } else {
	    intersection = scene.camera.pickEllipsoid(position, Cesium.Ellipsoid.WGS84);
	  }

	  var button = -1;

	  if (eventName.indexOf('LEFT') !== -1) {
	    button = 0;
	  } else if (eventName.indexOf('MIDDLE') !== -1) {
	    button = 1;
	  } else if (eventName.indexOf('RIGHT') !== -1) {
	    button = 2;
	  }

	  var eventSourceList = [];
	  pickedFeatureAndCallbackNames.forEach(function (item) {
	    var callbackName = item.callbackName;
	    var pickedFeature = item.pickedFeature;

	    if (pickedFeature.id) {
	      if (isArray(pickedFeature.id) && pickedFeature.id[0] instanceof Cesium.Entity) {
	        // 数据源集合（集群）
	        eventSourceList.push({
	          callbackName: callbackName,
	          cesiumObject: pickedFeature.id[0].entityCollection.owner,
	          pickedFeature: pickedFeature
	        });
	      } else if (pickedFeature.id instanceof Cesium.Entity) {
	        // 实体
	        eventSourceList.push({
	          callbackName: callbackName,
	          cesiumObject: pickedFeature.id,
	          pickedFeature: pickedFeature
	        }); // 数据源

	        eventSourceList.push({
	          callbackName: callbackName,
	          cesiumObject: pickedFeature.id.entityCollection.owner,
	          pickedFeature: pickedFeature
	        });
	      }
	    } // 图元


	    if (pickedFeature.primitive) {
	      eventSourceList.push({
	        callbackName: callbackName,
	        cesiumObject: pickedFeature.primitive,
	        pickedFeature: pickedFeature
	      });
	    }

	    var getParentCollection = function getParentCollection(e) {
	      eventSourceList.push({
	        callbackName: callbackName,
	        cesiumObject: e,
	        pickedFeature: pickedFeature
	      });

	      if (e._vcParent) {
	        getParentCollection(e._vcParent);
	      }
	    }; // 图元集合


	    if (pickedFeature.collection) {
	      eventSourceList.push({
	        callbackName: callbackName,
	        cesiumObject: pickedFeature.collection,
	        pickedFeature: pickedFeature
	      });

	      if (pickedFeature.collection._vcParent) {
	        getParentCollection(pickedFeature.collection._vcParent);
	      }
	    }
	  });
	  eventSourceList.forEach(function (event) {
	    event.cesiumObject[event.callbackName] && event.cesiumObject[event.callbackName]({
	      type: "on".concat(event.callbackName),
	      windowPosition: position,
	      surfacePosition: intersection,
	      pickedFeature: event.pickedFeature,
	      button: button,
	      cesiumObject: event.cesiumObject
	    });
	  });
	  this.pickedFeature = pickedFeature;
	}

	var watch = {
	  entities: {
	    /**
	     * https://cn.vuejs.org/v2/guide/reactivity.html#检测变化的注意事项
	     */
	    handler: function handler(newVal, oldVal) {
	      if (!this.mounted) {
	        return;
	      }

	      var transformProp = this.transformProp,
	          transformProps = this.transformProps,
	          datasource = this.datasource;

	      if (newVal === oldVal) {
	        if (newVal.length === datasource.entities.values.length) {
	          var _loop = function _loop(i) {
	            var options = newVal[i];

	            keys$1(options).forEach(function (prop) {
	              if (prop !== 'id') {
	                datasource.entities.values[i][prop] = transformProp(prop, options[prop]);
	              }
	            });
	          };

	          // 认为是修改了某个对象
	          for (var i = 0; i < newVal.length; i++) {
	            _loop(i);
	          }
	        } else if (newVal.length > datasource.entities.values.length) {
	          // 认为是插入了新对象 push unshift splice
	          var addedEntities = differenceBy(newVal, datasource.entities.values, 'id');

	          if (addedEntities.length === 0) ;

	          for (var _i = 0; _i < addedEntities.length; _i++) {
	            var entityOptions = addedEntities[_i];
	            var entityOptionsTransform = transformProps(entityOptions);
	            var entityAdded = datasource.entities.add(entityOptionsTransform);
	            entityAdded.vcIndex = newVal.indexOf(entityOptions);
	            entityAdded.id !== entityOptions.id && (entityOptions.id = entityAdded.id);
	          }
	        } else if (newVal.length < datasource.entities.values.length) {
	          // 认为是删除了对象 pop splice shift
	          var deletedEntities = differenceBy(datasource.entities.values, newVal, 'id');

	          for (var _i2 = 0; _i2 < deletedEntities.length; _i2++) {
	            var entity = deletedEntities[_i2];
	            datasource.entities.remove(entity);
	          }

	          var iNull = 0;

	          for (var _i3 = 0; _i3 < datasource.entities.values.length; _i3++) {
	            if (datasource.entities.values[_i3]) {
	              datasource.entities.values[_i3].vcIndex = _i3 - iNull;
	            } else {
	              iNull++;
	            }
	          }
	        }
	      } else {
	        // 认为是赋新值
	        this.reload();
	      }
	    },
	    deep: true
	  }
	};
	var methods$4 = {
	  mount: function mount() {
	    var _this = this;

	    var dataSources, datasource, registerEvents, entities, transformProps, i, entityOptions, entityOptionsTransform, entity;
	    return regenerator.async(function mount$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            dataSources = this.dataSources, datasource = this.datasource, registerEvents = this.registerEvents, entities = this.entities, transformProps = this.transformProps;
	            bindEvents.call(this, datasource, Events['datasource-events'], true);
	            Events['datasource-property-events'].forEach(function (eventName) {
	              datasource[eventName.name] && bindEvents.call(_this, datasource[eventName.name], eventName.events, true);
	            });
	            datasource.show = this.show;
	            registerEvents(true);

	            for (i = 0; i < entities.length; i++) {
	              entityOptions = entities[i];
	              entityOptionsTransform = transformProps(entityOptions);
	              entity = datasource.entities.add(entityOptionsTransform);
	              entity.vcIndex = i;
	              entityOptions.id !== entity.id && (entityOptions.id = entity.id);
	            }

	            return _context.abrupt("return", dataSources && dataSources.add(datasource));

	          case 7:
	          case "end":
	            return _context.stop();
	        }
	      }
	    }, null, this);
	  },
	  unmount: function unmount() {
	    var _this2 = this;

	    var dataSources, datasource, registerEvents;
	    return regenerator.async(function unmount$(_context2) {
	      while (1) {
	        switch (_context2.prev = _context2.next) {
	          case 0:
	            dataSources = this.dataSources, datasource = this.datasource, registerEvents = this.registerEvents;
	            bindEvents.call(this, datasource, Events['datasource-events'], false);
	            Events['datasource-property-events'].forEach(function (eventName) {
	              datasource[eventName.name] && bindEvents.call(_this2, datasource[eventName.name], eventName.events, false);
	            });
	            registerEvents(false);
	            return _context2.abrupt("return", dataSources && dataSources.remove(datasource));

	          case 5:
	          case "end":
	            return _context2.stop();
	        }
	      }
	    }, null, this);
	  },
	  getServices: function getServices() {
	    var vm = this;
	    return multiMergeDescriptors(cmp.methods.getServices.call(this), {
	      get datasource() {
	        return vm.datasource;
	      },

	      get entities() {
	        return vm.datasource.entities;
	      }

	    });
	  }
	};
	var mixinDatasource = {
	  mixins: [cmp, show, mixinPickEvent],
	  methods: methods$4,
	  props: {
	    enbaleEvent: {
	      type: Boolean,
	      default: true
	    },
	    entities: {
	      type: Array,
	      default: function _default() {
	        return [];
	      }
	    }
	  },
	  watch: watch,
	  stubVNode: {
	    attrs: function attrs() {
	      return {
	        class: this.$options.name
	      };
	    }
	  },
	  created: function created() {
	    var _this3 = this;

	    defineProperties$1(this, {
	      datasource: {
	        enumerable: true,
	        get: function get() {
	          return _this3.cesiumObject;
	        }
	      },
	      dataSources: {
	        enumerable: true,
	        get: function get() {
	          return _this3.$services && _this3.$services.dataSources;
	        }
	      }
	    });
	  }
	};

	var script$m = {
	  name: 'vc-datasource-custom',
	  mixins: [mixinDatasource],
	  props: {
	    name: String
	  },
	  methods: {
	    /**
	     *  重写 createCesiumObject 方法
	     */
	    createCesiumObject: function createCesiumObject() {
	      var name, ds;
	      return regenerator.async(function createCesiumObject$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              name = this.name;
	              ds = new Cesium.CustomDataSource(name);
	              return _context.abrupt("return", ds);

	            case 3:
	            case "end":
	              return _context.stop();
	          }
	        }
	      }, null, this);
	    }
	  }
	};

	/* script */
	var __vue_script__$m = script$m;
	/* template */

	/* style */

	var __vue_inject_styles__$m = undefined;
	/* scoped */

	var __vue_scope_id__$m = undefined;
	/* functional template */

	var __vue_is_functional_template__$m = undefined;
	/* component normalizer */

	function __vue_normalize__$m(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "CustomDataSource.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var CustomDataSource = __vue_normalize__$m({}, __vue_inject_styles__$m, __vue_script__$m, __vue_scope_id__$m, __vue_is_functional_template__$m);

	function plugin$m(Vue) {

	  if (plugin$m.installed) {
	    return;
	  }

	  plugin$m.installed = true;
	  Vue.component(CustomDataSource.name, CustomDataSource);
	}

	var CustomDataSource$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$m,
		CustomDataSource: CustomDataSource,
		install: plugin$m
	});

	var script$n = {
	  name: 'vc-datasource-czml',
	  mixins: [mixinDatasource],
	  props: {
	    czml: {
	      type: [String, Object],
	      required: true
	    },
	    options: Object
	  },
	  methods: {
	    createCesiumObject: function createCesiumObject() {
	      var czml, options;
	      return regenerator.async(function createCesiumObject$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              czml = this.czml, options = this.options;
	              return _context.abrupt("return", Cesium.CzmlDataSource.load(czml, options));

	            case 2:
	            case "end":
	              return _context.stop();
	          }
	        }
	      }, null, this);
	    }
	  }
	};

	/* script */
	var __vue_script__$n = script$n;
	/* template */

	/* style */

	var __vue_inject_styles__$n = undefined;
	/* scoped */

	var __vue_scope_id__$n = undefined;
	/* functional template */

	var __vue_is_functional_template__$n = undefined;
	/* component normalizer */

	function __vue_normalize__$n(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "CzmlDataSource.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var CzmlDataSource = __vue_normalize__$n({}, __vue_inject_styles__$n, __vue_script__$n, __vue_scope_id__$n, __vue_is_functional_template__$n);

	function plugin$n(Vue) {

	  if (plugin$n.installed) {
	    return;
	  }

	  plugin$n.installed = true;
	  Vue.component(CzmlDataSource.name, CzmlDataSource);
	}

	var CzmlDataSource$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$n,
		CzmlDataSource: CzmlDataSource,
		install: plugin$n
	});

	var script$o = {
	  name: 'vc-datasource-geojson',
	  mixins: [data, options, mixinDatasource],
	  methods: {
	    createCesiumObject: function createCesiumObject() {
	      var $props, transformProps, options;
	      return regenerator.async(function createCesiumObject$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              $props = this.$props, transformProps = this.transformProps;
	              options = transformProps($props);
	              return _context.abrupt("return", Cesium.GeoJsonDataSource.load(options.data, options.options));

	            case 3:
	            case "end":
	              return _context.stop();
	          }
	        }
	      }, null, this);
	    }
	  }
	};

	/* script */
	var __vue_script__$o = script$o;
	/* template */

	/* style */

	var __vue_inject_styles__$o = undefined;
	/* scoped */

	var __vue_scope_id__$o = undefined;
	/* functional template */

	var __vue_is_functional_template__$o = undefined;
	/* component normalizer */

	function __vue_normalize__$o(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "GeoJsonDataSource.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var GeoJsonDataSource = __vue_normalize__$o({}, __vue_inject_styles__$o, __vue_script__$o, __vue_scope_id__$o, __vue_is_functional_template__$o);

	function plugin$o(Vue) {

	  if (plugin$o.installed) {
	    return;
	  }

	  plugin$o.installed = true;
	  Vue.component(GeoJsonDataSource.name, GeoJsonDataSource);
	}

	var GeoJsonDataSource$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$o,
		GeoJsonDataSource: GeoJsonDataSource,
		install: plugin$o
	});

	var script$p = {
	  name: 'vc-datasource-kml',
	  mixins: [data, options, mixinDatasource],
	  methods: {
	    createCesiumObject: function createCesiumObject() {
	      var $props, transformProps, viewer, options;
	      return regenerator.async(function createCesiumObject$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              $props = this.$props, transformProps = this.transformProps, viewer = this.viewer;
	              options = transformProps($props);
	              options.options = options.options || {};

	              if (!options.options.camera) {
	                options.options.camera = viewer.camera;
	              }

	              if (!options.options.canvas) {
	                options.options.canvas = viewer.canvas;
	              }

	              return _context.abrupt("return", Cesium.KmlDataSource.load(options.data, options.options));

	            case 6:
	            case "end":
	              return _context.stop();
	          }
	        }
	      }, null, this);
	    }
	  }
	};

	/* script */
	var __vue_script__$p = script$p;
	/* template */

	/* style */

	var __vue_inject_styles__$p = undefined;
	/* scoped */

	var __vue_scope_id__$p = undefined;
	/* functional template */

	var __vue_is_functional_template__$p = undefined;
	/* component normalizer */

	function __vue_normalize__$p(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "KmlDataSource.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var KmlDataSource = __vue_normalize__$p({}, __vue_inject_styles__$p, __vue_script__$p, __vue_scope_id__$p, __vue_is_functional_template__$p);

	function plugin$p(Vue) {

	  if (plugin$p.installed) {
	    return;
	  }

	  plugin$p.installed = true;
	  Vue.component(KmlDataSource.name, KmlDataSource);
	}

	var KmlDataSource$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$p,
		KmlDataSource: KmlDataSource,
		install: plugin$p
	});

	var script$q = {
	  name: 'vc-entity',
	  mixins: [cmp, position, plane, mixinPickEvent],
	  props: {
	    id: String,
	    name: String,
	    availability: Object,
	    show: {
	      type: Boolean,
	      default: true
	    },
	    description: [String, Object],
	    orientation: Object,
	    viewFrom: Object,
	    parent: Object,
	    billboard: Object,
	    corridor: Object,
	    cylinder: Object,
	    ellipse: Object,
	    ellipsoid: Object,
	    box: Object,
	    label: Object,
	    model: Object,
	    tileset: Object,
	    path: Object,
	    point: Object,
	    polygon: Object,
	    polyline: Object,
	    properties: Object,
	    polylineVolume: Object,
	    rectangle: Object,
	    wall: Object,
	    enbaleEvent: {
	      type: Boolean,
	      default: true
	    }
	  },
	  methods: {
	    mount: function mount() {
	      var entities, entity, registerEvents;
	      return regenerator.async(function mount$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              entities = this.entities, entity = this.entity, registerEvents = this.registerEvents;
	              registerEvents(true);
	              bindEvents.call(this, entity, Events['entity-events']);
	              return _context.abrupt("return", entities && entities.add(entity));

	            case 4:
	            case "end":
	              return _context.stop();
	          }
	        }
	      }, null, this);
	    },
	    unmount: function unmount() {
	      var entities, entity, registerEvents;
	      return regenerator.async(function unmount$(_context2) {
	        while (1) {
	          switch (_context2.prev = _context2.next) {
	            case 0:
	              entities = this.entities, entity = this.entity, registerEvents = this.registerEvents;
	              bindEvents.call(this, entity, Events['entity-events'], false);
	              registerEvents(false);
	              return _context2.abrupt("return", entities && entities.remove(entity));

	            case 4:
	            case "end":
	              return _context2.stop();
	          }
	        }
	      }, null, this);
	    },
	    setGraphics: function setGraphics(graphics, type) {
	      var listener = this.$listeners['update:' + type];

	      if (listener) {
	        this.$emit('update:' + type, graphics);
	      } else {
	        this.entity[type] = graphics;
	      }

	      return true;
	    },
	    getServices: function getServices() {
	      var vm = this;
	      return multiMergeDescriptors(cmp.methods.getServices.call(this), {
	        get entity() {
	          return vm.entity;
	        },

	        get graphicsContainer() {
	          return vm;
	        }

	      });
	    }
	  },
	  stubVNode: {
	    attrs: function attrs() {
	      return {
	        class: this.$options.name
	      };
	    }
	  },
	  created: function created() {
	    var _this = this;

	    defineProperties$1(this, {
	      entity: {
	        enumerable: true,
	        get: function get() {
	          return _this.cesiumObject;
	        }
	      },
	      entities: {
	        enumerable: true,
	        get: function get() {
	          return _this.$services && _this.$services.entities;
	        }
	      }
	    });
	  }
	};

	/* script */
	var __vue_script__$q = script$q;
	/* template */

	/* style */

	var __vue_inject_styles__$q = undefined;
	/* scoped */

	var __vue_scope_id__$q = undefined;
	/* functional template */

	var __vue_is_functional_template__$q = undefined;
	/* component normalizer */

	function __vue_normalize__$q(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "Entity.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var Entity = __vue_normalize__$q({}, __vue_inject_styles__$q, __vue_script__$q, __vue_scope_id__$q, __vue_is_functional_template__$q);

	function plugin$q(Vue) {

	  if (plugin$q.installed) {
	    return;
	  }

	  plugin$q.installed = true;
	  Vue.component(Entity.name, Entity);
	}

	var Entity$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$q,
		Entity: Entity,
		install: plugin$q
	});

	/**
	 * vc-graphics-billbord or vc-billboard base props
	 */

	var mixinBillboard = {
	  mixins: [image, scale, pixelOffset, eyeOffset, horizontalOrigin, verticalOrigin, heightReference, color, rotation, alignedAxis, sizeInMeters, width, height, scaleByDistance, translucencyByDistance, pixelOffsetScaleByDistance, disableDepthTestDistance, show, distanceDisplayCondition]
	};

	var methods$5 = {
	  /**
	   * 用异步方式的将 graphics 挂载到 entity。
	   */
	  mount: function mount() {
	    var graphics, graphicsContainer, $options, arr;
	    return regenerator.async(function mount$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            graphics = this.graphics, graphicsContainer = this.graphicsContainer, $options = this.$options;
	            bindEvents.call(this, graphics, Events['entity-events']);
	            arr = $options.name.split('-');
	            return _context.abrupt("return", graphicsContainer && graphicsContainer.setGraphics(graphics, arr.length === 3 ? arr[2] : 'polylineVolume'));

	          case 4:
	          case "end":
	            return _context.stop();
	        }
	      }
	    }, null, this);
	  },

	  /**
	   * 用异步方的式将 graphics 从 entity 卸载。
	   */
	  unmount: function unmount() {
	    var graphics, graphicsContainer, $options, arr;
	    return regenerator.async(function unmount$(_context2) {
	      while (1) {
	        switch (_context2.prev = _context2.next) {
	          case 0:
	            graphics = this.graphics, graphicsContainer = this.graphicsContainer, $options = this.$options;
	            bindEvents.call(this, graphics, Events['entity-events'], false);
	            arr = $options.name.split('-');
	            return _context2.abrupt("return", graphicsContainer && graphicsContainer.setGraphics(undefined, arr.length === 3 ? arr[2] : 'polylineVolume'));

	          case 4:
	          case "end":
	            return _context2.stop();
	        }
	      }
	    }, null, this);
	  }
	};
	/**
	 * 与 vc-entity 组件关联的各 graphics 子组件基础混入方法。
	 */

	var mixinGraphic = {
	  mixins: [cmp],
	  methods: methods$5,
	  stubVNode: {
	    empty: function empty() {
	      return this.$options.name;
	    }
	  },
	  created: function created() {
	    var _this = this;

	    defineProperties$1(this, {
	      graphics: {
	        enumerable: true,
	        get: function get() {
	          return _this.cesiumObject;
	        }
	      },
	      graphicsContainer: {
	        enumerable: true,
	        get: function get() {
	          return _this.$services && _this.$services.graphicsContainer;
	        }
	      }
	    });
	  }
	};

	var script$r = {
	  name: 'vc-graphics-billboard',
	  mixins: [imageSubRegion, mixinBillboard, mixinGraphic]
	};

	/* script */
	var __vue_script__$r = script$r;
	/* template */

	/* style */

	var __vue_inject_styles__$r = undefined;
	/* scoped */

	var __vue_scope_id__$r = undefined;
	/* functional template */

	var __vue_is_functional_template__$r = undefined;
	/* component normalizer */

	function __vue_normalize__$r(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "BillboardGraphics.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var BillboardGraphics = __vue_normalize__$r({}, __vue_inject_styles__$r, __vue_script__$r, __vue_scope_id__$r, __vue_is_functional_template__$r);

	function plugin$r(Vue) {

	  if (plugin$r.installed) {
	    return;
	  }

	  plugin$r.installed = true;
	  Vue.component(BillboardGraphics.name, BillboardGraphics);
	}

	var BillboardGraphics$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$r,
		BillboardGraphics: BillboardGraphics,
		install: plugin$r
	});

	/**
	 * vc-graphics-box base props mixins
	 */

	var mixinBox = {
	  mixins: [dimensions]
	};

	var script$s = {
	  name: 'vc-graphics-box',
	  mixins: [heightReference, fill, material, outline, outlineColor, outlineWidth, shadows, mixinBox, mixinGraphic]
	};

	/* script */
	var __vue_script__$s = script$s;
	/* template */

	/* style */

	var __vue_inject_styles__$s = undefined;
	/* scoped */

	var __vue_scope_id__$s = undefined;
	/* functional template */

	var __vue_is_functional_template__$s = undefined;
	/* component normalizer */

	function __vue_normalize__$s(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "BoxGraphics.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var BoxGraphics = __vue_normalize__$s({}, __vue_inject_styles__$s, __vue_script__$s, __vue_scope_id__$s, __vue_is_functional_template__$s);

	function plugin$s(Vue) {

	  if (plugin$s.installed) {
	    return;
	  }

	  plugin$s.installed = true;
	  Vue.component(BoxGraphics.name, BoxGraphics);
	}

	var BoxGraphics$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$s,
		BoxGraphics: BoxGraphics,
		install: plugin$s
	});

	/**
	 * vc-graphics-corridor base props mixins
	 */

	var mixinCorridor = {
	  mixins: [positions, width, height, extrudedHeight, cornerType, granularity]
	};

	var script$t = {
	  name: 'vc-graphics-corridor',
	  mixins: [mixinCorridor, heightReference, extrudedHeightReference, fill, material, outline, outlineColor, outlineWidth, shadows, classificationType, zIndex, mixinGraphic, show, distanceDisplayCondition]
	};

	/* script */
	var __vue_script__$t = script$t;
	/* template */

	/* style */

	var __vue_inject_styles__$t = undefined;
	/* scoped */

	var __vue_scope_id__$t = undefined;
	/* functional template */

	var __vue_is_functional_template__$t = undefined;
	/* component normalizer */

	function __vue_normalize__$t(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "CorridorGraphics.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var CorridorGraphics = __vue_normalize__$t({}, __vue_inject_styles__$t, __vue_script__$t, __vue_scope_id__$t, __vue_is_functional_template__$t);

	function plugin$t(Vue) {

	  if (plugin$t.installed) {
	    return;
	  }

	  plugin$t.installed = true;
	  Vue.component(CorridorGraphics.name, CorridorGraphics);
	}

	var CorridorGraphics$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$t,
		CorridorGraphics: CorridorGraphics,
		install: plugin$t
	});

	/**
	 * vc-graphics-cylinder base props mixins
	 */

	var mixinCylinder = {
	  mixins: [length, topRadius, bottomRadius, slices]
	};

	var script$u = {
	  name: 'vc-graphics-cylinder',
	  mixins: [show, distanceDisplayCondition, heightReference, fill, material, outline, outlineColor, outlineWidth, numberOfVerticalLines, shadows, mixinCylinder, mixinGraphic]
	};

	/* script */
	var __vue_script__$u = script$u;
	/* template */

	/* style */

	var __vue_inject_styles__$u = undefined;
	/* scoped */

	var __vue_scope_id__$u = undefined;
	/* functional template */

	var __vue_is_functional_template__$u = undefined;
	/* component normalizer */

	function __vue_normalize__$u(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "CylinderGraphics.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var CylinderGraphics = __vue_normalize__$u({}, __vue_inject_styles__$u, __vue_script__$u, __vue_scope_id__$u, __vue_is_functional_template__$u);

	function plugin$u(Vue) {

	  if (plugin$u.installed) {
	    return;
	  }

	  plugin$u.installed = true;
	  Vue.component(CylinderGraphics.name, CylinderGraphics);
	}

	var CylinderGraphics$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$u,
		CylinderGraphics: CylinderGraphics,
		install: plugin$u
	});

	/**
	 * vc-graphics-ellipse base props mixins
	 */

	var mixinEllipse = {
	  mixins: [semiMajorAxis, semiMinorAxis, height, extrudedHeight, rotation, granularity]
	};

	var script$v = {
	  name: 'vc-graphics-ellipse',
	  mixins: [show, distanceDisplayCondition, heightReference, extrudedHeightReference, fill, material, outline, outlineColor, outlineWidth, numberOfVerticalLines, shadows, classificationType, zIndex, stRotation, mixinEllipse, mixinGraphic]
	};

	/* script */
	var __vue_script__$v = script$v;
	/* template */

	/* style */

	var __vue_inject_styles__$v = undefined;
	/* scoped */

	var __vue_scope_id__$v = undefined;
	/* functional template */

	var __vue_is_functional_template__$v = undefined;
	/* component normalizer */

	function __vue_normalize__$v(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "EllipseGraphics.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var EllipseGraphics = __vue_normalize__$v({}, __vue_inject_styles__$v, __vue_script__$v, __vue_scope_id__$v, __vue_is_functional_template__$v);

	function plugin$v(Vue) {

	  if (plugin$v.installed) {
	    return;
	  }

	  plugin$v.installed = true;
	  Vue.component(EllipseGraphics.name, EllipseGraphics);
	}

	var EllipseGraphics$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$v,
		EllipseGraphics: EllipseGraphics,
		install: plugin$v
	});

	/**
	 * vc-graphics-ellipsoid base props mixins
	 */

	var mixinEllipsoid = {
	  mixins: [radii, stackPartitions, slicePartitions]
	};

	var script$w = {
	  name: 'vc-graphics-ellipsoid',
	  mixins: [show, distanceDisplayCondition, heightReference, fill, material, outline, outlineColor, outlineWidth, subdivisions, shadows, mixinEllipsoid, mixinGraphic]
	};

	/* script */
	var __vue_script__$w = script$w;
	/* template */

	/* style */

	var __vue_inject_styles__$w = undefined;
	/* scoped */

	var __vue_scope_id__$w = undefined;
	/* functional template */

	var __vue_is_functional_template__$w = undefined;
	/* component normalizer */

	function __vue_normalize__$w(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "EllipsoidGraphics.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var EllipsoidGraphics = __vue_normalize__$w({}, __vue_inject_styles__$w, __vue_script__$w, __vue_scope_id__$w, __vue_is_functional_template__$w);

	function plugin$w(Vue) {

	  if (plugin$w.installed) {
	    return;
	  }

	  plugin$w.installed = true;
	  Vue.component(EllipsoidGraphics.name, EllipsoidGraphics);
	}

	var EllipsoidGraphics$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$w,
		EllipsoidGraphics: EllipsoidGraphics,
		install: plugin$w
	});

	/**
	 * vc-graphics-label or vc-label base props mixins
	 */

	var mixinLabel = {
	  mixins: [show, distanceDisplayCondition, text, font, labelStyle, scale, showBackground, backgroundColor, backgroundPadding, pixelOffset, eyeOffset, horizontalOrigin, verticalOrigin, heightReference, fillColor, outlineColor, outlineWidth, translucencyByDistance, pixelOffsetScaleByDistance, scaleByDistance, disableDepthTestDistance]
	};

	var script$x = {
	  name: 'vc-graphics-label',
	  mixins: [mixinLabel, mixinGraphic]
	};

	/* script */
	var __vue_script__$x = script$x;
	/* template */

	/* style */

	var __vue_inject_styles__$x = undefined;
	/* scoped */

	var __vue_scope_id__$x = undefined;
	/* functional template */

	var __vue_is_functional_template__$x = undefined;
	/* component normalizer */

	function __vue_normalize__$x(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "LabelGraphics.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var LabelGraphics = __vue_normalize__$x({}, __vue_inject_styles__$x, __vue_script__$x, __vue_scope_id__$x, __vue_is_functional_template__$x);

	function plugin$x(Vue) {

	  if (plugin$x.installed) {
	    return;
	  }

	  plugin$x.installed = true;
	  Vue.component(LabelGraphics.name, LabelGraphics);
	}

	var LabelGraphics$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$x,
		LabelGraphics: LabelGraphics,
		install: plugin$x
	});

	/**
	 * vc-graphics-model base props mixins
	 */

	var mixinModel = {
	  mixins: [show, distanceDisplayCondition, scale, minimumPixelSize, maximumScale, incrementallyLoadTextures, clampAnimations, shadows, heightReference, silhouetteColor, silhouetteSize, color, colorBlendMode, colorBlendAmount]
	};

	var script$y = {
	  name: 'vc-graphics-model',
	  mixins: [mixinModel, mixinGraphic, imageBasedLightingFactor, lightColor, uri, nodeTransformations, runAnimations, articulations]
	};

	/* script */
	var __vue_script__$y = script$y;
	/* template */

	/* style */

	var __vue_inject_styles__$y = undefined;
	/* scoped */

	var __vue_scope_id__$y = undefined;
	/* functional template */

	var __vue_is_functional_template__$y = undefined;
	/* component normalizer */

	function __vue_normalize__$y(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "ModelGraphics.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var ModelGraphics = __vue_normalize__$y({}, __vue_inject_styles__$y, __vue_script__$y, __vue_scope_id__$y, __vue_is_functional_template__$y);

	function plugin$y(Vue) {

	  if (plugin$y.installed) {
	    return;
	  }

	  plugin$y.installed = true;
	  Vue.component(ModelGraphics.name, ModelGraphics);
	}

	var ModelGraphics$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$y,
		ModelGraphics: ModelGraphics,
		install: plugin$y
	});

	var script$z = {
	  name: 'vc-graphics-tileset',
	  mixins: [show, uri, maximumScreenSpaceError, mixinGraphic]
	};

	/* script */
	var __vue_script__$z = script$z;
	/* template */

	/* style */

	var __vue_inject_styles__$z = undefined;
	/* scoped */

	var __vue_scope_id__$z = undefined;
	/* functional template */

	var __vue_is_functional_template__$z = undefined;
	/* component normalizer */

	function __vue_normalize__$z(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "Cesium3DTilesetGraphics.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var Cesium3DTilesetGraphics = __vue_normalize__$z({}, __vue_inject_styles__$z, __vue_script__$z, __vue_scope_id__$z, __vue_is_functional_template__$z);

	function plugin$z(Vue) {

	  if (plugin$z.installed) {
	    return;
	  }

	  plugin$z.installed = true;
	  Vue.component(Cesium3DTilesetGraphics.name, Cesium3DTilesetGraphics);
	}

	var Cesium3DTilesetGraphics$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$z,
		Cesium3DTilesetGraphics: Cesium3DTilesetGraphics,
		install: plugin$z
	});

	var script$A = {
	  name: 'vc-graphics-path',
	  mixins: [show, distanceDisplayCondition, width, material, mixinGraphic],
	  props: {
	    leadTime: [Number, Object, Function],
	    trailTime: [Number, Object, Function],
	    resolution: {
	      type: [Number, Object, Function],
	      default: 60
	    }
	  }
	};

	/* script */
	var __vue_script__$A = script$A;
	/* template */

	/* style */

	var __vue_inject_styles__$A = undefined;
	/* scoped */

	var __vue_scope_id__$A = undefined;
	/* functional template */

	var __vue_is_functional_template__$A = undefined;
	/* component normalizer */

	function __vue_normalize__$A(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "PathGraphics.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var PathGraphics = __vue_normalize__$A({}, __vue_inject_styles__$A, __vue_script__$A, __vue_scope_id__$A, __vue_is_functional_template__$A);

	function plugin$A(Vue) {

	  if (plugin$A.installed) {
	    return;
	  }

	  plugin$A.installed = true;
	  Vue.component(PathGraphics.name, PathGraphics);
	}

	var PathGraphics$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$A,
		PathGraphics: PathGraphics,
		install: plugin$A
	});

	var script$B = {
	  name: 'vc-graphics-plane',
	  mixins: [show, distanceDisplayCondition, dimensions, fill, material, outline, outlineColor, outlineWidth, shadows, mixinGraphic],
	  props: {
	    // 和 BoxGraphics.dimensions 区分
	    plane: {
	      type: [Object, Array, Function],
	      watcherOptions: {
	        cesiumObjectBuilder: makeCartesian2
	      }
	    }
	  }
	};

	/* script */
	var __vue_script__$B = script$B;
	/* template */

	/* style */

	var __vue_inject_styles__$B = undefined;
	/* scoped */

	var __vue_scope_id__$B = undefined;
	/* functional template */

	var __vue_is_functional_template__$B = undefined;
	/* component normalizer */

	function __vue_normalize__$B(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "PlaneGraphics.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var PlaneGraphics = __vue_normalize__$B({}, __vue_inject_styles__$B, __vue_script__$B, __vue_scope_id__$B, __vue_is_functional_template__$B);

	function plugin$B(Vue) {

	  if (plugin$B.installed) {
	    return;
	  }

	  plugin$B.installed = true;
	  Vue.component(PlaneGraphics.name, PlaneGraphics);
	}

	var PlaneGraphics$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$B,
		PlaneGraphics: PlaneGraphics,
		install: plugin$B
	});

	/**
	 * vc-graphics-point base props mixins
	 */

	var mixinPoint = {
	  mixins: [show, distanceDisplayCondition, pixelSize, color, outlineColor, outlineWidth, scaleByDistance, translucencyByDistance, disableDepthTestDistance]
	};

	var script$C = {
	  name: 'vc-graphics-point',
	  mixins: [heightReference, mixinPoint, mixinGraphic]
	};

	/* script */
	var __vue_script__$C = script$C;
	/* template */

	/* style */

	var __vue_inject_styles__$C = undefined;
	/* scoped */

	var __vue_scope_id__$C = undefined;
	/* functional template */

	var __vue_is_functional_template__$C = undefined;
	/* component normalizer */

	function __vue_normalize__$C(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "PointGraphics.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var PointGraphics = __vue_normalize__$C({}, __vue_inject_styles__$C, __vue_script__$C, __vue_scope_id__$C, __vue_is_functional_template__$C);

	function plugin$C(Vue) {

	  if (plugin$C.installed) {
	    return;
	  }

	  plugin$C.installed = true;
	  Vue.component(PointGraphics.name, PointGraphics);
	}

	var PointGraphics$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$C,
		PointGraphics: PointGraphics,
		install: plugin$C
	});

	/**
	 * vc-graphics-polygon base props mixins
	 */

	var mixinPolygon = {
	  mixins: [height, extrudedHeight, stRotation, granularity, perPositionHeight, closeTop, closeBottom, arcType]
	};

	var script$D = {
	  name: 'vc-graphics-polygon',
	  mixins: [show, distanceDisplayCondition, heightReference, extrudedHeightReference, fill, material, outline, outlineColor, outlineWidth, shadows, classificationType, zIndex, hierarchy, mixinPolygon, mixinGraphic]
	};

	/* script */
	var __vue_script__$D = script$D;
	/* template */

	/* style */

	var __vue_inject_styles__$D = undefined;
	/* scoped */

	var __vue_scope_id__$D = undefined;
	/* functional template */

	var __vue_is_functional_template__$D = undefined;
	/* component normalizer */

	function __vue_normalize__$D(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "PolygonGraphics.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var PolygonGraphics = __vue_normalize__$D({}, __vue_inject_styles__$D, __vue_script__$D, __vue_scope_id__$D, __vue_is_functional_template__$D);

	function plugin$D(Vue) {

	  if (plugin$D.installed) {
	    return;
	  }

	  plugin$D.installed = true;
	  Vue.component(PolygonGraphics.name, PolygonGraphics);
	}

	var PolygonGraphics$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$D,
		PolygonGraphics: PolygonGraphics,
		install: plugin$D
	});

	/**
	 * vc-graphics-polyline base props mixins
	 */

	var mixinPolyline = {
	  mixins: [show, distanceDisplayCondition, width, material, positions]
	};

	var script$E = {
	  name: 'vc-graphics-polyline',
	  mixins: [granularity, arcType, clampToGround, classificationType, zIndex, depthFailMaterial, mixinPolyline, mixinGraphic]
	};

	/* script */
	var __vue_script__$E = script$E;
	/* template */

	/* style */

	var __vue_inject_styles__$E = undefined;
	/* scoped */

	var __vue_scope_id__$E = undefined;
	/* functional template */

	var __vue_is_functional_template__$E = undefined;
	/* component normalizer */

	function __vue_normalize__$E(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "PolylineGraphics.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var PolylineGraphics = __vue_normalize__$E({}, __vue_inject_styles__$E, __vue_script__$E, __vue_scope_id__$E, __vue_is_functional_template__$E);

	function plugin$E(Vue) {

	  if (plugin$E.installed) {
	    return;
	  }

	  plugin$E.installed = true;
	  Vue.component(PolylineGraphics.name, PolylineGraphics);
	}

	var PolylineGraphics$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$E,
		PolylineGraphics: PolylineGraphics,
		install: plugin$E
	});

	/**
	 * vc-graphics-polyline-volume base props mixins
	 */

	var mixinPolylineVolume = {
	  mixins: [cornerType, granularity]
	};

	var script$F = {
	  name: 'vc-graphics-polyline-volume',
	  mixins: [show, distanceDisplayCondition, positions, fill, material, outline, outlineColor, outlineWidth, shadows, shape, mixinPolylineVolume, mixinGraphic]
	};

	/* script */
	var __vue_script__$F = script$F;
	/* template */

	/* style */

	var __vue_inject_styles__$F = undefined;
	/* scoped */

	var __vue_scope_id__$F = undefined;
	/* functional template */

	var __vue_is_functional_template__$F = undefined;
	/* component normalizer */

	function __vue_normalize__$F(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "PolylineVolumeGraphics.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var PolylineVolumeGraphics = __vue_normalize__$F({}, __vue_inject_styles__$F, __vue_script__$F, __vue_scope_id__$F, __vue_is_functional_template__$F);

	function plugin$F(Vue) {

	  if (plugin$F.installed) {
	    return;
	  }

	  plugin$F.installed = true;
	  Vue.component(PolylineVolumeGraphics.name, PolylineVolumeGraphics);
	}

	var PolylineVolumeGraphics$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$F,
		PolylineVolumeGraphics: PolylineVolumeGraphics,
		install: plugin$F
	});

	/**
	 * vc-graphics-rectangle base props mixins
	 */

	var mixinRectangle = {
	  mixins: [granularity, height, rotation, stRotation, extrudedHeight]
	};

	var script$G = {
	  name: 'vc-graphics-rectangle',
	  mixins: [show, distanceDisplayCondition, heightReference, extrudedHeightReference, fill, material, outline, outlineColor, outlineWidth, shadows, classificationType, zIndex, coordinates, mixinRectangle, mixinGraphic]
	};

	/* script */
	var __vue_script__$G = script$G;
	/* template */

	/* style */

	var __vue_inject_styles__$G = undefined;
	/* scoped */

	var __vue_scope_id__$G = undefined;
	/* functional template */

	var __vue_is_functional_template__$G = undefined;
	/* component normalizer */

	function __vue_normalize__$G(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "RectangleGraphics.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var RectangleGraphics = __vue_normalize__$G({}, __vue_inject_styles__$G, __vue_script__$G, __vue_scope_id__$G, __vue_is_functional_template__$G);

	function plugin$G(Vue) {

	  if (plugin$G.installed) {
	    return;
	  }

	  plugin$G.installed = true;
	  Vue.component(RectangleGraphics.name, RectangleGraphics);
	}

	var RectangleGraphics$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$G,
		RectangleGraphics: RectangleGraphics,
		install: plugin$G
	});

	/**
	 * vc-graphics-wall base props mixins
	 */

	var mixinWall = {
	  mixins: [positions, granularity, maximumHeights, minimumHeights]
	};

	var script$H = {
	  name: 'vc-graphics-wall',
	  mixins: [show, distanceDisplayCondition, fill, material, outline, outlineColor, outlineWidth, shadows, mixinWall, mixinGraphic]
	};

	/* script */
	var __vue_script__$H = script$H;
	/* template */

	/* style */

	var __vue_inject_styles__$H = undefined;
	/* scoped */

	var __vue_scope_id__$H = undefined;
	/* functional template */

	var __vue_is_functional_template__$H = undefined;
	/* component normalizer */

	function __vue_normalize__$H(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "WallGraphics.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var WallGraphics = __vue_normalize__$H({}, __vue_inject_styles__$H, __vue_script__$H, __vue_scope_id__$H, __vue_is_functional_template__$H);

	function plugin$H(Vue) {

	  if (plugin$H.installed) {
	    return;
	  }

	  plugin$H.installed = true;
	  Vue.component(WallGraphics.name, WallGraphics);
	}

	var WallGraphics$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$H,
		WallGraphics: WallGraphics,
		install: plugin$H
	});

	var methods$6 = {
	  mount: function mount() {
	    var primitives, collection, registerEvents;
	    return regenerator.async(function mount$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            primitives = this.primitives, collection = this.collection, registerEvents = this.registerEvents;
	            registerEvents(true);
	            collection._vcParent = primitives;
	            return _context.abrupt("return", primitives && primitives.add(collection));

	          case 4:
	          case "end":
	            return _context.stop();
	        }
	      }
	    }, null, this);
	  },
	  unmount: function unmount() {
	    var primitives, collection, registerEvents;
	    return regenerator.async(function unmount$(_context2) {
	      while (1) {
	        switch (_context2.prev = _context2.next) {
	          case 0:
	            primitives = this.primitives, collection = this.collection, registerEvents = this.registerEvents;
	            registerEvents(false);
	            return _context2.abrupt("return", primitives && !collection.isDestroyed() && primitives.remove(collection));

	          case 3:
	          case "end":
	            return _context2.stop();
	        }
	      }
	    }, null, this);
	  },
	  getServices: function getServices() {
	    var vm = this;
	    return multiMergeDescriptors(cmp.methods.getServices.call(this), {
	      get primitives() {
	        return vm.collection;
	      },

	      get collectionContainer() {
	        return vm;
	      }

	    });
	  }
	};
	var mixinPrimitiveCollection = {
	  mixins: [cmp, mixinPickEvent],
	  methods: methods$6,
	  props: {
	    enbaleEvent: {
	      type: Boolean,
	      default: true
	    }
	  },
	  stubVNode: {
	    attrs: function attrs() {
	      return {
	        class: this.$options.name
	      };
	    }
	  },
	  created: function created() {
	    var _this = this;

	    defineProperties$1(this, {
	      collection: {
	        enumerable: true,
	        get: function get() {
	          return _this.cesiumObject;
	        }
	      },
	      primitives: {
	        enumerable: true,
	        get: function get() {
	          return _this.$services && _this.$services.primitives;
	        }
	      },
	      groundPrimitives: {
	        enumerable: true,
	        get: function get() {
	          return _this.$services && _this.$services.groundPrimitives;
	        }
	      }
	    });
	  }
	};

	var script$I = {
	  name: 'vc-collection-primitive',
	  mixins: [show, mixinPrimitiveCollection],
	  props: {
	    destroyPrimitives: {
	      type: Boolean,
	      default: true
	    }
	  }
	};

	/* script */
	var __vue_script__$I = script$I;
	/* template */

	/* style */

	var __vue_inject_styles__$I = undefined;
	/* scoped */

	var __vue_scope_id__$I = undefined;
	/* functional template */

	var __vue_is_functional_template__$I = undefined;
	/* component normalizer */

	function __vue_normalize__$I(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "PrimitiveCollection.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var PrimitiveCollection = __vue_normalize__$I({}, __vue_inject_styles__$I, __vue_script__$I, __vue_scope_id__$I, __vue_is_functional_template__$I);

	function plugin$I(Vue) {

	  if (plugin$I.installed) {
	    return;
	  }

	  plugin$I.installed = true;
	  Vue.component(PrimitiveCollection.name, PrimitiveCollection);
	}

	var PrimitiveCollection$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$I,
		PrimitiveCollection: PrimitiveCollection,
		install: plugin$I
	});

	var script$J = {
	  name: 'vc-collection-primitive-billboard',
	  mixins: [scene, blendOption, mixinPrimitiveCollection],
	  props: {
	    billboards: {
	      type: Array,
	      default: function _default() {
	        return [];
	      }
	    }
	  },
	  watch: {
	    billboards: {
	      /**
	       * https://cn.vuejs.org/v2/guide/reactivity.html#检测变化的注意事项
	       */
	      handler: function handler(newVal, oldVal) {
	        if (!this.mounted) {
	          return;
	        }

	        var transformProp = this.transformProp,
	            transformProps = this.transformProps,
	            billboardCollection = this.collection;

	        if (newVal === oldVal) {
	          // 插入新布告板 billboards.push()，修改布告板属性 billboards[i].xxx，或者 vm.$set(vm.billboards, indexOfBillboard, newValue)
	          if (newVal.length === billboardCollection._billboards.length) {
	            var _loop = function _loop(i) {
	              var options = newVal[i];

	              keys$1(options).forEach(function (prop) {
	                billboardCollection._billboards[i][prop] = transformProp(prop, options[prop]);
	              });
	            };

	            // 认为是修改了某个对象
	            for (var i = 0; i < newVal.length; i++) {
	              _loop(i);
	            }
	          } else if (newVal.length > billboardCollection._billboards.length) {
	            // 认为是插入了新对象 push unshift splice
	            var addedBillboards = differenceBy(newVal, billboardCollection._billboards, 'id');

	            if (addedBillboards.length === 0) ;

	            for (var _i = 0; _i < addedBillboards.length; _i++) {
	              var billboard = addedBillboards[_i];
	              billboard.id = billboard.id || Cesium.createGuid();
	              var billboardTransform = transformProps(billboard);
	              var billboardAdded = billboardCollection.add(billboardTransform);
	              billboardAdded.vcIndex = newVal.indexOf(billboard);
	            }
	          } else if (newVal.length < billboardCollection._billboards.length) {
	            // 认为是删除了对象 pop splice shift
	            var deletedBillboards = differenceBy(billboardCollection._billboards, newVal, 'id');

	            for (var _i2 = 0; _i2 < deletedBillboards.length; _i2++) {
	              var _billboard = deletedBillboards[_i2];
	              billboardCollection.remove(_billboard);
	            }

	            var iNull = 0;

	            for (var _i3 = 0; _i3 < billboardCollection._billboards.length; _i3++) {
	              if (billboardCollection._billboards[_i3]) {
	                billboardCollection._billboards[_i3].vcIndex = _i3 - iNull;
	              } else {
	                iNull++;
	              }
	            }
	          }
	        } else {
	          // 认为是赋新值
	          this.reload();
	        }
	      },
	      deep: true
	    }
	  },
	  methods: {
	    /**
	     *  重写 createCesiumObject 方法，支持用数组加载大量 billboard。
	     */
	    createCesiumObject: function createCesiumObject() {
	      var $props, transformProps, billboards, options, billboardCollection, i, billboardOptions, billboardOptionsTransform, billboard, prop;
	      return regenerator.async(function createCesiumObject$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              $props = this.$props, transformProps = this.transformProps, billboards = this.billboards;
	              options = transformProps($props);
	              billboardCollection = new Cesium.BillboardCollection(options);

	              for (i = 0; i < billboards.length; i++) {
	                billboardOptions = billboards[i];
	                billboardOptions.id = Cesium.defined(billboardOptions.id) ? billboardOptions.id : Cesium.createGuid();
	                billboardOptionsTransform = transformProps(billboardOptions);
	                billboard = billboardCollection.add(billboardOptionsTransform);

	                for (prop in billboardOptionsTransform) {
	                  if (!billboard[prop]) {
	                    billboard[prop] = billboardOptionsTransform[prop];
	                  }
	                }

	                billboard.vcIndex = i;
	              }

	              return _context.abrupt("return", billboardCollection);

	            case 5:
	            case "end":
	              return _context.stop();
	          }
	        }
	      }, null, this);
	    }
	  }
	};

	/* script */
	var __vue_script__$J = script$J;
	/* template */

	/* style */

	var __vue_inject_styles__$J = undefined;
	/* scoped */

	var __vue_scope_id__$J = undefined;
	/* functional template */

	var __vue_is_functional_template__$J = undefined;
	/* component normalizer */

	function __vue_normalize__$J(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "BillboardCollection.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var BillboardCollection = __vue_normalize__$J({}, __vue_inject_styles__$J, __vue_script__$J, __vue_scope_id__$J, __vue_is_functional_template__$J);

	function plugin$J(Vue) {

	  if (plugin$J.installed) {
	    return;
	  }

	  plugin$J.installed = true;
	  Vue.component(BillboardCollection.name, BillboardCollection);
	}

	var BillboardCollection$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$J,
		BillboardCollection: BillboardCollection,
		install: plugin$J
	});

	var script$K = {
	  name: 'vc-collection-primitive-label',
	  mixins: [scene, blendOption, mixinPrimitiveCollection],
	  props: {
	    labels: {
	      type: Array,
	      default: function _default() {
	        return [];
	      }
	    }
	  },
	  watch: {
	    labels: {
	      /**
	       * https://cn.vuejs.org/v2/guide/reactivity.html#检测变化的注意事项
	       */
	      handler: function handler(newVal, oldVal) {
	        if (!this.mounted) {
	          return;
	        }

	        var transformProp = this.transformProp,
	            transformProps = this.transformProps,
	            labelCollection = this.collection;

	        if (newVal === oldVal) {
	          if (newVal.length === labelCollection._labels.length) {
	            var _loop = function _loop(i) {
	              var options = newVal[i];

	              keys$1(options).forEach(function (prop) {
	                labelCollection._labels[i][prop] = transformProp(prop, options[prop]);
	              });
	            };

	            // 认为是修改了某个对象
	            for (var i = 0; i < newVal.length; i++) {
	              _loop(i);
	            }
	          } else if (newVal.length > labelCollection._labels.length) {
	            // 认为是插入了新对象 push unshift splice
	            var addedLabels = differenceBy(newVal, labelCollection._labels, 'id');

	            if (addedLabels.length === 0) ;

	            for (var _i = 0; _i < addedLabels.length; _i++) {
	              var label = addedLabels[_i];
	              label.id = label.id || Cesium.createGuid();
	              var labelTransform = transformProps(label);
	              var labelAdded = labelCollection.add(labelTransform);
	              labelAdded.vcIndex = newVal.indexOf(label);
	            }
	          } else if (newVal.length < labelCollection._labels.length) {
	            // 认为是删除了对象 pop splice shift
	            var deletedLabels = differenceBy(labelCollection._labels, newVal, 'id');

	            for (var _i2 = 0; _i2 < deletedLabels.length; _i2++) {
	              var _label = deletedLabels[_i2];
	              labelCollection.remove(_label);
	            }

	            var iNull = 0;

	            for (var _i3 = 0; _i3 < labelCollection._labels.length; _i3++) {
	              if (labelCollection._labels[_i3]) {
	                labelCollection._labels[_i3].vcIndex = _i3 - iNull;
	              } else {
	                iNull++;
	              }
	            }
	          }
	        } else {
	          // 认为是赋新值
	          this.reload();
	        }
	      },
	      deep: true
	    }
	  },
	  methods: {
	    /**
	     *  重写 createCesiumObject 方法，支持用数组加载大量 label。
	     */
	    createCesiumObject: function createCesiumObject() {
	      var $props, transformProps, labels, options, labelColletion, i, labelOptions, labelOptionsTransform, label, prop;
	      return regenerator.async(function createCesiumObject$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              $props = this.$props, transformProps = this.transformProps, labels = this.labels;
	              options = transformProps($props);
	              labelColletion = new Cesium.LabelCollection(options);

	              for (i = 0; i < labels.length; i++) {
	                labelOptions = labels[i];
	                labelOptions.id = Cesium.defined(labelOptions.id) ? labelOptions.id : Cesium.createGuid();
	                labelOptionsTransform = transformProps(labelOptions);
	                label = labelColletion.add(labelOptionsTransform);

	                for (prop in labelOptionsTransform) {
	                  if (!label[prop]) {
	                    label[prop] = labelOptionsTransform[prop];
	                  }
	                }

	                label.vcIndex = i;
	              }

	              return _context.abrupt("return", labelColletion);

	            case 5:
	            case "end":
	              return _context.stop();
	          }
	        }
	      }, null, this);
	    }
	  }
	};

	/* script */
	var __vue_script__$K = script$K;
	/* template */

	/* style */

	var __vue_inject_styles__$K = undefined;
	/* scoped */

	var __vue_scope_id__$K = undefined;
	/* functional template */

	var __vue_is_functional_template__$K = undefined;
	/* component normalizer */

	function __vue_normalize__$K(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "LabelCollection.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var LabelCollection = __vue_normalize__$K({}, __vue_inject_styles__$K, __vue_script__$K, __vue_scope_id__$K, __vue_is_functional_template__$K);

	function plugin$K(Vue) {

	  if (plugin$K.installed) {
	    return;
	  }

	  plugin$K.installed = true;
	  Vue.component(LabelCollection.name, LabelCollection);
	}

	var LabelCollection$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$K,
		LabelCollection: LabelCollection,
		install: plugin$K
	});

	var script$L = {
	  name: 'vc-collection-primitive-point',
	  mixins: [blendOption, modelMatrix, debugShowBoundingVolume, mixinPrimitiveCollection],
	  props: {
	    points: {
	      type: Array,
	      default: function _default() {
	        return [];
	      }
	    }
	  },
	  watch: {
	    labels: {
	      /**
	       * https://cn.vuejs.org/v2/guide/reactivity.html#检测变化的注意事项
	       */
	      handler: function handler(newVal, oldVal) {
	        if (!this.mounted) {
	          return;
	        }

	        var transformProp = this.transformProp,
	            transformProps = this.transformProps,
	            pointColletion = this.collection;

	        if (newVal === oldVal) {
	          if (newVal.length === pointColletion._points.length) {
	            var _loop = function _loop(i) {
	              var options = newVal[i];

	              keys$1(options).forEach(function (prop) {
	                pointColletion._points[i][prop] = transformProp(prop, options[prop]);
	              });
	            };

	            // 认为是修改了某个对象
	            for (var i = 0; i < newVal.length; i++) {
	              _loop(i);
	            }
	          } else if (newVal.length > pointColletion._points.length) {
	            // 认为是插入了新对象 push unshift splice
	            var addedPoints = differenceBy(newVal, pointColletion._points, 'id');

	            if (addedPoints.length === 0) ;

	            for (var _i = 0; _i < addedPoints.length; _i++) {
	              var point = addedPoints[_i];
	              point.id = point.id || Cesium.createGuid();
	              var pointTransform = transformProps(point);
	              var pointAdded = pointColletion.add(pointTransform);
	              pointAdded.vcIndex = newVal.indexOf(point);
	            }
	          } else if (newVal.length < pointColletion._points.length) {
	            // 认为是删除了对象 pop splice shift
	            var deletedPoints = differenceBy(pointColletion._points, newVal, 'id');

	            for (var _i2 = 0; _i2 < deletedPoints.length; _i2++) {
	              var _point = deletedPoints[_i2];
	              pointColletion.remove(_point);
	            }

	            var iNull = 0;

	            for (var _i3 = 0; _i3 < pointColletion._points.length; _i3++) {
	              if (pointColletion._points[_i3]) {
	                pointColletion._points[_i3].vcIndex = _i3 - iNull;
	              } else {
	                iNull++;
	              }
	            }
	          }
	        } else {
	          // 认为是赋新值
	          this.reload();
	        }
	      },
	      deep: true
	    }
	  },
	  methods: {
	    /**
	     *  重写 createCesiumObject 方法，支持用数组加载大量 point。
	     */
	    createCesiumObject: function createCesiumObject() {
	      var $props, transformProps, points, options, pointColletion, i, pointOptions, pointOptionsTransform, point, prop;
	      return regenerator.async(function createCesiumObject$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              $props = this.$props, transformProps = this.transformProps, points = this.points;
	              options = transformProps($props);
	              pointColletion = new Cesium.PointPrimitiveCollection(options);

	              for (i = 0; i < points.length; i++) {
	                pointOptions = points[i];
	                pointOptions.id = Cesium.defined(pointOptions.id) ? pointOptions.id : Cesium.createGuid();
	                pointOptionsTransform = transformProps(pointOptions);
	                point = pointColletion.add(pointOptionsTransform);

	                for (prop in pointOptionsTransform) {
	                  if (!point[prop]) {
	                    point[prop] = pointOptionsTransform[prop];
	                  }
	                }

	                point.vcIndex = i;
	              }

	              return _context.abrupt("return", pointColletion);

	            case 5:
	            case "end":
	              return _context.stop();
	          }
	        }
	      }, null, this);
	    }
	  }
	};

	/* script */
	var __vue_script__$L = script$L;
	/* template */

	/* style */

	var __vue_inject_styles__$L = undefined;
	/* scoped */

	var __vue_scope_id__$L = undefined;
	/* functional template */

	var __vue_is_functional_template__$L = undefined;
	/* component normalizer */

	function __vue_normalize__$L(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "PointPrimitiveCollection.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var PointPrimitiveCollection = __vue_normalize__$L({}, __vue_inject_styles__$L, __vue_script__$L, __vue_scope_id__$L, __vue_is_functional_template__$L);

	function plugin$L(Vue) {

	  if (plugin$L.installed) {
	    return;
	  }

	  plugin$L.installed = true;
	  Vue.component(PointPrimitiveCollection.name, PointPrimitiveCollection);
	}

	var PointPrimitiveCollection$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$L,
		PointPrimitiveCollection: PointPrimitiveCollection,
		install: plugin$L
	});

	var script$M = {
	  name: 'vc-collection-primitive-polyline',
	  mixins: [modelMatrix, debugShowBoundingVolume, mixinPrimitiveCollection],
	  props: {
	    polylines: {
	      type: Array,
	      default: function _default() {
	        return [];
	      }
	    }
	  },
	  watch: {
	    polylines: {
	      /**
	       * https://cn.vuejs.org/v2/guide/reactivity.html#检测变化的注意事项
	       */
	      handler: function handler(newVal, oldVal) {
	        if (!this.mounted) {
	          return;
	        }

	        var transformProp = this.transformProp,
	            transformProps = this.transformProps,
	            polylineCollection = this.collection;

	        if (newVal === oldVal) {
	          if (newVal.length === polylineCollection._polylines.length) {
	            var _loop = function _loop(i) {
	              var options = newVal[i];

	              keys$1(options).forEach(function (prop) {
	                polylineCollection._polylines[i][prop] = transformProp(prop, options[prop]);
	              });
	            };

	            // 认为是修改了某个对象
	            for (var i = 0; i < newVal.length; i++) {
	              _loop(i);
	            }
	          } else if (newVal.length > polylineCollection._polylines.length) {
	            // 认为是插入了新对象 push unshift splice
	            var addedPolylines = differenceBy(newVal, polylineCollection._polylines, 'id');

	            if (addedPolylines.length === 0) ;

	            for (var _i = 0; _i < addedPolylines.length; _i++) {
	              var polyline = addedPolylines[_i];
	              polyline.id = polyline.id || Cesium.createGuid();
	              var polylineTransform = transformProps(polyline);
	              var polylineAdded = polylineCollection.add(polylineTransform);
	              polylineAdded.vcIndex = newVal.indexOf(polyline);
	            }
	          } else if (newVal.length < polylineCollection._polylines.length) {
	            // 认为是删除了对象 pop splice shift
	            var deletedPolylines = differenceBy(polylineCollection._polylines, newVal, 'id');

	            for (var _i2 = 0; _i2 < deletedPolylines.length; _i2++) {
	              var _polyline = deletedPolylines[_i2];
	              polylineCollection.remove(_polyline);
	            }

	            var iNull = 0;

	            for (var _i3 = 0; _i3 < polylineCollection._polylines.length; _i3++) {
	              if (polylineCollection._polylines[_i3]) {
	                polylineCollection._polylines[_i3].vcIndex = _i3 - iNull;
	              } else {
	                iNull++;
	              }
	            }
	          }
	        } else {
	          // 认为是赋新值
	          this.reload();
	        }
	      },
	      deep: true
	    }
	  },
	  methods: {
	    /**
	     *  重写 createCesiumObject 方法，支持用数组加载大量 polyline
	     */
	    createCesiumObject: function createCesiumObject() {
	      var $props, transformProps, polylines, options, polylineCollection, i, polylineOptions, polylineOptionsTransform, polyline, prop;
	      return regenerator.async(function createCesiumObject$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              $props = this.$props, transformProps = this.transformProps, polylines = this.polylines;
	              options = transformProps($props);
	              polylineCollection = new Cesium.PolylineCollection(options);

	              for (i = 0; i < polylines.length; i++) {
	                polylineOptions = polylines[i];
	                polylineOptions.id = Cesium.defined(polylineOptions.id) ? polylineOptions.id : Cesium.createGuid();
	                polylineOptionsTransform = transformProps(polylineOptions);
	                polyline = polylineCollection.add(polylineOptionsTransform);

	                for (prop in polylineOptionsTransform) {
	                  if (!polyline[prop]) {
	                    polyline[prop] = polylineOptionsTransform[prop];
	                  }
	                }

	                polyline.vcIndex = i;
	              }

	              return _context.abrupt("return", polylineCollection);

	            case 5:
	            case "end":
	              return _context.stop();
	          }
	        }
	      }, null, this);
	    }
	  }
	};

	/* script */
	var __vue_script__$M = script$M;
	/* template */

	/* style */

	var __vue_inject_styles__$M = undefined;
	/* scoped */

	var __vue_scope_id__$M = undefined;
	/* functional template */

	var __vue_is_functional_template__$M = undefined;
	/* component normalizer */

	function __vue_normalize__$M(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "PolylineCollection.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var PolylineCollection = __vue_normalize__$M({}, __vue_inject_styles__$M, __vue_script__$M, __vue_scope_id__$M, __vue_is_functional_template__$M);

	function plugin$M(Vue) {

	  if (plugin$M.installed) {
	    return;
	  }

	  plugin$M.installed = true;
	  Vue.component(PolylineCollection.name, PolylineCollection);
	}

	var PolylineCollection$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$M,
		PolylineCollection: PolylineCollection,
		install: plugin$M
	});

	var methods$7 = {
	  mount: function mount() {
	    var _this = this;

	    var primitives, primitive, registerEvents;
	    return regenerator.async(function mount$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            primitives = this.primitives, primitive = this.primitive, registerEvents = this.registerEvents;
	            primitive.readyPromise && primitive.readyPromise.then(function (primitive) {
	              var listener = _this.$listeners.readyPromise;
	              listener && _this.$emit('readyPromise', primitive);
	            }).otherwise(function (error) {
	              throw new Cesium.DeveloperError(error);
	            });
	            bindEvents.call(this, primitive, undefined, true);
	            registerEvents(true);
	            primitive._vcParent = primitives;
	            return _context.abrupt("return", primitives && primitives.add(primitive));

	          case 6:
	          case "end":
	            return _context.stop();
	        }
	      }
	    }, null, this);
	  },
	  unmount: function unmount() {
	    var primitives, primitive, registerEvents;
	    return regenerator.async(function unmount$(_context2) {
	      while (1) {
	        switch (_context2.prev = _context2.next) {
	          case 0:
	            primitives = this.primitives, primitive = this.primitive, registerEvents = this.registerEvents;
	            this.childCount = 0;
	            this.instances = [];
	            bindEvents.call(this, primitive, undefined, false);
	            registerEvents(false);
	            return _context2.abrupt("return", primitives && primitives.remove(primitive));

	          case 6:
	          case "end":
	            return _context2.stop();
	        }
	      }
	    }, null, this);
	  },
	  setGeometryInstances: function setGeometryInstances(geometryInstance, index) {
	    var listener;
	    return regenerator.async(function setGeometryInstances$(_context3) {
	      while (1) {
	        switch (_context3.prev = _context3.next) {
	          case 0:
	            this.instances.push(geometryInstance);

	            if (index === this.childCount - 1) {
	              listener = this.$listeners['update:geometryInstances'];

	              if (listener) {
	                this.$emit('update:geometryInstances', this.instances);
	              } else {
	                this.primitive.geometryInstances = index === 0 ? geometryInstance : this.instances;
	              }
	            }

	            return _context3.abrupt("return", true);

	          case 3:
	          case "end":
	            return _context3.stop();
	        }
	      }
	    }, null, this);
	  },
	  getServices: function getServices() {
	    var vm = this;
	    return multiMergeDescriptors(cmp.methods.getServices.call(this), {
	      get primitive() {
	        return vm.primitive;
	      },

	      get primitiveContainer() {
	        return vm;
	      }

	    });
	  }
	};
	var mixinPrimitive = {
	  data: function data() {
	    return {
	      childCount: 0,
	      instances: []
	    };
	  },
	  props: {
	    enbaleEvent: {
	      type: Boolean,
	      default: true
	    }
	  },
	  mixins: [cmp, mixinPickEvent],
	  methods: methods$7,
	  stubVNode: {
	    attrs: function attrs() {
	      return {
	        class: this.$options.name
	      };
	    }
	  },
	  created: function created() {
	    var _this2 = this;

	    defineProperties$1(this, {
	      primitive: {
	        enumerable: true,
	        get: function get() {
	          return _this2.cesiumObject;
	        }
	      },
	      primitives: {
	        enumerable: true,
	        get: function get() {
	          return _this2.$services && _this2.$services.primitives;
	        }
	      },
	      groundPrimitives: {
	        enumerable: true,
	        get: function get() {
	          return _this2.$services && _this2.$services.groundPrimitives;
	        }
	      }
	    });
	  }
	};

	var script$N = {
	  name: 'vc-primitive',
	  mixins: [vcMixin, modelMatrix, shadows, geometryInstances, appearance, show, interleave, releaseGeometryInstances, aaMixin, classificationType, debugShowBoundingVolume, debugShowShadowVolume, mixinPrimitive],
	  props: {
	    cull: {
	      type: Boolean,
	      default: true
	    }
	  }
	};

	/* script */
	var __vue_script__$N = script$N;
	/* template */

	/* style */

	var __vue_inject_styles__$N = undefined;
	/* scoped */

	var __vue_scope_id__$N = undefined;
	/* functional template */

	var __vue_is_functional_template__$N = undefined;
	/* component normalizer */

	function __vue_normalize__$N(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "Primitive.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var Primitive = __vue_normalize__$N({}, __vue_inject_styles__$N, __vue_script__$N, __vue_scope_id__$N, __vue_is_functional_template__$N);

	function plugin$N(Vue) {

	  if (plugin$N.installed) {
	    return;
	  }

	  plugin$N.installed = true;
	  Vue.component(Primitive.name, Primitive);
	}

	var Primitive$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$N,
		Primitive: Primitive,
		install: plugin$N
	});

	var script$O = {
	  name: 'vc-primitive-classification',
	  mixins: [vcMixin, geometryInstances, appearance, show, interleave, releaseGeometryInstances, aaMixin, classificationType, debugShowBoundingVolume, debugShowShadowVolume, mixinPrimitive]
	};

	/* script */
	var __vue_script__$O = script$O;
	/* template */

	/* style */

	var __vue_inject_styles__$O = undefined;
	/* scoped */

	var __vue_scope_id__$O = undefined;
	/* functional template */

	var __vue_is_functional_template__$O = undefined;
	/* component normalizer */

	function __vue_normalize__$O(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "ClassificationPrimitive.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var ClassificationPrimitive = __vue_normalize__$O({}, __vue_inject_styles__$O, __vue_script__$O, __vue_scope_id__$O, __vue_is_functional_template__$O);

	function plugin$O(Vue) {

	  if (plugin$O.installed) {
	    return;
	  }

	  plugin$O.installed = true;
	  Vue.component(ClassificationPrimitive.name, ClassificationPrimitive);
	}

	var ClassificationPrimitive$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$O,
		ClassificationPrimitive: ClassificationPrimitive,
		install: plugin$O
	});

	var script$P = {
	  name: 'vc-primitive-ground',
	  mixins: [vcMixin, geometryInstances, appearance, show, interleave, releaseGeometryInstances, aaMixin, classificationType, debugShowBoundingVolume, debugShowShadowVolume, mixinPrimitive],
	  methods: {
	    createCesiumObject: function createCesiumObject() {
	      var $props, transformProps, options;
	      return regenerator.async(function createCesiumObject$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              $props = this.$props, transformProps = this.transformProps;
	              options = transformProps($props);

	              if (options.asynchronous) {
	                _context.next = 5;
	                break;
	              }

	              _context.next = 5;
	              return regenerator.awrap(Cesium.GroundPrimitive.initializeTerrainHeights());

	            case 5:
	              return _context.abrupt("return", new Cesium.GroundPrimitive(options));

	            case 6:
	            case "end":
	              return _context.stop();
	          }
	        }
	      }, null, this);
	    }
	  }
	};

	/* script */
	var __vue_script__$P = script$P;
	/* template */

	/* style */

	var __vue_inject_styles__$P = undefined;
	/* scoped */

	var __vue_scope_id__$P = undefined;
	/* functional template */

	var __vue_is_functional_template__$P = undefined;
	/* component normalizer */

	function __vue_normalize__$P(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "GroundPrimitive.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var GroundPrimitive = __vue_normalize__$P({}, __vue_inject_styles__$P, __vue_script__$P, __vue_scope_id__$P, __vue_is_functional_template__$P);

	function plugin$P(Vue) {

	  if (plugin$P.installed) {
	    return;
	  }

	  plugin$P.installed = true;
	  Vue.component(GroundPrimitive.name, GroundPrimitive);
	}

	var GroundPrimitive$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$P,
		GroundPrimitive: GroundPrimitive,
		install: plugin$P
	});

	var script$Q = {
	  name: 'vc-primitive-polyline-ground',
	  mixins: [geometryInstances, appearance, show, interleave, releaseGeometryInstances, aaMixin, classificationType, debugShowBoundingVolume, debugShowShadowVolume, mixinPrimitive],
	  methods: {
	    createCesiumObject: function createCesiumObject() {
	      var $props, transformProps, options;
	      return regenerator.async(function createCesiumObject$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              $props = this.$props, transformProps = this.transformProps;
	              options = transformProps($props);

	              if (options.asynchronous) {
	                _context.next = 5;
	                break;
	              }

	              _context.next = 5;
	              return regenerator.awrap(Cesium.GroundPolylinePrimitive.initializeTerrainHeights());

	            case 5:
	              return _context.abrupt("return", new Cesium.GroundPolylinePrimitive(options));

	            case 6:
	            case "end":
	              return _context.stop();
	          }
	        }
	      }, null, this);
	    }
	  }
	};

	/* script */
	var __vue_script__$Q = script$Q;
	/* template */

	/* style */

	var __vue_inject_styles__$Q = undefined;
	/* scoped */

	var __vue_scope_id__$Q = undefined;
	/* functional template */

	var __vue_is_functional_template__$Q = undefined;
	/* component normalizer */

	function __vue_normalize__$Q(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "GroundPolylinePrimitive.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var GroundPolylinePrimitive = __vue_normalize__$Q({}, __vue_inject_styles__$Q, __vue_script__$Q, __vue_scope_id__$Q, __vue_is_functional_template__$Q);

	function plugin$Q(Vue) {

	  if (plugin$Q.installed) {
	    return;
	  }

	  plugin$Q.installed = true;
	  Vue.component(GroundPolylinePrimitive.name, GroundPolylinePrimitive);
	}

	var GroundPolylinePrimitive$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$Q,
		GroundPolylinePrimitive: GroundPolylinePrimitive,
		install: plugin$Q
	});

	var methods$8 = {
	  /**
	   * 重写 createCesiumObject 方法。
	   */
	  createCesiumObject: function createCesiumObject() {
	    var $props, transformProps, primitives, options;
	    return regenerator.async(function createCesiumObject$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            $props = this.$props, transformProps = this.transformProps, primitives = this.primitives;
	            options = transformProps($props);
	            return _context.abrupt("return", primitives && primitives.add(options));

	          case 3:
	          case "end":
	            return _context.stop();
	        }
	      }
	    }, null, this);
	  },
	  mount: function mount() {
	    var primitives, primitive, registerEvents;
	    return regenerator.async(function mount$(_context2) {
	      while (1) {
	        switch (_context2.prev = _context2.next) {
	          case 0:
	            primitives = this.primitives, primitive = this.primitive, registerEvents = this.registerEvents;
	            registerEvents(true);
	            return _context2.abrupt("return", primitives && primitives.contains(primitive));

	          case 3:
	          case "end":
	            return _context2.stop();
	        }
	      }
	    }, null, this);
	  },
	  unmount: function unmount() {
	    var primitives, primitive, registerEvents;
	    return regenerator.async(function unmount$(_context3) {
	      while (1) {
	        switch (_context3.prev = _context3.next) {
	          case 0:
	            primitives = this.primitives, primitive = this.primitive, registerEvents = this.registerEvents;
	            registerEvents(false);
	            return _context3.abrupt("return", primitives && !primitives.isDestroyed() && primitives.remove(primitive));

	          case 3:
	          case "end":
	            return _context3.stop();
	        }
	      }
	    }, null, this);
	  }
	};
	var mixinPrimitiveCollectionItem = {
	  props: {
	    enbaleEvent: {
	      type: Boolean,
	      default: true
	    }
	  },
	  mixins: [cmp, mixinPickEvent],
	  methods: methods$8,
	  stubVNode: {
	    empty: function empty() {
	      return this.$options.name;
	    }
	  },
	  created: function created() {
	    var _this = this;

	    this.index = 0;

	    defineProperties$1(this, {
	      primitive: {
	        enumerable: true,
	        get: function get() {
	          return _this.cesiumObject;
	        }
	      },
	      primitives: {
	        enumerable: true,
	        get: function get() {
	          return _this.$services && _this.$services.primitives;
	        }
	      }
	    });
	  }
	};

	var script$R = {
	  name: 'vc-primitive-billboard',
	  mixins: [id$1, position, mixinBillboard, mixinPrimitiveCollectionItem]
	};

	/* script */
	var __vue_script__$R = script$R;
	/* template */

	/* style */

	var __vue_inject_styles__$R = undefined;
	/* scoped */

	var __vue_scope_id__$R = undefined;
	/* functional template */

	var __vue_is_functional_template__$R = undefined;
	/* component normalizer */

	function __vue_normalize__$R(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "Billboard.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var Billboard = __vue_normalize__$R({}, __vue_inject_styles__$R, __vue_script__$R, __vue_scope_id__$R, __vue_is_functional_template__$R);

	function plugin$R(Vue) {

	  if (plugin$R.installed) {
	    return;
	  }

	  plugin$R.installed = true;
	  Vue.component(Billboard.name, Billboard);
	}

	var Billboard$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$R,
		Billboard: Billboard,
		install: plugin$R
	});

	var script$S = {
	  name: 'vc-primitive-label',
	  mixins: [id$1, position, mixinLabel, mixinPrimitiveCollectionItem],
	  props: {
	    totalScale: Number
	  }
	};

	/* script */
	var __vue_script__$S = script$S;
	/* template */

	/* style */

	var __vue_inject_styles__$S = undefined;
	/* scoped */

	var __vue_scope_id__$S = undefined;
	/* functional template */

	var __vue_is_functional_template__$S = undefined;
	/* component normalizer */

	function __vue_normalize__$S(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "Label.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var Label = __vue_normalize__$S({}, __vue_inject_styles__$S, __vue_script__$S, __vue_scope_id__$S, __vue_is_functional_template__$S);

	function plugin$S(Vue) {

	  if (plugin$S.installed) {
	    return;
	  }

	  plugin$S.installed = true;
	  Vue.component(Label.name, Label);
	}

	var Label$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$S,
		Label: Label,
		install: plugin$S
	});

	var script$T = {
	  name: 'vc-primitive-point',
	  mixins: [id$1, position, mixinPoint, mixinPrimitiveCollectionItem]
	};

	/* script */
	var __vue_script__$T = script$T;
	/* template */

	/* style */

	var __vue_inject_styles__$T = undefined;
	/* scoped */

	var __vue_scope_id__$T = undefined;
	/* functional template */

	var __vue_is_functional_template__$T = undefined;
	/* component normalizer */

	function __vue_normalize__$T(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "PointPrimitive.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var PointPrimitive = __vue_normalize__$T({}, __vue_inject_styles__$T, __vue_script__$T, __vue_scope_id__$T, __vue_is_functional_template__$T);

	function plugin$T(Vue) {

	  if (plugin$T.installed) {
	    return;
	  }

	  plugin$T.installed = true;
	  Vue.component(PointPrimitive.name, PointPrimitive);
	}

	var PointPrimitive$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$T,
		PointPrimitive: PointPrimitive,
		install: plugin$T
	});

	var script$U = {
	  name: 'vc-primitive-polyline',
	  mixins: [loop, id$1, mixinPolyline, mixinPrimitiveCollectionItem]
	};

	/* script */
	var __vue_script__$U = script$U;
	/* template */

	/* style */

	var __vue_inject_styles__$U = undefined;
	/* scoped */

	var __vue_scope_id__$U = undefined;
	/* functional template */

	var __vue_is_functional_template__$U = undefined;
	/* component normalizer */

	function __vue_normalize__$U(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "Polyline.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var Polyline = __vue_normalize__$U({}, __vue_inject_styles__$U, __vue_script__$U, __vue_scope_id__$U, __vue_is_functional_template__$U);

	function plugin$U(Vue) {

	  if (plugin$U.installed) {
	    return;
	  }

	  plugin$U.installed = true;
	  Vue.component(Polyline.name, Polyline);
	}

	var Polyline$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$U,
		Polyline: Polyline,
		install: plugin$U
	});

	var script$V = {
	  name: 'vc-primitive-model',
	  mixins: [modelMatrix, id$1, aaMixin, debugShowBoundingVolume, scene, debugWireframe, lightColor2, imageBasedLightingFactor, luminanceAtZenith, sphericalHarmonicCoefficients, specularEnvironmentMaps, backFaceCulling, mixinModel, mixinPrimitive],
	  props: {
	    url: String,
	    basePath: String,
	    dequantizeInShader: {
	      type: Boolean,
	      default: true
	    }
	  },
	  methods: {
	    /**
	     *  重写 createCesiumObject 方法
	     */
	    createCesiumObject: function createCesiumObject() {
	      var $props, transformProps, options;
	      return regenerator.async(function createCesiumObject$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              $props = this.$props, transformProps = this.transformProps;
	              options = transformProps($props);
	              return _context.abrupt("return", Cesium.Model.fromGltf(options));

	            case 3:
	            case "end":
	              return _context.stop();
	          }
	        }
	      }, null, this);
	    }
	  }
	};

	/* script */
	var __vue_script__$V = script$V;
	/* template */

	/* style */

	var __vue_inject_styles__$V = undefined;
	/* scoped */

	var __vue_scope_id__$V = undefined;
	/* functional template */

	var __vue_is_functional_template__$V = undefined;
	/* component normalizer */

	function __vue_normalize__$V(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "Model.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var Model = __vue_normalize__$V({}, __vue_inject_styles__$V, __vue_script__$V, __vue_scope_id__$V, __vue_is_functional_template__$V);

	function plugin$V(Vue) {

	  if (plugin$V.installed) {
	    return;
	  }

	  plugin$V.installed = true;
	  Vue.component(Model.name, Model);
	}

	var Model$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$V,
		Model: Model,
		install: plugin$V
	});

	var script$W = {
	  name: 'vc-primitive-tileset',
	  mixins: [show, modelMatrix, shadows, clippingPlanes, debugShowBoundingVolume, debugWireframe, imageBasedLightingFactor, url, classificationType, ellipsoid, lightColor2, luminanceAtZenith, sphericalHarmonicCoefficients, specularEnvironmentMaps, backFaceCulling, mixinPrimitive],
	  props: {
	    maximumScreenSpaceError: {
	      type: Number,
	      default: 16
	    },
	    maximumMemoryUsage: {
	      type: Number,
	      default: 512
	    },
	    cullWithChildrenBounds: {
	      type: Boolean,
	      default: true
	    },
	    cullRequestsWhileMoving: {
	      type: Boolean,
	      default: true
	    },
	    cullRequestsWhileMovingMultiplier: {
	      type: Number,
	      default: 60.0
	    },
	    preloadWhenHidden: {
	      type: Boolean,
	      default: false
	    },
	    preloadFlightDestinations: {
	      type: Boolean,
	      default: true
	    },
	    preferLeaves: {
	      type: Boolean,
	      default: false
	    },
	    dynamicScreenSpaceError: {
	      type: Boolean,
	      default: false
	    },
	    dynamicScreenSpaceErrorDensity: {
	      type: Number,
	      default: 0.00278
	    },
	    dynamicScreenSpaceErrorFactor: {
	      type: Number,
	      default: 4.0
	    },
	    dynamicScreenSpaceErrorHeightFalloff: {
	      type: Number,
	      default: 0.25
	    },
	    progressiveResolutionHeightFraction: {
	      type: Number,
	      default: 0.3
	    },
	    foveatedScreenSpaceError: {
	      type: Boolean,
	      default: true
	    },
	    foveatedConeSize: {
	      type: Number,
	      default: 0.1
	    },
	    foveatedMinimumScreenSpaceErrorRelaxation: {
	      type: Number,
	      default: 0.0
	    },
	    foveatedInterpolationCallback: Function,
	    foveatedTimeDelay: {
	      type: Number,
	      default: 0.2
	    },
	    skipLevelOfDetail: {
	      type: Boolean,
	      default: true
	    },
	    baseScreenSpaceError: {
	      type: Number,
	      default: 1024
	    },
	    skipScreenSpaceErrorFactor: {
	      type: Number,
	      default: 16
	    },
	    skipLevels: {
	      type: Number,
	      default: 1
	    },
	    immediatelyLoadDesiredLevelOfDetail: {
	      type: Boolean,
	      default: false
	    },
	    loadSiblings: {
	      type: Boolean,
	      default: false
	    },
	    pointCloudShading: Object,
	    debugHeatmapTilePropertyName: String,
	    debugFreezeFrame: {
	      type: Boolean,
	      default: false
	    },
	    debugColorizeTiles: {
	      type: Boolean,
	      default: false
	    },
	    debugShowContentBoundingVolume: {
	      type: Boolean,
	      default: false
	    },
	    debugShowViewerRequestVolume: {
	      type: Boolean,
	      default: false
	    },
	    debugShowGeometricError: {
	      type: Boolean,
	      default: false
	    },
	    debugShowRenderingStatistics: {
	      type: Boolean,
	      default: false
	    },
	    debugShowMemoryUsage: {
	      type: Boolean,
	      default: false
	    },
	    debugShowUrl: {
	      type: Boolean,
	      default: false
	    }
	  }
	};

	/* script */
	var __vue_script__$W = script$W;
	/* template */

	/* style */

	var __vue_inject_styles__$W = undefined;
	/* scoped */

	var __vue_scope_id__$W = undefined;
	/* functional template */

	var __vue_is_functional_template__$W = undefined;
	/* component normalizer */

	function __vue_normalize__$W(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "Cesium3DTileset.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var Cesium3DTileset = __vue_normalize__$W({}, __vue_inject_styles__$W, __vue_script__$W, __vue_scope_id__$W, __vue_is_functional_template__$W);

	function plugin$W(Vue) {

	  if (plugin$W.installed) {
	    return;
	  }

	  plugin$W.installed = true;
	  Vue.component(Cesium3DTileset.name, Cesium3DTileset);
	}

	var Cesium3DTileset$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$W,
		Cesium3DTileset: Cesium3DTileset,
		install: plugin$W
	});

	var script$X = {
	  name: 'vc-primitive-particle',
	  mixins: [show, modelMatrix, image, color, startColor, endColor, imageSize, minimumImageSize, maximumImageSize, mixinPrimitive],
	  props: {
	    updateCallback: Function,
	    emitter: Object,
	    emitterModelMatrix: Object,
	    emissionRate: Number,
	    bursts: Array,
	    loop: {
	      type: Boolean,
	      default: true
	    },
	    scale: Number,
	    startScale: Number,
	    endScale: Number,
	    speed: Number,
	    minimumSpeed: Number,
	    maximumSpeed: Number,
	    lifetime: Number,
	    particleLife: Number,
	    minimumParticleLife: Number,
	    maximumParticleLife: Number,
	    mass: Number,
	    minimumMass: Number,
	    maximumMass: Number
	  }
	};

	/* script */
	var __vue_script__$X = script$X;
	/* template */

	/* style */

	var __vue_inject_styles__$X = undefined;
	/* scoped */

	var __vue_scope_id__$X = undefined;
	/* functional template */

	var __vue_is_functional_template__$X = undefined;
	/* component normalizer */

	function __vue_normalize__$X(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "ParticleSystem.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var ParticleSystem = __vue_normalize__$X({}, __vue_inject_styles__$X, __vue_script__$X, __vue_scope_id__$X, __vue_is_functional_template__$X);

	function plugin$X(Vue) {

	  if (plugin$X.installed) {
	    return;
	  }

	  plugin$X.installed = true;
	  Vue.component(ParticleSystem.name, ParticleSystem);
	}

	var ParticleSystem$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$X,
		ParticleSystem: ParticleSystem,
		install: plugin$X
	});

	var script$Y = {
	  name: 'vc-instance-geometry',
	  mixins: [cmp, modelMatrix, id$1],
	  props: {
	    geometry: Object,
	    attributes: Object
	  },
	  methods: {
	    /**
	     * 重写 createCesiumObject 方法，因为 GeometryInstance 构造参数中有一个必要参数 geometry，需要单独处理一下。
	     */
	    createCesiumObject: function createCesiumObject() {
	      var $props, transformProps, options;
	      return regenerator.async(function createCesiumObject$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              $props = this.$props, transformProps = this.transformProps;
	              options = transformProps($props);

	              if (!options.geometry) {
	                options.geometry = new Cesium.Geometry({
	                  attributes: new Cesium.GeometryAttributes()
	                });
	              }

	              return _context.abrupt("return", new Cesium.GeometryInstance(options));

	            case 4:
	            case "end":
	              return _context.stop();
	          }
	        }
	      }, null, this);
	    },
	    mount: function mount() {
	      var geometryInstance, primitiveContainer;
	      return regenerator.async(function mount$(_context2) {
	        while (1) {
	          switch (_context2.prev = _context2.next) {
	            case 0:
	              this.index = this.$parent.childCount;
	              this.$parent.childCount += 1;
	              geometryInstance = this.geometryInstance, primitiveContainer = this.primitiveContainer;
	              primitiveContainer && primitiveContainer.setGeometryInstances(geometryInstance, this.index);
	              return _context2.abrupt("return", true);

	            case 5:
	            case "end":
	              return _context2.stop();
	          }
	        }
	      }, null, this);
	    },
	    setGeometry: function setGeometry(geometry) {
	      var listener;
	      return regenerator.async(function setGeometry$(_context3) {
	        while (1) {
	          switch (_context3.prev = _context3.next) {
	            case 0:
	              listener = this.$listeners['update:geometry'];

	              if (listener) {
	                this.$emit('update:geometry', geometry);
	              } else this.geometryInstance.geometry = geometry;

	              return _context3.abrupt("return", true);

	            case 3:
	            case "end":
	              return _context3.stop();
	          }
	        }
	      }, null, this);
	    },
	    getServices: function getServices() {
	      var vm = this;
	      return multiMergeDescriptors(cmp.methods.getServices.call(this), {
	        get geometryInstance() {
	          return vm.geometryInstance;
	        },

	        get geometryContainer() {
	          return vm;
	        }

	      });
	    }
	  },
	  stubVNode: {
	    attrs: function attrs() {
	      return {
	        class: this.$options.name
	      };
	    }
	  },
	  created: function created() {
	    var _this = this;

	    this.renderByParent = true;

	    defineProperties$1(this, {
	      geometryInstance: {
	        enumerable: true,
	        get: function get() {
	          return _this.cesiumObject;
	        }
	      },
	      primitiveContainer: {
	        enumerable: true,
	        get: function get() {
	          return _this.$services && _this.$services.primitiveContainer;
	        }
	      }
	    });
	  }
	};

	/* script */
	var __vue_script__$Y = script$Y;
	/* template */

	/* style */

	var __vue_inject_styles__$Y = undefined;
	/* scoped */

	var __vue_scope_id__$Y = undefined;
	/* functional template */

	var __vue_is_functional_template__$Y = undefined;
	/* component normalizer */

	function __vue_normalize__$Y(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "GeometryInstance.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var GeometryInstance = __vue_normalize__$Y({}, __vue_inject_styles__$Y, __vue_script__$Y, __vue_scope_id__$Y, __vue_is_functional_template__$Y);

	function plugin$Y(Vue) {

	  if (plugin$Y.installed) {
	    return;
	  }

	  plugin$Y.installed = true;
	  Vue.component(GeometryInstance.name, GeometryInstance);
	}

	var GeometryInstance$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$Y,
		GeometryInstance: GeometryInstance,
		install: plugin$Y
	});

	var methods$9 = {
	  mount: function mount() {
	    var geometry, geometryContainer;
	    return regenerator.async(function mount$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            geometry = this.geometry, geometryContainer = this.geometryContainer;
	            return _context.abrupt("return", geometryContainer.setGeometry(geometry));

	          case 2:
	          case "end":
	            return _context.stop();
	        }
	      }
	    }, null, this);
	  }
	};
	var mixinGeometry = {
	  mixins: [cmp],
	  methods: methods$9,
	  stubVNode: {
	    empty: function empty() {
	      return this.$options.name;
	    }
	  },
	  created: function created() {
	    var _this = this;

	    this.renderByParent = true;

	    defineProperties$1(this, {
	      geometry: {
	        enumerable: true,
	        get: function get() {
	          return _this.cesiumObject;
	        }
	      },
	      geometryContainer: {
	        enumerable: true,
	        get: function get() {
	          return _this.$services && _this.$services.geometryContainer;
	        }
	      }
	    });
	  }
	};

	var script$Z = {
	  name: 'vc-geometry-box',
	  mixins: [dimensions, vertexFormat, mixinGeometry],
	  methods: {
	    /**
	     *  重写 createCesiumObject 方法。
	     */
	    createCesiumObject: function createCesiumObject() {
	      var $props, transformProps, options;
	      return regenerator.async(function createCesiumObject$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              $props = this.$props, transformProps = this.transformProps;
	              options = transformProps($props);
	              return _context.abrupt("return", Cesium.BoxGeometry.fromDimensions(options));

	            case 3:
	            case "end":
	              return _context.stop();
	          }
	        }
	      }, null, this);
	    }
	  }
	};

	/* script */
	var __vue_script__$Z = script$Z;
	/* template */

	/* style */

	var __vue_inject_styles__$Z = undefined;
	/* scoped */

	var __vue_scope_id__$Z = undefined;
	/* functional template */

	var __vue_is_functional_template__$Z = undefined;
	/* component normalizer */

	function __vue_normalize__$Z(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "BoxGeometry.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var BoxGeometry = __vue_normalize__$Z({}, __vue_inject_styles__$Z, __vue_script__$Z, __vue_scope_id__$Z, __vue_is_functional_template__$Z);

	function plugin$Z(Vue) {

	  if (plugin$Z.installed) {
	    return;
	  }

	  plugin$Z.installed = true;
	  Vue.component(BoxGeometry.name, BoxGeometry);
	}

	var BoxGeometry$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$Z,
		BoxGeometry: BoxGeometry,
		install: plugin$Z
	});

	var script$_ = {
	  name: 'vc-geometry-outline-box',
	  mixins: [dimensions, mixinGeometry],
	  methods: {
	    /**
	     *  重写 createCesiumObject 方法。
	     */
	    createCesiumObject: function createCesiumObject() {
	      var $props, transformProps, options;
	      return regenerator.async(function createCesiumObject$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              $props = this.$props, transformProps = this.transformProps;
	              options = transformProps($props);
	              return _context.abrupt("return", Cesium.BoxOutlineGeometry.fromDimensions(options));

	            case 3:
	            case "end":
	              return _context.stop();
	          }
	        }
	      }, null, this);
	    }
	  }
	};

	/* script */
	var __vue_script__$_ = script$_;
	/* template */

	/* style */

	var __vue_inject_styles__$_ = undefined;
	/* scoped */

	var __vue_scope_id__$_ = undefined;
	/* functional template */

	var __vue_is_functional_template__$_ = undefined;
	/* component normalizer */

	function __vue_normalize__$_(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "BoxOutlineGeometry.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var BoxOutlineGeometry = __vue_normalize__$_({}, __vue_inject_styles__$_, __vue_script__$_, __vue_scope_id__$_, __vue_is_functional_template__$_);

	function plugin$_(Vue) {

	  if (plugin$_.installed) {
	    return;
	  }

	  plugin$_.installed = true;
	  Vue.component(BoxOutlineGeometry.name, BoxOutlineGeometry);
	}

	var BoxOutlineGeometry$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$_,
		BoxOutlineGeometry: BoxOutlineGeometry,
		install: plugin$_
	});

	var script$$ = {
	  name: 'vc-geometry-circle',
	  mixins: [center, radius, ellipsoid, height, granularity, vertexFormat, extrudedHeight, stRotation, mixinGeometry]
	};

	/* script */
	var __vue_script__$$ = script$$;
	/* template */

	/* style */

	var __vue_inject_styles__$$ = undefined;
	/* scoped */

	var __vue_scope_id__$$ = undefined;
	/* functional template */

	var __vue_is_functional_template__$$ = undefined;
	/* component normalizer */

	function __vue_normalize__$$(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "CircleGeometry.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var CircleGeometry = __vue_normalize__$$({}, __vue_inject_styles__$$, __vue_script__$$, __vue_scope_id__$$, __vue_is_functional_template__$$);

	function plugin$$(Vue) {

	  if (plugin$$.installed) {
	    return;
	  }

	  plugin$$.installed = true;
	  Vue.component(CircleGeometry.name, CircleGeometry);
	}

	var CircleGeometry$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$$,
		CircleGeometry: CircleGeometry,
		install: plugin$$
	});

	var script$10 = {
	  name: 'vc-geometry-outline-circle',
	  mixins: [center, radius, ellipsoid, height, granularity, extrudedHeight, numberOfVerticalLines, mixinGeometry]
	};

	/* script */
	var __vue_script__$10 = script$10;
	/* template */

	/* style */

	var __vue_inject_styles__$10 = undefined;
	/* scoped */

	var __vue_scope_id__$10 = undefined;
	/* functional template */

	var __vue_is_functional_template__$10 = undefined;
	/* component normalizer */

	function __vue_normalize__$10(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "CircleOutlineGeometry.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var CircleOutlineGeometry = __vue_normalize__$10({}, __vue_inject_styles__$10, __vue_script__$10, __vue_scope_id__$10, __vue_is_functional_template__$10);

	function plugin$10(Vue) {

	  if (plugin$10.installed) {
	    return;
	  }

	  plugin$10.installed = true;
	  Vue.component(CircleOutlineGeometry.name, CircleOutlineGeometry);
	}

	var CircleOutlineGeometry$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$10,
		CircleOutlineGeometry: CircleOutlineGeometry,
		install: plugin$10
	});

	var script$11 = {
	  name: 'vc-geometry-polygon-coplanar',
	  mixins: [positions, stRotation, vertexFormat, ellipsoid, mixinGeometry],
	  methods: {
	    createCesiumObject: function createCesiumObject() {
	      var $props, transformProps, options;
	      return regenerator.async(function createCesiumObject$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              $props = this.$props, transformProps = this.transformProps;
	              options = transformProps($props);
	              return _context.abrupt("return", Cesium.CoplanarPolygonGeometry.fromPositions(options));

	            case 3:
	            case "end":
	              return _context.stop();
	          }
	        }
	      }, null, this);
	    }
	  }
	};

	/* script */
	var __vue_script__$11 = script$11;
	/* template */

	/* style */

	var __vue_inject_styles__$11 = undefined;
	/* scoped */

	var __vue_scope_id__$11 = undefined;
	/* functional template */

	var __vue_is_functional_template__$11 = undefined;
	/* component normalizer */

	function __vue_normalize__$11(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "CoplanarPolygonGeometry.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var CoplanarPolygonGeometry = __vue_normalize__$11({}, __vue_inject_styles__$11, __vue_script__$11, __vue_scope_id__$11, __vue_is_functional_template__$11);

	function plugin$11(Vue) {

	  if (plugin$11.installed) {
	    return;
	  }

	  plugin$11.installed = true;
	  Vue.component(CoplanarPolygonGeometry.name, CoplanarPolygonGeometry);
	}

	var CoplanarPolygonGeometry$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$11,
		CoplanarPolygonGeometry: CoplanarPolygonGeometry,
		install: plugin$11
	});

	var script$12 = {
	  name: 'vc-geometry-outline-polygon-coplanar',
	  mixins: [positions, mixinGeometry],
	  methods: {
	    createCesiumObject: function createCesiumObject() {
	      var $props, transformProps, options;
	      return regenerator.async(function createCesiumObject$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              $props = this.$props, transformProps = this.transformProps;
	              options = transformProps($props);
	              return _context.abrupt("return", Cesium.CoplanarPolygonOutlineGeometry.fromPositions(options));

	            case 3:
	            case "end":
	              return _context.stop();
	          }
	        }
	      }, null, this);
	    }
	  }
	};

	/* script */
	var __vue_script__$12 = script$12;
	/* template */

	/* style */

	var __vue_inject_styles__$12 = undefined;
	/* scoped */

	var __vue_scope_id__$12 = undefined;
	/* functional template */

	var __vue_is_functional_template__$12 = undefined;
	/* component normalizer */

	function __vue_normalize__$12(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "CoplanarPolygonOutlineGeometry.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var CoplanarPolygonOutlineGeometry = __vue_normalize__$12({}, __vue_inject_styles__$12, __vue_script__$12, __vue_scope_id__$12, __vue_is_functional_template__$12);

	function plugin$12(Vue) {

	  if (plugin$12.installed) {
	    return;
	  }

	  plugin$12.installed = true;
	  Vue.component(CoplanarPolygonOutlineGeometry.name, CoplanarPolygonOutlineGeometry);
	}

	var CoplanarPolygonOutlineGeometry$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$12,
		CoplanarPolygonOutlineGeometry: CoplanarPolygonOutlineGeometry,
		install: plugin$12
	});

	var script$13 = {
	  name: 'vc-geometry-corridor',
	  mixins: [ellipsoid, vertexFormat, mixinCorridor, mixinGeometry]
	};

	/* script */
	var __vue_script__$13 = script$13;
	/* template */

	/* style */

	var __vue_inject_styles__$13 = undefined;
	/* scoped */

	var __vue_scope_id__$13 = undefined;
	/* functional template */

	var __vue_is_functional_template__$13 = undefined;
	/* component normalizer */

	function __vue_normalize__$13(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "CorridorGeometry.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var CorridorGeometry = __vue_normalize__$13({}, __vue_inject_styles__$13, __vue_script__$13, __vue_scope_id__$13, __vue_is_functional_template__$13);

	function plugin$13(Vue) {

	  if (plugin$13.installed) {
	    return;
	  }

	  plugin$13.installed = true;
	  Vue.component(CorridorGeometry.name, CorridorGeometry);
	}

	var CorridorGeometry$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$13,
		CorridorGeometry: CorridorGeometry,
		install: plugin$13
	});

	var script$14 = {
	  name: 'vc-geometry-outline-corridor',
	  mixins: [ellipsoid, mixinCorridor, mixinGeometry]
	};

	/* script */
	var __vue_script__$14 = script$14;
	/* template */

	/* style */

	var __vue_inject_styles__$14 = undefined;
	/* scoped */

	var __vue_scope_id__$14 = undefined;
	/* functional template */

	var __vue_is_functional_template__$14 = undefined;
	/* component normalizer */

	function __vue_normalize__$14(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "CorridorOutlineGeometry.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var CorridorOutlineGeometry = __vue_normalize__$14({}, __vue_inject_styles__$14, __vue_script__$14, __vue_scope_id__$14, __vue_is_functional_template__$14);

	function plugin$14(Vue) {

	  if (plugin$14.installed) {
	    return;
	  }

	  plugin$14.installed = true;
	  Vue.component(CorridorOutlineGeometry.name, CorridorOutlineGeometry);
	}

	var CorridorOutlineGeometry$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$14,
		CorridorOutlineGeometry: CorridorOutlineGeometry,
		install: plugin$14
	});

	var script$15 = {
	  name: 'vc-geometry-cylinder',
	  mixins: [vertexFormat, mixinCylinder, mixinGeometry]
	};

	/* script */
	var __vue_script__$15 = script$15;
	/* template */

	/* style */

	var __vue_inject_styles__$15 = undefined;
	/* scoped */

	var __vue_scope_id__$15 = undefined;
	/* functional template */

	var __vue_is_functional_template__$15 = undefined;
	/* component normalizer */

	function __vue_normalize__$15(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "CylinderGeometry.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var CylinderGeometry = __vue_normalize__$15({}, __vue_inject_styles__$15, __vue_script__$15, __vue_scope_id__$15, __vue_is_functional_template__$15);

	function plugin$15(Vue) {

	  if (plugin$15.installed) {
	    return;
	  }

	  plugin$15.installed = true;
	  Vue.component(CylinderGeometry.name, CylinderGeometry);
	}

	var CylinderGeometry$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$15,
		CylinderGeometry: CylinderGeometry,
		install: plugin$15
	});

	var script$16 = {
	  name: 'vc-geometry-outline-cylinder',
	  mixins: [numberOfVerticalLines, mixinCylinder, mixinGeometry]
	};

	/* script */
	var __vue_script__$16 = script$16;
	/* template */

	/* style */

	var __vue_inject_styles__$16 = undefined;
	/* scoped */

	var __vue_scope_id__$16 = undefined;
	/* functional template */

	var __vue_is_functional_template__$16 = undefined;
	/* component normalizer */

	function __vue_normalize__$16(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "CylinderOutlineGeometry.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var CylinderOutlineGeometry = __vue_normalize__$16({}, __vue_inject_styles__$16, __vue_script__$16, __vue_scope_id__$16, __vue_is_functional_template__$16);

	function plugin$16(Vue) {

	  if (plugin$16.installed) {
	    return;
	  }

	  plugin$16.installed = true;
	  Vue.component(CylinderOutlineGeometry.name, CylinderOutlineGeometry);
	}

	var CylinderOutlineGeometry$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$16,
		CylinderOutlineGeometry: CylinderOutlineGeometry,
		install: plugin$16
	});

	var script$17 = {
	  name: 'vc-geometry-ellipse',
	  mixins: [center, ellipsoid, stRotation, vertexFormat, mixinEllipse, mixinGeometry]
	};

	/* script */
	var __vue_script__$17 = script$17;
	/* template */

	/* style */

	var __vue_inject_styles__$17 = undefined;
	/* scoped */

	var __vue_scope_id__$17 = undefined;
	/* functional template */

	var __vue_is_functional_template__$17 = undefined;
	/* component normalizer */

	function __vue_normalize__$17(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "EllipseGeometry.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var EllipseGeometry = __vue_normalize__$17({}, __vue_inject_styles__$17, __vue_script__$17, __vue_scope_id__$17, __vue_is_functional_template__$17);

	function plugin$17(Vue) {

	  if (plugin$17.installed) {
	    return;
	  }

	  plugin$17.installed = true;
	  Vue.component(EllipseGeometry.name, EllipseGeometry);
	}

	var EllipseGeometry$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$17,
		EllipseGeometry: EllipseGeometry,
		install: plugin$17
	});

	var script$18 = {
	  name: 'vc-geometry-outline-ellipse',
	  mixins: [center, ellipsoid, numberOfVerticalLines, mixinEllipse, mixinGeometry]
	};

	/* script */
	var __vue_script__$18 = script$18;
	/* template */

	/* style */

	var __vue_inject_styles__$18 = undefined;
	/* scoped */

	var __vue_scope_id__$18 = undefined;
	/* functional template */

	var __vue_is_functional_template__$18 = undefined;
	/* component normalizer */

	function __vue_normalize__$18(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "EllipseOutlineGeometry.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var EllipseOutlineGeometry = __vue_normalize__$18({}, __vue_inject_styles__$18, __vue_script__$18, __vue_scope_id__$18, __vue_is_functional_template__$18);

	function plugin$18(Vue) {

	  if (plugin$18.installed) {
	    return;
	  }

	  plugin$18.installed = true;
	  Vue.component(EllipseOutlineGeometry.name, EllipseOutlineGeometry);
	}

	var EllipseOutlineGeometry$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$18,
		EllipseOutlineGeometry: EllipseOutlineGeometry,
		install: plugin$18
	});

	var script$19 = {
	  name: 'vc-geometry-ellipsoid',
	  mixins: [innerRadii, minimumClock, maximumClock, minimumCone, maximumCone, vertexFormat, mixinEllipsoid, mixinGeometry]
	};

	/* script */
	var __vue_script__$19 = script$19;
	/* template */

	/* style */

	var __vue_inject_styles__$19 = undefined;
	/* scoped */

	var __vue_scope_id__$19 = undefined;
	/* functional template */

	var __vue_is_functional_template__$19 = undefined;
	/* component normalizer */

	function __vue_normalize__$19(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "EllipsoidGeometry.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var EllipsoidGeometry = __vue_normalize__$19({}, __vue_inject_styles__$19, __vue_script__$19, __vue_scope_id__$19, __vue_is_functional_template__$19);

	function plugin$19(Vue) {

	  if (plugin$19.installed) {
	    return;
	  }

	  plugin$19.installed = true;
	  Vue.component(EllipsoidGeometry.name, EllipsoidGeometry);
	}

	var EllipsoidGeometry$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$19,
		EllipsoidGeometry: EllipsoidGeometry,
		install: plugin$19
	});

	var script$1a = {
	  name: 'vc-geometry-outline-ellipsoid',
	  mixins: [innerRadii, minimumClock, maximumClock, minimumCone, maximumCone, subdivisions, mixinEllipsoid, mixinGeometry],
	  props: {
	    stackPartitions: {
	      type: Number,
	      default: 10
	    },
	    slicePartitions: {
	      type: Number,
	      default: 8
	    }
	  }
	};

	/* script */
	var __vue_script__$1a = script$1a;
	/* template */

	/* style */

	var __vue_inject_styles__$1a = undefined;
	/* scoped */

	var __vue_scope_id__$1a = undefined;
	/* functional template */

	var __vue_is_functional_template__$1a = undefined;
	/* component normalizer */

	function __vue_normalize__$1a(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "EllipsoidOutlineGeometry.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var EllipsoidOutlineGeometry = __vue_normalize__$1a({}, __vue_inject_styles__$1a, __vue_script__$1a, __vue_scope_id__$1a, __vue_is_functional_template__$1a);

	function plugin$1a(Vue) {

	  if (plugin$1a.installed) {
	    return;
	  }

	  plugin$1a.installed = true;
	  Vue.component(EllipsoidOutlineGeometry.name, EllipsoidOutlineGeometry);
	}

	var EllipsoidOutlineGeometry$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$1a,
		EllipsoidOutlineGeometry: EllipsoidOutlineGeometry,
		install: plugin$1a
	});

	var script$1b = {
	  name: 'vc-geometry-frustum',
	  mixins: [frustum, origin, orientation$1, vertexFormat, mixinGeometry]
	};

	/* script */
	var __vue_script__$1b = script$1b;
	/* template */

	/* style */

	var __vue_inject_styles__$1b = undefined;
	/* scoped */

	var __vue_scope_id__$1b = undefined;
	/* functional template */

	var __vue_is_functional_template__$1b = undefined;
	/* component normalizer */

	function __vue_normalize__$1b(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "FrustumGeometry.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var FrustumGeometry = __vue_normalize__$1b({}, __vue_inject_styles__$1b, __vue_script__$1b, __vue_scope_id__$1b, __vue_is_functional_template__$1b);

	function plugin$1b(Vue) {

	  if (plugin$1b.installed) {
	    return;
	  }

	  plugin$1b.installed = true;
	  Vue.component(FrustumGeometry.name, FrustumGeometry);
	}

	var FrustumGeometry$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$1b,
		FrustumGeometry: FrustumGeometry,
		install: plugin$1b
	});

	var script$1c = {
	  name: 'vc-geometry-outline-frustum',
	  mixins: [frustum, origin, orientation$1, mixinGeometry]
	};

	/* script */
	var __vue_script__$1c = script$1c;
	/* template */

	/* style */

	var __vue_inject_styles__$1c = undefined;
	/* scoped */

	var __vue_scope_id__$1c = undefined;
	/* functional template */

	var __vue_is_functional_template__$1c = undefined;
	/* component normalizer */

	function __vue_normalize__$1c(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "FrustumOutlineGeometry.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var FrustumOutlineGeometry = __vue_normalize__$1c({}, __vue_inject_styles__$1c, __vue_script__$1c, __vue_scope_id__$1c, __vue_is_functional_template__$1c);

	function plugin$1c(Vue) {

	  if (plugin$1c.installed) {
	    return;
	  }

	  plugin$1c.installed = true;
	  Vue.component(FrustumOutlineGeometry.name, FrustumOutlineGeometry);
	}

	var FrustumOutlineGeometry$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$1c,
		FrustumOutlineGeometry: FrustumOutlineGeometry,
		install: plugin$1c
	});

	var script$1d = {
	  name: 'vc-geometry-polyline-ground',
	  mixins: [positions, width, granularity, loop, arcType, mixinGeometry]
	};

	/* script */
	var __vue_script__$1d = script$1d;
	/* template */

	/* style */

	var __vue_inject_styles__$1d = undefined;
	/* scoped */

	var __vue_scope_id__$1d = undefined;
	/* functional template */

	var __vue_is_functional_template__$1d = undefined;
	/* component normalizer */

	function __vue_normalize__$1d(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "GroundPolylineGeometry.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var GroundPolylineGeometry = __vue_normalize__$1d({}, __vue_inject_styles__$1d, __vue_script__$1d, __vue_scope_id__$1d, __vue_is_functional_template__$1d);

	function plugin$1d(Vue) {

	  if (plugin$1d.installed) {
	    return;
	  }

	  plugin$1d.installed = true;
	  Vue.component(GroundPolylineGeometry.name, GroundPolylineGeometry);
	}

	var GroundPolylineGeometry$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$1d,
		GroundPolylineGeometry: GroundPolylineGeometry,
		install: plugin$1d
	});

	var script$1e = {
	  name: 'vc-geometry-plane',
	  mixins: [vertexFormat, mixinGeometry]
	};

	/* script */
	var __vue_script__$1e = script$1e;
	/* template */

	/* style */

	var __vue_inject_styles__$1e = undefined;
	/* scoped */

	var __vue_scope_id__$1e = undefined;
	/* functional template */

	var __vue_is_functional_template__$1e = undefined;
	/* component normalizer */

	function __vue_normalize__$1e(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "PlaneGeometry.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var PlaneGeometry = __vue_normalize__$1e({}, __vue_inject_styles__$1e, __vue_script__$1e, __vue_scope_id__$1e, __vue_is_functional_template__$1e);

	function plugin$1e(Vue) {

	  if (plugin$1e.installed) {
	    return;
	  }

	  plugin$1e.installed = true;
	  Vue.component(PlaneGeometry.name, PlaneGeometry);
	}

	var PlaneGeometry$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$1e,
		PlaneGeometry: PlaneGeometry,
		install: plugin$1e
	});

	var script$1f = {
	  name: 'vc-geometry-outline-plane',
	  mixins: [mixinGeometry]
	};

	/* script */
	var __vue_script__$1f = script$1f;
	/* template */

	/* style */

	var __vue_inject_styles__$1f = undefined;
	/* scoped */

	var __vue_scope_id__$1f = undefined;
	/* functional template */

	var __vue_is_functional_template__$1f = undefined;
	/* component normalizer */

	function __vue_normalize__$1f(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "PlaneOutlineGeometry.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var PlaneOutlineGeometry = __vue_normalize__$1f({}, __vue_inject_styles__$1f, __vue_script__$1f, __vue_scope_id__$1f, __vue_is_functional_template__$1f);

	function plugin$1f(Vue) {

	  if (plugin$1f.installed) {
	    return;
	  }

	  plugin$1f.installed = true;
	  Vue.component(PlaneOutlineGeometry.name, PlaneOutlineGeometry);
	}

	var PlaneOutlineGeometry$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$1f,
		PlaneOutlineGeometry: PlaneOutlineGeometry,
		install: plugin$1f
	});

	var script$1g = {
	  name: 'vc-geometry-polygon',
	  mixins: [mixinPolygon, ellipsoid, vertexFormat, mixinGeometry],
	  props: {
	    polygonHierarchy: [Object, Array]
	  }
	};

	/* script */
	var __vue_script__$1g = script$1g;
	/* template */

	/* style */

	var __vue_inject_styles__$1g = undefined;
	/* scoped */

	var __vue_scope_id__$1g = undefined;
	/* functional template */

	var __vue_is_functional_template__$1g = undefined;
	/* component normalizer */

	function __vue_normalize__$1g(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "PolygonGeometry.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var PolygonGeometry = __vue_normalize__$1g({}, __vue_inject_styles__$1g, __vue_script__$1g, __vue_scope_id__$1g, __vue_is_functional_template__$1g);

	function plugin$1g(Vue) {

	  if (plugin$1g.installed) {
	    return;
	  }

	  plugin$1g.installed = true;
	  Vue.component(PolygonGeometry.name, PolygonGeometry);
	}

	var PolygonGeometry$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$1g,
		PolygonGeometry: PolygonGeometry,
		install: plugin$1g
	});

	var script$1h = {
	  name: 'vc-geometry-outline-polygon',
	  mixins: [polygonHierarchy, height, extrudedHeight, vertexFormat, ellipsoid, granularity, perPositionHeight, arcType, mixinGeometry]
	};

	/* script */
	var __vue_script__$1h = script$1h;
	/* template */

	/* style */

	var __vue_inject_styles__$1h = undefined;
	/* scoped */

	var __vue_scope_id__$1h = undefined;
	/* functional template */

	var __vue_is_functional_template__$1h = undefined;
	/* component normalizer */

	function __vue_normalize__$1h(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "PolygonOutlineGeometry.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var PolygonOutlineGeometry = __vue_normalize__$1h({}, __vue_inject_styles__$1h, __vue_script__$1h, __vue_scope_id__$1h, __vue_is_functional_template__$1h);

	function plugin$1h(Vue) {

	  if (plugin$1h.installed) {
	    return;
	  }

	  plugin$1h.installed = true;
	  Vue.component(PolygonOutlineGeometry.name, PolygonOutlineGeometry);
	}

	var PolygonOutlineGeometry$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$1h,
		PolygonOutlineGeometry: PolygonOutlineGeometry,
		install: plugin$1h
	});

	var script$1i = {
	  name: 'vc-geometry-polyline',
	  mixins: [positions, width, arcType, granularity, vertexFormat, ellipsoid, mixinGeometry],
	  props: {
	    colors: Array,
	    colorsPerVertex: {
	      type: Boolean,
	      default: false
	    }
	  }
	};

	/* script */
	var __vue_script__$1i = script$1i;
	/* template */

	/* style */

	var __vue_inject_styles__$1i = undefined;
	/* scoped */

	var __vue_scope_id__$1i = undefined;
	/* functional template */

	var __vue_is_functional_template__$1i = undefined;
	/* component normalizer */

	function __vue_normalize__$1i(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "PolylineGeometry.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var PolylineGeometry = __vue_normalize__$1i({}, __vue_inject_styles__$1i, __vue_script__$1i, __vue_scope_id__$1i, __vue_is_functional_template__$1i);

	function plugin$1i(Vue) {

	  if (plugin$1i.installed) {
	    return;
	  }

	  plugin$1i.installed = true;
	  Vue.component(PolylineGeometry.name, PolylineGeometry);
	}

	var PolylineGeometry$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$1i,
		PolylineGeometry: PolylineGeometry,
		install: plugin$1i
	});

	var script$1j = {
	  name: 'vc-geometry-polyline-volume',
	  mixins: [ellipsoid, granularity, vertexFormat, cornerType, mixinGeometry],
	  props: {
	    polylinePositions: Array,
	    shapePositions: Array
	  }
	};

	/* script */
	var __vue_script__$1j = script$1j;
	/* template */

	/* style */

	var __vue_inject_styles__$1j = undefined;
	/* scoped */

	var __vue_scope_id__$1j = undefined;
	/* functional template */

	var __vue_is_functional_template__$1j = undefined;
	/* component normalizer */

	function __vue_normalize__$1j(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "PolylineVolumeGeometry.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var PolylineVolumeGeometry = __vue_normalize__$1j({}, __vue_inject_styles__$1j, __vue_script__$1j, __vue_scope_id__$1j, __vue_is_functional_template__$1j);

	function plugin$1j(Vue) {

	  if (plugin$1j.installed) {
	    return;
	  }

	  plugin$1j.installed = true;
	  Vue.component(PolylineVolumeGeometry.name, PolylineVolumeGeometry);
	}

	var PolylineVolumeGeometry$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$1j,
		PolylineVolumeGeometry: PolylineVolumeGeometry,
		install: plugin$1j
	});

	var script$1k = {
	  name: 'vc-geometry-outline-polyline-volume',
	  mixins: [ellipsoid, granularity, cornerType, shapePositions, polylinePositions, mixinGeometry]
	};

	/* script */
	var __vue_script__$1k = script$1k;
	/* template */

	/* style */

	var __vue_inject_styles__$1k = undefined;
	/* scoped */

	var __vue_scope_id__$1k = undefined;
	/* functional template */

	var __vue_is_functional_template__$1k = undefined;
	/* component normalizer */

	function __vue_normalize__$1k(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "PolylineVolumeOutlineGeometry.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var PolylineVolumeOutlineGeometry = __vue_normalize__$1k({}, __vue_inject_styles__$1k, __vue_script__$1k, __vue_scope_id__$1k, __vue_is_functional_template__$1k);

	function plugin$1k(Vue) {

	  if (plugin$1k.installed) {
	    return;
	  }

	  plugin$1k.installed = true;
	  Vue.component(PolylineVolumeOutlineGeometry.name, PolylineVolumeOutlineGeometry);
	}

	var PolylineVolumeOutlineGeometry$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$1k,
		PolylineVolumeOutlineGeometry: PolylineVolumeOutlineGeometry,
		install: plugin$1k
	});

	var script$1l = {
	  name: 'vc-geometry-rectangle',
	  mixins: [mixinRectangle, ellipsoid, vertexFormat, rectangle, mixinGeometry]
	};

	/* script */
	var __vue_script__$1l = script$1l;
	/* template */

	/* style */

	var __vue_inject_styles__$1l = undefined;
	/* scoped */

	var __vue_scope_id__$1l = undefined;
	/* functional template */

	var __vue_is_functional_template__$1l = undefined;
	/* component normalizer */

	function __vue_normalize__$1l(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "RectangleGeometry.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var RectangleGeometry = __vue_normalize__$1l({}, __vue_inject_styles__$1l, __vue_script__$1l, __vue_scope_id__$1l, __vue_is_functional_template__$1l);

	function plugin$1l(Vue) {

	  if (plugin$1l.installed) {
	    return;
	  }

	  plugin$1l.installed = true;
	  Vue.component(RectangleGeometry.name, RectangleGeometry);
	}

	var RectangleGeometry$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$1l,
		RectangleGeometry: RectangleGeometry,
		install: plugin$1l
	});

	var script$1m = {
	  name: 'vc-geometry-outline-rectangle',
	  mixins: [rectangle, ellipsoid, granularity, height, rotation, extrudedHeight, mixinGeometry]
	};

	/* script */
	var __vue_script__$1m = script$1m;
	/* template */

	/* style */

	var __vue_inject_styles__$1m = undefined;
	/* scoped */

	var __vue_scope_id__$1m = undefined;
	/* functional template */

	var __vue_is_functional_template__$1m = undefined;
	/* component normalizer */

	function __vue_normalize__$1m(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "RectangleOutlineGeometry.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var RectangleOutlineGeometry = __vue_normalize__$1m({}, __vue_inject_styles__$1m, __vue_script__$1m, __vue_scope_id__$1m, __vue_is_functional_template__$1m);

	function plugin$1m(Vue) {

	  if (plugin$1m.installed) {
	    return;
	  }

	  plugin$1m.installed = true;
	  Vue.component(RectangleOutlineGeometry.name, RectangleOutlineGeometry);
	}

	var RectangleOutlineGeometry$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$1m,
		RectangleOutlineGeometry: RectangleOutlineGeometry,
		install: plugin$1m
	});

	var script$1n = {
	  name: 'vc-geometry-polyline-simple',
	  mixins: [positions, arcType, granularity, ellipsoid, ellipsoid, mixinGeometry],
	  props: {
	    colors: Array,
	    colorsPerVertex: {
	      type: Boolean,
	      default: false
	    }
	  }
	};

	/* script */
	var __vue_script__$1n = script$1n;
	/* template */

	/* style */

	var __vue_inject_styles__$1n = undefined;
	/* scoped */

	var __vue_scope_id__$1n = undefined;
	/* functional template */

	var __vue_is_functional_template__$1n = undefined;
	/* component normalizer */

	function __vue_normalize__$1n(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "SimplePolylineGeometry.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var SimplePolylineGeometry = __vue_normalize__$1n({}, __vue_inject_styles__$1n, __vue_script__$1n, __vue_scope_id__$1n, __vue_is_functional_template__$1n);

	function plugin$1n(Vue) {

	  if (plugin$1n.installed) {
	    return;
	  }

	  plugin$1n.installed = true;
	  Vue.component(SimplePolylineGeometry.name, SimplePolylineGeometry);
	}

	var SimplePolylineGeometry$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$1n,
		SimplePolylineGeometry: SimplePolylineGeometry,
		install: plugin$1n
	});

	var script$1o = {
	  name: 'vc-geometry-sphere',
	  mixins: [radius, stackPartitions, slicePartitions, vertexFormat, mixinGeometry]
	};

	/* script */
	var __vue_script__$1o = script$1o;
	/* template */

	/* style */

	var __vue_inject_styles__$1o = undefined;
	/* scoped */

	var __vue_scope_id__$1o = undefined;
	/* functional template */

	var __vue_is_functional_template__$1o = undefined;
	/* component normalizer */

	function __vue_normalize__$1o(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "SphereGeometry.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var SphereGeometry = __vue_normalize__$1o({}, __vue_inject_styles__$1o, __vue_script__$1o, __vue_scope_id__$1o, __vue_is_functional_template__$1o);

	function plugin$1o(Vue) {

	  if (plugin$1o.installed) {
	    return;
	  }

	  plugin$1o.installed = true;
	  Vue.component(SphereGeometry.name, SphereGeometry);
	}

	var SphereGeometry$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$1o,
		SphereGeometry: SphereGeometry,
		install: plugin$1o
	});

	var script$1p = {
	  name: 'vc-geometry-outline-sphere',
	  mixins: [radius, stackPartitions, slicePartitions, subdivisions, mixinGeometry]
	};

	/* script */
	var __vue_script__$1p = script$1p;
	/* template */

	/* style */

	var __vue_inject_styles__$1p = undefined;
	/* scoped */

	var __vue_scope_id__$1p = undefined;
	/* functional template */

	var __vue_is_functional_template__$1p = undefined;
	/* component normalizer */

	function __vue_normalize__$1p(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "SphereOutlineGeometry.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var SphereOutlineGeometry = __vue_normalize__$1p({}, __vue_inject_styles__$1p, __vue_script__$1p, __vue_scope_id__$1p, __vue_is_functional_template__$1p);

	function plugin$1p(Vue) {

	  if (plugin$1p.installed) {
	    return;
	  }

	  plugin$1p.installed = true;
	  Vue.component(SphereOutlineGeometry.name, SphereOutlineGeometry);
	}

	var SphereOutlineGeometry$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$1p,
		SphereOutlineGeometry: SphereOutlineGeometry,
		install: plugin$1p
	});

	var script$1q = {
	  name: 'vc-geometry-wall',
	  mixins: [ellipsoid, vertexFormat, mixinWall, mixinGeometry]
	};

	/* script */
	var __vue_script__$1q = script$1q;
	/* template */

	/* style */

	var __vue_inject_styles__$1q = undefined;
	/* scoped */

	var __vue_scope_id__$1q = undefined;
	/* functional template */

	var __vue_is_functional_template__$1q = undefined;
	/* component normalizer */

	function __vue_normalize__$1q(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "WallGeometry.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var WallGeometry = __vue_normalize__$1q({}, __vue_inject_styles__$1q, __vue_script__$1q, __vue_scope_id__$1q, __vue_is_functional_template__$1q);

	function plugin$1q(Vue) {

	  if (plugin$1q.installed) {
	    return;
	  }

	  plugin$1q.installed = true;
	  Vue.component(WallGeometry.name, WallGeometry);
	}

	var WallGeometry$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$1q,
		WallGeometry: WallGeometry,
		install: plugin$1q
	});

	var script$1r = {
	  name: 'vc-geometry-outline-wall',
	  mixins: [ellipsoid, mixinWall, mixinGeometry]
	};

	/* script */
	var __vue_script__$1r = script$1r;
	/* template */

	/* style */

	var __vue_inject_styles__$1r = undefined;
	/* scoped */

	var __vue_scope_id__$1r = undefined;
	/* functional template */

	var __vue_is_functional_template__$1r = undefined;
	/* component normalizer */

	function __vue_normalize__$1r(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "WallOutlineGeometry.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var WallOutlineGeometry = __vue_normalize__$1r({}, __vue_inject_styles__$1r, __vue_script__$1r, __vue_scope_id__$1r, __vue_is_functional_template__$1r);

	function plugin$1r(Vue) {

	  if (plugin$1r.installed) {
	    return;
	  }

	  plugin$1r.installed = true;
	  Vue.component(WallOutlineGeometry.name, WallOutlineGeometry);
	}

	var WallOutlineGeometry$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$1r,
		WallOutlineGeometry: WallOutlineGeometry,
		install: plugin$1r
	});

	var script$1s = {
	  name: 'vc-collection-stage-process-post',
	  mixins: [cmp],
	  props: {
	    stages: {
	      type: Array,
	      default: function _default() {
	        return [];
	      }
	    }
	  },
	  methods: {
	    createCesiumObject: function createCesiumObject() {
	      var transformProps, stages, postProcessStageCollection;
	      return regenerator.async(function createCesiumObject$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              transformProps = this.transformProps, stages = this.stages;
	              postProcessStageCollection = new Cesium.PostProcessStageCollection();
	              stages.forEach(function (stage) {
	                var stageOptions = transformProps(stage);
	                postProcessStageCollection.add(new Cesium.PostProcessStage(stageOptions));
	              });
	              return _context.abrupt("return", postProcessStageCollection);

	            case 4:
	            case "end":
	              return _context.stop();
	          }
	        }
	      }, null, this);
	    },
	    mount: function mount() {
	      var postProcessStages, viewer;
	      return regenerator.async(function mount$(_context2) {
	        while (1) {
	          switch (_context2.prev = _context2.next) {
	            case 0:
	              postProcessStages = this.postProcessStages, viewer = this.viewer;
	              viewer.scene.postProcessStages = postProcessStages;
	              return _context2.abrupt("return", true);

	            case 3:
	            case "end":
	              return _context2.stop();
	          }
	        }
	      }, null, this);
	    },
	    unmount: function unmount() {
	      var postProcessStages;
	      return regenerator.async(function unmount$(_context3) {
	        while (1) {
	          switch (_context3.prev = _context3.next) {
	            case 0:
	              postProcessStages = this.postProcessStages;
	              postProcessStages.destroy();
	              return _context3.abrupt("return", true);

	            case 3:
	            case "end":
	              return _context3.stop();
	          }
	        }
	      }, null, this);
	    },
	    getServices: function getServices() {
	      var vm = this;
	      return multiMergeDescriptors(cmp.methods.getServices.call(this), {
	        get postProcessStages() {
	          return vm.postProcessStages;
	        },

	        get postProcessStagesContainer() {
	          return vm;
	        }

	      });
	    }
	  },
	  created: function created() {
	    var _this = this;

	    defineProperties$1(this, {
	      postProcessStages: {
	        enumerable: true,
	        get: function get() {
	          return _this.cesiumObject;
	        }
	      }
	    });
	  },
	  stubVNode: {
	    attrs: function attrs() {
	      return {
	        class: this.$options.name
	      };
	    }
	  }
	};

	/* script */
	var __vue_script__$1s = script$1s;
	/* template */

	/* style */

	var __vue_inject_styles__$1s = undefined;
	/* scoped */

	var __vue_scope_id__$1s = undefined;
	/* functional template */

	var __vue_is_functional_template__$1s = undefined;
	/* component normalizer */

	function __vue_normalize__$1s(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "PostProcessStageCollection.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var PostProcessStageCollection = __vue_normalize__$1s({}, __vue_inject_styles__$1s, __vue_script__$1s, __vue_scope_id__$1s, __vue_is_functional_template__$1s);

	function plugin$1s(Vue) {

	  if (plugin$1s.installed) {
	    return;
	  }

	  plugin$1s.installed = true;
	  Vue.component(PostProcessStageCollection.name, PostProcessStageCollection);
	}

	var PostProcessStageCollection$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$1s,
		PostProcessStageCollection: PostProcessStageCollection,
		install: plugin$1s
	});

	var script$1t = {
	  name: 'vc-stage-process-post',
	  mixins: [clearColor, scissorRectangle, cmp],
	  props: {
	    fragmentShader: String,
	    uniforms: Object,
	    textureScale: {
	      type: Number
	    },
	    forcePowerOfTwo: {
	      type: Boolean,
	      default: false
	    },
	    sampleMode: Number,
	    pixelFormat: Number,
	    pixelDatatype: Number,
	    name: String
	  },
	  methods: {
	    createCesiumObject: function createCesiumObject() {
	      var $props, transformProps, options;
	      return regenerator.async(function createCesiumObject$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              $props = this.$props, transformProps = this.transformProps;
	              options = transformProps($props);
	              return _context.abrupt("return", new Cesium.PostProcessStage(options));

	            case 3:
	            case "end":
	              return _context.stop();
	          }
	        }
	      }, null, this);
	    },
	    mount: function mount() {
	      var postProcessStages, postProcessStage;
	      return regenerator.async(function mount$(_context2) {
	        while (1) {
	          switch (_context2.prev = _context2.next) {
	            case 0:
	              postProcessStages = this.postProcessStages, postProcessStage = this.postProcessStage;
	              return _context2.abrupt("return", postProcessStages.add(postProcessStage));

	            case 2:
	            case "end":
	              return _context2.stop();
	          }
	        }
	      }, null, this);
	    },
	    unmount: function unmount() {
	      var postProcessStages, postProcessStage;
	      return regenerator.async(function unmount$(_context3) {
	        while (1) {
	          switch (_context3.prev = _context3.next) {
	            case 0:
	              postProcessStages = this.postProcessStages, postProcessStage = this.postProcessStage;
	              return _context3.abrupt("return", postProcessStages.remove(postProcessStage));

	            case 2:
	            case "end":
	              return _context3.stop();
	          }
	        }
	      }, null, this);
	    }
	  },
	  created: function created() {
	    var _this = this;

	    defineProperties$1(this, {
	      postProcessStage: {
	        enumerable: true,
	        get: function get() {
	          return _this.cesiumObject;
	        }
	      },
	      postProcessStages: {
	        enumerable: true,
	        get: function get() {
	          return _this.$services && _this.$services.postProcessStages;
	        }
	      }
	    });
	  },
	  stubVNode: {
	    empty: function empty() {
	      return this.$options.name;
	    }
	  }
	};

	/* script */
	var __vue_script__$1t = script$1t;
	/* template */

	/* style */

	var __vue_inject_styles__$1t = undefined;
	/* scoped */

	var __vue_scope_id__$1t = undefined;
	/* functional template */

	var __vue_is_functional_template__$1t = undefined;
	/* component normalizer */

	function __vue_normalize__$1t(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "PostProcessStage.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var PostProcessStage = __vue_normalize__$1t({}, __vue_inject_styles__$1t, __vue_script__$1t, __vue_scope_id__$1t, __vue_is_functional_template__$1t);

	function plugin$1t(Vue) {

	  if (plugin$1t.installed) {
	    return;
	  }

	  plugin$1t.installed = true;
	  Vue.component(PostProcessStage.name, PostProcessStage);
	}

	var PostProcessStage$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$1t,
		PostProcessStage: PostProcessStage,
		install: plugin$1t
	});

	var helpers = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	/**
	 * @module helpers
	 */
	/**
	 * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.
	 *
	 * @memberof helpers
	 * @type {number}
	 */
	exports.earthRadius = 6371008.8;
	/**
	 * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.
	 *
	 * @memberof helpers
	 * @type {Object}
	 */
	exports.factors = {
	    centimeters: exports.earthRadius * 100,
	    centimetres: exports.earthRadius * 100,
	    degrees: exports.earthRadius / 111325,
	    feet: exports.earthRadius * 3.28084,
	    inches: exports.earthRadius * 39.370,
	    kilometers: exports.earthRadius / 1000,
	    kilometres: exports.earthRadius / 1000,
	    meters: exports.earthRadius,
	    metres: exports.earthRadius,
	    miles: exports.earthRadius / 1609.344,
	    millimeters: exports.earthRadius * 1000,
	    millimetres: exports.earthRadius * 1000,
	    nauticalmiles: exports.earthRadius / 1852,
	    radians: 1,
	    yards: exports.earthRadius / 1.0936,
	};
	/**
	 * Units of measurement factors based on 1 meter.
	 *
	 * @memberof helpers
	 * @type {Object}
	 */
	exports.unitsFactors = {
	    centimeters: 100,
	    centimetres: 100,
	    degrees: 1 / 111325,
	    feet: 3.28084,
	    inches: 39.370,
	    kilometers: 1 / 1000,
	    kilometres: 1 / 1000,
	    meters: 1,
	    metres: 1,
	    miles: 1 / 1609.344,
	    millimeters: 1000,
	    millimetres: 1000,
	    nauticalmiles: 1 / 1852,
	    radians: 1 / exports.earthRadius,
	    yards: 1 / 1.0936,
	};
	/**
	 * Area of measurement factors based on 1 square meter.
	 *
	 * @memberof helpers
	 * @type {Object}
	 */
	exports.areaFactors = {
	    acres: 0.000247105,
	    centimeters: 10000,
	    centimetres: 10000,
	    feet: 10.763910417,
	    inches: 1550.003100006,
	    kilometers: 0.000001,
	    kilometres: 0.000001,
	    meters: 1,
	    metres: 1,
	    miles: 3.86e-7,
	    millimeters: 1000000,
	    millimetres: 1000000,
	    yards: 1.195990046,
	};
	/**
	 * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.
	 *
	 * @name feature
	 * @param {Geometry} geometry input geometry
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature} a GeoJSON Feature
	 * @example
	 * var geometry = {
	 *   "type": "Point",
	 *   "coordinates": [110, 50]
	 * };
	 *
	 * var feature = turf.feature(geometry);
	 *
	 * //=feature
	 */
	function feature(geom, properties, options) {
	    if (options === void 0) { options = {}; }
	    var feat = { type: "Feature" };
	    if (options.id === 0 || options.id) {
	        feat.id = options.id;
	    }
	    if (options.bbox) {
	        feat.bbox = options.bbox;
	    }
	    feat.properties = properties || {};
	    feat.geometry = geom;
	    return feat;
	}
	exports.feature = feature;
	/**
	 * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.
	 * For GeometryCollection type use `helpers.geometryCollection`
	 *
	 * @name geometry
	 * @param {string} type Geometry Type
	 * @param {Array<any>} coordinates Coordinates
	 * @param {Object} [options={}] Optional Parameters
	 * @returns {Geometry} a GeoJSON Geometry
	 * @example
	 * var type = "Point";
	 * var coordinates = [110, 50];
	 * var geometry = turf.geometry(type, coordinates);
	 * // => geometry
	 */
	function geometry(type, coordinates, options) {
	    switch (type) {
	        case "Point": return point(coordinates).geometry;
	        case "LineString": return lineString(coordinates).geometry;
	        case "Polygon": return polygon(coordinates).geometry;
	        case "MultiPoint": return multiPoint(coordinates).geometry;
	        case "MultiLineString": return multiLineString(coordinates).geometry;
	        case "MultiPolygon": return multiPolygon(coordinates).geometry;
	        default: throw new Error(type + " is invalid");
	    }
	}
	exports.geometry = geometry;
	/**
	 * Creates a {@link Point} {@link Feature} from a Position.
	 *
	 * @name point
	 * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature<Point>} a Point feature
	 * @example
	 * var point = turf.point([-75.343, 39.984]);
	 *
	 * //=point
	 */
	function point(coordinates, properties, options) {
	    if (options === void 0) { options = {}; }
	    var geom = {
	        type: "Point",
	        coordinates: coordinates,
	    };
	    return feature(geom, properties, options);
	}
	exports.point = point;
	/**
	 * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.
	 *
	 * @name points
	 * @param {Array<Array<number>>} coordinates an array of Points
	 * @param {Object} [properties={}] Translate these properties to each Feature
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]
	 * associated with the FeatureCollection
	 * @param {string|number} [options.id] Identifier associated with the FeatureCollection
	 * @returns {FeatureCollection<Point>} Point Feature
	 * @example
	 * var points = turf.points([
	 *   [-75, 39],
	 *   [-80, 45],
	 *   [-78, 50]
	 * ]);
	 *
	 * //=points
	 */
	function points(coordinates, properties, options) {
	    if (options === void 0) { options = {}; }
	    return featureCollection(coordinates.map(function (coords) {
	        return point(coords, properties);
	    }), options);
	}
	exports.points = points;
	/**
	 * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.
	 *
	 * @name polygon
	 * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature<Polygon>} Polygon Feature
	 * @example
	 * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });
	 *
	 * //=polygon
	 */
	function polygon(coordinates, properties, options) {
	    if (options === void 0) { options = {}; }
	    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {
	        var ring = coordinates_1[_i];
	        if (ring.length < 4) {
	            throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
	        }
	        for (var j = 0; j < ring[ring.length - 1].length; j++) {
	            // Check if first point of Polygon contains two numbers
	            if (ring[ring.length - 1][j] !== ring[0][j]) {
	                throw new Error("First and last Position are not equivalent.");
	            }
	        }
	    }
	    var geom = {
	        type: "Polygon",
	        coordinates: coordinates,
	    };
	    return feature(geom, properties, options);
	}
	exports.polygon = polygon;
	/**
	 * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.
	 *
	 * @name polygons
	 * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the FeatureCollection
	 * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection
	 * @example
	 * var polygons = turf.polygons([
	 *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],
	 *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],
	 * ]);
	 *
	 * //=polygons
	 */
	function polygons(coordinates, properties, options) {
	    if (options === void 0) { options = {}; }
	    return featureCollection(coordinates.map(function (coords) {
	        return polygon(coords, properties);
	    }), options);
	}
	exports.polygons = polygons;
	/**
	 * Creates a {@link LineString} {@link Feature} from an Array of Positions.
	 *
	 * @name lineString
	 * @param {Array<Array<number>>} coordinates an array of Positions
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature<LineString>} LineString Feature
	 * @example
	 * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});
	 * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});
	 *
	 * //=linestring1
	 * //=linestring2
	 */
	function lineString(coordinates, properties, options) {
	    if (options === void 0) { options = {}; }
	    if (coordinates.length < 2) {
	        throw new Error("coordinates must be an array of two or more positions");
	    }
	    var geom = {
	        type: "LineString",
	        coordinates: coordinates,
	    };
	    return feature(geom, properties, options);
	}
	exports.lineString = lineString;
	/**
	 * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.
	 *
	 * @name lineStrings
	 * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]
	 * associated with the FeatureCollection
	 * @param {string|number} [options.id] Identifier associated with the FeatureCollection
	 * @returns {FeatureCollection<LineString>} LineString FeatureCollection
	 * @example
	 * var linestrings = turf.lineStrings([
	 *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],
	 *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]
	 * ]);
	 *
	 * //=linestrings
	 */
	function lineStrings(coordinates, properties, options) {
	    if (options === void 0) { options = {}; }
	    return featureCollection(coordinates.map(function (coords) {
	        return lineString(coords, properties);
	    }), options);
	}
	exports.lineStrings = lineStrings;
	/**
	 * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.
	 *
	 * @name featureCollection
	 * @param {Feature[]} features input features
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {FeatureCollection} FeatureCollection of Features
	 * @example
	 * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});
	 * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});
	 * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});
	 *
	 * var collection = turf.featureCollection([
	 *   locationA,
	 *   locationB,
	 *   locationC
	 * ]);
	 *
	 * //=collection
	 */
	function featureCollection(features, options) {
	    if (options === void 0) { options = {}; }
	    var fc = { type: "FeatureCollection" };
	    if (options.id) {
	        fc.id = options.id;
	    }
	    if (options.bbox) {
	        fc.bbox = options.bbox;
	    }
	    fc.features = features;
	    return fc;
	}
	exports.featureCollection = featureCollection;
	/**
	 * Creates a {@link Feature<MultiLineString>} based on a
	 * coordinate array. Properties can be added optionally.
	 *
	 * @name multiLineString
	 * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature<MultiLineString>} a MultiLineString feature
	 * @throws {Error} if no coordinates are passed
	 * @example
	 * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);
	 *
	 * //=multiLine
	 */
	function multiLineString(coordinates, properties, options) {
	    if (options === void 0) { options = {}; }
	    var geom = {
	        type: "MultiLineString",
	        coordinates: coordinates,
	    };
	    return feature(geom, properties, options);
	}
	exports.multiLineString = multiLineString;
	/**
	 * Creates a {@link Feature<MultiPoint>} based on a
	 * coordinate array. Properties can be added optionally.
	 *
	 * @name multiPoint
	 * @param {Array<Array<number>>} coordinates an array of Positions
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature<MultiPoint>} a MultiPoint feature
	 * @throws {Error} if no coordinates are passed
	 * @example
	 * var multiPt = turf.multiPoint([[0,0],[10,10]]);
	 *
	 * //=multiPt
	 */
	function multiPoint(coordinates, properties, options) {
	    if (options === void 0) { options = {}; }
	    var geom = {
	        type: "MultiPoint",
	        coordinates: coordinates,
	    };
	    return feature(geom, properties, options);
	}
	exports.multiPoint = multiPoint;
	/**
	 * Creates a {@link Feature<MultiPolygon>} based on a
	 * coordinate array. Properties can be added optionally.
	 *
	 * @name multiPolygon
	 * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature<MultiPolygon>} a multipolygon feature
	 * @throws {Error} if no coordinates are passed
	 * @example
	 * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);
	 *
	 * //=multiPoly
	 *
	 */
	function multiPolygon(coordinates, properties, options) {
	    if (options === void 0) { options = {}; }
	    var geom = {
	        type: "MultiPolygon",
	        coordinates: coordinates,
	    };
	    return feature(geom, properties, options);
	}
	exports.multiPolygon = multiPolygon;
	/**
	 * Creates a {@link Feature<GeometryCollection>} based on a
	 * coordinate array. Properties can be added optionally.
	 *
	 * @name geometryCollection
	 * @param {Array<Geometry>} geometries an array of GeoJSON Geometries
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature
	 * @example
	 * var pt = turf.geometry("Point", [100, 0]);
	 * var line = turf.geometry("LineString", [[101, 0], [102, 1]]);
	 * var collection = turf.geometryCollection([pt, line]);
	 *
	 * // => collection
	 */
	function geometryCollection(geometries, properties, options) {
	    if (options === void 0) { options = {}; }
	    var geom = {
	        type: "GeometryCollection",
	        geometries: geometries,
	    };
	    return feature(geom, properties, options);
	}
	exports.geometryCollection = geometryCollection;
	/**
	 * Round number to precision
	 *
	 * @param {number} num Number
	 * @param {number} [precision=0] Precision
	 * @returns {number} rounded number
	 * @example
	 * turf.round(120.4321)
	 * //=120
	 *
	 * turf.round(120.4321, 2)
	 * //=120.43
	 */
	function round(num, precision) {
	    if (precision === void 0) { precision = 0; }
	    if (precision && !(precision >= 0)) {
	        throw new Error("precision must be a positive number");
	    }
	    var multiplier = Math.pow(10, precision || 0);
	    return Math.round(num * multiplier) / multiplier;
	}
	exports.round = round;
	/**
	 * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.
	 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
	 *
	 * @name radiansToLength
	 * @param {number} radians in radians across the sphere
	 * @param {string} [units="kilometers"] can be degrees, radians, miles, or kilometers inches, yards, metres,
	 * meters, kilometres, kilometers.
	 * @returns {number} distance
	 */
	function radiansToLength(radians, units) {
	    if (units === void 0) { units = "kilometers"; }
	    var factor = exports.factors[units];
	    if (!factor) {
	        throw new Error(units + " units is invalid");
	    }
	    return radians * factor;
	}
	exports.radiansToLength = radiansToLength;
	/**
	 * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians
	 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
	 *
	 * @name lengthToRadians
	 * @param {number} distance in real units
	 * @param {string} [units="kilometers"] can be degrees, radians, miles, or kilometers inches, yards, metres,
	 * meters, kilometres, kilometers.
	 * @returns {number} radians
	 */
	function lengthToRadians(distance, units) {
	    if (units === void 0) { units = "kilometers"; }
	    var factor = exports.factors[units];
	    if (!factor) {
	        throw new Error(units + " units is invalid");
	    }
	    return distance / factor;
	}
	exports.lengthToRadians = lengthToRadians;
	/**
	 * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees
	 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet
	 *
	 * @name lengthToDegrees
	 * @param {number} distance in real units
	 * @param {string} [units="kilometers"] can be degrees, radians, miles, or kilometers inches, yards, metres,
	 * meters, kilometres, kilometers.
	 * @returns {number} degrees
	 */
	function lengthToDegrees(distance, units) {
	    return radiansToDegrees(lengthToRadians(distance, units));
	}
	exports.lengthToDegrees = lengthToDegrees;
	/**
	 * Converts any bearing angle from the north line direction (positive clockwise)
	 * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line
	 *
	 * @name bearingToAzimuth
	 * @param {number} bearing angle, between -180 and +180 degrees
	 * @returns {number} angle between 0 and 360 degrees
	 */
	function bearingToAzimuth(bearing) {
	    var angle = bearing % 360;
	    if (angle < 0) {
	        angle += 360;
	    }
	    return angle;
	}
	exports.bearingToAzimuth = bearingToAzimuth;
	/**
	 * Converts an angle in radians to degrees
	 *
	 * @name radiansToDegrees
	 * @param {number} radians angle in radians
	 * @returns {number} degrees between 0 and 360 degrees
	 */
	function radiansToDegrees(radians) {
	    var degrees = radians % (2 * Math.PI);
	    return degrees * 180 / Math.PI;
	}
	exports.radiansToDegrees = radiansToDegrees;
	/**
	 * Converts an angle in degrees to radians
	 *
	 * @name degreesToRadians
	 * @param {number} degrees angle between 0 and 360 degrees
	 * @returns {number} angle in radians
	 */
	function degreesToRadians(degrees) {
	    var radians = degrees % 360;
	    return radians * Math.PI / 180;
	}
	exports.degreesToRadians = degreesToRadians;
	/**
	 * Converts a length to the requested unit.
	 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
	 *
	 * @param {number} length to be converted
	 * @param {Units} [originalUnit="kilometers"] of the length
	 * @param {Units} [finalUnit="kilometers"] returned unit
	 * @returns {number} the converted length
	 */
	function convertLength(length, originalUnit, finalUnit) {
	    if (originalUnit === void 0) { originalUnit = "kilometers"; }
	    if (finalUnit === void 0) { finalUnit = "kilometers"; }
	    if (!(length >= 0)) {
	        throw new Error("length must be a positive number");
	    }
	    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);
	}
	exports.convertLength = convertLength;
	/**
	 * Converts a area to the requested unit.
	 * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches
	 * @param {number} area to be converted
	 * @param {Units} [originalUnit="meters"] of the distance
	 * @param {Units} [finalUnit="kilometers"] returned unit
	 * @returns {number} the converted distance
	 */
	function convertArea(area, originalUnit, finalUnit) {
	    if (originalUnit === void 0) { originalUnit = "meters"; }
	    if (finalUnit === void 0) { finalUnit = "kilometers"; }
	    if (!(area >= 0)) {
	        throw new Error("area must be a positive number");
	    }
	    var startFactor = exports.areaFactors[originalUnit];
	    if (!startFactor) {
	        throw new Error("invalid original units");
	    }
	    var finalFactor = exports.areaFactors[finalUnit];
	    if (!finalFactor) {
	        throw new Error("invalid final units");
	    }
	    return (area / startFactor) * finalFactor;
	}
	exports.convertArea = convertArea;
	/**
	 * isNumber
	 *
	 * @param {*} num Number to validate
	 * @returns {boolean} true/false
	 * @example
	 * turf.isNumber(123)
	 * //=true
	 * turf.isNumber('foo')
	 * //=false
	 */
	function isNumber(num) {
	    return !isNaN(num) && num !== null && !Array.isArray(num) && !/^\s*$/.test(num);
	}
	exports.isNumber = isNumber;
	/**
	 * isObject
	 *
	 * @param {*} input variable to validate
	 * @returns {boolean} true/false
	 * @example
	 * turf.isObject({elevation: 10})
	 * //=true
	 * turf.isObject('foo')
	 * //=false
	 */
	function isObject(input) {
	    return (!!input) && (input.constructor === Object);
	}
	exports.isObject = isObject;
	/**
	 * Validate BBox
	 *
	 * @private
	 * @param {Array<number>} bbox BBox to validate
	 * @returns {void}
	 * @throws Error if BBox is not valid
	 * @example
	 * validateBBox([-180, -40, 110, 50])
	 * //=OK
	 * validateBBox([-180, -40])
	 * //=Error
	 * validateBBox('Foo')
	 * //=Error
	 * validateBBox(5)
	 * //=Error
	 * validateBBox(null)
	 * //=Error
	 * validateBBox(undefined)
	 * //=Error
	 */
	function validateBBox(bbox) {
	    if (!bbox) {
	        throw new Error("bbox is required");
	    }
	    if (!Array.isArray(bbox)) {
	        throw new Error("bbox must be an Array");
	    }
	    if (bbox.length !== 4 && bbox.length !== 6) {
	        throw new Error("bbox must be an Array of 4 or 6 numbers");
	    }
	    bbox.forEach(function (num) {
	        if (!isNumber(num)) {
	            throw new Error("bbox must only contain numbers");
	        }
	    });
	}
	exports.validateBBox = validateBBox;
	/**
	 * Validate Id
	 *
	 * @private
	 * @param {string|number} id Id to validate
	 * @returns {void}
	 * @throws Error if Id is not valid
	 * @example
	 * validateId([-180, -40, 110, 50])
	 * //=Error
	 * validateId([-180, -40])
	 * //=Error
	 * validateId('Foo')
	 * //=OK
	 * validateId(5)
	 * //=OK
	 * validateId(null)
	 * //=Error
	 * validateId(undefined)
	 * //=Error
	 */
	function validateId(id) {
	    if (!id) {
	        throw new Error("id is required");
	    }
	    if (["string", "number"].indexOf(typeof id) === -1) {
	        throw new Error("id must be a number or a string");
	    }
	}
	exports.validateId = validateId;
	// Deprecated methods
	function radians2degrees() {
	    throw new Error("method has been renamed to `radiansToDegrees`");
	}
	exports.radians2degrees = radians2degrees;
	function degrees2radians() {
	    throw new Error("method has been renamed to `degreesToRadians`");
	}
	exports.degrees2radians = degrees2radians;
	function distanceToDegrees() {
	    throw new Error("method has been renamed to `lengthToDegrees`");
	}
	exports.distanceToDegrees = distanceToDegrees;
	function distanceToRadians() {
	    throw new Error("method has been renamed to `lengthToRadians`");
	}
	exports.distanceToRadians = distanceToRadians;
	function radiansToDistance() {
	    throw new Error("method has been renamed to `radiansToLength`");
	}
	exports.radiansToDistance = radiansToDistance;
	function bearingToAngle() {
	    throw new Error("method has been renamed to `bearingToAzimuth`");
	}
	exports.bearingToAngle = bearingToAngle;
	function convertDistance() {
	    throw new Error("method has been renamed to `convertLength`");
	}
	exports.convertDistance = convertDistance;
	});

	unwrapExports(helpers);
	var helpers_1 = helpers.earthRadius;
	var helpers_2 = helpers.factors;
	var helpers_3 = helpers.unitsFactors;
	var helpers_4 = helpers.areaFactors;
	var helpers_5 = helpers.feature;
	var helpers_6 = helpers.geometry;
	var helpers_7 = helpers.point;
	var helpers_8 = helpers.points;
	var helpers_9 = helpers.polygon;
	var helpers_10 = helpers.polygons;
	var helpers_11 = helpers.lineString;
	var helpers_12 = helpers.lineStrings;
	var helpers_13 = helpers.featureCollection;
	var helpers_14 = helpers.multiLineString;
	var helpers_15 = helpers.multiPoint;
	var helpers_16 = helpers.multiPolygon;
	var helpers_17 = helpers.geometryCollection;
	var helpers_18 = helpers.round;
	var helpers_19 = helpers.radiansToLength;
	var helpers_20 = helpers.lengthToRadians;
	var helpers_21 = helpers.lengthToDegrees;
	var helpers_22 = helpers.bearingToAzimuth;
	var helpers_23 = helpers.radiansToDegrees;
	var helpers_24 = helpers.degreesToRadians;
	var helpers_25 = helpers.convertLength;
	var helpers_26 = helpers.convertArea;
	var helpers_27 = helpers.isNumber;
	var helpers_28 = helpers.isObject;
	var helpers_29 = helpers.validateBBox;
	var helpers_30 = helpers.validateId;
	var helpers_31 = helpers.radians2degrees;
	var helpers_32 = helpers.degrees2radians;
	var helpers_33 = helpers.distanceToDegrees;
	var helpers_34 = helpers.distanceToRadians;
	var helpers_35 = helpers.radiansToDistance;
	var helpers_36 = helpers.bearingToAngle;
	var helpers_37 = helpers.convertDistance;

	var meta$1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, '__esModule', { value: true });



	/**
	 * Callback for coordEach
	 *
	 * @callback coordEachCallback
	 * @param {Array<number>} currentCoord The current coordinate being processed.
	 * @param {number} coordIndex The current index of the coordinate being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
	 * @param {number} geometryIndex The current index of the Geometry being processed.
	 */

	/**
	 * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()
	 *
	 * @name coordEach
	 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
	 * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)
	 * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.
	 * @returns {void}
	 * @example
	 * var features = turf.featureCollection([
	 *   turf.point([26, 37], {"foo": "bar"}),
	 *   turf.point([36, 53], {"hello": "world"})
	 * ]);
	 *
	 * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
	 *   //=currentCoord
	 *   //=coordIndex
	 *   //=featureIndex
	 *   //=multiFeatureIndex
	 *   //=geometryIndex
	 * });
	 */
	function coordEach(geojson, callback, excludeWrapCoord) {
	    // Handles null Geometry -- Skips this GeoJSON
	    if (geojson === null) return;
	    var j, k, l, geometry, stopG, coords,
	        geometryMaybeCollection,
	        wrapShrink = 0,
	        coordIndex = 0,
	        isGeometryCollection,
	        type = geojson.type,
	        isFeatureCollection = type === 'FeatureCollection',
	        isFeature = type === 'Feature',
	        stop = isFeatureCollection ? geojson.features.length : 1;

	    // This logic may look a little weird. The reason why it is that way
	    // is because it's trying to be fast. GeoJSON supports multiple kinds
	    // of objects at its root: FeatureCollection, Features, Geometries.
	    // This function has the responsibility of handling all of them, and that
	    // means that some of the `for` loops you see below actually just don't apply
	    // to certain inputs. For instance, if you give this just a
	    // Point geometry, then both loops are short-circuited and all we do
	    // is gradually rename the input until it's called 'geometry'.
	    //
	    // This also aims to allocate as few resources as possible: just a
	    // few numbers and booleans, rather than any temporary arrays as would
	    // be required with the normalization approach.
	    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {
	        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :
	            (isFeature ? geojson.geometry : geojson));
	        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;
	        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

	        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {
	            var multiFeatureIndex = 0;
	            var geometryIndex = 0;
	            geometry = isGeometryCollection ?
	                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;

	            // Handles null Geometry -- Skips this geometry
	            if (geometry === null) continue;
	            coords = geometry.coordinates;
	            var geomType = geometry.type;

	            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;

	            switch (geomType) {
	            case null:
	                break;
	            case 'Point':
	                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
	                coordIndex++;
	                multiFeatureIndex++;
	                break;
	            case 'LineString':
	            case 'MultiPoint':
	                for (j = 0; j < coords.length; j++) {
	                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
	                    coordIndex++;
	                    if (geomType === 'MultiPoint') multiFeatureIndex++;
	                }
	                if (geomType === 'LineString') multiFeatureIndex++;
	                break;
	            case 'Polygon':
	            case 'MultiLineString':
	                for (j = 0; j < coords.length; j++) {
	                    for (k = 0; k < coords[j].length - wrapShrink; k++) {
	                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
	                        coordIndex++;
	                    }
	                    if (geomType === 'MultiLineString') multiFeatureIndex++;
	                    if (geomType === 'Polygon') geometryIndex++;
	                }
	                if (geomType === 'Polygon') multiFeatureIndex++;
	                break;
	            case 'MultiPolygon':
	                for (j = 0; j < coords.length; j++) {
	                    geometryIndex = 0;
	                    for (k = 0; k < coords[j].length; k++) {
	                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
	                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
	                            coordIndex++;
	                        }
	                        geometryIndex++;
	                    }
	                    multiFeatureIndex++;
	                }
	                break;
	            case 'GeometryCollection':
	                for (j = 0; j < geometry.geometries.length; j++)
	                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;
	                break;
	            default:
	                throw new Error('Unknown Geometry Type');
	            }
	        }
	    }
	}

	/**
	 * Callback for coordReduce
	 *
	 * The first time the callback function is called, the values provided as arguments depend
	 * on whether the reduce method has an initialValue argument.
	 *
	 * If an initialValue is provided to the reduce method:
	 *  - The previousValue argument is initialValue.
	 *  - The currentValue argument is the value of the first element present in the array.
	 *
	 * If an initialValue is not provided:
	 *  - The previousValue argument is the value of the first element present in the array.
	 *  - The currentValue argument is the value of the second element present in the array.
	 *
	 * @callback coordReduceCallback
	 * @param {*} previousValue The accumulated value previously returned in the last invocation
	 * of the callback, or initialValue, if supplied.
	 * @param {Array<number>} currentCoord The current coordinate being processed.
	 * @param {number} coordIndex The current index of the coordinate being processed.
	 * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
	 * @param {number} geometryIndex The current index of the Geometry being processed.
	 */

	/**
	 * Reduce coordinates in any GeoJSON object, similar to Array.reduce()
	 *
	 * @name coordReduce
	 * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object
	 * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)
	 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
	 * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.
	 * @returns {*} The value that results from the reduction.
	 * @example
	 * var features = turf.featureCollection([
	 *   turf.point([26, 37], {"foo": "bar"}),
	 *   turf.point([36, 53], {"hello": "world"})
	 * ]);
	 *
	 * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
	 *   //=previousValue
	 *   //=currentCoord
	 *   //=coordIndex
	 *   //=featureIndex
	 *   //=multiFeatureIndex
	 *   //=geometryIndex
	 *   return currentCoord;
	 * });
	 */
	function coordReduce(geojson, callback, initialValue, excludeWrapCoord) {
	    var previousValue = initialValue;
	    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
	        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;
	        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);
	    }, excludeWrapCoord);
	    return previousValue;
	}

	/**
	 * Callback for propEach
	 *
	 * @callback propEachCallback
	 * @param {Object} currentProperties The current Properties being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 */

	/**
	 * Iterate over properties in any GeoJSON object, similar to Array.forEach()
	 *
	 * @name propEach
	 * @param {FeatureCollection|Feature} geojson any GeoJSON object
	 * @param {Function} callback a method that takes (currentProperties, featureIndex)
	 * @returns {void}
	 * @example
	 * var features = turf.featureCollection([
	 *     turf.point([26, 37], {foo: 'bar'}),
	 *     turf.point([36, 53], {hello: 'world'})
	 * ]);
	 *
	 * turf.propEach(features, function (currentProperties, featureIndex) {
	 *   //=currentProperties
	 *   //=featureIndex
	 * });
	 */
	function propEach(geojson, callback) {
	    var i;
	    switch (geojson.type) {
	    case 'FeatureCollection':
	        for (i = 0; i < geojson.features.length; i++) {
	            if (callback(geojson.features[i].properties, i) === false) break;
	        }
	        break;
	    case 'Feature':
	        callback(geojson.properties, 0);
	        break;
	    }
	}


	/**
	 * Callback for propReduce
	 *
	 * The first time the callback function is called, the values provided as arguments depend
	 * on whether the reduce method has an initialValue argument.
	 *
	 * If an initialValue is provided to the reduce method:
	 *  - The previousValue argument is initialValue.
	 *  - The currentValue argument is the value of the first element present in the array.
	 *
	 * If an initialValue is not provided:
	 *  - The previousValue argument is the value of the first element present in the array.
	 *  - The currentValue argument is the value of the second element present in the array.
	 *
	 * @callback propReduceCallback
	 * @param {*} previousValue The accumulated value previously returned in the last invocation
	 * of the callback, or initialValue, if supplied.
	 * @param {*} currentProperties The current Properties being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 */

	/**
	 * Reduce properties in any GeoJSON object into a single value,
	 * similar to how Array.reduce works. However, in this case we lazily run
	 * the reduction, so an array of all properties is unnecessary.
	 *
	 * @name propReduce
	 * @param {FeatureCollection|Feature} geojson any GeoJSON object
	 * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)
	 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
	 * @returns {*} The value that results from the reduction.
	 * @example
	 * var features = turf.featureCollection([
	 *     turf.point([26, 37], {foo: 'bar'}),
	 *     turf.point([36, 53], {hello: 'world'})
	 * ]);
	 *
	 * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {
	 *   //=previousValue
	 *   //=currentProperties
	 *   //=featureIndex
	 *   return currentProperties
	 * });
	 */
	function propReduce(geojson, callback, initialValue) {
	    var previousValue = initialValue;
	    propEach(geojson, function (currentProperties, featureIndex) {
	        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;
	        else previousValue = callback(previousValue, currentProperties, featureIndex);
	    });
	    return previousValue;
	}

	/**
	 * Callback for featureEach
	 *
	 * @callback featureEachCallback
	 * @param {Feature<any>} currentFeature The current Feature being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 */

	/**
	 * Iterate over features in any GeoJSON object, similar to
	 * Array.forEach.
	 *
	 * @name featureEach
	 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
	 * @param {Function} callback a method that takes (currentFeature, featureIndex)
	 * @returns {void}
	 * @example
	 * var features = turf.featureCollection([
	 *   turf.point([26, 37], {foo: 'bar'}),
	 *   turf.point([36, 53], {hello: 'world'})
	 * ]);
	 *
	 * turf.featureEach(features, function (currentFeature, featureIndex) {
	 *   //=currentFeature
	 *   //=featureIndex
	 * });
	 */
	function featureEach(geojson, callback) {
	    if (geojson.type === 'Feature') {
	        callback(geojson, 0);
	    } else if (geojson.type === 'FeatureCollection') {
	        for (var i = 0; i < geojson.features.length; i++) {
	            if (callback(geojson.features[i], i) === false) break;
	        }
	    }
	}

	/**
	 * Callback for featureReduce
	 *
	 * The first time the callback function is called, the values provided as arguments depend
	 * on whether the reduce method has an initialValue argument.
	 *
	 * If an initialValue is provided to the reduce method:
	 *  - The previousValue argument is initialValue.
	 *  - The currentValue argument is the value of the first element present in the array.
	 *
	 * If an initialValue is not provided:
	 *  - The previousValue argument is the value of the first element present in the array.
	 *  - The currentValue argument is the value of the second element present in the array.
	 *
	 * @callback featureReduceCallback
	 * @param {*} previousValue The accumulated value previously returned in the last invocation
	 * of the callback, or initialValue, if supplied.
	 * @param {Feature} currentFeature The current Feature being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 */

	/**
	 * Reduce features in any GeoJSON object, similar to Array.reduce().
	 *
	 * @name featureReduce
	 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
	 * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)
	 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
	 * @returns {*} The value that results from the reduction.
	 * @example
	 * var features = turf.featureCollection([
	 *   turf.point([26, 37], {"foo": "bar"}),
	 *   turf.point([36, 53], {"hello": "world"})
	 * ]);
	 *
	 * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {
	 *   //=previousValue
	 *   //=currentFeature
	 *   //=featureIndex
	 *   return currentFeature
	 * });
	 */
	function featureReduce(geojson, callback, initialValue) {
	    var previousValue = initialValue;
	    featureEach(geojson, function (currentFeature, featureIndex) {
	        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;
	        else previousValue = callback(previousValue, currentFeature, featureIndex);
	    });
	    return previousValue;
	}

	/**
	 * Get all coordinates from any GeoJSON object.
	 *
	 * @name coordAll
	 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
	 * @returns {Array<Array<number>>} coordinate position array
	 * @example
	 * var features = turf.featureCollection([
	 *   turf.point([26, 37], {foo: 'bar'}),
	 *   turf.point([36, 53], {hello: 'world'})
	 * ]);
	 *
	 * var coords = turf.coordAll(features);
	 * //= [[26, 37], [36, 53]]
	 */
	function coordAll(geojson) {
	    var coords = [];
	    coordEach(geojson, function (coord) {
	        coords.push(coord);
	    });
	    return coords;
	}

	/**
	 * Callback for geomEach
	 *
	 * @callback geomEachCallback
	 * @param {Geometry} currentGeometry The current Geometry being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 * @param {Object} featureProperties The current Feature Properties being processed.
	 * @param {Array<number>} featureBBox The current Feature BBox being processed.
	 * @param {number|string} featureId The current Feature Id being processed.
	 */

	/**
	 * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()
	 *
	 * @name geomEach
	 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
	 * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)
	 * @returns {void}
	 * @example
	 * var features = turf.featureCollection([
	 *     turf.point([26, 37], {foo: 'bar'}),
	 *     turf.point([36, 53], {hello: 'world'})
	 * ]);
	 *
	 * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
	 *   //=currentGeometry
	 *   //=featureIndex
	 *   //=featureProperties
	 *   //=featureBBox
	 *   //=featureId
	 * });
	 */
	function geomEach(geojson, callback) {
	    var i, j, g, geometry, stopG,
	        geometryMaybeCollection,
	        isGeometryCollection,
	        featureProperties,
	        featureBBox,
	        featureId,
	        featureIndex = 0,
	        isFeatureCollection = geojson.type === 'FeatureCollection',
	        isFeature = geojson.type === 'Feature',
	        stop = isFeatureCollection ? geojson.features.length : 1;

	    // This logic may look a little weird. The reason why it is that way
	    // is because it's trying to be fast. GeoJSON supports multiple kinds
	    // of objects at its root: FeatureCollection, Features, Geometries.
	    // This function has the responsibility of handling all of them, and that
	    // means that some of the `for` loops you see below actually just don't apply
	    // to certain inputs. For instance, if you give this just a
	    // Point geometry, then both loops are short-circuited and all we do
	    // is gradually rename the input until it's called 'geometry'.
	    //
	    // This also aims to allocate as few resources as possible: just a
	    // few numbers and booleans, rather than any temporary arrays as would
	    // be required with the normalization approach.
	    for (i = 0; i < stop; i++) {

	        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :
	            (isFeature ? geojson.geometry : geojson));
	        featureProperties = (isFeatureCollection ? geojson.features[i].properties :
	            (isFeature ? geojson.properties : {}));
	        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :
	            (isFeature ? geojson.bbox : undefined));
	        featureId = (isFeatureCollection ? geojson.features[i].id :
	            (isFeature ? geojson.id : undefined));
	        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;
	        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

	        for (g = 0; g < stopG; g++) {
	            geometry = isGeometryCollection ?
	                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;

	            // Handle null Geometry
	            if (geometry === null) {
	                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;
	                continue;
	            }
	            switch (geometry.type) {
	            case 'Point':
	            case 'LineString':
	            case 'MultiPoint':
	            case 'Polygon':
	            case 'MultiLineString':
	            case 'MultiPolygon': {
	                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;
	                break;
	            }
	            case 'GeometryCollection': {
	                for (j = 0; j < geometry.geometries.length; j++) {
	                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;
	                }
	                break;
	            }
	            default:
	                throw new Error('Unknown Geometry Type');
	            }
	        }
	        // Only increase `featureIndex` per each feature
	        featureIndex++;
	    }
	}

	/**
	 * Callback for geomReduce
	 *
	 * The first time the callback function is called, the values provided as arguments depend
	 * on whether the reduce method has an initialValue argument.
	 *
	 * If an initialValue is provided to the reduce method:
	 *  - The previousValue argument is initialValue.
	 *  - The currentValue argument is the value of the first element present in the array.
	 *
	 * If an initialValue is not provided:
	 *  - The previousValue argument is the value of the first element present in the array.
	 *  - The currentValue argument is the value of the second element present in the array.
	 *
	 * @callback geomReduceCallback
	 * @param {*} previousValue The accumulated value previously returned in the last invocation
	 * of the callback, or initialValue, if supplied.
	 * @param {Geometry} currentGeometry The current Geometry being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 * @param {Object} featureProperties The current Feature Properties being processed.
	 * @param {Array<number>} featureBBox The current Feature BBox being processed.
	 * @param {number|string} featureId The current Feature Id being processed.
	 */

	/**
	 * Reduce geometry in any GeoJSON object, similar to Array.reduce().
	 *
	 * @name geomReduce
	 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
	 * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)
	 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
	 * @returns {*} The value that results from the reduction.
	 * @example
	 * var features = turf.featureCollection([
	 *     turf.point([26, 37], {foo: 'bar'}),
	 *     turf.point([36, 53], {hello: 'world'})
	 * ]);
	 *
	 * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
	 *   //=previousValue
	 *   //=currentGeometry
	 *   //=featureIndex
	 *   //=featureProperties
	 *   //=featureBBox
	 *   //=featureId
	 *   return currentGeometry
	 * });
	 */
	function geomReduce(geojson, callback, initialValue) {
	    var previousValue = initialValue;
	    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
	        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;
	        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);
	    });
	    return previousValue;
	}

	/**
	 * Callback for flattenEach
	 *
	 * @callback flattenEachCallback
	 * @param {Feature} currentFeature The current flattened feature being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
	 */

	/**
	 * Iterate over flattened features in any GeoJSON object, similar to
	 * Array.forEach.
	 *
	 * @name flattenEach
	 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
	 * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)
	 * @example
	 * var features = turf.featureCollection([
	 *     turf.point([26, 37], {foo: 'bar'}),
	 *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})
	 * ]);
	 *
	 * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {
	 *   //=currentFeature
	 *   //=featureIndex
	 *   //=multiFeatureIndex
	 * });
	 */
	function flattenEach(geojson, callback) {
	    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {
	        // Callback for single geometry
	        var type = (geometry === null) ? null : geometry.type;
	        switch (type) {
	        case null:
	        case 'Point':
	        case 'LineString':
	        case 'Polygon':
	            if (callback(helpers.feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;
	            return;
	        }

	        var geomType;

	        // Callback for multi-geometry
	        switch (type) {
	        case 'MultiPoint':
	            geomType = 'Point';
	            break;
	        case 'MultiLineString':
	            geomType = 'LineString';
	            break;
	        case 'MultiPolygon':
	            geomType = 'Polygon';
	            break;
	        }

	        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {
	            var coordinate = geometry.coordinates[multiFeatureIndex];
	            var geom = {
	                type: geomType,
	                coordinates: coordinate
	            };
	            if (callback(helpers.feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;
	        }
	    });
	}

	/**
	 * Callback for flattenReduce
	 *
	 * The first time the callback function is called, the values provided as arguments depend
	 * on whether the reduce method has an initialValue argument.
	 *
	 * If an initialValue is provided to the reduce method:
	 *  - The previousValue argument is initialValue.
	 *  - The currentValue argument is the value of the first element present in the array.
	 *
	 * If an initialValue is not provided:
	 *  - The previousValue argument is the value of the first element present in the array.
	 *  - The currentValue argument is the value of the second element present in the array.
	 *
	 * @callback flattenReduceCallback
	 * @param {*} previousValue The accumulated value previously returned in the last invocation
	 * of the callback, or initialValue, if supplied.
	 * @param {Feature} currentFeature The current Feature being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
	 */

	/**
	 * Reduce flattened features in any GeoJSON object, similar to Array.reduce().
	 *
	 * @name flattenReduce
	 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
	 * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)
	 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
	 * @returns {*} The value that results from the reduction.
	 * @example
	 * var features = turf.featureCollection([
	 *     turf.point([26, 37], {foo: 'bar'}),
	 *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})
	 * ]);
	 *
	 * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {
	 *   //=previousValue
	 *   //=currentFeature
	 *   //=featureIndex
	 *   //=multiFeatureIndex
	 *   return currentFeature
	 * });
	 */
	function flattenReduce(geojson, callback, initialValue) {
	    var previousValue = initialValue;
	    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {
	        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;
	        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);
	    });
	    return previousValue;
	}

	/**
	 * Callback for segmentEach
	 *
	 * @callback segmentEachCallback
	 * @param {Feature<LineString>} currentSegment The current Segment being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
	 * @param {number} geometryIndex The current index of the Geometry being processed.
	 * @param {number} segmentIndex The current index of the Segment being processed.
	 * @returns {void}
	 */

	/**
	 * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()
	 * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
	 *
	 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON
	 * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)
	 * @returns {void}
	 * @example
	 * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
	 *
	 * // Iterate over GeoJSON by 2-vertex segments
	 * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
	 *   //=currentSegment
	 *   //=featureIndex
	 *   //=multiFeatureIndex
	 *   //=geometryIndex
	 *   //=segmentIndex
	 * });
	 *
	 * // Calculate the total number of segments
	 * var total = 0;
	 * turf.segmentEach(polygon, function () {
	 *     total++;
	 * });
	 */
	function segmentEach(geojson, callback) {
	    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {
	        var segmentIndex = 0;

	        // Exclude null Geometries
	        if (!feature.geometry) return;
	        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
	        var type = feature.geometry.type;
	        if (type === 'Point' || type === 'MultiPoint') return;

	        // Generate 2-vertex line segments
	        var previousCoords;
	        var previousFeatureIndex = 0;
	        var previousMultiIndex = 0;
	        var prevGeomIndex = 0;
	        if (coordEach(feature, function (currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {
	            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`
	            if (previousCoords === undefined || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {
	                previousCoords = currentCoord;
	                previousFeatureIndex = featureIndex;
	                previousMultiIndex = multiPartIndexCoord;
	                prevGeomIndex = geometryIndex;
	                segmentIndex = 0;
	                return;
	            }
	            var currentSegment = helpers.lineString([previousCoords, currentCoord], feature.properties);
	            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;
	            segmentIndex++;
	            previousCoords = currentCoord;
	        }) === false) return false;
	    });
	}

	/**
	 * Callback for segmentReduce
	 *
	 * The first time the callback function is called, the values provided as arguments depend
	 * on whether the reduce method has an initialValue argument.
	 *
	 * If an initialValue is provided to the reduce method:
	 *  - The previousValue argument is initialValue.
	 *  - The currentValue argument is the value of the first element present in the array.
	 *
	 * If an initialValue is not provided:
	 *  - The previousValue argument is the value of the first element present in the array.
	 *  - The currentValue argument is the value of the second element present in the array.
	 *
	 * @callback segmentReduceCallback
	 * @param {*} previousValue The accumulated value previously returned in the last invocation
	 * of the callback, or initialValue, if supplied.
	 * @param {Feature<LineString>} currentSegment The current Segment being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
	 * @param {number} geometryIndex The current index of the Geometry being processed.
	 * @param {number} segmentIndex The current index of the Segment being processed.
	 */

	/**
	 * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()
	 * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
	 *
	 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON
	 * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)
	 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
	 * @returns {void}
	 * @example
	 * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
	 *
	 * // Iterate over GeoJSON by 2-vertex segments
	 * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
	 *   //= previousSegment
	 *   //= currentSegment
	 *   //= featureIndex
	 *   //= multiFeatureIndex
	 *   //= geometryIndex
	 *   //= segmentInex
	 *   return currentSegment
	 * });
	 *
	 * // Calculate the total number of segments
	 * var initialValue = 0
	 * var total = turf.segmentReduce(polygon, function (previousValue) {
	 *     previousValue++;
	 *     return previousValue;
	 * }, initialValue);
	 */
	function segmentReduce(geojson, callback, initialValue) {
	    var previousValue = initialValue;
	    var started = false;
	    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
	        if (started === false && initialValue === undefined) previousValue = currentSegment;
	        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);
	        started = true;
	    });
	    return previousValue;
	}

	/**
	 * Callback for lineEach
	 *
	 * @callback lineEachCallback
	 * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed
	 * @param {number} featureIndex The current index of the Feature being processed
	 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed
	 * @param {number} geometryIndex The current index of the Geometry being processed
	 */

	/**
	 * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,
	 * similar to Array.forEach.
	 *
	 * @name lineEach
	 * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object
	 * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)
	 * @example
	 * var multiLine = turf.multiLineString([
	 *   [[26, 37], [35, 45]],
	 *   [[36, 53], [38, 50], [41, 55]]
	 * ]);
	 *
	 * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
	 *   //=currentLine
	 *   //=featureIndex
	 *   //=multiFeatureIndex
	 *   //=geometryIndex
	 * });
	 */
	function lineEach(geojson, callback) {
	    // validation
	    if (!geojson) throw new Error('geojson is required');

	    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {
	        if (feature.geometry === null) return;
	        var type = feature.geometry.type;
	        var coords = feature.geometry.coordinates;
	        switch (type) {
	        case 'LineString':
	            if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false) return false;
	            break;
	        case 'Polygon':
	            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {
	                if (callback(helpers.lineString(coords[geometryIndex], feature.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
	            }
	            break;
	        }
	    });
	}

	/**
	 * Callback for lineReduce
	 *
	 * The first time the callback function is called, the values provided as arguments depend
	 * on whether the reduce method has an initialValue argument.
	 *
	 * If an initialValue is provided to the reduce method:
	 *  - The previousValue argument is initialValue.
	 *  - The currentValue argument is the value of the first element present in the array.
	 *
	 * If an initialValue is not provided:
	 *  - The previousValue argument is the value of the first element present in the array.
	 *  - The currentValue argument is the value of the second element present in the array.
	 *
	 * @callback lineReduceCallback
	 * @param {*} previousValue The accumulated value previously returned in the last invocation
	 * of the callback, or initialValue, if supplied.
	 * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.
	 * @param {number} featureIndex The current index of the Feature being processed
	 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed
	 * @param {number} geometryIndex The current index of the Geometry being processed
	 */

	/**
	 * Reduce features in any GeoJSON object, similar to Array.reduce().
	 *
	 * @name lineReduce
	 * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object
	 * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)
	 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
	 * @returns {*} The value that results from the reduction.
	 * @example
	 * var multiPoly = turf.multiPolygon([
	 *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),
	 *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])
	 * ]);
	 *
	 * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
	 *   //=previousValue
	 *   //=currentLine
	 *   //=featureIndex
	 *   //=multiFeatureIndex
	 *   //=geometryIndex
	 *   return currentLine
	 * });
	 */
	function lineReduce(geojson, callback, initialValue) {
	    var previousValue = initialValue;
	    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
	        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;
	        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);
	    });
	    return previousValue;
	}

	/**
	 * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.
	 *
	 * Negative indexes are permitted.
	 * Point & MultiPoint will always return null.
	 *
	 * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry
	 * @param {Object} [options={}] Optional parameters
	 * @param {number} [options.featureIndex=0] Feature Index
	 * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index
	 * @param {number} [options.geometryIndex=0] Geometry Index
	 * @param {number} [options.segmentIndex=0] Segment Index
	 * @param {Object} [options.properties={}] Translate Properties to output LineString
	 * @param {BBox} [options.bbox={}] Translate BBox to output LineString
	 * @param {number|string} [options.id={}] Translate Id to output LineString
	 * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString
	 * @example
	 * var multiLine = turf.multiLineString([
	 *     [[10, 10], [50, 30], [30, 40]],
	 *     [[-10, -10], [-50, -30], [-30, -40]]
	 * ]);
	 *
	 * // First Segment (defaults are 0)
	 * turf.findSegment(multiLine);
	 * // => Feature<LineString<[[10, 10], [50, 30]]>>
	 *
	 * // First Segment of 2nd Multi Feature
	 * turf.findSegment(multiLine, {multiFeatureIndex: 1});
	 * // => Feature<LineString<[[-10, -10], [-50, -30]]>>
	 *
	 * // Last Segment of Last Multi Feature
	 * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});
	 * // => Feature<LineString<[[-50, -30], [-30, -40]]>>
	 */
	function findSegment(geojson, options) {
	    // Optional Parameters
	    options = options || {};
	    if (!helpers.isObject(options)) throw new Error('options is invalid');
	    var featureIndex = options.featureIndex || 0;
	    var multiFeatureIndex = options.multiFeatureIndex || 0;
	    var geometryIndex = options.geometryIndex || 0;
	    var segmentIndex = options.segmentIndex || 0;

	    // Find FeatureIndex
	    var properties = options.properties;
	    var geometry;

	    switch (geojson.type) {
	    case 'FeatureCollection':
	        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;
	        properties = properties || geojson.features[featureIndex].properties;
	        geometry = geojson.features[featureIndex].geometry;
	        break;
	    case 'Feature':
	        properties = properties || geojson.properties;
	        geometry = geojson.geometry;
	        break;
	    case 'Point':
	    case 'MultiPoint':
	        return null;
	    case 'LineString':
	    case 'Polygon':
	    case 'MultiLineString':
	    case 'MultiPolygon':
	        geometry = geojson;
	        break;
	    default:
	        throw new Error('geojson is invalid');
	    }

	    // Find SegmentIndex
	    if (geometry === null) return null;
	    var coords = geometry.coordinates;
	    switch (geometry.type) {
	    case 'Point':
	    case 'MultiPoint':
	        return null;
	    case 'LineString':
	        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;
	        return helpers.lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);
	    case 'Polygon':
	        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;
	        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;
	        return helpers.lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);
	    case 'MultiLineString':
	        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
	        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;
	        return helpers.lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);
	    case 'MultiPolygon':
	        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
	        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
	        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;
	        return helpers.lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);
	    }
	    throw new Error('geojson is invalid');
	}

	/**
	 * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.
	 *
	 * Negative indexes are permitted.
	 *
	 * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry
	 * @param {Object} [options={}] Optional parameters
	 * @param {number} [options.featureIndex=0] Feature Index
	 * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index
	 * @param {number} [options.geometryIndex=0] Geometry Index
	 * @param {number} [options.coordIndex=0] Coord Index
	 * @param {Object} [options.properties={}] Translate Properties to output Point
	 * @param {BBox} [options.bbox={}] Translate BBox to output Point
	 * @param {number|string} [options.id={}] Translate Id to output Point
	 * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point
	 * @example
	 * var multiLine = turf.multiLineString([
	 *     [[10, 10], [50, 30], [30, 40]],
	 *     [[-10, -10], [-50, -30], [-30, -40]]
	 * ]);
	 *
	 * // First Segment (defaults are 0)
	 * turf.findPoint(multiLine);
	 * // => Feature<Point<[10, 10]>>
	 *
	 * // First Segment of the 2nd Multi-Feature
	 * turf.findPoint(multiLine, {multiFeatureIndex: 1});
	 * // => Feature<Point<[-10, -10]>>
	 *
	 * // Last Segment of last Multi-Feature
	 * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});
	 * // => Feature<Point<[-30, -40]>>
	 */
	function findPoint(geojson, options) {
	    // Optional Parameters
	    options = options || {};
	    if (!helpers.isObject(options)) throw new Error('options is invalid');
	    var featureIndex = options.featureIndex || 0;
	    var multiFeatureIndex = options.multiFeatureIndex || 0;
	    var geometryIndex = options.geometryIndex || 0;
	    var coordIndex = options.coordIndex || 0;

	    // Find FeatureIndex
	    var properties = options.properties;
	    var geometry;

	    switch (geojson.type) {
	    case 'FeatureCollection':
	        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;
	        properties = properties || geojson.features[featureIndex].properties;
	        geometry = geojson.features[featureIndex].geometry;
	        break;
	    case 'Feature':
	        properties = properties || geojson.properties;
	        geometry = geojson.geometry;
	        break;
	    case 'Point':
	    case 'MultiPoint':
	        return null;
	    case 'LineString':
	    case 'Polygon':
	    case 'MultiLineString':
	    case 'MultiPolygon':
	        geometry = geojson;
	        break;
	    default:
	        throw new Error('geojson is invalid');
	    }

	    // Find Coord Index
	    if (geometry === null) return null;
	    var coords = geometry.coordinates;
	    switch (geometry.type) {
	    case 'Point':
	        return helpers.point(coords, properties, options);
	    case 'MultiPoint':
	        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
	        return helpers.point(coords[multiFeatureIndex], properties, options);
	    case 'LineString':
	        if (coordIndex < 0) coordIndex = coords.length + coordIndex;
	        return helpers.point(coords[coordIndex], properties, options);
	    case 'Polygon':
	        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;
	        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;
	        return helpers.point(coords[geometryIndex][coordIndex], properties, options);
	    case 'MultiLineString':
	        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
	        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;
	        return helpers.point(coords[multiFeatureIndex][coordIndex], properties, options);
	    case 'MultiPolygon':
	        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
	        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
	        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;
	        return helpers.point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);
	    }
	    throw new Error('geojson is invalid');
	}

	exports.coordEach = coordEach;
	exports.coordReduce = coordReduce;
	exports.propEach = propEach;
	exports.propReduce = propReduce;
	exports.featureEach = featureEach;
	exports.featureReduce = featureReduce;
	exports.coordAll = coordAll;
	exports.geomEach = geomEach;
	exports.geomReduce = geomReduce;
	exports.flattenEach = flattenEach;
	exports.flattenReduce = flattenReduce;
	exports.segmentEach = segmentEach;
	exports.segmentReduce = segmentReduce;
	exports.lineEach = lineEach;
	exports.lineReduce = lineReduce;
	exports.findSegment = findSegment;
	exports.findPoint = findPoint;
	});

	unwrapExports(meta$1);
	var meta_1 = meta$1.coordEach;
	var meta_2 = meta$1.coordReduce;
	var meta_3 = meta$1.propEach;
	var meta_4 = meta$1.propReduce;
	var meta_5 = meta$1.featureEach;
	var meta_6 = meta$1.featureReduce;
	var meta_7 = meta$1.coordAll;
	var meta_8 = meta$1.geomEach;
	var meta_9 = meta$1.geomReduce;
	var meta_10 = meta$1.flattenEach;
	var meta_11 = meta$1.flattenReduce;
	var meta_12 = meta$1.segmentEach;
	var meta_13 = meta$1.segmentReduce;
	var meta_14 = meta$1.lineEach;
	var meta_15 = meta$1.lineReduce;
	var meta_16 = meta$1.findSegment;
	var meta_17 = meta$1.findPoint;

	var area_1 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });

	// Note: change RADIUS => earthRadius
	var RADIUS = 6378137;
	/**
	 * Takes one or more features and returns their area in square meters.
	 *
	 * @name area
	 * @param {GeoJSON} geojson input GeoJSON feature(s)
	 * @returns {number} area in square meters
	 * @example
	 * var polygon = turf.polygon([[[125, -15], [113, -22], [154, -27], [144, -15], [125, -15]]]);
	 *
	 * var area = turf.area(polygon);
	 *
	 * //addToMap
	 * var addToMap = [polygon]
	 * polygon.properties.area = area
	 */
	function area(geojson) {
	    return meta$1.geomReduce(geojson, function (value, geom) {
	        return value + calculateArea(geom);
	    }, 0);
	}
	exports.default = area;
	/**
	 * Calculate Area
	 *
	 * @private
	 * @param {Geometry} geom GeoJSON Geometries
	 * @returns {number} area
	 */
	function calculateArea(geom) {
	    var total = 0;
	    var i;
	    switch (geom.type) {
	        case "Polygon":
	            return polygonArea(geom.coordinates);
	        case "MultiPolygon":
	            for (i = 0; i < geom.coordinates.length; i++) {
	                total += polygonArea(geom.coordinates[i]);
	            }
	            return total;
	        case "Point":
	        case "MultiPoint":
	        case "LineString":
	        case "MultiLineString":
	            return 0;
	    }
	    return 0;
	}
	function polygonArea(coords) {
	    var total = 0;
	    if (coords && coords.length > 0) {
	        total += Math.abs(ringArea(coords[0]));
	        for (var i = 1; i < coords.length; i++) {
	            total -= Math.abs(ringArea(coords[i]));
	        }
	    }
	    return total;
	}
	/**
	 * @private
	 * Calculate the approximate area of the polygon were it projected onto the earth.
	 * Note that this area will be positive if ring is oriented clockwise, otherwise it will be negative.
	 *
	 * Reference:
	 * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for Polygons on a Sphere",
	 * JPL Publication 07-03, Jet Propulsion
	 * Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409
	 *
	 * @param {Array<Array<number>>} coords Ring Coordinates
	 * @returns {number} The approximate signed geodesic area of the polygon in square meters.
	 */
	function ringArea(coords) {
	    var p1;
	    var p2;
	    var p3;
	    var lowerIndex;
	    var middleIndex;
	    var upperIndex;
	    var i;
	    var total = 0;
	    var coordsLength = coords.length;
	    if (coordsLength > 2) {
	        for (i = 0; i < coordsLength; i++) {
	            if (i === coordsLength - 2) {
	                lowerIndex = coordsLength - 2;
	                middleIndex = coordsLength - 1;
	                upperIndex = 0;
	            }
	            else if (i === coordsLength - 1) {
	                lowerIndex = coordsLength - 1;
	                middleIndex = 0;
	                upperIndex = 1;
	            }
	            else {
	                lowerIndex = i;
	                middleIndex = i + 1;
	                upperIndex = i + 2;
	            }
	            p1 = coords[lowerIndex];
	            p2 = coords[middleIndex];
	            p3 = coords[upperIndex];
	            total += (rad(p3[0]) - rad(p1[0])) * Math.sin(rad(p2[1]));
	        }
	        total = total * RADIUS * RADIUS / 2;
	    }
	    return total;
	}
	function rad(num) {
	    return num * Math.PI / 180;
	}
	});

	var area = unwrapExports(area_1);

	var props = {
	  mode: {
	    type: Number,
	    default: 1
	  },
	  font: {
	    type: String,
	    default: '100 20px SimSun'
	  },
	  fillColor: {
	    type: String | Object | Array,
	    default: 'WHITE'
	  },
	  labelStyle: {
	    type: Number,
	    default: 2
	  },
	  showBackground: {
	    type: Boolean,
	    default: true
	  },
	  backgroundColor: {
	    type: String | Object | Array,
	    default: 'rgba(38, 38, 38, 0.85)'
	  },
	  outlineWidth: {
	    type: Number,
	    default: 1
	  },
	  outlineColor: {
	    type: String | Object | Array,
	    default: 'BLUE'
	  },
	  pixelOffset: {
	    type: Object,
	    default: function _default() {
	      return {
	        x: 15,
	        y: -20
	      };
	    }
	  },
	  pointColor: {
	    type: String | Object | Array,
	    default: 'rgb(255,229,0)'
	  },
	  pointPixelSize: {
	    type: Number,
	    default: 8
	  },
	  polylineMaterial: {
	    type: Object,
	    default: function _default() {
	      return {
	        fabric: {
	          type: 'Color',
	          uniforms: {
	            color: '#51ff00'
	          }
	        }
	      };
	    }
	  },
	  polylineWidth: {
	    type: Number,
	    default: 2
	  },
	  depthTest: {
	    type: Boolean,
	    default: false
	  }
	};
	var watch$1 = {
	  measuring: function measuring(val) {
	    var nextTick, polylines, startNew, type, $parent, getParent, polyline, measureCmpNames, drawCmpNames, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, $node, listener;

	    return regenerator.async(function measuring$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            nextTick = false;
	            polylines = this.polylines, startNew = this.startNew, type = this.type, $parent = this.$parent, getParent = this.getParent;
	            polyline = polylines[polylines.length - 1];

	            if (!(!val && polyline && !polyline.positions.length)) {
	              _context.next = 7;
	              break;
	            }

	            this.polylines.pop();
	            _context.next = 42;
	            break;

	          case 7:
	            if (!val) {
	              _context.next = 42;
	              break;
	            }

	            measureCmpNames = [];
	            _context.t0 = type;
	            _context.next = _context.t0 === 'distanceMeasuring' ? 12 : _context.t0 === 'areaMeasuring' ? 15 : _context.t0 === 'heightMeasuring' ? 18 : 21;
	            break;

	          case 12:
	            measureCmpNames.push('vc-measure-height');
	            measureCmpNames.push('vc-measure-area');
	            return _context.abrupt("break", 21);

	          case 15:
	            measureCmpNames.push('vc-measure-distance');
	            measureCmpNames.push('vc-measure-height');
	            return _context.abrupt("break", 21);

	          case 18:
	            measureCmpNames.push('vc-measure-distance');
	            measureCmpNames.push('vc-measure-area');
	            return _context.abrupt("break", 21);

	          case 21:
	            drawCmpNames = ['vc-handler-draw-polyline', 'vc-handler-draw-point', 'vc-handler-draw-polygon'];
	            _iteratorNormalCompletion = true;
	            _didIteratorError = false;
	            _iteratorError = undefined;
	            _context.prev = 25;

	            for (_iterator = getIterator$1(getParent($parent).$slots.default || []); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	              $node = _step.value;

	              if ($node.componentOptions && measureCmpNames.indexOf($node.componentOptions.tag) !== -1) {
	                $node.child.measuring = false;
	                nextTick = true;
	              }

	              if ($node.componentOptions && drawCmpNames.indexOf($node.componentOptions.tag) !== -1) {
	                $node.child.drawing = false;
	                nextTick = true;
	              }
	            }

	            _context.next = 33;
	            break;

	          case 29:
	            _context.prev = 29;
	            _context.t1 = _context["catch"](25);
	            _didIteratorError = true;
	            _iteratorError = _context.t1;

	          case 33:
	            _context.prev = 33;
	            _context.prev = 34;

	            if (!_iteratorNormalCompletion && _iterator.return != null) {
	              _iterator.return();
	            }

	          case 36:
	            _context.prev = 36;

	            if (!_didIteratorError) {
	              _context.next = 39;
	              break;
	            }

	            throw _iteratorError;

	          case 39:
	            return _context.finish(36);

	          case 40:
	            return _context.finish(33);

	          case 41:
	            startNew();

	          case 42:
	            _context.t2 = nextTick;

	            if (!_context.t2) {
	              _context.next = 46;
	              break;
	            }

	            _context.next = 46;
	            return regenerator.awrap(this.$nextTick());

	          case 46:
	            this.viewer.canvas.setAttribute('style', val ? 'cursor: crosshair' : 'cursor: auto');
	            listener = this.$listeners.activeEvt;
	            listener && this.$emit('activeEvt', {
	              type: type,
	              isActive: val
	            });

	          case 49:
	          case "end":
	            return _context.stop();
	        }
	      }
	    }, null, this, [[25, 29, 33, 41], [34,, 36, 40]]);
	  }
	};
	var methods$a = {
	  createCesiumObject: function createCesiumObject() {
	    var viewer, handler;
	    return regenerator.async(function createCesiumObject$(_context2) {
	      while (1) {
	        switch (_context2.prev = _context2.next) {
	          case 0:
	            viewer = this.viewer;
	            viewer.scene.frameState.morphTime = 0;
	            handler = new Cesium.ScreenSpaceEventHandler(viewer.canvas);
	            handler.setInputAction(this.LEFT_CLICK, Cesium.ScreenSpaceEventType.LEFT_CLICK);
	            handler.setInputAction(this.MOUSE_MOVE, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
	            handler.setInputAction(this.RIGHT_CLICK, Cesium.ScreenSpaceEventType.RIGHT_CLICK);
	            this.handler = handler;
	            this.enterMoveAction = false;
	            this.lastCartesianRemoved = false;
	            return _context2.abrupt("return", this.polylines);

	          case 10:
	          case "end":
	            return _context2.stop();
	        }
	      }
	    }, null, this);
	  },
	  mount: function mount() {
	    return regenerator.async(function mount$(_context3) {
	      while (1) {
	        switch (_context3.prev = _context3.next) {
	          case 0:
	            return _context3.abrupt("return", true);

	          case 1:
	          case "end":
	            return _context3.stop();
	        }
	      }
	    });
	  },
	  unmount: function unmount() {
	    return regenerator.async(function unmount$(_context4) {
	      while (1) {
	        switch (_context4.prev = _context4.next) {
	          case 0:
	            return _context4.abrupt("return", true);

	          case 1:
	          case "end":
	            return _context4.stop();
	        }
	      }
	    });
	  },
	  LEFT_CLICK: function LEFT_CLICK(movement) {
	    if (!this.measuring) {
	      return;
	    }

	    var Cesium = this.Cesium,
	        viewer = this.viewer,
	        polylines = this.polylines,
	        type = this.type,
	        onMeasureEvt = this.onMeasureEvt;
	    var cartesian = viewer.scene.pickPosition(movement.position);

	    if (!Cesium.defined(cartesian)) {
	      return;
	    }

	    var nIndex = polylines.length - 1;
	    var polyline = polylines[nIndex];

	    if (type === 'distanceMeasuring' || type === 'areaMeasuring') {
	      // 鼠标移动事件添加的移动点需要移除
	      if (this.enterMoveAction) {
	        polyline.positions.pop();
	        polyline.distances && polyline.distances.pop();
	        this.lastCartesianRemoved = true;
	      }
	    }

	    polyline.positions.push(cartesian);
	    var length = polyline.positions.length;

	    if (length > 1) {
	      // 重复点不计算
	      if (Cesium.Cartesian3.distance(polyline.positions[length - 1], polyline.positions[length - 2]) < 1e-3) {
	        polyline.positions.pop();
	        return;
	      }
	    }

	    switch (type) {
	      case 'distanceMeasuring':
	        polyline.distance = this.getDistance(polyline.positions);
	        polyline.distances.push(polyline.distance);
	        onMeasureEvt(polyline, nIndex);
	        break;

	      case 'areaMeasuring':
	        polyline.area = this.getSurfaceArea(polyline.positions);
	        polyline.projectedArea = this.getProjectedArea(polyline.positions);
	        polyline.distance = this.getDistance(polyline.positions);
	        polyline.distances.push(polyline.distance);

	        if (polyline.positions.length > 2 && !this.enterMoveAction) {
	          if (this.moveLastDistance) {
	            polyline.distances.pop();
	          }

	          var clonePoistions = Cesium.clone(polyline.positions, true);
	          clonePoistions.push(polyline.positions[0]);
	          var distance = this.getDistance(clonePoistions);
	          polyline.distances.push(distance);
	          polyline.distance = distance;
	          this.moveLastDistance = true;
	        }

	        onMeasureEvt(polyline, nIndex);
	        break;

	      case 'heightMeasuring':
	        polyline.positions.pop();

	        if (polyline.positions.length === 0) {
	          polyline.positions.push(cartesian);
	          this.startPoint = cartesian;
	        }

	        onMeasureEvt(polyline, this.labels);
	        break;
	    }
	  },
	  MOUSE_MOVE: function MOUSE_MOVE(movement) {
	    var viewer, polylines, onMeasureEvt, type, nIndex, polyline, cartesian, listener, distance, _distance, clonePoistions, labels;

	    return regenerator.async(function MOUSE_MOVE$(_context5) {
	      while (1) {
	        switch (_context5.prev = _context5.next) {
	          case 0:
	            if (this.measuring) {
	              _context5.next = 2;
	              break;
	            }

	            return _context5.abrupt("return");

	          case 2:
	            viewer = this.viewer, polylines = this.polylines, onMeasureEvt = this.onMeasureEvt, type = this.type;

	            if (polylines.length) {
	              _context5.next = 5;
	              break;
	            }

	            return _context5.abrupt("return");

	          case 5:
	            nIndex = polylines.length - 1;
	            polyline = polylines[nIndex];

	            if (polyline.positions.length) {
	              _context5.next = 9;
	              break;
	            }

	            return _context5.abrupt("return");

	          case 9:
	            cartesian = viewer.scene.pickPosition(movement.endPosition);

	            if (Cesium.defined(cartesian)) {
	              _context5.next = 12;
	              break;
	            }

	            return _context5.abrupt("return");

	          case 12:
	            this.enterMoveAction = true;
	            listener = this.$listeners.movingEvt;
	            listener && this.$emit('movingEvt', movement.endPosition, type);

	            if (!(type === 'distanceMeasuring' || type === 'areaMeasuring')) {
	              _context5.next = 25;
	              break;
	            }

	            if (polyline.positions.length >= 2) {
	              // 如果鼠标左键点击事件移除了 不需要再移除
	              if (!this.lastCartesianRemoved) {
	                polyline.positions.pop();
	                polyline.distances && polyline.distances.pop();
	              }

	              if (type === 'areaMeasuring') {
	                polyline.distances && polyline.distances.pop();
	              }
	            }

	            polyline.positions.push(cartesian);
	            this.lastCartesianRemoved = false;

	            if (type === 'distanceMeasuring') {
	              distance = this.getDistance(polyline.positions);
	              polyline.distances.push(distance);
	              polyline.distance = distance;
	              nIndex = polylines.reduce(function (pre, cur) {
	                return pre + cur.positions.length - 1;
	              }, 0) - 1;
	            } else {
	              polyline.area = this.getSurfaceArea(polyline.positions);
	              polyline.projectedArea = this.getProjectedArea(polyline.positions);
	              _distance = this.getDistance(polyline.positions);
	              polyline.distances.push(_distance);
	              polyline.distance = _distance;

	              if (polyline.positions.length >= 2) {
	                clonePoistions = Cesium.clone(polyline.positions, true);
	                clonePoistions.push(polyline.positions[0]);
	                _distance = this.getDistance(clonePoistions);
	                polyline.distances.push(_distance);
	                polyline.distance = _distance;
	              }
	            }

	            _context5.next = 22;
	            return regenerator.awrap(this.$nextTick());

	          case 22:
	            onMeasureEvt(polyline, nIndex);
	            _context5.next = 30;
	            break;

	          case 25:
	            labels = this.labels;
	            this.getHeight(cartesian, polyline);
	            _context5.next = 29;
	            return regenerator.awrap(this.$nextTick());

	          case 29:
	            onMeasureEvt(polyline, labels);

	          case 30:
	          case "end":
	            return _context5.stop();
	        }
	      }
	    }, null, this);
	  },
	  RIGHT_CLICK: function RIGHT_CLICK(movement) {
	    var viewer, polylines, mode, startNew, onMeasureEvt, type, removeLastPosition, nIndex, polyline, cartesian, getDistance, getSurfaceArea, getProjectedArea, clonePoistions, distance, labels;
	    return regenerator.async(function RIGHT_CLICK$(_context6) {
	      while (1) {
	        switch (_context6.prev = _context6.next) {
	          case 0:
	            if (this.measuring) {
	              _context6.next = 2;
	              break;
	            }

	            return _context6.abrupt("return");

	          case 2:
	            viewer = this.viewer, polylines = this.polylines, mode = this.mode, startNew = this.startNew, onMeasureEvt = this.onMeasureEvt, type = this.type, removeLastPosition = this.removeLastPosition;

	            if (polylines.length) {
	              _context6.next = 5;
	              break;
	            }

	            return _context6.abrupt("return");

	          case 5:
	            nIndex = polylines.length - 1;
	            polyline = polylines[nIndex];

	            if (!(polyline.positions.length === 0)) {
	              _context6.next = 9;
	              break;
	            }

	            return _context6.abrupt("return");

	          case 9:
	            cartesian = viewer.scene.pickPosition(movement.position);

	            if (Cesium.defined(cartesian)) {
	              _context6.next = 12;
	              break;
	            }

	            return _context6.abrupt("return");

	          case 12:
	            if (type === 'distanceMeasuring') {
	              if (removeLastPosition) {
	                polyline.positions.pop();
	                polyline.distances.pop();
	              }

	              getDistance = this.getDistance;
	              polyline.distance = getDistance(polyline.positions);

	              if (polyline.positions.length === 1) {
	                polyline.positions = [];
	              }

	              nIndex = polylines.reduce(function (pre, cur) {
	                return pre + cur.positions.length - 1;
	              }, 0) - 1;
	            } else if (type === 'areaMeasuring') {
	              if (removeLastPosition) {
	                polyline.positions.pop();
	                polyline.distances.pop();
	              }

	              getSurfaceArea = this.getSurfaceArea, getProjectedArea = this.getProjectedArea;
	              polyline.area = getSurfaceArea(polyline.positions);
	              polyline.projectedArea = getProjectedArea(polyline.positions);
	              polyline.distance = this.getDistance(polyline.positions);

	              if (polyline.positions.length >= 2 && this.enterMoveAction) {
	                polyline.distances.pop();
	                clonePoistions = Cesium.clone(polyline.positions, true);
	                clonePoistions.push(polyline.positions[0]);
	                distance = this.getDistance(clonePoistions);
	                polyline.distances.push(distance);
	                polyline.distance = distance;
	              }

	              this.moveLastDistance = false;

	              if (polyline.positions.length <= 2) {
	                polyline.positions = [];
	              }
	            } else {
	              this.getHeight(cartesian, polyline);
	            }

	            if (mode === 0) {
	              startNew();
	            } else {
	              this.measuring = false;
	            }

	            _context6.next = 16;
	            return regenerator.awrap(this.$nextTick());

	          case 16:
	            if (type === 'distanceMeasuring' || type === 'areaMeasuring') {
	              onMeasureEvt(polyline, nIndex, true);
	            } else {
	              labels = this.labels;
	              onMeasureEvt(polyline, labels, true);
	            }

	          case 17:
	          case "end":
	            return _context6.stop();
	        }
	      }
	    }, null, this);
	  },
	  startNew: function startNew() {
	    var polylines = this.polylines,
	        type = this.type;

	    if (!Cesium.defined(polylines)) {
	      return;
	    }

	    var polyline = {
	      positions: []
	    };

	    if (type === 'distanceMeasuring') {
	      assign$1(polyline, {
	        distances: [],
	        distance: 0
	      });
	    } else if (type === 'areaMeasuring') {
	      assign$1(polyline, {
	        area: 0,
	        projectedArea: 0,
	        distances: [],
	        distance: 0
	      });
	    } else {
	      assign$1(polyline, {
	        distanceH: 0,
	        height: 0,
	        distanceS: 0
	      });
	    }

	    polylines.push(polyline);
	  },

	  /**
	   * 根据传入坐标数组计算距离。
	   * @param {Array.Cartesian3} positions 传入的坐标数组
	   * @returns {Number} 返回长度数值。
	   */
	  getDistance: function getDistance(positions) {
	    var _Cesium = Cesium,
	        Cartesian3 = _Cesium.Cartesian3;
	    var clampToGround = this.clampToGround,
	        getGeodesicDistance = this.getGeodesicDistance;
	    var distance = 0;

	    for (var i = 0; i < positions.length - 1; i++) {
	      var s = 0;

	      if (clampToGround) {
	        // Cartesian.distance gives the straight line distance between the two points, ignoring curvature. This is not what we want.
	        // Cartesian3.distance 计算的是两点之间的直线距离，忽略了地球曲率，贴地时不太合理。
	        // 2.0.3 版本增加测地线距离（GeodesicDistance）。
	        s = getGeodesicDistance(positions[i], positions[i + 1]);
	      } else {
	        s = Cartesian3.distance(positions[i], positions[i + 1]);
	      }

	      distance = distance + s;
	    }

	    return distance;
	  },

	  /**
	   * 返回两点之间的测地距离。
	   * @param {Cartesian3} pointOne 第一个坐标点
	   * @param {Cartesian3} pointTwo 第二个坐标点
	   * @returns {Number} 返回两点之间的测地距离。
	   */
	  getGeodesicDistance: function getGeodesicDistance(pointOne, pointTwo) {
	    var _Cesium2 = Cesium,
	        Ellipsoid = _Cesium2.Ellipsoid,
	        EllipsoidGeodesic = _Cesium2.EllipsoidGeodesic;
	    var pickedPointCartographic = Ellipsoid.WGS84.cartesianToCartographic(pointOne);
	    var lastPointCartographic = Ellipsoid.WGS84.cartesianToCartographic(pointTwo);
	    var geodesic = new EllipsoidGeodesic(pickedPointCartographic, lastPointCartographic);
	    return geodesic.surfaceDistance;
	  },
	  getHeight: function getHeight(endPoint, polyline) {
	    var labels = this.labels; // let endPoint = cartesian

	    var normalStart = {};
	    Cesium.Cartesian3.normalize(this.startPoint, normalStart);
	    var planeStart = new Cesium.Plane(normalStart, -Cesium.Cartesian3.distance(this.startPoint, new Cesium.Cartesian3(0, 0, 0)));
	    var hypPoint = {};
	    polyline.height = Cesium.Plane.getPointDistance(planeStart, endPoint);
	    var labelPositonHeight = {};
	    var labelPositonH = {};
	    var labelPositonS = {};

	    if (polyline.height <= 0) {
	      Cesium.Plane.projectPointOntoPlane(planeStart, endPoint, hypPoint);
	      Cesium.Cartesian3.midpoint(endPoint, hypPoint, labelPositonHeight);
	      Cesium.Cartesian3.midpoint(this.startPoint, hypPoint, labelPositonH);
	      polyline.distanceH = Cesium.Cartesian3.distance(this.startPoint, hypPoint);
	    } else {
	      var normalEnd = {};
	      Cesium.Cartesian3.normalize(endPoint, normalEnd);
	      var planeEnd = new Cesium.Plane(normalStart, -Cesium.Cartesian3.distance(endPoint, new Cesium.Cartesian3(0, 0, 0)));
	      Cesium.Plane.projectPointOntoPlane(planeEnd, this.startPoint, hypPoint);
	      Cesium.Cartesian3.midpoint(this.startPoint, hypPoint, labelPositonHeight);
	      Cesium.Cartesian3.midpoint(endPoint, hypPoint, labelPositonH);
	      polyline.distanceH = Cesium.Cartesian3.distance(endPoint, hypPoint);
	    }

	    polyline.distanceS = Cesium.Cartesian3.distance(this.startPoint, endPoint);
	    Cesium.Cartesian3.midpoint(this.startPoint, endPoint, labelPositonS);
	    polyline.height = Math.abs(polyline.height);

	    if (polyline.positions.length !== 1) {
	      polyline.positions.pop();
	      polyline.positions.pop();
	      labels.pop();
	      labels.pop();
	      labels.pop();
	    }

	    polyline.positions.push(endPoint);
	    polyline.positions.push(hypPoint);
	    var labelTextHeight = polyline.height > 1000 ? (polyline.height / 1000).toFixed(2) + 'km' : polyline.height.toFixed(2) + 'm';
	    labels.push({
	      text: this.$vc.lang.measure.verticalHeight + ': ' + labelTextHeight,
	      position: labelPositonHeight
	    });
	    var labelTextH = polyline.distanceH > 1000 ? (polyline.distanceH / 1000).toFixed(2) + 'km' : polyline.distanceH.toFixed(2) + 'm';
	    labels.push({
	      text: this.$vc.lang.measure.horizontalDistance + ': ' + labelTextH,
	      position: labelPositonH
	    });
	    var labelTextS = polyline.distanceS > 1000 ? (polyline.distanceS / 1000).toFixed(2) + 'km' : polyline.distanceS.toFixed(2) + 'm';
	    labels.push({
	      text: this.$vc.lang.measure.spaceDistance + ': ' + labelTextS,
	      position: labelPositonS
	    });
	  },
	  onMeasureEvt: function onMeasureEvt(polyline, index) {
	    var flag = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

	    if (!this.depthTest) {
	      var rs = Cesium.RenderState.fromCache({
	        depthMask: true,
	        depthTest: {
	          enabled: false
	        }
	      });

	      if (Cesium.SuperMapImageryProvider) {
	        this.$refs.polylineCollection && (this.$refs.polylineCollection.cesiumObject._opaqueRS = rs);
	      } else {
	        this.$refs.polylineCollection && (this.$refs.polylineCollection.cesiumObject._opaqueRS.depthTest.enabled = false);
	      }

	      this.$refs.pointCollection && (this.$refs.pointCollection.cesiumObject._rsOpaque = rs);
	      this.$refs.labelCollection.cesiumObject._billboardCollection._rsTranslucent = rs;
	      this.$refs.labelCollection.cesiumObject._backgroundBillboardCollection._rsTranslucent = rs;
	      var listener = this.$listeners.measureEvt;
	      var type = this.type;

	      if (type === 'distanceMeasuring' || type === 'areaMeasuring') {
	        listener && this.$emit('measureEvt', {
	          polyline: polyline,
	          label: this.$refs.labelCollection.cesiumObject.get(index),
	          type: type,
	          finished: flag
	        });
	      } else {
	        var labels = index;
	        var labelsResult = {
	          labelHeight: this.$refs.labelCollection.cesiumObject.get(labels.length - 3),
	          labelH: this.$refs.labelCollection.cesiumObject.get(labels.length - 2),
	          labelS: this.$refs.labelCollection.cesiumObject.get(labels.length - 1)
	        };
	        listener && this.$emit('measureEvt', {
	          polyline: polyline,
	          label: labelsResult,
	          type: 'heightMeasuring',
	          finished: flag
	        });
	      }
	    }
	  }
	};
	var mixinMeasure = {
	  mixins: [cmp],
	  props: props,
	  watch: watch$1,
	  methods: methods$a,
	  created: function created() {
	    var _this = this;

	    defineProperties$1(this, {
	      polyline: {
	        enumerable: true,
	        get: function get() {
	          return _this.polyline;
	        }
	      }
	    });
	  },
	  destroyed: function destroyed() {
	    var handler = this.handler;

	    if (handler) {
	      handler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_CLICK);
	      handler.removeInputAction(Cesium.ScreenSpaceEventType.MOUSE_MOVE);
	      handler.removeInputAction(Cesium.ScreenSpaceEventType.RIGHT_CLICK);
	      handler.destroy();
	    }
	  }
	};

	//
	var script$1u = {
	  name: 'vc-measure-area',
	  mixins: [mixinMeasure],
	  data: function data() {
	    return {
	      index: 0,
	      type: 'areaMeasuring',
	      measuring: false,
	      polylines: [],
	      nowaiting: true
	    };
	  },
	  props: {
	    removeLastPosition: {
	      type: Boolean,
	      default: true
	    },
	    clampToGround: {
	      type: Boolean,
	      default: false
	    },
	    alongLine: {
	      type: Boolean,
	      default: true
	    },
	    polygonMaterial: {
	      type: Object,
	      default: function _default() {
	        return {
	          fabric: {
	            type: 'Color',
	            uniforms: {
	              color: 'rgba(255,165,0,0.25)'
	            }
	          }
	        };
	      }
	    }
	  },
	  watch: {
	    clampToGround: function clampToGround() {
	      var getSurfaceArea = this.getSurfaceArea,
	          getDistance = this.getDistance,
	          polylines = this.polylines;
	      polylines.forEach(function (polyline) {
	        polyline.area = getSurfaceArea(polyline.positions);
	        var distances = [0];
	        var totalDistance = 0;

	        for (var i = 0; i < polyline.positions.length; i++) {
	          var positions = [polyline.positions[i], polyline.positions.length - 1 !== i ? polyline.positions[i + 1] : polyline.positions[0]];
	          var distance = getDistance(positions);
	          totalDistance += distance;
	          distances.push(totalDistance);
	        }

	        polyline.distances = distances;
	        polyline.distance = totalDistance;
	      });
	    }
	  },
	  methods: {
	    getDistanceText: function getDistanceText(distance) {
	      return distance > 1000 ? (distance / 1000).toFixed(2) + 'km' : distance.toFixed(2) + 'm';
	    },
	    getMidPoistion: function getMidPoistion(left, right) {
	      var _Cesium = Cesium,
	          Cartesian3 = _Cesium.Cartesian3;
	      return Cartesian3.midpoint(left, right, new Cartesian3());
	    },
	    makeEllipsoidSurfaceAppearance: function makeEllipsoidSurfaceAppearance(val) {
	      return new Cesium.EllipsoidSurfaceAppearance({
	        material: makeMaterial.call(this, val),
	        renderState: {
	          cull: {
	            enabled: false
	          }
	        }
	      });
	    },
	    makePolylineMaterialAppearance: function makePolylineMaterialAppearance(val) {
	      return new Cesium.PolylineMaterialAppearance({
	        material: makeMaterial.call(this, val)
	      });
	    },
	    clone: clone,

	    /**
	     * 用海伦公式获取传入坐标的构成的多边形的面积。
	     * @param {Array.Cartesian}
	     * @returns {Number} 返回面积数值。
	     */
	    getSurfaceArea: function getSurfaceArea(vals) {
	      var positions = clone(vals, true);

	      if (positions.length < 3) {
	        return 0;
	      }

	      var _Cesium2 = Cesium,
	          Cartesian3 = _Cesium2.Cartesian3,
	          EllipsoidTangentPlane = _Cesium2.EllipsoidTangentPlane,
	          Ellipsoid = _Cesium2.Ellipsoid,
	          CesiumMath = _Cesium2.Math,
	          PolygonGeometryLibrary = _Cesium2.PolygonGeometryLibrary,
	          PolygonHierarchy = _Cesium2.PolygonHierarchy,
	          VertexFormat = _Cesium2.VertexFormat,
	          ArcType = _Cesium2.ArcType;
	      var perPositionHeight = !this.clampToGround; // Request the triangles that make up the polygon from Cesium.
	      // 获取组成多边形的三角形。

	      var tangentPlane = EllipsoidTangentPlane.fromPoints(positions, Ellipsoid.WGS84);
	      var polygons = PolygonGeometryLibrary.polygonsFromHierarchy(new PolygonHierarchy(positions), tangentPlane.projectPointsOntoPlane.bind(tangentPlane), this.clampToGround, Ellipsoid.WGS84);
	      var geom = PolygonGeometryLibrary.createGeometryFromPositions(Ellipsoid.WGS84, polygons.polygons[0], CesiumMath.RADIANS_PER_DEGREE, perPositionHeight, VertexFormat.POSITION_ONLY, ArcType.GEODESIC);

	      if (geom.indices.length % 3 !== 0 || geom.attributes.position.values.length % 3 !== 0) {
	        // Something has gone wrong. We expect triangles. Can't calcuate area.
	        // 不是三角形，无法计算。
	        return 0;
	      }

	      var coords = [];

	      for (var i = 0; i < geom.attributes.position.values.length; i += 3) {
	        coords.push(new Cartesian3(geom.attributes.position.values[i], geom.attributes.position.values[i + 1], geom.attributes.position.values[i + 2]));
	      }

	      var area = 0;

	      for (var _i = 0; _i < geom.indices.length; _i += 3) {
	        var ind1 = geom.indices[_i];
	        var ind2 = geom.indices[_i + 1];
	        var ind3 = geom.indices[_i + 2];
	        var a = Cartesian3.distance(coords[ind1], coords[ind2]);
	        var b = Cartesian3.distance(coords[ind2], coords[ind3]);
	        var c = Cartesian3.distance(coords[ind3], coords[ind1]); // Heron's formula 海伦公式

	        var s = (a + b + c) / 2.0;
	        area += Math.sqrt(s * (s - a) * (s - b) * (s - c));
	      }

	      return area;
	    },

	    /**
	     * 用 @turf/area 获取传入坐标的构成的多边形的面积。实际上是投影面积。
	     * @param {Array.Cartesian}
	     * @returns {Number} 返回面积数值。
	     */
	    getProjectedArea: function getProjectedArea(positions) {
	      var _Cesium3 = Cesium,
	          Cartographic = _Cesium3.Cartographic,
	          CesiumMath = _Cesium3.Math;
	      var array = [];

	      for (var i = 0, len = positions.length; i < len; i++) {
	        var cartographic = Cartographic.fromCartesian(positions[i]);
	        var longitude = CesiumMath.toDegrees(cartographic.longitude).toFixed(6);
	        var latitude = CesiumMath.toDegrees(cartographic.latitude).toFixed(6);
	        array.push({
	          x: longitude,
	          y: latitude
	        });
	      }

	      var arrs = [];
	      var tems = [];
	      arrs.push(tems);

	      for (var _i2 = 0, _len = array.length; _i2 < _len; _i2++) {
	        tems.push([array[_i2].x, array[_i2].y]);
	      }

	      var polygons = {
	        type: 'FeatureCollection',
	        features: [{
	          type: 'Feature',
	          properties: {},
	          geometry: {
	            type: 'Polygon',
	            coordinates: arrs
	          }
	        }, {
	          type: 'Feature',
	          properties: {},
	          geometry: {
	            type: 'Polygon',
	            coordinates: [[[0, 0], [0, 0], [0, 0], [0, 0], [0, 0]]]
	          }
	        }]
	      };
	      return area(polygons);
	    },
	    clear: function clear() {
	      this.distance = 0;
	      this.polylines = [];
	      this.labels = [];
	      this.measuring = false;
	    }
	  }
	};

	/* script */
	var __vue_script__$1u = script$1u;
	/* template */

	var __vue_render__$1 = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('i', {
	    class: _vm.$options.name,
	    staticStyle: {
	      "display": "none !important"
	    }
	  }, [_vm.clampToGround ? _c('vc-collection-primitive', {
	    ref: "groundPolygonCollection"
	  }, [_vm._l(_vm.polylines, function (polyline, index) {
	    return [polyline.positions.length > 2 ? _c('vc-primitive-ground', {
	      key: index,
	      attrs: {
	        "appearance": _vm.makeEllipsoidSurfaceAppearance(_vm.polygonMaterial),
	        "asynchronous": false
	      }
	    }, [_c('vc-instance-geometry', [_c('vc-geometry-polygon', {
	      attrs: {
	        "perPositionHeight": false,
	        "polygonHierarchy": _vm.clone(polyline.positions, true)
	      }
	    })], 1)], 1) : _vm._e()];
	  })], 2) : _c('vc-collection-primitive', {
	    ref: "polygonCollection"
	  }, [_vm._l(_vm.polylines, function (polyline, index) {
	    return [polyline.positions.length > 2 ? _c('vc-primitive', {
	      key: index,
	      attrs: {
	        "appearance": _vm.makeEllipsoidSurfaceAppearance(_vm.polygonMaterial),
	        "asynchronous": false
	      }
	    }, [_c('vc-instance-geometry', [_c('vc-geometry-polygon', {
	      attrs: {
	        "perPositionHeight": true,
	        "polygonHierarchy": _vm.clone(polyline.positions, true)
	      }
	    })], 1)], 1) : _vm._e()];
	  })], 2), _vm._v(" "), _vm.clampToGround ? _c('vc-collection-primitive', {
	    ref: "groundPolylineCollection"
	  }, [_vm._l(_vm.polylines, function (polyline, index) {
	    return [polyline.positions.length > 1 ? _c('vc-primitive-polyline-ground', {
	      key: index,
	      attrs: {
	        "appearance": _vm.makePolylineMaterialAppearance(_vm.polylineMaterial),
	        "asynchronous": false
	      }
	    }, [_c('vc-instance-geometry', [_c('vc-geometry-polyline-ground', {
	      attrs: {
	        "positions": polyline.positions,
	        "width": _vm.polylineWidth,
	        "loop": ""
	      }
	    })], 1)], 1) : _vm._e()];
	  })], 2) : _c('vc-collection-primitive-polyline', {
	    ref: "polylineCollection"
	  }, _vm._l(_vm.polylines, function (polyline, index) {
	    return _c('vc-primitive-polyline', {
	      key: index,
	      attrs: {
	        "loop": true,
	        "material": _vm.polylineMaterial,
	        "positions": polyline.positions,
	        "width": _vm.polylineWidth
	      }
	    });
	  }), 1), _vm._v(" "), _c('vc-collection-primitive-point', {
	    ref: "pointCollection"
	  }, [_vm._l(_vm.polylines, function (polyline, index) {
	    return [_vm._l(polyline.positions, function (position, subIndex) {
	      return [_c('vc-primitive-point', {
	        key: 'point' + index + 'position' + subIndex,
	        attrs: {
	          "color": _vm.pointColor,
	          "pixelSize": _vm.pointPixelSize,
	          "position": position
	        }
	      })];
	    })];
	  })], 2), _vm._v(" "), _c('vc-collection-primitive-label', {
	    ref: "labelCollection"
	  }, [_vm._l(_vm.polylines, function (polyline, index) {
	    return [_c('vc-primitive-label', {
	      key: 'label' + index,
	      attrs: {
	        "backgroundColor": _vm.backgroundColor,
	        "font": _vm.font,
	        "horizontalOrigin": 1,
	        "labelStyle": _vm.labelStyle,
	        "outlineColor": _vm.outlineColor,
	        "outlineWidth": _vm.outlineWidth,
	        "pixelOffset": _vm.pixelOffset,
	        "position": polyline.positions[polyline.positions.length - 1],
	        "showBackground": _vm.showBackground,
	        "text": _vm.$vc.lang.measure.area + ': ' + (polyline.area > 1000000 ? (polyline.area / 1000000).toFixed(2) + 'km²' : polyline.area.toFixed(2) + '㎡')
	      }
	    }), _vm._v(" "), _vm._l(polyline.positions, function (position, subIndex) {
	      return [_vm.alongLine && polyline.positions.length > 1 && subIndex + 1 < polyline.distances.length ? _c('vc-primitive-label', {
	        key: 'label' + index + 'position' + subIndex,
	        attrs: {
	          "backgroundColor": _vm.backgroundColor,
	          "fillColor": _vm.fillColor,
	          "font": _vm.font,
	          "horizontalOrigin": 0,
	          "labelStyle": _vm.labelStyle,
	          "outlineColor": _vm.outlineColor,
	          "outlineWidth": _vm.outlineWidth,
	          "pixelOffset": _vm.pixelOffset,
	          "position": subIndex !== polyline.positions.length - 1 ? _vm.getMidPoistion(polyline.positions[subIndex], polyline.positions[subIndex + 1]) : _vm.getMidPoistion(polyline.positions[subIndex], polyline.positions[0]),
	          "showBackground": _vm.showBackground,
	          "text": _vm.getDistanceText(polyline.distances[subIndex + 1] - polyline.distances[subIndex]),
	          "verticalOrigin": 0
	        }
	      }) : _vm._e()];
	    })];
	  })], 2)], 1);
	};

	var __vue_staticRenderFns__$1 = [];
	/* style */

	var __vue_inject_styles__$1u = undefined;
	/* scoped */

	var __vue_scope_id__$1u = undefined;
	/* functional template */

	var __vue_is_functional_template__$1u = false;
	/* component normalizer */

	function __vue_normalize__$1u(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "VcMeasureArea.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var VcMeasureArea = __vue_normalize__$1u({
	  render: __vue_render__$1,
	  staticRenderFns: __vue_staticRenderFns__$1
	}, __vue_inject_styles__$1u, __vue_script__$1u, __vue_scope_id__$1u, __vue_is_functional_template__$1u);

	function plugin$1u(Vue) {

	  if (plugin$1u.installed) {
	    return;
	  }

	  plugin$1u.installed = true;
	  Vue.use(PrimitiveCollection$1);
	  Vue.use(GroundPrimitive$1);
	  Vue.use(GeometryInstance$1);
	  Vue.use(PolygonGeometry$1);
	  Vue.use(Primitive$1);
	  Vue.use(GroundPolylinePrimitive$1);
	  Vue.use(GroundPolylineGeometry$1);
	  Vue.use(PolylineCollection$1);
	  Vue.use(Polyline$1);
	  Vue.use(PointPrimitiveCollection$1);
	  Vue.use(PointPrimitive$1);
	  Vue.use(LabelCollection$1);
	  Vue.use(Label$1);
	  Vue.component(VcMeasureArea.name, VcMeasureArea);
	}

	var VcMeasureArea$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$1u,
		VcMeasureArea: VcMeasureArea,
		install: plugin$1u
	});

	//
	var script$1v = {
	  name: 'vc-measure-distance',
	  mixins: [mixinMeasure],
	  data: function data() {
	    return {
	      type: 'distanceMeasuring',
	      measuring: false,
	      polylines: [],
	      nowaiting: true
	    };
	  },
	  props: {
	    arcType: {
	      type: Number,
	      default: 0
	    },
	    clampToGround: {
	      type: Boolean,
	      default: false
	    },
	    alongLine: {
	      type: Boolean,
	      default: true
	    },
	    removeLastPosition: {
	      type: Boolean,
	      default: true
	    }
	  },
	  watch: {
	    clampToGround: function clampToGround() {
	      var getDistance = this.getDistance,
	          polylines = this.polylines;
	      polylines.forEach(function (polyline) {
	        var distances = [0];
	        var totalDistance = 0;

	        for (var i = 0; i < polyline.positions.length - 1; i++) {
	          var positions = [polyline.positions[i], polyline.positions[i + 1]];
	          var distance = getDistance(positions);
	          totalDistance += distance;
	          distances.push(totalDistance);
	        }

	        polyline.distances = distances;
	        polyline.distance = totalDistance;
	      });
	    }
	  },
	  methods: {
	    getDistanceText: function getDistanceText(distance) {
	      return distance > 1000 ? (distance / 1000).toFixed(2) + 'km' : distance.toFixed(2) + 'm';
	    },
	    getMidPoistion: function getMidPoistion(left, right) {
	      var _Cesium = Cesium,
	          Cartesian3 = _Cesium.Cartesian3;
	      return Cartesian3.midpoint(left, right, new Cartesian3());
	    },
	    clear: function clear() {
	      this.polylines = [];
	      this.measuring = false;
	    },
	    makeAppearance: function makeAppearance(val) {
	      return new Cesium.PolylineMaterialAppearance({
	        material: makeMaterial.call(this, val)
	      });
	    }
	  }
	};

	/* script */
	var __vue_script__$1v = script$1v;
	/* template */

	var __vue_render__$2 = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('i', {
	    class: _vm.$options.name,
	    staticStyle: {
	      "display": "none !important"
	    }
	  }, [_vm.clampToGround ? _c('vc-collection-primitive', {
	    ref: "groundPolylineCollection"
	  }, [_vm._l(_vm.polylines, function (polyline, index) {
	    return [polyline.positions.length > 1 ? _c('vc-primitive-polyline-ground', {
	      key: index,
	      attrs: {
	        "appearance": _vm.makeAppearance(_vm.polylineMaterial),
	        "arcType": _vm.arcType,
	        "asynchronous": false
	      }
	    }, [_c('vc-instance-geometry', [_c('vc-geometry-polyline-ground', {
	      attrs: {
	        "positions": polyline.positions,
	        "width": _vm.polylineWidth
	      }
	    })], 1)], 1) : _vm._e()];
	  })], 2) : _c('vc-collection-primitive-polyline', {
	    ref: "polylineCollection"
	  }, _vm._l(_vm.polylines, function (polyline, index) {
	    return _c('vc-primitive-polyline', {
	      key: index,
	      attrs: {
	        "material": _vm.polylineMaterial,
	        "positions": polyline.positions,
	        "width": _vm.polylineWidth
	      }
	    });
	  }), 1), _vm._v(" "), _c('vc-collection-primitive-point', {
	    ref: "pointCollection"
	  }, [_vm._l(_vm.polylines, function (polyline, index) {
	    return [_vm._l(polyline.positions, function (position, subIndex) {
	      return [_c('vc-primitive-point', {
	        key: 'point' + index + 'position' + subIndex,
	        attrs: {
	          "color": _vm.pointColor,
	          "pixelSize": _vm.pointPixelSize,
	          "position": position
	        }
	      })];
	    })];
	  })], 2), _vm._v(" "), _c('vc-collection-primitive-label', {
	    ref: "labelCollection"
	  }, [_vm._l(_vm.polylines, function (polyline, index) {
	    return [_vm._l(polyline.positions, function (position, subIndex) {
	      return [subIndex === polyline.positions.length - 1 ? _c('vc-primitive-label', {
	        key: 'label' + index + 'position' + subIndex,
	        attrs: {
	          "backgroundColor": _vm.backgroundColor,
	          "fillColor": _vm.fillColor,
	          "font": _vm.font,
	          "horizontalOrigin": 1,
	          "labelStyle": _vm.labelStyle,
	          "outlineColor": _vm.outlineColor,
	          "outlineWidth": _vm.outlineWidth,
	          "pixelOffset": _vm.pixelOffset,
	          "position": position,
	          "showBackground": _vm.showBackground,
	          "text": _vm.$vc.lang.measure.distance + ': ' + _vm.getDistanceText(polyline.distances[subIndex])
	        }
	      }) : _vm._e(), _vm._v(" "), subIndex !== polyline.positions.length - 1 && polyline.positions.length > 2 + subIndex || (polyline.positions.length > 2 + subIndex || polyline.positions.length - 2 === subIndex && polyline.positions.length !== 2) && _vm.alongLine ? _c('vc-primitive-label', {
	        key: 'label' + index + 'position' + subIndex,
	        attrs: {
	          "backgroundColor": _vm.backgroundColor,
	          "fillColor": _vm.fillColor,
	          "font": _vm.font,
	          "horizontalOrigin": 0,
	          "labelStyle": _vm.labelStyle,
	          "outlineColor": _vm.outlineColor,
	          "outlineWidth": _vm.outlineWidth,
	          "pixelOffset": _vm.pixelOffset,
	          "position": _vm.getMidPoistion(polyline.positions[subIndex], polyline.positions[subIndex + 1]),
	          "showBackground": _vm.showBackground,
	          "text": _vm.getDistanceText(polyline.distances[subIndex + 1] - polyline.distances[subIndex]),
	          "verticalOrigin": 0
	        }
	      }) : _vm._e()];
	    })];
	  })], 2)], 1);
	};

	var __vue_staticRenderFns__$2 = [];
	/* style */

	var __vue_inject_styles__$1v = undefined;
	/* scoped */

	var __vue_scope_id__$1v = undefined;
	/* functional template */

	var __vue_is_functional_template__$1v = false;
	/* component normalizer */

	function __vue_normalize__$1v(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "VcMeasureDistance.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var VcMeasureDistance = __vue_normalize__$1v({
	  render: __vue_render__$2,
	  staticRenderFns: __vue_staticRenderFns__$2
	}, __vue_inject_styles__$1v, __vue_script__$1v, __vue_scope_id__$1v, __vue_is_functional_template__$1v);

	function plugin$1v(Vue) {

	  if (plugin$1v.installed) {
	    return;
	  }

	  plugin$1v.installed = true;
	  Vue.use(PrimitiveCollection$1);
	  Vue.use(GeometryInstance$1);
	  Vue.use(GroundPolylinePrimitive$1);
	  Vue.use(GroundPolylineGeometry$1);
	  Vue.use(PolylineCollection$1);
	  Vue.use(Polyline$1);
	  Vue.use(PointPrimitiveCollection$1);
	  Vue.use(PointPrimitive$1);
	  Vue.use(LabelCollection$1);
	  Vue.use(Label$1);
	  Vue.component(VcMeasureDistance.name, VcMeasureDistance);
	}

	var VcMeasureDistance$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$1v,
		VcMeasureDistance: VcMeasureDistance,
		install: plugin$1v
	});

	//
	var script$1w = {
	  name: 'vc-measure-height',
	  mixins: [mixinMeasure],
	  data: function data() {
	    return {
	      type: 'heightMeasuring',
	      measuring: false,
	      startPoint: {},
	      polylines: [],
	      labels: [],
	      nowaiting: true
	    };
	  },
	  methods: {
	    getDistance: function getDistance(positions) {
	      var distance = 0;

	      for (var i = 0; i < positions.length - 1; i++) {
	        var s = Cesium.Cartesian3.distance(positions[i], positions[i + 1]);
	        distance = distance + s;
	      }

	      return distance;
	    },
	    clear: function clear() {
	      this.distance = 0;
	      this.polylines = [];
	      this.labels = [];
	      this.measuring = false;
	    }
	  }
	};

	/* script */
	var __vue_script__$1w = script$1w;
	/* template */

	var __vue_render__$3 = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('i', {
	    class: _vm.$options.name,
	    staticStyle: {
	      "display": "none !important"
	    }
	  }, [_c('vc-collection-primitive-polyline', {
	    ref: "polylineCollection"
	  }, _vm._l(_vm.polylines, function (polyline, index) {
	    return _c('vc-primitive-polyline', {
	      key: index,
	      attrs: {
	        "material": _vm.polylineMaterial,
	        "positions": polyline.positions,
	        "width": _vm.polylineWidth,
	        "loop": ""
	      }
	    });
	  }), 1), _vm._v(" "), _c('vc-collection-primitive-point', {
	    ref: "pointCollection"
	  }, [_vm._l(_vm.polylines, function (polyline, index) {
	    return [_vm._l(polyline.positions, function (position, subIndex) {
	      return [_c('vc-primitive-point', {
	        key: 'point' + index + 'position' + subIndex,
	        attrs: {
	          "color": _vm.pointColor,
	          "pixelSize": _vm.pointPixelSize,
	          "position": position
	        }
	      })];
	    })];
	  })], 2), _vm._v(" "), _c('vc-collection-primitive-label', {
	    ref: "labelCollection"
	  }, _vm._l(_vm.labels, function (label, index) {
	    return _c('vc-primitive-label', {
	      key: 'label' + index,
	      attrs: {
	        "backgroundColor": _vm.backgroundColor,
	        "fillColor": _vm.fillColor,
	        "font": _vm.font,
	        "horizontalOrigin": 0,
	        "verticalOrigin": 0,
	        "labelStyle": _vm.labelStyle,
	        "outlineColor": _vm.outlineColor,
	        "outlineWidth": _vm.outlineWidth,
	        "pixelOffset": _vm.pixelOffset,
	        "position": label.position,
	        "showBackground": _vm.showBackground,
	        "text": label.text
	      }
	    });
	  }), 1)], 1);
	};

	var __vue_staticRenderFns__$3 = [];
	/* style */

	var __vue_inject_styles__$1w = undefined;
	/* scoped */

	var __vue_scope_id__$1w = undefined;
	/* functional template */

	var __vue_is_functional_template__$1w = false;
	/* component normalizer */

	function __vue_normalize__$1w(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "VcMeasureHeight.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var VcMeasureHeight = __vue_normalize__$1w({
	  render: __vue_render__$3,
	  staticRenderFns: __vue_staticRenderFns__$3
	}, __vue_inject_styles__$1w, __vue_script__$1w, __vue_scope_id__$1w, __vue_is_functional_template__$1w);

	function plugin$1w(Vue) {

	  if (plugin$1w.installed) {
	    return;
	  }

	  plugin$1w.installed = true;
	  Vue.use(PolylineCollection$1);
	  Vue.use(Polyline$1);
	  Vue.use(PointPrimitiveCollection$1);
	  Vue.use(PointPrimitive$1);
	  Vue.use(LabelCollection$1);
	  Vue.use(Label$1);
	  Vue.component(VcMeasureHeight.name, VcMeasureHeight);
	}

	var VcMeasureHeight$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$1w,
		VcMeasureHeight: VcMeasureHeight,
		install: plugin$1w
	});

	//
	//
	//
	//
	var icons = {};
	var notLoadedIcons = [];
	var defaultWidth = '';
	var defaultHeight = '';
	var classPrefix = 'vc-svg';
	var isStroke = false;
	var isOriginalDefault = false;
	var script$1x = {
	  name: 'svgicon',
	  data: function data() {
	    return {
	      loaded: false
	    };
	  },
	  props: {
	    icon: String,
	    name: String,
	    width: {
	      type: String,
	      default: ''
	    },
	    height: {
	      type: String,
	      default: ''
	    },
	    scale: String,
	    dir: String,
	    fill: {
	      type: Boolean,
	      default: function _default() {
	        return !isStroke;
	      }
	    },
	    color: String,
	    original: {
	      type: Boolean,
	      default: function _default() {
	        return isOriginalDefault;
	      }
	    },
	    title: String
	  },
	  computed: {
	    clazz: function clazz() {
	      var clazz = "".concat(classPrefix, "-icon");

	      if (this.fill) {
	        clazz += " ".concat(classPrefix, "-fill");
	      }

	      if (this.dir) {
	        clazz += " ".concat(classPrefix, "-").concat(this.dir);
	      }

	      return clazz;
	    },
	    iconName: function iconName() {
	      return this.name || this.icon;
	    },
	    iconData: function iconData() {
	      var iconData = icons[this.iconName];

	      if (iconData || this.loaded) {
	        return iconData;
	      }

	      return null;
	    },
	    colors: function colors() {
	      if (this.color) {
	        return this.color.split(' ');
	      }

	      return [];
	    },
	    path: function path() {
	      var pathData = '';

	      if (this.iconData) {
	        pathData = this.iconData.data;
	        pathData = this.setTitle(pathData); // use original color

	        if (this.original) {
	          pathData = this.addOriginalColor(pathData);
	        }

	        if (this.colors.length > 0) {
	          pathData = this.addColor(pathData);
	        }
	      } else {
	        // if no iconData, push to notLoadedIcons
	        notLoadedIcons.push({
	          name: this.iconName,
	          component: this
	        });
	      }

	      return this.getValidPathData(pathData);
	    },
	    box: function box() {
	      var width = this.width || 16;
	      var height = this.width || 16;

	      if (this.iconData) {
	        if (this.iconData.viewBox) {
	          return this.iconData.viewBox;
	        }

	        return "0 0 ".concat(this.iconData.width, " ").concat(this.iconData.height);
	      }

	      return "0 0 ".concat(_parseFloat$2(width), " ").concat(_parseFloat$2(height));
	    },
	    style: function style() {
	      var digitReg = /^\d+$/;
	      var scale = Number(this.scale);
	      var width;
	      var height; // apply scale

	      if (!isNaN(scale) && this.iconData) {
	        width = Number(this.iconData.width) * scale + 'px';
	        height = Number(this.iconData.height) * scale + 'px';
	      } else {
	        width = digitReg.test(this.width) ? this.width + 'px' : this.width || defaultWidth;
	        height = digitReg.test(this.height) ? this.height + 'px' : this.height || defaultHeight;
	      }

	      var style = {};

	      if (width) {
	        style.width = width;
	      }

	      if (height) {
	        style.height = height;
	      }

	      return style;
	    }
	  },
	  created: function created() {
	    if (icons[this.iconName]) {
	      this.loaded = true;
	    }
	  },
	  methods: {
	    addColor: function addColor(data) {
	      var _this = this;

	      var reg = /<(path|rect|circle|polygon|line|polyline|ellipse)\s/gi;
	      var i = 0;
	      return data.replace(reg, function (match) {
	        var color = _this.colors[i++] || _this.colors[_this.colors.length - 1];
	        var fill = _this.fill; // if color is '_', ignore it

	        if (color && color === '_') {
	          return match;
	        } // if color start with 'r-', reverse the fill value


	        if (color && color.indexOf('r-') === 0) {
	          fill = !fill;
	          color = color.split('r-')[1];
	        }

	        var style = fill ? 'fill' : 'stroke';
	        var reverseStyle = fill ? 'stroke' : 'fill';
	        return match + "".concat(style, "=\"").concat(color, "\" ").concat(reverseStyle, "=\"none\" ");
	      });
	    },
	    addOriginalColor: function addOriginalColor(data) {
	      var styleReg = /_fill="|_stroke="/gi;
	      return data.replace(styleReg, function (styleName) {
	        return styleName && styleName.slice(1);
	      });
	    },
	    getValidPathData: function getValidPathData(pathData) {
	      // If use original and colors, clear double fill or stroke
	      if (this.original && this.colors.length > 0) {
	        // eslint-disable-next-line no-useless-escape
	        var reg = /<(path|rect|circle|polygon|line|polyline|ellipse)(\sfill|\sstroke)([="\w\s\.\-\+#\$\&>]+)(fill|stroke)/gi;
	        pathData = pathData.replace(reg, function (match, p1, p2, p3, p4) {
	          return "<".concat(p1).concat(p2).concat(p3, "_").concat(p4);
	        });
	      }

	      return pathData;
	    },
	    setTitle: function setTitle(pathData) {
	      if (this.title) {
	        var title = this.title // eslint-disable-next-line no-useless-escape
	        .replace(/\</gi, '&lt;').replace(/>/gi, '&gt;').replace(/&/g, '&amp;');
	        return "<title>".concat(title, "</title>") + pathData;
	      }

	      return pathData;
	    },
	    onClick: function onClick(e) {
	      this.$emit('click', e);
	    }
	  },
	  install: function install(Vue) {
	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	    var tagName = options.tagName || 'svgicon';

	    if (options.classPrefix) {
	      classPrefix = options.classPrefix;
	    }

	    isStroke = !!options.isStroke;
	    isOriginalDefault = !!options.isOriginalDefault; // default size

	    options.defaultWidth && (defaultWidth = options.defaultWidth);
	    options.defaultHeight && (defaultHeight = options.defaultHeight);
	    Vue.component(tagName, this);
	  },
	  // register icons
	  register: function register(data) {
	    var _loop = function _loop(name) {
	      if (!icons[name]) {
	        icons[name] = data[name];
	      } // check new register icon is not loaded, and set loaded to true


	      notLoadedIcons = notLoadedIcons.filter(function (v, ix) {
	        if (v.name === name) {
	          v.component.$set(v.component, 'loaded', true);
	        }

	        return v.name !== name;
	      });
	    };

	    for (var name in data) {
	      _loop(name);
	    }
	  },
	  icons: icons
	};

	/* script */
	var __vue_script__$1x = script$1x;
	/* template */

	var __vue_render__$4 = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('svg', {
	    class: _vm.clazz,
	    style: _vm.style,
	    attrs: {
	      "viewBox": _vm.box,
	      "version": "1.1"
	    },
	    domProps: {
	      "innerHTML": _vm._s(_vm.path)
	    },
	    on: {
	      "click": _vm.onClick
	    }
	  });
	};

	var __vue_staticRenderFns__$4 = [];
	/* style */

	var __vue_inject_styles__$1x = undefined;
	/* scoped */

	var __vue_scope_id__$1x = "data-v-b5224d78";
	/* functional template */

	var __vue_is_functional_template__$1x = false;
	/* component normalizer */

	function __vue_normalize__$1x(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "VcIconSvg.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var VcIconSvg = __vue_normalize__$1x({
	  render: __vue_render__$4,
	  staticRenderFns: __vue_staticRenderFns__$4
	}, __vue_inject_styles__$1x, __vue_script__$1x, __vue_scope_id__$1x, __vue_is_functional_template__$1x);

	VcIconSvg.register({
	  'icon-move': {
	    width: 48,
	    height: 48,
	    viewBox: '0 0 1024 1024',
	    data: "\n    <!-- Generator: Sketch 3.4.3 (16044) - http://www.bohemiancoding.com/sketch -->\n    <!-- <title>icon-move</title> -->\n    <path d=\"M918.557 489.053L794.902 365.398c-12.526-12.526-32.868-12.526-45.394 0-12.526 12.526-12.526 32.868 0 45.394l68.842 68.842H542.983V206.37l68.541 68.541c12.526 12.526 32.868 12.526 45.394 0 12.526-12.526 12.526-32.868 0-45.394L533.663 106.263l-0.301-0.301c-0.301-0.301-0.601-0.601-0.902-0.802-0.1-0.1-0.2-0.2-0.401-0.301-0.301-0.2-0.601-0.501-0.802-0.701-0.1-0.1-0.2-0.2-0.301-0.2a3.584 3.584 0 0 0-1.002-0.701c-0.1 0-0.1-0.1-0.2-0.1-0.401-0.301-0.701-0.501-1.102-0.802-4.209-2.806-9.219-4.71-14.53-5.211h-0.2c-0.501 0-0.902-0.1-1.403-0.1h-3.207c-0.501 0-0.902 0.1-1.403 0.1h-0.2c-5.311 0.501-10.321 2.405-14.53 5.211-0.401 0.301-0.701 0.501-1.102 0.802-0.1 0-0.1 0.1-0.2 0.1-0.301 0.2-0.601 0.501-1.002 0.701-0.1 0.1-0.2 0.2-0.301 0.2-0.301 0.2-0.601 0.501-0.802 0.701-0.1 0.1-0.2 0.2-0.401 0.301-0.301 0.301-0.601 0.501-0.902 0.802l-0.301 0.301-123.353 123.555c-12.526 12.526-12.526 32.868 0 45.394a32.034 32.034 0 0 0 22.647 9.419c8.217 0 16.434-3.106 22.647-9.419l68.742-68.742v273.063H205.386l68.842-68.842c12.526-12.526 12.526-32.868 0-45.394-12.526-12.526-32.868-12.526-45.394 0L105.48 488.752c-6.012 6.012-9.419 14.129-9.419 22.647s3.407 16.634 9.419 22.647l122.753 122.753c6.213 6.213 14.43 9.419 22.647 9.419s16.434-3.106 22.647-9.419c12.526-12.526 12.526-32.868 0-45.394l-67.639-67.74h273.063V817.43l-69.844-69.844c-12.526-12.526-32.868-12.526-45.394 0-12.526 12.526-12.526 32.868 0 45.394L488.27 917.536c6.012 6.012 14.129 9.419 22.647 9.419 8.518 0 16.634-3.407 22.647-9.419l123.755-123.755c12.526-12.526 12.526-32.868 0-45.394-12.526-12.526-32.868-12.526-45.394 0l-68.942 68.942V543.665h275.568l-68.842 68.842c-12.526 12.526-12.526 32.868 0 45.394a32.034 32.034 0 0 0 22.647 9.419c8.217 0 16.434-3.106 22.647-9.419l123.455-123.455c12.625-12.526 12.625-32.868 0.099-45.393z\" fill=\"#1296db\" p-id=\"11002\"></path>"
	  }
	});

	VcIconSvg.register({
	  'icon-add': {
	    width: 48,
	    height: 48,
	    viewBox: '0 0 1024 1024',
	    data: "\n    <!-- Generator: Sketch 3.4.3 (16044) - http://www.bohemiancoding.com/sketch -->\n    <!-- <title>icon-add</title> -->\n    <path d=\"M903.37727 439.522292 584.476173 439.522292 584.476173 120.622218c0-32.020274-25.961278-57.981553-57.981553-57.981553l-28.990265 0c-32.020274 0-57.982576 25.962302-57.982576 57.981553l0 318.900074L120.621706 439.522292c-32.020274 0-57.981553 25.962302-57.981553 57.981553l0 28.991288c0 32.020274 25.962302 57.981553 57.981553 57.981553l318.900074 0L439.52178 903.377782c0 32.019251 25.962302 57.981553 57.982576 57.981553l28.990265 0c32.020274 0 57.981553-25.962302 57.981553-57.981553L584.476173 584.476685l318.901097 0c32.020274 0 57.981553-25.961278 57.981553-57.981553l0-28.991288C961.358823 465.484593 935.397544 439.522292 903.37727 439.522292z\" p-id=\"6657\" fill=\"#1296db\"></path>"
	  }
	});

	VcIconSvg.register({
	  'icon-delete': {
	    width: 48,
	    height: 48,
	    viewBox: '0 0 1024 1024',
	    data: "\n    <!-- Generator: Sketch 3.4.3 (16044) - http://www.bohemiancoding.com/sketch -->\n    <!-- <title>icon-delete</title> -->\n    <path d=\"M512 620.544l253.3376 253.3376a76.6976 76.6976 0 1 0 108.544-108.544L620.6464 512l253.2352-253.3376a76.6976 76.6976 0 1 0-108.544-108.544L512 403.3536 258.6624 150.1184a76.6976 76.6976 0 1 0-108.544 108.544L403.3536 512 150.1184 765.3376a76.6976 76.6976 0 1 0 108.544 108.544L512 620.6464z\" p-id=\"7671\" fill=\"#1296db\"></path>"
	  }
	});

	var props$1 = {
	  mode: {
	    type: Number,
	    default: 1
	  },
	  show: {
	    type: Boolean,
	    default: true
	  },
	  pointColor: {
	    type: String | Object | Array,
	    default: 'rgb(255,229,0)'
	  },
	  pointPixelSize: {
	    type: Number,
	    default: 8
	  },
	  editable: {
	    type: Boolean,
	    default: false
	  },
	  showDrawTip: {
	    type: Boolean,
	    default: true
	  }
	};
	var watch$2 = {
	  editable: function editable(val) {
	    if (!val) {
	      this.showToolbar = false;
	    } else {
	      this.drawing = false;
	    }
	  },
	  drawing: function drawing(val) {
	    var nextTick, polylines, startNew, drawType, $parent, getParent, polyline, drawCmpNames, measureCmpNames, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, $node, listener;

	    return regenerator.async(function drawing$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            nextTick = false;
	            polylines = this.polylines, startNew = this.startNew, drawType = this.drawType, $parent = this.$parent, getParent = this.getParent;
	            polyline = polylines[polylines.length - 1];

	            if (!(!val && polyline && !polyline.positions.length)) {
	              _context.next = 8;
	              break;
	            }

	            this.polylines.pop();
	            this.showTooltip = false;
	            _context.next = 47;
	            break;

	          case 8:
	            if (!val) {
	              _context.next = 46;
	              break;
	            }

	            drawCmpNames = [];
	            _context.t0 = drawType;
	            _context.next = _context.t0 === 'pointDrawing' ? 13 : _context.t0 === 'polylineDrawing' ? 16 : _context.t0 === 'polygonDrawing' ? 19 : 22;
	            break;

	          case 13:
	            drawCmpNames.push('vc-handler-draw-polyline');
	            drawCmpNames.push('vc-handler-draw-polygon');
	            return _context.abrupt("break", 22);

	          case 16:
	            drawCmpNames.push('vc-handler-draw-point');
	            drawCmpNames.push('vc-handler-draw-polygon');
	            return _context.abrupt("break", 22);

	          case 19:
	            drawCmpNames.push('vc-handler-draw-polyline');
	            drawCmpNames.push('vc-handler-draw-point');
	            return _context.abrupt("break", 22);

	          case 22:
	            measureCmpNames = ['vc-measure-height', 'vc-measure-distance', 'vc-measure-area'];
	            _iteratorNormalCompletion = true;
	            _didIteratorError = false;
	            _iteratorError = undefined;
	            _context.prev = 26;

	            for (_iterator = getIterator$1(getParent($parent).$slots.default || []); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	              $node = _step.value;

	              if ($node.componentOptions && drawCmpNames.indexOf($node.componentOptions.tag) !== -1) {
	                $node.child.drawing = false;
	                nextTick = true;
	              }

	              if ($node.componentOptions && measureCmpNames.indexOf($node.componentOptions.tag) !== -1) {
	                $node.child.measuring = false;
	                nextTick = true;
	              }
	            }

	            _context.next = 34;
	            break;

	          case 30:
	            _context.prev = 30;
	            _context.t1 = _context["catch"](26);
	            _didIteratorError = true;
	            _iteratorError = _context.t1;

	          case 34:
	            _context.prev = 34;
	            _context.prev = 35;

	            if (!_iteratorNormalCompletion && _iterator.return != null) {
	              _iterator.return();
	            }

	          case 37:
	            _context.prev = 37;

	            if (!_didIteratorError) {
	              _context.next = 40;
	              break;
	            }

	            throw _iteratorError;

	          case 40:
	            return _context.finish(37);

	          case 41:
	            return _context.finish(34);

	          case 42:
	            startNew();
	            this.showTooltip = true;
	            _context.next = 47;
	            break;

	          case 46:
	            this.showTooltip = false;

	          case 47:
	            if (!this.showTooltip) {
	              this.tooltipPosition = [0, 0, 0];
	            }

	            _context.t2 = nextTick;

	            if (!_context.t2) {
	              _context.next = 52;
	              break;
	            }

	            _context.next = 52;
	            return regenerator.awrap(this.$nextTick());

	          case 52:
	            this.viewer.canvas.setAttribute('style', val ? 'cursor: crosshair' : 'cursor: auto');
	            listener = this.$listeners.activeEvt;
	            listener && this.$emit('activeEvt', {
	              type: drawType,
	              isActive: val
	            });

	          case 55:
	          case "end":
	            return _context.stop();
	        }
	      }
	    }, null, this, [[26, 30, 34, 42], [35,, 37, 41]]);
	  }
	};
	var computed = {
	  points: function points() {
	    var _this = this;

	    var points = [];
	    this.polylines.forEach(function (polyline, index) {
	      polyline.positions.forEach(function (position, subIndex) {
	        var point = {
	          color: _this.pointColor,
	          pixelSize: _this.pointPixelSize,
	          position: position,
	          polylineIndex: index,
	          positionIndex: subIndex
	        };
	        points.push(point);
	      });
	    });
	    return points;
	  }
	};
	var methods$b = {
	  createCesiumObject: function createCesiumObject() {
	    var viewer, handler;
	    return regenerator.async(function createCesiumObject$(_context2) {
	      while (1) {
	        switch (_context2.prev = _context2.next) {
	          case 0:
	            viewer = this.viewer;
	            handler = new Cesium.ScreenSpaceEventHandler(viewer.canvas);
	            handler.setInputAction(this.LEFT_CLICK, Cesium.ScreenSpaceEventType.LEFT_CLICK);
	            handler.setInputAction(this.MOUSE_MOVE, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
	            handler.setInputAction(this.RIGHT_CLICK, Cesium.ScreenSpaceEventType.RIGHT_CLICK);
	            this.handler = handler;
	            return _context2.abrupt("return", this.polylines);

	          case 7:
	          case "end":
	            return _context2.stop();
	        }
	      }
	    }, null, this);
	  },
	  mount: function mount() {
	    return regenerator.async(function mount$(_context3) {
	      while (1) {
	        switch (_context3.prev = _context3.next) {
	          case 0:
	            return _context3.abrupt("return", true);

	          case 1:
	          case "end":
	            return _context3.stop();
	        }
	      }
	    });
	  },
	  unload: function unload() {
	    return regenerator.async(function unload$(_context4) {
	      while (1) {
	        switch (_context4.prev = _context4.next) {
	          case 0:
	            return _context4.abrupt("return", true);

	          case 1:
	          case "end":
	            return _context4.stop();
	        }
	      }
	    });
	  },
	  LEFT_CLICK: function LEFT_CLICK(movement) {
	    if (!this.drawing) {
	      return;
	    }

	    if (this.editingPoint) {
	      this.RIGHT_CLICK(movement);
	      return;
	    }

	    var Cesium = this.Cesium,
	        viewer = this.viewer,
	        polylines = this.polylines,
	        onDrawingEvt = this.onDrawingEvt;
	    var cartesian = viewer.scene.pickPosition(movement.position);

	    if (!Cesium.defined(cartesian)) {
	      return;
	    }

	    var nIndex = polylines.length - 1;
	    var polyline = polylines[nIndex];
	    polyline.positions.push(cartesian);
	    onDrawingEvt(polyline, nIndex);
	  },
	  MOUSE_MOVE: function MOUSE_MOVE(movement) {
	    var Cesium, viewer, polylines, onDrawingEvt, drawType, cartesian, nIndex, polyline, listener;
	    return regenerator.async(function MOUSE_MOVE$(_context5) {
	      while (1) {
	        switch (_context5.prev = _context5.next) {
	          case 0:
	            if (this.drawing) {
	              _context5.next = 2;
	              break;
	            }

	            return _context5.abrupt("return");

	          case 2:
	            Cesium = this.Cesium, viewer = this.viewer, polylines = this.polylines, onDrawingEvt = this.onDrawingEvt, drawType = this.drawType;
	            cartesian = viewer.scene.pickPosition(movement.endPosition);

	            if (Cesium.defined(cartesian)) {
	              _context5.next = 6;
	              break;
	            }

	            return _context5.abrupt("return");

	          case 6:
	            this.tooltipPosition = cartesian;
	            this.tooltip = this.$vc.lang.draw.drawingTip1;

	            if (polylines.length) {
	              _context5.next = 10;
	              break;
	            }

	            return _context5.abrupt("return");

	          case 10:
	            nIndex = this.editingPoint ? this.editingPoint.polylineIndex : polylines.length - 1;
	            polyline = polylines[nIndex];

	            if (polyline.positions.length) {
	              _context5.next = 14;
	              break;
	            }

	            return _context5.abrupt("return");

	          case 14:
	            if (polyline.positions.length >= 2) {
	              this.tooltip = this.editingPoint ? this.$vc.lang.draw.drawingTip3 : this.$vc.lang.draw.drawingTip2;
	            }

	            if (this.editingPoint) {
	              polyline.positions.splice(this.editingPoint.positionIndex, 1, cartesian);
	            } else {
	              if (polyline.positions.length >= 2) {
	                polyline.positions.pop();
	              }

	              polyline.positions.push(cartesian);
	            }

	            listener = this.$listeners.movingEvt;
	            listener && this.$emit('movingEvt', movement.endPosition, drawType);
	            onDrawingEvt(polyline, nIndex);

	          case 19:
	          case "end":
	            return _context5.stop();
	        }
	      }
	    }, null, this);
	  },
	  RIGHT_CLICK: function RIGHT_CLICK(movement) {
	    var viewer, polylines, mode, startNew, onDrawingEvt, nIndex, polyline, cartesian;
	    return regenerator.async(function RIGHT_CLICK$(_context6) {
	      while (1) {
	        switch (_context6.prev = _context6.next) {
	          case 0:
	            if (this.drawing) {
	              _context6.next = 2;
	              break;
	            }

	            return _context6.abrupt("return");

	          case 2:
	            viewer = this.viewer, polylines = this.polylines, mode = this.mode, startNew = this.startNew, onDrawingEvt = this.onDrawingEvt;

	            if (polylines.length) {
	              _context6.next = 5;
	              break;
	            }

	            return _context6.abrupt("return");

	          case 5:
	            nIndex = this.editingPoint ? this.editingPoint.polylineIndex : polylines.length - 1; // const nIndex = polylines.length - 1

	            polyline = polylines[nIndex];

	            if (!(polyline.positions.length === 0)) {
	              _context6.next = 9;
	              break;
	            }

	            return _context6.abrupt("return");

	          case 9:
	            cartesian = viewer.scene.pickPosition(movement.position);

	            if (Cesium.defined(cartesian)) {
	              _context6.next = 12;
	              break;
	            }

	            return _context6.abrupt("return");

	          case 12:
	            if (!this.editingPoint) {
	              if (polyline.positions.length > 1) {
	                polyline.positions.pop();
	              }

	              if (mode === 0) {
	                startNew();
	              } else {
	                this.drawing = false;
	              }
	            } else {
	              this.editingPoint = undefined;
	              this.drawing = false;
	            }

	            _context6.next = 15;
	            return regenerator.awrap(this.$nextTick());

	          case 15:
	            onDrawingEvt(polyline, nIndex, true);

	          case 16:
	          case "end":
	            return _context6.stop();
	        }
	      }
	    }, null, this);
	  },
	  startNew: function startNew() {
	    var polylines = this.polylines;
	    var poyline = {
	      positions: []
	    };
	    Cesium.defined(polylines) && polylines.push(poyline);
	  },
	  clear: function clear() {
	    this.polylines = [];
	    this.drawing = false;
	  },
	  onDrawingEvt: function onDrawingEvt(polyline, index) {
	    var flag = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
	    this.index = index;

	    if (!this.depthTest) {
	      var rs = Cesium.RenderState.fromCache({
	        depthMask: true,
	        depthTest: {
	          enabled: false
	        }
	      });
	      this.$refs.pointCollection && (this.$refs.pointCollection.cesiumObject._rsOpaque = rs);

	      if (Cesium.SuperMapImageryProvider) {
	        this.$refs.polylineCollection && (this.$refs.polylineCollection.cesiumObject._opaqueRS = rs);
	      } else {
	        this.$refs.polylineCollection && (this.$refs.polylineCollection.cesiumObject._opaqueRS.depthTest.enabled = false);
	      }
	    }

	    var listener = this.$listeners.drawEvt;
	    listener && this.$emit('drawEvt', {
	      polyline: polyline,
	      type: this.drawType,
	      finished: flag
	    });
	  },
	  pointMouseOver: function pointMouseOver(e) {
	    if (!this.editable) {
	      return;
	    }

	    if (this.editingPoint) {
	      return;
	    }

	    e.pickedFeature.primitive.pixelSize = this.pointPixelSize * 2.0;
	    this.toolbarPosition = e.pickedFeature.primitive.position;
	    this.showToolbar = true;
	    this.mouseoverPoint = e.pickedFeature.primitive;
	  },
	  pointMouseOut: function pointMouseOut(e) {
	    if (!this.editable) {
	      return;
	    }

	    e.pickedFeature.primitive.pixelSize = this.pointPixelSize * 1.0;
	    this.toolbarPosition = [0, 0, 0];
	    this.showToolbar = false;
	    this.mouseoverPoint = undefined;
	  },
	  onEditClick: function onEditClick(e) {
	    this.editType = e;
	    this.toolbarPosition = [0, 0, 0];
	    this.showToolbar = false;

	    if (!this.editable) {
	      return;
	    }

	    this.drawing = false;

	    if (e === 'delete') {
	      var nIndex = this.mouseoverPoint.polylineIndex;
	      var polyline = this.polylines[nIndex];
	      polyline.positions.splice(this.mouseoverPoint.positionIndex, 1);
	    } else if (e === 'insert') {
	      var _nIndex = this.mouseoverPoint.polylineIndex;
	      var _polyline = this.polylines[_nIndex];

	      _polyline.positions.splice(this.mouseoverPoint.positionIndex, 0, this.mouseoverPoint.position);

	      this.editingPoint = this.mouseoverPoint;
	      this.drawing = true;
	    } else {
	      this.editingPoint = this.mouseoverPoint;
	      this.drawing = true;
	    }
	  }
	};
	var mixinDraw = {
	  mixins: [cmp],
	  data: function data() {
	    return {
	      drawing: false,
	      polylines: [],
	      toolbarPosition: [0, 0, 0],
	      showToolbar: false,
	      tooltipPosition: [0, 0, 0],
	      showTooltip: false,
	      tooltip: '',
	      nowaiting: true
	    };
	  },
	  components: {
	    VcIconSvg: VcIconSvg
	  },
	  props: props$1,
	  watch: watch$2,
	  computed: computed,
	  methods: methods$b,
	  destroyed: function destroyed() {
	    var handler = this.handler;

	    if (handler) {
	      handler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_CLICK);
	      handler.removeInputAction(Cesium.ScreenSpaceEventType.MOUSE_MOVE);
	      handler.removeInputAction(Cesium.ScreenSpaceEventType.RIGHT_CLICK);
	      handler.destroy();
	    }
	  }
	};

	//
	var script$1y = {
	  name: 'vc-handler-draw-point',
	  mixins: [mixinDraw],
	  data: function data() {
	    return {
	      drawType: 'pointDrawing'
	    };
	  }
	};

	/* script */
	var __vue_script__$1y = script$1y;
	/* template */

	var __vue_render__$5 = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('i', {
	    class: _vm.$options.name
	  }, [_c('vc-collection-primitive-point', {
	    ref: "pointCollection",
	    attrs: {
	      "points": _vm.points
	    },
	    on: {
	      "mouseover": _vm.pointMouseOver,
	      "mouseout": _vm.pointMouseOut
	    }
	  }), _vm._v(" "), _vm.showToolbar ? _c('vc-overlay-html', {
	    attrs: {
	      "position": _vm.toolbarPosition
	    }
	  }, [_c('button', {
	    staticClass: "vc-btn",
	    attrs: {
	      "title": _vm.$vc.lang.draw.editingMove,
	      "type": "button"
	    },
	    on: {
	      "click": function click($event) {
	        return _vm.onEditClick('move');
	      }
	    }
	  }, [_c('vc-icon-svg', {
	    attrs: {
	      "name": "icon-move"
	    }
	  })], 1), _vm._v(" "), _c('button', {
	    staticClass: "vc-btn",
	    attrs: {
	      "title": _vm.$vc.lang.draw.editingInsert,
	      "type": "button"
	    },
	    on: {
	      "click": function click($event) {
	        return _vm.onEditClick('insert');
	      }
	    }
	  }, [_c('vc-icon-svg', {
	    attrs: {
	      "name": "icon-add"
	    }
	  })], 1), _vm._v(" "), _c('button', {
	    staticClass: "vc-btn",
	    attrs: {
	      "title": _vm.$vc.lang.draw.editingDelete,
	      "type": "button"
	    },
	    on: {
	      "click": function click($event) {
	        return _vm.onEditClick('delete');
	      }
	    }
	  }, [_c('vc-icon-svg', {
	    attrs: {
	      "name": "icon-delete"
	    }
	  })], 1)]) : _vm._e(), _vm._v(" "), _vm.showTooltip && _vm.showDrawTip ? _c('vc-overlay-html', {
	    attrs: {
	      "position": _vm.tooltipPosition,
	      "pixelOffset": [32, 32]
	    }
	  }, [_c('div', {
	    staticClass: "vc-html-bubble"
	  }, [_vm._v(_vm._s(_vm.tooltip))])]) : _vm._e()], 1);
	};

	var __vue_staticRenderFns__$5 = [];
	/* style */

	var __vue_inject_styles__$1y = undefined;
	/* scoped */

	var __vue_scope_id__$1y = undefined;
	/* functional template */

	var __vue_is_functional_template__$1y = false;
	/* component normalizer */

	function __vue_normalize__$1y(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "VcDrawHandlerPoint.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var VcDrawHandlerPoint = __vue_normalize__$1y({
	  render: __vue_render__$5,
	  staticRenderFns: __vue_staticRenderFns__$5
	}, __vue_inject_styles__$1y, __vue_script__$1y, __vue_scope_id__$1y, __vue_is_functional_template__$1y);

	var script$1z = {
	  name: 'vc-overlay-html',
	  mixins: [cmp, pixelOffset, position],
	  props: {
	    hiddenOnBack: {
	      type: Boolean,
	      default: true
	    }
	  },
	  data: function data() {
	    return {
	      nowaiting: true
	    };
	  },
	  methods: {
	    createCesiumObject: function createCesiumObject() {
	      var viewer, onPreRender;
	      return regenerator.async(function createCesiumObject$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              viewer = this.viewer, onPreRender = this.onPreRender;
	              viewer.scene.preRender.addEventListener(onPreRender);
	              return _context.abrupt("return", this.$el);

	            case 3:
	            case "end":
	              return _context.stop();
	          }
	        }
	      }, null, this);
	    },
	    mount: function mount() {
	      return regenerator.async(function mount$(_context2) {
	        while (1) {
	          switch (_context2.prev = _context2.next) {
	            case 0:
	              return _context2.abrupt("return", true);

	            case 1:
	            case "end":
	              return _context2.stop();
	          }
	        }
	      });
	    },
	    unmount: function unmount() {
	      var viewer, onPreRender;
	      return regenerator.async(function unmount$(_context3) {
	        while (1) {
	          switch (_context3.prev = _context3.next) {
	            case 0:
	              viewer = this.viewer, onPreRender = this.onPreRender;
	              viewer.scene.preRender.removeEventListener(onPreRender);
	              this.$el.style.display = 'none';
	              return _context3.abrupt("return", true);

	            case 4:
	            case "end":
	              return _context3.stop();
	          }
	        }
	      }, null, this);
	    },
	    onPreRender: function onPreRender() {
	      var viewer = this.viewer,
	          position = this.position,
	          pixelOffset = this.pixelOffset,
	          hiddenOnBack = this.hiddenOnBack;
	      var cartesian2 = makeCartesian2(pixelOffset);
	      var cartesian3 = makeCartesian3(position);
	      var scratch = {};
	      var canvasPosition = viewer.scene.cartesianToCanvasCoordinates(cartesian3, scratch);

	      if (Cesium.defined(canvasPosition)) {
	        this.$el.style.left = canvasPosition.x + cartesian2.x + 'px';
	        this.$el.style.top = canvasPosition.y + cartesian2.y + 'px';

	        if (hiddenOnBack) {
	          var cameraPosition = viewer.camera.position;
	          var cartographicPosition = viewer.scene.globe.ellipsoid.cartesianToCartographic(cameraPosition);

	          if (Cesium.defined(cartographicPosition)) {
	            var cameraHeight = cartographicPosition.height;
	            cameraHeight += 1 * viewer.scene.globe.ellipsoid.maximumRadius;

	            if (Cesium.Cartesian3.distance(cameraPosition, cartesian3) > cameraHeight) {
	              this.$el.style.display = 'none';
	            } else {
	              this.$el.style.display = 'block';
	            }
	          }
	        }
	      }
	    },
	    onClick: function onClick(e) {
	      var listener = this.$listeners.click;
	      listener && this.$emit('click', e);
	    }
	  },
	  created: function created() {
	    var _this = this;

	    defineProperties$1(this, {
	      element: {
	        enumerable: true,
	        get: function get() {
	          return _this.cesiumObject;
	        }
	      }
	    });
	  }
	};

	/* script */
	var __vue_script__$1z = script$1z;
	/* template */

	var __vue_render__$6 = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('div', {
	    staticClass: "vc-html-container",
	    on: {
	      "click": _vm.onClick
	    }
	  }, [_vm._t("default")], 2);
	};

	var __vue_staticRenderFns__$6 = [];
	/* style */

	var __vue_inject_styles__$1z = undefined;
	/* scoped */

	var __vue_scope_id__$1z = undefined;
	/* functional template */

	var __vue_is_functional_template__$1z = false;
	/* component normalizer */

	function __vue_normalize__$1z(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "VcHTMLOverlay.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var VcHTMLOverlay = __vue_normalize__$1z({
	  render: __vue_render__$6,
	  staticRenderFns: __vue_staticRenderFns__$6
	}, __vue_inject_styles__$1z, __vue_script__$1z, __vue_scope_id__$1z, __vue_is_functional_template__$1z);

	function plugin$1x(Vue) {

	  if (plugin$1x.installed) {
	    return;
	  }

	  plugin$1x.installed = true;
	  Vue.component(VcHTMLOverlay.name, VcHTMLOverlay);
	}

	var VcHTMLOverlay$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$1x,
		VcHTMLOverlay: VcHTMLOverlay,
		install: plugin$1x
	});

	function plugin$1y(Vue) {

	  if (plugin$1y.installed) {
	    return;
	  }

	  plugin$1y.installed = true;
	  Vue.use(PointPrimitiveCollection$1);
	  Vue.use(PointPrimitive$1);
	  Vue.use(VcHTMLOverlay$1);
	  Vue.component(VcDrawHandlerPoint.name, VcDrawHandlerPoint);
	}

	var VcDrawHandlerPoint$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$1y,
		VcDrawHandlerPoint: VcDrawHandlerPoint,
		install: plugin$1y
	});

	//
	var script$1A = {
	  name: 'vc-handler-draw-polyline',
	  mixins: [mixinDraw],
	  data: function data() {
	    return {
	      drawType: 'polylineDrawing'
	    };
	  },
	  props: {
	    depthTest: {
	      type: Boolean,
	      default: false
	    },
	    polylineMaterial: {
	      type: Object,
	      default: function _default() {
	        return {
	          fabric: {
	            type: 'Color',
	            uniforms: {
	              color: '#51ff00'
	            }
	          }
	        };
	      }
	    },
	    polylineWidth: {
	      type: Number,
	      default: 2
	    },
	    clampToGround: {
	      type: Boolean,
	      default: false
	    }
	  },
	  computed: {
	    primitivePolylines: function primitivePolylines() {
	      var _this = this;

	      var polylines = [];
	      this.polylines.forEach(function (item, index) {
	        var polyline = {
	          material: _this.polylineMaterial,
	          positions: item.positions,
	          width: _this.polylineWidth,
	          polylineIndex: index
	        };
	        polylines.push(polyline);
	      });
	      return polylines;
	    }
	  },
	  methods: {
	    makeAppearance: function makeAppearance(val) {
	      return new Cesium.PolylineMaterialAppearance({
	        material: makeMaterial.call(this, val)
	      });
	    }
	  }
	};

	/* script */
	var __vue_script__$1A = script$1A;
	/* template */

	var __vue_render__$7 = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('i', {
	    class: _vm.$options.name
	  }, [_c('vc-collection-primitive', {
	    attrs: {
	      "show": _vm.show
	    }
	  }, [_vm.clampToGround ? _c('vc-collection-primitive', {
	    ref: "groundPolylineCollection"
	  }, [_vm._l(_vm.polylines, function (polyline, index) {
	    return [polyline.positions.length > 1 ? _c('vc-primitive-polyline-ground', {
	      key: index,
	      attrs: {
	        "appearance": _vm.makeAppearance(_vm.polylineMaterial),
	        "asynchronous": false
	      }
	    }, [_c('vc-instance-geometry', [_c('vc-geometry-polyline-ground', {
	      attrs: {
	        "positions": polyline.positions,
	        "width": _vm.polylineWidth
	      }
	    })], 1)], 1) : _vm._e()];
	  })], 2) : _c('vc-collection-primitive-polyline', {
	    ref: "polylineCollection",
	    attrs: {
	      "polylines": _vm.primitivePolylines
	    }
	  }), _vm._v(" "), _c('vc-collection-primitive-point', {
	    ref: "pointCollection",
	    attrs: {
	      "points": _vm.points
	    },
	    on: {
	      "mouseover": _vm.pointMouseOver,
	      "mouseout": _vm.pointMouseOut
	    }
	  })], 1), _vm._v(" "), _vm.showToolbar ? _c('vc-overlay-html', {
	    attrs: {
	      "position": _vm.toolbarPosition
	    }
	  }, [_c('button', {
	    staticClass: "vc-btn",
	    attrs: {
	      "title": _vm.$vc.lang.draw.editingMove,
	      "type": "button"
	    },
	    on: {
	      "click": function click($event) {
	        return _vm.onEditClick('move');
	      }
	    }
	  }, [_c('vc-icon-svg', {
	    attrs: {
	      "name": "icon-move"
	    }
	  })], 1), _vm._v(" "), _c('button', {
	    staticClass: "vc-btn",
	    attrs: {
	      "title": _vm.$vc.lang.draw.editingInsert,
	      "type": "button"
	    },
	    on: {
	      "click": function click($event) {
	        return _vm.onEditClick('insert');
	      }
	    }
	  }, [_c('vc-icon-svg', {
	    attrs: {
	      "name": "icon-add"
	    }
	  })], 1), _vm._v(" "), _c('button', {
	    staticClass: "vc-btn",
	    attrs: {
	      "title": _vm.$vc.lang.draw.editingDelete,
	      "type": "button"
	    },
	    on: {
	      "click": function click($event) {
	        return _vm.onEditClick('delete');
	      }
	    }
	  }, [_c('vc-icon-svg', {
	    attrs: {
	      "name": "icon-delete"
	    }
	  })], 1)]) : _vm._e(), _vm._v(" "), _vm.showTooltip && _vm.showDrawTip ? _c('vc-overlay-html', {
	    attrs: {
	      "position": _vm.tooltipPosition,
	      "pixelOffset": [32, 32]
	    }
	  }, [_c('div', {
	    staticClass: "vc-html-bubble"
	  }, [_vm._v(_vm._s(_vm.tooltip))])]) : _vm._e()], 1);
	};

	var __vue_staticRenderFns__$7 = [];
	/* style */

	var __vue_inject_styles__$1A = undefined;
	/* scoped */

	var __vue_scope_id__$1A = undefined;
	/* functional template */

	var __vue_is_functional_template__$1A = false;
	/* component normalizer */

	function __vue_normalize__$1A(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "VcDrawHandlerPolyline.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var VcDrawHandlerPolyline = __vue_normalize__$1A({
	  render: __vue_render__$7,
	  staticRenderFns: __vue_staticRenderFns__$7
	}, __vue_inject_styles__$1A, __vue_script__$1A, __vue_scope_id__$1A, __vue_is_functional_template__$1A);

	function plugin$1z(Vue) {

	  if (plugin$1z.installed) {
	    return;
	  }

	  plugin$1z.installed = true;
	  Vue.use(PrimitiveCollection$1);
	  Vue.use(GeometryInstance$1);
	  Vue.use(GroundPolylinePrimitive$1);
	  Vue.use(GroundPolylineGeometry$1);
	  Vue.use(PolylineCollection$1);
	  Vue.use(Polyline$1);
	  Vue.use(PointPrimitiveCollection$1);
	  Vue.use(PointPrimitive$1);
	  Vue.use(VcHTMLOverlay$1);
	  Vue.component(VcDrawHandlerPolyline.name, VcDrawHandlerPolyline);
	}

	var VcDrawHandlerPolyline$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$1z,
		VcDrawHandlerPolyline: VcDrawHandlerPolyline,
		install: plugin$1z
	});

	//
	var script$1B = {
	  name: 'vc-handler-draw-polygon',
	  mixins: [mixinDraw],
	  data: function data() {
	    return {
	      drawType: 'polygonDrawing'
	    };
	  },
	  props: {
	    depthTest: {
	      type: Boolean,
	      default: true
	    },
	    perPositionHeight: {
	      type: Boolean,
	      default: true
	    },
	    polylineMaterial: {
	      type: Object,
	      default: function _default() {
	        return {
	          fabric: {
	            type: 'Color',
	            uniforms: {
	              color: '#51ff00'
	            }
	          }
	        };
	      }
	    },
	    polylineWidth: {
	      type: Number,
	      default: 2
	    },
	    polygonMaterial: {
	      type: Object,
	      default: function _default() {
	        return {
	          fabric: {
	            type: 'Color',
	            uniforms: {
	              color: 'rgba(255,165,0,0.25)'
	            }
	          }
	        };
	      }
	    },
	    clampToGround: {
	      type: Boolean,
	      default: false
	    }
	  },
	  computed: {
	    primitivePolylines: function primitivePolylines() {
	      var _this = this;

	      var polylines = [];
	      this.polylines.forEach(function (item, index) {
	        var polyline = {
	          material: _this.polylineMaterial,
	          positions: item.positions,
	          width: _this.polylineWidth,
	          loop: true,
	          polylineIndex: index
	        };
	        polylines.push(polyline);
	      });
	      return polylines;
	    }
	  },
	  methods: {
	    makeEllipsoidSurfaceAppearance: function makeEllipsoidSurfaceAppearance(val) {
	      return new Cesium.EllipsoidSurfaceAppearance({
	        material: makeMaterial.call(this, val),
	        renderState: {
	          cull: {
	            enabled: false
	          }
	        }
	      });
	    },
	    makePolylineMaterialAppearance: function makePolylineMaterialAppearance(val) {
	      return new Cesium.PolylineMaterialAppearance({
	        material: makeMaterial.call(this, val)
	      });
	    },
	    clone: clone
	  }
	};

	/* script */
	var __vue_script__$1B = script$1B;
	/* template */

	var __vue_render__$8 = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('i', {
	    class: _vm.$options.name
	  }, [_c('vc-collection-primitive', {
	    attrs: {
	      "show": _vm.show
	    }
	  }, [!_vm.clampToGround ? _c('vc-collection-primitive', {
	    ref: "polygonCollection"
	  }, [_vm._l(_vm.polylines, function (polyline, index) {
	    return [polyline.positions.length > 2 ? _c('vc-primitive', {
	      key: index,
	      attrs: {
	        "appearance": _vm.makeEllipsoidSurfaceAppearance(_vm.polygonMaterial),
	        "asynchronous": false
	      }
	    }, [_c('vc-instance-geometry', [_c('vc-geometry-polygon', {
	      attrs: {
	        "perPositionHeight": true,
	        "polygonHierarchy": _vm.clone(polyline.positions, true)
	      }
	    })], 1)], 1) : _vm._e()];
	  })], 2) : _c('vc-collection-primitive', {
	    ref: "groundPolygonCollection"
	  }, [_vm._l(_vm.polylines, function (polyline, index) {
	    return [polyline.positions.length > 2 ? _c('vc-primitive-ground', {
	      key: index,
	      attrs: {
	        "appearance": _vm.makeEllipsoidSurfaceAppearance(_vm.polygonMaterial),
	        "asynchronous": false
	      }
	    }, [_c('vc-instance-geometry', [_c('vc-geometry-polygon', {
	      attrs: {
	        "perPositionHeight": false,
	        "polygonHierarchy": _vm.clone(polyline.positions, true)
	      }
	    })], 1)], 1) : _vm._e()];
	  })], 2), _vm._v(" "), _vm.clampToGround ? _c('vc-collection-primitive', {
	    ref: "groundPolylineCollection"
	  }, [_vm._l(_vm.polylines, function (polyline, index) {
	    return [polyline.positions.length > 1 ? _c('vc-primitive-polyline-ground', {
	      key: index,
	      attrs: {
	        "appearance": _vm.makePolylineMaterialAppearance(_vm.polylineMaterial),
	        "asynchronous": false
	      }
	    }, [_c('vc-instance-geometry', [_c('vc-geometry-polyline-ground', {
	      attrs: {
	        "positions": polyline.positions,
	        "width": _vm.polylineWidth,
	        "loop": ""
	      }
	    })], 1)], 1) : _vm._e()];
	  })], 2) : _c('vc-collection-primitive-polyline', {
	    ref: "polylineCollection",
	    attrs: {
	      "polylines": _vm.primitivePolylines
	    }
	  }), _vm._v(" "), _c('vc-collection-primitive-point', {
	    ref: "pointCollection",
	    attrs: {
	      "points": _vm.points
	    },
	    on: {
	      "mouseover": _vm.pointMouseOver,
	      "mouseout": _vm.pointMouseOut
	    }
	  })], 1), _vm._v(" "), _vm.showToolbar ? _c('vc-overlay-html', {
	    attrs: {
	      "position": _vm.toolbarPosition
	    }
	  }, [_c('button', {
	    staticClass: "vc-btn",
	    attrs: {
	      "title": _vm.$vc.lang.draw.editingMove,
	      "type": "button"
	    },
	    on: {
	      "click": function click($event) {
	        return _vm.onEditClick('move');
	      }
	    }
	  }, [_c('vc-icon-svg', {
	    attrs: {
	      "name": "icon-move"
	    }
	  })], 1), _vm._v(" "), _c('button', {
	    staticClass: "vc-btn",
	    attrs: {
	      "title": _vm.$vc.lang.draw.editingInsert,
	      "type": "button"
	    },
	    on: {
	      "click": function click($event) {
	        return _vm.onEditClick('insert');
	      }
	    }
	  }, [_c('vc-icon-svg', {
	    attrs: {
	      "name": "icon-add"
	    }
	  })], 1), _vm._v(" "), _c('button', {
	    staticClass: "vc-btn",
	    attrs: {
	      "title": _vm.$vc.lang.draw.editingDelete,
	      "type": "button"
	    },
	    on: {
	      "click": function click($event) {
	        return _vm.onEditClick('delete');
	      }
	    }
	  }, [_c('vc-icon-svg', {
	    attrs: {
	      "name": "icon-delete"
	    }
	  })], 1)]) : _vm._e(), _vm._v(" "), _vm.showTooltip && _vm.showDrawTip ? _c('vc-overlay-html', {
	    attrs: {
	      "position": _vm.tooltipPosition,
	      "pixelOffset": [32, 32]
	    }
	  }, [_c('div', {
	    staticClass: "vc-html-bubble"
	  }, [_vm._v(_vm._s(_vm.tooltip))])]) : _vm._e()], 1);
	};

	var __vue_staticRenderFns__$8 = [];
	/* style */

	var __vue_inject_styles__$1B = undefined;
	/* scoped */

	var __vue_scope_id__$1B = undefined;
	/* functional template */

	var __vue_is_functional_template__$1B = false;
	/* component normalizer */

	function __vue_normalize__$1B(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "VcDrawHandlerPolygon.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var VcDrawHandlerPolygon = __vue_normalize__$1B({
	  render: __vue_render__$8,
	  staticRenderFns: __vue_staticRenderFns__$8
	}, __vue_inject_styles__$1B, __vue_script__$1B, __vue_scope_id__$1B, __vue_is_functional_template__$1B);

	function plugin$1A(Vue) {

	  if (plugin$1A.installed) {
	    return;
	  }

	  plugin$1A.installed = true;
	  Vue.use(PrimitiveCollection$1);
	  Vue.use(GroundPrimitive$1);
	  Vue.use(GeometryInstance$1);
	  Vue.use(PolygonGeometry$1);
	  Vue.use(Primitive$1);
	  Vue.use(GroundPolylinePrimitive$1);
	  Vue.use(GroundPolylineGeometry$1);
	  Vue.use(PolylineCollection$1);
	  Vue.use(Polyline$1);
	  Vue.use(PointPrimitiveCollection$1);
	  Vue.use(PointPrimitive$1);
	  Vue.use(VcHTMLOverlay$1);
	  Vue.component(VcDrawHandlerPolygon.name, VcDrawHandlerPolygon);
	}

	var VcDrawHandlerPolygon$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$1A,
		VcDrawHandlerPolygon: VcDrawHandlerPolygon,
		install: plugin$1A
	});

	/**
	 * Turns the longitude / latitude in degrees into a human readable pretty strings.
	 *
	 * @param {Number} longitude The longitude to format.
	 * @param {Number} latitude The latitude to format.
	 * @param {Object} options Object with the following properties:
	 * @param {Number} options.height The height.
	 * @param {Number} options.errorBar The error +/- for the height.
	 * @param {Number} options.digits The number of digits to fix the lat / lon to.
	 */
	function prettifyCoordinates(longitude, latitude, options) {
	  var result = {};
	  var _Cesium = Cesium,
	      defaultValue = _Cesium.defaultValue,
	      defined = _Cesium.defined;
	  var optionsDefaulted = defaultValue(options, {});
	  var digits = defaultValue(optionsDefaulted.digits, 5);
	  result.latitude = Math.abs(latitude).toFixed(digits) + '°' + (latitude < 0.0 ? 'S' : 'N');
	  result.longitude = Math.abs(longitude).toFixed(digits) + '°' + (longitude < 0.0 ? 'W' : 'E');

	  if (defined(optionsDefaulted.height)) {
	    result.elevation = Math.round(optionsDefaulted.height) + (defined(optionsDefaulted.errorBar) ? '±' + Math.round(optionsDefaulted.errorBar) : '') + 'm';
	  } else {
	    result.elevation = undefined;
	  }

	  return result;
	}

	var proj4Src = createCommonjsModule(function (module, exports) {
	(function (global, factory) {
	     module.exports = factory() ;
	}(commonjsGlobal, (function () {
	    var globals = function(defs) {
	      defs('EPSG:4326', "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees");
	      defs('EPSG:4269', "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees");
	      defs('EPSG:3857', "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");

	      defs.WGS84 = defs['EPSG:4326'];
	      defs['EPSG:3785'] = defs['EPSG:3857']; // maintain backward compat, official code is 3857
	      defs.GOOGLE = defs['EPSG:3857'];
	      defs['EPSG:900913'] = defs['EPSG:3857'];
	      defs['EPSG:102113'] = defs['EPSG:3857'];
	    };

	    var PJD_3PARAM = 1;
	    var PJD_7PARAM = 2;
	    var PJD_WGS84 = 4; // WGS84 or equivalent
	    var PJD_NODATUM = 5; // WGS84 or equivalent
	    var SEC_TO_RAD = 4.84813681109535993589914102357e-6;
	    var HALF_PI = Math.PI/2;
	    // ellipoid pj_set_ell.c
	    var SIXTH = 0.1666666666666666667;
	    /* 1/6 */
	    var RA4 = 0.04722222222222222222;
	    /* 17/360 */
	    var RA6 = 0.02215608465608465608;
	    var EPSLN = 1.0e-10;
	    // you'd think you could use Number.EPSILON above but that makes
	    // Mollweide get into an infinate loop.

	    var D2R = 0.01745329251994329577;
	    var R2D = 57.29577951308232088;
	    var FORTPI = Math.PI/4;
	    var TWO_PI = Math.PI * 2;
	    // SPI is slightly greater than Math.PI, so values that exceed the -180..180
	    // degree range by a tiny amount don't get wrapped. This prevents points that
	    // have drifted from their original location along the 180th meridian (due to
	    // floating point error) from changing their sign.
	    var SPI = 3.14159265359;

	    var exports$1 = {};
	    exports$1.greenwich = 0.0; //"0dE",
	    exports$1.lisbon = -9.131906111111; //"9d07'54.862\"W",
	    exports$1.paris = 2.337229166667; //"2d20'14.025\"E",
	    exports$1.bogota = -74.080916666667; //"74d04'51.3\"W",
	    exports$1.madrid = -3.687938888889; //"3d41'16.58\"W",
	    exports$1.rome = 12.452333333333; //"12d27'8.4\"E",
	    exports$1.bern = 7.439583333333; //"7d26'22.5\"E",
	    exports$1.jakarta = 106.807719444444; //"106d48'27.79\"E",
	    exports$1.ferro = -17.666666666667; //"17d40'W",
	    exports$1.brussels = 4.367975; //"4d22'4.71\"E",
	    exports$1.stockholm = 18.058277777778; //"18d3'29.8\"E",
	    exports$1.athens = 23.7163375; //"23d42'58.815\"E",
	    exports$1.oslo = 10.722916666667; //"10d43'22.5\"E"

	    var units = {
	      ft: {to_meter: 0.3048},
	      'us-ft': {to_meter: 1200 / 3937}
	    };

	    var ignoredChar = /[\s_\-\/\(\)]/g;
	    function match(obj, key) {
	      if (obj[key]) {
	        return obj[key];
	      }
	      var keys = Object.keys(obj);
	      var lkey = key.toLowerCase().replace(ignoredChar, '');
	      var i = -1;
	      var testkey, processedKey;
	      while (++i < keys.length) {
	        testkey = keys[i];
	        processedKey = testkey.toLowerCase().replace(ignoredChar, '');
	        if (processedKey === lkey) {
	          return obj[testkey];
	        }
	      }
	    }

	    var parseProj = function(defData) {
	      var self = {};
	      var paramObj = defData.split('+').map(function(v) {
	        return v.trim();
	      }).filter(function(a) {
	        return a;
	      }).reduce(function(p, a) {
	        var split = a.split('=');
	        split.push(true);
	        p[split[0].toLowerCase()] = split[1];
	        return p;
	      }, {});
	      var paramName, paramVal, paramOutname;
	      var params = {
	        proj: 'projName',
	        datum: 'datumCode',
	        rf: function(v) {
	          self.rf = parseFloat(v);
	        },
	        lat_0: function(v) {
	          self.lat0 = v * D2R;
	        },
	        lat_1: function(v) {
	          self.lat1 = v * D2R;
	        },
	        lat_2: function(v) {
	          self.lat2 = v * D2R;
	        },
	        lat_ts: function(v) {
	          self.lat_ts = v * D2R;
	        },
	        lon_0: function(v) {
	          self.long0 = v * D2R;
	        },
	        lon_1: function(v) {
	          self.long1 = v * D2R;
	        },
	        lon_2: function(v) {
	          self.long2 = v * D2R;
	        },
	        alpha: function(v) {
	          self.alpha = parseFloat(v) * D2R;
	        },
	        lonc: function(v) {
	          self.longc = v * D2R;
	        },
	        x_0: function(v) {
	          self.x0 = parseFloat(v);
	        },
	        y_0: function(v) {
	          self.y0 = parseFloat(v);
	        },
	        k_0: function(v) {
	          self.k0 = parseFloat(v);
	        },
	        k: function(v) {
	          self.k0 = parseFloat(v);
	        },
	        a: function(v) {
	          self.a = parseFloat(v);
	        },
	        b: function(v) {
	          self.b = parseFloat(v);
	        },
	        r_a: function() {
	          self.R_A = true;
	        },
	        zone: function(v) {
	          self.zone = parseInt(v, 10);
	        },
	        south: function() {
	          self.utmSouth = true;
	        },
	        towgs84: function(v) {
	          self.datum_params = v.split(",").map(function(a) {
	            return parseFloat(a);
	          });
	        },
	        to_meter: function(v) {
	          self.to_meter = parseFloat(v);
	        },
	        units: function(v) {
	          self.units = v;
	          var unit = match(units, v);
	          if (unit) {
	            self.to_meter = unit.to_meter;
	          }
	        },
	        from_greenwich: function(v) {
	          self.from_greenwich = v * D2R;
	        },
	        pm: function(v) {
	          var pm = match(exports$1, v);
	          self.from_greenwich = (pm ? pm : parseFloat(v)) * D2R;
	        },
	        nadgrids: function(v) {
	          if (v === '@null') {
	            self.datumCode = 'none';
	          }
	          else {
	            self.nadgrids = v;
	          }
	        },
	        axis: function(v) {
	          var legalAxis = "ewnsud";
	          if (v.length === 3 && legalAxis.indexOf(v.substr(0, 1)) !== -1 && legalAxis.indexOf(v.substr(1, 1)) !== -1 && legalAxis.indexOf(v.substr(2, 1)) !== -1) {
	            self.axis = v;
	          }
	        }
	      };
	      for (paramName in paramObj) {
	        paramVal = paramObj[paramName];
	        if (paramName in params) {
	          paramOutname = params[paramName];
	          if (typeof paramOutname === 'function') {
	            paramOutname(paramVal);
	          }
	          else {
	            self[paramOutname] = paramVal;
	          }
	        }
	        else {
	          self[paramName] = paramVal;
	        }
	      }
	      if(typeof self.datumCode === 'string' && self.datumCode !== "WGS84"){
	        self.datumCode = self.datumCode.toLowerCase();
	      }
	      return self;
	    };

	    var NEUTRAL = 1;
	    var KEYWORD = 2;
	    var NUMBER = 3;
	    var QUOTED = 4;
	    var AFTERQUOTE = 5;
	    var ENDED = -1;
	    var whitespace = /\s/;
	    var latin = /[A-Za-z]/;
	    var keyword = /[A-Za-z84]/;
	    var endThings = /[,\]]/;
	    var digets = /[\d\.E\-\+]/;
	    // const ignoredChar = /[\s_\-\/\(\)]/g;
	    function Parser(text) {
	      if (typeof text !== 'string') {
	        throw new Error('not a string');
	      }
	      this.text = text.trim();
	      this.level = 0;
	      this.place = 0;
	      this.root = null;
	      this.stack = [];
	      this.currentObject = null;
	      this.state = NEUTRAL;
	    }
	    Parser.prototype.readCharicter = function() {
	      var char = this.text[this.place++];
	      if (this.state !== QUOTED) {
	        while (whitespace.test(char)) {
	          if (this.place >= this.text.length) {
	            return;
	          }
	          char = this.text[this.place++];
	        }
	      }
	      switch (this.state) {
	        case NEUTRAL:
	          return this.neutral(char);
	        case KEYWORD:
	          return this.keyword(char)
	        case QUOTED:
	          return this.quoted(char);
	        case AFTERQUOTE:
	          return this.afterquote(char);
	        case NUMBER:
	          return this.number(char);
	        case ENDED:
	          return;
	      }
	    };
	    Parser.prototype.afterquote = function(char) {
	      if (char === '"') {
	        this.word += '"';
	        this.state = QUOTED;
	        return;
	      }
	      if (endThings.test(char)) {
	        this.word = this.word.trim();
	        this.afterItem(char);
	        return;
	      }
	      throw new Error('havn\'t handled "' +char + '" in afterquote yet, index ' + this.place);
	    };
	    Parser.prototype.afterItem = function(char) {
	      if (char === ',') {
	        if (this.word !== null) {
	          this.currentObject.push(this.word);
	        }
	        this.word = null;
	        this.state = NEUTRAL;
	        return;
	      }
	      if (char === ']') {
	        this.level--;
	        if (this.word !== null) {
	          this.currentObject.push(this.word);
	          this.word = null;
	        }
	        this.state = NEUTRAL;
	        this.currentObject = this.stack.pop();
	        if (!this.currentObject) {
	          this.state = ENDED;
	        }

	        return;
	      }
	    };
	    Parser.prototype.number = function(char) {
	      if (digets.test(char)) {
	        this.word += char;
	        return;
	      }
	      if (endThings.test(char)) {
	        this.word = parseFloat(this.word);
	        this.afterItem(char);
	        return;
	      }
	      throw new Error('havn\'t handled "' +char + '" in number yet, index ' + this.place);
	    };
	    Parser.prototype.quoted = function(char) {
	      if (char === '"') {
	        this.state = AFTERQUOTE;
	        return;
	      }
	      this.word += char;
	      return;
	    };
	    Parser.prototype.keyword = function(char) {
	      if (keyword.test(char)) {
	        this.word += char;
	        return;
	      }
	      if (char === '[') {
	        var newObjects = [];
	        newObjects.push(this.word);
	        this.level++;
	        if (this.root === null) {
	          this.root = newObjects;
	        } else {
	          this.currentObject.push(newObjects);
	        }
	        this.stack.push(this.currentObject);
	        this.currentObject = newObjects;
	        this.state = NEUTRAL;
	        return;
	      }
	      if (endThings.test(char)) {
	        this.afterItem(char);
	        return;
	      }
	      throw new Error('havn\'t handled "' +char + '" in keyword yet, index ' + this.place);
	    };
	    Parser.prototype.neutral = function(char) {
	      if (latin.test(char)) {
	        this.word = char;
	        this.state = KEYWORD;
	        return;
	      }
	      if (char === '"') {
	        this.word = '';
	        this.state = QUOTED;
	        return;
	      }
	      if (digets.test(char)) {
	        this.word = char;
	        this.state = NUMBER;
	        return;
	      }
	      if (endThings.test(char)) {
	        this.afterItem(char);
	        return;
	      }
	      throw new Error('havn\'t handled "' +char + '" in neutral yet, index ' + this.place);
	    };
	    Parser.prototype.output = function() {
	      while (this.place < this.text.length) {
	        this.readCharicter();
	      }
	      if (this.state === ENDED) {
	        return this.root;
	      }
	      throw new Error('unable to parse string "' +this.text + '". State is ' + this.state);
	    };

	    function parseString(txt) {
	      var parser = new Parser(txt);
	      return parser.output();
	    }

	    function mapit(obj, key, value) {
	      if (Array.isArray(key)) {
	        value.unshift(key);
	        key = null;
	      }
	      var thing = key ? {} : obj;

	      var out = value.reduce(function(newObj, item) {
	        sExpr(item, newObj);
	        return newObj
	      }, thing);
	      if (key) {
	        obj[key] = out;
	      }
	    }

	    function sExpr(v, obj) {
	      if (!Array.isArray(v)) {
	        obj[v] = true;
	        return;
	      }
	      var key = v.shift();
	      if (key === 'PARAMETER') {
	        key = v.shift();
	      }
	      if (v.length === 1) {
	        if (Array.isArray(v[0])) {
	          obj[key] = {};
	          sExpr(v[0], obj[key]);
	          return;
	        }
	        obj[key] = v[0];
	        return;
	      }
	      if (!v.length) {
	        obj[key] = true;
	        return;
	      }
	      if (key === 'TOWGS84') {
	        obj[key] = v;
	        return;
	      }
	      if (!Array.isArray(key)) {
	        obj[key] = {};
	      }

	      var i;
	      switch (key) {
	        case 'UNIT':
	        case 'PRIMEM':
	        case 'VERT_DATUM':
	          obj[key] = {
	            name: v[0].toLowerCase(),
	            convert: v[1]
	          };
	          if (v.length === 3) {
	            sExpr(v[2], obj[key]);
	          }
	          return;
	        case 'SPHEROID':
	        case 'ELLIPSOID':
	          obj[key] = {
	            name: v[0],
	            a: v[1],
	            rf: v[2]
	          };
	          if (v.length === 4) {
	            sExpr(v[3], obj[key]);
	          }
	          return;
	        case 'PROJECTEDCRS':
	        case 'PROJCRS':
	        case 'GEOGCS':
	        case 'GEOCCS':
	        case 'PROJCS':
	        case 'LOCAL_CS':
	        case 'GEODCRS':
	        case 'GEODETICCRS':
	        case 'GEODETICDATUM':
	        case 'EDATUM':
	        case 'ENGINEERINGDATUM':
	        case 'VERT_CS':
	        case 'VERTCRS':
	        case 'VERTICALCRS':
	        case 'COMPD_CS':
	        case 'COMPOUNDCRS':
	        case 'ENGINEERINGCRS':
	        case 'ENGCRS':
	        case 'FITTED_CS':
	        case 'LOCAL_DATUM':
	        case 'DATUM':
	          v[0] = ['name', v[0]];
	          mapit(obj, key, v);
	          return;
	        default:
	          i = -1;
	          while (++i < v.length) {
	            if (!Array.isArray(v[i])) {
	              return sExpr(v, obj[key]);
	            }
	          }
	          return mapit(obj, key, v);
	      }
	    }

	    var D2R$1 = 0.01745329251994329577;
	    function rename(obj, params) {
	      var outName = params[0];
	      var inName = params[1];
	      if (!(outName in obj) && (inName in obj)) {
	        obj[outName] = obj[inName];
	        if (params.length === 3) {
	          obj[outName] = params[2](obj[outName]);
	        }
	      }
	    }

	    function d2r(input) {
	      return input * D2R$1;
	    }

	    function cleanWKT(wkt) {
	      if (wkt.type === 'GEOGCS') {
	        wkt.projName = 'longlat';
	      } else if (wkt.type === 'LOCAL_CS') {
	        wkt.projName = 'identity';
	        wkt.local = true;
	      } else {
	        if (typeof wkt.PROJECTION === 'object') {
	          wkt.projName = Object.keys(wkt.PROJECTION)[0];
	        } else {
	          wkt.projName = wkt.PROJECTION;
	        }
	      }
	      if (wkt.UNIT) {
	        wkt.units = wkt.UNIT.name.toLowerCase();
	        if (wkt.units === 'metre') {
	          wkt.units = 'meter';
	        }
	        if (wkt.UNIT.convert) {
	          if (wkt.type === 'GEOGCS') {
	            if (wkt.DATUM && wkt.DATUM.SPHEROID) {
	              wkt.to_meter = wkt.UNIT.convert*wkt.DATUM.SPHEROID.a;
	            }
	          } else {
	            wkt.to_meter = wkt.UNIT.convert;
	          }
	        }
	      }
	      var geogcs = wkt.GEOGCS;
	      if (wkt.type === 'GEOGCS') {
	        geogcs = wkt;
	      }
	      if (geogcs) {
	        //if(wkt.GEOGCS.PRIMEM&&wkt.GEOGCS.PRIMEM.convert){
	        //  wkt.from_greenwich=wkt.GEOGCS.PRIMEM.convert*D2R;
	        //}
	        if (geogcs.DATUM) {
	          wkt.datumCode = geogcs.DATUM.name.toLowerCase();
	        } else {
	          wkt.datumCode = geogcs.name.toLowerCase();
	        }
	        if (wkt.datumCode.slice(0, 2) === 'd_') {
	          wkt.datumCode = wkt.datumCode.slice(2);
	        }
	        if (wkt.datumCode === 'new_zealand_geodetic_datum_1949' || wkt.datumCode === 'new_zealand_1949') {
	          wkt.datumCode = 'nzgd49';
	        }
	        if (wkt.datumCode === 'wgs_1984') {
	          if (wkt.PROJECTION === 'Mercator_Auxiliary_Sphere') {
	            wkt.sphere = true;
	          }
	          wkt.datumCode = 'wgs84';
	        }
	        if (wkt.datumCode.slice(-6) === '_ferro') {
	          wkt.datumCode = wkt.datumCode.slice(0, - 6);
	        }
	        if (wkt.datumCode.slice(-8) === '_jakarta') {
	          wkt.datumCode = wkt.datumCode.slice(0, - 8);
	        }
	        if (~wkt.datumCode.indexOf('belge')) {
	          wkt.datumCode = 'rnb72';
	        }
	        if (geogcs.DATUM && geogcs.DATUM.SPHEROID) {
	          wkt.ellps = geogcs.DATUM.SPHEROID.name.replace('_19', '').replace(/[Cc]larke\_18/, 'clrk');
	          if (wkt.ellps.toLowerCase().slice(0, 13) === 'international') {
	            wkt.ellps = 'intl';
	          }

	          wkt.a = geogcs.DATUM.SPHEROID.a;
	          wkt.rf = parseFloat(geogcs.DATUM.SPHEROID.rf, 10);
	        }

	        if (geogcs.DATUM && geogcs.DATUM.TOWGS84) {
	          wkt.datum_params = geogcs.DATUM.TOWGS84;
	        }
	        if (~wkt.datumCode.indexOf('osgb_1936')) {
	          wkt.datumCode = 'osgb36';
	        }
	        if (~wkt.datumCode.indexOf('osni_1952')) {
	          wkt.datumCode = 'osni52';
	        }
	        if (~wkt.datumCode.indexOf('tm65')
	          || ~wkt.datumCode.indexOf('geodetic_datum_of_1965')) {
	          wkt.datumCode = 'ire65';
	        }
	        if (wkt.datumCode === 'ch1903+') {
	          wkt.datumCode = 'ch1903';
	        }
	        if (~wkt.datumCode.indexOf('israel')) {
	          wkt.datumCode = 'isr93';
	        }
	      }
	      if (wkt.b && !isFinite(wkt.b)) {
	        wkt.b = wkt.a;
	      }

	      function toMeter(input) {
	        var ratio = wkt.to_meter || 1;
	        return input * ratio;
	      }
	      var renamer = function(a) {
	        return rename(wkt, a);
	      };
	      var list = [
	        ['standard_parallel_1', 'Standard_Parallel_1'],
	        ['standard_parallel_2', 'Standard_Parallel_2'],
	        ['false_easting', 'False_Easting'],
	        ['false_northing', 'False_Northing'],
	        ['central_meridian', 'Central_Meridian'],
	        ['latitude_of_origin', 'Latitude_Of_Origin'],
	        ['latitude_of_origin', 'Central_Parallel'],
	        ['scale_factor', 'Scale_Factor'],
	        ['k0', 'scale_factor'],
	        ['latitude_of_center', 'Latitude_Of_Center'],
	        ['latitude_of_center', 'Latitude_of_center'],
	        ['lat0', 'latitude_of_center', d2r],
	        ['longitude_of_center', 'Longitude_Of_Center'],
	        ['longitude_of_center', 'Longitude_of_center'],
	        ['longc', 'longitude_of_center', d2r],
	        ['x0', 'false_easting', toMeter],
	        ['y0', 'false_northing', toMeter],
	        ['long0', 'central_meridian', d2r],
	        ['lat0', 'latitude_of_origin', d2r],
	        ['lat0', 'standard_parallel_1', d2r],
	        ['lat1', 'standard_parallel_1', d2r],
	        ['lat2', 'standard_parallel_2', d2r],
	        ['azimuth', 'Azimuth'],
	        ['alpha', 'azimuth', d2r],
	        ['srsCode', 'name']
	      ];
	      list.forEach(renamer);
	      if (!wkt.long0 && wkt.longc && (wkt.projName === 'Albers_Conic_Equal_Area' || wkt.projName === 'Lambert_Azimuthal_Equal_Area')) {
	        wkt.long0 = wkt.longc;
	      }
	      if (!wkt.lat_ts && wkt.lat1 && (wkt.projName === 'Stereographic_South_Pole' || wkt.projName === 'Polar Stereographic (variant B)')) {
	        wkt.lat0 = d2r(wkt.lat1 > 0 ? 90 : -90);
	        wkt.lat_ts = wkt.lat1;
	      }
	    }
	    var wkt = function(wkt) {
	      var lisp = parseString(wkt);
	      var type = lisp.shift();
	      var name = lisp.shift();
	      lisp.unshift(['name', name]);
	      lisp.unshift(['type', type]);
	      var obj = {};
	      sExpr(lisp, obj);
	      cleanWKT(obj);
	      return obj;
	    };

	    function defs(name) {
	      /*global console*/
	      var that = this;
	      if (arguments.length === 2) {
	        var def = arguments[1];
	        if (typeof def === 'string') {
	          if (def.charAt(0) === '+') {
	            defs[name] = parseProj(arguments[1]);
	          }
	          else {
	            defs[name] = wkt(arguments[1]);
	          }
	        } else {
	          defs[name] = def;
	        }
	      }
	      else if (arguments.length === 1) {
	        if (Array.isArray(name)) {
	          return name.map(function(v) {
	            if (Array.isArray(v)) {
	              defs.apply(that, v);
	            }
	            else {
	              defs(v);
	            }
	          });
	        }
	        else if (typeof name === 'string') {
	          if (name in defs) {
	            return defs[name];
	          }
	        }
	        else if ('EPSG' in name) {
	          defs['EPSG:' + name.EPSG] = name;
	        }
	        else if ('ESRI' in name) {
	          defs['ESRI:' + name.ESRI] = name;
	        }
	        else if ('IAU2000' in name) {
	          defs['IAU2000:' + name.IAU2000] = name;
	        }
	        else {
	          console.log(name);
	        }
	        return;
	      }


	    }
	    globals(defs);

	    function testObj(code){
	      return typeof code === 'string';
	    }
	    function testDef(code){
	      return code in defs;
	    }
	     var codeWords = ['PROJECTEDCRS', 'PROJCRS', 'GEOGCS','GEOCCS','PROJCS','LOCAL_CS', 'GEODCRS', 'GEODETICCRS', 'GEODETICDATUM', 'ENGCRS', 'ENGINEERINGCRS'];
	    function testWKT(code){
	      return codeWords.some(function (word) {
	        return code.indexOf(word) > -1;
	      });
	    }
	    var codes = ['3857', '900913', '3785', '102113'];
	    function checkMercator(item) {
	      var auth = match(item, 'authority');
	      if (!auth) {
	        return;
	      }
	      var code = match(auth, 'epsg');
	      return code && codes.indexOf(code) > -1;
	    }
	    function checkProjStr(item) {
	      var ext = match(item, 'extension');
	      if (!ext) {
	        return;
	      }
	      return match(ext, 'proj4');
	    }
	    function testProj(code){
	      return code[0] === '+';
	    }
	    function parse(code){
	      if (testObj(code)) {
	        //check to see if this is a WKT string
	        if (testDef(code)) {
	          return defs[code];
	        }
	        if (testWKT(code)) {
	          var out = wkt(code);
	          // test of spetial case, due to this being a very common and often malformed
	          if (checkMercator(out)) {
	            return defs['EPSG:3857'];
	          }
	          var maybeProjStr = checkProjStr(out);
	          if (maybeProjStr) {
	            return parseProj(maybeProjStr);
	          }
	          return out;
	        }
	        if (testProj(code)) {
	          return parseProj(code);
	        }
	      }else{
	        return code;
	      }
	    }

	    var extend = function(destination, source) {
	      destination = destination || {};
	      var value, property;
	      if (!source) {
	        return destination;
	      }
	      for (property in source) {
	        value = source[property];
	        if (value !== undefined) {
	          destination[property] = value;
	        }
	      }
	      return destination;
	    };

	    var msfnz = function(eccent, sinphi, cosphi) {
	      var con = eccent * sinphi;
	      return cosphi / (Math.sqrt(1 - con * con));
	    };

	    var sign = function(x) {
	      return x<0 ? -1 : 1;
	    };

	    var adjust_lon = function(x) {
	      return (Math.abs(x) <= SPI) ? x : (x - (sign(x) * TWO_PI));
	    };

	    var tsfnz = function(eccent, phi, sinphi) {
	      var con = eccent * sinphi;
	      var com = 0.5 * eccent;
	      con = Math.pow(((1 - con) / (1 + con)), com);
	      return (Math.tan(0.5 * (HALF_PI - phi)) / con);
	    };

	    var phi2z = function(eccent, ts) {
	      var eccnth = 0.5 * eccent;
	      var con, dphi;
	      var phi = HALF_PI - 2 * Math.atan(ts);
	      for (var i = 0; i <= 15; i++) {
	        con = eccent * Math.sin(phi);
	        dphi = HALF_PI - 2 * Math.atan(ts * (Math.pow(((1 - con) / (1 + con)), eccnth))) - phi;
	        phi += dphi;
	        if (Math.abs(dphi) <= 0.0000000001) {
	          return phi;
	        }
	      }
	      //console.log("phi2z has NoConvergence");
	      return -9999;
	    };

	    function init() {
	      var con = this.b / this.a;
	      this.es = 1 - con * con;
	      if(!('x0' in this)){
	        this.x0 = 0;
	      }
	      if(!('y0' in this)){
	        this.y0 = 0;
	      }
	      this.e = Math.sqrt(this.es);
	      if (this.lat_ts) {
	        if (this.sphere) {
	          this.k0 = Math.cos(this.lat_ts);
	        }
	        else {
	          this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
	        }
	      }
	      else {
	        if (!this.k0) {
	          if (this.k) {
	            this.k0 = this.k;
	          }
	          else {
	            this.k0 = 1;
	          }
	        }
	      }
	    }

	    /* Mercator forward equations--mapping lat,long to x,y
	      --------------------------------------------------*/

	    function forward(p) {
	      var lon = p.x;
	      var lat = p.y;
	      // convert to radians
	      if (lat * R2D > 90 && lat * R2D < -90 && lon * R2D > 180 && lon * R2D < -180) {
	        return null;
	      }

	      var x, y;
	      if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
	        return null;
	      }
	      else {
	        if (this.sphere) {
	          x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
	          y = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * lat));
	        }
	        else {
	          var sinphi = Math.sin(lat);
	          var ts = tsfnz(this.e, lat, sinphi);
	          x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
	          y = this.y0 - this.a * this.k0 * Math.log(ts);
	        }
	        p.x = x;
	        p.y = y;
	        return p;
	      }
	    }

	    /* Mercator inverse equations--mapping x,y to lat/long
	      --------------------------------------------------*/
	    function inverse(p) {

	      var x = p.x - this.x0;
	      var y = p.y - this.y0;
	      var lon, lat;

	      if (this.sphere) {
	        lat = HALF_PI - 2 * Math.atan(Math.exp(-y / (this.a * this.k0)));
	      }
	      else {
	        var ts = Math.exp(-y / (this.a * this.k0));
	        lat = phi2z(this.e, ts);
	        if (lat === -9999) {
	          return null;
	        }
	      }
	      lon = adjust_lon(this.long0 + x / (this.a * this.k0));

	      p.x = lon;
	      p.y = lat;
	      return p;
	    }

	    var names$1 = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"];
	    var merc = {
	      init: init,
	      forward: forward,
	      inverse: inverse,
	      names: names$1
	    };

	    function init$1() {
	      //no-op for longlat
	    }

	    function identity(pt) {
	      return pt;
	    }
	    var names$2 = ["longlat", "identity"];
	    var longlat = {
	      init: init$1,
	      forward: identity,
	      inverse: identity,
	      names: names$2
	    };

	    var projs = [merc, longlat];
	    var names = {};
	    var projStore = [];

	    function add(proj, i) {
	      var len = projStore.length;
	      if (!proj.names) {
	        console.log(i);
	        return true;
	      }
	      projStore[len] = proj;
	      proj.names.forEach(function(n) {
	        names[n.toLowerCase()] = len;
	      });
	      return this;
	    }

	    function get(name) {
	      if (!name) {
	        return false;
	      }
	      var n = name.toLowerCase();
	      if (typeof names[n] !== 'undefined' && projStore[names[n]]) {
	        return projStore[names[n]];
	      }
	    }

	    function start() {
	      projs.forEach(add);
	    }
	    var projections = {
	      start: start,
	      add: add,
	      get: get
	    };

	    var exports$2 = {};
	    exports$2.MERIT = {
	      a: 6378137.0,
	      rf: 298.257,
	      ellipseName: "MERIT 1983"
	    };

	    exports$2.SGS85 = {
	      a: 6378136.0,
	      rf: 298.257,
	      ellipseName: "Soviet Geodetic System 85"
	    };

	    exports$2.GRS80 = {
	      a: 6378137.0,
	      rf: 298.257222101,
	      ellipseName: "GRS 1980(IUGG, 1980)"
	    };

	    exports$2.IAU76 = {
	      a: 6378140.0,
	      rf: 298.257,
	      ellipseName: "IAU 1976"
	    };

	    exports$2.airy = {
	      a: 6377563.396,
	      b: 6356256.910,
	      ellipseName: "Airy 1830"
	    };

	    exports$2.APL4 = {
	      a: 6378137,
	      rf: 298.25,
	      ellipseName: "Appl. Physics. 1965"
	    };

	    exports$2.NWL9D = {
	      a: 6378145.0,
	      rf: 298.25,
	      ellipseName: "Naval Weapons Lab., 1965"
	    };

	    exports$2.mod_airy = {
	      a: 6377340.189,
	      b: 6356034.446,
	      ellipseName: "Modified Airy"
	    };

	    exports$2.andrae = {
	      a: 6377104.43,
	      rf: 300.0,
	      ellipseName: "Andrae 1876 (Den., Iclnd.)"
	    };

	    exports$2.aust_SA = {
	      a: 6378160.0,
	      rf: 298.25,
	      ellipseName: "Australian Natl & S. Amer. 1969"
	    };

	    exports$2.GRS67 = {
	      a: 6378160.0,
	      rf: 298.2471674270,
	      ellipseName: "GRS 67(IUGG 1967)"
	    };

	    exports$2.bessel = {
	      a: 6377397.155,
	      rf: 299.1528128,
	      ellipseName: "Bessel 1841"
	    };

	    exports$2.bess_nam = {
	      a: 6377483.865,
	      rf: 299.1528128,
	      ellipseName: "Bessel 1841 (Namibia)"
	    };

	    exports$2.clrk66 = {
	      a: 6378206.4,
	      b: 6356583.8,
	      ellipseName: "Clarke 1866"
	    };

	    exports$2.clrk80 = {
	      a: 6378249.145,
	      rf: 293.4663,
	      ellipseName: "Clarke 1880 mod."
	    };

	    exports$2.clrk58 = {
	      a: 6378293.645208759,
	      rf: 294.2606763692654,
	      ellipseName: "Clarke 1858"
	    };

	    exports$2.CPM = {
	      a: 6375738.7,
	      rf: 334.29,
	      ellipseName: "Comm. des Poids et Mesures 1799"
	    };

	    exports$2.delmbr = {
	      a: 6376428.0,
	      rf: 311.5,
	      ellipseName: "Delambre 1810 (Belgium)"
	    };

	    exports$2.engelis = {
	      a: 6378136.05,
	      rf: 298.2566,
	      ellipseName: "Engelis 1985"
	    };

	    exports$2.evrst30 = {
	      a: 6377276.345,
	      rf: 300.8017,
	      ellipseName: "Everest 1830"
	    };

	    exports$2.evrst48 = {
	      a: 6377304.063,
	      rf: 300.8017,
	      ellipseName: "Everest 1948"
	    };

	    exports$2.evrst56 = {
	      a: 6377301.243,
	      rf: 300.8017,
	      ellipseName: "Everest 1956"
	    };

	    exports$2.evrst69 = {
	      a: 6377295.664,
	      rf: 300.8017,
	      ellipseName: "Everest 1969"
	    };

	    exports$2.evrstSS = {
	      a: 6377298.556,
	      rf: 300.8017,
	      ellipseName: "Everest (Sabah & Sarawak)"
	    };

	    exports$2.fschr60 = {
	      a: 6378166.0,
	      rf: 298.3,
	      ellipseName: "Fischer (Mercury Datum) 1960"
	    };

	    exports$2.fschr60m = {
	      a: 6378155.0,
	      rf: 298.3,
	      ellipseName: "Fischer 1960"
	    };

	    exports$2.fschr68 = {
	      a: 6378150.0,
	      rf: 298.3,
	      ellipseName: "Fischer 1968"
	    };

	    exports$2.helmert = {
	      a: 6378200.0,
	      rf: 298.3,
	      ellipseName: "Helmert 1906"
	    };

	    exports$2.hough = {
	      a: 6378270.0,
	      rf: 297.0,
	      ellipseName: "Hough"
	    };

	    exports$2.intl = {
	      a: 6378388.0,
	      rf: 297.0,
	      ellipseName: "International 1909 (Hayford)"
	    };

	    exports$2.kaula = {
	      a: 6378163.0,
	      rf: 298.24,
	      ellipseName: "Kaula 1961"
	    };

	    exports$2.lerch = {
	      a: 6378139.0,
	      rf: 298.257,
	      ellipseName: "Lerch 1979"
	    };

	    exports$2.mprts = {
	      a: 6397300.0,
	      rf: 191.0,
	      ellipseName: "Maupertius 1738"
	    };

	    exports$2.new_intl = {
	      a: 6378157.5,
	      b: 6356772.2,
	      ellipseName: "New International 1967"
	    };

	    exports$2.plessis = {
	      a: 6376523.0,
	      rf: 6355863.0,
	      ellipseName: "Plessis 1817 (France)"
	    };

	    exports$2.krass = {
	      a: 6378245.0,
	      rf: 298.3,
	      ellipseName: "Krassovsky, 1942"
	    };

	    exports$2.SEasia = {
	      a: 6378155.0,
	      b: 6356773.3205,
	      ellipseName: "Southeast Asia"
	    };

	    exports$2.walbeck = {
	      a: 6376896.0,
	      b: 6355834.8467,
	      ellipseName: "Walbeck"
	    };

	    exports$2.WGS60 = {
	      a: 6378165.0,
	      rf: 298.3,
	      ellipseName: "WGS 60"
	    };

	    exports$2.WGS66 = {
	      a: 6378145.0,
	      rf: 298.25,
	      ellipseName: "WGS 66"
	    };

	    exports$2.WGS7 = {
	      a: 6378135.0,
	      rf: 298.26,
	      ellipseName: "WGS 72"
	    };

	    var WGS84 = exports$2.WGS84 = {
	      a: 6378137.0,
	      rf: 298.257223563,
	      ellipseName: "WGS 84"
	    };

	    exports$2.sphere = {
	      a: 6370997.0,
	      b: 6370997.0,
	      ellipseName: "Normal Sphere (r=6370997)"
	    };

	    function eccentricity(a, b, rf, R_A) {
	      var a2 = a * a; // used in geocentric
	      var b2 = b * b; // used in geocentric
	      var es = (a2 - b2) / a2; // e ^ 2
	      var e = 0;
	      if (R_A) {
	        a *= 1 - es * (SIXTH + es * (RA4 + es * RA6));
	        a2 = a * a;
	        es = 0;
	      } else {
	        e = Math.sqrt(es); // eccentricity
	      }
	      var ep2 = (a2 - b2) / b2; // used in geocentric
	      return {
	        es: es,
	        e: e,
	        ep2: ep2
	      };
	    }
	    function sphere(a, b, rf, ellps, sphere) {
	      if (!a) { // do we have an ellipsoid?
	        var ellipse = match(exports$2, ellps);
	        if (!ellipse) {
	          ellipse = WGS84;
	        }
	        a = ellipse.a;
	        b = ellipse.b;
	        rf = ellipse.rf;
	      }

	      if (rf && !b) {
	        b = (1.0 - 1.0 / rf) * a;
	      }
	      if (rf === 0 || Math.abs(a - b) < EPSLN) {
	        sphere = true;
	        b = a;
	      }
	      return {
	        a: a,
	        b: b,
	        rf: rf,
	        sphere: sphere
	      };
	    }

	    var exports$3 = {};
	    exports$3.wgs84 = {
	      towgs84: "0,0,0",
	      ellipse: "WGS84",
	      datumName: "WGS84"
	    };

	    exports$3.ch1903 = {
	      towgs84: "674.374,15.056,405.346",
	      ellipse: "bessel",
	      datumName: "swiss"
	    };

	    exports$3.ggrs87 = {
	      towgs84: "-199.87,74.79,246.62",
	      ellipse: "GRS80",
	      datumName: "Greek_Geodetic_Reference_System_1987"
	    };

	    exports$3.nad83 = {
	      towgs84: "0,0,0",
	      ellipse: "GRS80",
	      datumName: "North_American_Datum_1983"
	    };

	    exports$3.nad27 = {
	      nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
	      ellipse: "clrk66",
	      datumName: "North_American_Datum_1927"
	    };

	    exports$3.potsdam = {
	      towgs84: "606.0,23.0,413.0",
	      ellipse: "bessel",
	      datumName: "Potsdam Rauenberg 1950 DHDN"
	    };

	    exports$3.carthage = {
	      towgs84: "-263.0,6.0,431.0",
	      ellipse: "clark80",
	      datumName: "Carthage 1934 Tunisia"
	    };

	    exports$3.hermannskogel = {
	      towgs84: "653.0,-212.0,449.0",
	      ellipse: "bessel",
	      datumName: "Hermannskogel"
	    };

	    exports$3.osni52 = {
	      towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
	      ellipse: "airy",
	      datumName: "Irish National"
	    };

	    exports$3.ire65 = {
	      towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
	      ellipse: "mod_airy",
	      datumName: "Ireland 1965"
	    };

	    exports$3.rassadiran = {
	      towgs84: "-133.63,-157.5,-158.62",
	      ellipse: "intl",
	      datumName: "Rassadiran"
	    };

	    exports$3.nzgd49 = {
	      towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
	      ellipse: "intl",
	      datumName: "New Zealand Geodetic Datum 1949"
	    };

	    exports$3.osgb36 = {
	      towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
	      ellipse: "airy",
	      datumName: "Airy 1830"
	    };

	    exports$3.s_jtsk = {
	      towgs84: "589,76,480",
	      ellipse: 'bessel',
	      datumName: 'S-JTSK (Ferro)'
	    };

	    exports$3.beduaram = {
	      towgs84: '-106,-87,188',
	      ellipse: 'clrk80',
	      datumName: 'Beduaram'
	    };

	    exports$3.gunung_segara = {
	      towgs84: '-403,684,41',
	      ellipse: 'bessel',
	      datumName: 'Gunung Segara Jakarta'
	    };

	    exports$3.rnb72 = {
	      towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
	      ellipse: "intl",
	      datumName: "Reseau National Belge 1972"
	    };

	    function datum(datumCode, datum_params, a, b, es, ep2) {
	      var out = {};

	      if (datumCode === undefined || datumCode === 'none') {
	        out.datum_type = PJD_NODATUM;
	      } else {
	        out.datum_type = PJD_WGS84;
	      }

	      if (datum_params) {
	        out.datum_params = datum_params.map(parseFloat);
	        if (out.datum_params[0] !== 0 || out.datum_params[1] !== 0 || out.datum_params[2] !== 0) {
	          out.datum_type = PJD_3PARAM;
	        }
	        if (out.datum_params.length > 3) {
	          if (out.datum_params[3] !== 0 || out.datum_params[4] !== 0 || out.datum_params[5] !== 0 || out.datum_params[6] !== 0) {
	            out.datum_type = PJD_7PARAM;
	            out.datum_params[3] *= SEC_TO_RAD;
	            out.datum_params[4] *= SEC_TO_RAD;
	            out.datum_params[5] *= SEC_TO_RAD;
	            out.datum_params[6] = (out.datum_params[6] / 1000000.0) + 1.0;
	          }
	        }
	      }

	      out.a = a; //datum object also uses these values
	      out.b = b;
	      out.es = es;
	      out.ep2 = ep2;
	      return out;
	    }

	    function Projection(srsCode,callback) {
	      if (!(this instanceof Projection)) {
	        return new Projection(srsCode);
	      }
	      callback = callback || function(error){
	        if(error){
	          throw error;
	        }
	      };
	      var json = parse(srsCode);
	      if(typeof json !== 'object'){
	        callback(srsCode);
	        return;
	      }
	      var ourProj = Projection.projections.get(json.projName);
	      if(!ourProj){
	        callback(srsCode);
	        return;
	      }
	      if (json.datumCode && json.datumCode !== 'none') {
	        var datumDef = match(exports$3, json.datumCode);
	        if (datumDef) {
	          json.datum_params = datumDef.towgs84 ? datumDef.towgs84.split(',') : null;
	          json.ellps = datumDef.ellipse;
	          json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;
	        }
	      }
	      json.k0 = json.k0 || 1.0;
	      json.axis = json.axis || 'enu';
	      json.ellps = json.ellps || 'wgs84';
	      var sphere_ = sphere(json.a, json.b, json.rf, json.ellps, json.sphere);
	      var ecc = eccentricity(sphere_.a, sphere_.b, sphere_.rf, json.R_A);
	      var datumObj = json.datum || datum(json.datumCode, json.datum_params, sphere_.a, sphere_.b, ecc.es, ecc.ep2);

	      extend(this, json); // transfer everything over from the projection because we don't know what we'll need
	      extend(this, ourProj); // transfer all the methods from the projection

	      // copy the 4 things over we calulated in deriveConstants.sphere
	      this.a = sphere_.a;
	      this.b = sphere_.b;
	      this.rf = sphere_.rf;
	      this.sphere = sphere_.sphere;

	      // copy the 3 things we calculated in deriveConstants.eccentricity
	      this.es = ecc.es;
	      this.e = ecc.e;
	      this.ep2 = ecc.ep2;

	      // add in the datum object
	      this.datum = datumObj;

	      // init the projection
	      this.init();

	      // legecy callback from back in the day when it went to spatialreference.org
	      callback(null, this);

	    }
	    Projection.projections = projections;
	    Projection.projections.start();
	    function compareDatums(source, dest) {
	      if (source.datum_type !== dest.datum_type) {
	        return false; // false, datums are not equal
	      } else if (source.a !== dest.a || Math.abs(source.es - dest.es) > 0.000000000050) {
	        // the tolerance for es is to ensure that GRS80 and WGS84
	        // are considered identical
	        return false;
	      } else if (source.datum_type === PJD_3PARAM) {
	        return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2]);
	      } else if (source.datum_type === PJD_7PARAM) {
	        return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] && source.datum_params[3] === dest.datum_params[3] && source.datum_params[4] === dest.datum_params[4] && source.datum_params[5] === dest.datum_params[5] && source.datum_params[6] === dest.datum_params[6]);
	      } else {
	        return true; // datums are equal
	      }
	    } // cs_compare_datums()

	    /*
	     * The function Convert_Geodetic_To_Geocentric converts geodetic coordinates
	     * (latitude, longitude, and height) to geocentric coordinates (X, Y, Z),
	     * according to the current ellipsoid parameters.
	     *
	     *    Latitude  : Geodetic latitude in radians                     (input)
	     *    Longitude : Geodetic longitude in radians                    (input)
	     *    Height    : Geodetic height, in meters                       (input)
	     *    X         : Calculated Geocentric X coordinate, in meters    (output)
	     *    Y         : Calculated Geocentric Y coordinate, in meters    (output)
	     *    Z         : Calculated Geocentric Z coordinate, in meters    (output)
	     *
	     */
	    function geodeticToGeocentric(p, es, a) {
	      var Longitude = p.x;
	      var Latitude = p.y;
	      var Height = p.z ? p.z : 0; //Z value not always supplied

	      var Rn; /*  Earth radius at location  */
	      var Sin_Lat; /*  Math.sin(Latitude)  */
	      var Sin2_Lat; /*  Square of Math.sin(Latitude)  */
	      var Cos_Lat; /*  Math.cos(Latitude)  */

	      /*
	       ** Don't blow up if Latitude is just a little out of the value
	       ** range as it may just be a rounding issue.  Also removed longitude
	       ** test, it should be wrapped by Math.cos() and Math.sin().  NFW for PROJ.4, Sep/2001.
	       */
	      if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {
	        Latitude = -HALF_PI;
	      } else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {
	        Latitude = HALF_PI;
	      } else if (Latitude < -HALF_PI) {
	        /* Latitude out of range */
	        //..reportError('geocent:lat out of range:' + Latitude);
	        return { x: -Infinity, y: -Infinity, z: p.z };
	      } else if (Latitude > HALF_PI) {
	        /* Latitude out of range */
	        return { x: Infinity, y: Infinity, z: p.z };
	      }

	      if (Longitude > Math.PI) {
	        Longitude -= (2 * Math.PI);
	      }
	      Sin_Lat = Math.sin(Latitude);
	      Cos_Lat = Math.cos(Latitude);
	      Sin2_Lat = Sin_Lat * Sin_Lat;
	      Rn = a / (Math.sqrt(1.0e0 - es * Sin2_Lat));
	      return {
	        x: (Rn + Height) * Cos_Lat * Math.cos(Longitude),
	        y: (Rn + Height) * Cos_Lat * Math.sin(Longitude),
	        z: ((Rn * (1 - es)) + Height) * Sin_Lat
	      };
	    } // cs_geodetic_to_geocentric()

	    function geocentricToGeodetic(p, es, a, b) {
	      /* local defintions and variables */
	      /* end-criterium of loop, accuracy of sin(Latitude) */
	      var genau = 1e-12;
	      var genau2 = (genau * genau);
	      var maxiter = 30;

	      var P; /* distance between semi-minor axis and location */
	      var RR; /* distance between center and location */
	      var CT; /* sin of geocentric latitude */
	      var ST; /* cos of geocentric latitude */
	      var RX;
	      var RK;
	      var RN; /* Earth radius at location */
	      var CPHI0; /* cos of start or old geodetic latitude in iterations */
	      var SPHI0; /* sin of start or old geodetic latitude in iterations */
	      var CPHI; /* cos of searched geodetic latitude */
	      var SPHI; /* sin of searched geodetic latitude */
	      var SDPHI; /* end-criterium: addition-theorem of sin(Latitude(iter)-Latitude(iter-1)) */
	      var iter; /* # of continous iteration, max. 30 is always enough (s.a.) */

	      var X = p.x;
	      var Y = p.y;
	      var Z = p.z ? p.z : 0.0; //Z value not always supplied
	      var Longitude;
	      var Latitude;
	      var Height;

	      P = Math.sqrt(X * X + Y * Y);
	      RR = Math.sqrt(X * X + Y * Y + Z * Z);

	      /*      special cases for latitude and longitude */
	      if (P / a < genau) {

	        /*  special case, if P=0. (X=0., Y=0.) */
	        Longitude = 0.0;

	        /*  if (X,Y,Z)=(0.,0.,0.) then Height becomes semi-minor axis
	         *  of ellipsoid (=center of mass), Latitude becomes PI/2 */
	        if (RR / a < genau) {
	          Latitude = HALF_PI;
	          Height = -b;
	          return {
	            x: p.x,
	            y: p.y,
	            z: p.z
	          };
	        }
	      } else {
	        /*  ellipsoidal (geodetic) longitude
	         *  interval: -PI < Longitude <= +PI */
	        Longitude = Math.atan2(Y, X);
	      }

	      /* --------------------------------------------------------------
	       * Following iterative algorithm was developped by
	       * "Institut for Erdmessung", University of Hannover, July 1988.
	       * Internet: www.ife.uni-hannover.de
	       * Iterative computation of CPHI,SPHI and Height.
	       * Iteration of CPHI and SPHI to 10**-12 radian resp.
	       * 2*10**-7 arcsec.
	       * --------------------------------------------------------------
	       */
	      CT = Z / RR;
	      ST = P / RR;
	      RX = 1.0 / Math.sqrt(1.0 - es * (2.0 - es) * ST * ST);
	      CPHI0 = ST * (1.0 - es) * RX;
	      SPHI0 = CT * RX;
	      iter = 0;

	      /* loop to find sin(Latitude) resp. Latitude
	       * until |sin(Latitude(iter)-Latitude(iter-1))| < genau */
	      do {
	        iter++;
	        RN = a / Math.sqrt(1.0 - es * SPHI0 * SPHI0);

	        /*  ellipsoidal (geodetic) height */
	        Height = P * CPHI0 + Z * SPHI0 - RN * (1.0 - es * SPHI0 * SPHI0);

	        RK = es * RN / (RN + Height);
	        RX = 1.0 / Math.sqrt(1.0 - RK * (2.0 - RK) * ST * ST);
	        CPHI = ST * (1.0 - RK) * RX;
	        SPHI = CT * RX;
	        SDPHI = SPHI * CPHI0 - CPHI * SPHI0;
	        CPHI0 = CPHI;
	        SPHI0 = SPHI;
	      }
	      while (SDPHI * SDPHI > genau2 && iter < maxiter);

	      /*      ellipsoidal (geodetic) latitude */
	      Latitude = Math.atan(SPHI / Math.abs(CPHI));
	      return {
	        x: Longitude,
	        y: Latitude,
	        z: Height
	      };
	    } // cs_geocentric_to_geodetic()

	    /****************************************************************/
	    // pj_geocentic_to_wgs84( p )
	    //  p = point to transform in geocentric coordinates (x,y,z)


	    /** point object, nothing fancy, just allows values to be
	        passed back and forth by reference rather than by value.
	        Other point classes may be used as long as they have
	        x and y properties, which will get modified in the transform method.
	    */
	    function geocentricToWgs84(p, datum_type, datum_params) {

	      if (datum_type === PJD_3PARAM) {
	        // if( x[io] === HUGE_VAL )
	        //    continue;
	        return {
	          x: p.x + datum_params[0],
	          y: p.y + datum_params[1],
	          z: p.z + datum_params[2],
	        };
	      } else if (datum_type === PJD_7PARAM) {
	        var Dx_BF = datum_params[0];
	        var Dy_BF = datum_params[1];
	        var Dz_BF = datum_params[2];
	        var Rx_BF = datum_params[3];
	        var Ry_BF = datum_params[4];
	        var Rz_BF = datum_params[5];
	        var M_BF = datum_params[6];
	        // if( x[io] === HUGE_VAL )
	        //    continue;
	        return {
	          x: M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF,
	          y: M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF,
	          z: M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF
	        };
	      }
	    } // cs_geocentric_to_wgs84

	    /****************************************************************/
	    // pj_geocentic_from_wgs84()
	    //  coordinate system definition,
	    //  point to transform in geocentric coordinates (x,y,z)
	    function geocentricFromWgs84(p, datum_type, datum_params) {

	      if (datum_type === PJD_3PARAM) {
	        //if( x[io] === HUGE_VAL )
	        //    continue;
	        return {
	          x: p.x - datum_params[0],
	          y: p.y - datum_params[1],
	          z: p.z - datum_params[2],
	        };

	      } else if (datum_type === PJD_7PARAM) {
	        var Dx_BF = datum_params[0];
	        var Dy_BF = datum_params[1];
	        var Dz_BF = datum_params[2];
	        var Rx_BF = datum_params[3];
	        var Ry_BF = datum_params[4];
	        var Rz_BF = datum_params[5];
	        var M_BF = datum_params[6];
	        var x_tmp = (p.x - Dx_BF) / M_BF;
	        var y_tmp = (p.y - Dy_BF) / M_BF;
	        var z_tmp = (p.z - Dz_BF) / M_BF;
	        //if( x[io] === HUGE_VAL )
	        //    continue;

	        return {
	          x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,
	          y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,
	          z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp
	        };
	      } //cs_geocentric_from_wgs84()
	    }

	    function checkParams(type) {
	      return (type === PJD_3PARAM || type === PJD_7PARAM);
	    }

	    var datum_transform = function(source, dest, point) {
	      // Short cut if the datums are identical.
	      if (compareDatums(source, dest)) {
	        return point; // in this case, zero is sucess,
	        // whereas cs_compare_datums returns 1 to indicate TRUE
	        // confusing, should fix this
	      }

	      // Explicitly skip datum transform by setting 'datum=none' as parameter for either source or dest
	      if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {
	        return point;
	      }

	      // If this datum requires grid shifts, then apply it to geodetic coordinates.

	      // Do we need to go through geocentric coordinates?
	      if (source.es === dest.es && source.a === dest.a && !checkParams(source.datum_type) &&  !checkParams(dest.datum_type)) {
	        return point;
	      }

	      // Convert to geocentric coordinates.
	      point = geodeticToGeocentric(point, source.es, source.a);
	      // Convert between datums
	      if (checkParams(source.datum_type)) {
	        point = geocentricToWgs84(point, source.datum_type, source.datum_params);
	      }
	      if (checkParams(dest.datum_type)) {
	        point = geocentricFromWgs84(point, dest.datum_type, dest.datum_params);
	      }
	      return geocentricToGeodetic(point, dest.es, dest.a, dest.b);

	    };

	    var adjust_axis = function(crs, denorm, point) {
	      var xin = point.x,
	        yin = point.y,
	        zin = point.z || 0.0;
	      var v, t, i;
	      var out = {};
	      for (i = 0; i < 3; i++) {
	        if (denorm && i === 2 && point.z === undefined) {
	          continue;
	        }
	        if (i === 0) {
	          v = xin;
	          t = 'x';
	        }
	        else if (i === 1) {
	          v = yin;
	          t = 'y';
	        }
	        else {
	          v = zin;
	          t = 'z';
	        }
	        switch (crs.axis[i]) {
	        case 'e':
	          out[t] = v;
	          break;
	        case 'w':
	          out[t] = -v;
	          break;
	        case 'n':
	          out[t] = v;
	          break;
	        case 's':
	          out[t] = -v;
	          break;
	        case 'u':
	          if (point[t] !== undefined) {
	            out.z = v;
	          }
	          break;
	        case 'd':
	          if (point[t] !== undefined) {
	            out.z = -v;
	          }
	          break;
	        default:
	          //console.log("ERROR: unknow axis ("+crs.axis[i]+") - check definition of "+crs.projName);
	          return null;
	        }
	      }
	      return out;
	    };

	    var toPoint = function (array){
	      var out = {
	        x: array[0],
	        y: array[1]
	      };
	      if (array.length>2) {
	        out.z = array[2];
	      }
	      if (array.length>3) {
	        out.m = array[3];
	      }
	      return out;
	    };

	    var checkSanity = function (point) {
	      checkCoord(point.x);
	      checkCoord(point.y);
	    };
	    function checkCoord(num) {
	      if (typeof Number.isFinite === 'function') {
	        if (Number.isFinite(num)) {
	          return;
	        }
	        throw new TypeError('coordinates must be finite numbers');
	      }
	      if (typeof num !== 'number' || num !== num || !isFinite(num)) {
	        throw new TypeError('coordinates must be finite numbers');
	      }
	    }

	    function checkNotWGS(source, dest) {
	      return ((source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM) && dest.datumCode !== 'WGS84') || ((dest.datum.datum_type === PJD_3PARAM || dest.datum.datum_type === PJD_7PARAM) && source.datumCode !== 'WGS84');
	    }

	    function transform(source, dest, point) {
	      var wgs84;
	      if (Array.isArray(point)) {
	        point = toPoint(point);
	      }
	      checkSanity(point);
	      // Workaround for datum shifts towgs84, if either source or destination projection is not wgs84
	      if (source.datum && dest.datum && checkNotWGS(source, dest)) {
	        wgs84 = new Projection('WGS84');
	        point = transform(source, wgs84, point);
	        source = wgs84;
	      }
	      // DGR, 2010/11/12
	      if (source.axis !== 'enu') {
	        point = adjust_axis(source, false, point);
	      }
	      // Transform source points to long/lat, if they aren't already.
	      if (source.projName === 'longlat') {
	        point = {
	          x: point.x * D2R,
	          y: point.y * D2R,
	          z: point.z || 0
	        };
	      } else {
	        if (source.to_meter) {
	          point = {
	            x: point.x * source.to_meter,
	            y: point.y * source.to_meter,
	            z: point.z || 0
	          };
	        }
	        point = source.inverse(point); // Convert Cartesian to longlat
	      }
	      // Adjust for the prime meridian if necessary
	      if (source.from_greenwich) {
	        point.x += source.from_greenwich;
	      }

	      // Convert datums if needed, and if possible.
	      point = datum_transform(source.datum, dest.datum, point);

	      // Adjust for the prime meridian if necessary
	      if (dest.from_greenwich) {
	        point = {
	          x: point.x - dest.from_greenwich,
	          y: point.y,
	          z: point.z || 0
	        };
	      }

	      if (dest.projName === 'longlat') {
	        // convert radians to decimal degrees
	        point = {
	          x: point.x * R2D,
	          y: point.y * R2D,
	          z: point.z || 0
	        };
	      } else { // else project
	        point = dest.forward(point);
	        if (dest.to_meter) {
	          point = {
	            x: point.x / dest.to_meter,
	            y: point.y / dest.to_meter,
	            z: point.z || 0
	          };
	        }
	      }

	      // DGR, 2010/11/12
	      if (dest.axis !== 'enu') {
	        return adjust_axis(dest, true, point);
	      }

	      return point;
	    }

	    var wgs84 = Projection('WGS84');

	    function transformer(from, to, coords) {
	      var transformedArray, out, keys;
	      if (Array.isArray(coords)) {
	        transformedArray = transform(from, to, coords) || {x: NaN, y: NaN};
	        if (coords.length > 2) {
	          if ((typeof from.name !== 'undefined' && from.name === 'geocent') || (typeof to.name !== 'undefined' && to.name === 'geocent')) {
	            if (typeof transformedArray.z === 'number') {
	              return [transformedArray.x, transformedArray.y, transformedArray.z].concat(coords.splice(3));
	            } else {
	              return [transformedArray.x, transformedArray.y, coords[2]].concat(coords.splice(3));
	            }
	          } else {
	            return [transformedArray.x, transformedArray.y].concat(coords.splice(2));
	          }
	        } else {
	          return [transformedArray.x, transformedArray.y];
	        }
	      } else {
	        out = transform(from, to, coords);
	        keys = Object.keys(coords);
	        if (keys.length === 2) {
	          return out;
	        }
	        keys.forEach(function (key) {
	          if ((typeof from.name !== 'undefined' && from.name === 'geocent') || (typeof to.name !== 'undefined' && to.name === 'geocent')) {
	            if (key === 'x' || key === 'y' || key === 'z') {
	              return;
	            }
	          } else {
	            if (key === 'x' || key === 'y') {
	              return;
	            }
	          }
	          out[key] = coords[key];
	        });
	        return out;
	      }
	    }

	    function checkProj(item) {
	      if (item instanceof Projection) {
	        return item;
	      }
	      if (item.oProj) {
	        return item.oProj;
	      }
	      return Projection(item);
	    }

	    function proj4$1(fromProj, toProj, coord) {
	      fromProj = checkProj(fromProj);
	      var single = false;
	      var obj;
	      if (typeof toProj === 'undefined') {
	        toProj = fromProj;
	        fromProj = wgs84;
	        single = true;
	      } else if (typeof toProj.x !== 'undefined' || Array.isArray(toProj)) {
	        coord = toProj;
	        toProj = fromProj;
	        fromProj = wgs84;
	        single = true;
	      }
	      toProj = checkProj(toProj);
	      if (coord) {
	        return transformer(fromProj, toProj, coord);
	      } else {
	        obj = {
	          forward: function (coords) {
	            return transformer(fromProj, toProj, coords);
	          },
	          inverse: function (coords) {
	            return transformer(toProj, fromProj, coords);
	          }
	        };
	        if (single) {
	          obj.oProj = toProj;
	        }
	        return obj;
	      }
	    }

	    /**
	     * UTM zones are grouped, and assigned to one of a group of 6
	     * sets.
	     *
	     * {int} @private
	     */
	    var NUM_100K_SETS = 6;

	    /**
	     * The column letters (for easting) of the lower left value, per
	     * set.
	     *
	     * {string} @private
	     */
	    var SET_ORIGIN_COLUMN_LETTERS = 'AJSAJS';

	    /**
	     * The row letters (for northing) of the lower left value, per
	     * set.
	     *
	     * {string} @private
	     */
	    var SET_ORIGIN_ROW_LETTERS = 'AFAFAF';

	    var A = 65; // A
	    var I = 73; // I
	    var O = 79; // O
	    var V = 86; // V
	    var Z = 90; // Z
	    var mgrs = {
	      forward: forward$1,
	      inverse: inverse$1,
	      toPoint: toPoint$1
	    };
	    /**
	     * Conversion of lat/lon to MGRS.
	     *
	     * @param {object} ll Object literal with lat and lon properties on a
	     *     WGS84 ellipsoid.
	     * @param {int} accuracy Accuracy in digits (5 for 1 m, 4 for 10 m, 3 for
	     *      100 m, 2 for 1000 m or 1 for 10000 m). Optional, default is 5.
	     * @return {string} the MGRS string for the given location and accuracy.
	     */
	    function forward$1(ll, accuracy) {
	      accuracy = accuracy || 5; // default accuracy 1m
	      return encode(LLtoUTM({
	        lat: ll[1],
	        lon: ll[0]
	      }), accuracy);
	    }

	    /**
	     * Conversion of MGRS to lat/lon.
	     *
	     * @param {string} mgrs MGRS string.
	     * @return {array} An array with left (longitude), bottom (latitude), right
	     *     (longitude) and top (latitude) values in WGS84, representing the
	     *     bounding box for the provided MGRS reference.
	     */
	    function inverse$1(mgrs) {
	      var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
	      if (bbox.lat && bbox.lon) {
	        return [bbox.lon, bbox.lat, bbox.lon, bbox.lat];
	      }
	      return [bbox.left, bbox.bottom, bbox.right, bbox.top];
	    }

	    function toPoint$1(mgrs) {
	      var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
	      if (bbox.lat && bbox.lon) {
	        return [bbox.lon, bbox.lat];
	      }
	      return [(bbox.left + bbox.right) / 2, (bbox.top + bbox.bottom) / 2];
	    }
	    /**
	     * Conversion from degrees to radians.
	     *
	     * @private
	     * @param {number} deg the angle in degrees.
	     * @return {number} the angle in radians.
	     */
	    function degToRad(deg) {
	      return (deg * (Math.PI / 180.0));
	    }

	    /**
	     * Conversion from radians to degrees.
	     *
	     * @private
	     * @param {number} rad the angle in radians.
	     * @return {number} the angle in degrees.
	     */
	    function radToDeg(rad) {
	      return (180.0 * (rad / Math.PI));
	    }

	    /**
	     * Converts a set of Longitude and Latitude co-ordinates to UTM
	     * using the WGS84 ellipsoid.
	     *
	     * @private
	     * @param {object} ll Object literal with lat and lon properties
	     *     representing the WGS84 coordinate to be converted.
	     * @return {object} Object literal containing the UTM value with easting,
	     *     northing, zoneNumber and zoneLetter properties, and an optional
	     *     accuracy property in digits. Returns null if the conversion failed.
	     */
	    function LLtoUTM(ll) {
	      var Lat = ll.lat;
	      var Long = ll.lon;
	      var a = 6378137.0; //ellip.radius;
	      var eccSquared = 0.00669438; //ellip.eccsq;
	      var k0 = 0.9996;
	      var LongOrigin;
	      var eccPrimeSquared;
	      var N, T, C, A, M;
	      var LatRad = degToRad(Lat);
	      var LongRad = degToRad(Long);
	      var LongOriginRad;
	      var ZoneNumber;
	      // (int)
	      ZoneNumber = Math.floor((Long + 180) / 6) + 1;

	      //Make sure the longitude 180.00 is in Zone 60
	      if (Long === 180) {
	        ZoneNumber = 60;
	      }

	      // Special zone for Norway
	      if (Lat >= 56.0 && Lat < 64.0 && Long >= 3.0 && Long < 12.0) {
	        ZoneNumber = 32;
	      }

	      // Special zones for Svalbard
	      if (Lat >= 72.0 && Lat < 84.0) {
	        if (Long >= 0.0 && Long < 9.0) {
	          ZoneNumber = 31;
	        }
	        else if (Long >= 9.0 && Long < 21.0) {
	          ZoneNumber = 33;
	        }
	        else if (Long >= 21.0 && Long < 33.0) {
	          ZoneNumber = 35;
	        }
	        else if (Long >= 33.0 && Long < 42.0) {
	          ZoneNumber = 37;
	        }
	      }

	      LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3; //+3 puts origin
	      // in middle of
	      // zone
	      LongOriginRad = degToRad(LongOrigin);

	      eccPrimeSquared = (eccSquared) / (1 - eccSquared);

	      N = a / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));
	      T = Math.tan(LatRad) * Math.tan(LatRad);
	      C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);
	      A = Math.cos(LatRad) * (LongRad - LongOriginRad);

	      M = a * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - (35 * eccSquared * eccSquared * eccSquared / 3072) * Math.sin(6 * LatRad));

	      var UTMEasting = (k0 * N * (A + (1 - T + C) * A * A * A / 6.0 + (5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A * A * A * A * A / 120.0) + 500000.0);

	      var UTMNorthing = (k0 * (M + N * Math.tan(LatRad) * (A * A / 2 + (5 - T + 9 * C + 4 * C * C) * A * A * A * A / 24.0 + (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A * A * A * A * A * A / 720.0)));
	      if (Lat < 0.0) {
	        UTMNorthing += 10000000.0; //10000000 meter offset for
	        // southern hemisphere
	      }

	      return {
	        northing: Math.round(UTMNorthing),
	        easting: Math.round(UTMEasting),
	        zoneNumber: ZoneNumber,
	        zoneLetter: getLetterDesignator(Lat)
	      };
	    }

	    /**
	     * Converts UTM coords to lat/long, using the WGS84 ellipsoid. This is a convenience
	     * class where the Zone can be specified as a single string eg."60N" which
	     * is then broken down into the ZoneNumber and ZoneLetter.
	     *
	     * @private
	     * @param {object} utm An object literal with northing, easting, zoneNumber
	     *     and zoneLetter properties. If an optional accuracy property is
	     *     provided (in meters), a bounding box will be returned instead of
	     *     latitude and longitude.
	     * @return {object} An object literal containing either lat and lon values
	     *     (if no accuracy was provided), or top, right, bottom and left values
	     *     for the bounding box calculated according to the provided accuracy.
	     *     Returns null if the conversion failed.
	     */
	    function UTMtoLL(utm) {

	      var UTMNorthing = utm.northing;
	      var UTMEasting = utm.easting;
	      var zoneLetter = utm.zoneLetter;
	      var zoneNumber = utm.zoneNumber;
	      // check the ZoneNummber is valid
	      if (zoneNumber < 0 || zoneNumber > 60) {
	        return null;
	      }

	      var k0 = 0.9996;
	      var a = 6378137.0; //ellip.radius;
	      var eccSquared = 0.00669438; //ellip.eccsq;
	      var eccPrimeSquared;
	      var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));
	      var N1, T1, C1, R1, D, M;
	      var LongOrigin;
	      var mu, phi1Rad;

	      // remove 500,000 meter offset for longitude
	      var x = UTMEasting - 500000.0;
	      var y = UTMNorthing;

	      // We must know somehow if we are in the Northern or Southern
	      // hemisphere, this is the only time we use the letter So even
	      // if the Zone letter isn't exactly correct it should indicate
	      // the hemisphere correctly
	      if (zoneLetter < 'N') {
	        y -= 10000000.0; // remove 10,000,000 meter offset used
	        // for southern hemisphere
	      }

	      // There are 60 zones with zone 1 being at West -180 to -174
	      LongOrigin = (zoneNumber - 1) * 6 - 180 + 3; // +3 puts origin
	      // in middle of
	      // zone

	      eccPrimeSquared = (eccSquared) / (1 - eccSquared);

	      M = y / k0;
	      mu = M / (a * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));

	      phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + (151 * e1 * e1 * e1 / 96) * Math.sin(6 * mu);
	      // double phi1 = ProjMath.radToDeg(phi1Rad);

	      N1 = a / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));
	      T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);
	      C1 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);
	      R1 = a * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);
	      D = x / (N1 * k0);

	      var lat = phi1Rad - (N1 * Math.tan(phi1Rad) / R1) * (D * D / 2 - (5 + 3 * T1 + 10 * C1 - 4 * C1 * C1 - 9 * eccPrimeSquared) * D * D * D * D / 24 + (61 + 90 * T1 + 298 * C1 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C1 * C1) * D * D * D * D * D * D / 720);
	      lat = radToDeg(lat);

	      var lon = (D - (1 + 2 * T1 + C1) * D * D * D / 6 + (5 - 2 * C1 + 28 * T1 - 3 * C1 * C1 + 8 * eccPrimeSquared + 24 * T1 * T1) * D * D * D * D * D / 120) / Math.cos(phi1Rad);
	      lon = LongOrigin + radToDeg(lon);

	      var result;
	      if (utm.accuracy) {
	        var topRight = UTMtoLL({
	          northing: utm.northing + utm.accuracy,
	          easting: utm.easting + utm.accuracy,
	          zoneLetter: utm.zoneLetter,
	          zoneNumber: utm.zoneNumber
	        });
	        result = {
	          top: topRight.lat,
	          right: topRight.lon,
	          bottom: lat,
	          left: lon
	        };
	      }
	      else {
	        result = {
	          lat: lat,
	          lon: lon
	        };
	      }
	      return result;
	    }

	    /**
	     * Calculates the MGRS letter designator for the given latitude.
	     *
	     * @private
	     * @param {number} lat The latitude in WGS84 to get the letter designator
	     *     for.
	     * @return {char} The letter designator.
	     */
	    function getLetterDesignator(lat) {
	      //This is here as an error flag to show that the Latitude is
	      //outside MGRS limits
	      var LetterDesignator = 'Z';

	      if ((84 >= lat) && (lat >= 72)) {
	        LetterDesignator = 'X';
	      }
	      else if ((72 > lat) && (lat >= 64)) {
	        LetterDesignator = 'W';
	      }
	      else if ((64 > lat) && (lat >= 56)) {
	        LetterDesignator = 'V';
	      }
	      else if ((56 > lat) && (lat >= 48)) {
	        LetterDesignator = 'U';
	      }
	      else if ((48 > lat) && (lat >= 40)) {
	        LetterDesignator = 'T';
	      }
	      else if ((40 > lat) && (lat >= 32)) {
	        LetterDesignator = 'S';
	      }
	      else if ((32 > lat) && (lat >= 24)) {
	        LetterDesignator = 'R';
	      }
	      else if ((24 > lat) && (lat >= 16)) {
	        LetterDesignator = 'Q';
	      }
	      else if ((16 > lat) && (lat >= 8)) {
	        LetterDesignator = 'P';
	      }
	      else if ((8 > lat) && (lat >= 0)) {
	        LetterDesignator = 'N';
	      }
	      else if ((0 > lat) && (lat >= -8)) {
	        LetterDesignator = 'M';
	      }
	      else if ((-8 > lat) && (lat >= -16)) {
	        LetterDesignator = 'L';
	      }
	      else if ((-16 > lat) && (lat >= -24)) {
	        LetterDesignator = 'K';
	      }
	      else if ((-24 > lat) && (lat >= -32)) {
	        LetterDesignator = 'J';
	      }
	      else if ((-32 > lat) && (lat >= -40)) {
	        LetterDesignator = 'H';
	      }
	      else if ((-40 > lat) && (lat >= -48)) {
	        LetterDesignator = 'G';
	      }
	      else if ((-48 > lat) && (lat >= -56)) {
	        LetterDesignator = 'F';
	      }
	      else if ((-56 > lat) && (lat >= -64)) {
	        LetterDesignator = 'E';
	      }
	      else if ((-64 > lat) && (lat >= -72)) {
	        LetterDesignator = 'D';
	      }
	      else if ((-72 > lat) && (lat >= -80)) {
	        LetterDesignator = 'C';
	      }
	      return LetterDesignator;
	    }

	    /**
	     * Encodes a UTM location as MGRS string.
	     *
	     * @private
	     * @param {object} utm An object literal with easting, northing,
	     *     zoneLetter, zoneNumber
	     * @param {number} accuracy Accuracy in digits (1-5).
	     * @return {string} MGRS string for the given UTM location.
	     */
	    function encode(utm, accuracy) {
	      // prepend with leading zeroes
	      var seasting = "00000" + utm.easting,
	        snorthing = "00000" + utm.northing;

	      return utm.zoneNumber + utm.zoneLetter + get100kID(utm.easting, utm.northing, utm.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);
	    }

	    /**
	     * Get the two letter 100k designator for a given UTM easting,
	     * northing and zone number value.
	     *
	     * @private
	     * @param {number} easting
	     * @param {number} northing
	     * @param {number} zoneNumber
	     * @return the two letter 100k designator for the given UTM location.
	     */
	    function get100kID(easting, northing, zoneNumber) {
	      var setParm = get100kSetForZone(zoneNumber);
	      var setColumn = Math.floor(easting / 100000);
	      var setRow = Math.floor(northing / 100000) % 20;
	      return getLetter100kID(setColumn, setRow, setParm);
	    }

	    /**
	     * Given a UTM zone number, figure out the MGRS 100K set it is in.
	     *
	     * @private
	     * @param {number} i An UTM zone number.
	     * @return {number} the 100k set the UTM zone is in.
	     */
	    function get100kSetForZone(i) {
	      var setParm = i % NUM_100K_SETS;
	      if (setParm === 0) {
	        setParm = NUM_100K_SETS;
	      }

	      return setParm;
	    }

	    /**
	     * Get the two-letter MGRS 100k designator given information
	     * translated from the UTM northing, easting and zone number.
	     *
	     * @private
	     * @param {number} column the column index as it relates to the MGRS
	     *        100k set spreadsheet, created from the UTM easting.
	     *        Values are 1-8.
	     * @param {number} row the row index as it relates to the MGRS 100k set
	     *        spreadsheet, created from the UTM northing value. Values
	     *        are from 0-19.
	     * @param {number} parm the set block, as it relates to the MGRS 100k set
	     *        spreadsheet, created from the UTM zone. Values are from
	     *        1-60.
	     * @return two letter MGRS 100k code.
	     */
	    function getLetter100kID(column, row, parm) {
	      // colOrigin and rowOrigin are the letters at the origin of the set
	      var index = parm - 1;
	      var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index);
	      var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index);

	      // colInt and rowInt are the letters to build to return
	      var colInt = colOrigin + column - 1;
	      var rowInt = rowOrigin + row;
	      var rollover = false;

	      if (colInt > Z) {
	        colInt = colInt - Z + A - 1;
	        rollover = true;
	      }

	      if (colInt === I || (colOrigin < I && colInt > I) || ((colInt > I || colOrigin < I) && rollover)) {
	        colInt++;
	      }

	      if (colInt === O || (colOrigin < O && colInt > O) || ((colInt > O || colOrigin < O) && rollover)) {
	        colInt++;

	        if (colInt === I) {
	          colInt++;
	        }
	      }

	      if (colInt > Z) {
	        colInt = colInt - Z + A - 1;
	      }

	      if (rowInt > V) {
	        rowInt = rowInt - V + A - 1;
	        rollover = true;
	      }
	      else {
	        rollover = false;
	      }

	      if (((rowInt === I) || ((rowOrigin < I) && (rowInt > I))) || (((rowInt > I) || (rowOrigin < I)) && rollover)) {
	        rowInt++;
	      }

	      if (((rowInt === O) || ((rowOrigin < O) && (rowInt > O))) || (((rowInt > O) || (rowOrigin < O)) && rollover)) {
	        rowInt++;

	        if (rowInt === I) {
	          rowInt++;
	        }
	      }

	      if (rowInt > V) {
	        rowInt = rowInt - V + A - 1;
	      }

	      var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);
	      return twoLetter;
	    }

	    /**
	     * Decode the UTM parameters from a MGRS string.
	     *
	     * @private
	     * @param {string} mgrsString an UPPERCASE coordinate string is expected.
	     * @return {object} An object literal with easting, northing, zoneLetter,
	     *     zoneNumber and accuracy (in meters) properties.
	     */
	    function decode(mgrsString) {

	      if (mgrsString && mgrsString.length === 0) {
	        throw ("MGRSPoint coverting from nothing");
	      }

	      var length = mgrsString.length;

	      var hunK = null;
	      var sb = "";
	      var testChar;
	      var i = 0;

	      // get Zone number
	      while (!(/[A-Z]/).test(testChar = mgrsString.charAt(i))) {
	        if (i >= 2) {
	          throw ("MGRSPoint bad conversion from: " + mgrsString);
	        }
	        sb += testChar;
	        i++;
	      }

	      var zoneNumber = parseInt(sb, 10);

	      if (i === 0 || i + 3 > length) {
	        // A good MGRS string has to be 4-5 digits long,
	        // ##AAA/#AAA at least.
	        throw ("MGRSPoint bad conversion from: " + mgrsString);
	      }

	      var zoneLetter = mgrsString.charAt(i++);

	      // Should we check the zone letter here? Why not.
	      if (zoneLetter <= 'A' || zoneLetter === 'B' || zoneLetter === 'Y' || zoneLetter >= 'Z' || zoneLetter === 'I' || zoneLetter === 'O') {
	        throw ("MGRSPoint zone letter " + zoneLetter + " not handled: " + mgrsString);
	      }

	      hunK = mgrsString.substring(i, i += 2);

	      var set = get100kSetForZone(zoneNumber);

	      var east100k = getEastingFromChar(hunK.charAt(0), set);
	      var north100k = getNorthingFromChar(hunK.charAt(1), set);

	      // We have a bug where the northing may be 2000000 too low.
	      // How
	      // do we know when to roll over?

	      while (north100k < getMinNorthing(zoneLetter)) {
	        north100k += 2000000;
	      }

	      // calculate the char index for easting/northing separator
	      var remainder = length - i;

	      if (remainder % 2 !== 0) {
	        throw ("MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + mgrsString);
	      }

	      var sep = remainder / 2;

	      var sepEasting = 0.0;
	      var sepNorthing = 0.0;
	      var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;
	      if (sep > 0) {
	        accuracyBonus = 100000.0 / Math.pow(10, sep);
	        sepEastingString = mgrsString.substring(i, i + sep);
	        sepEasting = parseFloat(sepEastingString) * accuracyBonus;
	        sepNorthingString = mgrsString.substring(i + sep);
	        sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;
	      }

	      easting = sepEasting + east100k;
	      northing = sepNorthing + north100k;

	      return {
	        easting: easting,
	        northing: northing,
	        zoneLetter: zoneLetter,
	        zoneNumber: zoneNumber,
	        accuracy: accuracyBonus
	      };
	    }

	    /**
	     * Given the first letter from a two-letter MGRS 100k zone, and given the
	     * MGRS table set for the zone number, figure out the easting value that
	     * should be added to the other, secondary easting value.
	     *
	     * @private
	     * @param {char} e The first letter from a two-letter MGRS 100´k zone.
	     * @param {number} set The MGRS table set for the zone number.
	     * @return {number} The easting value for the given letter and set.
	     */
	    function getEastingFromChar(e, set) {
	      // colOrigin is the letter at the origin of the set for the
	      // column
	      var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set - 1);
	      var eastingValue = 100000.0;
	      var rewindMarker = false;

	      while (curCol !== e.charCodeAt(0)) {
	        curCol++;
	        if (curCol === I) {
	          curCol++;
	        }
	        if (curCol === O) {
	          curCol++;
	        }
	        if (curCol > Z) {
	          if (rewindMarker) {
	            throw ("Bad character: " + e);
	          }
	          curCol = A;
	          rewindMarker = true;
	        }
	        eastingValue += 100000.0;
	      }

	      return eastingValue;
	    }

	    /**
	     * Given the second letter from a two-letter MGRS 100k zone, and given the
	     * MGRS table set for the zone number, figure out the northing value that
	     * should be added to the other, secondary northing value. You have to
	     * remember that Northings are determined from the equator, and the vertical
	     * cycle of letters mean a 2000000 additional northing meters. This happens
	     * approx. every 18 degrees of latitude. This method does *NOT* count any
	     * additional northings. You have to figure out how many 2000000 meters need
	     * to be added for the zone letter of the MGRS coordinate.
	     *
	     * @private
	     * @param {char} n Second letter of the MGRS 100k zone
	     * @param {number} set The MGRS table set number, which is dependent on the
	     *     UTM zone number.
	     * @return {number} The northing value for the given letter and set.
	     */
	    function getNorthingFromChar(n, set) {

	      if (n > 'V') {
	        throw ("MGRSPoint given invalid Northing " + n);
	      }

	      // rowOrigin is the letter at the origin of the set for the
	      // column
	      var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set - 1);
	      var northingValue = 0.0;
	      var rewindMarker = false;

	      while (curRow !== n.charCodeAt(0)) {
	        curRow++;
	        if (curRow === I) {
	          curRow++;
	        }
	        if (curRow === O) {
	          curRow++;
	        }
	        // fixing a bug making whole application hang in this loop
	        // when 'n' is a wrong character
	        if (curRow > V) {
	          if (rewindMarker) { // making sure that this loop ends
	            throw ("Bad character: " + n);
	          }
	          curRow = A;
	          rewindMarker = true;
	        }
	        northingValue += 100000.0;
	      }

	      return northingValue;
	    }

	    /**
	     * The function getMinNorthing returns the minimum northing value of a MGRS
	     * zone.
	     *
	     * Ported from Geotrans' c Lattitude_Band_Value structure table.
	     *
	     * @private
	     * @param {char} zoneLetter The MGRS zone to get the min northing for.
	     * @return {number}
	     */
	    function getMinNorthing(zoneLetter) {
	      var northing;
	      switch (zoneLetter) {
	      case 'C':
	        northing = 1100000.0;
	        break;
	      case 'D':
	        northing = 2000000.0;
	        break;
	      case 'E':
	        northing = 2800000.0;
	        break;
	      case 'F':
	        northing = 3700000.0;
	        break;
	      case 'G':
	        northing = 4600000.0;
	        break;
	      case 'H':
	        northing = 5500000.0;
	        break;
	      case 'J':
	        northing = 6400000.0;
	        break;
	      case 'K':
	        northing = 7300000.0;
	        break;
	      case 'L':
	        northing = 8200000.0;
	        break;
	      case 'M':
	        northing = 9100000.0;
	        break;
	      case 'N':
	        northing = 0.0;
	        break;
	      case 'P':
	        northing = 800000.0;
	        break;
	      case 'Q':
	        northing = 1700000.0;
	        break;
	      case 'R':
	        northing = 2600000.0;
	        break;
	      case 'S':
	        northing = 3500000.0;
	        break;
	      case 'T':
	        northing = 4400000.0;
	        break;
	      case 'U':
	        northing = 5300000.0;
	        break;
	      case 'V':
	        northing = 6200000.0;
	        break;
	      case 'W':
	        northing = 7000000.0;
	        break;
	      case 'X':
	        northing = 7900000.0;
	        break;
	      default:
	        northing = -1.0;
	      }
	      if (northing >= 0.0) {
	        return northing;
	      }
	      else {
	        throw ("Invalid zone letter: " + zoneLetter);
	      }

	    }

	    function Point(x, y, z) {
	      if (!(this instanceof Point)) {
	        return new Point(x, y, z);
	      }
	      if (Array.isArray(x)) {
	        this.x = x[0];
	        this.y = x[1];
	        this.z = x[2] || 0.0;
	      } else if(typeof x === 'object') {
	        this.x = x.x;
	        this.y = x.y;
	        this.z = x.z || 0.0;
	      } else if (typeof x === 'string' && typeof y === 'undefined') {
	        var coords = x.split(',');
	        this.x = parseFloat(coords[0], 10);
	        this.y = parseFloat(coords[1], 10);
	        this.z = parseFloat(coords[2], 10) || 0.0;
	      } else {
	        this.x = x;
	        this.y = y;
	        this.z = z || 0.0;
	      }
	      console.warn('proj4.Point will be removed in version 3, use proj4.toPoint');
	    }

	    Point.fromMGRS = function(mgrsStr) {
	      return new Point(toPoint$1(mgrsStr));
	    };
	    Point.prototype.toMGRS = function(accuracy) {
	      return forward$1([this.x, this.y], accuracy);
	    };

	    var C00 = 1;
	    var C02 = 0.25;
	    var C04 = 0.046875;
	    var C06 = 0.01953125;
	    var C08 = 0.01068115234375;
	    var C22 = 0.75;
	    var C44 = 0.46875;
	    var C46 = 0.01302083333333333333;
	    var C48 = 0.00712076822916666666;
	    var C66 = 0.36458333333333333333;
	    var C68 = 0.00569661458333333333;
	    var C88 = 0.3076171875;

	    var pj_enfn = function(es) {
	      var en = [];
	      en[0] = C00 - es * (C02 + es * (C04 + es * (C06 + es * C08)));
	      en[1] = es * (C22 - es * (C04 + es * (C06 + es * C08)));
	      var t = es * es;
	      en[2] = t * (C44 - es * (C46 + es * C48));
	      t *= es;
	      en[3] = t * (C66 - es * C68);
	      en[4] = t * es * C88;
	      return en;
	    };

	    var pj_mlfn = function(phi, sphi, cphi, en) {
	      cphi *= sphi;
	      sphi *= sphi;
	      return (en[0] * phi - cphi * (en[1] + sphi * (en[2] + sphi * (en[3] + sphi * en[4]))));
	    };

	    var MAX_ITER = 20;

	    var pj_inv_mlfn = function(arg, es, en) {
	      var k = 1 / (1 - es);
	      var phi = arg;
	      for (var i = MAX_ITER; i; --i) { /* rarely goes over 2 iterations */
	        var s = Math.sin(phi);
	        var t = 1 - es * s * s;
	        //t = this.pj_mlfn(phi, s, Math.cos(phi), en) - arg;
	        //phi -= t * (t * Math.sqrt(t)) * k;
	        t = (pj_mlfn(phi, s, Math.cos(phi), en) - arg) * (t * Math.sqrt(t)) * k;
	        phi -= t;
	        if (Math.abs(t) < EPSLN) {
	          return phi;
	        }
	      }
	      //..reportError("cass:pj_inv_mlfn: Convergence error");
	      return phi;
	    };

	    // Heavily based on this tmerc projection implementation
	    // https://github.com/mbloch/mapshaper-proj/blob/master/src/projections/tmerc.js

	    function init$2() {
	      this.x0 = this.x0 !== undefined ? this.x0 : 0;
	      this.y0 = this.y0 !== undefined ? this.y0 : 0;
	      this.long0 = this.long0 !== undefined ? this.long0 : 0;
	      this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;

	      if (this.es) {
	        this.en = pj_enfn(this.es);
	        this.ml0 = pj_mlfn(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en);
	      }
	    }

	    /**
	        Transverse Mercator Forward  - long/lat to x/y
	        long/lat in radians
	      */
	    function forward$2(p) {
	      var lon = p.x;
	      var lat = p.y;

	      var delta_lon = adjust_lon(lon - this.long0);
	      var con;
	      var x, y;
	      var sin_phi = Math.sin(lat);
	      var cos_phi = Math.cos(lat);

	      if (!this.es) {
	        var b = cos_phi * Math.sin(delta_lon);

	        if ((Math.abs(Math.abs(b) - 1)) < EPSLN) {
	          return (93);
	        }
	        else {
	          x = 0.5 * this.a * this.k0 * Math.log((1 + b) / (1 - b)) + this.x0;
	          y = cos_phi * Math.cos(delta_lon) / Math.sqrt(1 - Math.pow(b, 2));
	          b = Math.abs(y);

	          if (b >= 1) {
	            if ((b - 1) > EPSLN) {
	              return (93);
	            }
	            else {
	              y = 0;
	            }
	          }
	          else {
	            y = Math.acos(y);
	          }

	          if (lat < 0) {
	            y = -y;
	          }

	          y = this.a * this.k0 * (y - this.lat0) + this.y0;
	        }
	      }
	      else {
	        var al = cos_phi * delta_lon;
	        var als = Math.pow(al, 2);
	        var c = this.ep2 * Math.pow(cos_phi, 2);
	        var cs = Math.pow(c, 2);
	        var tq = Math.abs(cos_phi) > EPSLN ? Math.tan(lat) : 0;
	        var t = Math.pow(tq, 2);
	        var ts = Math.pow(t, 2);
	        con = 1 - this.es * Math.pow(sin_phi, 2);
	        al = al / Math.sqrt(con);
	        var ml = pj_mlfn(lat, sin_phi, cos_phi, this.en);

	        x = this.a * (this.k0 * al * (1 +
	          als / 6 * (1 - t + c +
	          als / 20 * (5 - 18 * t + ts + 14 * c - 58 * t * c +
	          als / 42 * (61 + 179 * ts - ts * t - 479 * t))))) +
	          this.x0;

	        y = this.a * (this.k0 * (ml - this.ml0 +
	          sin_phi * delta_lon * al / 2 * (1 +
	          als / 12 * (5 - t + 9 * c + 4 * cs +
	          als / 30 * (61 + ts - 58 * t + 270 * c - 330 * t * c +
	          als / 56 * (1385 + 543 * ts - ts * t - 3111 * t)))))) +
	          this.y0;
	      }

	      p.x = x;
	      p.y = y;

	      return p;
	    }

	    /**
	        Transverse Mercator Inverse  -  x/y to long/lat
	      */
	    function inverse$2(p) {
	      var con, phi;
	      var lat, lon;
	      var x = (p.x - this.x0) * (1 / this.a);
	      var y = (p.y - this.y0) * (1 / this.a);

	      if (!this.es) {
	        var f = Math.exp(x / this.k0);
	        var g = 0.5 * (f - 1 / f);
	        var temp = this.lat0 + y / this.k0;
	        var h = Math.cos(temp);
	        con = Math.sqrt((1 - Math.pow(h, 2)) / (1 + Math.pow(g, 2)));
	        lat = Math.asin(con);

	        if (y < 0) {
	          lat = -lat;
	        }

	        if ((g === 0) && (h === 0)) {
	          lon = 0;
	        }
	        else {
	          lon = adjust_lon(Math.atan2(g, h) + this.long0);
	        }
	      }
	      else { // ellipsoidal form
	        con = this.ml0 + y / this.k0;
	        phi = pj_inv_mlfn(con, this.es, this.en);

	        if (Math.abs(phi) < HALF_PI) {
	          var sin_phi = Math.sin(phi);
	          var cos_phi = Math.cos(phi);
	          var tan_phi = Math.abs(cos_phi) > EPSLN ? Math.tan(phi) : 0;
	          var c = this.ep2 * Math.pow(cos_phi, 2);
	          var cs = Math.pow(c, 2);
	          var t = Math.pow(tan_phi, 2);
	          var ts = Math.pow(t, 2);
	          con = 1 - this.es * Math.pow(sin_phi, 2);
	          var d = x * Math.sqrt(con) / this.k0;
	          var ds = Math.pow(d, 2);
	          con = con * tan_phi;

	          lat = phi - (con * ds / (1 - this.es)) * 0.5 * (1 -
	            ds / 12 * (5 + 3 * t - 9 * c * t + c - 4 * cs -
	            ds / 30 * (61 + 90 * t - 252 * c * t + 45 * ts + 46 * c -
	            ds / 56 * (1385 + 3633 * t + 4095 * ts + 1574 * ts * t))));

	          lon = adjust_lon(this.long0 + (d * (1 -
	            ds / 6 * (1 + 2 * t + c -
	            ds / 20 * (5 + 28 * t + 24 * ts + 8 * c * t + 6 * c -
	            ds / 42 * (61 + 662 * t + 1320 * ts + 720 * ts * t)))) / cos_phi));
	        }
	        else {
	          lat = HALF_PI * sign(y);
	          lon = 0;
	        }
	      }

	      p.x = lon;
	      p.y = lat;

	      return p;
	    }

	    var names$3 = ["Transverse_Mercator", "Transverse Mercator", "tmerc"];
	    var tmerc = {
	      init: init$2,
	      forward: forward$2,
	      inverse: inverse$2,
	      names: names$3
	    };

	    var sinh = function(x) {
	      var r = Math.exp(x);
	      r = (r - 1 / r) / 2;
	      return r;
	    };

	    var hypot = function(x, y) {
	      x = Math.abs(x);
	      y = Math.abs(y);
	      var a = Math.max(x, y);
	      var b = Math.min(x, y) / (a ? a : 1);

	      return a * Math.sqrt(1 + Math.pow(b, 2));
	    };

	    var log1py = function(x) {
	      var y = 1 + x;
	      var z = y - 1;

	      return z === 0 ? x : x * Math.log(y) / z;
	    };

	    var asinhy = function(x) {
	      var y = Math.abs(x);
	      y = log1py(y * (1 + y / (hypot(1, y) + 1)));

	      return x < 0 ? -y : y;
	    };

	    var gatg = function(pp, B) {
	      var cos_2B = 2 * Math.cos(2 * B);
	      var i = pp.length - 1;
	      var h1 = pp[i];
	      var h2 = 0;
	      var h;

	      while (--i >= 0) {
	        h = -h2 + cos_2B * h1 + pp[i];
	        h2 = h1;
	        h1 = h;
	      }

	      return (B + h * Math.sin(2 * B));
	    };

	    var clens = function(pp, arg_r) {
	      var r = 2 * Math.cos(arg_r);
	      var i = pp.length - 1;
	      var hr1 = pp[i];
	      var hr2 = 0;
	      var hr;

	      while (--i >= 0) {
	        hr = -hr2 + r * hr1 + pp[i];
	        hr2 = hr1;
	        hr1 = hr;
	      }

	      return Math.sin(arg_r) * hr;
	    };

	    var cosh = function(x) {
	      var r = Math.exp(x);
	      r = (r + 1 / r) / 2;
	      return r;
	    };

	    var clens_cmplx = function(pp, arg_r, arg_i) {
	      var sin_arg_r = Math.sin(arg_r);
	      var cos_arg_r = Math.cos(arg_r);
	      var sinh_arg_i = sinh(arg_i);
	      var cosh_arg_i = cosh(arg_i);
	      var r = 2 * cos_arg_r * cosh_arg_i;
	      var i = -2 * sin_arg_r * sinh_arg_i;
	      var j = pp.length - 1;
	      var hr = pp[j];
	      var hi1 = 0;
	      var hr1 = 0;
	      var hi = 0;
	      var hr2;
	      var hi2;

	      while (--j >= 0) {
	        hr2 = hr1;
	        hi2 = hi1;
	        hr1 = hr;
	        hi1 = hi;
	        hr = -hr2 + r * hr1 - i * hi1 + pp[j];
	        hi = -hi2 + i * hr1 + r * hi1;
	      }

	      r = sin_arg_r * cosh_arg_i;
	      i = cos_arg_r * sinh_arg_i;

	      return [r * hr - i * hi, r * hi + i * hr];
	    };

	    // Heavily based on this etmerc projection implementation
	    // https://github.com/mbloch/mapshaper-proj/blob/master/src/projections/etmerc.js

	    function init$3() {
	      if (this.es === undefined || this.es <= 0) {
	        throw new Error('incorrect elliptical usage');
	      }

	      this.x0 = this.x0 !== undefined ? this.x0 : 0;
	      this.y0 = this.y0 !== undefined ? this.y0 : 0;
	      this.long0 = this.long0 !== undefined ? this.long0 : 0;
	      this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;

	      this.cgb = [];
	      this.cbg = [];
	      this.utg = [];
	      this.gtu = [];

	      var f = this.es / (1 + Math.sqrt(1 - this.es));
	      var n = f / (2 - f);
	      var np = n;

	      this.cgb[0] = n * (2 + n * (-2 / 3 + n * (-2 + n * (116 / 45 + n * (26 / 45 + n * (-2854 / 675 ))))));
	      this.cbg[0] = n * (-2 + n * ( 2 / 3 + n * ( 4 / 3 + n * (-82 / 45 + n * (32 / 45 + n * (4642 / 4725))))));

	      np = np * n;
	      this.cgb[1] = np * (7 / 3 + n * (-8 / 5 + n * (-227 / 45 + n * (2704 / 315 + n * (2323 / 945)))));
	      this.cbg[1] = np * (5 / 3 + n * (-16 / 15 + n * ( -13 / 9 + n * (904 / 315 + n * (-1522 / 945)))));

	      np = np * n;
	      this.cgb[2] = np * (56 / 15 + n * (-136 / 35 + n * (-1262 / 105 + n * (73814 / 2835))));
	      this.cbg[2] = np * (-26 / 15 + n * (34 / 21 + n * (8 / 5 + n * (-12686 / 2835))));

	      np = np * n;
	      this.cgb[3] = np * (4279 / 630 + n * (-332 / 35 + n * (-399572 / 14175)));
	      this.cbg[3] = np * (1237 / 630 + n * (-12 / 5 + n * ( -24832 / 14175)));

	      np = np * n;
	      this.cgb[4] = np * (4174 / 315 + n * (-144838 / 6237));
	      this.cbg[4] = np * (-734 / 315 + n * (109598 / 31185));

	      np = np * n;
	      this.cgb[5] = np * (601676 / 22275);
	      this.cbg[5] = np * (444337 / 155925);

	      np = Math.pow(n, 2);
	      this.Qn = this.k0 / (1 + n) * (1 + np * (1 / 4 + np * (1 / 64 + np / 256)));

	      this.utg[0] = n * (-0.5 + n * ( 2 / 3 + n * (-37 / 96 + n * ( 1 / 360 + n * (81 / 512 + n * (-96199 / 604800))))));
	      this.gtu[0] = n * (0.5 + n * (-2 / 3 + n * (5 / 16 + n * (41 / 180 + n * (-127 / 288 + n * (7891 / 37800))))));

	      this.utg[1] = np * (-1 / 48 + n * (-1 / 15 + n * (437 / 1440 + n * (-46 / 105 + n * (1118711 / 3870720)))));
	      this.gtu[1] = np * (13 / 48 + n * (-3 / 5 + n * (557 / 1440 + n * (281 / 630 + n * (-1983433 / 1935360)))));

	      np = np * n;
	      this.utg[2] = np * (-17 / 480 + n * (37 / 840 + n * (209 / 4480 + n * (-5569 / 90720 ))));
	      this.gtu[2] = np * (61 / 240 + n * (-103 / 140 + n * (15061 / 26880 + n * (167603 / 181440))));

	      np = np * n;
	      this.utg[3] = np * (-4397 / 161280 + n * (11 / 504 + n * (830251 / 7257600)));
	      this.gtu[3] = np * (49561 / 161280 + n * (-179 / 168 + n * (6601661 / 7257600)));

	      np = np * n;
	      this.utg[4] = np * (-4583 / 161280 + n * (108847 / 3991680));
	      this.gtu[4] = np * (34729 / 80640 + n * (-3418889 / 1995840));

	      np = np * n;
	      this.utg[5] = np * (-20648693 / 638668800);
	      this.gtu[5] = np * (212378941 / 319334400);

	      var Z = gatg(this.cbg, this.lat0);
	      this.Zb = -this.Qn * (Z + clens(this.gtu, 2 * Z));
	    }

	    function forward$3(p) {
	      var Ce = adjust_lon(p.x - this.long0);
	      var Cn = p.y;

	      Cn = gatg(this.cbg, Cn);
	      var sin_Cn = Math.sin(Cn);
	      var cos_Cn = Math.cos(Cn);
	      var sin_Ce = Math.sin(Ce);
	      var cos_Ce = Math.cos(Ce);

	      Cn = Math.atan2(sin_Cn, cos_Ce * cos_Cn);
	      Ce = Math.atan2(sin_Ce * cos_Cn, hypot(sin_Cn, cos_Cn * cos_Ce));
	      Ce = asinhy(Math.tan(Ce));

	      var tmp = clens_cmplx(this.gtu, 2 * Cn, 2 * Ce);

	      Cn = Cn + tmp[0];
	      Ce = Ce + tmp[1];

	      var x;
	      var y;

	      if (Math.abs(Ce) <= 2.623395162778) {
	        x = this.a * (this.Qn * Ce) + this.x0;
	        y = this.a * (this.Qn * Cn + this.Zb) + this.y0;
	      }
	      else {
	        x = Infinity;
	        y = Infinity;
	      }

	      p.x = x;
	      p.y = y;

	      return p;
	    }

	    function inverse$3(p) {
	      var Ce = (p.x - this.x0) * (1 / this.a);
	      var Cn = (p.y - this.y0) * (1 / this.a);

	      Cn = (Cn - this.Zb) / this.Qn;
	      Ce = Ce / this.Qn;

	      var lon;
	      var lat;

	      if (Math.abs(Ce) <= 2.623395162778) {
	        var tmp = clens_cmplx(this.utg, 2 * Cn, 2 * Ce);

	        Cn = Cn + tmp[0];
	        Ce = Ce + tmp[1];
	        Ce = Math.atan(sinh(Ce));

	        var sin_Cn = Math.sin(Cn);
	        var cos_Cn = Math.cos(Cn);
	        var sin_Ce = Math.sin(Ce);
	        var cos_Ce = Math.cos(Ce);

	        Cn = Math.atan2(sin_Cn * cos_Ce, hypot(sin_Ce, cos_Ce * cos_Cn));
	        Ce = Math.atan2(sin_Ce, cos_Ce * cos_Cn);

	        lon = adjust_lon(Ce + this.long0);
	        lat = gatg(this.cgb, Cn);
	      }
	      else {
	        lon = Infinity;
	        lat = Infinity;
	      }

	      p.x = lon;
	      p.y = lat;

	      return p;
	    }

	    var names$4 = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc"];
	    var etmerc = {
	      init: init$3,
	      forward: forward$3,
	      inverse: inverse$3,
	      names: names$4
	    };

	    var adjust_zone = function(zone, lon) {
	      if (zone === undefined) {
	        zone = Math.floor((adjust_lon(lon) + Math.PI) * 30 / Math.PI) + 1;

	        if (zone < 0) {
	          return 0;
	        } else if (zone > 60) {
	          return 60;
	        }
	      }
	      return zone;
	    };

	    var dependsOn = 'etmerc';
	    function init$4() {
	      var zone = adjust_zone(this.zone, this.long0);
	      if (zone === undefined) {
	        throw new Error('unknown utm zone');
	      }
	      this.lat0 = 0;
	      this.long0 =  ((6 * Math.abs(zone)) - 183) * D2R;
	      this.x0 = 500000;
	      this.y0 = this.utmSouth ? 10000000 : 0;
	      this.k0 = 0.9996;

	      etmerc.init.apply(this);
	      this.forward = etmerc.forward;
	      this.inverse = etmerc.inverse;
	    }

	    var names$5 = ["Universal Transverse Mercator System", "utm"];
	    var utm = {
	      init: init$4,
	      names: names$5,
	      dependsOn: dependsOn
	    };

	    var srat = function(esinp, exp) {
	      return (Math.pow((1 - esinp) / (1 + esinp), exp));
	    };

	    var MAX_ITER$1 = 20;
	    function init$6() {
	      var sphi = Math.sin(this.lat0);
	      var cphi = Math.cos(this.lat0);
	      cphi *= cphi;
	      this.rc = Math.sqrt(1 - this.es) / (1 - this.es * sphi * sphi);
	      this.C = Math.sqrt(1 + this.es * cphi * cphi / (1 - this.es));
	      this.phic0 = Math.asin(sphi / this.C);
	      this.ratexp = 0.5 * this.C * this.e;
	      this.K = Math.tan(0.5 * this.phic0 + FORTPI) / (Math.pow(Math.tan(0.5 * this.lat0 + FORTPI), this.C) * srat(this.e * sphi, this.ratexp));
	    }

	    function forward$5(p) {
	      var lon = p.x;
	      var lat = p.y;

	      p.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * lat + FORTPI), this.C) * srat(this.e * Math.sin(lat), this.ratexp)) - HALF_PI;
	      p.x = this.C * lon;
	      return p;
	    }

	    function inverse$5(p) {
	      var DEL_TOL = 1e-14;
	      var lon = p.x / this.C;
	      var lat = p.y;
	      var num = Math.pow(Math.tan(0.5 * lat + FORTPI) / this.K, 1 / this.C);
	      for (var i = MAX_ITER$1; i > 0; --i) {
	        lat = 2 * Math.atan(num * srat(this.e * Math.sin(p.y), - 0.5 * this.e)) - HALF_PI;
	        if (Math.abs(lat - p.y) < DEL_TOL) {
	          break;
	        }
	        p.y = lat;
	      }
	      /* convergence failed */
	      if (!i) {
	        return null;
	      }
	      p.x = lon;
	      p.y = lat;
	      return p;
	    }

	    var names$7 = ["gauss"];
	    var gauss = {
	      init: init$6,
	      forward: forward$5,
	      inverse: inverse$5,
	      names: names$7
	    };

	    function init$5() {
	      gauss.init.apply(this);
	      if (!this.rc) {
	        return;
	      }
	      this.sinc0 = Math.sin(this.phic0);
	      this.cosc0 = Math.cos(this.phic0);
	      this.R2 = 2 * this.rc;
	      if (!this.title) {
	        this.title = "Oblique Stereographic Alternative";
	      }
	    }

	    function forward$4(p) {
	      var sinc, cosc, cosl, k;
	      p.x = adjust_lon(p.x - this.long0);
	      gauss.forward.apply(this, [p]);
	      sinc = Math.sin(p.y);
	      cosc = Math.cos(p.y);
	      cosl = Math.cos(p.x);
	      k = this.k0 * this.R2 / (1 + this.sinc0 * sinc + this.cosc0 * cosc * cosl);
	      p.x = k * cosc * Math.sin(p.x);
	      p.y = k * (this.cosc0 * sinc - this.sinc0 * cosc * cosl);
	      p.x = this.a * p.x + this.x0;
	      p.y = this.a * p.y + this.y0;
	      return p;
	    }

	    function inverse$4(p) {
	      var sinc, cosc, lon, lat, rho;
	      p.x = (p.x - this.x0) / this.a;
	      p.y = (p.y - this.y0) / this.a;

	      p.x /= this.k0;
	      p.y /= this.k0;
	      if ((rho = Math.sqrt(p.x * p.x + p.y * p.y))) {
	        var c = 2 * Math.atan2(rho, this.R2);
	        sinc = Math.sin(c);
	        cosc = Math.cos(c);
	        lat = Math.asin(cosc * this.sinc0 + p.y * sinc * this.cosc0 / rho);
	        lon = Math.atan2(p.x * sinc, rho * this.cosc0 * cosc - p.y * this.sinc0 * sinc);
	      }
	      else {
	        lat = this.phic0;
	        lon = 0;
	      }

	      p.x = lon;
	      p.y = lat;
	      gauss.inverse.apply(this, [p]);
	      p.x = adjust_lon(p.x + this.long0);
	      return p;
	    }

	    var names$6 = ["Stereographic_North_Pole", "Oblique_Stereographic", "Polar_Stereographic", "sterea","Oblique Stereographic Alternative","Double_Stereographic"];
	    var sterea = {
	      init: init$5,
	      forward: forward$4,
	      inverse: inverse$4,
	      names: names$6
	    };

	    function ssfn_(phit, sinphi, eccen) {
	      sinphi *= eccen;
	      return (Math.tan(0.5 * (HALF_PI + phit)) * Math.pow((1 - sinphi) / (1 + sinphi), 0.5 * eccen));
	    }

	    function init$7() {
	      this.coslat0 = Math.cos(this.lat0);
	      this.sinlat0 = Math.sin(this.lat0);
	      if (this.sphere) {
	        if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
	          this.k0 = 0.5 * (1 + sign(this.lat0) * Math.sin(this.lat_ts));
	        }
	      }
	      else {
	        if (Math.abs(this.coslat0) <= EPSLN) {
	          if (this.lat0 > 0) {
	            //North pole
	            //trace('stere:north pole');
	            this.con = 1;
	          }
	          else {
	            //South pole
	            //trace('stere:south pole');
	            this.con = -1;
	          }
	        }
	        this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e));
	        if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
	          this.k0 = 0.5 * this.cons * msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / tsfnz(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts));
	        }
	        this.ms1 = msfnz(this.e, this.sinlat0, this.coslat0);
	        this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - HALF_PI;
	        this.cosX0 = Math.cos(this.X0);
	        this.sinX0 = Math.sin(this.X0);
	      }
	    }

	    // Stereographic forward equations--mapping lat,long to x,y
	    function forward$6(p) {
	      var lon = p.x;
	      var lat = p.y;
	      var sinlat = Math.sin(lat);
	      var coslat = Math.cos(lat);
	      var A, X, sinX, cosX, ts, rh;
	      var dlon = adjust_lon(lon - this.long0);

	      if (Math.abs(Math.abs(lon - this.long0) - Math.PI) <= EPSLN && Math.abs(lat + this.lat0) <= EPSLN) {
	        //case of the origine point
	        //trace('stere:this is the origin point');
	        p.x = NaN;
	        p.y = NaN;
	        return p;
	      }
	      if (this.sphere) {
	        //trace('stere:sphere case');
	        A = 2 * this.k0 / (1 + this.sinlat0 * sinlat + this.coslat0 * coslat * Math.cos(dlon));
	        p.x = this.a * A * coslat * Math.sin(dlon) + this.x0;
	        p.y = this.a * A * (this.coslat0 * sinlat - this.sinlat0 * coslat * Math.cos(dlon)) + this.y0;
	        return p;
	      }
	      else {
	        X = 2 * Math.atan(this.ssfn_(lat, sinlat, this.e)) - HALF_PI;
	        cosX = Math.cos(X);
	        sinX = Math.sin(X);
	        if (Math.abs(this.coslat0) <= EPSLN) {
	          ts = tsfnz(this.e, lat * this.con, this.con * sinlat);
	          rh = 2 * this.a * this.k0 * ts / this.cons;
	          p.x = this.x0 + rh * Math.sin(lon - this.long0);
	          p.y = this.y0 - this.con * rh * Math.cos(lon - this.long0);
	          //trace(p.toString());
	          return p;
	        }
	        else if (Math.abs(this.sinlat0) < EPSLN) {
	          //Eq
	          //trace('stere:equateur');
	          A = 2 * this.a * this.k0 / (1 + cosX * Math.cos(dlon));
	          p.y = A * sinX;
	        }
	        else {
	          //other case
	          //trace('stere:normal case');
	          A = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * sinX + this.cosX0 * cosX * Math.cos(dlon)));
	          p.y = A * (this.cosX0 * sinX - this.sinX0 * cosX * Math.cos(dlon)) + this.y0;
	        }
	        p.x = A * cosX * Math.sin(dlon) + this.x0;
	      }
	      //trace(p.toString());
	      return p;
	    }

	    //* Stereographic inverse equations--mapping x,y to lat/long
	    function inverse$6(p) {
	      p.x -= this.x0;
	      p.y -= this.y0;
	      var lon, lat, ts, ce, Chi;
	      var rh = Math.sqrt(p.x * p.x + p.y * p.y);
	      if (this.sphere) {
	        var c = 2 * Math.atan(rh / (2 * this.a * this.k0));
	        lon = this.long0;
	        lat = this.lat0;
	        if (rh <= EPSLN) {
	          p.x = lon;
	          p.y = lat;
	          return p;
	        }
	        lat = Math.asin(Math.cos(c) * this.sinlat0 + p.y * Math.sin(c) * this.coslat0 / rh);
	        if (Math.abs(this.coslat0) < EPSLN) {
	          if (this.lat0 > 0) {
	            lon = adjust_lon(this.long0 + Math.atan2(p.x, - 1 * p.y));
	          }
	          else {
	            lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
	          }
	        }
	        else {
	          lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(c), rh * this.coslat0 * Math.cos(c) - p.y * this.sinlat0 * Math.sin(c)));
	        }
	        p.x = lon;
	        p.y = lat;
	        return p;
	      }
	      else {
	        if (Math.abs(this.coslat0) <= EPSLN) {
	          if (rh <= EPSLN) {
	            lat = this.lat0;
	            lon = this.long0;
	            p.x = lon;
	            p.y = lat;
	            //trace(p.toString());
	            return p;
	          }
	          p.x *= this.con;
	          p.y *= this.con;
	          ts = rh * this.cons / (2 * this.a * this.k0);
	          lat = this.con * phi2z(this.e, ts);
	          lon = this.con * adjust_lon(this.con * this.long0 + Math.atan2(p.x, - 1 * p.y));
	        }
	        else {
	          ce = 2 * Math.atan(rh * this.cosX0 / (2 * this.a * this.k0 * this.ms1));
	          lon = this.long0;
	          if (rh <= EPSLN) {
	            Chi = this.X0;
	          }
	          else {
	            Chi = Math.asin(Math.cos(ce) * this.sinX0 + p.y * Math.sin(ce) * this.cosX0 / rh);
	            lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(ce), rh * this.cosX0 * Math.cos(ce) - p.y * this.sinX0 * Math.sin(ce)));
	          }
	          lat = -1 * phi2z(this.e, Math.tan(0.5 * (HALF_PI + Chi)));
	        }
	      }
	      p.x = lon;
	      p.y = lat;

	      //trace(p.toString());
	      return p;

	    }

	    var names$8 = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)"];
	    var stere = {
	      init: init$7,
	      forward: forward$6,
	      inverse: inverse$6,
	      names: names$8,
	      ssfn_: ssfn_
	    };

	    /*
	      references:
	        Formules et constantes pour le Calcul pour la
	        projection cylindrique conforme à axe oblique et pour la transformation entre
	        des systèmes de référence.
	        http://www.swisstopo.admin.ch/internet/swisstopo/fr/home/topics/survey/sys/refsys/switzerland.parsysrelated1.31216.downloadList.77004.DownloadFile.tmp/swissprojectionfr.pdf
	      */

	    function init$8() {
	      var phy0 = this.lat0;
	      this.lambda0 = this.long0;
	      var sinPhy0 = Math.sin(phy0);
	      var semiMajorAxis = this.a;
	      var invF = this.rf;
	      var flattening = 1 / invF;
	      var e2 = 2 * flattening - Math.pow(flattening, 2);
	      var e = this.e = Math.sqrt(e2);
	      this.R = this.k0 * semiMajorAxis * Math.sqrt(1 - e2) / (1 - e2 * Math.pow(sinPhy0, 2));
	      this.alpha = Math.sqrt(1 + e2 / (1 - e2) * Math.pow(Math.cos(phy0), 4));
	      this.b0 = Math.asin(sinPhy0 / this.alpha);
	      var k1 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2));
	      var k2 = Math.log(Math.tan(Math.PI / 4 + phy0 / 2));
	      var k3 = Math.log((1 + e * sinPhy0) / (1 - e * sinPhy0));
	      this.K = k1 - this.alpha * k2 + this.alpha * e / 2 * k3;
	    }

	    function forward$7(p) {
	      var Sa1 = Math.log(Math.tan(Math.PI / 4 - p.y / 2));
	      var Sa2 = this.e / 2 * Math.log((1 + this.e * Math.sin(p.y)) / (1 - this.e * Math.sin(p.y)));
	      var S = -this.alpha * (Sa1 + Sa2) + this.K;

	      // spheric latitude
	      var b = 2 * (Math.atan(Math.exp(S)) - Math.PI / 4);

	      // spheric longitude
	      var I = this.alpha * (p.x - this.lambda0);

	      // psoeudo equatorial rotation
	      var rotI = Math.atan(Math.sin(I) / (Math.sin(this.b0) * Math.tan(b) + Math.cos(this.b0) * Math.cos(I)));

	      var rotB = Math.asin(Math.cos(this.b0) * Math.sin(b) - Math.sin(this.b0) * Math.cos(b) * Math.cos(I));

	      p.y = this.R / 2 * Math.log((1 + Math.sin(rotB)) / (1 - Math.sin(rotB))) + this.y0;
	      p.x = this.R * rotI + this.x0;
	      return p;
	    }

	    function inverse$7(p) {
	      var Y = p.x - this.x0;
	      var X = p.y - this.y0;

	      var rotI = Y / this.R;
	      var rotB = 2 * (Math.atan(Math.exp(X / this.R)) - Math.PI / 4);

	      var b = Math.asin(Math.cos(this.b0) * Math.sin(rotB) + Math.sin(this.b0) * Math.cos(rotB) * Math.cos(rotI));
	      var I = Math.atan(Math.sin(rotI) / (Math.cos(this.b0) * Math.cos(rotI) - Math.sin(this.b0) * Math.tan(rotB)));

	      var lambda = this.lambda0 + I / this.alpha;

	      var S = 0;
	      var phy = b;
	      var prevPhy = -1000;
	      var iteration = 0;
	      while (Math.abs(phy - prevPhy) > 0.0000001) {
	        if (++iteration > 20) {
	          //...reportError("omercFwdInfinity");
	          return;
	        }
	        //S = Math.log(Math.tan(Math.PI / 4 + phy / 2));
	        S = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + b / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(phy)) / 2));
	        prevPhy = phy;
	        phy = 2 * Math.atan(Math.exp(S)) - Math.PI / 2;
	      }

	      p.x = lambda;
	      p.y = phy;
	      return p;
	    }

	    var names$9 = ["somerc"];
	    var somerc = {
	      init: init$8,
	      forward: forward$7,
	      inverse: inverse$7,
	      names: names$9
	    };

	    /* Initialize the Oblique Mercator  projection
	        ------------------------------------------*/
	    function init$9() {
	      this.no_off = this.no_off || false;
	      this.no_rot = this.no_rot || false;

	      if (isNaN(this.k0)) {
	        this.k0 = 1;
	      }
	      var sinlat = Math.sin(this.lat0);
	      var coslat = Math.cos(this.lat0);
	      var con = this.e * sinlat;

	      this.bl = Math.sqrt(1 + this.es / (1 - this.es) * Math.pow(coslat, 4));
	      this.al = this.a * this.bl * this.k0 * Math.sqrt(1 - this.es) / (1 - con * con);
	      var t0 = tsfnz(this.e, this.lat0, sinlat);
	      var dl = this.bl / coslat * Math.sqrt((1 - this.es) / (1 - con * con));
	      if (dl * dl < 1) {
	        dl = 1;
	      }
	      var fl;
	      var gl;
	      if (!isNaN(this.longc)) {
	        //Central point and azimuth method

	        if (this.lat0 >= 0) {
	          fl = dl + Math.sqrt(dl * dl - 1);
	        }
	        else {
	          fl = dl - Math.sqrt(dl * dl - 1);
	        }
	        this.el = fl * Math.pow(t0, this.bl);
	        gl = 0.5 * (fl - 1 / fl);
	        this.gamma0 = Math.asin(Math.sin(this.alpha) / dl);
	        this.long0 = this.longc - Math.asin(gl * Math.tan(this.gamma0)) / this.bl;

	      }
	      else {
	        //2 points method
	        var t1 = tsfnz(this.e, this.lat1, Math.sin(this.lat1));
	        var t2 = tsfnz(this.e, this.lat2, Math.sin(this.lat2));
	        if (this.lat0 >= 0) {
	          this.el = (dl + Math.sqrt(dl * dl - 1)) * Math.pow(t0, this.bl);
	        }
	        else {
	          this.el = (dl - Math.sqrt(dl * dl - 1)) * Math.pow(t0, this.bl);
	        }
	        var hl = Math.pow(t1, this.bl);
	        var ll = Math.pow(t2, this.bl);
	        fl = this.el / hl;
	        gl = 0.5 * (fl - 1 / fl);
	        var jl = (this.el * this.el - ll * hl) / (this.el * this.el + ll * hl);
	        var pl = (ll - hl) / (ll + hl);
	        var dlon12 = adjust_lon(this.long1 - this.long2);
	        this.long0 = 0.5 * (this.long1 + this.long2) - Math.atan(jl * Math.tan(0.5 * this.bl * (dlon12)) / pl) / this.bl;
	        this.long0 = adjust_lon(this.long0);
	        var dlon10 = adjust_lon(this.long1 - this.long0);
	        this.gamma0 = Math.atan(Math.sin(this.bl * (dlon10)) / gl);
	        this.alpha = Math.asin(dl * Math.sin(this.gamma0));
	      }

	      if (this.no_off) {
	        this.uc = 0;
	      }
	      else {
	        if (this.lat0 >= 0) {
	          this.uc = this.al / this.bl * Math.atan2(Math.sqrt(dl * dl - 1), Math.cos(this.alpha));
	        }
	        else {
	          this.uc = -1 * this.al / this.bl * Math.atan2(Math.sqrt(dl * dl - 1), Math.cos(this.alpha));
	        }
	      }

	    }

	    /* Oblique Mercator forward equations--mapping lat,long to x,y
	        ----------------------------------------------------------*/
	    function forward$8(p) {
	      var lon = p.x;
	      var lat = p.y;
	      var dlon = adjust_lon(lon - this.long0);
	      var us, vs;
	      var con;
	      if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
	        if (lat > 0) {
	          con = -1;
	        }
	        else {
	          con = 1;
	        }
	        vs = this.al / this.bl * Math.log(Math.tan(FORTPI + con * this.gamma0 * 0.5));
	        us = -1 * con * HALF_PI * this.al / this.bl;
	      }
	      else {
	        var t = tsfnz(this.e, lat, Math.sin(lat));
	        var ql = this.el / Math.pow(t, this.bl);
	        var sl = 0.5 * (ql - 1 / ql);
	        var tl = 0.5 * (ql + 1 / ql);
	        var vl = Math.sin(this.bl * (dlon));
	        var ul = (sl * Math.sin(this.gamma0) - vl * Math.cos(this.gamma0)) / tl;
	        if (Math.abs(Math.abs(ul) - 1) <= EPSLN) {
	          vs = Number.POSITIVE_INFINITY;
	        }
	        else {
	          vs = 0.5 * this.al * Math.log((1 - ul) / (1 + ul)) / this.bl;
	        }
	        if (Math.abs(Math.cos(this.bl * (dlon))) <= EPSLN) {
	          us = this.al * this.bl * (dlon);
	        }
	        else {
	          us = this.al * Math.atan2(sl * Math.cos(this.gamma0) + vl * Math.sin(this.gamma0), Math.cos(this.bl * dlon)) / this.bl;
	        }
	      }

	      if (this.no_rot) {
	        p.x = this.x0 + us;
	        p.y = this.y0 + vs;
	      }
	      else {

	        us -= this.uc;
	        p.x = this.x0 + vs * Math.cos(this.alpha) + us * Math.sin(this.alpha);
	        p.y = this.y0 + us * Math.cos(this.alpha) - vs * Math.sin(this.alpha);
	      }
	      return p;
	    }

	    function inverse$8(p) {
	      var us, vs;
	      if (this.no_rot) {
	        vs = p.y - this.y0;
	        us = p.x - this.x0;
	      }
	      else {
	        vs = (p.x - this.x0) * Math.cos(this.alpha) - (p.y - this.y0) * Math.sin(this.alpha);
	        us = (p.y - this.y0) * Math.cos(this.alpha) + (p.x - this.x0) * Math.sin(this.alpha);
	        us += this.uc;
	      }
	      var qp = Math.exp(-1 * this.bl * vs / this.al);
	      var sp = 0.5 * (qp - 1 / qp);
	      var tp = 0.5 * (qp + 1 / qp);
	      var vp = Math.sin(this.bl * us / this.al);
	      var up = (vp * Math.cos(this.gamma0) + sp * Math.sin(this.gamma0)) / tp;
	      var ts = Math.pow(this.el / Math.sqrt((1 + up) / (1 - up)), 1 / this.bl);
	      if (Math.abs(up - 1) < EPSLN) {
	        p.x = this.long0;
	        p.y = HALF_PI;
	      }
	      else if (Math.abs(up + 1) < EPSLN) {
	        p.x = this.long0;
	        p.y = -1 * HALF_PI;
	      }
	      else {
	        p.y = phi2z(this.e, ts);
	        p.x = adjust_lon(this.long0 - Math.atan2(sp * Math.cos(this.gamma0) - vp * Math.sin(this.gamma0), Math.cos(this.bl * us / this.al)) / this.bl);
	      }
	      return p;
	    }

	    var names$10 = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "omerc"];
	    var omerc = {
	      init: init$9,
	      forward: forward$8,
	      inverse: inverse$8,
	      names: names$10
	    };

	    function init$10() {

	      // array of:  r_maj,r_min,lat1,lat2,c_lon,c_lat,false_east,false_north
	      //double c_lat;                   /* center latitude                      */
	      //double c_lon;                   /* center longitude                     */
	      //double lat1;                    /* first standard parallel              */
	      //double lat2;                    /* second standard parallel             */
	      //double r_maj;                   /* major axis                           */
	      //double r_min;                   /* minor axis                           */
	      //double false_east;              /* x offset in meters                   */
	      //double false_north;             /* y offset in meters                   */

	      if (!this.lat2) {
	        this.lat2 = this.lat1;
	      } //if lat2 is not defined
	      if (!this.k0) {
	        this.k0 = 1;
	      }
	      this.x0 = this.x0 || 0;
	      this.y0 = this.y0 || 0;
	      // Standard Parallels cannot be equal and on opposite sides of the equator
	      if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
	        return;
	      }

	      var temp = this.b / this.a;
	      this.e = Math.sqrt(1 - temp * temp);

	      var sin1 = Math.sin(this.lat1);
	      var cos1 = Math.cos(this.lat1);
	      var ms1 = msfnz(this.e, sin1, cos1);
	      var ts1 = tsfnz(this.e, this.lat1, sin1);

	      var sin2 = Math.sin(this.lat2);
	      var cos2 = Math.cos(this.lat2);
	      var ms2 = msfnz(this.e, sin2, cos2);
	      var ts2 = tsfnz(this.e, this.lat2, sin2);

	      var ts0 = tsfnz(this.e, this.lat0, Math.sin(this.lat0));

	      if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
	        this.ns = Math.log(ms1 / ms2) / Math.log(ts1 / ts2);
	      }
	      else {
	        this.ns = sin1;
	      }
	      if (isNaN(this.ns)) {
	        this.ns = sin1;
	      }
	      this.f0 = ms1 / (this.ns * Math.pow(ts1, this.ns));
	      this.rh = this.a * this.f0 * Math.pow(ts0, this.ns);
	      if (!this.title) {
	        this.title = "Lambert Conformal Conic";
	      }
	    }

	    // Lambert Conformal conic forward equations--mapping lat,long to x,y
	    // -----------------------------------------------------------------
	    function forward$9(p) {

	      var lon = p.x;
	      var lat = p.y;

	      // singular cases :
	      if (Math.abs(2 * Math.abs(lat) - Math.PI) <= EPSLN) {
	        lat = sign(lat) * (HALF_PI - 2 * EPSLN);
	      }

	      var con = Math.abs(Math.abs(lat) - HALF_PI);
	      var ts, rh1;
	      if (con > EPSLN) {
	        ts = tsfnz(this.e, lat, Math.sin(lat));
	        rh1 = this.a * this.f0 * Math.pow(ts, this.ns);
	      }
	      else {
	        con = lat * this.ns;
	        if (con <= 0) {
	          return null;
	        }
	        rh1 = 0;
	      }
	      var theta = this.ns * adjust_lon(lon - this.long0);
	      p.x = this.k0 * (rh1 * Math.sin(theta)) + this.x0;
	      p.y = this.k0 * (this.rh - rh1 * Math.cos(theta)) + this.y0;

	      return p;
	    }

	    // Lambert Conformal Conic inverse equations--mapping x,y to lat/long
	    // -----------------------------------------------------------------
	    function inverse$9(p) {

	      var rh1, con, ts;
	      var lat, lon;
	      var x = (p.x - this.x0) / this.k0;
	      var y = (this.rh - (p.y - this.y0) / this.k0);
	      if (this.ns > 0) {
	        rh1 = Math.sqrt(x * x + y * y);
	        con = 1;
	      }
	      else {
	        rh1 = -Math.sqrt(x * x + y * y);
	        con = -1;
	      }
	      var theta = 0;
	      if (rh1 !== 0) {
	        theta = Math.atan2((con * x), (con * y));
	      }
	      if ((rh1 !== 0) || (this.ns > 0)) {
	        con = 1 / this.ns;
	        ts = Math.pow((rh1 / (this.a * this.f0)), con);
	        lat = phi2z(this.e, ts);
	        if (lat === -9999) {
	          return null;
	        }
	      }
	      else {
	        lat = -HALF_PI;
	      }
	      lon = adjust_lon(theta / this.ns + this.long0);

	      p.x = lon;
	      p.y = lat;
	      return p;
	    }

	    var names$11 = ["Lambert Tangential Conformal Conic Projection", "Lambert_Conformal_Conic", "Lambert_Conformal_Conic_2SP", "lcc"];
	    var lcc = {
	      init: init$10,
	      forward: forward$9,
	      inverse: inverse$9,
	      names: names$11
	    };

	    function init$11() {
	      this.a = 6377397.155;
	      this.es = 0.006674372230614;
	      this.e = Math.sqrt(this.es);
	      if (!this.lat0) {
	        this.lat0 = 0.863937979737193;
	      }
	      if (!this.long0) {
	        this.long0 = 0.7417649320975901 - 0.308341501185665;
	      }
	      /* if scale not set default to 0.9999 */
	      if (!this.k0) {
	        this.k0 = 0.9999;
	      }
	      this.s45 = 0.785398163397448; /* 45 */
	      this.s90 = 2 * this.s45;
	      this.fi0 = this.lat0;
	      this.e2 = this.es;
	      this.e = Math.sqrt(this.e2);
	      this.alfa = Math.sqrt(1 + (this.e2 * Math.pow(Math.cos(this.fi0), 4)) / (1 - this.e2));
	      this.uq = 1.04216856380474;
	      this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa);
	      this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2);
	      this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g;
	      this.k1 = this.k0;
	      this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2));
	      this.s0 = 1.37008346281555;
	      this.n = Math.sin(this.s0);
	      this.ro0 = this.k1 * this.n0 / Math.tan(this.s0);
	      this.ad = this.s90 - this.uq;
	    }

	    /* ellipsoid */
	    /* calculate xy from lat/lon */
	    /* Constants, identical to inverse transform function */
	    function forward$10(p) {
	      var gfi, u, deltav, s, d, eps, ro;
	      var lon = p.x;
	      var lat = p.y;
	      var delta_lon = adjust_lon(lon - this.long0);
	      /* Transformation */
	      gfi = Math.pow(((1 + this.e * Math.sin(lat)) / (1 - this.e * Math.sin(lat))), (this.alfa * this.e / 2));
	      u = 2 * (Math.atan(this.k * Math.pow(Math.tan(lat / 2 + this.s45), this.alfa) / gfi) - this.s45);
	      deltav = -delta_lon * this.alfa;
	      s = Math.asin(Math.cos(this.ad) * Math.sin(u) + Math.sin(this.ad) * Math.cos(u) * Math.cos(deltav));
	      d = Math.asin(Math.cos(u) * Math.sin(deltav) / Math.cos(s));
	      eps = this.n * d;
	      ro = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s / 2 + this.s45), this.n);
	      p.y = ro * Math.cos(eps) / 1;
	      p.x = ro * Math.sin(eps) / 1;

	      if (!this.czech) {
	        p.y *= -1;
	        p.x *= -1;
	      }
	      return (p);
	    }

	    /* calculate lat/lon from xy */
	    function inverse$10(p) {
	      var u, deltav, s, d, eps, ro, fi1;
	      var ok;

	      /* Transformation */
	      /* revert y, x*/
	      var tmp = p.x;
	      p.x = p.y;
	      p.y = tmp;
	      if (!this.czech) {
	        p.y *= -1;
	        p.x *= -1;
	      }
	      ro = Math.sqrt(p.x * p.x + p.y * p.y);
	      eps = Math.atan2(p.y, p.x);
	      d = eps / Math.sin(this.s0);
	      s = 2 * (Math.atan(Math.pow(this.ro0 / ro, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45);
	      u = Math.asin(Math.cos(this.ad) * Math.sin(s) - Math.sin(this.ad) * Math.cos(s) * Math.cos(d));
	      deltav = Math.asin(Math.cos(s) * Math.sin(d) / Math.cos(u));
	      p.x = this.long0 - deltav / this.alfa;
	      fi1 = u;
	      ok = 0;
	      var iter = 0;
	      do {
	        p.y = 2 * (Math.atan(Math.pow(this.k, - 1 / this.alfa) * Math.pow(Math.tan(u / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(fi1)) / (1 - this.e * Math.sin(fi1)), this.e / 2)) - this.s45);
	        if (Math.abs(fi1 - p.y) < 0.0000000001) {
	          ok = 1;
	        }
	        fi1 = p.y;
	        iter += 1;
	      } while (ok === 0 && iter < 15);
	      if (iter >= 15) {
	        return null;
	      }

	      return (p);
	    }

	    var names$12 = ["Krovak", "krovak"];
	    var krovak = {
	      init: init$11,
	      forward: forward$10,
	      inverse: inverse$10,
	      names: names$12
	    };

	    var mlfn = function(e0, e1, e2, e3, phi) {
	      return (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi));
	    };

	    var e0fn = function(x) {
	      return (1 - 0.25 * x * (1 + x / 16 * (3 + 1.25 * x)));
	    };

	    var e1fn = function(x) {
	      return (0.375 * x * (1 + 0.25 * x * (1 + 0.46875 * x)));
	    };

	    var e2fn = function(x) {
	      return (0.05859375 * x * x * (1 + 0.75 * x));
	    };

	    var e3fn = function(x) {
	      return (x * x * x * (35 / 3072));
	    };

	    var gN = function(a, e, sinphi) {
	      var temp = e * sinphi;
	      return a / Math.sqrt(1 - temp * temp);
	    };

	    var adjust_lat = function(x) {
	      return (Math.abs(x) < HALF_PI) ? x : (x - (sign(x) * Math.PI));
	    };

	    var imlfn = function(ml, e0, e1, e2, e3) {
	      var phi;
	      var dphi;

	      phi = ml / e0;
	      for (var i = 0; i < 15; i++) {
	        dphi = (ml - (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi))) / (e0 - 2 * e1 * Math.cos(2 * phi) + 4 * e2 * Math.cos(4 * phi) - 6 * e3 * Math.cos(6 * phi));
	        phi += dphi;
	        if (Math.abs(dphi) <= 0.0000000001) {
	          return phi;
	        }
	      }

	      //..reportError("IMLFN-CONV:Latitude failed to converge after 15 iterations");
	      return NaN;
	    };

	    function init$12() {
	      if (!this.sphere) {
	        this.e0 = e0fn(this.es);
	        this.e1 = e1fn(this.es);
	        this.e2 = e2fn(this.es);
	        this.e3 = e3fn(this.es);
	        this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
	      }
	    }

	    /* Cassini forward equations--mapping lat,long to x,y
	      -----------------------------------------------------------------------*/
	    function forward$11(p) {

	      /* Forward equations
	          -----------------*/
	      var x, y;
	      var lam = p.x;
	      var phi = p.y;
	      lam = adjust_lon(lam - this.long0);

	      if (this.sphere) {
	        x = this.a * Math.asin(Math.cos(phi) * Math.sin(lam));
	        y = this.a * (Math.atan2(Math.tan(phi), Math.cos(lam)) - this.lat0);
	      }
	      else {
	        //ellipsoid
	        var sinphi = Math.sin(phi);
	        var cosphi = Math.cos(phi);
	        var nl = gN(this.a, this.e, sinphi);
	        var tl = Math.tan(phi) * Math.tan(phi);
	        var al = lam * Math.cos(phi);
	        var asq = al * al;
	        var cl = this.es * cosphi * cosphi / (1 - this.es);
	        var ml = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);

	        x = nl * al * (1 - asq * tl * (1 / 6 - (8 - tl + 8 * cl) * asq / 120));
	        y = ml - this.ml0 + nl * sinphi / cosphi * asq * (0.5 + (5 - tl + 6 * cl) * asq / 24);


	      }

	      p.x = x + this.x0;
	      p.y = y + this.y0;
	      return p;
	    }

	    /* Inverse equations
	      -----------------*/
	    function inverse$11(p) {
	      p.x -= this.x0;
	      p.y -= this.y0;
	      var x = p.x / this.a;
	      var y = p.y / this.a;
	      var phi, lam;

	      if (this.sphere) {
	        var dd = y + this.lat0;
	        phi = Math.asin(Math.sin(dd) * Math.cos(x));
	        lam = Math.atan2(Math.tan(x), Math.cos(dd));
	      }
	      else {
	        /* ellipsoid */
	        var ml1 = this.ml0 / this.a + y;
	        var phi1 = imlfn(ml1, this.e0, this.e1, this.e2, this.e3);
	        if (Math.abs(Math.abs(phi1) - HALF_PI) <= EPSLN) {
	          p.x = this.long0;
	          p.y = HALF_PI;
	          if (y < 0) {
	            p.y *= -1;
	          }
	          return p;
	        }
	        var nl1 = gN(this.a, this.e, Math.sin(phi1));

	        var rl1 = nl1 * nl1 * nl1 / this.a / this.a * (1 - this.es);
	        var tl1 = Math.pow(Math.tan(phi1), 2);
	        var dl = x * this.a / nl1;
	        var dsq = dl * dl;
	        phi = phi1 - nl1 * Math.tan(phi1) / rl1 * dl * dl * (0.5 - (1 + 3 * tl1) * dl * dl / 24);
	        lam = dl * (1 - dsq * (tl1 / 3 + (1 + 3 * tl1) * tl1 * dsq / 15)) / Math.cos(phi1);

	      }

	      p.x = adjust_lon(lam + this.long0);
	      p.y = adjust_lat(phi);
	      return p;

	    }

	    var names$13 = ["Cassini", "Cassini_Soldner", "cass"];
	    var cass = {
	      init: init$12,
	      forward: forward$11,
	      inverse: inverse$11,
	      names: names$13
	    };

	    var qsfnz = function(eccent, sinphi) {
	      var con;
	      if (eccent > 1.0e-7) {
	        con = eccent * sinphi;
	        return ((1 - eccent * eccent) * (sinphi / (1 - con * con) - (0.5 / eccent) * Math.log((1 - con) / (1 + con))));
	      }
	      else {
	        return (2 * sinphi);
	      }
	    };

	    /*
	      reference
	        "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
	        The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
	      */

	    var S_POLE = 1;

	    var N_POLE = 2;
	    var EQUIT = 3;
	    var OBLIQ = 4;

	    /* Initialize the Lambert Azimuthal Equal Area projection
	      ------------------------------------------------------*/
	    function init$13() {
	      var t = Math.abs(this.lat0);
	      if (Math.abs(t - HALF_PI) < EPSLN) {
	        this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE;
	      }
	      else if (Math.abs(t) < EPSLN) {
	        this.mode = this.EQUIT;
	      }
	      else {
	        this.mode = this.OBLIQ;
	      }
	      if (this.es > 0) {
	        var sinphi;

	        this.qp = qsfnz(this.e, 1);
	        this.mmf = 0.5 / (1 - this.es);
	        this.apa = authset(this.es);
	        switch (this.mode) {
	        case this.N_POLE:
	          this.dd = 1;
	          break;
	        case this.S_POLE:
	          this.dd = 1;
	          break;
	        case this.EQUIT:
	          this.rq = Math.sqrt(0.5 * this.qp);
	          this.dd = 1 / this.rq;
	          this.xmf = 1;
	          this.ymf = 0.5 * this.qp;
	          break;
	        case this.OBLIQ:
	          this.rq = Math.sqrt(0.5 * this.qp);
	          sinphi = Math.sin(this.lat0);
	          this.sinb1 = qsfnz(this.e, sinphi) / this.qp;
	          this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1);
	          this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * sinphi * sinphi) * this.rq * this.cosb1);
	          this.ymf = (this.xmf = this.rq) / this.dd;
	          this.xmf *= this.dd;
	          break;
	        }
	      }
	      else {
	        if (this.mode === this.OBLIQ) {
	          this.sinph0 = Math.sin(this.lat0);
	          this.cosph0 = Math.cos(this.lat0);
	        }
	      }
	    }

	    /* Lambert Azimuthal Equal Area forward equations--mapping lat,long to x,y
	      -----------------------------------------------------------------------*/
	    function forward$12(p) {

	      /* Forward equations
	          -----------------*/
	      var x, y, coslam, sinlam, sinphi, q, sinb, cosb, b, cosphi;
	      var lam = p.x;
	      var phi = p.y;

	      lam = adjust_lon(lam - this.long0);
	      if (this.sphere) {
	        sinphi = Math.sin(phi);
	        cosphi = Math.cos(phi);
	        coslam = Math.cos(lam);
	        if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
	          y = (this.mode === this.EQUIT) ? 1 + cosphi * coslam : 1 + this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
	          if (y <= EPSLN) {
	            return null;
	          }
	          y = Math.sqrt(2 / y);
	          x = y * cosphi * Math.sin(lam);
	          y *= (this.mode === this.EQUIT) ? sinphi : this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
	        }
	        else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
	          if (this.mode === this.N_POLE) {
	            coslam = -coslam;
	          }
	          if (Math.abs(phi + this.phi0) < EPSLN) {
	            return null;
	          }
	          y = FORTPI - phi * 0.5;
	          y = 2 * ((this.mode === this.S_POLE) ? Math.cos(y) : Math.sin(y));
	          x = y * Math.sin(lam);
	          y *= coslam;
	        }
	      }
	      else {
	        sinb = 0;
	        cosb = 0;
	        b = 0;
	        coslam = Math.cos(lam);
	        sinlam = Math.sin(lam);
	        sinphi = Math.sin(phi);
	        q = qsfnz(this.e, sinphi);
	        if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
	          sinb = q / this.qp;
	          cosb = Math.sqrt(1 - sinb * sinb);
	        }
	        switch (this.mode) {
	        case this.OBLIQ:
	          b = 1 + this.sinb1 * sinb + this.cosb1 * cosb * coslam;
	          break;
	        case this.EQUIT:
	          b = 1 + cosb * coslam;
	          break;
	        case this.N_POLE:
	          b = HALF_PI + phi;
	          q = this.qp - q;
	          break;
	        case this.S_POLE:
	          b = phi - HALF_PI;
	          q = this.qp + q;
	          break;
	        }
	        if (Math.abs(b) < EPSLN) {
	          return null;
	        }
	        switch (this.mode) {
	        case this.OBLIQ:
	        case this.EQUIT:
	          b = Math.sqrt(2 / b);
	          if (this.mode === this.OBLIQ) {
	            y = this.ymf * b * (this.cosb1 * sinb - this.sinb1 * cosb * coslam);
	          }
	          else {
	            y = (b = Math.sqrt(2 / (1 + cosb * coslam))) * sinb * this.ymf;
	          }
	          x = this.xmf * b * cosb * sinlam;
	          break;
	        case this.N_POLE:
	        case this.S_POLE:
	          if (q >= 0) {
	            x = (b = Math.sqrt(q)) * sinlam;
	            y = coslam * ((this.mode === this.S_POLE) ? b : -b);
	          }
	          else {
	            x = y = 0;
	          }
	          break;
	        }
	      }

	      p.x = this.a * x + this.x0;
	      p.y = this.a * y + this.y0;
	      return p;
	    }

	    /* Inverse equations
	      -----------------*/
	    function inverse$12(p) {
	      p.x -= this.x0;
	      p.y -= this.y0;
	      var x = p.x / this.a;
	      var y = p.y / this.a;
	      var lam, phi, cCe, sCe, q, rho, ab;
	      if (this.sphere) {
	        var cosz = 0,
	          rh, sinz = 0;

	        rh = Math.sqrt(x * x + y * y);
	        phi = rh * 0.5;
	        if (phi > 1) {
	          return null;
	        }
	        phi = 2 * Math.asin(phi);
	        if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
	          sinz = Math.sin(phi);
	          cosz = Math.cos(phi);
	        }
	        switch (this.mode) {
	        case this.EQUIT:
	          phi = (Math.abs(rh) <= EPSLN) ? 0 : Math.asin(y * sinz / rh);
	          x *= sinz;
	          y = cosz * rh;
	          break;
	        case this.OBLIQ:
	          phi = (Math.abs(rh) <= EPSLN) ? this.phi0 : Math.asin(cosz * this.sinph0 + y * sinz * this.cosph0 / rh);
	          x *= sinz * this.cosph0;
	          y = (cosz - Math.sin(phi) * this.sinph0) * rh;
	          break;
	        case this.N_POLE:
	          y = -y;
	          phi = HALF_PI - phi;
	          break;
	        case this.S_POLE:
	          phi -= HALF_PI;
	          break;
	        }
	        lam = (y === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ)) ? 0 : Math.atan2(x, y);
	      }
	      else {
	        ab = 0;
	        if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
	          x /= this.dd;
	          y *= this.dd;
	          rho = Math.sqrt(x * x + y * y);
	          if (rho < EPSLN) {
	            p.x = 0;
	            p.y = this.phi0;
	            return p;
	          }
	          sCe = 2 * Math.asin(0.5 * rho / this.rq);
	          cCe = Math.cos(sCe);
	          x *= (sCe = Math.sin(sCe));
	          if (this.mode === this.OBLIQ) {
	            ab = cCe * this.sinb1 + y * sCe * this.cosb1 / rho;
	            q = this.qp * ab;
	            y = rho * this.cosb1 * cCe - y * this.sinb1 * sCe;
	          }
	          else {
	            ab = y * sCe / rho;
	            q = this.qp * ab;
	            y = rho * cCe;
	          }
	        }
	        else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
	          if (this.mode === this.N_POLE) {
	            y = -y;
	          }
	          q = (x * x + y * y);
	          if (!q) {
	            p.x = 0;
	            p.y = this.phi0;
	            return p;
	          }
	          ab = 1 - q / this.qp;
	          if (this.mode === this.S_POLE) {
	            ab = -ab;
	          }
	        }
	        lam = Math.atan2(x, y);
	        phi = authlat(Math.asin(ab), this.apa);
	      }

	      p.x = adjust_lon(this.long0 + lam);
	      p.y = phi;
	      return p;
	    }

	    /* determine latitude from authalic latitude */
	    var P00 = 0.33333333333333333333;

	    var P01 = 0.17222222222222222222;
	    var P02 = 0.10257936507936507936;
	    var P10 = 0.06388888888888888888;
	    var P11 = 0.06640211640211640211;
	    var P20 = 0.01641501294219154443;

	    function authset(es) {
	      var t;
	      var APA = [];
	      APA[0] = es * P00;
	      t = es * es;
	      APA[0] += t * P01;
	      APA[1] = t * P10;
	      t *= es;
	      APA[0] += t * P02;
	      APA[1] += t * P11;
	      APA[2] = t * P20;
	      return APA;
	    }

	    function authlat(beta, APA) {
	      var t = beta + beta;
	      return (beta + APA[0] * Math.sin(t) + APA[1] * Math.sin(t + t) + APA[2] * Math.sin(t + t + t));
	    }

	    var names$14 = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];
	    var laea = {
	      init: init$13,
	      forward: forward$12,
	      inverse: inverse$12,
	      names: names$14,
	      S_POLE: S_POLE,
	      N_POLE: N_POLE,
	      EQUIT: EQUIT,
	      OBLIQ: OBLIQ
	    };

	    var asinz = function(x) {
	      if (Math.abs(x) > 1) {
	        x = (x > 1) ? 1 : -1;
	      }
	      return Math.asin(x);
	    };

	    function init$14() {

	      if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
	        return;
	      }
	      this.temp = this.b / this.a;
	      this.es = 1 - Math.pow(this.temp, 2);
	      this.e3 = Math.sqrt(this.es);

	      this.sin_po = Math.sin(this.lat1);
	      this.cos_po = Math.cos(this.lat1);
	      this.t1 = this.sin_po;
	      this.con = this.sin_po;
	      this.ms1 = msfnz(this.e3, this.sin_po, this.cos_po);
	      this.qs1 = qsfnz(this.e3, this.sin_po, this.cos_po);

	      this.sin_po = Math.sin(this.lat2);
	      this.cos_po = Math.cos(this.lat2);
	      this.t2 = this.sin_po;
	      this.ms2 = msfnz(this.e3, this.sin_po, this.cos_po);
	      this.qs2 = qsfnz(this.e3, this.sin_po, this.cos_po);

	      this.sin_po = Math.sin(this.lat0);
	      this.cos_po = Math.cos(this.lat0);
	      this.t3 = this.sin_po;
	      this.qs0 = qsfnz(this.e3, this.sin_po, this.cos_po);

	      if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
	        this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1);
	      }
	      else {
	        this.ns0 = this.con;
	      }
	      this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1;
	      this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0;
	    }

	    /* Albers Conical Equal Area forward equations--mapping lat,long to x,y
	      -------------------------------------------------------------------*/
	    function forward$13(p) {

	      var lon = p.x;
	      var lat = p.y;

	      this.sin_phi = Math.sin(lat);
	      this.cos_phi = Math.cos(lat);

	      var qs = qsfnz(this.e3, this.sin_phi, this.cos_phi);
	      var rh1 = this.a * Math.sqrt(this.c - this.ns0 * qs) / this.ns0;
	      var theta = this.ns0 * adjust_lon(lon - this.long0);
	      var x = rh1 * Math.sin(theta) + this.x0;
	      var y = this.rh - rh1 * Math.cos(theta) + this.y0;

	      p.x = x;
	      p.y = y;
	      return p;
	    }

	    function inverse$13(p) {
	      var rh1, qs, con, theta, lon, lat;

	      p.x -= this.x0;
	      p.y = this.rh - p.y + this.y0;
	      if (this.ns0 >= 0) {
	        rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
	        con = 1;
	      }
	      else {
	        rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
	        con = -1;
	      }
	      theta = 0;
	      if (rh1 !== 0) {
	        theta = Math.atan2(con * p.x, con * p.y);
	      }
	      con = rh1 * this.ns0 / this.a;
	      if (this.sphere) {
	        lat = Math.asin((this.c - con * con) / (2 * this.ns0));
	      }
	      else {
	        qs = (this.c - con * con) / this.ns0;
	        lat = this.phi1z(this.e3, qs);
	      }

	      lon = adjust_lon(theta / this.ns0 + this.long0);
	      p.x = lon;
	      p.y = lat;
	      return p;
	    }

	    /* Function to compute phi1, the latitude for the inverse of the
	       Albers Conical Equal-Area projection.
	    -------------------------------------------*/
	    function phi1z(eccent, qs) {
	      var sinphi, cosphi, con, com, dphi;
	      var phi = asinz(0.5 * qs);
	      if (eccent < EPSLN) {
	        return phi;
	      }

	      var eccnts = eccent * eccent;
	      for (var i = 1; i <= 25; i++) {
	        sinphi = Math.sin(phi);
	        cosphi = Math.cos(phi);
	        con = eccent * sinphi;
	        com = 1 - con * con;
	        dphi = 0.5 * com * com / cosphi * (qs / (1 - eccnts) - sinphi / com + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
	        phi = phi + dphi;
	        if (Math.abs(dphi) <= 1e-7) {
	          return phi;
	        }
	      }
	      return null;
	    }

	    var names$15 = ["Albers_Conic_Equal_Area", "Albers", "aea"];
	    var aea = {
	      init: init$14,
	      forward: forward$13,
	      inverse: inverse$13,
	      names: names$15,
	      phi1z: phi1z
	    };

	    /*
	      reference:
	        Wolfram Mathworld "Gnomonic Projection"
	        http://mathworld.wolfram.com/GnomonicProjection.html
	        Accessed: 12th November 2009
	      */
	    function init$15() {

	      /* Place parameters in static storage for common use
	          -------------------------------------------------*/
	      this.sin_p14 = Math.sin(this.lat0);
	      this.cos_p14 = Math.cos(this.lat0);
	      // Approximation for projecting points to the horizon (infinity)
	      this.infinity_dist = 1000 * this.a;
	      this.rc = 1;
	    }

	    /* Gnomonic forward equations--mapping lat,long to x,y
	        ---------------------------------------------------*/
	    function forward$14(p) {
	      var sinphi, cosphi; /* sin and cos value        */
	      var dlon; /* delta longitude value      */
	      var coslon; /* cos of longitude        */
	      var ksp; /* scale factor          */
	      var g;
	      var x, y;
	      var lon = p.x;
	      var lat = p.y;
	      /* Forward equations
	          -----------------*/
	      dlon = adjust_lon(lon - this.long0);

	      sinphi = Math.sin(lat);
	      cosphi = Math.cos(lat);

	      coslon = Math.cos(dlon);
	      g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
	      ksp = 1;
	      if ((g > 0) || (Math.abs(g) <= EPSLN)) {
	        x = this.x0 + this.a * ksp * cosphi * Math.sin(dlon) / g;
	        y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon) / g;
	      }
	      else {

	        // Point is in the opposing hemisphere and is unprojectable
	        // We still need to return a reasonable point, so we project
	        // to infinity, on a bearing
	        // equivalent to the northern hemisphere equivalent
	        // This is a reasonable approximation for short shapes and lines that
	        // straddle the horizon.

	        x = this.x0 + this.infinity_dist * cosphi * Math.sin(dlon);
	        y = this.y0 + this.infinity_dist * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);

	      }
	      p.x = x;
	      p.y = y;
	      return p;
	    }

	    function inverse$14(p) {
	      var rh; /* Rho */
	      var sinc, cosc;
	      var c;
	      var lon, lat;

	      /* Inverse equations
	          -----------------*/
	      p.x = (p.x - this.x0) / this.a;
	      p.y = (p.y - this.y0) / this.a;

	      p.x /= this.k0;
	      p.y /= this.k0;

	      if ((rh = Math.sqrt(p.x * p.x + p.y * p.y))) {
	        c = Math.atan2(rh, this.rc);
	        sinc = Math.sin(c);
	        cosc = Math.cos(c);

	        lat = asinz(cosc * this.sin_p14 + (p.y * sinc * this.cos_p14) / rh);
	        lon = Math.atan2(p.x * sinc, rh * this.cos_p14 * cosc - p.y * this.sin_p14 * sinc);
	        lon = adjust_lon(this.long0 + lon);
	      }
	      else {
	        lat = this.phic0;
	        lon = 0;
	      }

	      p.x = lon;
	      p.y = lat;
	      return p;
	    }

	    var names$16 = ["gnom"];
	    var gnom = {
	      init: init$15,
	      forward: forward$14,
	      inverse: inverse$14,
	      names: names$16
	    };

	    var iqsfnz = function(eccent, q) {
	      var temp = 1 - (1 - eccent * eccent) / (2 * eccent) * Math.log((1 - eccent) / (1 + eccent));
	      if (Math.abs(Math.abs(q) - temp) < 1.0E-6) {
	        if (q < 0) {
	          return (-1 * HALF_PI);
	        }
	        else {
	          return HALF_PI;
	        }
	      }
	      //var phi = 0.5* q/(1-eccent*eccent);
	      var phi = Math.asin(0.5 * q);
	      var dphi;
	      var sin_phi;
	      var cos_phi;
	      var con;
	      for (var i = 0; i < 30; i++) {
	        sin_phi = Math.sin(phi);
	        cos_phi = Math.cos(phi);
	        con = eccent * sin_phi;
	        dphi = Math.pow(1 - con * con, 2) / (2 * cos_phi) * (q / (1 - eccent * eccent) - sin_phi / (1 - con * con) + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
	        phi += dphi;
	        if (Math.abs(dphi) <= 0.0000000001) {
	          return phi;
	        }
	      }

	      //console.log("IQSFN-CONV:Latitude failed to converge after 30 iterations");
	      return NaN;
	    };

	    /*
	      reference:
	        "Cartographic Projection Procedures for the UNIX Environment-
	        A User's Manual" by Gerald I. Evenden,
	        USGS Open File Report 90-284and Release 4 Interim Reports (2003)
	    */
	    function init$16() {
	      //no-op
	      if (!this.sphere) {
	        this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
	      }
	    }

	    /* Cylindrical Equal Area forward equations--mapping lat,long to x,y
	        ------------------------------------------------------------*/
	    function forward$15(p) {
	      var lon = p.x;
	      var lat = p.y;
	      var x, y;
	      /* Forward equations
	          -----------------*/
	      var dlon = adjust_lon(lon - this.long0);
	      if (this.sphere) {
	        x = this.x0 + this.a * dlon * Math.cos(this.lat_ts);
	        y = this.y0 + this.a * Math.sin(lat) / Math.cos(this.lat_ts);
	      }
	      else {
	        var qs = qsfnz(this.e, Math.sin(lat));
	        x = this.x0 + this.a * this.k0 * dlon;
	        y = this.y0 + this.a * qs * 0.5 / this.k0;
	      }

	      p.x = x;
	      p.y = y;
	      return p;
	    }

	    /* Cylindrical Equal Area inverse equations--mapping x,y to lat/long
	        ------------------------------------------------------------*/
	    function inverse$15(p) {
	      p.x -= this.x0;
	      p.y -= this.y0;
	      var lon, lat;

	      if (this.sphere) {
	        lon = adjust_lon(this.long0 + (p.x / this.a) / Math.cos(this.lat_ts));
	        lat = Math.asin((p.y / this.a) * Math.cos(this.lat_ts));
	      }
	      else {
	        lat = iqsfnz(this.e, 2 * p.y * this.k0 / this.a);
	        lon = adjust_lon(this.long0 + p.x / (this.a * this.k0));
	      }

	      p.x = lon;
	      p.y = lat;
	      return p;
	    }

	    var names$17 = ["cea"];
	    var cea = {
	      init: init$16,
	      forward: forward$15,
	      inverse: inverse$15,
	      names: names$17
	    };

	    function init$17() {

	      this.x0 = this.x0 || 0;
	      this.y0 = this.y0 || 0;
	      this.lat0 = this.lat0 || 0;
	      this.long0 = this.long0 || 0;
	      this.lat_ts = this.lat_ts || 0;
	      this.title = this.title || "Equidistant Cylindrical (Plate Carre)";

	      this.rc = Math.cos(this.lat_ts);
	    }

	    // forward equations--mapping lat,long to x,y
	    // -----------------------------------------------------------------
	    function forward$16(p) {

	      var lon = p.x;
	      var lat = p.y;

	      var dlon = adjust_lon(lon - this.long0);
	      var dlat = adjust_lat(lat - this.lat0);
	      p.x = this.x0 + (this.a * dlon * this.rc);
	      p.y = this.y0 + (this.a * dlat);
	      return p;
	    }

	    // inverse equations--mapping x,y to lat/long
	    // -----------------------------------------------------------------
	    function inverse$16(p) {

	      var x = p.x;
	      var y = p.y;

	      p.x = adjust_lon(this.long0 + ((x - this.x0) / (this.a * this.rc)));
	      p.y = adjust_lat(this.lat0 + ((y - this.y0) / (this.a)));
	      return p;
	    }

	    var names$18 = ["Equirectangular", "Equidistant_Cylindrical", "eqc"];
	    var eqc = {
	      init: init$17,
	      forward: forward$16,
	      inverse: inverse$16,
	      names: names$18
	    };

	    var MAX_ITER$2 = 20;

	    function init$18() {
	      /* Place parameters in static storage for common use
	          -------------------------------------------------*/
	      this.temp = this.b / this.a;
	      this.es = 1 - Math.pow(this.temp, 2); // devait etre dans tmerc.js mais n y est pas donc je commente sinon retour de valeurs nulles
	      this.e = Math.sqrt(this.es);
	      this.e0 = e0fn(this.es);
	      this.e1 = e1fn(this.es);
	      this.e2 = e2fn(this.es);
	      this.e3 = e3fn(this.es);
	      this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0); //si que des zeros le calcul ne se fait pas
	    }

	    /* Polyconic forward equations--mapping lat,long to x,y
	        ---------------------------------------------------*/
	    function forward$17(p) {
	      var lon = p.x;
	      var lat = p.y;
	      var x, y, el;
	      var dlon = adjust_lon(lon - this.long0);
	      el = dlon * Math.sin(lat);
	      if (this.sphere) {
	        if (Math.abs(lat) <= EPSLN) {
	          x = this.a * dlon;
	          y = -1 * this.a * this.lat0;
	        }
	        else {
	          x = this.a * Math.sin(el) / Math.tan(lat);
	          y = this.a * (adjust_lat(lat - this.lat0) + (1 - Math.cos(el)) / Math.tan(lat));
	        }
	      }
	      else {
	        if (Math.abs(lat) <= EPSLN) {
	          x = this.a * dlon;
	          y = -1 * this.ml0;
	        }
	        else {
	          var nl = gN(this.a, this.e, Math.sin(lat)) / Math.tan(lat);
	          x = nl * Math.sin(el);
	          y = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, lat) - this.ml0 + nl * (1 - Math.cos(el));
	        }

	      }
	      p.x = x + this.x0;
	      p.y = y + this.y0;
	      return p;
	    }

	    /* Inverse equations
	      -----------------*/
	    function inverse$17(p) {
	      var lon, lat, x, y, i;
	      var al, bl;
	      var phi, dphi;
	      x = p.x - this.x0;
	      y = p.y - this.y0;

	      if (this.sphere) {
	        if (Math.abs(y + this.a * this.lat0) <= EPSLN) {
	          lon = adjust_lon(x / this.a + this.long0);
	          lat = 0;
	        }
	        else {
	          al = this.lat0 + y / this.a;
	          bl = x * x / this.a / this.a + al * al;
	          phi = al;
	          var tanphi;
	          for (i = MAX_ITER$2; i; --i) {
	            tanphi = Math.tan(phi);
	            dphi = -1 * (al * (phi * tanphi + 1) - phi - 0.5 * (phi * phi + bl) * tanphi) / ((phi - al) / tanphi - 1);
	            phi += dphi;
	            if (Math.abs(dphi) <= EPSLN) {
	              lat = phi;
	              break;
	            }
	          }
	          lon = adjust_lon(this.long0 + (Math.asin(x * Math.tan(phi) / this.a)) / Math.sin(lat));
	        }
	      }
	      else {
	        if (Math.abs(y + this.ml0) <= EPSLN) {
	          lat = 0;
	          lon = adjust_lon(this.long0 + x / this.a);
	        }
	        else {

	          al = (this.ml0 + y) / this.a;
	          bl = x * x / this.a / this.a + al * al;
	          phi = al;
	          var cl, mln, mlnp, ma;
	          var con;
	          for (i = MAX_ITER$2; i; --i) {
	            con = this.e * Math.sin(phi);
	            cl = Math.sqrt(1 - con * con) * Math.tan(phi);
	            mln = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);
	            mlnp = this.e0 - 2 * this.e1 * Math.cos(2 * phi) + 4 * this.e2 * Math.cos(4 * phi) - 6 * this.e3 * Math.cos(6 * phi);
	            ma = mln / this.a;
	            dphi = (al * (cl * ma + 1) - ma - 0.5 * cl * (ma * ma + bl)) / (this.es * Math.sin(2 * phi) * (ma * ma + bl - 2 * al * ma) / (4 * cl) + (al - ma) * (cl * mlnp - 2 / Math.sin(2 * phi)) - mlnp);
	            phi -= dphi;
	            if (Math.abs(dphi) <= EPSLN) {
	              lat = phi;
	              break;
	            }
	          }

	          //lat=phi4z(this.e,this.e0,this.e1,this.e2,this.e3,al,bl,0,0);
	          cl = Math.sqrt(1 - this.es * Math.pow(Math.sin(lat), 2)) * Math.tan(lat);
	          lon = adjust_lon(this.long0 + Math.asin(x * cl / this.a) / Math.sin(lat));
	        }
	      }

	      p.x = lon;
	      p.y = lat;
	      return p;
	    }

	    var names$19 = ["Polyconic", "poly"];
	    var poly = {
	      init: init$18,
	      forward: forward$17,
	      inverse: inverse$17,
	      names: names$19
	    };

	    /*
	      reference
	        Department of Land and Survey Technical Circular 1973/32
	          http://www.linz.govt.nz/docs/miscellaneous/nz-map-definition.pdf
	        OSG Technical Report 4.1
	          http://www.linz.govt.nz/docs/miscellaneous/nzmg.pdf
	      */

	    /**
	     * iterations: Number of iterations to refine inverse transform.
	     *     0 -> km accuracy
	     *     1 -> m accuracy -- suitable for most mapping applications
	     *     2 -> mm accuracy
	     */


	    function init$19() {
	      this.A = [];
	      this.A[1] = 0.6399175073;
	      this.A[2] = -0.1358797613;
	      this.A[3] = 0.063294409;
	      this.A[4] = -0.02526853;
	      this.A[5] = 0.0117879;
	      this.A[6] = -0.0055161;
	      this.A[7] = 0.0026906;
	      this.A[8] = -0.001333;
	      this.A[9] = 0.00067;
	      this.A[10] = -0.00034;

	      this.B_re = [];
	      this.B_im = [];
	      this.B_re[1] = 0.7557853228;
	      this.B_im[1] = 0;
	      this.B_re[2] = 0.249204646;
	      this.B_im[2] = 0.003371507;
	      this.B_re[3] = -0.001541739;
	      this.B_im[3] = 0.041058560;
	      this.B_re[4] = -0.10162907;
	      this.B_im[4] = 0.01727609;
	      this.B_re[5] = -0.26623489;
	      this.B_im[5] = -0.36249218;
	      this.B_re[6] = -0.6870983;
	      this.B_im[6] = -1.1651967;

	      this.C_re = [];
	      this.C_im = [];
	      this.C_re[1] = 1.3231270439;
	      this.C_im[1] = 0;
	      this.C_re[2] = -0.577245789;
	      this.C_im[2] = -0.007809598;
	      this.C_re[3] = 0.508307513;
	      this.C_im[3] = -0.112208952;
	      this.C_re[4] = -0.15094762;
	      this.C_im[4] = 0.18200602;
	      this.C_re[5] = 1.01418179;
	      this.C_im[5] = 1.64497696;
	      this.C_re[6] = 1.9660549;
	      this.C_im[6] = 2.5127645;

	      this.D = [];
	      this.D[1] = 1.5627014243;
	      this.D[2] = 0.5185406398;
	      this.D[3] = -0.03333098;
	      this.D[4] = -0.1052906;
	      this.D[5] = -0.0368594;
	      this.D[6] = 0.007317;
	      this.D[7] = 0.01220;
	      this.D[8] = 0.00394;
	      this.D[9] = -0.0013;
	    }

	    /**
	        New Zealand Map Grid Forward  - long/lat to x/y
	        long/lat in radians
	      */
	    function forward$18(p) {
	      var n;
	      var lon = p.x;
	      var lat = p.y;

	      var delta_lat = lat - this.lat0;
	      var delta_lon = lon - this.long0;

	      // 1. Calculate d_phi and d_psi    ...                          // and d_lambda
	      // For this algorithm, delta_latitude is in seconds of arc x 10-5, so we need to scale to those units. Longitude is radians.
	      var d_phi = delta_lat / SEC_TO_RAD * 1E-5;
	      var d_lambda = delta_lon;
	      var d_phi_n = 1; // d_phi^0

	      var d_psi = 0;
	      for (n = 1; n <= 10; n++) {
	        d_phi_n = d_phi_n * d_phi;
	        d_psi = d_psi + this.A[n] * d_phi_n;
	      }

	      // 2. Calculate theta
	      var th_re = d_psi;
	      var th_im = d_lambda;

	      // 3. Calculate z
	      var th_n_re = 1;
	      var th_n_im = 0; // theta^0
	      var th_n_re1;
	      var th_n_im1;

	      var z_re = 0;
	      var z_im = 0;
	      for (n = 1; n <= 6; n++) {
	        th_n_re1 = th_n_re * th_re - th_n_im * th_im;
	        th_n_im1 = th_n_im * th_re + th_n_re * th_im;
	        th_n_re = th_n_re1;
	        th_n_im = th_n_im1;
	        z_re = z_re + this.B_re[n] * th_n_re - this.B_im[n] * th_n_im;
	        z_im = z_im + this.B_im[n] * th_n_re + this.B_re[n] * th_n_im;
	      }

	      // 4. Calculate easting and northing
	      p.x = (z_im * this.a) + this.x0;
	      p.y = (z_re * this.a) + this.y0;

	      return p;
	    }

	    /**
	        New Zealand Map Grid Inverse  -  x/y to long/lat
	      */
	    function inverse$18(p) {
	      var n;
	      var x = p.x;
	      var y = p.y;

	      var delta_x = x - this.x0;
	      var delta_y = y - this.y0;

	      // 1. Calculate z
	      var z_re = delta_y / this.a;
	      var z_im = delta_x / this.a;

	      // 2a. Calculate theta - first approximation gives km accuracy
	      var z_n_re = 1;
	      var z_n_im = 0; // z^0
	      var z_n_re1;
	      var z_n_im1;

	      var th_re = 0;
	      var th_im = 0;
	      for (n = 1; n <= 6; n++) {
	        z_n_re1 = z_n_re * z_re - z_n_im * z_im;
	        z_n_im1 = z_n_im * z_re + z_n_re * z_im;
	        z_n_re = z_n_re1;
	        z_n_im = z_n_im1;
	        th_re = th_re + this.C_re[n] * z_n_re - this.C_im[n] * z_n_im;
	        th_im = th_im + this.C_im[n] * z_n_re + this.C_re[n] * z_n_im;
	      }

	      // 2b. Iterate to refine the accuracy of the calculation
	      //        0 iterations gives km accuracy
	      //        1 iteration gives m accuracy -- good enough for most mapping applications
	      //        2 iterations bives mm accuracy
	      for (var i = 0; i < this.iterations; i++) {
	        var th_n_re = th_re;
	        var th_n_im = th_im;
	        var th_n_re1;
	        var th_n_im1;

	        var num_re = z_re;
	        var num_im = z_im;
	        for (n = 2; n <= 6; n++) {
	          th_n_re1 = th_n_re * th_re - th_n_im * th_im;
	          th_n_im1 = th_n_im * th_re + th_n_re * th_im;
	          th_n_re = th_n_re1;
	          th_n_im = th_n_im1;
	          num_re = num_re + (n - 1) * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
	          num_im = num_im + (n - 1) * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
	        }

	        th_n_re = 1;
	        th_n_im = 0;
	        var den_re = this.B_re[1];
	        var den_im = this.B_im[1];
	        for (n = 2; n <= 6; n++) {
	          th_n_re1 = th_n_re * th_re - th_n_im * th_im;
	          th_n_im1 = th_n_im * th_re + th_n_re * th_im;
	          th_n_re = th_n_re1;
	          th_n_im = th_n_im1;
	          den_re = den_re + n * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
	          den_im = den_im + n * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
	        }

	        // Complex division
	        var den2 = den_re * den_re + den_im * den_im;
	        th_re = (num_re * den_re + num_im * den_im) / den2;
	        th_im = (num_im * den_re - num_re * den_im) / den2;
	      }

	      // 3. Calculate d_phi              ...                                    // and d_lambda
	      var d_psi = th_re;
	      var d_lambda = th_im;
	      var d_psi_n = 1; // d_psi^0

	      var d_phi = 0;
	      for (n = 1; n <= 9; n++) {
	        d_psi_n = d_psi_n * d_psi;
	        d_phi = d_phi + this.D[n] * d_psi_n;
	      }

	      // 4. Calculate latitude and longitude
	      // d_phi is calcuated in second of arc * 10^-5, so we need to scale back to radians. d_lambda is in radians.
	      var lat = this.lat0 + (d_phi * SEC_TO_RAD * 1E5);
	      var lon = this.long0 + d_lambda;

	      p.x = lon;
	      p.y = lat;

	      return p;
	    }

	    var names$20 = ["New_Zealand_Map_Grid", "nzmg"];
	    var nzmg = {
	      init: init$19,
	      forward: forward$18,
	      inverse: inverse$18,
	      names: names$20
	    };

	    /*
	      reference
	        "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
	        The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
	      */


	    /* Initialize the Miller Cylindrical projection
	      -------------------------------------------*/
	    function init$20() {
	      //no-op
	    }

	    /* Miller Cylindrical forward equations--mapping lat,long to x,y
	        ------------------------------------------------------------*/
	    function forward$19(p) {
	      var lon = p.x;
	      var lat = p.y;
	      /* Forward equations
	          -----------------*/
	      var dlon = adjust_lon(lon - this.long0);
	      var x = this.x0 + this.a * dlon;
	      var y = this.y0 + this.a * Math.log(Math.tan((Math.PI / 4) + (lat / 2.5))) * 1.25;

	      p.x = x;
	      p.y = y;
	      return p;
	    }

	    /* Miller Cylindrical inverse equations--mapping x,y to lat/long
	        ------------------------------------------------------------*/
	    function inverse$19(p) {
	      p.x -= this.x0;
	      p.y -= this.y0;

	      var lon = adjust_lon(this.long0 + p.x / this.a);
	      var lat = 2.5 * (Math.atan(Math.exp(0.8 * p.y / this.a)) - Math.PI / 4);

	      p.x = lon;
	      p.y = lat;
	      return p;
	    }

	    var names$21 = ["Miller_Cylindrical", "mill"];
	    var mill = {
	      init: init$20,
	      forward: forward$19,
	      inverse: inverse$19,
	      names: names$21
	    };

	    var MAX_ITER$3 = 20;
	    function init$21() {
	      /* Place parameters in static storage for common use
	        -------------------------------------------------*/


	      if (!this.sphere) {
	        this.en = pj_enfn(this.es);
	      }
	      else {
	        this.n = 1;
	        this.m = 0;
	        this.es = 0;
	        this.C_y = Math.sqrt((this.m + 1) / this.n);
	        this.C_x = this.C_y / (this.m + 1);
	      }

	    }

	    /* Sinusoidal forward equations--mapping lat,long to x,y
	      -----------------------------------------------------*/
	    function forward$20(p) {
	      var x, y;
	      var lon = p.x;
	      var lat = p.y;
	      /* Forward equations
	        -----------------*/
	      lon = adjust_lon(lon - this.long0);

	      if (this.sphere) {
	        if (!this.m) {
	          lat = this.n !== 1 ? Math.asin(this.n * Math.sin(lat)) : lat;
	        }
	        else {
	          var k = this.n * Math.sin(lat);
	          for (var i = MAX_ITER$3; i; --i) {
	            var V = (this.m * lat + Math.sin(lat) - k) / (this.m + Math.cos(lat));
	            lat -= V;
	            if (Math.abs(V) < EPSLN) {
	              break;
	            }
	          }
	        }
	        x = this.a * this.C_x * lon * (this.m + Math.cos(lat));
	        y = this.a * this.C_y * lat;

	      }
	      else {

	        var s = Math.sin(lat);
	        var c = Math.cos(lat);
	        y = this.a * pj_mlfn(lat, s, c, this.en);
	        x = this.a * lon * c / Math.sqrt(1 - this.es * s * s);
	      }

	      p.x = x;
	      p.y = y;
	      return p;
	    }

	    function inverse$20(p) {
	      var lat, temp, lon, s;

	      p.x -= this.x0;
	      lon = p.x / this.a;
	      p.y -= this.y0;
	      lat = p.y / this.a;

	      if (this.sphere) {
	        lat /= this.C_y;
	        lon = lon / (this.C_x * (this.m + Math.cos(lat)));
	        if (this.m) {
	          lat = asinz((this.m * lat + Math.sin(lat)) / this.n);
	        }
	        else if (this.n !== 1) {
	          lat = asinz(Math.sin(lat) / this.n);
	        }
	        lon = adjust_lon(lon + this.long0);
	        lat = adjust_lat(lat);
	      }
	      else {
	        lat = pj_inv_mlfn(p.y / this.a, this.es, this.en);
	        s = Math.abs(lat);
	        if (s < HALF_PI) {
	          s = Math.sin(lat);
	          temp = this.long0 + p.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(lat));
	          //temp = this.long0 + p.x / (this.a * Math.cos(lat));
	          lon = adjust_lon(temp);
	        }
	        else if ((s - EPSLN) < HALF_PI) {
	          lon = this.long0;
	        }
	      }
	      p.x = lon;
	      p.y = lat;
	      return p;
	    }

	    var names$22 = ["Sinusoidal", "sinu"];
	    var sinu = {
	      init: init$21,
	      forward: forward$20,
	      inverse: inverse$20,
	      names: names$22
	    };

	    function init$22() {}
	    /* Mollweide forward equations--mapping lat,long to x,y
	        ----------------------------------------------------*/
	    function forward$21(p) {

	      /* Forward equations
	          -----------------*/
	      var lon = p.x;
	      var lat = p.y;

	      var delta_lon = adjust_lon(lon - this.long0);
	      var theta = lat;
	      var con = Math.PI * Math.sin(lat);

	      /* Iterate using the Newton-Raphson method to find theta
	          -----------------------------------------------------*/
	      while (true) {
	        var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));
	        theta += delta_theta;
	        if (Math.abs(delta_theta) < EPSLN) {
	          break;
	        }
	      }
	      theta /= 2;

	      /* If the latitude is 90 deg, force the x coordinate to be "0 + false easting"
	           this is done here because of precision problems with "cos(theta)"
	           --------------------------------------------------------------------------*/
	      if (Math.PI / 2 - Math.abs(lat) < EPSLN) {
	        delta_lon = 0;
	      }
	      var x = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;
	      var y = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;

	      p.x = x;
	      p.y = y;
	      return p;
	    }

	    function inverse$21(p) {
	      var theta;
	      var arg;

	      /* Inverse equations
	          -----------------*/
	      p.x -= this.x0;
	      p.y -= this.y0;
	      arg = p.y / (1.4142135623731 * this.a);

	      /* Because of division by zero problems, 'arg' can not be 1.  Therefore
	           a number very close to one is used instead.
	           -------------------------------------------------------------------*/
	      if (Math.abs(arg) > 0.999999999999) {
	        arg = 0.999999999999;
	      }
	      theta = Math.asin(arg);
	      var lon = adjust_lon(this.long0 + (p.x / (0.900316316158 * this.a * Math.cos(theta))));
	      if (lon < (-Math.PI)) {
	        lon = -Math.PI;
	      }
	      if (lon > Math.PI) {
	        lon = Math.PI;
	      }
	      arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;
	      if (Math.abs(arg) > 1) {
	        arg = 1;
	      }
	      var lat = Math.asin(arg);

	      p.x = lon;
	      p.y = lat;
	      return p;
	    }

	    var names$23 = ["Mollweide", "moll"];
	    var moll = {
	      init: init$22,
	      forward: forward$21,
	      inverse: inverse$21,
	      names: names$23
	    };

	    function init$23() {

	      /* Place parameters in static storage for common use
	          -------------------------------------------------*/
	      // Standard Parallels cannot be equal and on opposite sides of the equator
	      if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
	        return;
	      }
	      this.lat2 = this.lat2 || this.lat1;
	      this.temp = this.b / this.a;
	      this.es = 1 - Math.pow(this.temp, 2);
	      this.e = Math.sqrt(this.es);
	      this.e0 = e0fn(this.es);
	      this.e1 = e1fn(this.es);
	      this.e2 = e2fn(this.es);
	      this.e3 = e3fn(this.es);

	      this.sinphi = Math.sin(this.lat1);
	      this.cosphi = Math.cos(this.lat1);

	      this.ms1 = msfnz(this.e, this.sinphi, this.cosphi);
	      this.ml1 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat1);

	      if (Math.abs(this.lat1 - this.lat2) < EPSLN) {
	        this.ns = this.sinphi;
	      }
	      else {
	        this.sinphi = Math.sin(this.lat2);
	        this.cosphi = Math.cos(this.lat2);
	        this.ms2 = msfnz(this.e, this.sinphi, this.cosphi);
	        this.ml2 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat2);
	        this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1);
	      }
	      this.g = this.ml1 + this.ms1 / this.ns;
	      this.ml0 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
	      this.rh = this.a * (this.g - this.ml0);
	    }

	    /* Equidistant Conic forward equations--mapping lat,long to x,y
	      -----------------------------------------------------------*/
	    function forward$22(p) {
	      var lon = p.x;
	      var lat = p.y;
	      var rh1;

	      /* Forward equations
	          -----------------*/
	      if (this.sphere) {
	        rh1 = this.a * (this.g - lat);
	      }
	      else {
	        var ml = mlfn(this.e0, this.e1, this.e2, this.e3, lat);
	        rh1 = this.a * (this.g - ml);
	      }
	      var theta = this.ns * adjust_lon(lon - this.long0);
	      var x = this.x0 + rh1 * Math.sin(theta);
	      var y = this.y0 + this.rh - rh1 * Math.cos(theta);
	      p.x = x;
	      p.y = y;
	      return p;
	    }

	    /* Inverse equations
	      -----------------*/
	    function inverse$22(p) {
	      p.x -= this.x0;
	      p.y = this.rh - p.y + this.y0;
	      var con, rh1, lat, lon;
	      if (this.ns >= 0) {
	        rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
	        con = 1;
	      }
	      else {
	        rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
	        con = -1;
	      }
	      var theta = 0;
	      if (rh1 !== 0) {
	        theta = Math.atan2(con * p.x, con * p.y);
	      }

	      if (this.sphere) {
	        lon = adjust_lon(this.long0 + theta / this.ns);
	        lat = adjust_lat(this.g - rh1 / this.a);
	        p.x = lon;
	        p.y = lat;
	        return p;
	      }
	      else {
	        var ml = this.g - rh1 / this.a;
	        lat = imlfn(ml, this.e0, this.e1, this.e2, this.e3);
	        lon = adjust_lon(this.long0 + theta / this.ns);
	        p.x = lon;
	        p.y = lat;
	        return p;
	      }

	    }

	    var names$24 = ["Equidistant_Conic", "eqdc"];
	    var eqdc = {
	      init: init$23,
	      forward: forward$22,
	      inverse: inverse$22,
	      names: names$24
	    };

	    /* Initialize the Van Der Grinten projection
	      ----------------------------------------*/
	    function init$24() {
	      //this.R = 6370997; //Radius of earth
	      this.R = this.a;
	    }

	    function forward$23(p) {

	      var lon = p.x;
	      var lat = p.y;

	      /* Forward equations
	        -----------------*/
	      var dlon = adjust_lon(lon - this.long0);
	      var x, y;

	      if (Math.abs(lat) <= EPSLN) {
	        x = this.x0 + this.R * dlon;
	        y = this.y0;
	      }
	      var theta = asinz(2 * Math.abs(lat / Math.PI));
	      if ((Math.abs(dlon) <= EPSLN) || (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN)) {
	        x = this.x0;
	        if (lat >= 0) {
	          y = this.y0 + Math.PI * this.R * Math.tan(0.5 * theta);
	        }
	        else {
	          y = this.y0 + Math.PI * this.R * -Math.tan(0.5 * theta);
	        }
	        //  return(OK);
	      }
	      var al = 0.5 * Math.abs((Math.PI / dlon) - (dlon / Math.PI));
	      var asq = al * al;
	      var sinth = Math.sin(theta);
	      var costh = Math.cos(theta);

	      var g = costh / (sinth + costh - 1);
	      var gsq = g * g;
	      var m = g * (2 / sinth - 1);
	      var msq = m * m;
	      var con = Math.PI * this.R * (al * (g - msq) + Math.sqrt(asq * (g - msq) * (g - msq) - (msq + asq) * (gsq - msq))) / (msq + asq);
	      if (dlon < 0) {
	        con = -con;
	      }
	      x = this.x0 + con;
	      //con = Math.abs(con / (Math.PI * this.R));
	      var q = asq + g;
	      con = Math.PI * this.R * (m * q - al * Math.sqrt((msq + asq) * (asq + 1) - q * q)) / (msq + asq);
	      if (lat >= 0) {
	        //y = this.y0 + Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
	        y = this.y0 + con;
	      }
	      else {
	        //y = this.y0 - Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
	        y = this.y0 - con;
	      }
	      p.x = x;
	      p.y = y;
	      return p;
	    }

	    /* Van Der Grinten inverse equations--mapping x,y to lat/long
	      ---------------------------------------------------------*/
	    function inverse$23(p) {
	      var lon, lat;
	      var xx, yy, xys, c1, c2, c3;
	      var a1;
	      var m1;
	      var con;
	      var th1;
	      var d;

	      /* inverse equations
	        -----------------*/
	      p.x -= this.x0;
	      p.y -= this.y0;
	      con = Math.PI * this.R;
	      xx = p.x / con;
	      yy = p.y / con;
	      xys = xx * xx + yy * yy;
	      c1 = -Math.abs(yy) * (1 + xys);
	      c2 = c1 - 2 * yy * yy + xx * xx;
	      c3 = -2 * c1 + 1 + 2 * yy * yy + xys * xys;
	      d = yy * yy / c3 + (2 * c2 * c2 * c2 / c3 / c3 / c3 - 9 * c1 * c2 / c3 / c3) / 27;
	      a1 = (c1 - c2 * c2 / 3 / c3) / c3;
	      m1 = 2 * Math.sqrt(-a1 / 3);
	      con = ((3 * d) / a1) / m1;
	      if (Math.abs(con) > 1) {
	        if (con >= 0) {
	          con = 1;
	        }
	        else {
	          con = -1;
	        }
	      }
	      th1 = Math.acos(con) / 3;
	      if (p.y >= 0) {
	        lat = (-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
	      }
	      else {
	        lat = -(-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
	      }

	      if (Math.abs(xx) < EPSLN) {
	        lon = this.long0;
	      }
	      else {
	        lon = adjust_lon(this.long0 + Math.PI * (xys - 1 + Math.sqrt(1 + 2 * (xx * xx - yy * yy) + xys * xys)) / 2 / xx);
	      }

	      p.x = lon;
	      p.y = lat;
	      return p;
	    }

	    var names$25 = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"];
	    var vandg = {
	      init: init$24,
	      forward: forward$23,
	      inverse: inverse$23,
	      names: names$25
	    };

	    function init$25() {
	      this.sin_p12 = Math.sin(this.lat0);
	      this.cos_p12 = Math.cos(this.lat0);
	    }

	    function forward$24(p) {
	      var lon = p.x;
	      var lat = p.y;
	      var sinphi = Math.sin(p.y);
	      var cosphi = Math.cos(p.y);
	      var dlon = adjust_lon(lon - this.long0);
	      var e0, e1, e2, e3, Mlp, Ml, tanphi, Nl1, Nl, psi, Az, G, H, GH, Hs, c, kp, cos_c, s, s2, s3, s4, s5;
	      if (this.sphere) {
	        if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
	          //North Pole case
	          p.x = this.x0 + this.a * (HALF_PI - lat) * Math.sin(dlon);
	          p.y = this.y0 - this.a * (HALF_PI - lat) * Math.cos(dlon);
	          return p;
	        }
	        else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
	          //South Pole case
	          p.x = this.x0 + this.a * (HALF_PI + lat) * Math.sin(dlon);
	          p.y = this.y0 + this.a * (HALF_PI + lat) * Math.cos(dlon);
	          return p;
	        }
	        else {
	          //default case
	          cos_c = this.sin_p12 * sinphi + this.cos_p12 * cosphi * Math.cos(dlon);
	          c = Math.acos(cos_c);
	          kp = c / Math.sin(c);
	          p.x = this.x0 + this.a * kp * cosphi * Math.sin(dlon);
	          p.y = this.y0 + this.a * kp * (this.cos_p12 * sinphi - this.sin_p12 * cosphi * Math.cos(dlon));
	          return p;
	        }
	      }
	      else {
	        e0 = e0fn(this.es);
	        e1 = e1fn(this.es);
	        e2 = e2fn(this.es);
	        e3 = e3fn(this.es);
	        if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
	          //North Pole case
	          Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
	          Ml = this.a * mlfn(e0, e1, e2, e3, lat);
	          p.x = this.x0 + (Mlp - Ml) * Math.sin(dlon);
	          p.y = this.y0 - (Mlp - Ml) * Math.cos(dlon);
	          return p;
	        }
	        else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
	          //South Pole case
	          Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
	          Ml = this.a * mlfn(e0, e1, e2, e3, lat);
	          p.x = this.x0 + (Mlp + Ml) * Math.sin(dlon);
	          p.y = this.y0 + (Mlp + Ml) * Math.cos(dlon);
	          return p;
	        }
	        else {
	          //Default case
	          tanphi = sinphi / cosphi;
	          Nl1 = gN(this.a, this.e, this.sin_p12);
	          Nl = gN(this.a, this.e, sinphi);
	          psi = Math.atan((1 - this.es) * tanphi + this.es * Nl1 * this.sin_p12 / (Nl * cosphi));
	          Az = Math.atan2(Math.sin(dlon), this.cos_p12 * Math.tan(psi) - this.sin_p12 * Math.cos(dlon));
	          if (Az === 0) {
	            s = Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
	          }
	          else if (Math.abs(Math.abs(Az) - Math.PI) <= EPSLN) {
	            s = -Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
	          }
	          else {
	            s = Math.asin(Math.sin(dlon) * Math.cos(psi) / Math.sin(Az));
	          }
	          G = this.e * this.sin_p12 / Math.sqrt(1 - this.es);
	          H = this.e * this.cos_p12 * Math.cos(Az) / Math.sqrt(1 - this.es);
	          GH = G * H;
	          Hs = H * H;
	          s2 = s * s;
	          s3 = s2 * s;
	          s4 = s3 * s;
	          s5 = s4 * s;
	          c = Nl1 * s * (1 - s2 * Hs * (1 - Hs) / 6 + s3 / 8 * GH * (1 - 2 * Hs) + s4 / 120 * (Hs * (4 - 7 * Hs) - 3 * G * G * (1 - 7 * Hs)) - s5 / 48 * GH);
	          p.x = this.x0 + c * Math.sin(Az);
	          p.y = this.y0 + c * Math.cos(Az);
	          return p;
	        }
	      }


	    }

	    function inverse$24(p) {
	      p.x -= this.x0;
	      p.y -= this.y0;
	      var rh, z, sinz, cosz, lon, lat, con, e0, e1, e2, e3, Mlp, M, N1, psi, Az, cosAz, tmp, A, B, D, Ee, F;
	      if (this.sphere) {
	        rh = Math.sqrt(p.x * p.x + p.y * p.y);
	        if (rh > (2 * HALF_PI * this.a)) {
	          return;
	        }
	        z = rh / this.a;

	        sinz = Math.sin(z);
	        cosz = Math.cos(z);

	        lon = this.long0;
	        if (Math.abs(rh) <= EPSLN) {
	          lat = this.lat0;
	        }
	        else {
	          lat = asinz(cosz * this.sin_p12 + (p.y * sinz * this.cos_p12) / rh);
	          con = Math.abs(this.lat0) - HALF_PI;
	          if (Math.abs(con) <= EPSLN) {
	            if (this.lat0 >= 0) {
	              lon = adjust_lon(this.long0 + Math.atan2(p.x, - p.y));
	            }
	            else {
	              lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));
	            }
	          }
	          else {
	            /*con = cosz - this.sin_p12 * Math.sin(lat);
	            if ((Math.abs(con) < EPSLN) && (Math.abs(p.x) < EPSLN)) {
	              //no-op, just keep the lon value as is
	            } else {
	              var temp = Math.atan2((p.x * sinz * this.cos_p12), (con * rh));
	              lon = adjust_lon(this.long0 + Math.atan2((p.x * sinz * this.cos_p12), (con * rh)));
	            }*/
	            lon = adjust_lon(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p12 * cosz - p.y * this.sin_p12 * sinz));
	          }
	        }

	        p.x = lon;
	        p.y = lat;
	        return p;
	      }
	      else {
	        e0 = e0fn(this.es);
	        e1 = e1fn(this.es);
	        e2 = e2fn(this.es);
	        e3 = e3fn(this.es);
	        if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
	          //North pole case
	          Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
	          rh = Math.sqrt(p.x * p.x + p.y * p.y);
	          M = Mlp - rh;
	          lat = imlfn(M / this.a, e0, e1, e2, e3);
	          lon = adjust_lon(this.long0 + Math.atan2(p.x, - 1 * p.y));
	          p.x = lon;
	          p.y = lat;
	          return p;
	        }
	        else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
	          //South pole case
	          Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
	          rh = Math.sqrt(p.x * p.x + p.y * p.y);
	          M = rh - Mlp;

	          lat = imlfn(M / this.a, e0, e1, e2, e3);
	          lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
	          p.x = lon;
	          p.y = lat;
	          return p;
	        }
	        else {
	          //default case
	          rh = Math.sqrt(p.x * p.x + p.y * p.y);
	          Az = Math.atan2(p.x, p.y);
	          N1 = gN(this.a, this.e, this.sin_p12);
	          cosAz = Math.cos(Az);
	          tmp = this.e * this.cos_p12 * cosAz;
	          A = -tmp * tmp / (1 - this.es);
	          B = 3 * this.es * (1 - A) * this.sin_p12 * this.cos_p12 * cosAz / (1 - this.es);
	          D = rh / N1;
	          Ee = D - A * (1 + A) * Math.pow(D, 3) / 6 - B * (1 + 3 * A) * Math.pow(D, 4) / 24;
	          F = 1 - A * Ee * Ee / 2 - D * Ee * Ee * Ee / 6;
	          psi = Math.asin(this.sin_p12 * Math.cos(Ee) + this.cos_p12 * Math.sin(Ee) * cosAz);
	          lon = adjust_lon(this.long0 + Math.asin(Math.sin(Az) * Math.sin(Ee) / Math.cos(psi)));
	          lat = Math.atan((1 - this.es * F * this.sin_p12 / Math.sin(psi)) * Math.tan(psi) / (1 - this.es));
	          p.x = lon;
	          p.y = lat;
	          return p;
	        }
	      }

	    }

	    var names$26 = ["Azimuthal_Equidistant", "aeqd"];
	    var aeqd = {
	      init: init$25,
	      forward: forward$24,
	      inverse: inverse$24,
	      names: names$26
	    };

	    function init$26() {
	      //double temp;      /* temporary variable    */

	      /* Place parameters in static storage for common use
	          -------------------------------------------------*/
	      this.sin_p14 = Math.sin(this.lat0);
	      this.cos_p14 = Math.cos(this.lat0);
	    }

	    /* Orthographic forward equations--mapping lat,long to x,y
	        ---------------------------------------------------*/
	    function forward$25(p) {
	      var sinphi, cosphi; /* sin and cos value        */
	      var dlon; /* delta longitude value      */
	      var coslon; /* cos of longitude        */
	      var ksp; /* scale factor          */
	      var g, x, y;
	      var lon = p.x;
	      var lat = p.y;
	      /* Forward equations
	          -----------------*/
	      dlon = adjust_lon(lon - this.long0);

	      sinphi = Math.sin(lat);
	      cosphi = Math.cos(lat);

	      coslon = Math.cos(dlon);
	      g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
	      ksp = 1;
	      if ((g > 0) || (Math.abs(g) <= EPSLN)) {
	        x = this.a * ksp * cosphi * Math.sin(dlon);
	        y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
	      }
	      p.x = x;
	      p.y = y;
	      return p;
	    }

	    function inverse$25(p) {
	      var rh; /* height above ellipsoid      */
	      var z; /* angle          */
	      var sinz, cosz; /* sin of z and cos of z      */
	      var con;
	      var lon, lat;
	      /* Inverse equations
	          -----------------*/
	      p.x -= this.x0;
	      p.y -= this.y0;
	      rh = Math.sqrt(p.x * p.x + p.y * p.y);
	      z = asinz(rh / this.a);

	      sinz = Math.sin(z);
	      cosz = Math.cos(z);

	      lon = this.long0;
	      if (Math.abs(rh) <= EPSLN) {
	        lat = this.lat0;
	        p.x = lon;
	        p.y = lat;
	        return p;
	      }
	      lat = asinz(cosz * this.sin_p14 + (p.y * sinz * this.cos_p14) / rh);
	      con = Math.abs(this.lat0) - HALF_PI;
	      if (Math.abs(con) <= EPSLN) {
	        if (this.lat0 >= 0) {
	          lon = adjust_lon(this.long0 + Math.atan2(p.x, - p.y));
	        }
	        else {
	          lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));
	        }
	        p.x = lon;
	        p.y = lat;
	        return p;
	      }
	      lon = adjust_lon(this.long0 + Math.atan2((p.x * sinz), rh * this.cos_p14 * cosz - p.y * this.sin_p14 * sinz));
	      p.x = lon;
	      p.y = lat;
	      return p;
	    }

	    var names$27 = ["ortho"];
	    var ortho = {
	      init: init$26,
	      forward: forward$25,
	      inverse: inverse$25,
	      names: names$27
	    };

	    // QSC projection rewritten from the original PROJ4
	    // https://github.com/OSGeo/proj.4/blob/master/src/PJ_qsc.c

	    /* constants */
	    var FACE_ENUM = {
	        FRONT: 1,
	        RIGHT: 2,
	        BACK: 3,
	        LEFT: 4,
	        TOP: 5,
	        BOTTOM: 6
	    };

	    var AREA_ENUM = {
	        AREA_0: 1,
	        AREA_1: 2,
	        AREA_2: 3,
	        AREA_3: 4
	    };

	    function init$27() {

	      this.x0 = this.x0 || 0;
	      this.y0 = this.y0 || 0;
	      this.lat0 = this.lat0 || 0;
	      this.long0 = this.long0 || 0;
	      this.lat_ts = this.lat_ts || 0;
	      this.title = this.title || "Quadrilateralized Spherical Cube";

	      /* Determine the cube face from the center of projection. */
	      if (this.lat0 >= HALF_PI - FORTPI / 2.0) {
	        this.face = FACE_ENUM.TOP;
	      } else if (this.lat0 <= -(HALF_PI - FORTPI / 2.0)) {
	        this.face = FACE_ENUM.BOTTOM;
	      } else if (Math.abs(this.long0) <= FORTPI) {
	        this.face = FACE_ENUM.FRONT;
	      } else if (Math.abs(this.long0) <= HALF_PI + FORTPI) {
	        this.face = this.long0 > 0.0 ? FACE_ENUM.RIGHT : FACE_ENUM.LEFT;
	      } else {
	        this.face = FACE_ENUM.BACK;
	      }

	      /* Fill in useful values for the ellipsoid <-> sphere shift
	       * described in [LK12]. */
	      if (this.es !== 0) {
	        this.one_minus_f = 1 - (this.a - this.b) / this.a;
	        this.one_minus_f_squared = this.one_minus_f * this.one_minus_f;
	      }
	    }

	    // QSC forward equations--mapping lat,long to x,y
	    // -----------------------------------------------------------------
	    function forward$26(p) {
	      var xy = {x: 0, y: 0};
	      var lat, lon;
	      var theta, phi;
	      var t, mu;
	      /* nu; */
	      var area = {value: 0};

	      // move lon according to projection's lon
	      p.x -= this.long0;

	      /* Convert the geodetic latitude to a geocentric latitude.
	       * This corresponds to the shift from the ellipsoid to the sphere
	       * described in [LK12]. */
	      if (this.es !== 0) {//if (P->es != 0) {
	        lat = Math.atan(this.one_minus_f_squared * Math.tan(p.y));
	      } else {
	        lat = p.y;
	      }

	      /* Convert the input lat, lon into theta, phi as used by QSC.
	       * This depends on the cube face and the area on it.
	       * For the top and bottom face, we can compute theta and phi
	       * directly from phi, lam. For the other faces, we must use
	       * unit sphere cartesian coordinates as an intermediate step. */
	      lon = p.x; //lon = lp.lam;
	      if (this.face === FACE_ENUM.TOP) {
	        phi = HALF_PI - lat;
	        if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
	          area.value = AREA_ENUM.AREA_0;
	          theta = lon - HALF_PI;
	        } else if (lon > HALF_PI + FORTPI || lon <= -(HALF_PI + FORTPI)) {
	          area.value = AREA_ENUM.AREA_1;
	          theta = (lon > 0.0 ? lon - SPI : lon + SPI);
	        } else if (lon > -(HALF_PI + FORTPI) && lon <= -FORTPI) {
	          area.value = AREA_ENUM.AREA_2;
	          theta = lon + HALF_PI;
	        } else {
	          area.value = AREA_ENUM.AREA_3;
	          theta = lon;
	        }
	      } else if (this.face === FACE_ENUM.BOTTOM) {
	        phi = HALF_PI + lat;
	        if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
	          area.value = AREA_ENUM.AREA_0;
	          theta = -lon + HALF_PI;
	        } else if (lon < FORTPI && lon >= -FORTPI) {
	          area.value = AREA_ENUM.AREA_1;
	          theta = -lon;
	        } else if (lon < -FORTPI && lon >= -(HALF_PI + FORTPI)) {
	          area.value = AREA_ENUM.AREA_2;
	          theta = -lon - HALF_PI;
	        } else {
	          area.value = AREA_ENUM.AREA_3;
	          theta = (lon > 0.0 ? -lon + SPI : -lon - SPI);
	        }
	      } else {
	        var q, r, s;
	        var sinlat, coslat;
	        var sinlon, coslon;

	        if (this.face === FACE_ENUM.RIGHT) {
	          lon = qsc_shift_lon_origin(lon, +HALF_PI);
	        } else if (this.face === FACE_ENUM.BACK) {
	          lon = qsc_shift_lon_origin(lon, +SPI);
	        } else if (this.face === FACE_ENUM.LEFT) {
	          lon = qsc_shift_lon_origin(lon, -HALF_PI);
	        }
	        sinlat = Math.sin(lat);
	        coslat = Math.cos(lat);
	        sinlon = Math.sin(lon);
	        coslon = Math.cos(lon);
	        q = coslat * coslon;
	        r = coslat * sinlon;
	        s = sinlat;

	        if (this.face === FACE_ENUM.FRONT) {
	          phi = Math.acos(q);
	          theta = qsc_fwd_equat_face_theta(phi, s, r, area);
	        } else if (this.face === FACE_ENUM.RIGHT) {
	          phi = Math.acos(r);
	          theta = qsc_fwd_equat_face_theta(phi, s, -q, area);
	        } else if (this.face === FACE_ENUM.BACK) {
	          phi = Math.acos(-q);
	          theta = qsc_fwd_equat_face_theta(phi, s, -r, area);
	        } else if (this.face === FACE_ENUM.LEFT) {
	          phi = Math.acos(-r);
	          theta = qsc_fwd_equat_face_theta(phi, s, q, area);
	        } else {
	          /* Impossible */
	          phi = theta = 0;
	          area.value = AREA_ENUM.AREA_0;
	        }
	      }

	      /* Compute mu and nu for the area of definition.
	       * For mu, see Eq. (3-21) in [OL76], but note the typos:
	       * compare with Eq. (3-14). For nu, see Eq. (3-38). */
	      mu = Math.atan((12 / SPI) * (theta + Math.acos(Math.sin(theta) * Math.cos(FORTPI)) - HALF_PI));
	      t = Math.sqrt((1 - Math.cos(phi)) / (Math.cos(mu) * Math.cos(mu)) / (1 - Math.cos(Math.atan(1 / Math.cos(theta)))));

	      /* Apply the result to the real area. */
	      if (area.value === AREA_ENUM.AREA_1) {
	        mu += HALF_PI;
	      } else if (area.value === AREA_ENUM.AREA_2) {
	        mu += SPI;
	      } else if (area.value === AREA_ENUM.AREA_3) {
	        mu += 1.5 * SPI;
	      }

	      /* Now compute x, y from mu and nu */
	      xy.x = t * Math.cos(mu);
	      xy.y = t * Math.sin(mu);
	      xy.x = xy.x * this.a + this.x0;
	      xy.y = xy.y * this.a + this.y0;

	      p.x = xy.x;
	      p.y = xy.y;
	      return p;
	    }

	    // QSC inverse equations--mapping x,y to lat/long
	    // -----------------------------------------------------------------
	    function inverse$26(p) {
	      var lp = {lam: 0, phi: 0};
	      var mu, nu, cosmu, tannu;
	      var tantheta, theta, cosphi, phi;
	      var t;
	      var area = {value: 0};

	      /* de-offset */
	      p.x = (p.x - this.x0) / this.a;
	      p.y = (p.y - this.y0) / this.a;

	      /* Convert the input x, y to the mu and nu angles as used by QSC.
	       * This depends on the area of the cube face. */
	      nu = Math.atan(Math.sqrt(p.x * p.x + p.y * p.y));
	      mu = Math.atan2(p.y, p.x);
	      if (p.x >= 0.0 && p.x >= Math.abs(p.y)) {
	        area.value = AREA_ENUM.AREA_0;
	      } else if (p.y >= 0.0 && p.y >= Math.abs(p.x)) {
	        area.value = AREA_ENUM.AREA_1;
	        mu -= HALF_PI;
	      } else if (p.x < 0.0 && -p.x >= Math.abs(p.y)) {
	        area.value = AREA_ENUM.AREA_2;
	        mu = (mu < 0.0 ? mu + SPI : mu - SPI);
	      } else {
	        area.value = AREA_ENUM.AREA_3;
	        mu += HALF_PI;
	      }

	      /* Compute phi and theta for the area of definition.
	       * The inverse projection is not described in the original paper, but some
	       * good hints can be found here (as of 2011-12-14):
	       * http://fits.gsfc.nasa.gov/fitsbits/saf.93/saf.9302
	       * (search for "Message-Id: <9302181759.AA25477 at fits.cv.nrao.edu>") */
	      t = (SPI / 12) * Math.tan(mu);
	      tantheta = Math.sin(t) / (Math.cos(t) - (1 / Math.sqrt(2)));
	      theta = Math.atan(tantheta);
	      cosmu = Math.cos(mu);
	      tannu = Math.tan(nu);
	      cosphi = 1 - cosmu * cosmu * tannu * tannu * (1 - Math.cos(Math.atan(1 / Math.cos(theta))));
	      if (cosphi < -1) {
	        cosphi = -1;
	      } else if (cosphi > +1) {
	        cosphi = +1;
	      }

	      /* Apply the result to the real area on the cube face.
	       * For the top and bottom face, we can compute phi and lam directly.
	       * For the other faces, we must use unit sphere cartesian coordinates
	       * as an intermediate step. */
	      if (this.face === FACE_ENUM.TOP) {
	        phi = Math.acos(cosphi);
	        lp.phi = HALF_PI - phi;
	        if (area.value === AREA_ENUM.AREA_0) {
	          lp.lam = theta + HALF_PI;
	        } else if (area.value === AREA_ENUM.AREA_1) {
	          lp.lam = (theta < 0.0 ? theta + SPI : theta - SPI);
	        } else if (area.value === AREA_ENUM.AREA_2) {
	          lp.lam = theta - HALF_PI;
	        } else /* area.value == AREA_ENUM.AREA_3 */ {
	          lp.lam = theta;
	        }
	      } else if (this.face === FACE_ENUM.BOTTOM) {
	        phi = Math.acos(cosphi);
	        lp.phi = phi - HALF_PI;
	        if (area.value === AREA_ENUM.AREA_0) {
	          lp.lam = -theta + HALF_PI;
	        } else if (area.value === AREA_ENUM.AREA_1) {
	          lp.lam = -theta;
	        } else if (area.value === AREA_ENUM.AREA_2) {
	          lp.lam = -theta - HALF_PI;
	        } else /* area.value == AREA_ENUM.AREA_3 */ {
	          lp.lam = (theta < 0.0 ? -theta - SPI : -theta + SPI);
	        }
	      } else {
	        /* Compute phi and lam via cartesian unit sphere coordinates. */
	        var q, r, s;
	        q = cosphi;
	        t = q * q;
	        if (t >= 1) {
	          s = 0;
	        } else {
	          s = Math.sqrt(1 - t) * Math.sin(theta);
	        }
	        t += s * s;
	        if (t >= 1) {
	          r = 0;
	        } else {
	          r = Math.sqrt(1 - t);
	        }
	        /* Rotate q,r,s into the correct area. */
	        if (area.value === AREA_ENUM.AREA_1) {
	          t = r;
	          r = -s;
	          s = t;
	        } else if (area.value === AREA_ENUM.AREA_2) {
	          r = -r;
	          s = -s;
	        } else if (area.value === AREA_ENUM.AREA_3) {
	          t = r;
	          r = s;
	          s = -t;
	        }
	        /* Rotate q,r,s into the correct cube face. */
	        if (this.face === FACE_ENUM.RIGHT) {
	          t = q;
	          q = -r;
	          r = t;
	        } else if (this.face === FACE_ENUM.BACK) {
	          q = -q;
	          r = -r;
	        } else if (this.face === FACE_ENUM.LEFT) {
	          t = q;
	          q = r;
	          r = -t;
	        }
	        /* Now compute phi and lam from the unit sphere coordinates. */
	        lp.phi = Math.acos(-s) - HALF_PI;
	        lp.lam = Math.atan2(r, q);
	        if (this.face === FACE_ENUM.RIGHT) {
	          lp.lam = qsc_shift_lon_origin(lp.lam, -HALF_PI);
	        } else if (this.face === FACE_ENUM.BACK) {
	          lp.lam = qsc_shift_lon_origin(lp.lam, -SPI);
	        } else if (this.face === FACE_ENUM.LEFT) {
	          lp.lam = qsc_shift_lon_origin(lp.lam, +HALF_PI);
	        }
	      }

	      /* Apply the shift from the sphere to the ellipsoid as described
	       * in [LK12]. */
	      if (this.es !== 0) {
	        var invert_sign;
	        var tanphi, xa;
	        invert_sign = (lp.phi < 0 ? 1 : 0);
	        tanphi = Math.tan(lp.phi);
	        xa = this.b / Math.sqrt(tanphi * tanphi + this.one_minus_f_squared);
	        lp.phi = Math.atan(Math.sqrt(this.a * this.a - xa * xa) / (this.one_minus_f * xa));
	        if (invert_sign) {
	          lp.phi = -lp.phi;
	        }
	      }

	      lp.lam += this.long0;
	      p.x = lp.lam;
	      p.y = lp.phi;
	      return p;
	    }

	    /* Helper function for forward projection: compute the theta angle
	     * and determine the area number. */
	    function qsc_fwd_equat_face_theta(phi, y, x, area) {
	      var theta;
	      if (phi < EPSLN) {
	        area.value = AREA_ENUM.AREA_0;
	        theta = 0.0;
	      } else {
	        theta = Math.atan2(y, x);
	        if (Math.abs(theta) <= FORTPI) {
	          area.value = AREA_ENUM.AREA_0;
	        } else if (theta > FORTPI && theta <= HALF_PI + FORTPI) {
	          area.value = AREA_ENUM.AREA_1;
	          theta -= HALF_PI;
	        } else if (theta > HALF_PI + FORTPI || theta <= -(HALF_PI + FORTPI)) {
	          area.value = AREA_ENUM.AREA_2;
	          theta = (theta >= 0.0 ? theta - SPI : theta + SPI);
	        } else {
	          area.value = AREA_ENUM.AREA_3;
	          theta += HALF_PI;
	        }
	      }
	      return theta;
	    }

	    /* Helper function: shift the longitude. */
	    function qsc_shift_lon_origin(lon, offset) {
	      var slon = lon + offset;
	      if (slon < -SPI) {
	        slon += TWO_PI;
	      } else if (slon > +SPI) {
	        slon -= TWO_PI;
	      }
	      return slon;
	    }

	    var names$28 = ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"];
	    var qsc = {
	      init: init$27,
	      forward: forward$26,
	      inverse: inverse$26,
	      names: names$28
	    };

	    // Robinson projection
	    // Based on https://github.com/OSGeo/proj.4/blob/master/src/PJ_robin.c
	    // Polynomial coeficients from http://article.gmane.org/gmane.comp.gis.proj-4.devel/6039

	    var COEFS_X = [
	        [1.0000, 2.2199e-17, -7.15515e-05, 3.1103e-06],
	        [0.9986, -0.000482243, -2.4897e-05, -1.3309e-06],
	        [0.9954, -0.00083103, -4.48605e-05, -9.86701e-07],
	        [0.9900, -0.00135364, -5.9661e-05, 3.6777e-06],
	        [0.9822, -0.00167442, -4.49547e-06, -5.72411e-06],
	        [0.9730, -0.00214868, -9.03571e-05, 1.8736e-08],
	        [0.9600, -0.00305085, -9.00761e-05, 1.64917e-06],
	        [0.9427, -0.00382792, -6.53386e-05, -2.6154e-06],
	        [0.9216, -0.00467746, -0.00010457, 4.81243e-06],
	        [0.8962, -0.00536223, -3.23831e-05, -5.43432e-06],
	        [0.8679, -0.00609363, -0.000113898, 3.32484e-06],
	        [0.8350, -0.00698325, -6.40253e-05, 9.34959e-07],
	        [0.7986, -0.00755338, -5.00009e-05, 9.35324e-07],
	        [0.7597, -0.00798324, -3.5971e-05, -2.27626e-06],
	        [0.7186, -0.00851367, -7.01149e-05, -8.6303e-06],
	        [0.6732, -0.00986209, -0.000199569, 1.91974e-05],
	        [0.6213, -0.010418, 8.83923e-05, 6.24051e-06],
	        [0.5722, -0.00906601, 0.000182, 6.24051e-06],
	        [0.5322, -0.00677797, 0.000275608, 6.24051e-06]
	    ];

	    var COEFS_Y = [
	        [-5.20417e-18, 0.0124, 1.21431e-18, -8.45284e-11],
	        [0.0620, 0.0124, -1.26793e-09, 4.22642e-10],
	        [0.1240, 0.0124, 5.07171e-09, -1.60604e-09],
	        [0.1860, 0.0123999, -1.90189e-08, 6.00152e-09],
	        [0.2480, 0.0124002, 7.10039e-08, -2.24e-08],
	        [0.3100, 0.0123992, -2.64997e-07, 8.35986e-08],
	        [0.3720, 0.0124029, 9.88983e-07, -3.11994e-07],
	        [0.4340, 0.0123893, -3.69093e-06, -4.35621e-07],
	        [0.4958, 0.0123198, -1.02252e-05, -3.45523e-07],
	        [0.5571, 0.0121916, -1.54081e-05, -5.82288e-07],
	        [0.6176, 0.0119938, -2.41424e-05, -5.25327e-07],
	        [0.6769, 0.011713, -3.20223e-05, -5.16405e-07],
	        [0.7346, 0.0113541, -3.97684e-05, -6.09052e-07],
	        [0.7903, 0.0109107, -4.89042e-05, -1.04739e-06],
	        [0.8435, 0.0103431, -6.4615e-05, -1.40374e-09],
	        [0.8936, 0.00969686, -6.4636e-05, -8.547e-06],
	        [0.9394, 0.00840947, -0.000192841, -4.2106e-06],
	        [0.9761, 0.00616527, -0.000256, -4.2106e-06],
	        [1.0000, 0.00328947, -0.000319159, -4.2106e-06]
	    ];

	    var FXC = 0.8487;
	    var FYC = 1.3523;
	    var C1 = R2D/5; // rad to 5-degree interval
	    var RC1 = 1/C1;
	    var NODES = 18;

	    var poly3_val = function(coefs, x) {
	        return coefs[0] + x * (coefs[1] + x * (coefs[2] + x * coefs[3]));
	    };

	    var poly3_der = function(coefs, x) {
	        return coefs[1] + x * (2 * coefs[2] + x * 3 * coefs[3]);
	    };

	    function newton_rapshon(f_df, start, max_err, iters) {
	        var x = start;
	        for (; iters; --iters) {
	            var upd = f_df(x);
	            x -= upd;
	            if (Math.abs(upd) < max_err) {
	                break;
	            }
	        }
	        return x;
	    }

	    function init$28() {
	        this.x0 = this.x0 || 0;
	        this.y0 = this.y0 || 0;
	        this.long0 = this.long0 || 0;
	        this.es = 0;
	        this.title = this.title || "Robinson";
	    }

	    function forward$27(ll) {
	        var lon = adjust_lon(ll.x - this.long0);

	        var dphi = Math.abs(ll.y);
	        var i = Math.floor(dphi * C1);
	        if (i < 0) {
	            i = 0;
	        } else if (i >= NODES) {
	            i = NODES - 1;
	        }
	        dphi = R2D * (dphi - RC1 * i);
	        var xy = {
	            x: poly3_val(COEFS_X[i], dphi) * lon,
	            y: poly3_val(COEFS_Y[i], dphi)
	        };
	        if (ll.y < 0) {
	            xy.y = -xy.y;
	        }

	        xy.x = xy.x * this.a * FXC + this.x0;
	        xy.y = xy.y * this.a * FYC + this.y0;
	        return xy;
	    }

	    function inverse$27(xy) {
	        var ll = {
	            x: (xy.x - this.x0) / (this.a * FXC),
	            y: Math.abs(xy.y - this.y0) / (this.a * FYC)
	        };

	        if (ll.y >= 1) { // pathologic case
	            ll.x /= COEFS_X[NODES][0];
	            ll.y = xy.y < 0 ? -HALF_PI : HALF_PI;
	        } else {
	            // find table interval
	            var i = Math.floor(ll.y * NODES);
	            if (i < 0) {
	                i = 0;
	            } else if (i >= NODES) {
	                i = NODES - 1;
	            }
	            for (;;) {
	                if (COEFS_Y[i][0] > ll.y) {
	                    --i;
	                } else if (COEFS_Y[i+1][0] <= ll.y) {
	                    ++i;
	                } else {
	                    break;
	                }
	            }
	            // linear interpolation in 5 degree interval
	            var coefs = COEFS_Y[i];
	            var t = 5 * (ll.y - coefs[0]) / (COEFS_Y[i+1][0] - coefs[0]);
	            // find t so that poly3_val(coefs, t) = ll.y
	            t = newton_rapshon(function(x) {
	                return (poly3_val(coefs, x) - ll.y) / poly3_der(coefs, x);
	            }, t, EPSLN, 100);

	            ll.x /= poly3_val(COEFS_X[i], t);
	            ll.y = (5 * i + t) * D2R;
	            if (xy.y < 0) {
	                ll.y = -ll.y;
	            }
	        }

	        ll.x = adjust_lon(ll.x + this.long0);
	        return ll;
	    }

	    var names$29 = ["Robinson", "robin"];
	    var robin = {
	      init: init$28,
	      forward: forward$27,
	      inverse: inverse$27,
	      names: names$29
	    };

	    function init$29() {
	        this.name = 'geocent';

	    }

	    function forward$28(p) {
	        var point = geodeticToGeocentric(p, this.es, this.a);
	        return point;
	    }

	    function inverse$28(p) {
	        var point = geocentricToGeodetic(p, this.es, this.a, this.b);
	        return point;
	    }

	    var names$30 = ["Geocentric", 'geocentric', "geocent", "Geocent"];
	    var geocent = {
	        init: init$29,
	        forward: forward$28,
	        inverse: inverse$28,
	        names: names$30
	    };

	    var includedProjections = function(proj4){
	      proj4.Proj.projections.add(tmerc);
	      proj4.Proj.projections.add(etmerc);
	      proj4.Proj.projections.add(utm);
	      proj4.Proj.projections.add(sterea);
	      proj4.Proj.projections.add(stere);
	      proj4.Proj.projections.add(somerc);
	      proj4.Proj.projections.add(omerc);
	      proj4.Proj.projections.add(lcc);
	      proj4.Proj.projections.add(krovak);
	      proj4.Proj.projections.add(cass);
	      proj4.Proj.projections.add(laea);
	      proj4.Proj.projections.add(aea);
	      proj4.Proj.projections.add(gnom);
	      proj4.Proj.projections.add(cea);
	      proj4.Proj.projections.add(eqc);
	      proj4.Proj.projections.add(poly);
	      proj4.Proj.projections.add(nzmg);
	      proj4.Proj.projections.add(mill);
	      proj4.Proj.projections.add(sinu);
	      proj4.Proj.projections.add(moll);
	      proj4.Proj.projections.add(eqdc);
	      proj4.Proj.projections.add(vandg);
	      proj4.Proj.projections.add(aeqd);
	      proj4.Proj.projections.add(ortho);
	      proj4.Proj.projections.add(qsc);
	      proj4.Proj.projections.add(robin);
	      proj4.Proj.projections.add(geocent);
	    };

	    proj4$1.defaultDatum = 'WGS84'; //default datum
	    proj4$1.Proj = Projection;
	    proj4$1.WGS84 = new proj4$1.Proj('WGS84');
	    proj4$1.Point = Point;
	    proj4$1.toPoint = toPoint;
	    proj4$1.defs = defs;
	    proj4$1.transform = transform;
	    proj4$1.mgrs = mgrs;
	    proj4$1.version = '2.6.0';
	    includedProjections(proj4$1);

	    return proj4$1;

	})));
	});

	/**
	 * Turns the longitude / latitude in degrees into a human readable pretty UTM zone representation.
	 */

	function prettifyProjection(longitude, latitude, proj4Projection, proj4longlat, projectionUnits) {
	  var zone = 1 + Math.floor((longitude + 180) / 6);
	  var projection = proj4Projection + ' +zone=' + zone + (latitude < 0 ? ' +south' : '');
	  var projPoint = proj4Src(proj4longlat, projection, [longitude, latitude]);
	  return {
	    utmZone: zone + (latitude < 0.0 ? 'S' : 'N'),
	    north: projPoint[1].toFixed(2) + projectionUnits,
	    east: projPoint[0].toFixed(2) + projectionUnits
	  };
	}

	/**
	 * The Earth Gravity Model 1996 (EGM96) geoid.
	 * @param {String} gridFileUrl The URL of the WW15MGH.DAC file.
	 */
	var EarthGravityModel1996 = function EarthGravityModel1996(gridFileUrl) {
	  this.gridFileUrl = gridFileUrl;
	  this.data = undefined; // These values were determined by inspecting the WW15MGH.DAC file.  We hard-code them here because
	  // we need them available before that file finishes loading.

	  this.minimumHeight = -106.99;
	  this.maximumHeight = 85.39;
	};
	/**
	 * Determines if this class will work in the current environment.  It will return false on older browsers without support
	 * for typed arrays.
	 * @return {Boolean} True if this class may be used in this environment; otherwise, false.
	 */


	EarthGravityModel1996.isSupported = function () {
	  return typeof Int16Array !== 'undefined' && typeof Uint8Array !== 'undefined';
	};
	/**
	 * Gets the height of EGM96 above the surface of the ellipsoid.
	 * @param {String} baseUrl The base URL for TerriaJS resources.
	 * @param {Number} longitude The longitude.
	 * @param {Number} latitude The latitude
	 * @return {Promise|Number} A promise, that, when it results The height of mean sea level above the ellipsoid at the specified location.  Negative numbers indicate that mean sea level
	 *                  is below the ellipsoid.
	 */


	EarthGravityModel1996.prototype.getHeight = function (longitude, latitude) {
	  return getHeightData(this).then(function (data) {
	    return getHeightFromData(data, longitude, latitude);
	  });
	};

	EarthGravityModel1996.prototype.getHeights = function (cartographicArray) {
	  return getHeightData(this).then(function (data) {
	    for (var i = 0; i < cartographicArray.length; ++i) {
	      var cartographic = cartographicArray[i];
	      cartographic.height = getHeightFromData(data, cartographic.longitude, cartographic.latitude);
	    }

	    return cartographicArray;
	  });
	};

	function getHeightData(model) {
	  var _Cesium = Cesium,
	      defined = _Cesium.defined,
	      when = _Cesium.when;

	  if (!defined(model.data)) {
	    model.data = loadArrayBuffer(model.gridFileUrl);
	  }

	  return when(model.data, function (data) {
	    if (!(model.data instanceof Int16Array)) {
	      // Data file is big-endian, all relevant platforms are little endian, so swap the byte order.
	      var byteView = new Uint8Array(data);

	      for (var k = 0; k < byteView.length; k += 2) {
	        var tmp = byteView[k];
	        byteView[k] = byteView[k + 1];
	        byteView[k + 1] = tmp;
	      }

	      model.data = new Int16Array(data);
	    }

	    return model.data;
	  });
	}

	function getHeightFromData(data, longitude, latitude) {
	  var _Cesium2 = Cesium,
	      CesiumMath = _Cesium2.Math;
	  var recordIndex = 720 * (CesiumMath.PI_OVER_TWO - latitude) / Math.PI;

	  if (recordIndex < 0) {
	    recordIndex = 0;
	  } else if (recordIndex > 720) {
	    recordIndex = 720;
	  }

	  longitude = CesiumMath.zeroToTwoPi(longitude);
	  var heightIndex = 1440 * longitude / CesiumMath.TWO_PI;

	  if (heightIndex < 0) {
	    heightIndex = 0;
	  } else if (heightIndex > 1440) {
	    heightIndex = 1440;
	  }

	  var i = heightIndex | 0;
	  var j = recordIndex | 0;
	  var xMinusX1 = heightIndex - i;
	  var yMinusY1 = recordIndex - j;
	  var x2MinusX = 1.0 - xMinusX1;
	  var y2MinusY = 1.0 - yMinusY1;
	  var f11 = getHeightValue(data, j, i);
	  var f21 = getHeightValue(data, j, i + 1);
	  var f12 = getHeightValue(data, j + 1, i);
	  var f22 = getHeightValue(data, j + 1, i + 1);
	  return (f11 * x2MinusX * y2MinusY + f21 * xMinusX1 * y2MinusY + f12 * x2MinusX * yMinusY1 + f22 * xMinusX1 * yMinusY1) / 100.0;
	} // Heights returned by this function are in centimeters.


	function getHeightValue(data, recordIndex, heightIndex) {
	  if (recordIndex > 720) {
	    recordIndex = 720;
	  } else if (recordIndex < 0) {
	    recordIndex = 0;
	  }

	  if (heightIndex > 1439) {
	    heightIndex -= 1440;
	  } else if (heightIndex < 0) {
	    heightIndex += 1440;
	  }

	  return data[recordIndex * 1440 + heightIndex];
	}

	function loadArrayBuffer(urlOrResource) {
	  var _Cesium3 = Cesium,
	      Resource = _Cesium3.Resource;
	  var resource = Resource.createIfNeeded(urlOrResource);
	  return resource.fetchArrayBuffer();
	} // module.exports = EarthGravityModel1996

	var MouseCoords =
	/*#__PURE__*/
	function () {
	  function MouseCoords() {
	    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    _classCallCheck(this, MouseCoords);

	    var _Cesium = Cesium,
	        Cartographic = _Cesium.Cartographic,
	        knockout = _Cesium.knockout;
	    var gridFileUrl = options.gridFileUrl;
	    gridFileUrl && (this.geoidModel = new EarthGravityModel1996(gridFileUrl));
	    this.proj4Projection = '+proj=utm +ellps=GRS80 +units=m +no_defs';
	    this.projectionUnits = 'm';
	    this.proj4longlat = '+proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees +no_defs';
	    this.lastHeightSamplePosition = new Cartographic();
	    this.accurateSamplingDebounceTime = 250;
	    this.tileRequestInFlight = undefined;
	    this.elevation = undefined;
	    this.utmZone = undefined;
	    this.latitude = undefined;
	    this.longitude = undefined;
	    this.north = undefined;
	    this.east = undefined;
	    this.useProjection = false;
	    this.debounceSampleAccurateHeight = debounce(this.sampleAccurateHeight, this.accurateSamplingDebounceTime);
	    knockout.track(this, ['elevation', 'utmZone', 'latitude', 'longitude', 'north', 'east', 'useProjection']);
	  }

	  _createClass(MouseCoords, [{
	    key: "toggleUseProjection",
	    value: function toggleUseProjection() {
	      this.useProjection = !this.useProjection;
	    }
	  }, {
	    key: "updateCoordinatesFromCesium",
	    value: function updateCoordinatesFromCesium(viewer, position) {
	      var _Cesium2 = Cesium,
	          Cartographic = _Cesium2.Cartographic,
	          defined = _Cesium2.defined,
	          EllipsoidTerrainProvider = _Cesium2.EllipsoidTerrainProvider,
	          Intersections2D = _Cesium2.Intersections2D,
	          SceneMode = _Cesium2.SceneMode;
	      var scene = viewer.scene;
	      var camera = scene.camera;
	      var pickRay = camera.getPickRay(position);
	      var globe = scene.globe;
	      var pickedTriangle = globe.pickTriangle(pickRay, scene);

	      if (defined(pickedTriangle)) {
	        // Get a fast, accurate-ish height every time the mouse moves.
	        var ellipsoid = globe.ellipsoid;
	        var v0 = ellipsoid.cartesianToCartographic(pickedTriangle.v0);
	        var v1 = ellipsoid.cartesianToCartographic(pickedTriangle.v1);
	        var v2 = ellipsoid.cartesianToCartographic(pickedTriangle.v2);
	        var intersection = ellipsoid.cartesianToCartographic(scene.mode === SceneMode.SCENE3D ? pickedTriangle.intersection : scene.globe.pick(pickRay, scene));
	        var errorBar;

	        if (globe.terrainProvider instanceof EllipsoidTerrainProvider) {
	          intersection.height = undefined;
	        } else {
	          var barycentric = Intersections2D.computeBarycentricCoordinates(intersection.longitude, intersection.latitude, v0.longitude, v0.latitude, v1.longitude, v1.latitude, v2.longitude, v2.latitude);

	          if (barycentric.x >= -1e-15 && barycentric.y >= -1e-15 && barycentric.z >= -1e-15) {
	            var height = barycentric.x * v0.height + barycentric.y * v1.height + barycentric.z * v2.height;
	            intersection.height = height;
	          }

	          var geometricError = globe.terrainProvider.getLevelMaximumGeometricError(pickedTriangle.tile.level);
	          var approximateHeight = intersection.height;
	          var minHeight = Math.max(pickedTriangle.tile.data.tileBoundingRegion.minimumHeight, approximateHeight - geometricError);
	          var maxHeight = Math.min(pickedTriangle.tile.data.tileBoundingRegion.maximumHeight, approximateHeight + geometricError);
	          var minHeightGeoid = minHeight - (this.geoidModel ? this.geoidModel.minimumHeight : 0.0);
	          var maxHeightGeoid = maxHeight + (this.geoidModel ? this.geoidModel.maximumHeight : 0.0);
	          errorBar = Math.max(Math.abs(approximateHeight - minHeightGeoid), Math.abs(maxHeightGeoid - approximateHeight));
	        }

	        Cartographic.clone(intersection, this.lastHeightSamplePosition);
	        var terrainProvider = globe.terrainProvider;
	        this.cartographicToFields(intersection, errorBar);

	        if (!(terrainProvider instanceof EllipsoidTerrainProvider)) {
	          this.debounceSampleAccurateHeight(terrainProvider, intersection);
	        }
	      } else {
	        this.elevation = undefined;
	        this.utmZone = undefined;
	        this.latitude = undefined;
	        this.longitude = undefined;
	        this.north = undefined;
	        this.east = undefined;
	      }
	    }
	  }, {
	    key: "cartographicToFields",
	    value: function cartographicToFields(coordinates, errorBar) {
	      var _Cesium3 = Cesium,
	          CesiumMath = _Cesium3.Math;
	      var latitude = CesiumMath.toDegrees(coordinates.latitude);
	      var longitude = CesiumMath.toDegrees(coordinates.longitude);

	      if (this.useProjection) {
	        var prettyProjection = prettifyProjection(longitude, latitude, this.proj4Projection, this.proj4longlat, this.projectionUnits);
	        this.utmZone = prettyProjection.utmZone;
	        this.north = prettyProjection.north;
	        this.east = prettyProjection.east;
	      }

	      var prettyCoordinate = prettifyCoordinates(longitude, latitude, {
	        height: coordinates.height,
	        errorBar: errorBar
	      });
	      this.latitude = prettyCoordinate.latitude;
	      this.longitude = prettyCoordinate.longitude;
	      this.elevation = prettyCoordinate.elevation;
	    }
	  }, {
	    key: "sampleAccurateHeight",
	    value: function sampleAccurateHeight(terrainProvider, position) {
	      var _this = this;

	      var _Cesium4 = Cesium,
	          Cartographic = _Cesium4.Cartographic,
	          sampleTerrainMostDetailed = _Cesium4.sampleTerrainMostDetailed,
	          when = _Cesium4.when;

	      if (this.tileRequestInFlight) {
	        // A tile request is already in flight, so reschedule for later.
	        this.debounceSampleAccurateHeight.cancel();
	        this.debounceSampleAccurateHeight(terrainProvider, position);
	        return;
	      }

	      var positionWithHeight = Cartographic.clone(position);
	      var geoidHeightPromise = this.geoidModel ? this.geoidModel.getHeight(position.longitude, position.latitude) : undefined;
	      var terrainPromise = sampleTerrainMostDetailed(terrainProvider, [positionWithHeight]);
	      this.tileRequestInFlight = when.all([geoidHeightPromise, terrainPromise], function (result) {
	        var geoidHeight = result[0] || 0.0;
	        _this.tileRequestInFlight = undefined;

	        if (Cartographic.equals(position, _this.lastHeightSamplePosition)) {
	          position.height = positionWithHeight.height - geoidHeight;

	          _this.cartographicToFields(position);
	        }
	      }, function () {
	        _this.tileRequestInFlight = undefined;
	      });
	    }
	  }]);

	  return MouseCoords;
	}();

	VcIconSvg.register({
	  'compass-outer': {
	    width: 162,
	    height: 162,
	    viewBox: '0 0 162 162',
	    data: "\n    <!-- Generator: Sketch 43.2 (39069) - http://www.bohemiancoding.com/sketch -->\n    <!-- <title>compass-outer</title> -->\n    <desc>Created with Sketch.</desc>\n    <defs></defs>\n    <g id=\"Page-1\" stroke=\"none\" stroke-width=\"1\" fill-rule=\"evenodd\">\n      <g id=\"compass-outer\" fill-rule=\"nonzero\">\n        <path d=\"M80.8410544,161.682109 C36.1937731,161.682109 0,125.488336 0,80.8410544 C0,36.1937731 36.1937731,0 80.8410544,0 C125.488336,0 161.682109,36.1937731 161.682109,80.8410544 C161.682109,125.488336 125.488336,161.682109 80.8410544,161.682109 Z M81.1836011,134.620909 C110.696211,134.620909 134.620909,110.696211 134.620909,81.1836011 C134.620909,51.6709916 110.696211,27.7462941 81.1836011,27.7462941 C51.6709916,27.7462941 27.7462941,51.6709916 27.7462941,81.1836011 C27.7462941,110.696211 51.6709916,134.620909 81.1836011,134.620909 Z\" id=\"Oval-108\"></path>\n        <circle id=\"Oval-74\" fill=\"#FFFFFF\" cx=\"129.493683\" cy=\"127.952092\" r=\"1.54159147\"></circle>\n        <circle id=\"Oval-74-Copy-3\" fill=\"#FFFFFF\" cx=\"129.493683\" cy=\"35.4566038\" r=\"1.54159147\"></circle>\n        <circle id=\"Oval-74-Copy-5\" fill=\"#FFFFFF\" cx=\"30.8318294\" cy=\"127.952092\" r=\"1.54159147\"></circle>\n        <circle id=\"Oval-74-Copy-4\" fill=\"#FFFFFF\" cx=\"30.8318294\" cy=\"35.4566038\" r=\"1.54159147\"></circle>\n        <polygon id=\"N\" fill=\"#FFFFFF\" points=\"84.9318072 23.1238721 84.9318072 13.1321362 82.5623385 13.1321362 82.5623385 19.2984646 77.951866 13.1321362 75.7108625 13.1321362 75.7108625 23.1238721 78.0946053 23.1238721 78.0946053 16.9718176 82.6908037 23.1238721\"></polygon>\n        <polygon id=\"Line\" fill=\"#FFFFFF\" points=\"143.368007 82.1093476 152.617555 82.1093476 152.617555 81.2993476 143.368007 81.2993476\"></polygon>\n        <polygon id=\"Line-Copy-8\" fill=\"#FFFFFF\" points=\"9.24954884 82.1093476 18.4990976 82.1093476 18.4990976 81.2993476 9.24954884 81.2993476\"></polygon>\n        <polygon id=\"Line\" fill=\"#FFFFFF\" points=\"81.2993476 143.368007 81.2993476 152.617555 82.1093476 152.617555 82.1093476 143.368007\"></polygon>\n      </g>\n    </g>"
	  }
	});

	VcIconSvg.register({
	  'compass-inner': {
	    width: 17,
	    height: 17,
	    viewBox: '0 0 17 17',
	    data: "\n    <!-- Generator: Sketch 43.2 (39069) - http://www.bohemiancoding.com/sketch -->\n    <!-- <title>compass-inner</title> -->\n    <desc>Created with Sketch.</desc>\n    <defs></defs>\n    <g id=\"Page-1\" stroke=\"none\" stroke-width=\"1\" fill-rule=\"evenodd\">\n      <g id=\"compass-inner\" fill-rule=\"nonzero\">\n        <path d=\"M8.5,16.5 C4.081722,16.5 0.5,12.918278 0.5,8.5 C0.5,4.081722 4.081722,0.5 8.5,0.5 C12.918278,0.5 16.5,4.081722 16.5,8.5 C16.5,12.918278 12.918278,16.5 8.5,16.5 Z M8.5,15.5 C12.3659932,15.5 15.5,12.3659932 15.5,8.5 C15.5,4.63400675 12.3659932,1.5 8.5,1.5 C4.63400675,1.5 1.5,4.63400675 1.5,8.5 C1.5,12.3659932 4.63400675,15.5 8.5,15.5 Z\" id=\"Oval-96\"></path>\n        <path d=\"M9.92599835,7.09066832 C12.7122872,9.87695712 14.3709388,12.5452228 13.4497471,13.4664145 C12.5285555,14.3876061 9.86028979,12.7289545 7.074001,9.94266568 C4.2877122,7.15637688 2.62906055,4.48811119 3.55025221,3.56691953 C4.47144386,2.64572788 7.13970955,4.30437952 9.92599835,7.09066832 Z M9.21889157,7.7977751 C6.92836458,5.50724811 4.52075769,4.01062761 4.25735899,4.27402631 C3.99396029,4.53742501 5.49058078,6.9450319 7.78110778,9.2355589 C10.0716348,11.5260859 12.4792417,13.0227064 12.7426404,12.7593077 C13.0060391,12.495909 11.5094186,10.0883021 9.21889157,7.7977751 Z\" id=\"Oval-96-Copy-2\"></path>\n        <path d=\"M9.92599835,9.94266568 C7.13970955,12.7289545 4.47144386,14.3876061 3.55025221,13.4664145 C2.62906055,12.5452228 4.2877122,9.87695712 7.074001,7.09066832 C9.86028979,4.30437952 12.5285555,2.64572788 13.4497471,3.56691953 C14.3709388,4.48811119 12.7122872,7.15637688 9.92599835,9.94266568 Z M9.21889157,9.2355589 C11.5094186,6.9450319 13.0060391,4.53742501 12.7426404,4.27402631 C12.4792417,4.01062761 10.0716348,5.50724811 7.78110778,7.7977751 C5.49058078,10.0883021 3.99396029,12.495909 4.25735899,12.7593077 C4.52075769,13.0227064 6.92836458,11.5260859 9.21889157,9.2355589 Z\" id=\"Oval-96-Copy-3\"></path>\n        <path d=\"M15.1464466,1.1464466 L14.3453364,1.94755684 L13.9608692,2.33202401 L14.667976,3.03913077 L15.0524431,2.65466362 L15.8535534,1.8535534 L15.1464466,1.1464466 Z M2.29760014,13.995293 L1.85311902,14.4397742 L1.004311,15.2885822 L1.71141776,15.995689 L2.56022581,15.146881 L3.00470698,14.7023998 L2.29760014,13.995293 Z\" id=\"Line\"></path>\n        <circle id=\"Oval-432\" cx=\"16\" cy=\"1\" r=\"1\"></circle>\n        <circle id=\"Oval-432-Copy\" cx=\"1\" cy=\"16\" r=\"1\"></circle>\n      </g>\n    </g>\n    "
	  }
	});

	VcIconSvg.register({
	  'compass-rotation-marker': {
	    width: 53,
	    height: 53,
	    viewBox: '0 0 53 53',
	    data: "\n    <!-- Generator: Sketch 3.4.3 (16044) - http://www.bohemiancoding.com/sketch -->\n    <!-- <title>compass-rotation-marker</title> -->\n    <desc>Created with Sketch.</desc>\n    <defs></defs>\n    <g id=\"Page-1\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\">\n      <g id=\"compass-rotation-marker\">\n        <path d=\"M52.4399986,26.2199993 C52.4399986,11.7390936 40.7009051,0 26.2199993,0 C11.7390936,0 0,11.7390936 0,26.2199993 C0,40.7009051 11.7390936,52.4399986 26.2199993,52.4399986 C40.7009051,52.4399986 52.4399986,40.7009051 52.4399986,26.2199993 Z\" id=\"rotator\" stroke-opacity=\"0.135841259\" stroke=\"#E2A549\" stroke-width=\"9\" opacity=\"0.201434235\"></path>\n        <path d=\"M0,26.2199993 C0,11.7390936 11.7390936,0 26.2199993,0 L26.2199993,9 C16.7096563,9 9,16.7096563 9,26.2199993\" id=\"Shape\" opacity=\"0.634561567\" fill=\"#4990E2\"></path>\n      </g>\n    </g>"
	  }
	});

	/**
	 * Creates tweens for camera flights.
	 * <br /><br />
	 * Mouse interaction is disabled during flights.
	 *
	 * @private
	 */
	var CameraFlightPath = {};

	function getAltitude(frustum, dx, dy) {
	  var _Cesium = Cesium,
	      PerspectiveFrustum = _Cesium.PerspectiveFrustum,
	      PerspectiveOffCenterFrustum = _Cesium.PerspectiveOffCenterFrustum;
	  var near;
	  var top;
	  var right;

	  if (frustum instanceof PerspectiveFrustum) {
	    var tanTheta = Math.tan(0.5 * frustum.fovy);
	    near = frustum.near;
	    top = frustum.near * tanTheta;
	    right = frustum.aspectRatio * top;
	    return Math.max(dx * near / right, dy * near / top);
	  } else if (frustum instanceof PerspectiveOffCenterFrustum) {
	    near = frustum.near;
	    top = frustum.top;
	    right = frustum.right;
	    return Math.max(dx * near / right, dy * near / top);
	  }

	  return Math.max(dx, dy);
	}

	var scratchCart = {};
	var scratchCart2 = {};

	function createPitchFunction(startPitch, endPitch, heightFunction, pitchAdjustHeight) {
	  var _Cesium2 = Cesium,
	      defined = _Cesium2.defined,
	      CesiumMath = _Cesium2.Math;

	  if (defined(pitchAdjustHeight) && heightFunction(0.5) > pitchAdjustHeight) {
	    var startHeight = heightFunction(0.0);
	    var endHeight = heightFunction(1.0);
	    var middleHeight = heightFunction(0.5);
	    var d1 = middleHeight - startHeight;
	    var d2 = middleHeight - endHeight;
	    return function (time) {
	      var altitude = heightFunction(time);

	      if (time <= 0.5) {
	        var t1 = (altitude - startHeight) / d1;
	        return CesiumMath.lerp(startPitch, -CesiumMath.PI_OVER_TWO, t1);
	      }

	      var t2 = (altitude - endHeight) / d2;
	      return CesiumMath.lerp(-CesiumMath.PI_OVER_TWO, endPitch, 1 - t2);
	    };
	  }

	  return function (time) {
	    return CesiumMath.lerp(startPitch, endPitch, time);
	  };
	}

	function createHeightFunction(camera, destination, startHeight, endHeight, optionAltitude) {
	  var _Cesium3 = Cesium,
	      Cartesian3 = _Cesium3.Cartesian3,
	      defined = _Cesium3.defined,
	      CesiumMath = _Cesium3.Math;
	  var altitude = optionAltitude;
	  var maxHeight = Math.max(startHeight, endHeight);

	  if (!defined(altitude)) {
	    var start = camera.position;
	    var end = destination;
	    var up = camera.up;
	    var right = camera.right;
	    var frustum = camera.frustum;
	    var diff = Cartesian3.subtract(start, end, scratchCart);
	    var verticalDistance = Cartesian3.magnitude(Cartesian3.multiplyByScalar(up, Cartesian3.dot(diff, up), scratchCart2));
	    var horizontalDistance = Cartesian3.magnitude(Cartesian3.multiplyByScalar(right, Cartesian3.dot(diff, right), scratchCart2));
	    altitude = Math.min(getAltitude(frustum, verticalDistance, horizontalDistance) * 0.2, 1000000000.0);
	  }

	  if (maxHeight < altitude) {
	    var power = 8.0;
	    var factor = 1000000.0;
	    var s = -Math.pow((altitude - startHeight) * factor, 1.0 / power);
	    var e = Math.pow((altitude - endHeight) * factor, 1.0 / power);
	    return function (t) {
	      var x = t * (e - s) + s;
	      return -Math.pow(x, power) / factor + altitude;
	    };
	  }

	  return function (t) {
	    return CesiumMath.lerp(startHeight, endHeight, t);
	  };
	}

	function adjustAngleForLERP(startAngle, endAngle) {
	  var _Cesium4 = Cesium,
	      CesiumMath = _Cesium4.Math;

	  if (CesiumMath.equalsEpsilon(startAngle, CesiumMath.TWO_PI, CesiumMath.EPSILON11)) {
	    startAngle = 0.0;
	  }

	  if (endAngle > startAngle + Math.PI) {
	    startAngle += CesiumMath.TWO_PI;
	  } else if (endAngle < startAngle - Math.PI) {
	    startAngle -= CesiumMath.TWO_PI;
	  }

	  return startAngle;
	}

	var scratchStart = {};

	function createUpdateCV(scene, duration, destination, heading, pitch, roll, optionAltitude) {
	  var _Cesium5 = Cesium,
	      Cartesian2 = _Cesium5.Cartesian2,
	      Cartesian3 = _Cesium5.Cartesian3,
	      CesiumMath = _Cesium5.Math;
	  var camera = scene.camera;
	  var start = Cartesian3.clone(camera.position, scratchStart);
	  var startPitch = camera.pitch;
	  var startHeading = adjustAngleForLERP(camera.heading, heading);
	  var startRoll = adjustAngleForLERP(camera.roll, roll);
	  var heightFunction = createHeightFunction(camera, destination, start.z, destination.z, optionAltitude);

	  function update(value) {
	    var time = value.time / duration;
	    camera.setView({
	      orientation: {
	        heading: CesiumMath.lerp(startHeading, heading, time),
	        pitch: CesiumMath.lerp(startPitch, pitch, time),
	        roll: CesiumMath.lerp(startRoll, roll, time)
	      }
	    });
	    Cartesian2.lerp(start, destination, time, camera.position);
	    camera.position.z = heightFunction(time);
	  }

	  return update;
	}

	function useLongestFlight(startCart, destCart) {
	  var _Cesium6 = Cesium,
	      CesiumMath = _Cesium6.Math;

	  if (startCart.longitude < destCart.longitude) {
	    startCart.longitude += CesiumMath.TWO_PI;
	  } else {
	    destCart.longitude += CesiumMath.TWO_PI;
	  }
	}

	function useShortestFlight(startCart, destCart) {
	  var _Cesium7 = Cesium,
	      CesiumMath = _Cesium7.Math;
	  var diff = startCart.longitude - destCart.longitude;

	  if (diff < -CesiumMath.PI) {
	    startCart.longitude += CesiumMath.TWO_PI;
	  } else if (diff > CesiumMath.PI) {
	    destCart.longitude += CesiumMath.TWO_PI;
	  }
	}

	var scratchStartCart = {};
	var scratchEndCart = {};

	function createUpdate3D(scene, duration, destination, heading, pitch, roll, optionAltitude, optionFlyOverLongitude, optionFlyOverLongitudeWeight, optionPitchAdjustHeight) {
	  var _Cesium8 = Cesium,
	      Cartesian3 = _Cesium8.Cartesian3,
	      Cartographic = _Cesium8.Cartographic,
	      defined = _Cesium8.defined,
	      CesiumMath = _Cesium8.Math;
	  var camera = scene.camera;
	  var projection = scene.mapProjection;
	  var ellipsoid = projection.ellipsoid;
	  var startCart = Cartographic.clone(camera.positionCartographic, scratchStartCart);
	  var startPitch = camera.pitch;
	  var startHeading = adjustAngleForLERP(camera.heading, heading);
	  var startRoll = adjustAngleForLERP(camera.roll, roll);
	  var destCart = ellipsoid.cartesianToCartographic(destination, scratchEndCart);
	  startCart.longitude = CesiumMath.zeroToTwoPi(startCart.longitude);
	  destCart.longitude = CesiumMath.zeroToTwoPi(destCart.longitude);
	  var useLongFlight = false;

	  if (defined(optionFlyOverLongitude)) {
	    var hitLon = CesiumMath.zeroToTwoPi(optionFlyOverLongitude);
	    var lonMin = Math.min(startCart.longitude, destCart.longitude);
	    var lonMax = Math.max(startCart.longitude, destCart.longitude);
	    var hitInside = hitLon >= lonMin && hitLon <= lonMax;

	    if (defined(optionFlyOverLongitudeWeight)) {
	      // Distance inside  (0...2Pi)
	      var din = Math.abs(startCart.longitude - destCart.longitude); // Distance outside (0...2Pi)

	      var dot = CesiumMath.TWO_PI - din;
	      var hitDistance = hitInside ? din : dot;
	      var offDistance = hitInside ? dot : din;

	      if (hitDistance < offDistance * optionFlyOverLongitudeWeight && !hitInside) {
	        useLongFlight = true;
	      }
	    } else if (!hitInside) {
	      useLongFlight = true;
	    }
	  }

	  if (useLongFlight) {
	    useLongestFlight(startCart, destCart);
	  } else {
	    useShortestFlight(startCart, destCart);
	  }

	  var heightFunction = createHeightFunction(camera, destination, startCart.height, destCart.height, optionAltitude);
	  var pitchFunction = createPitchFunction(startPitch, pitch, heightFunction, optionPitchAdjustHeight); // Isolate scope for update function.
	  // to have local copies of vars used in lerp
	  // Othervise, if you call nex
	  // createUpdate3D (createAnimationTween)
	  // before you played animation, variables will be overwriten.

	  function isolateUpdateFunction() {
	    var startLongitude = startCart.longitude;
	    var destLongitude = destCart.longitude;
	    var startLatitude = startCart.latitude;
	    var destLatitude = destCart.latitude;
	    return function update(value) {
	      var time = value.time / duration;
	      var position = Cartesian3.fromRadians(CesiumMath.lerp(startLongitude, destLongitude, time), CesiumMath.lerp(startLatitude, destLatitude, time), heightFunction(time));
	      camera.setView({
	        destination: position,
	        orientation: {
	          heading: CesiumMath.lerp(startHeading, heading, time),
	          pitch: pitchFunction(time),
	          roll: CesiumMath.lerp(startRoll, roll, time)
	        }
	      });
	    };
	  }

	  return isolateUpdateFunction();
	}

	function createUpdate2D(scene, duration, destination, heading, pitch, roll, optionAltitude) {
	  var _Cesium9 = Cesium,
	      Cartesian2 = _Cesium9.Cartesian2,
	      Cartesian3 = _Cesium9.Cartesian3,
	      CesiumMath = _Cesium9.Math;
	  var camera = scene.camera;
	  var start = Cartesian3.clone(camera.position, scratchStart);
	  var startHeading = adjustAngleForLERP(camera.heading, heading);
	  var startHeight = camera.frustum.right - camera.frustum.left;
	  var heightFunction = createHeightFunction(camera, destination, startHeight, destination.z, optionAltitude);

	  function update(value) {
	    var time = value.time / duration;
	    camera.setView({
	      orientation: {
	        heading: CesiumMath.lerp(startHeading, heading, time)
	      }
	    });
	    Cartesian2.lerp(start, destination, time, camera.position);
	    var zoom = heightFunction(time);
	    var frustum = camera.frustum;
	    var ratio = frustum.top / frustum.right;
	    var incrementAmount = (zoom - (frustum.right - frustum.left)) * 0.5;
	    frustum.right += incrementAmount;
	    frustum.left -= incrementAmount;
	    frustum.top = ratio * frustum.right;
	    frustum.bottom = -frustum.top;
	  }

	  return update;
	}

	var scratchCartographic = {};
	var scratchDestination = {};

	function emptyFlight(complete, cancel) {
	  return {
	    startObject: {},
	    stopObject: {},
	    duration: 0.0,
	    complete: complete,
	    cancel: cancel
	  };
	}

	function wrapCallback(controller, cb) {
	  function wrapped() {
	    if (typeof cb === 'function') {
	      cb();
	    }

	    controller.enableInputs = true;
	  }

	  return wrapped;
	}

	CameraFlightPath.createTween = function (scene, options) {
	  var _Cesium10 = Cesium,
	      Cartesian2 = _Cesium10.Cartesian2,
	      Cartesian3 = _Cesium10.Cartesian3,
	      defaultValue = _Cesium10.defaultValue,
	      defined = _Cesium10.defined,
	      DeveloperError = _Cesium10.DeveloperError,
	      EasingFunction = _Cesium10.EasingFunction,
	      CesiumMath = _Cesium10.Math,
	      SceneMode = _Cesium10.SceneMode;
	  options = defaultValue(options, defaultValue.EMPTY_OBJECT);
	  var destination = options.destination; // >>includeStart('debug', pragmas.debug);

	  if (!defined(scene)) {
	    throw new DeveloperError('scene is required.');
	  }

	  if (!defined(destination)) {
	    throw new DeveloperError('destination is required.');
	  } // >>includeEnd('debug');


	  var mode = scene.mode;

	  if (mode === SceneMode.MORPHING) {
	    return emptyFlight();
	  }

	  var convert = defaultValue(options.convert, true);
	  var projection = scene.mapProjection;
	  var ellipsoid = projection.ellipsoid;
	  var maximumHeight = options.maximumHeight;
	  var flyOverLongitude = options.flyOverLongitude;
	  var flyOverLongitudeWeight = options.flyOverLongitudeWeight;
	  var pitchAdjustHeight = options.pitchAdjustHeight;
	  var easingFunction = options.easingFunction;

	  if (convert && mode !== SceneMode.SCENE3D) {
	    ellipsoid.cartesianToCartographic(destination, scratchCartographic);
	    destination = projection.project(scratchCartographic, scratchDestination);
	  }

	  var camera = scene.camera;
	  var transform = options.endTransform;

	  if (defined(transform)) {
	    camera._setTransform(transform);
	  }

	  var duration = options.duration;

	  if (!defined(duration)) {
	    duration = Math.ceil(Cartesian3.distance(camera.position, destination) / 1000000.0) + 2.0;
	    duration = Math.min(duration, 3.0);
	  }

	  var heading = defaultValue(options.heading, 0.0);
	  var pitch = defaultValue(options.pitch, -CesiumMath.PI_OVER_TWO);
	  var roll = defaultValue(options.roll, 0.0);
	  var controller = scene.screenSpaceCameraController;
	  controller.enableInputs = false;
	  var complete = wrapCallback(controller, options.complete);
	  var cancel = wrapCallback(controller, options.cancel);
	  var frustum = camera.frustum;
	  var empty = scene.mode === SceneMode.SCENE2D;
	  empty = empty && Cartesian2.equalsEpsilon(camera.position, destination, CesiumMath.EPSILON6);
	  empty = empty && CesiumMath.equalsEpsilon(Math.max(frustum.right - frustum.left, frustum.top - frustum.bottom), destination.z, CesiumMath.EPSILON6);
	  empty = empty || scene.mode !== SceneMode.SCENE2D && Cartesian3.equalsEpsilon(destination, camera.position, CesiumMath.EPSILON10);
	  empty = empty && CesiumMath.equalsEpsilon(CesiumMath.negativePiToPi(heading), CesiumMath.negativePiToPi(camera.heading), CesiumMath.EPSILON10) && CesiumMath.equalsEpsilon(CesiumMath.negativePiToPi(pitch), CesiumMath.negativePiToPi(camera.pitch), CesiumMath.EPSILON10) && CesiumMath.equalsEpsilon(CesiumMath.negativePiToPi(roll), CesiumMath.negativePiToPi(camera.roll), CesiumMath.EPSILON10);

	  if (empty) {
	    return emptyFlight(complete, cancel);
	  }

	  var updateFunctions = new Array(4);
	  updateFunctions[SceneMode.SCENE2D] = createUpdate2D;
	  updateFunctions[SceneMode.SCENE3D] = createUpdate3D;
	  updateFunctions[SceneMode.COLUMBUS_VIEW] = createUpdateCV;

	  if (duration <= 0.0) {
	    var newOnComplete = function newOnComplete() {
	      var update = updateFunctions[mode](scene, 1.0, destination, heading, pitch, roll, maximumHeight, flyOverLongitude, flyOverLongitudeWeight, pitchAdjustHeight);
	      update({
	        time: 1.0
	      });

	      if (typeof complete === 'function') {
	        complete();
	      }
	    };

	    return emptyFlight(newOnComplete, cancel);
	  }

	  var update = updateFunctions[mode](scene, duration, destination, heading, pitch, roll, maximumHeight, flyOverLongitude, flyOverLongitudeWeight, pitchAdjustHeight);

	  if (!defined(easingFunction)) {
	    var startHeight = camera.positionCartographic.height;
	    var endHeight = mode === SceneMode.SCENE3D ? ellipsoid.cartesianToCartographic(destination).height : destination.z;

	    if (startHeight > endHeight && startHeight > 11500.0) {
	      easingFunction = EasingFunction.CUBIC_OUT;
	    } else {
	      easingFunction = EasingFunction.QUINTIC_IN_OUT;
	    }
	  }

	  return {
	    duration: duration,
	    easingFunction: easingFunction,
	    startObject: {
	      time: 0.0
	    },
	    stopObject: {
	      time: duration
	    },
	    update: update,
	    complete: complete,
	    cancel: cancel
	  };
	};

	//
	var vectorScratch = {};
	var oldTransformScratch = {};
	var newTransformScratch = {};
	var centerScratch = {};
	var script$1C = {
	  name: 'vc-compass',
	  props: {
	    enableCompassOuterRing: Boolean
	  },
	  data: function data() {
	    return {
	      heading: 0,
	      orbitCursorAngle: 0,
	      orbitCursorOpacity: 0
	    };
	  },
	  components: {
	    VcIconSvg: VcIconSvg
	  },
	  computed: {
	    outerCircleStyle: function outerCircleStyle() {
	      return {
	        transform: 'rotate(-' + this.heading + 'rad)',
	        WebkitTransform: 'rotate(-' + this.heading + 'rad)',
	        opacity: ''
	      };
	    },
	    rotationMarkerStyle: function rotationMarkerStyle() {
	      return {
	        transform: 'rotate(-' + this.orbitCursorAngle + 'rad)',
	        WebkitTransform: 'rotate(-' + this.orbitCursorAngle + 'rad)',
	        opacity: this.orbitCursorOpacity
	      };
	    }
	  },
	  mounted: function mounted() {
	    var _this = this;

	    this.$parent.createPromise.then(function (_ref) {
	      var Cesium = _ref.Cesium,
	          viewer = _ref.viewer,
	          cesiumObject = _ref.cesiumObject;
	      _this.viewer = viewer;
	      _this._unsubscribeFromViewerChange = _this.viewer.afterViewerChanged.addEventListener(function () {
	        return viewerChange(_this);
	      });
	      viewerChange(_this);
	    });
	  },
	  destroyed: function destroyed() {
	    document.removeEventListener('mousemove', this.orbitMouseMoveFunction, false);
	    document.removeEventListener('mouseup', this.orbitMouseUpFunction, false);
	    document.removeEventListener('touchmove', this.orbitMouseMoveFunction, false);
	    document.removeEventListener('touchend', this.orbitMouseUpFunction, false);
	    this._unsubscribeFromClockTick && this._unsubscribeFromClockTick();
	    this._unsubscribeFromPostRender && this._unsubscribeFromPostRender();
	    this._unsubscribeFromViewerChange && this._unsubscribeFromViewerChange();
	  },
	  methods: {
	    handleMouseDown: function handleMouseDown(e) {
	      if (e.stopPropagation) e.stopPropagation();
	      if (e.preventDefault) e.preventDefault();
	      var _Cesium = Cesium,
	          SceneMode = _Cesium.SceneMode;
	      var scene = this.viewer.scene;

	      if (scene.mode === SceneMode.MORPHING) {
	        return true;
	      }

	      var _Cesium2 = Cesium,
	          Cartesian2 = _Cesium2.Cartesian2;
	      var compassElement = e.currentTarget;
	      var compassRectangle = e.currentTarget.getBoundingClientRect();
	      var maxDistance = compassRectangle.width / 2.0;
	      var center = new Cartesian2((compassRectangle.right - compassRectangle.left) / 2.0, (compassRectangle.bottom - compassRectangle.top) / 2.0);
	      var clickLocation = event.type === 'mousedown' ? new Cartesian2(event.clientX - compassRectangle.left, event.clientY - compassRectangle.top) : new Cartesian2(event.changedTouches[0].clientX - compassRectangle.left, event.changedTouches[0].clientY - compassRectangle.top);
	      var vector = Cartesian2.subtract(clickLocation, center, vectorScratch);
	      var distanceFromCenter = Cartesian2.magnitude(vector);
	      var distanceFraction = distanceFromCenter / maxDistance;
	      var nominalTotalRadius = 145;
	      var norminalGyroRadius = 50;

	      if (distanceFraction < norminalGyroRadius / nominalTotalRadius) {
	        orbit(this, compassElement, vector);
	      } else if (distanceFraction < 1.0) {
	        rotate(this, compassElement, vector);
	      } else {
	        return true;
	      }
	    },
	    handleDoubleClick: function handleDoubleClick(e) {
	      var _Cesium3 = Cesium,
	          Cartesian2 = _Cesium3.Cartesian2,
	          Cartesian3 = _Cesium3.Cartesian3,
	          defined = _Cesium3.defined,
	          Ellipsoid = _Cesium3.Ellipsoid,
	          Matrix4 = _Cesium3.Matrix4,
	          Ray = _Cesium3.Ray,
	          SceneMode = _Cesium3.SceneMode,
	          Transforms = _Cesium3.Transforms;
	      var scene = this.viewer.scene;
	      var camera = scene.camera;
	      var sscc = scene.screenSpaceCameraController;

	      if (scene.mode === SceneMode.MORPHING || !sscc.enableInputs) {
	        return true;
	      }

	      if (scene.mode === SceneMode.COLUMBUS_VIEW && !sscc.enableTranslate) {
	        return;
	      }

	      if (scene.mode === SceneMode.SCENE3D || scene.mode === SceneMode.COLUMBUS_VIEW) {
	        if (!sscc.enableLook) {
	          return;
	        }

	        if (scene.mode === SceneMode.SCENE3D) {
	          if (!sscc.enableRotate) {
	            return;
	          }
	        }
	      }

	      var windowPosition = new Cartesian2();
	      windowPosition.x = scene.canvas.clientWidth / 2;
	      windowPosition.y = scene.canvas.clientHeight / 2;
	      var pickRayScratch = new Ray();
	      var ray = camera.getPickRay(windowPosition, pickRayScratch);
	      var center = scene.globe.pick(ray, scene, centerScratch);

	      if (!defined(center)) {
	        // Globe is barely visible, so reset to home view.
	        this.viewer.camera.flyHome();
	        return;
	      }

	      var rotateFrame = Transforms.eastNorthUpToFixedFrame(center, Ellipsoid.WGS84);
	      var lookVector = Cartesian3.subtract(center, camera.position, new Cartesian3());
	      var flight = CameraFlightPath.createTween(scene, {
	        destination: Matrix4.multiplyByPoint(rotateFrame, new Cartesian3(0.0, 0.0, Cartesian3.magnitude(lookVector)), new Cartesian3()),
	        direction: Matrix4.multiplyByPointAsVector(rotateFrame, new Cartesian3(0.0, 0.0, -1.0), new Cartesian3()),
	        up: Matrix4.multiplyByPointAsVector(rotateFrame, new Cartesian3(0.0, 1.0, 0.0), new Cartesian3()),
	        duration: 1.5
	      });
	      scene.tweens.add(flight);
	    },
	    resetRotater: function resetRotater() {
	      this.orbitCursorOpacity = 0;
	      this.orbitCursorAngle = 0;
	    }
	  }
	};

	function viewerChange(viewModel) {
	  var _Cesium4 = Cesium,
	      defined = _Cesium4.defined;

	  if (defined(viewModel.viewer)) {
	    if (viewModel._unsubscribeFromPostRender) {
	      viewModel._unsubscribeFromPostRender();

	      viewModel._unsubscribeFromPostRender = undefined;
	    }

	    viewModel._unsubscribeFromPostRender = viewModel.viewer.scene.postRender.addEventListener(function () {
	      viewModel.heading = viewModel.viewer.scene.camera.heading;
	    });
	  } else {
	    if (viewModel._unsubscribeFromPostRender) {
	      viewModel._unsubscribeFromPostRender();

	      viewModel._unsubscribeFromPostRender = undefined;
	    }

	    viewModel.showCompass = false;
	  }
	}

	function orbit(viewModel, compassElement, cursorVector) {
	  var _Cesium5 = Cesium,
	      Cartesian2 = _Cesium5.Cartesian2,
	      Cartesian3 = _Cesium5.Cartesian3,
	      defined = _Cesium5.defined,
	      getTimestamp = _Cesium5.getTimestamp,
	      CesiumMath = _Cesium5.Math,
	      Matrix4 = _Cesium5.Matrix4,
	      Ellipsoid = _Cesium5.Ellipsoid,
	      Ray = _Cesium5.Ray,
	      SceneMode = _Cesium5.SceneMode,
	      Transforms = _Cesium5.Transforms;
	  var scene = viewModel.viewer.scene;
	  var camera = scene.camera;
	  var sscc = scene.screenSpaceCameraController; // do not orbit if it is disabled

	  if (scene.mode === SceneMode.MORPHING || !sscc.enableInputs) {
	    return;
	  }

	  switch (scene.mode) {
	    case SceneMode.COLUMBUS_VIEW:
	      if (sscc.enableLook) {
	        break;
	      }

	      if (!sscc.enableTranslate || !sscc.enableTilt) {
	        return;
	      }

	      break;

	    case SceneMode.SCENE3D:
	      if (sscc.enableLook) {
	        break;
	      }

	      if (!sscc.enableTilt || !sscc.enableRotate) {
	        return;
	      }

	      break;

	    case Cesium.SceneMode.SCENE2D:
	      if (!sscc.enableTranslate) {
	        return;
	      }

	      break;
	  } // Remove existing event handlers, if any.


	  document.removeEventListener('mousemove', viewModel.orbitMouseMoveFunction, false);
	  document.removeEventListener('mouseup', viewModel.orbitMouseUpFunction, false);
	  document.removeEventListener('touchmove', viewModel.orbitMouseMoveFunction, false);
	  document.removeEventListener('touchend', viewModel.orbitMouseUpFunction, false);

	  if (defined(viewModel.orbitTickFunction)) {
	    viewModel.viewer.clock.onTick.removeEventListener(viewModel.orbitTickFunction);
	  }

	  viewModel.orbitMouseMoveFunction = undefined;
	  viewModel.orbitMouseUpFunction = undefined;
	  viewModel.orbitTickFunction = undefined;
	  viewModel.isOrbiting = true;
	  viewModel.orbitLastTimestamp = getTimestamp();
	  var windowPosition = new Cartesian2();
	  windowPosition.x = scene.canvas.clientWidth / 2;
	  windowPosition.y = scene.canvas.clientHeight / 2;
	  var pickRayScratch = new Ray();
	  var ray = camera.getPickRay(windowPosition, pickRayScratch);
	  var center = scene.globe.pick(ray, scene, centerScratch);

	  if (!defined(center)) {
	    viewModel.orbitFrame = Transforms.eastNorthUpToFixedFrame(camera.positionWC, Ellipsoid.WGS84, newTransformScratch);
	    viewModel.orbitIsLook = true;
	  } else {
	    viewModel.orbitFrame = Transforms.eastNorthUpToFixedFrame(center, Ellipsoid.WGS84, newTransformScratch);
	    viewModel.orbitIsLook = false;
	  }

	  viewModel.orbitTickFunction = function (e) {
	    var timestamp = getTimestamp();
	    var deltaT = timestamp - viewModel.orbitLastTimestamp;
	    var rate = (viewModel.orbitCursorOpacity - 0.5) * 2.5 / 1000;
	    var distance = deltaT * rate;
	    var angle = viewModel.orbitCursorAngle + CesiumMath.PI_OVER_TWO;
	    var x = Math.cos(angle) * distance;
	    var y = Math.sin(angle) * distance;
	    scene = viewModel.viewer.scene;
	    camera = scene.camera;
	    var oldTransform = Matrix4.clone(camera.transform, oldTransformScratch);
	    camera.lookAtTransform(viewModel.orbitFrame);

	    if (viewModel.orbitIsLook) {
	      camera.look(Cartesian3.UNIT_Z, -x);
	      camera.look(camera.right, -y);
	    } else {
	      camera.rotateLeft(x);
	      camera.rotateUp(y);
	    }

	    camera.lookAtTransform(oldTransform);
	    viewModel.orbitLastTimestamp = timestamp;
	  };

	  function updateAngleAndOpacity(vector, compassWidth) {
	    var angle = Math.atan2(-vector.y, vector.x);
	    viewModel.orbitCursorAngle = CesiumMath.zeroToTwoPi(angle - CesiumMath.PI_OVER_TWO);
	    var distance = Cartesian2.magnitude(vector);
	    var maxDistance = compassWidth / 2.0;
	    var distanceFraction = Math.min(distance / maxDistance, 1.0);
	    var easedOpacity = 0.5 * distanceFraction * distanceFraction + 0.5;
	    viewModel.orbitCursorOpacity = easedOpacity;
	  }

	  viewModel.orbitMouseMoveFunction = function (e) {
	    var compassRectangle = compassElement.getBoundingClientRect();
	    center = new Cartesian2((compassRectangle.right - compassRectangle.left) / 2.0, (compassRectangle.bottom - compassRectangle.top) / 2.0);
	    var clickLocation = event.type === 'mousemove' ? new Cartesian2(event.clientX - compassRectangle.left, event.clientY - compassRectangle.top) : new Cartesian2(event.changedTouches[0].clientX - compassRectangle.left, event.changedTouches[0].clientY - compassRectangle.top);
	    var vector = Cartesian2.subtract(clickLocation, center, vectorScratch);
	    updateAngleAndOpacity(vector, compassRectangle.width);
	  };

	  viewModel.orbitMouseUpFunction = function (e) {
	    // TODO: if mouse didn't move, reset view to looking down, north is up?
	    viewModel.isOrbiting = false;
	    document.removeEventListener('mousemove', viewModel.orbitMouseMoveFunction, false);
	    document.removeEventListener('mouseup', viewModel.orbitMouseUpFunction, false);
	    document.removeEventListener('touchmove', viewModel.orbitMouseMoveFunction, false);
	    document.removeEventListener('touchend', viewModel.orbitMouseUpFunction, false);

	    if (defined(viewModel.orbitTickFunction)) {
	      viewModel.viewer.clock.onTick.removeEventListener(viewModel.orbitTickFunction);
	    }

	    viewModel.orbitMouseMoveFunction = undefined;
	    viewModel.orbitMouseUpFunction = undefined;
	    viewModel.orbitTickFunction = undefined;
	  };

	  document.addEventListener('mousemove', viewModel.orbitMouseMoveFunction, false);
	  document.addEventListener('mouseup', viewModel.orbitMouseUpFunction, false);
	  document.addEventListener('touchmove', viewModel.orbitMouseMoveFunction, false);
	  document.addEventListener('touchend', viewModel.orbitMouseUpFunction, false);
	  viewModel._unsubscribeFromClockTick = viewModel.viewer.clock.onTick.addEventListener(viewModel.orbitTickFunction);
	  updateAngleAndOpacity(cursorVector, compassElement.getBoundingClientRect().width);
	}

	function rotate(viewModel, compassElement, cursorVector) {
	  if (!viewModel.enableCompassOuterRing) {
	    return;
	  }

	  var scene = viewModel.viewer.scene;
	  var camera = scene.camera;
	  var sscc = scene.screenSpaceCameraController; // do not rotate in 2D mode or if rotating is disabled

	  if (scene.mode === Cesium.SceneMode.MORPHING || scene.mode === Cesium.SceneMode.SCENE2D || !sscc.enableInputs) {
	    return;
	  }

	  if (!sscc.enableLook && (scene.mode === Cesium.SceneMode.COLUMBUS_VIEW || scene.mode === Cesium.SceneMode.SCENE3D && !sscc.enableRotate)) {
	    return;
	  } // Remove existing event handlers, if any.


	  document.removeEventListener('mousemove', viewModel.rotateMouseMoveFunction, false);
	  document.removeEventListener('touchmove', viewModel.rotateMouseMoveFunction, false);
	  document.removeEventListener('mouseup', viewModel.rotateMouseUpFunction, false);
	  document.removeEventListener('touchend', viewModel.rotateMouseUpFunction, false);
	  var _Cesium6 = Cesium,
	      Cartesian2 = _Cesium6.Cartesian2,
	      Cartesian3 = _Cesium6.Cartesian3,
	      defined = _Cesium6.defined,
	      CesiumMath = _Cesium6.Math,
	      Matrix4 = _Cesium6.Matrix4,
	      Ellipsoid = _Cesium6.Ellipsoid,
	      Ray = _Cesium6.Ray,
	      Transforms = _Cesium6.Transforms;
	  viewModel.rotateMouseMoveFunction = undefined;
	  viewModel.rotateMouseUpFunction = undefined;
	  viewModel.isRotating = true;
	  viewModel.rotateInitialCursorAngle = Math.atan2(-cursorVector.y, cursorVector.x);
	  var windowPosition = new Cartesian2();
	  windowPosition.x = scene.canvas.clientWidth / 2;
	  windowPosition.y = scene.canvas.clientHeight / 2;
	  var pickRayScratch = new Ray();
	  var ray = camera.getPickRay(windowPosition, pickRayScratch);
	  var viewCenter = scene.globe.pick(ray, scene, centerScratch);

	  if (!defined(viewCenter)) {
	    viewModel.rotateFrame = Transforms.eastNorthUpToFixedFrame(camera.positionWC, Ellipsoid.WGS84, newTransformScratch);
	    viewModel.rotateIsLook = true;
	  } else {
	    viewModel.rotateFrame = Transforms.eastNorthUpToFixedFrame(viewCenter, Ellipsoid.WGS84, newTransformScratch);
	    viewModel.rotateIsLook = false;
	  }

	  var oldTransform = Matrix4.clone(camera.transform, oldTransformScratch);
	  camera.lookAtTransform(viewModel.rotateFrame);
	  viewModel.rotateInitialCameraAngle = Math.atan2(camera.position.y, camera.position.x);
	  viewModel.rotateInitialCameraDistance = Cartesian3.magnitude(new Cartesian3(camera.position.x, camera.position.y, 0.0));
	  camera.lookAtTransform(oldTransform);

	  viewModel.rotateMouseMoveFunction = function (e) {
	    var compassRectangle = compassElement.getBoundingClientRect();
	    var center = new Cartesian2((compassRectangle.right - compassRectangle.left) / 2.0, (compassRectangle.bottom - compassRectangle.top) / 2.0);
	    var clickLocation = event.type === 'mousedown' || event.type === 'mousemove' ? new Cartesian2(event.clientX - compassRectangle.left, event.clientY - compassRectangle.top) : new Cartesian2(event.changedTouches[0].clientX - compassRectangle.left, event.changedTouches[0].clientY - compassRectangle.top);
	    var vector = Cartesian2.subtract(clickLocation, center, vectorScratch);
	    var angle = Math.atan2(-vector.y, vector.x);
	    var angleDifference = angle - viewModel.rotateInitialCursorAngle;
	    var newCameraAngle = CesiumMath.zeroToTwoPi(viewModel.rotateInitialCameraAngle - angleDifference);
	    camera = viewModel.viewer.scene.camera;
	    oldTransform = Matrix4.clone(camera.transform, oldTransformScratch);
	    camera.lookAtTransform(viewModel.rotateFrame);
	    var currentCameraAngle = Math.atan2(camera.position.y, camera.position.x);
	    camera.rotateRight(newCameraAngle - currentCameraAngle);
	    camera.lookAtTransform(oldTransform);
	  };

	  viewModel.rotateMouseUpFunction = function (e) {
	    viewModel.isRotating = false;
	    document.removeEventListener('mousemove', viewModel.rotateMouseMoveFunction, false);
	    document.removeEventListener('touchmove', viewModel.rotateMouseMoveFunction, false);
	    document.removeEventListener('mouseup', viewModel.rotateMouseUpFunction, false);
	    document.removeEventListener('touchend', viewModel.rotateMouseUpFunction, false);
	    viewModel.rotateMouseMoveFunction = undefined;
	    viewModel.rotateMouseUpFunction = undefined;
	  };

	  document.addEventListener('mousemove', viewModel.rotateMouseMoveFunction, false);
	  document.addEventListener('touchmove', viewModel.rotateMouseMoveFunction, false);
	  document.addEventListener('mouseup', viewModel.rotateMouseUpFunction, false);
	  document.addEventListener('touchend', viewModel.rotateMouseUpFunction, false);
	}

	/* script */
	var __vue_script__$1C = script$1C;
	/* template */

	var __vue_render__$9 = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('div', {
	    staticClass: "vc-compass",
	    attrs: {
	      "title": _vm.$vc.lang.navigation.compass.description
	    },
	    on: {
	      "dblclick": _vm.handleDoubleClick,
	      "mousedown": _vm.handleMouseDown,
	      "mouseup": _vm.resetRotater,
	      "touchend": _vm.resetRotater,
	      "touchstart": _vm.handleMouseDown
	    }
	  }, [_c('div', {
	    staticClass: "vc-compass-outerRing",
	    style: _vm.outerCircleStyle
	  }, [_c('vc-icon-svg', {
	    attrs: {
	      "name": "compass-outer"
	    }
	  })], 1), _vm._v(" "), _c('div', {
	    staticClass: "vc-compass-innerRing"
	  }, [_c('vc-icon-svg', {
	    attrs: {
	      "name": "compass-inner"
	    }
	  })], 1), _vm._v(" "), _c('div', {
	    staticClass: "vc-compass-rotation-marker",
	    style: _vm.rotationMarkerStyle
	  }, [_c('vc-icon-svg', {
	    attrs: {
	      "name": "compass-rotation-marker"
	    }
	  })], 1)]);
	};

	var __vue_staticRenderFns__$9 = [];
	/* style */

	var __vue_inject_styles__$1C = undefined;
	/* scoped */

	var __vue_scope_id__$1C = undefined;
	/* functional template */

	var __vue_is_functional_template__$1C = false;
	/* component normalizer */

	function __vue_normalize__$1C(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "VcCompass.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var VcCompass = __vue_normalize__$1C({
	  render: __vue_render__$9,
	  staticRenderFns: __vue_staticRenderFns__$9
	}, __vue_inject_styles__$1C, __vue_script__$1C, __vue_scope_id__$1C, __vue_is_functional_template__$1C);

	VcIconSvg.register({
	  increase: {
	    width: 50,
	    height: 50,
	    viewBox: '0 0 50 50',
	    data: "\n    <!-- Generator: Sketch 3.4.3 (16044) - http://www.bohemiancoding.com/sketch -->\n    <!-- <title>increase</title> -->\n    <path d=\"M0,25 C0,25.3514939 0.131810207,25.659051 0.373462207,25.900703 C0.615114207,26.142355 0.922671379,26.2741652 1.27416517,26.2741652 L23.7258348,26.2741652 L23.7258348,48.7258348 C23.7258348,49.0773286 23.857645,49.3848858 24.099297,49.6265378 C24.3189807,49.8462214 24.6485061,50 25,50 C25.7029877,50 26.2741652,49.4288225 26.2741652,48.7258348 L26.2741652,26.2741652 L48.7258348,26.2741652 C49.4288225,26.2741652 50,25.7029877 50,25 C50,24.2970123 49.4288225,23.7258348 48.7258348,23.7258348 L26.2741652,23.7258348 L26.2741652,1.27416517 C26.2741652,0.571177517 25.7029877,0 25,0 C24.2970123,0 23.7258348,0.571177517 23.7258348,1.27416517 L23.7258348,23.7258348 L1.27416517,23.7258348 C0.571177517,23.7258348 0,24.2970123 0,25 L0,25 L0,25 L0,25 Z\" id=\"Shape\"></path>"
	  }
	});

	VcIconSvg.register({
	  decrease: {
	    width: 50,
	    height: 6,
	    viewBox: '0 0 50 6',
	    data: "\n    <!-- Generator: Sketch 3.4.3 (16044) - http://www.bohemiancoding.com/sketch -->\n    <!-- <title>decrease</title> -->\n    <path d=\"M46.6183575,0.657894737 L3.30112724,0.657894737 C1.44927539,0.657894737 0,1.66880618 0,2.96052632 C0,4.25224645 1.44927539,5.26315789 3.30112724,5.26315789 L46.6988728,5.26315789 C48.5507246,5.26315789 50,4.25224645 50,2.96052632 C49.9194847,1.66880618 48.4702093,0.657894737 46.6183575,0.657894737 L46.6183575,0.657894737 L46.6183575,0.657894737 Z\" id=\"Shape\"></path>"
	  }
	});

	VcIconSvg.register({
	  refresh: {
	    width: 50,
	    height: 50,
	    viewBox: '0 0 50 50',
	    data: "\n    <!-- Generator: Sketch 3.4.3 (16044) - http://www.bohemiancoding.com/sketch -->\n    <!-- <title>refresh</title>  -->\n    <path d=\"M48.2758621,0 C47.2844828,0 46.5086207,0.775193846 46.5086207,1.76571923 L46.5086207,12.2308355 C42.0689655,4.78036173 34.0086207,0 25,0 C11.2068965,0 0,11.1972438 0,25.0215332 C0,38.8458226 11.2068965,50 25,50 C38.7931035,50 50,38.8027562 50,25.0215332 C50,24.0310078 49.2241379,23.2558139 48.2327587,23.2558139 C47.2413793,23.2558139 46.4655172,24.0310078 46.4655172,25.0215332 C46.4655172,36.8647717 36.8103448,46.5116279 24.9568965,46.5116279 C13.1034483,46.5116279 3.49137933,36.8217054 3.49137933,24.9784668 C3.49137933,13.1352283 13.1465517,3.48837212 25,3.48837212 C33.4913793,3.48837212 41.0775862,8.44099913 44.5258621,16.0206718 L32.1551724,16.0206718 C31.1637931,16.0206718 30.3879311,16.7958657 30.3879311,17.7863911 C30.3879311,18.7769164 31.1637931,19.5521103 32.1551724,19.5521103 L48.2327587,19.5521103 C49.2241379,19.5521103 50,18.7769164 50,17.7863911 L50,1.72265288 C50,0.775193846 49.2241379,0 48.2758621,0 L48.2758621,0 L48.2758621,0 Z\" id=\"Shape\"></path>"
	  }
	});

	//
	var script$1D = {
	  name: 'vc-zoomControl',
	  components: {
	    VcIconSvg: VcIconSvg
	  },
	  props: {
	    defaultResetView: Object,
	    zoomAmount: Number,
	    overrideCamera: Boolean
	  },
	  mounted: function mounted() {
	    var _this = this;

	    this.$parent.createPromise.then(function (_ref) {
	      var Cesium = _ref.Cesium,
	          viewer = _ref.viewer,
	          cesiumObject = _ref.cesiumObject;
	      _this.viewer = viewer;

	      if (_this.overrideCamera) {
	        var resetView = _this.defaultResetView;

	        if (resetView && resetView.lng) {
	          viewer.camera.setView({
	            destination: Cesium.Cartesian3.fromDegrees(resetView.lng, resetView.lat, resetView.height),
	            orientation: {
	              heading: Cesium.Math.toRadians(resetView.heading || 360),
	              pitch: Cesium.Math.toRadians(resetView.pitch || -90),
	              roll: Cesium.Math.toRadians(resetView.roll || 0)
	            }
	          });
	        } else if (resetView && resetView.west) {
	          try {
	            var rectangle = Cesium.Rectangle.fromDegrees(resetView.west, resetView.south, resetView.east, resetView.north);
	            Cesium.Rectangle.validate(rectangle);
	            viewer.camera.setView({
	              destination: rectangle,
	              orientation: {
	                heading: Cesium.Math.toRadians(5.729578)
	              }
	            });
	          } catch (e) {
	            console.error('[VueCesium] ERROR: options.defaultResetView Cesium rectangle is  invalid!');
	          }
	        }
	      }
	    });
	  },
	  methods: {
	    zoomIn: function zoomIn() {
	      this.zoom(1 / this.zoomAmount);
	    },
	    zoomOut: function zoomOut() {
	      this.zoom(this.zoomAmount);
	    },
	    zoom: function zoom(relativeAmount) {
	      var _Cesium = Cesium,
	          Cartesian3 = _Cesium.Cartesian3,
	          defined = _Cesium.defined,
	          IntersectionTests = _Cesium.IntersectionTests,
	          Ray = _Cesium.Ray,
	          SceneMode = _Cesium.SceneMode;

	      if (defined(this.viewer)) {
	        var scene = this.viewer.scene;
	        var sscc = scene.screenSpaceCameraController; // do not zoom if it is disabled

	        if (!sscc.enableInputs || !sscc.enableZoom) {
	          return;
	        } // TODO
	        //            if(scene.mode == SceneMode.COLUMBUS_VIEW && !sscc.enableTranslate) {
	        //                return;
	        //            }


	        var camera = scene.camera;
	        var orientation;

	        switch (scene.mode) {
	          case SceneMode.MORPHING:
	            {
	              break;
	            }

	          case SceneMode.SCENE2D:
	            {
	              camera.zoomIn(camera.positionCartographic.height * (1 - relativeAmount));
	              break;
	            }

	          default:
	            {
	              var focus;

	              if (defined(this.viewer.trackedEntity)) {
	                focus = new Cesium.Cartesian3();
	              } else {
	                focus = this.getCameraFocus(this.viewer, false);
	              }

	              if (!Cesium.defined(focus)) {
	                // Camera direction is not pointing at the globe, so use the ellipsoid horizon point as
	                // the focal point.
	                var ray = new Ray(camera.worldToCameraCoordinatesPoint(scene.globe.ellipsoid.cartographicToCartesian(camera.positionCartographic)), camera.directionWC);
	                focus = IntersectionTests.grazingAltitudeLocation(ray, scene.globe.ellipsoid);
	                orientation = {
	                  heading: camera.heading,
	                  pitch: camera.pitch,
	                  roll: camera.roll
	                };
	              } else {
	                orientation = {
	                  direction: camera.direction,
	                  up: camera.up
	                };
	              }

	              var cartesian3Scratch = new Cartesian3();
	              var direction = Cartesian3.subtract(camera.position, focus, cartesian3Scratch);
	              var movementVector = Cartesian3.multiplyByScalar(direction, relativeAmount, direction);
	              var endPosition = Cartesian3.add(focus, movementVector, focus);

	              if (Cesium.defined(this.viewer.trackedEntity) || scene.mode === SceneMode.COLUMBUS_VIEW) {
	                // sometimes flyTo does not work (jumps to wrong position) so just set the position without any animation
	                // do not use flyTo when tracking an entity because during animatiuon the position of the entity may change
	                camera.position = endPosition;
	              } else {
	                camera.flyTo({
	                  destination: endPosition,
	                  orientation: orientation,
	                  duration: 0.5,
	                  convert: false
	                });
	              }
	            }
	        }
	      }
	    },
	    zoomReset: function zoomReset() {
	      var scene = this.viewer.scene;
	      var sscc = scene.screenSpaceCameraController;

	      if (!sscc.enableInputs) {
	        return;
	      }

	      var _Cesium2 = Cesium,
	          Cartesian3 = _Cesium2.Cartesian3,
	          CesiumMath = _Cesium2.Math,
	          Rectangle = _Cesium2.Rectangle;
	      var camera = scene.camera;

	      if (Cesium.defined(this.viewer.trackedEntity)) {
	        // when tracking do not reset to default view but to default view of tracked entity
	        var trackedEntity = this.viewer.trackedEntity;
	        this.viewer.trackedEntity = undefined;
	        this.viewer.trackedEntity = trackedEntity;
	      } else {
	        // reset to a default position or view defined in the options
	        var resetView = this.defaultResetView;

	        if (resetView && resetView.lng) {
	          camera.flyTo({
	            destination: Cartesian3.fromDegrees(resetView.lng, resetView.lat, resetView.height),
	            orientation: {
	              heading: Cesium.Math.toRadians(resetView.heading || 360),
	              pitch: Cesium.Math.toRadians(resetView.pitch || -90),
	              roll: Cesium.Math.toRadians(resetView.roll || 0)
	            }
	          });
	        } else if (resetView && resetView.west) {
	          try {
	            var rectangle = Rectangle.fromDegrees(resetView.west, resetView.south, resetView.east, resetView.north);
	            Rectangle.validate(rectangle);
	            camera.flyTo({
	              destination: rectangle,
	              orientation: {
	                heading: CesiumMath.toRadians(5.729578)
	              }
	            });
	          } catch (e) {
	            console.error('[VueCesium] ERROR: options.defaultResetView Cesium rectangle is  invalid!');
	          }
	        } else {
	          camera.flyTo({
	            destination: Cartesian3.fromDegrees(105, 29.999999999999993, 19059568.497290563)
	          });
	        }
	      }
	    },
	    getCameraFocus: function getCameraFocus(scene) {
	      var _Cesium3 = Cesium,
	          defined = _Cesium3.defined,
	          Ellipsoid = _Cesium3.Ellipsoid,
	          IntersectionTests = _Cesium3.IntersectionTests,
	          Ray = _Cesium3.Ray;
	      var ray = new Ray(scene.camera.positionWC, scene.camera.directionWC);
	      var intersections = IntersectionTests.rayEllipsoid(ray, Ellipsoid.WGS84);

	      if (defined(intersections)) {
	        return Ray.getPoint(ray, intersections.start);
	      } // Camera direction is not pointing at the globe, so use the ellipsoid horizon point as
	      // the focal point.


	      return IntersectionTests.grazingAltitudeLocation(ray, Ellipsoid.WGS84);
	    }
	  }
	};

	/* script */
	var __vue_script__$1D = script$1D;
	/* template */

	var __vue_render__$a = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('div', {
	    staticClass: "vc-zoom-control"
	  }, [_c('ul', {
	    staticClass: "vc-list"
	  }, [_c('li', [_c('button', {
	    staticClass: "vc-increase",
	    attrs: {
	      "title": _vm.$vc.lang.navigation.zoomCotrol.zoomIn,
	      "type": "button"
	    },
	    on: {
	      "click": _vm.zoomIn
	    }
	  }, [_c('vc-icon-svg', {
	    attrs: {
	      "name": "increase"
	    }
	  })], 1)]), _vm._v(" "), _c('li', [_c('button', {
	    staticClass: "vc-refresh",
	    attrs: {
	      "title": _vm.$vc.lang.navigation.zoomCotrol.zoomReset,
	      "type": "button"
	    },
	    on: {
	      "click": _vm.zoomReset
	    }
	  }, [_c('vc-icon-svg', {
	    attrs: {
	      "name": "refresh"
	    }
	  })], 1)]), _vm._v(" "), _c('li', [_c('button', {
	    staticClass: "vc-decrease",
	    attrs: {
	      "title": _vm.$vc.lang.navigation.zoomCotrol.zoomOut,
	      "type": "button"
	    },
	    on: {
	      "click": _vm.zoomOut
	    }
	  }, [_c('vc-icon-svg', {
	    attrs: {
	      "name": "decrease"
	    }
	  })], 1)])])]);
	};

	var __vue_staticRenderFns__$a = [];
	/* style */

	var __vue_inject_styles__$1D = undefined;
	/* scoped */

	var __vue_scope_id__$1D = undefined;
	/* functional template */

	var __vue_is_functional_template__$1D = false;
	/* component normalizer */

	function __vue_normalize__$1D(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "VcZoomControl.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var VcZoomControl = __vue_normalize__$1D({
	  render: __vue_render__$a,
	  staticRenderFns: __vue_staticRenderFns__$a
	}, __vue_inject_styles__$1D, __vue_script__$1D, __vue_scope_id__$1D, __vue_is_functional_template__$1D);

	//
	var script$1E = {
	  name: 'vc-legend-distance',
	  data: function data() {
	    return {
	      barWidth: 0,
	      distance: 0,
	      distanceLabel: undefined
	    };
	  },
	  computed: {
	    barStyle: function barStyle() {
	      return {
	        width: this.barWidth + 'px',
	        left: 5 + (125 - this.barWidth) / 2 + 'px',
	        height: '2px'
	      };
	    }
	  },
	  mounted: function mounted() {
	    var _this = this;

	    this.$parent.createPromise.then(function (_ref) {
	      var Cesium = _ref.Cesium,
	          viewer = _ref.viewer;
	      _this.viewer = viewer;
	      _this.viewerSubscriptions = [];
	      _this.removeUpdateSubscription = undefined;
	      _this._lastLegendUpdate = undefined;

	      _this.viewerSubscriptions.push(_this.viewer.beforeViewerChanged.addEventListener(function () {
	        if (Cesium.defined(_this.removeUpdateSubscription)) {
	          _this.removeUpdateSubscription();

	          _this.removeUpdateSubscription = undefined;
	        }
	      }));

	      _this.addUpdateSubscription();

	      _this.viewerSubscriptions.push(_this.viewer.afterViewerChanged.addEventListener(function () {
	        _this.addUpdateSubscription();
	      }));
	    });
	  },
	  methods: {
	    addUpdateSubscription: function addUpdateSubscription() {
	      var _this2 = this;

	      // const that = this
	      var _Cesium = Cesium,
	          defined = _Cesium.defined;

	      if (defined(this.viewer)) {
	        var scene = this.viewer.scene;
	        this.removeUpdateSubscription = scene.postRender.addEventListener(function () {
	          _this2.updateDistanceLegendCesium(scene);
	        });
	      }
	    },
	    updateDistanceLegendCesium: function updateDistanceLegendCesium(scene) {
	      var _Cesium2 = Cesium,
	          Cartesian2 = _Cesium2.Cartesian2,
	          defined = _Cesium2.defined,
	          getTimestamp = _Cesium2.getTimestamp;
	      var now = getTimestamp();

	      if (now < this._lastLegendUpdate + 250) {
	        return;
	      }

	      this._lastLegendUpdate = now;
	      var geodesic = new Cesium.EllipsoidGeodesic(); // Find the distance between two pixels at the bottom center of the screen.

	      var width = scene.canvas.clientWidth;
	      var height = scene.canvas.clientHeight;
	      var left = scene.camera.getPickRay(new Cartesian2(width / 2 | 0, height - 1));
	      var right = scene.camera.getPickRay(new Cartesian2(1 + width / 2 | 0, height - 1));
	      var globe = scene.globe;
	      var leftPosition = globe.pick(left, scene);
	      var rightPosition = globe.pick(right, scene);

	      if (!defined(leftPosition) || !defined(rightPosition)) {
	        this.barWidth = undefined;
	        this.distanceLabel = undefined;
	        return;
	      }

	      var leftCartographic = globe.ellipsoid.cartesianToCartographic(leftPosition);
	      var rightCartographic = globe.ellipsoid.cartesianToCartographic(rightPosition);
	      geodesic.setEndPoints(leftCartographic, rightCartographic);
	      var pixelDistance = geodesic.surfaceDistance; // Find the first distance that makes the scale bar less than 100 pixels.

	      var maxBarWidth = 100;
	      var distance;

	      for (var i = distances.length - 1; !defined(distance) && i >= 0; --i) {
	        if (distances[i] / pixelDistance < maxBarWidth) {
	          distance = distances[i];

	          if (this.distance !== distance) {
	            this.distance = distance;
	            this.$emit('legendChanged', distance);
	          }
	        }
	      }

	      if (defined(distance)) {
	        var label;

	        if (distance >= 1000) {
	          label = (distance / 1000).toString() + ' km';
	        } else {
	          label = distance.toString() + ' m';
	        }

	        this.barWidth = distance / pixelDistance | 0;
	        this.distanceLabel = label;
	      } else {
	        this.barWidth = undefined;
	        this.distanceLabel = undefined;
	      }
	    }
	  }
	};
	var distances = [1, 2, 3, 5, 10, 20, 30, 50, 100, 200, 300, 500, 1000, 2000, 3000, 5000, 10000, 20000, 30000, 50000, 100000, 200000, 300000, 500000, 1000000, 2000000, 3000000, 5000000, 10000000, 20000000, 30000000, 50000000];

	/* script */
	var __vue_script__$1E = script$1E;
	/* template */

	var __vue_render__$b = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _vm.distanceLabel ? _c('div', {
	    staticClass: "vc-legend vc-legend-distance"
	  }, [_c('label', [_vm._v(_vm._s(_vm.distanceLabel))]), _vm._v(" "), _c('div', {
	    staticClass: "vc-bar",
	    style: _vm.barStyle
	  })]) : _vm._e();
	};

	var __vue_staticRenderFns__$b = [];
	/* style */

	var __vue_inject_styles__$1E = undefined;
	/* scoped */

	var __vue_scope_id__$1E = undefined;
	/* functional template */

	var __vue_is_functional_template__$1E = false;
	/* component normalizer */

	function __vue_normalize__$1E(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "VcDistanceLegend.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var VcDistanceLegend = __vue_normalize__$1E({
	  render: __vue_render__$b,
	  staticRenderFns: __vue_staticRenderFns__$b
	}, __vue_inject_styles__$1E, __vue_script__$1E, __vue_scope_id__$1E, __vue_is_functional_template__$1E);

	//
	var script$1F = {
	  name: 'vc-bar-location',
	  data: function data() {
	    return {
	      cameraHeight: 0
	    };
	  },
	  props: {
	    showUtmZone: {
	      type: Boolean,
	      default: true
	    },
	    mouseCoords: Object
	  },
	  mounted: function mounted() {
	    var _this = this;

	    this.$parent.createPromise.then(function (_ref) {
	      var Cesium = _ref.Cesium,
	          viewer = _ref.viewer;
	      _this.viewer = viewer;
	      _this.lastMouseX = -1;
	      _this.lastMouseY = -1;

	      _this.viewer._element.addEventListener('mousemove', _this.onMouseMove, false);

	      _this.viewer._element.addEventListener('touchmove', _this.onMouseMove, false);

	      _this.cameraHeight = _this.viewer.camera.positionCartographic.height.toFixed(2);

	      _this.viewer.camera.changed.addEventListener(function () {
	        _this.cameraHeight = _this.viewer.camera.positionCartographic.height.toFixed(2);
	      });

	      extend();
	    });
	  },
	  methods: {
	    toggleUseProjection: function toggleUseProjection() {
	      this.mouseCoords.toggleUseProjection();
	    },
	    onMouseMove: function onMouseMove(event) {
	      var _Cesium = Cesium,
	          Cartesian2 = _Cesium.Cartesian2;
	      var clientX = event.type === 'mousemove' ? event.clientX : event.changedTouches[0].clientX;
	      var clientY = event.type === 'mousemove' ? event.clientY : event.changedTouches[0].clientY;

	      if (clientX === this.lastMouseX && clientY === this.lastMouseY) {
	        return;
	      }

	      this.lastMouseX = clientX;
	      this.lastMouseY = clientY;

	      if (this.viewer) {
	        var rect = this.viewer._element.getBoundingClientRect();

	        var position = new Cartesian2(clientX - rect.left, clientY - rect.top);
	        this.mouseCoords.updateCoordinatesFromCesium(this.viewer, position);
	      }
	    }
	  },
	  destroyed: function destroyed() {
	    this.viewer._element.removeEventListener('mousemove', this.onMouseMove, false);

	    this.viewer._element.removeEventListener('touchmove', this.onMouseMove, false);
	  }
	};
	var scratchArray = [];
	var scratchSphereIntersectionResult = {
	  start: 0.0,
	  stop: 0.0
	};
	var scratchV0 = {};
	var scratchV1 = {};
	var scratchV2 = {};
	var scratchResult = {};

	function extend() {
	  var _Cesium2 = Cesium,
	      Globe = _Cesium2.Globe,
	      GlobeSurfaceTile = _Cesium2.GlobeSurfaceTile,
	      BoundingSphere = _Cesium2.BoundingSphere,
	      defaultValue = _Cesium2.defaultValue,
	      Cartesian3 = _Cesium2.Cartesian3,
	      defined = _Cesium2.defined,
	      DeveloperError = _Cesium2.DeveloperError,
	      IntersectionTests = _Cesium2.IntersectionTests,
	      SceneMode = _Cesium2.SceneMode;

	  Globe.prototype.pickTriangle = Globe.prototype.pickTriangle || function (ray, scene, cullBackFaces, result) {
	    // >>includeStart('debug', pragmas.debug);
	    if (!defined(ray)) {
	      throw new DeveloperError('ray is required');
	    }

	    if (!defined(scene)) {
	      throw new DeveloperError('scene is required');
	    } // >>includeEnd('debug');


	    cullBackFaces = defaultValue(cullBackFaces, true);
	    var mode = scene.mode;
	    var projection = scene.mapProjection;
	    var sphereIntersections = scratchArray;
	    sphereIntersections.length = 0;
	    var tilesToRender = this._surface._tilesToRender;
	    var length = tilesToRender.length;
	    var tile;
	    var i;

	    for (i = 0; i < length; ++i) {
	      tile = tilesToRender[i];
	      var surfaceTile = tile.data;

	      if (!defined(surfaceTile)) {
	        continue;
	      }

	      var boundingVolume = surfaceTile.pickBoundingSphere;

	      if (mode !== SceneMode.SCENE3D) {
	        BoundingSphere.fromRectangleWithHeights2D(tile.rectangle, projection, surfaceTile.minimumHeight, surfaceTile.maximumHeight, boundingVolume);
	        Cartesian3.fromElements(boundingVolume.center.z, boundingVolume.center.x, boundingVolume.center.y, boundingVolume.center);
	      } else {
	        BoundingSphere.clone(surfaceTile.boundingSphere3D, boundingVolume);
	      }

	      var boundingSphereIntersection = IntersectionTests.raySphere(ray, boundingVolume, scratchSphereIntersectionResult);

	      if (defined(boundingSphereIntersection)) {
	        sphereIntersections.push(tile);
	      }
	    }

	    sphereIntersections.sort(createComparePickTileFunction(ray.origin));
	    var intersection;
	    length = sphereIntersections.length;

	    for (i = 0; i < length; ++i) {
	      intersection = sphereIntersections[i].data.pickTriangle(ray, scene.mode, scene.mapProjection, cullBackFaces, result);

	      if (defined(intersection)) {
	        intersection.tile = sphereIntersections[i];
	        break;
	      }
	    }

	    return intersection;
	  };

	  GlobeSurfaceTile.prototype.pickTriangle = GlobeSurfaceTile.prototype.pickTriangle || function (ray, mode, projection, cullBackFaces) {
	    var mesh = this.renderedMesh;

	    if (!defined(mesh)) {
	      return undefined;
	    }

	    var vertices = mesh.vertices;
	    var indices = mesh.indices;
	    var encoding = mesh.encoding;
	    var length = indices.length;

	    for (var i = 0; i < length; i += 3) {
	      var i0 = indices[i];
	      var i1 = indices[i + 1];
	      var i2 = indices[i + 2];
	      var v0 = getPosition(encoding, mode, projection, vertices, i0, scratchV0);
	      var v1 = getPosition(encoding, mode, projection, vertices, i1, scratchV1);
	      var v2 = getPosition(encoding, mode, projection, vertices, i2, scratchV2);
	      var intersection = IntersectionTests.rayTriangle(ray, v0, v1, v2, cullBackFaces, scratchResult);

	      if (defined(intersection)) {
	        return {
	          intersection: intersection,
	          v0: v0,
	          v1: v1,
	          v2: v2
	        };
	      }
	    }

	    return undefined;
	  };
	}

	function createComparePickTileFunction(rayOrigin) {
	  var _Cesium3 = Cesium,
	      BoundingSphere = _Cesium3.BoundingSphere;
	  return function (a, b) {
	    var aDist = BoundingSphere.distanceSquaredTo(a.data.pickBoundingSphere, rayOrigin);
	    var bDist = BoundingSphere.distanceSquaredTo(b.data.pickBoundingSphere, rayOrigin);
	    return aDist - bDist;
	  };
	}

	function getPosition(encoding, mode, projection, vertices, index, result) {
	  encoding.decodePosition(vertices, index, result);
	  var _Cesium4 = Cesium,
	      Cartesian3 = _Cesium4.Cartesian3,
	      defined = _Cesium4.defined,
	      SceneMode = _Cesium4.SceneMode;

	  if (defined(mode) && mode !== SceneMode.SCENE3D) {
	    var ellipsoid = projection.ellipsoid;
	    var positionCart = ellipsoid.cartesianToCartographic(result);
	    projection.project(positionCart, result);
	    Cartesian3.fromElements(result.z, result.x, result.y, result);
	  }

	  return result;
	}

	/* script */
	var __vue_script__$1F = script$1F;
	/* template */

	var __vue_render__$c = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('button', {
	    staticClass: "vc-legend vc-bar-location",
	    attrs: {
	      "type": "button"
	    },
	    on: {
	      "click": _vm.toggleUseProjection
	    }
	  }, [!_vm.mouseCoords.useProjection ? [_c('div', {
	    staticClass: "vc-section"
	  }, [_c('span', [_vm._v(_vm._s(_vm.$vc.lang.navigation.legend.lon))]), _vm._v(" "), _c('span', [_vm._v(_vm._s(_vm.mouseCoords.longitude))])]), _vm._v(" "), _c('div', {
	    staticClass: "vc-section"
	  }, [_c('span', [_vm._v(_vm._s(_vm.$vc.lang.navigation.legend.lat))]), _vm._v(" "), _c('span', [_vm._v(_vm._s(_vm.mouseCoords.latitude))])])] : [_c('div', {
	    staticClass: "vc-section-short"
	  }, [_c('span', [_vm._v(_vm._s(_vm.$vc.lang.navigation.legend.zone))]), _vm._v(" "), _c('span', [_vm._v(_vm._s(_vm.mouseCoords.utmZone))])]), _vm._v(" "), _c('div', {
	    staticClass: "vc-section"
	  }, [_c('span', [_vm._v(_vm._s(_vm.$vc.lang.navigation.legend.e))]), _vm._v(" "), _c('span', [_vm._v(_vm._s(_vm.mouseCoords.east))])]), _vm._v(" "), _c('div', {
	    staticClass: "vc-section"
	  }, [_c('span', [_vm._v(_vm._s(_vm.$vc.lang.navigation.legend.n))]), _vm._v(" "), _c('span', [_vm._v(_vm._s(_vm.mouseCoords.north))])])], _vm._v(" "), _vm.mouseCoords.elevation ? _c('div', {
	    staticClass: "vc-section-long"
	  }, [_c('span', [_vm._v(_vm._s(_vm.$vc.lang.navigation.legend.elev))]), _vm._v(" "), _c('span', [_vm._v(_vm._s(_vm.mouseCoords.elevation))])]) : _vm._e(), _vm._v(" "), _vm.cameraHeight < 20000000 ? _c('div', {
	    staticClass: "vc-section-long"
	  }, [_c('span', [_vm._v(_vm._s(_vm.$vc.lang.navigation.legend.cameraHeight))]), _vm._v(" "), _c('span', [_vm._v(_vm._s(_vm.cameraHeight))])]) : _vm._e()], 2);
	};

	var __vue_staticRenderFns__$c = [];
	/* style */

	var __vue_inject_styles__$1F = undefined;
	/* scoped */

	var __vue_scope_id__$1F = undefined;
	/* functional template */

	var __vue_is_functional_template__$1F = false;
	/* component normalizer */

	function __vue_normalize__$1F(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "VcLocationBar.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var VcLocationBar = __vue_normalize__$1F({
	  render: __vue_render__$c,
	  staticRenderFns: __vue_staticRenderFns__$c
	}, __vue_inject_styles__$1F, __vue_script__$1F, __vue_scope_id__$1F, __vue_is_functional_template__$1F);

	VcIconSvg.register({
	  share: {
	    width: 16,
	    height: 16,
	    viewBox: '0 0 16 16',
	    data: "\n    <!-- Generator: Sketch 43.2 (39069) - http://www.bohemiancoding.com/sketch -->\n    <!-- <title>Mask</title> -->\n    <desc>Created with Sketch.</desc>\n    <defs></defs>\n    <g id=\"Page-1\" stroke=\"none\" stroke-width=\"1\" fill-rule=\"evenodd\">\n      <g id=\"share-20\" fill-rule=\"nonzero\">\n        <g id=\"Mask\">\n            <path d=\"M5.97733131,7.62936833 C5.99229467,7.75081434 6,7.87450733 6,8 C6,8.1254927 5.99229467,8.2491857 5.97733131,8.3706317 L10.9173886,10.8406603 C11.456951,10.3201529 12.1910876,10 13,10 C14.6568542,10 16,11.3431458 16,13 C16,14.6568542 14.6568542,16 13,16 C11.3431458,16 10,14.6568542 10,13 C10,12.8745073 10.0077053,12.7508143 10.0226687,12.6293683 L5.08261143,10.1593397 C4.54304902,10.6798471 3.80891237,11 3,11 C1.34314575,11 0,9.6568542 0,8 C0,6.34314575 1.34314575,5 3,5 C3.80891237,5 4.54304902,5.32015293 5.08261143,5.84066029 L10.0226687,3.37063167 C10.0077053,3.24918566 10,3.12549267 10,3 C10,1.34314575 11.3431458,0 13,0 C14.6568542,0 16,1.34314575 16,3 C16,4.65685425 14.6568542,6 13,6 C12.1910876,6 11.456951,5.67984707 10.9173886,5.15933971 L5.97733131,7.62936833 Z M13,14 C13.5522847,14 14,13.5522847 14,13 C14,12.4477153 13.5522847,12 13,12 C12.4477153,12 12,12.4477153 12,13 C12,13.5522847 12.4477153,14 13,14 Z M13,4 C13.5522847,4 14,3.55228475 14,3 C14,2.44771525 13.5522847,2 13,2 C12.4477153,2 12,2.44771525 12,3 C12,3.55228475 12.4477153,4 13,4 Z M3,9 C3.55228475,9 4,8.5522847 4,8 C4,7.44771525 3.55228475,7 3,7 C2.44771525,7 2,7.44771525 2,8 C2,8.5522847 2.44771525,9 3,9 Z\" id=\"path-1\"></path>\n        </g>\n      </g>\n    </g>"
	  }
	});

	/**
	 * Tells the web browser to print a given window, which my be an iframe window, and
	 * returns a promise that resolves when printing is safely over so that, for example
	 * the window can be removed.
	 * @param {Window} windowToPrint The window to print.
	 * @returns {Promise} A promise that resolves when printing is safely over. The prommise is rejected if
	 *                    there is no indication that the browser's print
	 */
	function printWindow(windowToPrint) {
	  var _Cesium = Cesium,
	      when = _Cesium.when;
	  var deferred = when.defer();
	  var printInProgressCount = 0;
	  var timeout = setTimeout(function () {
	    deferred.reject(false // new TerriaError({
	    //   title: i18next.t('core.printWindow.errorTitle'),
	    //   message: i18next.t('core.printWindow.errorMessage')
	    // })
	    );
	  }, 10000);

	  function cancelTimeout() {
	    clearTimeout(timeout);
	  }

	  function resolveIfZero() {
	    if (printInProgressCount <= 0) {
	      deferred.resolve();
	    }
	  }

	  if (windowToPrint.matchMedia) {
	    windowToPrint.matchMedia('print').addListener(function (evt) {
	      cancelTimeout();

	      if (evt.matches) {
	        // console.log(i18next.t('core.printWindow.printMediaStart'))
	        ++printInProgressCount;
	      } else {
	        // console.log(i18next.t('core.printWindow.printMediaEnd'))
	        --printInProgressCount;
	        resolveIfZero();
	      }
	    });
	  }

	  windowToPrint.onbeforeprint = function () {
	    cancelTimeout(); // console.log(i18next.t('core.printWindow.onbeforeprint'))

	    ++printInProgressCount;
	  };

	  windowToPrint.onafterprint = function () {
	    cancelTimeout(); // console.log(i18next.t('core.printWindow.onafterprint'))

	    --printInProgressCount;
	    resolveIfZero();
	  }; // First try printing with execCommand, because, in IE11, `printWindow.print()`
	  // prints the entire page instead of just the embedded iframe (if the window
	  // is an iframe, anyway).


	  var result = windowToPrint.document.execCommand('print', true, null);

	  if (!result) {
	    windowToPrint.print();
	  }

	  return deferred.promise;
	}

	//
	var script$1G = {
	  props: {
	    options: Object
	  },
	  data: function data() {
	    return {
	      mapImageDataUrl: undefined,
	      ready: false,
	      credits: []
	    };
	  },
	  mounted: function mounted() {
	    var _this = this;

	    captureScreenshot(this.options.viewer).then(function (mapImageDataUrl) {
	      // We need to periodically check whether all images are loaded.
	      // We can theoretically do that either with a setInterval on the original TerriaJS window,
	      // or on the print view window. But:
	      //    * Chrome (as of v66.0.3359.139 anyway) seems to aggressively suspend setInterval calls in background
	      // tabs, so only a setInterval on the print view window works reliably.
	      //    * Internet Explorer 11 does not seem to allow a cross-window setInterval call, so only a setInterval
	      // on the original TerriaJS window works reliably.
	      // So, we'll do both.
	      var printWindow = _this.options.printWindow;
	      var mainWindow = window;
	      var printWindowIntervalId = printWindow.setInterval(_this.checkForImagesReady, 200);
	      var mainWindowIntervalId = mainWindow.setInterval(_this.checkForImagesReady, 200);

	      _this._stopCheckingForImages = function () {
	        printWindow.clearInterval(printWindowIntervalId);
	        mainWindow.clearInterval(mainWindowIntervalId);
	        _this._stopCheckingForImages = undefined;
	      };

	      _this.mapImageDataUrl = mapImageDataUrl;
	    });
	    this.credits = getAllAttribution(this.options.viewer);
	  },
	  methods: {
	    checkForImagesReady: function checkForImagesReady() {
	      if (this.ready) {
	        return;
	      }

	      var imageTags = this.options.printWindow.document.getElementsByTagName('img');

	      if (imageTags.length === 0) {
	        return;
	      }

	      var allImagesReady = true;

	      for (var i = 0; allImagesReady && i < imageTags.length; ++i) {
	        allImagesReady = imageTags[i].complete;
	      }

	      if (allImagesReady) {
	        this.stopCheckingForImages();
	        this.ready = allImagesReady;
	        this.$emit('ready', this.options.printWindow);
	      }
	    },
	    stopCheckingForImages: function stopCheckingForImages() {
	      if (this._stopCheckingForImages) {
	        this._stopCheckingForImages();
	      }
	    }
	  },
	  destroyed: function destroyed() {
	    this.stopCheckingForImages();
	  }
	};

	/* script */
	var __vue_script__$1G = script$1G;
	/* template */

	var __vue_render__$d = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('div', [_c('p', [_c('img', {
	    staticClass: "vc-map-image",
	    attrs: {
	      "src": _vm.mapImageDataUrl,
	      "alt": "Map snaphot"
	    }
	  })]), _vm._v(" "), _vm.credits.length > 0 && _vm.options.showCredit ? _c('h1', [_vm._v("Map Credits")]) : _vm._e(), _vm._v(" "), _vm.credits.length > 0 && _vm.options.showCredit ? _c('ul', [_vm._l(_vm.credits, function (credit, index) {
	    return [_c('li', {
	      key: 'credit' + index,
	      domProps: {
	        "innerHTML": _vm._s(credit)
	      }
	    })];
	  })], 2) : _vm._e()]);
	};

	var __vue_staticRenderFns__$d = [];
	/* style */

	var __vue_inject_styles__$1G = undefined;
	/* scoped */

	var __vue_scope_id__$1G = undefined;
	/* functional template */

	var __vue_is_functional_template__$1G = false;
	/* component normalizer */

	function __vue_normalize__$1G(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "VcPrintView.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var VcPrintView = __vue_normalize__$1G({
	  render: __vue_render__$d,
	  staticRenderFns: __vue_staticRenderFns__$d
	}, __vue_inject_styles__$1G, __vue_script__$1G, __vue_scope_id__$1G, __vue_is_functional_template__$1G);

	//
	var script$1H = {
	  name: 'vc-view-print',
	  components: {
	    VcIconSvg: VcIconSvg
	  },
	  props: {
	    printAutomatically: Boolean,
	    showCredit: {
	      type: Boolean,
	      default: true
	    }
	  },
	  mounted: function mounted() {
	    var _this = this;

	    this.$parent.createPromise.then(function (_ref) {
	      var Cesium = _ref.Cesium,
	          viewer = _ref.viewer;
	      _this.viewer = viewer;
	    });
	  },
	  methods: {
	    handleCick: function handleCick() {
	      this.createPrintView();
	    },
	    createPrintView: function createPrintView() {
	      var _this2 = this;

	      var viewer = this.viewer,
	          showCredit = this.showCredit,
	          printAutomatically = this.printAutomatically;
	      this.creatingPrintView = true;

	      if (printAutomatically) {
	        this.iframe = document.createElement('iframe');
	        document.body.appendChild(this.iframe);
	      }

	      var newWindow = createWindow({
	        printWindow: this.iframe ? this.iframe.contentWindow : undefined,
	        closeCallback: function closeCallback(windowToPrint) {
	          if (printAutomatically) {
	            _this2.creatingPrintView = false;
	          }
	        }
	      });
	      var options = {
	        viewer: viewer,
	        printWindow: newWindow,
	        showCredit: showCredit
	      };
	      new Vue({
	        render: function render(h) {
	          return h(VcPrintView, {
	            props: {
	              options: options
	            },
	            on: {
	              ready: _this2.printViewReady
	            }
	          });
	        }
	      }).$mount(newWindow.document.getElementById('print'));

	      if (!printAutomatically) {
	        this.creatingPrintView = false;
	      }
	    },
	    printViewReady: function printViewReady(windowToPrint) {
	      var _this3 = this;

	      var printAutomatically = this.printAutomatically,
	          iframe = this.iframe;

	      if (printAutomatically) {
	        printWindow(windowToPrint).otherwise(function (e) {
	          console.error(e);
	        }).always(function () {
	          if (iframe) {
	            document.body.removeChild(iframe);
	          }

	          if (printAutomatically) {
	            _this3.creatingPrintView = false;
	          }
	        });
	      }
	    },
	    printViewClosed: function printViewClosed(windowToPrint) {
	      if (this.printAutomatically) {
	        this.creatingPrintView = false;
	      }
	    }
	  }
	};

	function createWindow(options) {
	  var _options$printWindow = options.printWindow,
	      printWindow = _options$printWindow === void 0 ? window.open() : _options$printWindow,
	      closeCallback = options.closeCallback;

	  if (closeCallback) {
	    printWindow.addEventListener('unload', function () {
	      closeCallback(printWindow);
	    });
	  } // Open and immediately close the document. This works around a problem in Firefox that is
	  // captured here: https://bugzilla.mozilla.org/show_bug.cgi?id=667227.
	  // Essentially, when we first create an iframe, it has no document loaded and asynchronously
	  // starts a load of "about:blank". If we access the document object and start manipulating it
	  // before that async load completes, a new document will be automatically created. But then
	  // when the async load completes, the original, automatically-created document gets unloaded
	  // and the new "about:blank" gets swapped in. End result: everything we add to the DOM before
	  // the async load complete gets lost and Firefox ends up printing a blank page.
	  // Explicitly opening and then closing a new document _seems_ to avoid this.


	  printWindow.document.open();
	  printWindow.document.close();
	  printWindow.document.head.innerHTML = "\n    <meta charset=\"UTF-8\">\n    <title>VueCesium Print View</title>\n    <style>\n      .background {\n        width: 100%;\n        fill: rgba(255, 255, 255, 1.0);\n      }\n      .map-image {\n        max-width: 95vw;\n        max-height: 95vh;\n      }\n      h1, h2, h3 {\n        clear: both;\n      }\n      </style>\n    ";
	  printWindow.document.body.innerHTML = '<div id="print"></div>';
	  return printWindow;
	}

	/* script */
	var __vue_script__$1H = script$1H;
	/* template */

	var __vue_render__$e = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('div', {
	    staticClass: "vc-tool-btn"
	  }, [_c('button', {
	    staticClass: "vc-btn",
	    attrs: {
	      "title": _vm.$vc.lang.navigation.printView,
	      "type": "button"
	    },
	    on: {
	      "click": _vm.handleCick
	    }
	  }, [_c('vc-icon-svg', {
	    attrs: {
	      "name": "share"
	    }
	  })], 1)]);
	};

	var __vue_staticRenderFns__$e = [];
	/* style */

	var __vue_inject_styles__$1H = undefined;
	/* scoped */

	var __vue_scope_id__$1H = undefined;
	/* functional template */

	var __vue_is_functional_template__$1H = false;
	/* component normalizer */

	function __vue_normalize__$1H(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "VcPrintViewBtn.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var VcPrintViewBtn = __vue_normalize__$1H({
	  render: __vue_render__$e,
	  staticRenderFns: __vue_staticRenderFns__$e
	}, __vue_inject_styles__$1H, __vue_script__$1H, __vue_scope_id__$1H, __vue_is_functional_template__$1H);

	VcIconSvg.register({
	  geolocation: {
	    width: 50,
	    height: 50,
	    viewBox: '0 0 50 50',
	    data: "\n    <!-- Generator: Sketch 3.4.3 (16044) - http://www.bohemiancoding.com/sketch -->\n    <!-- <title>geolocation</title> -->\n    <path d=\"M25.2083333,40.9848485 L25.2083333,40.9848485 C33.9214621,40.9848485 40.9848485,33.9214621 40.9848485,25.2083333 C40.9848485,16.4952046 33.9214621,9.43181817 25.2083333,9.43181817 C16.4952046,9.43181817 9.43181817,16.4952046 9.43181817,25.2083333 C9.43181817,33.9214621 16.4952046,40.9848485 25.2083333,40.9848485 L25.2083333,40.9848485 L25.2083333,40.9848485 Z M6.485903,23.7069504 C7.21162342,14.5314545 14.5314545,7.21162342 23.7069504,6.485903 C23.7061912,6.46628533 23.7058081,6.44657125 23.7058081,6.42676767 L23.7058081,1.91919192 C23.7058081,1.08937017 24.3785116,0.416666667 25.2083333,0.416666667 C26.0381551,0.416666667 26.7108586,1.08937017 26.7108586,1.91919192 L26.7108586,6.42676767 C26.7108586,6.44657125 26.7104755,6.46628533 26.7097162,6.485903 C35.8852122,7.21162342 43.2050433,14.5314545 43.9307637,23.7069504 C43.9503813,23.7061912 43.9700954,23.7058081 43.989899,23.7058081 L48.4974747,23.7058081 C49.3272965,23.7058081 50,24.3785116 50,25.2083333 C50,26.0381551 49.3272965,26.7108586 48.4974747,26.7108586 L43.989899,26.7108586 C43.9700954,26.7108586 43.9503813,26.7104755 43.9307637,26.7097162 C43.2050433,35.8852122 35.8852122,43.2050433 26.7097162,43.9307637 C26.7104755,43.9503813 26.7108586,43.9700954 26.7108586,43.989899 L26.7108586,48.4974747 C26.7108586,49.3272965 26.0381551,50 25.2083333,50 C24.3785116,50 23.7058081,49.3272965 23.7058081,48.4974747 L23.7058081,43.989899 C23.7058081,43.9700954 23.7061912,43.9503813 23.7069504,43.9307637 C14.5314545,43.2050433 7.21162342,35.8852122 6.485903,26.7097162 C6.46628533,26.7104755 6.44657125,26.7108586 6.42676767,26.7108586 L1.91919192,26.7108586 C1.08937017,26.7108586 0.416666667,26.0381551 0.416666667,25.2083333 C0.416666667,24.3785116 1.08937017,23.7058081 1.91919192,23.7058081 L6.42676767,23.7058081 C6.44657125,23.7058081 6.46628533,23.7061912 6.485903,23.7069504 L6.485903,23.7069504 Z M25.2083333,29.7159091 C27.6977987,29.7159091 29.7159091,27.6977987 29.7159091,25.2083333 C29.7159091,22.718868 27.6977987,20.7007576 25.2083333,20.7007576 C22.718868,20.7007576 20.7007576,22.718868 20.7007576,25.2083333 C20.7007576,27.6977987 22.718868,29.7159091 25.2083333,29.7159091 L25.2083333,29.7159091 Z\" id=\"Shape\"></path>"
	  }
	});

	var dist = createCommonjsModule(function (module, exports) {
	(function(e,h){module.exports=h();})(commonjsGlobal,function(){function e(a,d){var c=Object.keys(a);if(Object.getOwnPropertySymbols){var b=Object.getOwnPropertySymbols(a);d&&(b=b.filter(function(b){return Object.getOwnPropertyDescriptor(a,b).enumerable}));c.push.apply(c,b);}return c}function h(a){for(var d=1;d<arguments.length;d++){var c=null!=arguments[d]?arguments[d]:
	{};d%2?e(Object(c),!0).forEach(function(b){var d=c[b];b in a?Object.defineProperty(a,b,{value:d,enumerable:!0,configurable:!0,writable:!0}):a[b]=d;}):Object.getOwnPropertyDescriptors?Object.defineProperties(a,Object.getOwnPropertyDescriptors(c)):e(Object(c)).forEach(function(b){Object.defineProperty(a,b,Object.getOwnPropertyDescriptor(c,b));});}return a}if(!window)throw Error("AMap JSAPI can only be used in Browser.");var f="notload",k={key:"",version:"1.4.15",plugins:[]},n=[],p=function(a){"function"==
	typeof a&&("loaded"==f?a(window.AMap):n.push(a));};return {load:function(a){return new Promise(function(d,c){if("notload"==f){var b=h({},k,{},a),g=b.key,e=b.version;b=b.plugins;if(g){window.AMap&&c("\u7981\u6b62\u591a\u79cdAPI\u52a0\u8f7d\u65b9\u5f0f\u6df7\u7528");k={key:g,version:e,plugins:b};f="loading";var q=document.body||document.head;window.___onAPILoaded=function(a){delete window.___onAPILoaded;a?(f="failed",c(a)):(f="loaded",d(window.AMap));for(;n.length;)n.splice(0,1)[0]();};var m=document.createElement("script");
	m.type="text/javascript";m.src="https://webapi.amap.com/maps?callback=___onAPILoaded&v="+e+"&key="+g+"&plugin="+b.join(",");m.onerror=function(a){f="failed";c(a);};q.appendChild(m);}else c("\u8bf7\u586b\u5199key");}else if(a.key&&a.key!==k.key)c("\u591a\u4e2a\u4e0d\u4e00\u81f4\u7684 key");else if(a.version&&a.version!==k.version)c("\u4e0d\u5141\u8bb8\u591a\u4e2a\u7248\u672c JSAPI \u6df7\u7528");else{"failed"==f&&c("\u524d\u6b21\u52a0\u8f7d\u5df2\u7ecf\u5931\u8d25");var l=[];if(a.plugins)for(g=0;g<a.plugins.length;g+=
	1)-1==k.plugins.indexOf(a.plugins[g])&&l.push(a.plugins[g]);"loaded"==f?l.length?window.AMap.plugin(l,function(){d(window.AMap);}):d(window.AMap):"loading"==f&&p(function(){l.length?window.AMap.plugin(l,function(){d(window.AMap);}):d(window.AMap);});}})}}});
	});

	var script$1I = {
	  components: {
	    VcIconSvg: VcIconSvg
	  },
	  props: {
	    enableMyLocation: [Object, Boolean]
	  },
	  mounted: function mounted() {
	    var _this = this;

	    this.$parent.createPromise.then(function (_ref) {
	      var Cesium = _ref.Cesium,
	          viewer = _ref.viewer;
	      _this.viewer = viewer;

	      _this.viewer.dataSources.add(new Cesium.CustomDataSource('vc-myLocation')).then(function (ds) {
	        _this.datasource = ds;
	      });

	      var enableMyLocation = _this.enableMyLocation;

	      if (enableMyLocation.amap && enableMyLocation.amap.key) {
	        dist.load({
	          key: enableMyLocation.amap.key,
	          version: '2.0',
	          plugins: ['AMap.Geolocation']
	        }).then(function (AMap) {
	          _this.AMap = AMap;
	          _this.amapGeolocation = new AMap.Geolocation({
	            // 是否使用高精度定位，默认：true
	            enableHighAccuracy: true,
	            convert: false,
	            // 设置定位超时时间，默认：无穷大
	            timeout: 20000
	          });
	        }).catch(function (e) {
	          console.error('[VueCesium] ERROR: ' + e);
	        });
	      }
	    });
	  },
	  destroyed: function destroyed() {
	    this.viewer.dataSources.remove(this.datasource, true);

	    if (this.amapGeolocation) {
	      var scripts = document.getElementsByTagName('script');
	      var removeScripts = [];
	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;

	      try {
	        for (var _iterator = getIterator$1(scripts), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var script = _step.value;

	          if (script.src.indexOf('/webapi.amap.com/maps') > -1) {
	            removeScripts.push(script);
	          }
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return != null) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }

	      removeScripts.forEach(function (script) {
	        document.getElementsByTagName('body')[0].removeChild(script);
	      });
	    }
	  },
	  methods: {
	    handleCick: function handleCick() {
	      var _this2 = this;

	      var enableMyLocation = this.enableMyLocation,
	          getLocation = this.getLocation;

	      if (enableMyLocation.amap && enableMyLocation.amap.key) {
	        this.amapGeolocation.getCurrentPosition(function (status, result) {
	          if (status === 'complete') {
	            _this2.$emit('geolocation', result);

	            _this2.zoomToMyLocation({
	              lng: result.position.lng,
	              lat: result.position.lat
	            });
	          } else {
	            console.error('[VueCesium] ERROR: ' + result.message);
	          }
	        });
	      } else {
	        getLocation();
	      }
	    },
	    getLocation: function getLocation() {
	      var _this3 = this;

	      if (navigator.geolocation) {
	        var options = {
	          enableHighAccuracy: true,
	          timeout: 5000,
	          maximumAge: 0
	        };
	        navigator.geolocation.getCurrentPosition(function (position) {
	          _this3.$emit('geolocation', position);

	          _this3.zoomToMyLocation({
	            lng: position.coords.longitude,
	            lat: position.coords.latitude
	          });
	        }, this.handleLocationError, options);
	      } else {
	        console.error('[VueCesium] ERROR: ' + 'Your browser cannot provide your location.');
	      }
	    },
	    // This next function modelled on Cesium.geoJsonDataSource's defaultDescribe.
	    describeWithoutUnderscores: function describeWithoutUnderscores(properties, nameProperty) {
	      var html = '';

	      if (properties instanceof Cesium.PropertyBag) {
	        // unwrap the properties from the PropertyBag
	        properties = properties.getValue(Cesium.JulianDate.now());
	      }

	      for (var key in properties) {
	        if (Object.prototype.hasOwnProperty.call(properties, key)) {
	          if (key === nameProperty) {
	            continue;
	          }

	          var value = properties[key];

	          if (_typeof(value) === 'object') {
	            value = this.describeWithoutUnderscores(value);
	          }

	          key = key.replace(/_/g, ' ');

	          if (Cesium.defined(value)) {
	            html += '<tr><th>' + key + '</th><td>' + value + '</td></tr>';
	          }
	        }
	      }

	      if (html.length > 0) {
	        html = '<table class="cesium-infoBox-defaultTable"><tbody>' + html + '</tbody></table>';
	      }

	      return html;
	    },
	    zoomToMyLocation: function zoomToMyLocation(position) {
	      var longitude = position.lng;
	      var latitude = position.lat;
	      var _Cesium = Cesium,
	          Cartesian3 = _Cesium.Cartesian3,
	          Rectangle = _Cesium.Rectangle,
	          Ellipsoid = _Cesium.Ellipsoid,
	          sampleTerrain = _Cesium.sampleTerrain;
	      var datasource = this.datasource,
	          describeWithoutUnderscores = this.describeWithoutUnderscores;
	      datasource.entities.removeAll();
	      datasource.entities.add({
	        id: 'My Location',
	        position: Cartesian3.fromDegrees(longitude, latitude),
	        point: {
	          color: Cesium.Color.fromCssColorString('#08ABD5'),
	          pixelSize: 25 / 2,
	          outlineWidth: 3,
	          outlineColor: Cesium.Color.fromCssColorString('#ffffff')
	        },
	        description: describeWithoutUnderscores({
	          longitude: longitude,
	          latitude: latitude
	        })
	      }); // west, south, east, north, result

	      var rectangle = Rectangle.fromDegrees(longitude - 0.01, latitude - 0.01, longitude + 0.01, latitude + 0.01);
	      var camera = this.viewer.scene.camera; // Work out the destination that the camera would naturally fly to

	      var destinationCartesian = camera.getRectangleCameraCoordinates(rectangle);
	      var destination = Ellipsoid.WGS84.cartesianToCartographic(destinationCartesian);
	      var terrainProvider = this.viewer.scene.globe.terrainProvider;
	      var level = 6; // A sufficiently coarse tile level that still has approximately accurate height

	      var positions = [Rectangle.center(rectangle)]; // Perform an elevation query at the centre of the rectangle

	      return sampleTerrain(terrainProvider, level, positions).then(function (results) {
	        // Add terrain elevation to camera altitude
	        var finalDestinationCartographic = {
	          longitude: destination.longitude,
	          latitude: destination.latitude,
	          height: destination.height + results[0].height
	        };
	        var finalDestination = Ellipsoid.WGS84.cartographicToCartesian(finalDestinationCartographic);
	        camera.flyTo({
	          duration: 3,
	          destination: finalDestination
	        });
	      });
	    },
	    handleLocationError: function handleLocationError(err) {
	      console.error('[VueCesium] ERROR: ' + err.message);
	    }
	  }
	};

	/* script */
	var __vue_script__$1I = script$1I;
	/* template */

	var __vue_render__$f = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('div', {
	    staticClass: "vc-tool-btn"
	  }, [_c('button', {
	    staticClass: "vc-btn",
	    attrs: {
	      "title": _vm.$vc.lang.navigation.centreMap,
	      "type": "button"
	    },
	    on: {
	      "click": _vm.handleCick
	    }
	  }, [_c('vc-icon-svg', {
	    attrs: {
	      "name": "geolocation"
	    }
	  })], 1)]);
	};

	var __vue_staticRenderFns__$f = [];
	/* style */

	var __vue_inject_styles__$1I = undefined;
	/* scoped */

	var __vue_scope_id__$1I = undefined;
	/* functional template */

	var __vue_is_functional_template__$1I = false;
	/* component normalizer */

	function __vue_normalize__$1I(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "VcMyLocation.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var VcMyLocation = __vue_normalize__$1I({
	  render: __vue_render__$f,
	  staticRenderFns: __vue_staticRenderFns__$f
	}, __vue_inject_styles__$1I, __vue_script__$1I, __vue_scope_id__$1I, __vue_is_functional_template__$1I);

	var script$1J = {
	  name: 'vc-navigation',
	  components: {
	    VcCompass: VcCompass,
	    VcZoomControl: VcZoomControl,
	    VcDistanceLegend: VcDistanceLegend,
	    VcLocationBar: VcLocationBar,
	    VcPrintViewBtn: VcPrintViewBtn,
	    VcMyLocation: VcMyLocation
	  },
	  mixins: [cmp],
	  props: {
	    options: Object
	  },
	  data: function data() {
	    return {
	      defaultOptions: {
	        enableCompass: true,
	        enableCompassOuterRing: true,
	        enableZoomControl: {
	          zoomAmount: 2,
	          defaultResetView: {
	            lng: 105,
	            lat: 29.999999999999993,
	            height: 19059568.497290563
	          },
	          overrideCamera: false
	        },
	        enableDistanceLegend: true,
	        enableLocationBar: {
	          gridFileUrl: 'https://zouyaoji.top/vue-cesium/statics/SampleData/WW15MGH.DAC'
	        },
	        enablePrintView: {
	          showCredit: true,
	          printAutomatically: false
	        },
	        enableMyLocation: {
	          amap: {
	            key: undefined
	          }
	        }
	      },
	      ldBottom: 2,
	      ldRight: 3,
	      mouseCoords: undefined,
	      canRender: false
	    };
	  },
	  computed: {
	    ldStyle: function ldStyle() {
	      return {
	        bottom: this.ldBottom + 'px',
	        right: this.ldRight + 'px'
	      };
	    }
	  },
	  watch: {
	    options: {
	      handler: function handler() {
	        var _this = this;

	        this.reload().then(function () {
	          _this.viewer.widgetResized.raiseEvent();
	        });
	      },
	      deep: true
	    }
	  },
	  methods: {
	    createCesiumObject: function createCesiumObject() {
	      var _this2 = this;

	      return regenerator.async(function createCesiumObject$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              this.viewer.afterViewerChanged = new Cesium.Event();
	              this.viewer.beforeViewerChanged = new Cesium.Event();
	              this.viewer.widgetResized.addEventListener(this.widgetResized);

	              assign$1(this.defaultOptions, this.options);

	              this.widgetResized();
	              this.mouseCoords = new MouseCoords({
	                gridFileUrl: this.defaultOptions.enableLocationBar.gridFileUrl
	              }); // 避免控件先按默认的参数创建 然后又隐藏 导致视觉上的体验不优雅

	              this.canRender = true;
	              this.$nextTick(function () {
	                var viewerContainer = _this2.viewer._element;
	                viewerContainer.appendChild(_this2.$el);
	                _this2.viewer.VcNavigationContaner = _this2.$refs.navigationContainer;
	              });
	              return _context.abrupt("return", this.$el);

	            case 9:
	            case "end":
	              return _context.stop();
	          }
	        }
	      }, null, this);
	    },
	    widgetResized: function widgetResized() {
	      this.ldBottom = this.viewer.timeline ? this.viewer.timeline.container.getBoundingClientRect().height + 2 : 2;

	      if (this.ldBottom === 2) {
	        var ldRight = 3;
	        this.viewer.fullscreenButton && (ldRight += this.viewer.fullscreenButton.container.getBoundingClientRect().width);
	        this.viewer.vrButton && (ldRight += this.viewer.vrButton.container.getBoundingClientRect().width);
	        this.ldRight = ldRight;
	      }
	    },
	    mount: function mount() {
	      return regenerator.async(function mount$(_context2) {
	        while (1) {
	          switch (_context2.prev = _context2.next) {
	            case 0:
	              return _context2.abrupt("return", true);

	            case 1:
	            case "end":
	              return _context2.stop();
	          }
	        }
	      });
	    },
	    unmount: function unmount() {
	      return regenerator.async(function unmount$(_context3) {
	        while (1) {
	          switch (_context3.prev = _context3.next) {
	            case 0:
	              this.viewer.widgetResized.removeEventListener(this.widgetResized);
	              return _context3.abrupt("return", true);

	            case 2:
	            case "end":
	              return _context3.stop();
	          }
	        }
	      }, null, this);
	    },
	    legendChanged: function legendChanged(e) {
	      var listener = this.$listeners.legendChanged;
	      listener && this.$emit('legendChanged', e);
	    },
	    geolocation: function geolocation(e) {
	      var listener = this.$listeners.geolocation;
	      listener && this.$emit('geolocation', e);
	    }
	  },
	  stubVNode: {
	    empty: function empty() {
	      return this.$options.name;
	    }
	  },
	  created: function created() {
	    var _this3 = this;

	    defineProperties$1(this, {
	      cesiumNavigation: {
	        enumerable: true,
	        get: function get() {
	          return _this3.cesiumObject;
	        }
	      }
	    });
	  }
	};

	/* script */
	var __vue_script__$1J = script$1J;
	/* template */

	var __vue_render__$g = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _vm.canRender ? _c('div', {
	    ref: "navigationContainer",
	    staticClass: "vc-navigationContainer"
	  }, [_c('div', {
	    staticClass: "vc-navigation"
	  }, [_c('div', {
	    staticClass: "vc-navigation-navs"
	  }, [_vm.defaultOptions.enableCompass ? _c('div', {
	    staticClass: "vc-navigation-control"
	  }, [_c('vc-compass', {
	    ref: "VcCompass",
	    attrs: {
	      "enableCompassOuterRing": _vm.defaultOptions.enableCompassOuterRing
	    }
	  })], 1) : _vm._e(), _vm._v(" "), _vm.defaultOptions.enableZoomControl ? _c('div', {
	    staticClass: "vc-navigation-control"
	  }, [_c('vc-zoom-control', {
	    ref: "VcZoomControl",
	    attrs: {
	      "defaultResetView": _vm.defaultOptions.enableZoomControl.defaultResetView,
	      "overrideCamera": _vm.defaultOptions.enableZoomControl.overrideCamera || false,
	      "zoomAmount": _vm.defaultOptions.enableZoomControl.zoomAmount || 2
	    }
	  })], 1) : _vm._e()]), _vm._v(" "), _c('div', {
	    staticClass: "vc-navigation-controls"
	  }, [_vm.defaultOptions.enablePrintView ? _c('div', {
	    staticClass: "vc-navigation-control"
	  }, [_c('vc-print-view-btn', {
	    ref: "VcPrintViewBtn",
	    attrs: {
	      "printAutomatically": _vm.defaultOptions.enablePrintView.printAutomatically,
	      "showCredit": _vm.defaultOptions.enablePrintView.showCredit
	    }
	  })], 1) : _vm._e(), _vm._v(" "), _vm.defaultOptions.enableMyLocation ? _c('div', {
	    staticClass: "vc-navigation-control"
	  }, [_c('vc-my-location', {
	    attrs: {
	      "enableMyLocation": _vm.defaultOptions.enableMyLocation
	    },
	    on: {
	      "geolocation": _vm.geolocation
	    }
	  })], 1) : _vm._e()])]), _vm._v(" "), _c('div', {
	    staticClass: "vc-location-distance",
	    style: _vm.ldStyle
	  }, [_vm.mouseCoords !== undefined && _vm.defaultOptions.enableLocationBar ? _c('vc-location-bar', {
	    ref: "VcLocationBar",
	    attrs: {
	      "mouseCoords": _vm.mouseCoords
	    }
	  }) : _vm._e(), _vm._v(" "), _vm.defaultOptions.enableDistanceLegend ? _c('vc-distance-legend', {
	    ref: "VcDistanceLengend",
	    on: {
	      "legendChanged": _vm.legendChanged
	    }
	  }) : _vm._e()], 1)]) : _vm._e();
	};

	var __vue_staticRenderFns__$g = [];
	/* style */

	var __vue_inject_styles__$1J = undefined;
	/* scoped */

	var __vue_scope_id__$1J = undefined;
	/* functional template */

	var __vue_is_functional_template__$1J = false;
	/* component normalizer */

	function __vue_normalize__$1J(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "VcNavigation.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var VcNavigation = __vue_normalize__$1J({
	  render: __vue_render__$g,
	  staticRenderFns: __vue_staticRenderFns__$g
	}, __vue_inject_styles__$1J, __vue_script__$1J, __vue_scope_id__$1J, __vue_is_functional_template__$1J);

	function plugin$1B(Vue) {

	  if (plugin$1B.installed) {
	    return;
	  }

	  plugin$1B.installed = true;
	  Vue.component(VcNavigation.name, VcNavigation);
	}

	var VcNavigation$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$1B,
		VcNavigation: VcNavigation,
		install: plugin$1B
	});

	//
	var script$1K = {
	  name: 'vc-compass-sm',
	  props: {
	    enableCompassOuterRing: Boolean
	  },
	  data: function data() {
	    return {
	      tiltbarLeft: 56,
	      tiltbarTop: 3,
	      heading: 0
	    };
	  },
	  computed: {
	    tiltbarStyle: function tiltbarStyle() {
	      return {
	        left: this.tiltbarLeft + 'px',
	        top: this.tiltbarTop + 'px'
	      };
	    },
	    outerRingStyle: function outerRingStyle() {
	      return {
	        transform: 'rotate(-' + this.heading + 'rad)',
	        '-webkit-transform': 'rotate(-' + this.heading + 'rad)'
	      };
	    }
	  },
	  mounted: function mounted() {
	    var _this = this;

	    this.$parent.createPromise.then(function (_ref) {
	      var Cesium = _ref.Cesium,
	          viewer = _ref.viewer;
	      _this.viewer = viewer;
	      _this.heading = viewer.scene.camera.heading;
	      _this.screenSpaceEventHandler = new Cesium.ScreenSpaceEventHandler(_this.$parent.$refs.navigationContainer);
	      _this.isRotating = false;
	      _this.rotateInitialCursorAngle = undefined;
	      _this.rotateFrame = undefined;
	      _this.rotateMouseMoveFunction = undefined;
	      _this.rotateMouseUpFunction = undefined;
	      _this._unsubcribeFromPostRender = undefined;
	      _this.isTilting = false;
	      _this.tiltInitialCursorAngle = 0;
	      getTiltbarPosition.call(_this);
	      viewerChange$1(_this);

	      if (!Platform().isPc) {
	        document.querySelector('.vc-compass-tiltbar-sm').style.visibility = 'visible';
	        document.querySelector('.vc-compass-arrows-sm').style.visibility = 'visible';
	        document.querySelector('.vc-compass-tilt-sm').style.visibility = 'visible';
	      }
	    });
	  },
	  methods: {
	    handleMouseDown: function handleMouseDown(event) {
	      var _Cesium = Cesium,
	          Cartesian2 = _Cesium.Cartesian2,
	          CesiumMath = _Cesium.Math,
	          SceneMode = _Cesium.SceneMode;
	      var scene = this.viewer.scene;

	      if (scene.mode === SceneMode.MORPHING) {
	        return true;
	      }

	      var compassElement = event.currentTarget;
	      var compassRectangle = event.currentTarget.getBoundingClientRect();
	      var center = new Cartesian2((compassRectangle.right - compassRectangle.left) / 2.0, (compassRectangle.bottom - compassRectangle.top) / 2.0);
	      var clickLocation = event.type === 'mousedown' ? new Cartesian2(event.clientX - compassRectangle.left, event.clientY - compassRectangle.top) : new Cartesian2(event.changedTouches[0].clientX - compassRectangle.left, event.changedTouches[0].clientY - compassRectangle.top);
	      var vector = Cartesian2.subtract(clickLocation, center, vectorScratch$1);
	      this.clickStartPosition = new Cartesian2(event.clientX, event.clientY);
	      var distanceFromCenter = Cartesian2.magnitude(vector);

	      if (distanceFromCenter > 30 && distanceFromCenter < 45) {
	        rotate$1(this, compassElement, vector);
	      } else if (!(distanceFromCenter > 50 && distanceFromCenter < 70)) {
	        rotateEast(this, compassElement, vector);
	      } else {
	        var angle = CesiumMath.PI_OVER_TWO - Math.atan2(-vector.y, vector.x);
	        angle >= 0 && angle <= CesiumMath.PI_OVER_TWO && tilt(this, compassElement, vector);
	      }
	    },
	    handleDoubleClick: function handleDoubleClick(e) {
	      var _Cesium2 = Cesium,
	          Cartesian2 = _Cesium2.Cartesian2,
	          Cartesian3 = _Cesium2.Cartesian3,
	          defined = _Cesium2.defined,
	          Ellipsoid = _Cesium2.Ellipsoid,
	          Matrix4 = _Cesium2.Matrix4,
	          Ray = _Cesium2.Ray,
	          SceneMode = _Cesium2.SceneMode,
	          Transforms = _Cesium2.Transforms;
	      var scene = this.viewer.scene;
	      var camera = scene.camera;

	      if (scene.mode === SceneMode.MORPHING) {
	        return true;
	      }

	      var compassRectangle = e.currentTarget.getBoundingClientRect();
	      var center = new Cartesian2((compassRectangle.right - compassRectangle.left) / 2.0, (compassRectangle.bottom - compassRectangle.top) / 2.0);
	      var clickLocation = e.type === 'dblclick' ? new Cartesian2(e.clientX - compassRectangle.left, e.clientY - compassRectangle.top) : new Cartesian2(e.changedTouches[0].clientX - compassRectangle.left, e.changedTouches[0].clientY - compassRectangle.top);
	      var vector = Cartesian2.subtract(clickLocation, center, vectorScratch$1);
	      this.clickStartPosition = new Cartesian2(e.clientX, e.clientY);
	      var distanceFromCenter = Cartesian2.magnitude(vector);

	      if (distanceFromCenter > 30 && distanceFromCenter < 45) {
	        var windowPosition = new Cartesian2();
	        windowPosition.x = scene.canvas.clientWidth / 2;
	        windowPosition.y = scene.canvas.clientHeight / 2;
	        var pickRayScratch = new Ray();
	        var ray = camera.getPickRay(windowPosition, pickRayScratch);

	        var _center = scene.globe.pick(ray, scene, centerScratch$1);

	        if (!defined(_center)) {
	          // Globe is barely visible, so reset to home view.
	          return;
	        }

	        var rotateFrame = Transforms.eastNorthUpToFixedFrame(_center, Ellipsoid.WGS84);
	        var lookVector = Cartesian3.subtract(_center, camera.position, new Cartesian3());
	        var flight = CameraFlightPath.createTween(scene, {
	          destination: Matrix4.multiplyByPoint(rotateFrame, new Cartesian3(0.0, 0.0, Cartesian3.magnitude(lookVector)), new Cartesian3()),
	          direction: Matrix4.multiplyByPointAsVector(rotateFrame, new Cartesian3(0.0, 0.0, -1.0), new Cartesian3()),
	          up: Matrix4.multiplyByPointAsVector(rotateFrame, new Cartesian3(0.0, 1.0, 0.0), new Cartesian3()),
	          duration: 1.5
	        });
	        scene.tweens.add(flight);
	      }
	    },
	    handleMouseUp: function handleMouseUp(event) {
	      var _Cesium3 = Cesium,
	          Cartesian2 = _Cesium3.Cartesian2,
	          CesiumMath = _Cesium3.Math;
	      var compassRectangle = event.currentTarget.getBoundingClientRect();
	      var center = new Cartesian2((compassRectangle.right - compassRectangle.left) / 2.0, (compassRectangle.bottom - compassRectangle.top) / 2.0);
	      var clickLocation = event.type === 'mouseup' ? new Cartesian2(event.clientX - compassRectangle.left, event.clientY - compassRectangle.top) : new Cartesian2(event.changedTouches[0].clientX - compassRectangle.left, event.changedTouches[0].clientY - compassRectangle.top);
	      var vector = Cartesian2.subtract(clickLocation, center, vectorScratch$1);
	      var magnitude = Cartesian2.magnitude(vector);

	      if (magnitude > 30 && magnitude < 45) {
	        var angle = CesiumMath.toDegrees(Math.atan2(-vector.y, vector.x));
	        var clickStartPosition = new Cartesian2(event.clientX, event.clientY);
	        var dX = clickStartPosition.x - this.clickStartPosition.x;
	        var dY = clickStartPosition.y - this.clickStartPosition.y;
	        var distance = Math.sqrt(dX * dX + dY * dY);

	        if (distance > 5) {
	          return;
	        }

	        var heading = CesiumMath.toDegrees(this.heading);
	        var m = Math.abs(angle - heading);
	        var scene = this.viewer.scene;

	        if (angle > 0 && heading > 0 && heading < 90 && m > 80 && m < 100 || m > 260 && m < 280) {
	          scene.camera.flyTo({
	            destination: scene.camera.position,
	            orientation: {
	              heading: 0,
	              pitch: scene.camera.pitch
	            }
	          });
	        }
	      }
	    }
	  },
	  destroyed: function destroyed() {
	    this.screenSpaceEventHandler && this.screenSpaceEventHandler.destroy();
	  }
	};
	var vectorScratch$1 = {};
	var oldTransformScratch$1 = {};
	var newTransformScratch$1 = {};
	var centerScratch$1 = {};
	var positions$1 = [{
	  x: 56,
	  y: 3
	}, {
	  x: 59,
	  y: 4
	}, {
	  x: 64,
	  y: 5
	}, {
	  x: 69,
	  y: 6
	}, {
	  x: 74,
	  y: 7
	}, {
	  x: 79,
	  y: 9
	}, {
	  x: 84,
	  y: 12
	}, {
	  x: 89,
	  y: 15
	}, {
	  x: 92,
	  y: 19
	}, {
	  x: 94,
	  y: 20
	}, {
	  x: 99,
	  y: 25
	}, {
	  x: 104,
	  y: 34
	}, {
	  x: 106,
	  y: 40
	}, {
	  x: 107,
	  y: 44
	}, {
	  x: 107,
	  y: 46
	}, {
	  x: 107,
	  y: 48
	}, {
	  x: 107,
	  y: 50
	}, {
	  x: 107,
	  y: 52
	}, {
	  x: 107,
	  y: 54
	}, {
	  x: 107,
	  y: 56
	}];

	function rotate$1(viewModel, compassElement, cursorVector) {
	  if (!viewModel.enableCompassOuterRing) {
	    return;
	  }

	  var _Cesium4 = Cesium,
	      Cartesian2 = _Cesium4.Cartesian2,
	      Cartesian3 = _Cesium4.Cartesian3,
	      defined = _Cesium4.defined,
	      CesiumMath = _Cesium4.Math,
	      Matrix4 = _Cesium4.Matrix4,
	      Ellipsoid = _Cesium4.Ellipsoid,
	      Ray = _Cesium4.Ray,
	      Transforms = _Cesium4.Transforms; // Remove existing event handlers, if any.

	  document.removeEventListener('mousemove', viewModel.rotateMouseMoveFunction, false);
	  document.removeEventListener('touchmove', viewModel.rotateMouseMoveFunction, false);
	  document.removeEventListener('mouseup', viewModel.rotateMouseUpFunction, false);
	  document.removeEventListener('touchend', viewModel.rotateMouseUpFunction, false);
	  viewModel.rotateMouseMoveFunction = undefined;
	  viewModel.rotateMouseUpFunction = undefined;
	  viewModel.isRotating = true;
	  viewModel.rotateInitialCursorAngle = Math.atan2(-cursorVector.y, cursorVector.x);
	  var scene = viewModel.viewer.scene;
	  var camera = scene.camera;
	  var windowPosition = new Cartesian2();
	  windowPosition.x = scene.canvas.clientWidth / 2;
	  windowPosition.y = scene.canvas.clientHeight / 2;
	  var pickRayScratch = new Ray();
	  var ray = camera.getPickRay(windowPosition, pickRayScratch);
	  var viewCenter = scene.globe.pick(ray, scene, centerScratch$1);

	  if (!defined(viewCenter)) {
	    viewModel.rotateFrame = Transforms.eastNorthUpToFixedFrame(camera.positionWC, Ellipsoid.WGS84, newTransformScratch$1);
	    viewModel.rotateIsLook = true;
	  } else {
	    viewModel.rotateFrame = Transforms.eastNorthUpToFixedFrame(viewCenter, Ellipsoid.WGS84, newTransformScratch$1);
	    viewModel.rotateIsLook = false;
	  }

	  var oldTransform = Matrix4.clone(camera.transform, oldTransformScratch$1);
	  camera.lookAtTransform(viewModel.rotateFrame);
	  viewModel.rotateInitialCameraAngle = Math.atan2(camera.position.y, camera.position.x);
	  viewModel.rotateInitialCameraDistance = Cartesian3.magnitude(new Cartesian3(camera.position.x, camera.position.y, 0.0));
	  camera.lookAtTransform(oldTransform);

	  viewModel.rotateMouseMoveFunction = function (event) {
	    var compassRectangle = compassElement.getBoundingClientRect();
	    var center = new Cartesian2((compassRectangle.right - compassRectangle.left) / 2.0, (compassRectangle.bottom - compassRectangle.top) / 2.0);
	    var clickLocation = event.type === 'mousedown' || event.type === 'mousemove' ? new Cartesian2(event.clientX - compassRectangle.left, event.clientY - compassRectangle.top) : new Cartesian2(event.changedTouches[0].clientX - compassRectangle.left, event.changedTouches[0].clientY - compassRectangle.top);
	    var vector = Cartesian2.subtract(clickLocation, center, vectorScratch$1);
	    var angle = Math.atan2(-vector.y, vector.x);
	    var angleDifference = angle - viewModel.rotateInitialCursorAngle;
	    var newCameraAngle = CesiumMath.zeroToTwoPi(viewModel.rotateInitialCameraAngle - angleDifference);
	    camera = viewModel.viewer.scene.camera;
	    oldTransform = Matrix4.clone(camera.transform, oldTransformScratch$1);
	    camera.lookAtTransform(viewModel.rotateFrame);
	    var currentCameraAngle = Math.atan2(camera.position.y, camera.position.x);
	    camera.rotateRight(newCameraAngle - currentCameraAngle);
	    camera.lookAtTransform(oldTransform);
	  };

	  viewModel.rotateMouseUpFunction = function () {
	    viewModel.isRotating = false;
	    document.removeEventListener('mousemove', viewModel.rotateMouseMoveFunction, false);
	    document.removeEventListener('touchmove', viewModel.rotateMouseMoveFunction, false);
	    document.removeEventListener('mouseup', viewModel.rotateMouseUpFunction, false);
	    document.removeEventListener('touchend', viewModel.rotateMouseUpFunction, false);
	    viewModel.rotateMouseMoveFunction = undefined;
	    viewModel.rotateMouseUpFunction = undefined;
	  };

	  document.addEventListener('mousemove', viewModel.rotateMouseMoveFunction, false);
	  document.addEventListener('touchmove', viewModel.rotateMouseMoveFunction, false);
	  document.addEventListener('mouseup', viewModel.rotateMouseUpFunction, false);
	  document.addEventListener('touchend', viewModel.rotateMouseUpFunction, false);
	}

	function rotateEast(viewModel, compassElement, cursorVector) {
	  var _Cesium5 = Cesium,
	      defined = _Cesium5.defined,
	      getTimestamp = _Cesium5.getTimestamp,
	      CesiumMath = _Cesium5.Math,
	      ScreenSpaceEventType = _Cesium5.ScreenSpaceEventType;
	  viewModel.screenSpaceEventHandler.removeInputAction(ScreenSpaceEventType.LEFT_UP);
	  defined(viewModel.rotateEastTickFunction) && viewModel.viewer.clock.onTick.removeEventListener(viewModel.rotateEastTickFunction);
	  viewModel.rotateEastMouseUpFunction = undefined;
	  viewModel.rotateEastTickFunction = undefined;
	  viewModel.isrotateEasting = true;
	  viewModel.rotateEastLastTimestamp = getTimestamp();
	  var angle = CesiumMath.PI_OVER_TWO - Math.atan2(-cursorVector.y, cursorVector.x);
	  var a = Math.PI / 4;
	  var roateDirection = 0;
	  var roateType = {
	    LEFT: 1,
	    RIGHT: 2,
	    UP: 3,
	    DOWN: 4
	  };
	  roateDirection = angle >= -a && a >= angle ? roateType.DOWN : angle >= a && 3 * a >= angle ? roateType.RIGHT : angle >= 3 * a && 5 * a >= angle ? roateType.UP : roateType.LEFT;

	  viewModel.rotateEastTickFunction = function () {
	    var scene = viewModel.viewer.scene;
	    var camera = scene.camera;
	    var timestamp = getTimestamp();
	    angle = 20 * Math.abs(camera.positionCartographic.height / 6378317) * 0.0005;

	    switch (roateDirection) {
	      case roateType.LEFT:
	        camera.rotateLeft(angle);
	        break;

	      case roateType.RIGHT:
	        camera.rotateRight(angle);
	        break;

	      case roateType.UP:
	        camera.rotate(camera.right, -angle);
	        break;

	      case roateType.DOWN:
	        camera.rotate(camera.right, angle);
	    }

	    viewModel.rotateLastTimestamp = timestamp;
	  };

	  viewModel.rotateEastMouseUpFunction = function () {
	    viewModel.isRotateEasting = false;
	    viewModel.screenSpaceEventHandler.removeInputAction(ScreenSpaceEventType.LEFT_UP);
	    defined(viewModel.rotateEastTickFunction) && viewModel.viewer.clock.onTick.removeEventListener(viewModel.rotateEastTickFunction);
	    viewModel.rotateEastMouseUpFunction = undefined;
	    viewModel.rotateEastTickFunction = undefined;
	  };

	  viewModel.screenSpaceEventHandler.setInputAction(viewModel.rotateEastMouseUpFunction, ScreenSpaceEventType.LEFT_UP);
	  viewModel.viewer.clock.onTick.addEventListener(viewModel.rotateEastTickFunction);
	}

	function tilt(viewModel, compassElement, cursorVector) {
	  var _Cesium6 = Cesium,
	      Cartesian2 = _Cesium6.Cartesian2,
	      defined = _Cesium6.defined,
	      CesiumMath = _Cesium6.Math,
	      Matrix4 = _Cesium6.Matrix4,
	      ScreenSpaceEventType = _Cesium6.ScreenSpaceEventType,
	      Transforms = _Cesium6.Transforms; // Remove existing event handlers, if any.

	  viewModel.screenSpaceEventHandler.removeInputAction(ScreenSpaceEventType.MOUSE_MOVE);
	  viewModel.screenSpaceEventHandler.removeInputAction(ScreenSpaceEventType.LEFT_UP);
	  viewModel.tiltMouseMoveFunction = undefined;
	  viewModel.tiltMouseUpFunction = undefined;
	  var tiltInitialCursorAngle = CesiumMath.PI_OVER_TWO - Math.atan2(-cursorVector.y, cursorVector.x);
	  tiltInitialCursorAngle = tiltInitialCursorAngle < 0 ? 0 : tiltInitialCursorAngle;
	  tiltInitialCursorAngle = tiltInitialCursorAngle > CesiumMath.PI_OVER_TWO ? CesiumMath.PI_OVER_TWO : tiltInitialCursorAngle;
	  viewModel.tiltInitialCursorAngle = tiltInitialCursorAngle;
	  viewModel.isTilting = true;
	  var scene = viewModel.viewer.scene;
	  var camera = scene.camera;
	  var windowPosition = new Cartesian2();
	  windowPosition.x = scene.canvas.clientWidth / 2;
	  windowPosition.y = scene.canvas.clientHeight / 2;
	  var pickPosition = camera.pickEllipsoid(windowPosition, scene.ellipsoid);

	  if (!defined(pickPosition)) {
	    for (; windowPosition.y < scene.canvas.clientHeight;) {
	      windowPosition.y += 5;
	      pickPosition = camera.pickEllipsoid(windowPosition, scene.globe.ellipsoid);
	    }
	  }

	  defined(pickPosition) && (viewModel.tiltFrame = Transforms.eastNorthUpToFixedFrame(pickPosition, scene.globe.ellipsoid));

	  viewModel.tiltMouseMoveFunction = function (e, n) {
	    viewModel.isTilting = true;
	    var compassRectangle = compassElement.getBoundingClientRect();
	    var center = new Cesium.Cartesian2((compassRectangle.right - compassRectangle.left) / 2.0, (compassRectangle.bottom - compassRectangle.top) / 2.0);
	    var endPosition = Cartesian2.clone(e.endPosition);
	    var vector = Cartesian2.subtract(endPosition, center, vectorScratch$1);
	    var angle = CesiumMath.PI_OVER_TWO - Math.atan2(-vector.y, vector.x);
	    angle = angle < 0 ? 0 : angle;
	    angle = angle > CesiumMath.PI_OVER_TWO ? CesiumMath.PI_OVER_TWO : angle;
	    var camera = viewModel.viewer.scene.camera;
	    var oldTransform = Matrix4.clone(camera.transform, oldTransformScratch$1);
	    camera.lookAtTransform(viewModel.tiltFrame);
	    var rotateUpAngle = angle - viewModel.tiltInitialCursorAngle;
	    camera.rotateUp(rotateUpAngle);
	    viewModel.tiltInitialCursorAngle = angle;
	    camera.lookAtTransform(oldTransform);
	    var level = Math.ceil(angle / (Math.PI / 40));
	    level = level > 19 ? 19 : level;
	    var position = positions$1[level];
	    viewModel.tiltbarLeft = position.x;
	    viewModel.tiltbarTop = position.y;
	  };

	  viewModel.tiltMouseUpFunction = function (e) {
	    viewModel.isTilting = false;
	    viewModel.screenSpaceEventHandler.removeInputAction(ScreenSpaceEventType.MOUSE_MOVE);
	    viewModel.screenSpaceEventHandler.removeInputAction(ScreenSpaceEventType.LEFT_UP);
	    viewModel.tiltMouseMoveFunction = undefined;
	    viewModel.tiltMouseUpFunction = undefined;
	  };

	  viewModel.screenSpaceEventHandler.setInputAction(viewModel.tiltMouseMoveFunction, ScreenSpaceEventType.MOUSE_MOVE);
	  viewModel.screenSpaceEventHandler.setInputAction(viewModel.tiltMouseUpFunction, ScreenSpaceEventType.LEFT_UP);
	}

	function getTiltbarPosition() {
	  var _Cesium7 = Cesium,
	      CesiumMath = _Cesium7.Math;
	  var pitch = CesiumMath.PI_OVER_TWO + this.viewer.scene.camera.pitch;
	  var length = Math.PI / 2 / 20;
	  var level = Math.floor(pitch / length);
	  level = level > 19 ? 19 : level;
	  level = level < 0 ? 0 : level;
	  this.tiltbarLeft = positions$1[level].x;
	  this.tiltbarTop = positions$1[level].y;
	}

	function viewerChange$1(viewModel) {
	  var _Cesium8 = Cesium,
	      defined = _Cesium8.defined,
	      CesiumMath = _Cesium8.Math;

	  if (defined(viewModel.viewer)) {
	    if (viewModel._unsubcribeFromPostRender) {
	      viewModel._unsubcribeFromPostRender();

	      viewModel._unsubcribeFromPostRender = undefined;
	    }

	    viewModel._unsubcribeFromPostRender = viewModel.viewer.scene.postRender.addEventListener(function () {
	      viewModel.heading = viewModel.viewer.scene.camera.heading;

	      if (!viewModel.isTilting) {
	        var angle = viewModel.viewer.scene.camera.pitch + CesiumMath.PI_OVER_TWO;
	        var length = CesiumMath.PI_OVER_TWO / 20;
	        var level = Math.floor(angle / length);
	        level = level > 19 ? 19 : level;
	        level = level < 0 ? 0 : level;
	        viewModel.tiltbarLeft = positions$1[level].x;
	        viewModel.tiltbarTop = positions$1[level].y;
	      }
	    });
	  } else {
	    if (viewModel._unsubcribeFromPostRender) {
	      viewModel._unsubcribeFromPostRender();

	      viewModel._unsubcribeFromPostRender = undefined;
	    }
	  }
	}

	/* script */
	var __vue_script__$1K = script$1K;
	/* template */

	var __vue_render__$h = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('div', {
	    staticClass: "vc-compass-sm",
	    attrs: {
	      "title": _vm.$vc.lang.navigation.compass.description
	    },
	    on: {
	      "dblclick": _vm.handleDoubleClick,
	      "mousedown": _vm.handleMouseDown,
	      "mouseup": _vm.handleMouseUp,
	      "touchend": _vm.handleMouseUp,
	      "touchstart": _vm.handleMouseDown
	    }
	  }, [_c('div', {
	    staticClass: "vc-compass-tilt-sm"
	  }), _vm._v(" "), _c('div', {
	    staticClass: "vc-compass-tiltbar-sm",
	    style: _vm.tiltbarStyle
	  }), _vm._v(" "), _c('div', {
	    staticClass: "vc-compass-arrows-sm"
	  }), _vm._v(" "), _c('div', {
	    staticClass: "vc-compass-outer-ring-sm",
	    style: _vm.outerRingStyle
	  }), _vm._v(" "), _c('div', {
	    staticClass: "vc-arrows-e-sm"
	  }), _vm._v(" "), _c('div', {
	    staticClass: "vc-arrows-n-sm"
	  }), _vm._v(" "), _c('div', {
	    staticClass: "vc-arrows-s-sm"
	  }), _vm._v(" "), _c('div', {
	    staticClass: "vc-arrows-w-sm"
	  })]);
	};

	var __vue_staticRenderFns__$h = [];
	/* style */

	var __vue_inject_styles__$1K = undefined;
	/* scoped */

	var __vue_scope_id__$1K = undefined;
	/* functional template */

	var __vue_is_functional_template__$1K = false;
	/* component normalizer */

	function __vue_normalize__$1K(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "VcCompassSM.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var VcCompassSM = __vue_normalize__$1K({
	  render: __vue_render__$h,
	  staticRenderFns: __vue_staticRenderFns__$h
	}, __vue_inject_styles__$1K, __vue_script__$1K, __vue_scope_id__$1K, __vue_is_functional_template__$1K);

	//
	var script$1L = {
	  data: function data() {
	    return {
	      zoombarTop: 65
	    };
	  },
	  computed: {
	    zoombarStyle: function zoombarStyle() {
	      return {
	        top: this.zoombarTop + 'px'
	      };
	    }
	  },
	  mounted: function mounted() {
	    var _this = this;

	    this.$parent.createPromise.then(function (_ref) {
	      var Cesium = _ref.Cesium,
	          viewer = _ref.viewer;
	      _this.viewer = viewer;
	      _this.container = _this.$parent.$refs.navigationContainer;
	      _this.screenSpaceEventHandler = new Cesium.ScreenSpaceEventHandler(_this.container);
	      Platform().isPc || (document.querySelector('.sm-zoom').style.visibility = 'visible');
	    });
	  },
	  methods: {
	    handleZoomBarScrollMouseDown: function handleZoomBarScrollMouseDown(event) {
	      var viewModel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;
	      var _Cesium = Cesium,
	          Cartesian2 = _Cesium.Cartesian2,
	          defined = _Cesium.defined,
	          SceneMode = _Cesium.SceneMode;
	      document.removeEventListener('mousemove', viewModel.zoomBarScrollMouseMoveFunction, false);
	      document.removeEventListener('touchmove', viewModel.zoomBarScrollMouseMoveFunction, false);
	      document.removeEventListener('mouseup', viewModel.zoomBarScrollMouseUpFunction, false);
	      document.removeEventListener('touchend', viewModel.zoomBarScrollMouseUpFunction, false);
	      defined(viewModel.zoombarTickFunction) && viewModel.viewer.clock.onTick.removeEventListener(viewModel.zoombarTickFunction);
	      viewModel.zoomBarScrollMouseUpFunction = undefined;
	      viewModel.zoombarTickFunction = undefined;
	      viewModel.isZoomBarScrolling = true;
	      var scene = viewModel.viewer.scene;
	      var camera = scene.camera;

	      viewModel.zoombarTickFunction = function () {
	        var zoomOffset = viewModel.zoombarTop - 65;

	        if (zoomOffset > 0) {
	          if (viewModel.viewer.scene.mode === SceneMode.COLUMBUS_VIEW) {
	            camera.zoomOut();
	          } else {
	            handlezoom(viewModel, -1);
	          }
	        } else if (zoomOffset < 0) {
	          if (viewModel.viewer.scene.mode === SceneMode.COLUMBUS_VIEW) {
	            camera.zoomIn();
	          } else {
	            handlezoom(viewModel, 1);
	          }
	        }
	      };

	      viewModel.zoomBarScrollMouseMoveFunction = function (e) {
	        var zoombarTop = viewModel.zoombarTop;
	        var clientRect = e.target.parentElement.getBoundingClientRect();
	        var rectNavigation = viewModel.container.getBoundingClientRect();
	        var endPosition = {};
	        endPosition.x = e.type === 'touchmove' ? e.changedTouches[0].clientX - rectNavigation.left : e.clientX - rectNavigation.left;
	        endPosition.y = e.type === 'touchmove' ? e.changedTouches[0].clientY - rectNavigation.top : e.clientY - rectNavigation.top; // 加上一个距离顶部的偏移量 rectViewer.top

	        var rectViewer = viewModel.viewer._element.getBoundingClientRect();

	        var padding = new Cartesian2(endPosition.x - clientRect.left, endPosition.y - clientRect.top + rectViewer.top);
	        var offset = padding.y - 16;
	        offset = offset < 0 ? 0 : offset;
	        offset = offset > 120 ? 120 : offset;
	        viewModel.zoombarTop = offset;
	        var zoomFlag = viewModel.zoombarTop - zoombarTop;

	        if (zoomFlag > 0) {
	          if (viewModel.viewer.scene.mode === SceneMode.COLUMBUS_VIEW) {
	            camera.zoomOut();
	          } else {
	            handlezoom(viewModel, -1);
	          }
	        } else {
	          if (viewModel.viewer.scene.mode === SceneMode.COLUMBUS_VIEW) {
	            camera.zoomIn();
	          } else {
	            handlezoom(viewModel, 1);
	          }
	        }
	      };

	      viewModel.zoomBarScrollMouseUpFunction = function () {
	        viewModel.isZoomBarScrolling = false;
	        document.removeEventListener('mousemove', viewModel.zoomBarScrollMouseMoveFunction, false);
	        document.removeEventListener('touchmove', viewModel.zoomBarScrollMouseMoveFunction, false);
	        document.removeEventListener('mouseup', viewModel.zoomBarScrollMouseUpFunction, false);
	        document.removeEventListener('touchend', viewModel.zoomBarScrollMouseUpFunction, false);
	        defined(viewModel.zoombarTickFunction) && viewModel.viewer.clock.onTick.removeEventListener(viewModel.zoombarTickFunction);
	        viewModel.zoomBarScrollMouseUpFunction = undefined;
	        viewModel.zoomBarScrollMouseMoveFunction = undefined;
	        viewModel.zoombarTickFunction = undefined;
	        viewModel.zoombarTop = 65;
	      };

	      document.addEventListener('mousemove', viewModel.zoomBarScrollMouseMoveFunction, false);
	      document.addEventListener('touchmove', viewModel.zoomBarScrollMouseMoveFunction, false);
	      document.addEventListener('mouseup', viewModel.zoomBarScrollMouseUpFunction, false);
	      document.addEventListener('touchend', viewModel.zoomBarScrollMouseUpFunction, false);
	      viewModel.viewer.clock.onTick.addEventListener(viewModel.zoombarTickFunction);
	    },
	    handleZoomInMouseDown: function handleZoomInMouseDown(event) {
	      var viewModel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;
	      var _Cesium2 = Cesium,
	          defined = _Cesium2.defined,
	          getTimestamp = _Cesium2.getTimestamp,
	          SceneMode = _Cesium2.SceneMode,
	          ScreenSpaceEventType = _Cesium2.ScreenSpaceEventType;
	      viewModel.screenSpaceEventHandler.removeInputAction(ScreenSpaceEventType.LEFT_UP);
	      defined(viewModel.zoominTickFunction) && viewModel.viewer.clock.onTick.removeEventListener(viewModel.zoominTickFunction);
	      viewModel.zoominMouseUpFunction = undefined;
	      viewModel.zoominTickFunction = undefined;
	      viewModel.isZoomin = true;
	      viewModel.zoominLastTimestamp = getTimestamp();
	      var scene = viewModel.viewer.scene;
	      var camera = scene.camera;

	      viewModel.zoominTickFunction = function () {
	        viewModel.viewer.scene.mode === SceneMode.COLUMBUS_VIEW ? camera.zoomIn() : handlezoom(viewModel, 1);
	      };

	      viewModel.zoominMouseUpFunction = function () {
	        viewModel.isZoomin = false;
	        viewModel.screenSpaceEventHandler.removeInputAction(ScreenSpaceEventType.LEFT_UP);
	        defined(viewModel.zoominTickFunction) && viewModel.viewer.clock.onTick.removeEventListener(viewModel.zoominTickFunction);
	        viewModel.zoominMouseUpFunction = undefined;
	        viewModel.zoominTickFunction = undefined;
	      };

	      viewModel.screenSpaceEventHandler.setInputAction(viewModel.zoominMouseUpFunction, ScreenSpaceEventType.LEFT_UP);
	      viewModel.viewer.clock.onTick.addEventListener(viewModel.zoominTickFunction);
	    },
	    handleZoomOutMouseDown: function handleZoomOutMouseDown(event) {
	      var viewModel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;
	      var _Cesium3 = Cesium,
	          defined = _Cesium3.defined,
	          getTimestamp = _Cesium3.getTimestamp,
	          SceneMode = _Cesium3.SceneMode,
	          ScreenSpaceEventType = _Cesium3.ScreenSpaceEventType;
	      viewModel.screenSpaceEventHandler.removeInputAction(ScreenSpaceEventType.LEFT_UP);
	      defined(viewModel.zoomoutTickFunction) && viewModel.viewer.clock.onTick.removeEventListener(viewModel.zoomoutTickFunction);
	      viewModel.zoomoutMouseUpFunction = undefined;
	      viewModel.zoomoutTickFunction = undefined;
	      viewModel.iszoomout = false;
	      viewModel.zoomoutLastTimestamp = getTimestamp();
	      var scene = viewModel.viewer.scene;
	      var camera = scene.camera;

	      viewModel.zoomoutTickFunction = function () {
	        viewModel.viewer.scene.mode === SceneMode.COLUMBUS_VIEW ? camera.zoomOut() : handlezoom(viewModel, -1);
	      };

	      viewModel.zoomoutMouseUpFunction = function () {
	        viewModel.iszoomout = false;
	        viewModel.screenSpaceEventHandler.removeInputAction(ScreenSpaceEventType.LEFT_UP);
	        defined(viewModel.zoomoutTickFunction) && viewModel.viewer.clock.onTick.removeEventListener(viewModel.zoomoutTickFunction);
	        viewModel.zoomoutMouseUpFunction = undefined;
	        viewModel.zoomoutTickFunction = undefined;
	      };

	      viewModel.screenSpaceEventHandler.setInputAction(viewModel.zoomoutMouseUpFunction, ScreenSpaceEventType.LEFT_UP);
	      viewModel.viewer.clock.onTick.addEventListener(viewModel.zoomoutTickFunction);
	    }
	  },
	  destroyed: function destroyed() {
	    this.screenSpaceEventHandler && this.screenSpaceEventHandler.destroy();
	  }
	};

	function handlezoom(viewModel, i) {
	  var _Cesium4 = Cesium,
	      Cartesian2 = _Cesium4.Cartesian2,
	      Cartesian3 = _Cesium4.Cartesian3,
	      defined = _Cesium4.defined,
	      Ellipsoid = _Cesium4.Ellipsoid,
	      Math = _Cesium4.Math;
	  var scene = viewModel.viewer.scene;
	  var camera = scene.camera;
	  var canvas = scene.canvas;
	  var centerPixel = new Cartesian2();
	  centerPixel.x = canvas.clientWidth / 2;
	  centerPixel.y = canvas.clientHeight / 2;
	  var centerPosition = pickGlobe(viewModel, centerPixel);

	  if (defined(centerPosition)) {
	    var distance = Cartesian3.distance(camera.position, centerPosition);
	    var factor = 0.0618 * i * 0.2;
	    factor = distance > 300 ? factor : 2 * factor;
	    var amount = distance * factor;
	    var direction = {};
	    Cartesian3.subtract(centerPosition, camera.position, direction);
	    var cameraRight = Cartesian3.clone(camera.right);
	    var dot = Cartesian3.dot(direction, cameraRight);
	    var movementVector = {};
	    Cartesian3.multiplyByScalar(cameraRight, dot, movementVector);
	    Cartesian3.subtract(direction, movementVector, direction);
	    Cartesian3.normalize(direction, direction);
	    camera.move(direction, amount);
	    var centerPositionNormal = {};
	    Cartesian3.normalize(centerPosition, centerPositionNormal);
	    var centerDistance = Cartesian3.magnitude(centerPosition);
	    var ellipsoid = Ellipsoid.fromCartesian3(centerDistance);
	    var pickPosition = camera.pickEllipsoid(centerPixel, ellipsoid);

	    if (defined(pickPosition) && !isNaN(pickPosition.x) && !isNaN(pickPosition.y) && !isNaN(pickPosition.z) && !(camera.positionCartographic.height < 0)) {
	      Cartesian3.normalize(pickPosition, pickPosition);
	      var angle = Cartesian3.angleBetween(centerPositionNormal, pickPosition);

	      if (!Math.equalsEpsilon(angle, 0, Math.EPSILON10)) {
	        var axis = Cartesian3.cross(centerPositionNormal, pickPosition);
	        camera.rotate(axis, angle);
	      }
	    }
	  }
	}

	function pickGlobe(viewModel, mousePosition) {
	  var _Cesium5 = Cesium,
	      defined = _Cesium5.defined,
	      Cartesian3 = _Cesium5.Cartesian3;
	  var scene = viewModel.viewer.scene;
	  var globe = scene.globe;
	  var camera = scene.camera;

	  if (defined(globe)) {
	    var depthIntersection;

	    if (scene.pickPositionSupported) {
	      depthIntersection = scene.pickPositionWorldCoordinates(mousePosition);
	    }

	    var ray = camera.getPickRay(mousePosition);
	    var rayIntersection = globe.pick(ray, scene);
	    var pickDistance = defined(depthIntersection) ? Cartesian3.distance(depthIntersection, camera.positionWC) : Number.POSITIVE_INFINITY;
	    var rayDistance = defined(rayIntersection) ? Cartesian3.distance(rayIntersection, camera.positionWC) : Number.POSITIVE_INFINITY;
	    return rayDistance > pickDistance ? depthIntersection : rayIntersection;
	  }
	}

	/* script */
	var __vue_script__$1L = script$1L;
	/* template */

	var __vue_render__$i = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('div', {
	    staticClass: "vc-zoom-sm"
	  }, [_c('div', {
	    staticClass: "vc-zoomin-sm",
	    attrs: {
	      "title": _vm.$vc.lang.navigation.zoomCotrol.zoomIn
	    },
	    on: {
	      "mousedown": _vm.handleZoomInMouseDown,
	      "touchstart": _vm.handleZoomInMouseDown
	    }
	  }), _vm._v(" "), _c('div', {
	    staticClass: "vc-zoomout-sm",
	    attrs: {
	      "title": _vm.$vc.lang.navigation.zoomCotrol.zoomOut
	    },
	    on: {
	      "mousedown": _vm.handleZoomOutMouseDown,
	      "touchstart": _vm.handleZoomOutMouseDown
	    }
	  }), _vm._v(" "), _c('div', {
	    staticClass: "vc-zoombar-sm",
	    style: _vm.zoombarStyle,
	    on: {
	      "mousedown": _vm.handleZoomBarScrollMouseDown,
	      "touchstart": _vm.handleZoomBarScrollMouseDown
	    }
	  })]);
	};

	var __vue_staticRenderFns__$i = [];
	/* style */

	var __vue_inject_styles__$1L = undefined;
	/* scoped */

	var __vue_scope_id__$1L = undefined;
	/* functional template */

	var __vue_is_functional_template__$1L = false;
	/* component normalizer */

	function __vue_normalize__$1L(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "VcZoomControlSM.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var VcZoomControlSM = __vue_normalize__$1L({
	  render: __vue_render__$i,
	  staticRenderFns: __vue_staticRenderFns__$i
	}, __vue_inject_styles__$1L, __vue_script__$1L, __vue_scope_id__$1L, __vue_is_functional_template__$1L);

	var script$1M = {
	  name: 'vc-navigation-sm',
	  components: {
	    'vc-compass-sm': VcCompassSM,
	    'vc-zoom-control-sm': VcZoomControlSM
	  },
	  data: function data() {
	    return {
	      defaultOptions: {
	        enableCompass: true,
	        enableCompassOuterRing: true,
	        enableZoomControl: true
	      },
	      ncTop: 0
	    };
	  },
	  mixins: [cmp],
	  props: {
	    options: Object
	  },
	  computed: {
	    navigationContainerStyle: function navigationContainerStyle() {
	      return {
	        top: this.ncTop + 'px'
	      };
	    }
	  },
	  watch: {
	    options: {
	      handler: function handler() {
	        this.reload();
	      },
	      deep: true
	    }
	  },
	  methods: {
	    createCesiumObject: function createCesiumObject() {
	      return regenerator.async(function createCesiumObject$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              assign$1(this.defaultOptions, this.options);

	              this.viewer.widgetResized.addEventListener(this.widgetResized);
	              this.widgetResized();

	            case 3:
	            case "end":
	              return _context.stop();
	          }
	        }
	      }, null, this);
	    },
	    mount: function mount() {
	      return regenerator.async(function mount$(_context2) {
	        while (1) {
	          switch (_context2.prev = _context2.next) {
	            case 0:
	              return _context2.abrupt("return", true);

	            case 1:
	            case "end":
	              return _context2.stop();
	          }
	        }
	      });
	    },
	    unmount: function unmount() {
	      return regenerator.async(function unmount$(_context3) {
	        while (1) {
	          switch (_context3.prev = _context3.next) {
	            case 0:
	              return _context3.abrupt("return", true);

	            case 1:
	            case "end":
	              return _context3.stop();
	          }
	        }
	      });
	    },
	    widgetResized: function widgetResized() {
	      var viewer = this.viewer;
	      var ncTop = 0;
	      viewer._toolbar && (ncTop += viewer._toolbar.getBoundingClientRect().height);
	      this.ncTop = ncTop;
	    }
	  },
	  stubVNode: {
	    empty: function empty() {
	      return this.$options.name;
	    }
	  },
	  created: function created() {
	    var _this = this;

	    defineProperties$1(this, {
	      cesiumNavigation: {
	        enumerable: true,
	        get: function get() {
	          return _this.$services && _this.cesiumObject;
	        }
	      }
	    });
	  }
	};

	/* script */
	var __vue_script__$1M = script$1M;
	/* template */

	var __vue_render__$j = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('div', {
	    ref: "navigationContainer",
	    staticClass: "vc-navigationContainer-sm",
	    style: _vm.navigationContainerStyle
	  }, [_vm.defaultOptions.enableCompass ? _c('vc-compass-sm', {
	    attrs: {
	      "enableCompassOuterRing": _vm.defaultOptions.enableCompassOuterRing
	    }
	  }) : _vm._e(), _vm._v(" "), _vm.defaultOptions.enableZoomControl ? _c('vc-zoom-control-sm') : _vm._e()], 1);
	};

	var __vue_staticRenderFns__$j = [];
	/* style */

	var __vue_inject_styles__$1M = undefined;
	/* scoped */

	var __vue_scope_id__$1M = undefined;
	/* functional template */

	var __vue_is_functional_template__$1M = false;
	/* component normalizer */

	function __vue_normalize__$1M(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "VcNavigationSM.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var VcNavigationSM = __vue_normalize__$1M({
	  render: __vue_render__$j,
	  staticRenderFns: __vue_staticRenderFns__$j
	}, __vue_inject_styles__$1M, __vue_script__$1M, __vue_scope_id__$1M, __vue_is_functional_template__$1M);

	function plugin$1C(Vue) {

	  if (plugin$1C.installed) {
	    return;
	  }

	  plugin$1C.installed = true;
	  Vue.component(VcNavigationSM.name, VcNavigationSM);
	}

	var index = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$1C,
		VcNavigationSM: VcNavigationSM,
		install: plugin$1C
	});

	/* @preserve
	 * Leaflet 1.6.0, a JS library for interactive maps. http://leafletjs.com
	 * (c) 2010-2019 Vladimir Agafonkin, (c) 2010-2011 CloudMade
	 */

	/*
	 * @namespace Util
	 *
	 * Various utility functions, used by Leaflet internally.
	 */

	var freeze$2 = Object.freeze;
	Object.freeze = function (obj) { return obj; };

	// @function extend(dest: Object, src?: Object): Object
	// Merges the properties of the `src` object (or multiple objects) into `dest` object and returns the latter. Has an `L.extend` shortcut.
	function extend$1(dest) {
		var i, j, len, src;

		for (j = 1, len = arguments.length; j < len; j++) {
			src = arguments[j];
			for (i in src) {
				dest[i] = src[i];
			}
		}
		return dest;
	}

	// @function create(proto: Object, properties?: Object): Object
	// Compatibility polyfill for [Object.create](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/create)
	var create$2 = Object.create || (function () {
		function F() {}
		return function (proto) {
			F.prototype = proto;
			return new F();
		};
	})();

	// @function bind(fn: Function, …): Function
	// Returns a new function bound to the arguments passed, like [Function.prototype.bind](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
	// Has a `L.bind()` shortcut.
	function bind(fn, obj) {
		var slice = Array.prototype.slice;

		if (fn.bind) {
			return fn.bind.apply(fn, slice.call(arguments, 1));
		}

		var args = slice.call(arguments, 2);

		return function () {
			return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
		};
	}

	// @property lastId: Number
	// Last unique ID used by [`stamp()`](#util-stamp)
	var lastId = 0;

	// @function stamp(obj: Object): Number
	// Returns the unique ID of an object, assigning it one if it doesn't have it.
	function stamp(obj) {
		/*eslint-disable */
		obj._leaflet_id = obj._leaflet_id || ++lastId;
		return obj._leaflet_id;
		/* eslint-enable */
	}

	// @function throttle(fn: Function, time: Number, context: Object): Function
	// Returns a function which executes function `fn` with the given scope `context`
	// (so that the `this` keyword refers to `context` inside `fn`'s code). The function
	// `fn` will be called no more than one time per given amount of `time`. The arguments
	// received by the bound function will be any arguments passed when binding the
	// function, followed by any arguments passed when invoking the bound function.
	// Has an `L.throttle` shortcut.
	function throttle(fn, time, context) {
		var lock, args, wrapperFn, later;

		later = function () {
			// reset lock and call if queued
			lock = false;
			if (args) {
				wrapperFn.apply(context, args);
				args = false;
			}
		};

		wrapperFn = function () {
			if (lock) {
				// called too soon, queue to call later
				args = arguments;

			} else {
				// call and lock until later
				fn.apply(context, arguments);
				setTimeout(later, time);
				lock = true;
			}
		};

		return wrapperFn;
	}

	// @function wrapNum(num: Number, range: Number[], includeMax?: Boolean): Number
	// Returns the number `num` modulo `range` in such a way so it lies within
	// `range[0]` and `range[1]`. The returned value will be always smaller than
	// `range[1]` unless `includeMax` is set to `true`.
	function wrapNum(x, range, includeMax) {
		var max = range[1],
		    min = range[0],
		    d = max - min;
		return x === max && includeMax ? x : ((x - min) % d + d) % d + min;
	}

	// @function falseFn(): Function
	// Returns a function which always returns `false`.
	function falseFn() { return false; }

	// @function formatNum(num: Number, digits?: Number): Number
	// Returns the number `num` rounded to `digits` decimals, or to 6 decimals by default.
	function formatNum(num, digits) {
		var pow = Math.pow(10, (digits === undefined ? 6 : digits));
		return Math.round(num * pow) / pow;
	}

	// @function trim(str: String): String
	// Compatibility polyfill for [String.prototype.trim](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim)
	function trim$1(str) {
		return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
	}

	// @function splitWords(str: String): String[]
	// Trims and splits the string on whitespace and returns the array of parts.
	function splitWords(str) {
		return trim$1(str).split(/\s+/);
	}

	// @function setOptions(obj: Object, options: Object): Object
	// Merges the given properties to the `options` of the `obj` object, returning the resulting options. See `Class options`. Has an `L.setOptions` shortcut.
	function setOptions(obj, options) {
		if (!obj.hasOwnProperty('options')) {
			obj.options = obj.options ? create$2(obj.options) : {};
		}
		for (var i in options) {
			obj.options[i] = options[i];
		}
		return obj.options;
	}

	// @function getParamString(obj: Object, existingUrl?: String, uppercase?: Boolean): String
	// Converts an object into a parameter URL string, e.g. `{a: "foo", b: "bar"}`
	// translates to `'?a=foo&b=bar'`. If `existingUrl` is set, the parameters will
	// be appended at the end. If `uppercase` is `true`, the parameter names will
	// be uppercased (e.g. `'?A=foo&B=bar'`)
	function getParamString(obj, existingUrl, uppercase) {
		var params = [];
		for (var i in obj) {
			params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));
		}
		return ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');
	}

	var templateRe = /\{ *([\w_-]+) *\}/g;

	// @function template(str: String, data: Object): String
	// Simple templating facility, accepts a template string of the form `'Hello {a}, {b}'`
	// and a data object like `{a: 'foo', b: 'bar'}`, returns evaluated string
	// `('Hello foo, bar')`. You can also specify functions instead of strings for
	// data values — they will be evaluated passing `data` as an argument.
	function template(str, data) {
		return str.replace(templateRe, function (str, key) {
			var value = data[key];

			if (value === undefined) {
				throw new Error('No value provided for variable ' + str);

			} else if (typeof value === 'function') {
				value = value(data);
			}
			return value;
		});
	}

	// @function isArray(obj): Boolean
	// Compatibility polyfill for [Array.isArray](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)
	var isArray$2 = Array.isArray || function (obj) {
		return (Object.prototype.toString.call(obj) === '[object Array]');
	};

	// @function indexOf(array: Array, el: Object): Number
	// Compatibility polyfill for [Array.prototype.indexOf](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)
	function indexOf(array, el) {
		for (var i = 0; i < array.length; i++) {
			if (array[i] === el) { return i; }
		}
		return -1;
	}

	// @property emptyImageUrl: String
	// Data URI string containing a base64-encoded empty GIF image.
	// Used as a hack to free memory from unused images on WebKit-powered
	// mobile devices (by setting image `src` to this string).
	var emptyImageUrl = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=';

	// inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/

	function getPrefixed(name) {
		return window['webkit' + name] || window['moz' + name] || window['ms' + name];
	}

	var lastTime = 0;

	// fallback for IE 7-8
	function timeoutDefer(fn) {
		var time = +new Date(),
		    timeToCall = Math.max(0, 16 - (time - lastTime));

		lastTime = time + timeToCall;
		return window.setTimeout(fn, timeToCall);
	}

	var requestFn = window.requestAnimationFrame || getPrefixed('RequestAnimationFrame') || timeoutDefer;
	var cancelFn = window.cancelAnimationFrame || getPrefixed('CancelAnimationFrame') ||
			getPrefixed('CancelRequestAnimationFrame') || function (id) { window.clearTimeout(id); };

	// @function requestAnimFrame(fn: Function, context?: Object, immediate?: Boolean): Number
	// Schedules `fn` to be executed when the browser repaints. `fn` is bound to
	// `context` if given. When `immediate` is set, `fn` is called immediately if
	// the browser doesn't have native support for
	// [`window.requestAnimationFrame`](https://developer.mozilla.org/docs/Web/API/window/requestAnimationFrame),
	// otherwise it's delayed. Returns a request ID that can be used to cancel the request.
	function requestAnimFrame(fn, context, immediate) {
		if (immediate && requestFn === timeoutDefer) {
			fn.call(context);
		} else {
			return requestFn.call(window, bind(fn, context));
		}
	}

	// @function cancelAnimFrame(id: Number): undefined
	// Cancels a previous `requestAnimFrame`. See also [window.cancelAnimationFrame](https://developer.mozilla.org/docs/Web/API/window/cancelAnimationFrame).
	function cancelAnimFrame(id) {
		if (id) {
			cancelFn.call(window, id);
		}
	}


	var Util = (Object.freeze || Object)({
		freeze: freeze$2,
		extend: extend$1,
		create: create$2,
		bind: bind,
		lastId: lastId,
		stamp: stamp,
		throttle: throttle,
		wrapNum: wrapNum,
		falseFn: falseFn,
		formatNum: formatNum,
		trim: trim$1,
		splitWords: splitWords,
		setOptions: setOptions,
		getParamString: getParamString,
		template: template,
		isArray: isArray$2,
		indexOf: indexOf,
		emptyImageUrl: emptyImageUrl,
		requestFn: requestFn,
		cancelFn: cancelFn,
		requestAnimFrame: requestAnimFrame,
		cancelAnimFrame: cancelAnimFrame
	});

	// @class Class
	// @aka L.Class

	// @section
	// @uninheritable

	// Thanks to John Resig and Dean Edwards for inspiration!

	function Class() {}

	Class.extend = function (props) {

		// @function extend(props: Object): Function
		// [Extends the current class](#class-inheritance) given the properties to be included.
		// Returns a Javascript function that is a class constructor (to be called with `new`).
		var NewClass = function () {

			// call the constructor
			if (this.initialize) {
				this.initialize.apply(this, arguments);
			}

			// call all constructor hooks
			this.callInitHooks();
		};

		var parentProto = NewClass.__super__ = this.prototype;

		var proto = create$2(parentProto);
		proto.constructor = NewClass;

		NewClass.prototype = proto;

		// inherit parent's statics
		for (var i in this) {
			if (this.hasOwnProperty(i) && i !== 'prototype' && i !== '__super__') {
				NewClass[i] = this[i];
			}
		}

		// mix static properties into the class
		if (props.statics) {
			extend$1(NewClass, props.statics);
			delete props.statics;
		}

		// mix includes into the prototype
		if (props.includes) {
			checkDeprecatedMixinEvents(props.includes);
			extend$1.apply(null, [proto].concat(props.includes));
			delete props.includes;
		}

		// merge options
		if (proto.options) {
			props.options = extend$1(create$2(proto.options), props.options);
		}

		// mix given properties into the prototype
		extend$1(proto, props);

		proto._initHooks = [];

		// add method for calling all hooks
		proto.callInitHooks = function () {

			if (this._initHooksCalled) { return; }

			if (parentProto.callInitHooks) {
				parentProto.callInitHooks.call(this);
			}

			this._initHooksCalled = true;

			for (var i = 0, len = proto._initHooks.length; i < len; i++) {
				proto._initHooks[i].call(this);
			}
		};

		return NewClass;
	};


	// @function include(properties: Object): this
	// [Includes a mixin](#class-includes) into the current class.
	Class.include = function (props) {
		extend$1(this.prototype, props);
		return this;
	};

	// @function mergeOptions(options: Object): this
	// [Merges `options`](#class-options) into the defaults of the class.
	Class.mergeOptions = function (options) {
		extend$1(this.prototype.options, options);
		return this;
	};

	// @function addInitHook(fn: Function): this
	// Adds a [constructor hook](#class-constructor-hooks) to the class.
	Class.addInitHook = function (fn) { // (Function) || (String, args...)
		var args = Array.prototype.slice.call(arguments, 1);

		var init = typeof fn === 'function' ? fn : function () {
			this[fn].apply(this, args);
		};

		this.prototype._initHooks = this.prototype._initHooks || [];
		this.prototype._initHooks.push(init);
		return this;
	};

	function checkDeprecatedMixinEvents(includes) {
		if (typeof L === 'undefined' || !L || !L.Mixin) { return; }

		includes = isArray$2(includes) ? includes : [includes];

		for (var i = 0; i < includes.length; i++) {
			if (includes[i] === L.Mixin.Events) {
				console.warn('Deprecated include of L.Mixin.Events: ' +
					'this property will be removed in future releases, ' +
					'please inherit from L.Evented instead.', new Error().stack);
			}
		}
	}

	/*
	 * @class Evented
	 * @aka L.Evented
	 * @inherits Class
	 *
	 * A set of methods shared between event-powered classes (like `Map` and `Marker`). Generally, events allow you to execute some function when something happens with an object (e.g. the user clicks on the map, causing the map to fire `'click'` event).
	 *
	 * @example
	 *
	 * ```js
	 * map.on('click', function(e) {
	 * 	alert(e.latlng);
	 * } );
	 * ```
	 *
	 * Leaflet deals with event listeners by reference, so if you want to add a listener and then remove it, define it as a function:
	 *
	 * ```js
	 * function onClick(e) { ... }
	 *
	 * map.on('click', onClick);
	 * map.off('click', onClick);
	 * ```
	 */

	var Events$1 = {
		/* @method on(type: String, fn: Function, context?: Object): this
		 * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
		 *
		 * @alternative
		 * @method on(eventMap: Object): this
		 * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
		 */
		on: function (types, fn, context) {

			// types can be a map of types/handlers
			if (typeof types === 'object') {
				for (var type in types) {
					// we don't process space-separated events here for performance;
					// it's a hot path since Layer uses the on(obj) syntax
					this._on(type, types[type], fn);
				}

			} else {
				// types can be a string of space-separated words
				types = splitWords(types);

				for (var i = 0, len = types.length; i < len; i++) {
					this._on(types[i], fn, context);
				}
			}

			return this;
		},

		/* @method off(type: String, fn?: Function, context?: Object): this
		 * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
		 *
		 * @alternative
		 * @method off(eventMap: Object): this
		 * Removes a set of type/listener pairs.
		 *
		 * @alternative
		 * @method off: this
		 * Removes all listeners to all events on the object. This includes implicitly attached events.
		 */
		off: function (types, fn, context) {

			if (!types) {
				// clear all listeners if called without arguments
				delete this._events;

			} else if (typeof types === 'object') {
				for (var type in types) {
					this._off(type, types[type], fn);
				}

			} else {
				types = splitWords(types);

				for (var i = 0, len = types.length; i < len; i++) {
					this._off(types[i], fn, context);
				}
			}

			return this;
		},

		// attach listener (without syntactic sugar now)
		_on: function (type, fn, context) {
			this._events = this._events || {};

			/* get/init listeners for type */
			var typeListeners = this._events[type];
			if (!typeListeners) {
				typeListeners = [];
				this._events[type] = typeListeners;
			}

			if (context === this) {
				// Less memory footprint.
				context = undefined;
			}
			var newListener = {fn: fn, ctx: context},
			    listeners = typeListeners;

			// check if fn already there
			for (var i = 0, len = listeners.length; i < len; i++) {
				if (listeners[i].fn === fn && listeners[i].ctx === context) {
					return;
				}
			}

			listeners.push(newListener);
		},

		_off: function (type, fn, context) {
			var listeners,
			    i,
			    len;

			if (!this._events) { return; }

			listeners = this._events[type];

			if (!listeners) {
				return;
			}

			if (!fn) {
				// Set all removed listeners to noop so they are not called if remove happens in fire
				for (i = 0, len = listeners.length; i < len; i++) {
					listeners[i].fn = falseFn;
				}
				// clear all listeners for a type if function isn't specified
				delete this._events[type];
				return;
			}

			if (context === this) {
				context = undefined;
			}

			if (listeners) {

				// find fn and remove it
				for (i = 0, len = listeners.length; i < len; i++) {
					var l = listeners[i];
					if (l.ctx !== context) { continue; }
					if (l.fn === fn) {

						// set the removed listener to noop so that's not called if remove happens in fire
						l.fn = falseFn;

						if (this._firingCount) {
							/* copy array in case events are being fired */
							this._events[type] = listeners = listeners.slice();
						}
						listeners.splice(i, 1);

						return;
					}
				}
			}
		},

		// @method fire(type: String, data?: Object, propagate?: Boolean): this
		// Fires an event of the specified type. You can optionally provide an data
		// object — the first argument of the listener function will contain its
		// properties. The event can optionally be propagated to event parents.
		fire: function (type, data, propagate) {
			if (!this.listens(type, propagate)) { return this; }

			var event = extend$1({}, data, {
				type: type,
				target: this,
				sourceTarget: data && data.sourceTarget || this
			});

			if (this._events) {
				var listeners = this._events[type];

				if (listeners) {
					this._firingCount = (this._firingCount + 1) || 1;
					for (var i = 0, len = listeners.length; i < len; i++) {
						var l = listeners[i];
						l.fn.call(l.ctx || this, event);
					}

					this._firingCount--;
				}
			}

			if (propagate) {
				// propagate the event to parents (set with addEventParent)
				this._propagateEvent(event);
			}

			return this;
		},

		// @method listens(type: String): Boolean
		// Returns `true` if a particular event type has any listeners attached to it.
		listens: function (type, propagate) {
			var listeners = this._events && this._events[type];
			if (listeners && listeners.length) { return true; }

			if (propagate) {
				// also check parents for listeners if event propagates
				for (var id in this._eventParents) {
					if (this._eventParents[id].listens(type, propagate)) { return true; }
				}
			}
			return false;
		},

		// @method once(…): this
		// Behaves as [`on(…)`](#evented-on), except the listener will only get fired once and then removed.
		once: function (types, fn, context) {

			if (typeof types === 'object') {
				for (var type in types) {
					this.once(type, types[type], fn);
				}
				return this;
			}

			var handler = bind(function () {
				this
				    .off(types, fn, context)
				    .off(types, handler, context);
			}, this);

			// add a listener that's executed once and removed after that
			return this
			    .on(types, fn, context)
			    .on(types, handler, context);
		},

		// @method addEventParent(obj: Evented): this
		// Adds an event parent - an `Evented` that will receive propagated events
		addEventParent: function (obj) {
			this._eventParents = this._eventParents || {};
			this._eventParents[stamp(obj)] = obj;
			return this;
		},

		// @method removeEventParent(obj: Evented): this
		// Removes an event parent, so it will stop receiving propagated events
		removeEventParent: function (obj) {
			if (this._eventParents) {
				delete this._eventParents[stamp(obj)];
			}
			return this;
		},

		_propagateEvent: function (e) {
			for (var id in this._eventParents) {
				this._eventParents[id].fire(e.type, extend$1({
					layer: e.target,
					propagatedFrom: e.target
				}, e), true);
			}
		}
	};

	// aliases; we should ditch those eventually

	// @method addEventListener(…): this
	// Alias to [`on(…)`](#evented-on)
	Events$1.addEventListener = Events$1.on;

	// @method removeEventListener(…): this
	// Alias to [`off(…)`](#evented-off)

	// @method clearAllEventListeners(…): this
	// Alias to [`off()`](#evented-off)
	Events$1.removeEventListener = Events$1.clearAllEventListeners = Events$1.off;

	// @method addOneTimeEventListener(…): this
	// Alias to [`once(…)`](#evented-once)
	Events$1.addOneTimeEventListener = Events$1.once;

	// @method fireEvent(…): this
	// Alias to [`fire(…)`](#evented-fire)
	Events$1.fireEvent = Events$1.fire;

	// @method hasEventListeners(…): Boolean
	// Alias to [`listens(…)`](#evented-listens)
	Events$1.hasEventListeners = Events$1.listens;

	var Evented = Class.extend(Events$1);

	/*
	 * @class Point
	 * @aka L.Point
	 *
	 * Represents a point with `x` and `y` coordinates in pixels.
	 *
	 * @example
	 *
	 * ```js
	 * var point = L.point(200, 300);
	 * ```
	 *
	 * All Leaflet methods and options that accept `Point` objects also accept them in a simple Array form (unless noted otherwise), so these lines are equivalent:
	 *
	 * ```js
	 * map.panBy([200, 300]);
	 * map.panBy(L.point(200, 300));
	 * ```
	 *
	 * Note that `Point` does not inherit from Leafet's `Class` object,
	 * which means new classes can't inherit from it, and new methods
	 * can't be added to it with the `include` function.
	 */

	function Point$1(x, y, round) {
		// @property x: Number; The `x` coordinate of the point
		this.x = (round ? Math.round(x) : x);
		// @property y: Number; The `y` coordinate of the point
		this.y = (round ? Math.round(y) : y);
	}

	var trunc = Math.trunc || function (v) {
		return v > 0 ? Math.floor(v) : Math.ceil(v);
	};

	Point$1.prototype = {

		// @method clone(): Point
		// Returns a copy of the current point.
		clone: function () {
			return new Point$1(this.x, this.y);
		},

		// @method add(otherPoint: Point): Point
		// Returns the result of addition of the current and the given points.
		add: function (point) {
			// non-destructive, returns a new point
			return this.clone()._add(toPoint(point));
		},

		_add: function (point) {
			// destructive, used directly for performance in situations where it's safe to modify existing point
			this.x += point.x;
			this.y += point.y;
			return this;
		},

		// @method subtract(otherPoint: Point): Point
		// Returns the result of subtraction of the given point from the current.
		subtract: function (point) {
			return this.clone()._subtract(toPoint(point));
		},

		_subtract: function (point) {
			this.x -= point.x;
			this.y -= point.y;
			return this;
		},

		// @method divideBy(num: Number): Point
		// Returns the result of division of the current point by the given number.
		divideBy: function (num) {
			return this.clone()._divideBy(num);
		},

		_divideBy: function (num) {
			this.x /= num;
			this.y /= num;
			return this;
		},

		// @method multiplyBy(num: Number): Point
		// Returns the result of multiplication of the current point by the given number.
		multiplyBy: function (num) {
			return this.clone()._multiplyBy(num);
		},

		_multiplyBy: function (num) {
			this.x *= num;
			this.y *= num;
			return this;
		},

		// @method scaleBy(scale: Point): Point
		// Multiply each coordinate of the current point by each coordinate of
		// `scale`. In linear algebra terms, multiply the point by the
		// [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)
		// defined by `scale`.
		scaleBy: function (point) {
			return new Point$1(this.x * point.x, this.y * point.y);
		},

		// @method unscaleBy(scale: Point): Point
		// Inverse of `scaleBy`. Divide each coordinate of the current point by
		// each coordinate of `scale`.
		unscaleBy: function (point) {
			return new Point$1(this.x / point.x, this.y / point.y);
		},

		// @method round(): Point
		// Returns a copy of the current point with rounded coordinates.
		round: function () {
			return this.clone()._round();
		},

		_round: function () {
			this.x = Math.round(this.x);
			this.y = Math.round(this.y);
			return this;
		},

		// @method floor(): Point
		// Returns a copy of the current point with floored coordinates (rounded down).
		floor: function () {
			return this.clone()._floor();
		},

		_floor: function () {
			this.x = Math.floor(this.x);
			this.y = Math.floor(this.y);
			return this;
		},

		// @method ceil(): Point
		// Returns a copy of the current point with ceiled coordinates (rounded up).
		ceil: function () {
			return this.clone()._ceil();
		},

		_ceil: function () {
			this.x = Math.ceil(this.x);
			this.y = Math.ceil(this.y);
			return this;
		},

		// @method trunc(): Point
		// Returns a copy of the current point with truncated coordinates (rounded towards zero).
		trunc: function () {
			return this.clone()._trunc();
		},

		_trunc: function () {
			this.x = trunc(this.x);
			this.y = trunc(this.y);
			return this;
		},

		// @method distanceTo(otherPoint: Point): Number
		// Returns the cartesian distance between the current and the given points.
		distanceTo: function (point) {
			point = toPoint(point);

			var x = point.x - this.x,
			    y = point.y - this.y;

			return Math.sqrt(x * x + y * y);
		},

		// @method equals(otherPoint: Point): Boolean
		// Returns `true` if the given point has the same coordinates.
		equals: function (point) {
			point = toPoint(point);

			return point.x === this.x &&
			       point.y === this.y;
		},

		// @method contains(otherPoint: Point): Boolean
		// Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).
		contains: function (point) {
			point = toPoint(point);

			return Math.abs(point.x) <= Math.abs(this.x) &&
			       Math.abs(point.y) <= Math.abs(this.y);
		},

		// @method toString(): String
		// Returns a string representation of the point for debugging purposes.
		toString: function () {
			return 'Point(' +
			        formatNum(this.x) + ', ' +
			        formatNum(this.y) + ')';
		}
	};

	// @factory L.point(x: Number, y: Number, round?: Boolean)
	// Creates a Point object with the given `x` and `y` coordinates. If optional `round` is set to true, rounds the `x` and `y` values.

	// @alternative
	// @factory L.point(coords: Number[])
	// Expects an array of the form `[x, y]` instead.

	// @alternative
	// @factory L.point(coords: Object)
	// Expects a plain object of the form `{x: Number, y: Number}` instead.
	function toPoint(x, y, round) {
		if (x instanceof Point$1) {
			return x;
		}
		if (isArray$2(x)) {
			return new Point$1(x[0], x[1]);
		}
		if (x === undefined || x === null) {
			return x;
		}
		if (typeof x === 'object' && 'x' in x && 'y' in x) {
			return new Point$1(x.x, x.y);
		}
		return new Point$1(x, y, round);
	}

	/*
	 * @class Bounds
	 * @aka L.Bounds
	 *
	 * Represents a rectangular area in pixel coordinates.
	 *
	 * @example
	 *
	 * ```js
	 * var p1 = L.point(10, 10),
	 * p2 = L.point(40, 60),
	 * bounds = L.bounds(p1, p2);
	 * ```
	 *
	 * All Leaflet methods that accept `Bounds` objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
	 *
	 * ```js
	 * otherBounds.intersects([[10, 10], [40, 60]]);
	 * ```
	 *
	 * Note that `Bounds` does not inherit from Leafet's `Class` object,
	 * which means new classes can't inherit from it, and new methods
	 * can't be added to it with the `include` function.
	 */

	function Bounds(a, b) {
		if (!a) { return; }

		var points = b ? [a, b] : a;

		for (var i = 0, len = points.length; i < len; i++) {
			this.extend(points[i]);
		}
	}

	Bounds.prototype = {
		// @method extend(point: Point): this
		// Extends the bounds to contain the given point.
		extend: function (point) { // (Point)
			point = toPoint(point);

			// @property min: Point
			// The top left corner of the rectangle.
			// @property max: Point
			// The bottom right corner of the rectangle.
			if (!this.min && !this.max) {
				this.min = point.clone();
				this.max = point.clone();
			} else {
				this.min.x = Math.min(point.x, this.min.x);
				this.max.x = Math.max(point.x, this.max.x);
				this.min.y = Math.min(point.y, this.min.y);
				this.max.y = Math.max(point.y, this.max.y);
			}
			return this;
		},

		// @method getCenter(round?: Boolean): Point
		// Returns the center point of the bounds.
		getCenter: function (round) {
			return new Point$1(
			        (this.min.x + this.max.x) / 2,
			        (this.min.y + this.max.y) / 2, round);
		},

		// @method getBottomLeft(): Point
		// Returns the bottom-left point of the bounds.
		getBottomLeft: function () {
			return new Point$1(this.min.x, this.max.y);
		},

		// @method getTopRight(): Point
		// Returns the top-right point of the bounds.
		getTopRight: function () { // -> Point
			return new Point$1(this.max.x, this.min.y);
		},

		// @method getTopLeft(): Point
		// Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).
		getTopLeft: function () {
			return this.min; // left, top
		},

		// @method getBottomRight(): Point
		// Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).
		getBottomRight: function () {
			return this.max; // right, bottom
		},

		// @method getSize(): Point
		// Returns the size of the given bounds
		getSize: function () {
			return this.max.subtract(this.min);
		},

		// @method contains(otherBounds: Bounds): Boolean
		// Returns `true` if the rectangle contains the given one.
		// @alternative
		// @method contains(point: Point): Boolean
		// Returns `true` if the rectangle contains the given point.
		contains: function (obj) {
			var min, max;

			if (typeof obj[0] === 'number' || obj instanceof Point$1) {
				obj = toPoint(obj);
			} else {
				obj = toBounds(obj);
			}

			if (obj instanceof Bounds) {
				min = obj.min;
				max = obj.max;
			} else {
				min = max = obj;
			}

			return (min.x >= this.min.x) &&
			       (max.x <= this.max.x) &&
			       (min.y >= this.min.y) &&
			       (max.y <= this.max.y);
		},

		// @method intersects(otherBounds: Bounds): Boolean
		// Returns `true` if the rectangle intersects the given bounds. Two bounds
		// intersect if they have at least one point in common.
		intersects: function (bounds) { // (Bounds) -> Boolean
			bounds = toBounds(bounds);

			var min = this.min,
			    max = this.max,
			    min2 = bounds.min,
			    max2 = bounds.max,
			    xIntersects = (max2.x >= min.x) && (min2.x <= max.x),
			    yIntersects = (max2.y >= min.y) && (min2.y <= max.y);

			return xIntersects && yIntersects;
		},

		// @method overlaps(otherBounds: Bounds): Boolean
		// Returns `true` if the rectangle overlaps the given bounds. Two bounds
		// overlap if their intersection is an area.
		overlaps: function (bounds) { // (Bounds) -> Boolean
			bounds = toBounds(bounds);

			var min = this.min,
			    max = this.max,
			    min2 = bounds.min,
			    max2 = bounds.max,
			    xOverlaps = (max2.x > min.x) && (min2.x < max.x),
			    yOverlaps = (max2.y > min.y) && (min2.y < max.y);

			return xOverlaps && yOverlaps;
		},

		isValid: function () {
			return !!(this.min && this.max);
		}
	};


	// @factory L.bounds(corner1: Point, corner2: Point)
	// Creates a Bounds object from two corners coordinate pairs.
	// @alternative
	// @factory L.bounds(points: Point[])
	// Creates a Bounds object from the given array of points.
	function toBounds(a, b) {
		if (!a || a instanceof Bounds) {
			return a;
		}
		return new Bounds(a, b);
	}

	/*
	 * @class LatLngBounds
	 * @aka L.LatLngBounds
	 *
	 * Represents a rectangular geographical area on a map.
	 *
	 * @example
	 *
	 * ```js
	 * var corner1 = L.latLng(40.712, -74.227),
	 * corner2 = L.latLng(40.774, -74.125),
	 * bounds = L.latLngBounds(corner1, corner2);
	 * ```
	 *
	 * All Leaflet methods that accept LatLngBounds objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
	 *
	 * ```js
	 * map.fitBounds([
	 * 	[40.712, -74.227],
	 * 	[40.774, -74.125]
	 * ]);
	 * ```
	 *
	 * Caution: if the area crosses the antimeridian (often confused with the International Date Line), you must specify corners _outside_ the [-180, 180] degrees longitude range.
	 *
	 * Note that `LatLngBounds` does not inherit from Leafet's `Class` object,
	 * which means new classes can't inherit from it, and new methods
	 * can't be added to it with the `include` function.
	 */

	function LatLngBounds(corner1, corner2) { // (LatLng, LatLng) or (LatLng[])
		if (!corner1) { return; }

		var latlngs = corner2 ? [corner1, corner2] : corner1;

		for (var i = 0, len = latlngs.length; i < len; i++) {
			this.extend(latlngs[i]);
		}
	}

	LatLngBounds.prototype = {

		// @method extend(latlng: LatLng): this
		// Extend the bounds to contain the given point

		// @alternative
		// @method extend(otherBounds: LatLngBounds): this
		// Extend the bounds to contain the given bounds
		extend: function (obj) {
			var sw = this._southWest,
			    ne = this._northEast,
			    sw2, ne2;

			if (obj instanceof LatLng) {
				sw2 = obj;
				ne2 = obj;

			} else if (obj instanceof LatLngBounds) {
				sw2 = obj._southWest;
				ne2 = obj._northEast;

				if (!sw2 || !ne2) { return this; }

			} else {
				return obj ? this.extend(toLatLng(obj) || toLatLngBounds(obj)) : this;
			}

			if (!sw && !ne) {
				this._southWest = new LatLng(sw2.lat, sw2.lng);
				this._northEast = new LatLng(ne2.lat, ne2.lng);
			} else {
				sw.lat = Math.min(sw2.lat, sw.lat);
				sw.lng = Math.min(sw2.lng, sw.lng);
				ne.lat = Math.max(ne2.lat, ne.lat);
				ne.lng = Math.max(ne2.lng, ne.lng);
			}

			return this;
		},

		// @method pad(bufferRatio: Number): LatLngBounds
		// Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
		// For example, a ratio of 0.5 extends the bounds by 50% in each direction.
		// Negative values will retract the bounds.
		pad: function (bufferRatio) {
			var sw = this._southWest,
			    ne = this._northEast,
			    heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,
			    widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;

			return new LatLngBounds(
			        new LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),
			        new LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));
		},

		// @method getCenter(): LatLng
		// Returns the center point of the bounds.
		getCenter: function () {
			return new LatLng(
			        (this._southWest.lat + this._northEast.lat) / 2,
			        (this._southWest.lng + this._northEast.lng) / 2);
		},

		// @method getSouthWest(): LatLng
		// Returns the south-west point of the bounds.
		getSouthWest: function () {
			return this._southWest;
		},

		// @method getNorthEast(): LatLng
		// Returns the north-east point of the bounds.
		getNorthEast: function () {
			return this._northEast;
		},

		// @method getNorthWest(): LatLng
		// Returns the north-west point of the bounds.
		getNorthWest: function () {
			return new LatLng(this.getNorth(), this.getWest());
		},

		// @method getSouthEast(): LatLng
		// Returns the south-east point of the bounds.
		getSouthEast: function () {
			return new LatLng(this.getSouth(), this.getEast());
		},

		// @method getWest(): Number
		// Returns the west longitude of the bounds
		getWest: function () {
			return this._southWest.lng;
		},

		// @method getSouth(): Number
		// Returns the south latitude of the bounds
		getSouth: function () {
			return this._southWest.lat;
		},

		// @method getEast(): Number
		// Returns the east longitude of the bounds
		getEast: function () {
			return this._northEast.lng;
		},

		// @method getNorth(): Number
		// Returns the north latitude of the bounds
		getNorth: function () {
			return this._northEast.lat;
		},

		// @method contains(otherBounds: LatLngBounds): Boolean
		// Returns `true` if the rectangle contains the given one.

		// @alternative
		// @method contains (latlng: LatLng): Boolean
		// Returns `true` if the rectangle contains the given point.
		contains: function (obj) { // (LatLngBounds) or (LatLng) -> Boolean
			if (typeof obj[0] === 'number' || obj instanceof LatLng || 'lat' in obj) {
				obj = toLatLng(obj);
			} else {
				obj = toLatLngBounds(obj);
			}

			var sw = this._southWest,
			    ne = this._northEast,
			    sw2, ne2;

			if (obj instanceof LatLngBounds) {
				sw2 = obj.getSouthWest();
				ne2 = obj.getNorthEast();
			} else {
				sw2 = ne2 = obj;
			}

			return (sw2.lat >= sw.lat) && (ne2.lat <= ne.lat) &&
			       (sw2.lng >= sw.lng) && (ne2.lng <= ne.lng);
		},

		// @method intersects(otherBounds: LatLngBounds): Boolean
		// Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.
		intersects: function (bounds) {
			bounds = toLatLngBounds(bounds);

			var sw = this._southWest,
			    ne = this._northEast,
			    sw2 = bounds.getSouthWest(),
			    ne2 = bounds.getNorthEast(),

			    latIntersects = (ne2.lat >= sw.lat) && (sw2.lat <= ne.lat),
			    lngIntersects = (ne2.lng >= sw.lng) && (sw2.lng <= ne.lng);

			return latIntersects && lngIntersects;
		},

		// @method overlaps(otherBounds: Bounds): Boolean
		// Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.
		overlaps: function (bounds) {
			bounds = toLatLngBounds(bounds);

			var sw = this._southWest,
			    ne = this._northEast,
			    sw2 = bounds.getSouthWest(),
			    ne2 = bounds.getNorthEast(),

			    latOverlaps = (ne2.lat > sw.lat) && (sw2.lat < ne.lat),
			    lngOverlaps = (ne2.lng > sw.lng) && (sw2.lng < ne.lng);

			return latOverlaps && lngOverlaps;
		},

		// @method toBBoxString(): String
		// Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.
		toBBoxString: function () {
			return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');
		},

		// @method equals(otherBounds: LatLngBounds, maxMargin?: Number): Boolean
		// Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overridden by setting `maxMargin` to a small number.
		equals: function (bounds, maxMargin) {
			if (!bounds) { return false; }

			bounds = toLatLngBounds(bounds);

			return this._southWest.equals(bounds.getSouthWest(), maxMargin) &&
			       this._northEast.equals(bounds.getNorthEast(), maxMargin);
		},

		// @method isValid(): Boolean
		// Returns `true` if the bounds are properly initialized.
		isValid: function () {
			return !!(this._southWest && this._northEast);
		}
	};

	// TODO International date line?

	// @factory L.latLngBounds(corner1: LatLng, corner2: LatLng)
	// Creates a `LatLngBounds` object by defining two diagonally opposite corners of the rectangle.

	// @alternative
	// @factory L.latLngBounds(latlngs: LatLng[])
	// Creates a `LatLngBounds` object defined by the geographical points it contains. Very useful for zooming the map to fit a particular set of locations with [`fitBounds`](#map-fitbounds).
	function toLatLngBounds(a, b) {
		if (a instanceof LatLngBounds) {
			return a;
		}
		return new LatLngBounds(a, b);
	}

	/* @class LatLng
	 * @aka L.LatLng
	 *
	 * Represents a geographical point with a certain latitude and longitude.
	 *
	 * @example
	 *
	 * ```
	 * var latlng = L.latLng(50.5, 30.5);
	 * ```
	 *
	 * All Leaflet methods that accept LatLng objects also accept them in a simple Array form and simple object form (unless noted otherwise), so these lines are equivalent:
	 *
	 * ```
	 * map.panTo([50, 30]);
	 * map.panTo({lon: 30, lat: 50});
	 * map.panTo({lat: 50, lng: 30});
	 * map.panTo(L.latLng(50, 30));
	 * ```
	 *
	 * Note that `LatLng` does not inherit from Leaflet's `Class` object,
	 * which means new classes can't inherit from it, and new methods
	 * can't be added to it with the `include` function.
	 */

	function LatLng(lat, lng, alt) {
		if (isNaN(lat) || isNaN(lng)) {
			throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');
		}

		// @property lat: Number
		// Latitude in degrees
		this.lat = +lat;

		// @property lng: Number
		// Longitude in degrees
		this.lng = +lng;

		// @property alt: Number
		// Altitude in meters (optional)
		if (alt !== undefined) {
			this.alt = +alt;
		}
	}

	LatLng.prototype = {
		// @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean
		// Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overridden by setting `maxMargin` to a small number.
		equals: function (obj, maxMargin) {
			if (!obj) { return false; }

			obj = toLatLng(obj);

			var margin = Math.max(
			        Math.abs(this.lat - obj.lat),
			        Math.abs(this.lng - obj.lng));

			return margin <= (maxMargin === undefined ? 1.0E-9 : maxMargin);
		},

		// @method toString(): String
		// Returns a string representation of the point (for debugging purposes).
		toString: function (precision) {
			return 'LatLng(' +
			        formatNum(this.lat, precision) + ', ' +
			        formatNum(this.lng, precision) + ')';
		},

		// @method distanceTo(otherLatLng: LatLng): Number
		// Returns the distance (in meters) to the given `LatLng` calculated using the [Spherical Law of Cosines](https://en.wikipedia.org/wiki/Spherical_law_of_cosines).
		distanceTo: function (other) {
			return Earth.distance(this, toLatLng(other));
		},

		// @method wrap(): LatLng
		// Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.
		wrap: function () {
			return Earth.wrapLatLng(this);
		},

		// @method toBounds(sizeInMeters: Number): LatLngBounds
		// Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.
		toBounds: function (sizeInMeters) {
			var latAccuracy = 180 * sizeInMeters / 40075017,
			    lngAccuracy = latAccuracy / Math.cos((Math.PI / 180) * this.lat);

			return toLatLngBounds(
			        [this.lat - latAccuracy, this.lng - lngAccuracy],
			        [this.lat + latAccuracy, this.lng + lngAccuracy]);
		},

		clone: function () {
			return new LatLng(this.lat, this.lng, this.alt);
		}
	};



	// @factory L.latLng(latitude: Number, longitude: Number, altitude?: Number): LatLng
	// Creates an object representing a geographical point with the given latitude and longitude (and optionally altitude).

	// @alternative
	// @factory L.latLng(coords: Array): LatLng
	// Expects an array of the form `[Number, Number]` or `[Number, Number, Number]` instead.

	// @alternative
	// @factory L.latLng(coords: Object): LatLng
	// Expects an plain object of the form `{lat: Number, lng: Number}` or `{lat: Number, lng: Number, alt: Number}` instead.

	function toLatLng(a, b, c) {
		if (a instanceof LatLng) {
			return a;
		}
		if (isArray$2(a) && typeof a[0] !== 'object') {
			if (a.length === 3) {
				return new LatLng(a[0], a[1], a[2]);
			}
			if (a.length === 2) {
				return new LatLng(a[0], a[1]);
			}
			return null;
		}
		if (a === undefined || a === null) {
			return a;
		}
		if (typeof a === 'object' && 'lat' in a) {
			return new LatLng(a.lat, 'lng' in a ? a.lng : a.lon, a.alt);
		}
		if (b === undefined) {
			return null;
		}
		return new LatLng(a, b, c);
	}

	/*
	 * @namespace CRS
	 * @crs L.CRS.Base
	 * Object that defines coordinate reference systems for projecting
	 * geographical points into pixel (screen) coordinates and back (and to
	 * coordinates in other units for [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services). See
	 * [spatial reference system](http://en.wikipedia.org/wiki/Coordinate_reference_system).
	 *
	 * Leaflet defines the most usual CRSs by default. If you want to use a
	 * CRS not defined by default, take a look at the
	 * [Proj4Leaflet](https://github.com/kartena/Proj4Leaflet) plugin.
	 *
	 * Note that the CRS instances do not inherit from Leafet's `Class` object,
	 * and can't be instantiated. Also, new classes can't inherit from them,
	 * and methods can't be added to them with the `include` function.
	 */

	var CRS = {
		// @method latLngToPoint(latlng: LatLng, zoom: Number): Point
		// Projects geographical coordinates into pixel coordinates for a given zoom.
		latLngToPoint: function (latlng, zoom) {
			var projectedPoint = this.projection.project(latlng),
			    scale = this.scale(zoom);

			return this.transformation._transform(projectedPoint, scale);
		},

		// @method pointToLatLng(point: Point, zoom: Number): LatLng
		// The inverse of `latLngToPoint`. Projects pixel coordinates on a given
		// zoom into geographical coordinates.
		pointToLatLng: function (point, zoom) {
			var scale = this.scale(zoom),
			    untransformedPoint = this.transformation.untransform(point, scale);

			return this.projection.unproject(untransformedPoint);
		},

		// @method project(latlng: LatLng): Point
		// Projects geographical coordinates into coordinates in units accepted for
		// this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).
		project: function (latlng) {
			return this.projection.project(latlng);
		},

		// @method unproject(point: Point): LatLng
		// Given a projected coordinate returns the corresponding LatLng.
		// The inverse of `project`.
		unproject: function (point) {
			return this.projection.unproject(point);
		},

		// @method scale(zoom: Number): Number
		// Returns the scale used when transforming projected coordinates into
		// pixel coordinates for a particular zoom. For example, it returns
		// `256 * 2^zoom` for Mercator-based CRS.
		scale: function (zoom) {
			return 256 * Math.pow(2, zoom);
		},

		// @method zoom(scale: Number): Number
		// Inverse of `scale()`, returns the zoom level corresponding to a scale
		// factor of `scale`.
		zoom: function (scale) {
			return Math.log(scale / 256) / Math.LN2;
		},

		// @method getProjectedBounds(zoom: Number): Bounds
		// Returns the projection's bounds scaled and transformed for the provided `zoom`.
		getProjectedBounds: function (zoom) {
			if (this.infinite) { return null; }

			var b = this.projection.bounds,
			    s = this.scale(zoom),
			    min = this.transformation.transform(b.min, s),
			    max = this.transformation.transform(b.max, s);

			return new Bounds(min, max);
		},

		// @method distance(latlng1: LatLng, latlng2: LatLng): Number
		// Returns the distance between two geographical coordinates.

		// @property code: String
		// Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)
		//
		// @property wrapLng: Number[]
		// An array of two numbers defining whether the longitude (horizontal) coordinate
		// axis wraps around a given range and how. Defaults to `[-180, 180]` in most
		// geographical CRSs. If `undefined`, the longitude axis does not wrap around.
		//
		// @property wrapLat: Number[]
		// Like `wrapLng`, but for the latitude (vertical) axis.

		// wrapLng: [min, max],
		// wrapLat: [min, max],

		// @property infinite: Boolean
		// If true, the coordinate space will be unbounded (infinite in both axes)
		infinite: false,

		// @method wrapLatLng(latlng: LatLng): LatLng
		// Returns a `LatLng` where lat and lng has been wrapped according to the
		// CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.
		wrapLatLng: function (latlng) {
			var lng = this.wrapLng ? wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng,
			    lat = this.wrapLat ? wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat,
			    alt = latlng.alt;

			return new LatLng(lat, lng, alt);
		},

		// @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
		// Returns a `LatLngBounds` with the same size as the given one, ensuring
		// that its center is within the CRS's bounds.
		// Only accepts actual `L.LatLngBounds` instances, not arrays.
		wrapLatLngBounds: function (bounds) {
			var center = bounds.getCenter(),
			    newCenter = this.wrapLatLng(center),
			    latShift = center.lat - newCenter.lat,
			    lngShift = center.lng - newCenter.lng;

			if (latShift === 0 && lngShift === 0) {
				return bounds;
			}

			var sw = bounds.getSouthWest(),
			    ne = bounds.getNorthEast(),
			    newSw = new LatLng(sw.lat - latShift, sw.lng - lngShift),
			    newNe = new LatLng(ne.lat - latShift, ne.lng - lngShift);

			return new LatLngBounds(newSw, newNe);
		}
	};

	/*
	 * @namespace CRS
	 * @crs L.CRS.Earth
	 *
	 * Serves as the base for CRS that are global such that they cover the earth.
	 * Can only be used as the base for other CRS and cannot be used directly,
	 * since it does not have a `code`, `projection` or `transformation`. `distance()` returns
	 * meters.
	 */

	var Earth = extend$1({}, CRS, {
		wrapLng: [-180, 180],

		// Mean Earth Radius, as recommended for use by
		// the International Union of Geodesy and Geophysics,
		// see http://rosettacode.org/wiki/Haversine_formula
		R: 6371000,

		// distance between two geographical points using spherical law of cosines approximation
		distance: function (latlng1, latlng2) {
			var rad = Math.PI / 180,
			    lat1 = latlng1.lat * rad,
			    lat2 = latlng2.lat * rad,
			    sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2),
			    sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad / 2),
			    a = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon,
			    c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
			return this.R * c;
		}
	});

	/*
	 * @namespace Projection
	 * @projection L.Projection.SphericalMercator
	 *
	 * Spherical Mercator projection — the most common projection for online maps,
	 * used by almost all free and commercial tile providers. Assumes that Earth is
	 * a sphere. Used by the `EPSG:3857` CRS.
	 */

	var earthRadius = 6378137;

	var SphericalMercator = {

		R: earthRadius,
		MAX_LATITUDE: 85.0511287798,

		project: function (latlng) {
			var d = Math.PI / 180,
			    max = this.MAX_LATITUDE,
			    lat = Math.max(Math.min(max, latlng.lat), -max),
			    sin = Math.sin(lat * d);

			return new Point$1(
				this.R * latlng.lng * d,
				this.R * Math.log((1 + sin) / (1 - sin)) / 2);
		},

		unproject: function (point) {
			var d = 180 / Math.PI;

			return new LatLng(
				(2 * Math.atan(Math.exp(point.y / this.R)) - (Math.PI / 2)) * d,
				point.x * d / this.R);
		},

		bounds: (function () {
			var d = earthRadius * Math.PI;
			return new Bounds([-d, -d], [d, d]);
		})()
	};

	/*
	 * @class Transformation
	 * @aka L.Transformation
	 *
	 * Represents an affine transformation: a set of coefficients `a`, `b`, `c`, `d`
	 * for transforming a point of a form `(x, y)` into `(a*x + b, c*y + d)` and doing
	 * the reverse. Used by Leaflet in its projections code.
	 *
	 * @example
	 *
	 * ```js
	 * var transformation = L.transformation(2, 5, -1, 10),
	 * 	p = L.point(1, 2),
	 * 	p2 = transformation.transform(p), //  L.point(7, 8)
	 * 	p3 = transformation.untransform(p2); //  L.point(1, 2)
	 * ```
	 */


	// factory new L.Transformation(a: Number, b: Number, c: Number, d: Number)
	// Creates a `Transformation` object with the given coefficients.
	function Transformation(a, b, c, d) {
		if (isArray$2(a)) {
			// use array properties
			this._a = a[0];
			this._b = a[1];
			this._c = a[2];
			this._d = a[3];
			return;
		}
		this._a = a;
		this._b = b;
		this._c = c;
		this._d = d;
	}

	Transformation.prototype = {
		// @method transform(point: Point, scale?: Number): Point
		// Returns a transformed point, optionally multiplied by the given scale.
		// Only accepts actual `L.Point` instances, not arrays.
		transform: function (point, scale) { // (Point, Number) -> Point
			return this._transform(point.clone(), scale);
		},

		// destructive transform (faster)
		_transform: function (point, scale) {
			scale = scale || 1;
			point.x = scale * (this._a * point.x + this._b);
			point.y = scale * (this._c * point.y + this._d);
			return point;
		},

		// @method untransform(point: Point, scale?: Number): Point
		// Returns the reverse transformation of the given point, optionally divided
		// by the given scale. Only accepts actual `L.Point` instances, not arrays.
		untransform: function (point, scale) {
			scale = scale || 1;
			return new Point$1(
			        (point.x / scale - this._b) / this._a,
			        (point.y / scale - this._d) / this._c);
		}
	};

	// factory L.transformation(a: Number, b: Number, c: Number, d: Number)

	// @factory L.transformation(a: Number, b: Number, c: Number, d: Number)
	// Instantiates a Transformation object with the given coefficients.

	// @alternative
	// @factory L.transformation(coefficients: Array): Transformation
	// Expects an coefficients array of the form
	// `[a: Number, b: Number, c: Number, d: Number]`.

	function toTransformation(a, b, c, d) {
		return new Transformation(a, b, c, d);
	}

	/*
	 * @namespace CRS
	 * @crs L.CRS.EPSG3857
	 *
	 * The most common CRS for online maps, used by almost all free and commercial
	 * tile providers. Uses Spherical Mercator projection. Set in by default in
	 * Map's `crs` option.
	 */

	var EPSG3857 = extend$1({}, Earth, {
		code: 'EPSG:3857',
		projection: SphericalMercator,

		transformation: (function () {
			var scale = 0.5 / (Math.PI * SphericalMercator.R);
			return toTransformation(scale, 0.5, -scale, 0.5);
		}())
	});

	var EPSG900913 = extend$1({}, EPSG3857, {
		code: 'EPSG:900913'
	});

	// @namespace SVG; @section
	// There are several static functions which can be called without instantiating L.SVG:

	// @function create(name: String): SVGElement
	// Returns a instance of [SVGElement](https://developer.mozilla.org/docs/Web/API/SVGElement),
	// corresponding to the class name passed. For example, using 'line' will return
	// an instance of [SVGLineElement](https://developer.mozilla.org/docs/Web/API/SVGLineElement).
	function svgCreate(name) {
		return document.createElementNS('http://www.w3.org/2000/svg', name);
	}

	// @function pointsToPath(rings: Point[], closed: Boolean): String
	// Generates a SVG path string for multiple rings, with each ring turning
	// into "M..L..L.." instructions
	function pointsToPath(rings, closed) {
		var str = '',
		i, j, len, len2, points, p;

		for (i = 0, len = rings.length; i < len; i++) {
			points = rings[i];

			for (j = 0, len2 = points.length; j < len2; j++) {
				p = points[j];
				str += (j ? 'L' : 'M') + p.x + ' ' + p.y;
			}

			// closes the ring for polygons; "x" is VML syntax
			str += closed ? (svg ? 'z' : 'x') : '';
		}

		// SVG complains about empty path strings
		return str || 'M0 0';
	}

	/*
	 * @namespace Browser
	 * @aka L.Browser
	 *
	 * A namespace with static properties for browser/feature detection used by Leaflet internally.
	 *
	 * @example
	 *
	 * ```js
	 * if (L.Browser.ielt9) {
	 *   alert('Upgrade your browser, dude!');
	 * }
	 * ```
	 */

	var style$1 = document.documentElement.style;

	// @property ie: Boolean; `true` for all Internet Explorer versions (not Edge).
	var ie = 'ActiveXObject' in window;

	// @property ielt9: Boolean; `true` for Internet Explorer versions less than 9.
	var ielt9 = ie && !document.addEventListener;

	// @property edge: Boolean; `true` for the Edge web browser.
	var edge = 'msLaunchUri' in navigator && !('documentMode' in document);

	// @property webkit: Boolean;
	// `true` for webkit-based browsers like Chrome and Safari (including mobile versions).
	var webkit = userAgentContains('webkit');

	// @property android: Boolean
	// `true` for any browser running on an Android platform.
	var android = userAgentContains('android');

	// @property android23: Boolean; `true` for browsers running on Android 2 or Android 3.
	var android23 = userAgentContains('android 2') || userAgentContains('android 3');

	/* See https://stackoverflow.com/a/17961266 for details on detecting stock Android */
	var webkitVer = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10); // also matches AppleWebKit
	// @property androidStock: Boolean; `true` for the Android stock browser (i.e. not Chrome)
	var androidStock = android && userAgentContains('Google') && webkitVer < 537 && !('AudioNode' in window);

	// @property opera: Boolean; `true` for the Opera browser
	var opera = !!window.opera;

	// @property chrome: Boolean; `true` for the Chrome browser.
	var chrome = userAgentContains('chrome');

	// @property gecko: Boolean; `true` for gecko-based browsers like Firefox.
	var gecko = userAgentContains('gecko') && !webkit && !opera && !ie;

	// @property safari: Boolean; `true` for the Safari browser.
	var safari = !chrome && userAgentContains('safari');

	var phantom = userAgentContains('phantom');

	// @property opera12: Boolean
	// `true` for the Opera browser supporting CSS transforms (version 12 or later).
	var opera12 = 'OTransition' in style$1;

	// @property win: Boolean; `true` when the browser is running in a Windows platform
	var win = navigator.platform.indexOf('Win') === 0;

	// @property ie3d: Boolean; `true` for all Internet Explorer versions supporting CSS transforms.
	var ie3d = ie && ('transition' in style$1);

	// @property webkit3d: Boolean; `true` for webkit-based browsers supporting CSS transforms.
	var webkit3d = ('WebKitCSSMatrix' in window) && ('m11' in new window.WebKitCSSMatrix()) && !android23;

	// @property gecko3d: Boolean; `true` for gecko-based browsers supporting CSS transforms.
	var gecko3d = 'MozPerspective' in style$1;

	// @property any3d: Boolean
	// `true` for all browsers supporting CSS transforms.
	var any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom;

	// @property mobile: Boolean; `true` for all browsers running in a mobile device.
	var mobile = typeof orientation !== 'undefined' || userAgentContains('mobile');

	// @property mobileWebkit: Boolean; `true` for all webkit-based browsers in a mobile device.
	var mobileWebkit = mobile && webkit;

	// @property mobileWebkit3d: Boolean
	// `true` for all webkit-based browsers in a mobile device supporting CSS transforms.
	var mobileWebkit3d = mobile && webkit3d;

	// @property msPointer: Boolean
	// `true` for browsers implementing the Microsoft touch events model (notably IE10).
	var msPointer = !window.PointerEvent && window.MSPointerEvent;

	// @property pointer: Boolean
	// `true` for all browsers supporting [pointer events](https://msdn.microsoft.com/en-us/library/dn433244%28v=vs.85%29.aspx).
	var pointer = !webkit && !!(window.PointerEvent || msPointer);

	// @property touch: Boolean
	// `true` for all browsers supporting [touch events](https://developer.mozilla.org/docs/Web/API/Touch_events).
	// This does not necessarily mean that the browser is running in a computer with
	// a touchscreen, it only means that the browser is capable of understanding
	// touch events.
	var touch = !window.L_NO_TOUCH && (pointer || 'ontouchstart' in window ||
			(window.DocumentTouch && document instanceof window.DocumentTouch));

	// @property mobileOpera: Boolean; `true` for the Opera browser in a mobile device.
	var mobileOpera = mobile && opera;

	// @property mobileGecko: Boolean
	// `true` for gecko-based browsers running in a mobile device.
	var mobileGecko = mobile && gecko;

	// @property retina: Boolean
	// `true` for browsers on a high-resolution "retina" screen or on any screen when browser's display zoom is more than 100%.
	var retina = (window.devicePixelRatio || (window.screen.deviceXDPI / window.screen.logicalXDPI)) > 1;

	// @property passiveEvents: Boolean
	// `true` for browsers that support passive events.
	var passiveEvents = (function () {
		var supportsPassiveOption = false;
		try {
			var opts = Object.defineProperty({}, 'passive', {
				get: function () {
					supportsPassiveOption = true;
				}
			});
			window.addEventListener('testPassiveEventSupport', falseFn, opts);
			window.removeEventListener('testPassiveEventSupport', falseFn, opts);
		} catch (e) {
			// Errors can safely be ignored since this is only a browser support test.
		}
		return supportsPassiveOption;
	});

	// @property canvas: Boolean
	// `true` when the browser supports [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).
	var canvas = (function () {
		return !!document.createElement('canvas').getContext;
	}());

	// @property svg: Boolean
	// `true` when the browser supports [SVG](https://developer.mozilla.org/docs/Web/SVG).
	var svg = !!(document.createElementNS && svgCreate('svg').createSVGRect);

	// @property vml: Boolean
	// `true` if the browser supports [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language).
	var vml = !svg && (function () {
		try {
			var div = document.createElement('div');
			div.innerHTML = '<v:shape adj="1"/>';

			var shape = div.firstChild;
			shape.style.behavior = 'url(#default#VML)';

			return shape && (typeof shape.adj === 'object');

		} catch (e) {
			return false;
		}
	}());


	function userAgentContains(str) {
		return navigator.userAgent.toLowerCase().indexOf(str) >= 0;
	}


	var Browser = (Object.freeze || Object)({
		ie: ie,
		ielt9: ielt9,
		edge: edge,
		webkit: webkit,
		android: android,
		android23: android23,
		androidStock: androidStock,
		opera: opera,
		chrome: chrome,
		gecko: gecko,
		safari: safari,
		phantom: phantom,
		opera12: opera12,
		win: win,
		ie3d: ie3d,
		webkit3d: webkit3d,
		gecko3d: gecko3d,
		any3d: any3d,
		mobile: mobile,
		mobileWebkit: mobileWebkit,
		mobileWebkit3d: mobileWebkit3d,
		msPointer: msPointer,
		pointer: pointer,
		touch: touch,
		mobileOpera: mobileOpera,
		mobileGecko: mobileGecko,
		retina: retina,
		passiveEvents: passiveEvents,
		canvas: canvas,
		svg: svg,
		vml: vml
	});

	/*
	 * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.
	 */


	var POINTER_DOWN =   msPointer ? 'MSPointerDown'   : 'pointerdown';
	var POINTER_MOVE =   msPointer ? 'MSPointerMove'   : 'pointermove';
	var POINTER_UP =     msPointer ? 'MSPointerUp'     : 'pointerup';
	var POINTER_CANCEL = msPointer ? 'MSPointerCancel' : 'pointercancel';
	var TAG_WHITE_LIST = ['INPUT', 'SELECT', 'OPTION'];

	var _pointers = {};
	var _pointerDocListener = false;

	// DomEvent.DoubleTap needs to know about this
	var _pointersCount = 0;

	// Provides a touch events wrapper for (ms)pointer events.
	// ref http://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890

	function addPointerListener(obj, type, handler, id) {
		if (type === 'touchstart') {
			_addPointerStart(obj, handler, id);

		} else if (type === 'touchmove') {
			_addPointerMove(obj, handler, id);

		} else if (type === 'touchend') {
			_addPointerEnd(obj, handler, id);
		}

		return this;
	}

	function removePointerListener(obj, type, id) {
		var handler = obj['_leaflet_' + type + id];

		if (type === 'touchstart') {
			obj.removeEventListener(POINTER_DOWN, handler, false);

		} else if (type === 'touchmove') {
			obj.removeEventListener(POINTER_MOVE, handler, false);

		} else if (type === 'touchend') {
			obj.removeEventListener(POINTER_UP, handler, false);
			obj.removeEventListener(POINTER_CANCEL, handler, false);
		}

		return this;
	}

	function _addPointerStart(obj, handler, id) {
		var onDown = bind(function (e) {
			if (e.pointerType !== 'mouse' && e.MSPOINTER_TYPE_MOUSE && e.pointerType !== e.MSPOINTER_TYPE_MOUSE) {
				// In IE11, some touch events needs to fire for form controls, or
				// the controls will stop working. We keep a whitelist of tag names that
				// need these events. For other target tags, we prevent default on the event.
				if (TAG_WHITE_LIST.indexOf(e.target.tagName) < 0) {
					preventDefault(e);
				} else {
					return;
				}
			}

			_handlePointer(e, handler);
		});

		obj['_leaflet_touchstart' + id] = onDown;
		obj.addEventListener(POINTER_DOWN, onDown, false);

		// need to keep track of what pointers and how many are active to provide e.touches emulation
		if (!_pointerDocListener) {
			// we listen documentElement as any drags that end by moving the touch off the screen get fired there
			document.documentElement.addEventListener(POINTER_DOWN, _globalPointerDown, true);
			document.documentElement.addEventListener(POINTER_MOVE, _globalPointerMove, true);
			document.documentElement.addEventListener(POINTER_UP, _globalPointerUp, true);
			document.documentElement.addEventListener(POINTER_CANCEL, _globalPointerUp, true);

			_pointerDocListener = true;
		}
	}

	function _globalPointerDown(e) {
		_pointers[e.pointerId] = e;
		_pointersCount++;
	}

	function _globalPointerMove(e) {
		if (_pointers[e.pointerId]) {
			_pointers[e.pointerId] = e;
		}
	}

	function _globalPointerUp(e) {
		delete _pointers[e.pointerId];
		_pointersCount--;
	}

	function _handlePointer(e, handler) {
		e.touches = [];
		for (var i in _pointers) {
			e.touches.push(_pointers[i]);
		}
		e.changedTouches = [e];

		handler(e);
	}

	function _addPointerMove(obj, handler, id) {
		var onMove = function (e) {
			// don't fire touch moves when mouse isn't down
			if ((e.pointerType === e.MSPOINTER_TYPE_MOUSE || e.pointerType === 'mouse') && e.buttons === 0) { return; }

			_handlePointer(e, handler);
		};

		obj['_leaflet_touchmove' + id] = onMove;
		obj.addEventListener(POINTER_MOVE, onMove, false);
	}

	function _addPointerEnd(obj, handler, id) {
		var onUp = function (e) {
			_handlePointer(e, handler);
		};

		obj['_leaflet_touchend' + id] = onUp;
		obj.addEventListener(POINTER_UP, onUp, false);
		obj.addEventListener(POINTER_CANCEL, onUp, false);
	}

	/*
	 * Extends the event handling code with double tap support for mobile browsers.
	 */

	var _touchstart = msPointer ? 'MSPointerDown' : pointer ? 'pointerdown' : 'touchstart';
	var _touchend = msPointer ? 'MSPointerUp' : pointer ? 'pointerup' : 'touchend';
	var _pre = '_leaflet_';

	// inspired by Zepto touch code by Thomas Fuchs
	function addDoubleTapListener(obj, handler, id) {
		var last, touch$$1,
		    doubleTap = false,
		    delay = 250;

		function onTouchStart(e) {
			var count;

			if (pointer) {
				if ((!edge) || e.pointerType === 'mouse') { return; }
				count = _pointersCount;
			} else {
				count = e.touches.length;
			}

			if (count > 1) { return; }

			var now = Date.now(),
			    delta = now - (last || now);

			touch$$1 = e.touches ? e.touches[0] : e;
			doubleTap = (delta > 0 && delta <= delay);
			last = now;
		}

		function onTouchEnd(e) {
			if (doubleTap && !touch$$1.cancelBubble) {
				if (pointer) {
					if ((!edge) || e.pointerType === 'mouse') { return; }
					// work around .type being readonly with MSPointer* events
					var newTouch = {},
					    prop, i;

					for (i in touch$$1) {
						prop = touch$$1[i];
						newTouch[i] = prop && prop.bind ? prop.bind(touch$$1) : prop;
					}
					touch$$1 = newTouch;
				}
				touch$$1.type = 'dblclick';
				touch$$1.button = 0;
				handler(touch$$1);
				last = null;
			}
		}

		obj[_pre + _touchstart + id] = onTouchStart;
		obj[_pre + _touchend + id] = onTouchEnd;
		obj[_pre + 'dblclick' + id] = handler;

		obj.addEventListener(_touchstart, onTouchStart, passiveEvents ? {passive: false} : false);
		obj.addEventListener(_touchend, onTouchEnd, passiveEvents ? {passive: false} : false);

		// On some platforms (notably, chrome<55 on win10 + touchscreen + mouse),
		// the browser doesn't fire touchend/pointerup events but does fire
		// native dblclicks. See #4127.
		// Edge 14 also fires native dblclicks, but only for pointerType mouse, see #5180.
		obj.addEventListener('dblclick', handler, false);

		return this;
	}

	function removeDoubleTapListener(obj, id) {
		var touchstart = obj[_pre + _touchstart + id],
		    touchend = obj[_pre + _touchend + id],
		    dblclick = obj[_pre + 'dblclick' + id];

		obj.removeEventListener(_touchstart, touchstart, passiveEvents ? {passive: false} : false);
		obj.removeEventListener(_touchend, touchend, passiveEvents ? {passive: false} : false);
		if (!edge) {
			obj.removeEventListener('dblclick', dblclick, false);
		}

		return this;
	}

	/*
	 * @namespace DomUtil
	 *
	 * Utility functions to work with the [DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model)
	 * tree, used by Leaflet internally.
	 *
	 * Most functions expecting or returning a `HTMLElement` also work for
	 * SVG elements. The only difference is that classes refer to CSS classes
	 * in HTML and SVG classes in SVG.
	 */


	// @property TRANSFORM: String
	// Vendor-prefixed transform style name (e.g. `'webkitTransform'` for WebKit).
	var TRANSFORM = testProp(
		['transform', 'webkitTransform', 'OTransform', 'MozTransform', 'msTransform']);

	// webkitTransition comes first because some browser versions that drop vendor prefix don't do
	// the same for the transitionend event, in particular the Android 4.1 stock browser

	// @property TRANSITION: String
	// Vendor-prefixed transition style name.
	var TRANSITION = testProp(
		['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);

	// @property TRANSITION_END: String
	// Vendor-prefixed transitionend event name.
	var TRANSITION_END =
		TRANSITION === 'webkitTransition' || TRANSITION === 'OTransition' ? TRANSITION + 'End' : 'transitionend';


	// @function get(id: String|HTMLElement): HTMLElement
	// Returns an element given its DOM id, or returns the element itself
	// if it was passed directly.
	function get$1(id) {
		return typeof id === 'string' ? document.getElementById(id) : id;
	}

	// @function getStyle(el: HTMLElement, styleAttrib: String): String
	// Returns the value for a certain style attribute on an element,
	// including computed values or values set through CSS.
	function getStyle(el, style) {
		var value = el.style[style] || (el.currentStyle && el.currentStyle[style]);

		if ((!value || value === 'auto') && document.defaultView) {
			var css = document.defaultView.getComputedStyle(el, null);
			value = css ? css[style] : null;
		}
		return value === 'auto' ? null : value;
	}

	// @function create(tagName: String, className?: String, container?: HTMLElement): HTMLElement
	// Creates an HTML element with `tagName`, sets its class to `className`, and optionally appends it to `container` element.
	function create$1$1(tagName, className, container) {
		var el = document.createElement(tagName);
		el.className = className || '';

		if (container) {
			container.appendChild(el);
		}
		return el;
	}

	// @function remove(el: HTMLElement)
	// Removes `el` from its parent element
	function remove(el) {
		var parent = el.parentNode;
		if (parent) {
			parent.removeChild(el);
		}
	}

	// @function empty(el: HTMLElement)
	// Removes all of `el`'s children elements from `el`
	function empty$1(el) {
		while (el.firstChild) {
			el.removeChild(el.firstChild);
		}
	}

	// @function toFront(el: HTMLElement)
	// Makes `el` the last child of its parent, so it renders in front of the other children.
	function toFront(el) {
		var parent = el.parentNode;
		if (parent && parent.lastChild !== el) {
			parent.appendChild(el);
		}
	}

	// @function toBack(el: HTMLElement)
	// Makes `el` the first child of its parent, so it renders behind the other children.
	function toBack(el) {
		var parent = el.parentNode;
		if (parent && parent.firstChild !== el) {
			parent.insertBefore(el, parent.firstChild);
		}
	}

	// @function hasClass(el: HTMLElement, name: String): Boolean
	// Returns `true` if the element's class attribute contains `name`.
	function hasClass(el, name) {
		if (el.classList !== undefined) {
			return el.classList.contains(name);
		}
		var className = getClass(el);
		return className.length > 0 && new RegExp('(^|\\s)' + name + '(\\s|$)').test(className);
	}

	// @function addClass(el: HTMLElement, name: String)
	// Adds `name` to the element's class attribute.
	function addClass(el, name) {
		if (el.classList !== undefined) {
			var classes = splitWords(name);
			for (var i = 0, len = classes.length; i < len; i++) {
				el.classList.add(classes[i]);
			}
		} else if (!hasClass(el, name)) {
			var className = getClass(el);
			setClass(el, (className ? className + ' ' : '') + name);
		}
	}

	// @function removeClass(el: HTMLElement, name: String)
	// Removes `name` from the element's class attribute.
	function removeClass(el, name) {
		if (el.classList !== undefined) {
			el.classList.remove(name);
		} else {
			setClass(el, trim$1((' ' + getClass(el) + ' ').replace(' ' + name + ' ', ' ')));
		}
	}

	// @function setClass(el: HTMLElement, name: String)
	// Sets the element's class.
	function setClass(el, name) {
		if (el.className.baseVal === undefined) {
			el.className = name;
		} else {
			// in case of SVG element
			el.className.baseVal = name;
		}
	}

	// @function getClass(el: HTMLElement): String
	// Returns the element's class.
	function getClass(el) {
		// Check if the element is an SVGElementInstance and use the correspondingElement instead
		// (Required for linked SVG elements in IE11.)
		if (el.correspondingElement) {
			el = el.correspondingElement;
		}
		return el.className.baseVal === undefined ? el.className : el.className.baseVal;
	}

	// @function setOpacity(el: HTMLElement, opacity: Number)
	// Set the opacity of an element (including old IE support).
	// `opacity` must be a number from `0` to `1`.
	function setOpacity(el, value) {
		if ('opacity' in el.style) {
			el.style.opacity = value;
		} else if ('filter' in el.style) {
			_setOpacityIE(el, value);
		}
	}

	function _setOpacityIE(el, value) {
		var filter = false,
		    filterName = 'DXImageTransform.Microsoft.Alpha';

		// filters collection throws an error if we try to retrieve a filter that doesn't exist
		try {
			filter = el.filters.item(filterName);
		} catch (e) {
			// don't set opacity to 1 if we haven't already set an opacity,
			// it isn't needed and breaks transparent pngs.
			if (value === 1) { return; }
		}

		value = Math.round(value * 100);

		if (filter) {
			filter.Enabled = (value !== 100);
			filter.Opacity = value;
		} else {
			el.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';
		}
	}

	// @function testProp(props: String[]): String|false
	// Goes through the array of style names and returns the first name
	// that is a valid style name for an element. If no such name is found,
	// it returns false. Useful for vendor-prefixed styles like `transform`.
	function testProp(props) {
		var style = document.documentElement.style;

		for (var i = 0; i < props.length; i++) {
			if (props[i] in style) {
				return props[i];
			}
		}
		return false;
	}

	// @function setTransform(el: HTMLElement, offset: Point, scale?: Number)
	// Resets the 3D CSS transform of `el` so it is translated by `offset` pixels
	// and optionally scaled by `scale`. Does not have an effect if the
	// browser doesn't support 3D CSS transforms.
	function setTransform(el, offset, scale) {
		var pos = offset || new Point$1(0, 0);

		el.style[TRANSFORM] =
			(ie3d ?
				'translate(' + pos.x + 'px,' + pos.y + 'px)' :
				'translate3d(' + pos.x + 'px,' + pos.y + 'px,0)') +
			(scale ? ' scale(' + scale + ')' : '');
	}

	// @function setPosition(el: HTMLElement, position: Point)
	// Sets the position of `el` to coordinates specified by `position`,
	// using CSS translate or top/left positioning depending on the browser
	// (used by Leaflet internally to position its layers).
	function setPosition(el, point) {

		/*eslint-disable */
		el._leaflet_pos = point;
		/* eslint-enable */

		if (any3d) {
			setTransform(el, point);
		} else {
			el.style.left = point.x + 'px';
			el.style.top = point.y + 'px';
		}
	}

	// @function getPosition(el: HTMLElement): Point
	// Returns the coordinates of an element previously positioned with setPosition.
	function getPosition$1(el) {
		// this method is only used for elements previously positioned using setPosition,
		// so it's safe to cache the position for performance

		return el._leaflet_pos || new Point$1(0, 0);
	}

	// @function disableTextSelection()
	// Prevents the user from generating `selectstart` DOM events, usually generated
	// when the user drags the mouse through a page with text. Used internally
	// by Leaflet to override the behaviour of any click-and-drag interaction on
	// the map. Affects drag interactions on the whole document.

	// @function enableTextSelection()
	// Cancels the effects of a previous [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection).
	var disableTextSelection;
	var enableTextSelection;
	var _userSelect;
	if ('onselectstart' in document) {
		disableTextSelection = function () {
			on(window, 'selectstart', preventDefault);
		};
		enableTextSelection = function () {
			off(window, 'selectstart', preventDefault);
		};
	} else {
		var userSelectProperty = testProp(
			['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);

		disableTextSelection = function () {
			if (userSelectProperty) {
				var style = document.documentElement.style;
				_userSelect = style[userSelectProperty];
				style[userSelectProperty] = 'none';
			}
		};
		enableTextSelection = function () {
			if (userSelectProperty) {
				document.documentElement.style[userSelectProperty] = _userSelect;
				_userSelect = undefined;
			}
		};
	}

	// @function disableImageDrag()
	// As [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection), but
	// for `dragstart` DOM events, usually generated when the user drags an image.
	function disableImageDrag() {
		on(window, 'dragstart', preventDefault);
	}

	// @function enableImageDrag()
	// Cancels the effects of a previous [`L.DomUtil.disableImageDrag`](#domutil-disabletextselection).
	function enableImageDrag() {
		off(window, 'dragstart', preventDefault);
	}

	var _outlineElement;
	var _outlineStyle;
	// @function preventOutline(el: HTMLElement)
	// Makes the [outline](https://developer.mozilla.org/docs/Web/CSS/outline)
	// of the element `el` invisible. Used internally by Leaflet to prevent
	// focusable elements from displaying an outline when the user performs a
	// drag interaction on them.
	function preventOutline(element) {
		while (element.tabIndex === -1) {
			element = element.parentNode;
		}
		if (!element.style) { return; }
		restoreOutline();
		_outlineElement = element;
		_outlineStyle = element.style.outline;
		element.style.outline = 'none';
		on(window, 'keydown', restoreOutline);
	}

	// @function restoreOutline()
	// Cancels the effects of a previous [`L.DomUtil.preventOutline`]().
	function restoreOutline() {
		if (!_outlineElement) { return; }
		_outlineElement.style.outline = _outlineStyle;
		_outlineElement = undefined;
		_outlineStyle = undefined;
		off(window, 'keydown', restoreOutline);
	}

	// @function getSizedParentNode(el: HTMLElement): HTMLElement
	// Finds the closest parent node which size (width and height) is not null.
	function getSizedParentNode(element) {
		do {
			element = element.parentNode;
		} while ((!element.offsetWidth || !element.offsetHeight) && element !== document.body);
		return element;
	}

	// @function getScale(el: HTMLElement): Object
	// Computes the CSS scale currently applied on the element.
	// Returns an object with `x` and `y` members as horizontal and vertical scales respectively,
	// and `boundingClientRect` as the result of [`getBoundingClientRect()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect).
	function getScale(element) {
		var rect = element.getBoundingClientRect(); // Read-only in old browsers.

		return {
			x: rect.width / element.offsetWidth || 1,
			y: rect.height / element.offsetHeight || 1,
			boundingClientRect: rect
		};
	}


	var DomUtil = (Object.freeze || Object)({
		TRANSFORM: TRANSFORM,
		TRANSITION: TRANSITION,
		TRANSITION_END: TRANSITION_END,
		get: get$1,
		getStyle: getStyle,
		create: create$1$1,
		remove: remove,
		empty: empty$1,
		toFront: toFront,
		toBack: toBack,
		hasClass: hasClass,
		addClass: addClass,
		removeClass: removeClass,
		setClass: setClass,
		getClass: getClass,
		setOpacity: setOpacity,
		testProp: testProp,
		setTransform: setTransform,
		setPosition: setPosition,
		getPosition: getPosition$1,
		disableTextSelection: disableTextSelection,
		enableTextSelection: enableTextSelection,
		disableImageDrag: disableImageDrag,
		enableImageDrag: enableImageDrag,
		preventOutline: preventOutline,
		restoreOutline: restoreOutline,
		getSizedParentNode: getSizedParentNode,
		getScale: getScale
	});

	/*
	 * @namespace DomEvent
	 * Utility functions to work with the [DOM events](https://developer.mozilla.org/docs/Web/API/Event), used by Leaflet internally.
	 */

	// Inspired by John Resig, Dean Edwards and YUI addEvent implementations.

	// @function on(el: HTMLElement, types: String, fn: Function, context?: Object): this
	// Adds a listener function (`fn`) to a particular DOM event type of the
	// element `el`. You can optionally specify the context of the listener
	// (object the `this` keyword will point to). You can also pass several
	// space-separated types (e.g. `'click dblclick'`).

	// @alternative
	// @function on(el: HTMLElement, eventMap: Object, context?: Object): this
	// Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
	function on(obj, types, fn, context) {

		if (typeof types === 'object') {
			for (var type in types) {
				addOne(obj, type, types[type], fn);
			}
		} else {
			types = splitWords(types);

			for (var i = 0, len = types.length; i < len; i++) {
				addOne(obj, types[i], fn, context);
			}
		}

		return this;
	}

	var eventsKey = '_leaflet_events';

	// @function off(el: HTMLElement, types: String, fn: Function, context?: Object): this
	// Removes a previously added listener function.
	// Note that if you passed a custom context to on, you must pass the same
	// context to `off` in order to remove the listener.

	// @alternative
	// @function off(el: HTMLElement, eventMap: Object, context?: Object): this
	// Removes a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
	function off(obj, types, fn, context) {

		if (typeof types === 'object') {
			for (var type in types) {
				removeOne(obj, type, types[type], fn);
			}
		} else if (types) {
			types = splitWords(types);

			for (var i = 0, len = types.length; i < len; i++) {
				removeOne(obj, types[i], fn, context);
			}
		} else {
			for (var j in obj[eventsKey]) {
				removeOne(obj, j, obj[eventsKey][j]);
			}
			delete obj[eventsKey];
		}

		return this;
	}

	function addOne(obj, type, fn, context) {
		var id = type + stamp(fn) + (context ? '_' + stamp(context) : '');

		if (obj[eventsKey] && obj[eventsKey][id]) { return this; }

		var handler = function (e) {
			return fn.call(context || obj, e || window.event);
		};

		var originalHandler = handler;

		if (pointer && type.indexOf('touch') === 0) {
			// Needs DomEvent.Pointer.js
			addPointerListener(obj, type, handler, id);

		} else if (touch && (type === 'dblclick') && addDoubleTapListener &&
		           !(pointer && chrome)) {
			// Chrome >55 does not need the synthetic dblclicks from addDoubleTapListener
			// See #5180
			addDoubleTapListener(obj, handler, id);

		} else if ('addEventListener' in obj) {

			if (type === 'mousewheel') {
				obj.addEventListener('onwheel' in obj ? 'wheel' : 'mousewheel', handler, passiveEvents ? {passive: false} : false);

			} else if ((type === 'mouseenter') || (type === 'mouseleave')) {
				handler = function (e) {
					e = e || window.event;
					if (isExternalTarget(obj, e)) {
						originalHandler(e);
					}
				};
				obj.addEventListener(type === 'mouseenter' ? 'mouseover' : 'mouseout', handler, false);

			} else {
				if (type === 'click' && android) {
					handler = function (e) {
						filterClick(e, originalHandler);
					};
				}
				obj.addEventListener(type, handler, false);
			}

		} else if ('attachEvent' in obj) {
			obj.attachEvent('on' + type, handler);
		}

		obj[eventsKey] = obj[eventsKey] || {};
		obj[eventsKey][id] = handler;
	}

	function removeOne(obj, type, fn, context) {

		var id = type + stamp(fn) + (context ? '_' + stamp(context) : ''),
		    handler = obj[eventsKey] && obj[eventsKey][id];

		if (!handler) { return this; }

		if (pointer && type.indexOf('touch') === 0) {
			removePointerListener(obj, type, id);

		} else if (touch && (type === 'dblclick') && removeDoubleTapListener &&
		           !(pointer && chrome)) {
			removeDoubleTapListener(obj, id);

		} else if ('removeEventListener' in obj) {

			if (type === 'mousewheel') {
				obj.removeEventListener('onwheel' in obj ? 'wheel' : 'mousewheel', handler, passiveEvents ? {passive: false} : false);

			} else {
				obj.removeEventListener(
					type === 'mouseenter' ? 'mouseover' :
					type === 'mouseleave' ? 'mouseout' : type, handler, false);
			}

		} else if ('detachEvent' in obj) {
			obj.detachEvent('on' + type, handler);
		}

		obj[eventsKey][id] = null;
	}

	// @function stopPropagation(ev: DOMEvent): this
	// Stop the given event from propagation to parent elements. Used inside the listener functions:
	// ```js
	// L.DomEvent.on(div, 'click', function (ev) {
	// 	L.DomEvent.stopPropagation(ev);
	// });
	// ```
	function stopPropagation(e) {

		if (e.stopPropagation) {
			e.stopPropagation();
		} else if (e.originalEvent) {  // In case of Leaflet event.
			e.originalEvent._stopped = true;
		} else {
			e.cancelBubble = true;
		}
		skipped(e);

		return this;
	}

	// @function disableScrollPropagation(el: HTMLElement): this
	// Adds `stopPropagation` to the element's `'mousewheel'` events (plus browser variants).
	function disableScrollPropagation(el) {
		addOne(el, 'mousewheel', stopPropagation);
		return this;
	}

	// @function disableClickPropagation(el: HTMLElement): this
	// Adds `stopPropagation` to the element's `'click'`, `'doubleclick'`,
	// `'mousedown'` and `'touchstart'` events (plus browser variants).
	function disableClickPropagation(el) {
		on(el, 'mousedown touchstart dblclick', stopPropagation);
		addOne(el, 'click', fakeStop);
		return this;
	}

	// @function preventDefault(ev: DOMEvent): this
	// Prevents the default action of the DOM Event `ev` from happening (such as
	// following a link in the href of the a element, or doing a POST request
	// with page reload when a `<form>` is submitted).
	// Use it inside listener functions.
	function preventDefault(e) {
		if (e.preventDefault) {
			e.preventDefault();
		} else {
			e.returnValue = false;
		}
		return this;
	}

	// @function stop(ev: DOMEvent): this
	// Does `stopPropagation` and `preventDefault` at the same time.
	function stop(e) {
		preventDefault(e);
		stopPropagation(e);
		return this;
	}

	// @function getMousePosition(ev: DOMEvent, container?: HTMLElement): Point
	// Gets normalized mouse position from a DOM event relative to the
	// `container` (border excluded) or to the whole page if not specified.
	function getMousePosition(e, container) {
		if (!container) {
			return new Point$1(e.clientX, e.clientY);
		}

		var scale = getScale(container),
		    offset = scale.boundingClientRect; // left and top  values are in page scale (like the event clientX/Y)

		return new Point$1(
			// offset.left/top values are in page scale (like clientX/Y),
			// whereas clientLeft/Top (border width) values are the original values (before CSS scale applies).
			(e.clientX - offset.left) / scale.x - container.clientLeft,
			(e.clientY - offset.top) / scale.y - container.clientTop
		);
	}

	// Chrome on Win scrolls double the pixels as in other platforms (see #4538),
	// and Firefox scrolls device pixels, not CSS pixels
	var wheelPxFactor =
		(win && chrome) ? 2 * window.devicePixelRatio :
		gecko ? window.devicePixelRatio : 1;

	// @function getWheelDelta(ev: DOMEvent): Number
	// Gets normalized wheel delta from a mousewheel DOM event, in vertical
	// pixels scrolled (negative if scrolling down).
	// Events from pointing devices without precise scrolling are mapped to
	// a best guess of 60 pixels.
	function getWheelDelta(e) {
		return (edge) ? e.wheelDeltaY / 2 : // Don't trust window-geometry-based delta
		       (e.deltaY && e.deltaMode === 0) ? -e.deltaY / wheelPxFactor : // Pixels
		       (e.deltaY && e.deltaMode === 1) ? -e.deltaY * 20 : // Lines
		       (e.deltaY && e.deltaMode === 2) ? -e.deltaY * 60 : // Pages
		       (e.deltaX || e.deltaZ) ? 0 :	// Skip horizontal/depth wheel events
		       e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : // Legacy IE pixels
		       (e.detail && Math.abs(e.detail) < 32765) ? -e.detail * 20 : // Legacy Moz lines
		       e.detail ? e.detail / -32765 * 60 : // Legacy Moz pages
		       0;
	}

	var skipEvents = {};

	function fakeStop(e) {
		// fakes stopPropagation by setting a special event flag, checked/reset with skipped(e)
		skipEvents[e.type] = true;
	}

	function skipped(e) {
		var events = skipEvents[e.type];
		// reset when checking, as it's only used in map container and propagates outside of the map
		skipEvents[e.type] = false;
		return events;
	}

	// check if element really left/entered the event target (for mouseenter/mouseleave)
	function isExternalTarget(el, e) {

		var related = e.relatedTarget;

		if (!related) { return true; }

		try {
			while (related && (related !== el)) {
				related = related.parentNode;
			}
		} catch (err) {
			return false;
		}
		return (related !== el);
	}

	var lastClick;

	// this is a horrible workaround for a bug in Android where a single touch triggers two click events
	function filterClick(e, handler) {
		var timeStamp = (e.timeStamp || (e.originalEvent && e.originalEvent.timeStamp)),
		    elapsed = lastClick && (timeStamp - lastClick);

		// are they closer together than 500ms yet more than 100ms?
		// Android typically triggers them ~300ms apart while multiple listeners
		// on the same event should be triggered far faster;
		// or check if click is simulated on the element, and if it is, reject any non-simulated events

		if ((elapsed && elapsed > 100 && elapsed < 500) || (e.target._simulatedClick && !e._simulated)) {
			stop(e);
			return;
		}
		lastClick = timeStamp;

		handler(e);
	}




	var DomEvent = (Object.freeze || Object)({
		on: on,
		off: off,
		stopPropagation: stopPropagation,
		disableScrollPropagation: disableScrollPropagation,
		disableClickPropagation: disableClickPropagation,
		preventDefault: preventDefault,
		stop: stop,
		getMousePosition: getMousePosition,
		getWheelDelta: getWheelDelta,
		fakeStop: fakeStop,
		skipped: skipped,
		isExternalTarget: isExternalTarget,
		addListener: on,
		removeListener: off
	});

	/*
	 * @class PosAnimation
	 * @aka L.PosAnimation
	 * @inherits Evented
	 * Used internally for panning animations, utilizing CSS3 Transitions for modern browsers and a timer fallback for IE6-9.
	 *
	 * @example
	 * ```js
	 * var fx = new L.PosAnimation();
	 * fx.run(el, [300, 500], 0.5);
	 * ```
	 *
	 * @constructor L.PosAnimation()
	 * Creates a `PosAnimation` object.
	 *
	 */

	var PosAnimation = Evented.extend({

		// @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)
		// Run an animation of a given element to a new position, optionally setting
		// duration in seconds (`0.25` by default) and easing linearity factor (3rd
		// argument of the [cubic bezier curve](http://cubic-bezier.com/#0,0,.5,1),
		// `0.5` by default).
		run: function (el, newPos, duration, easeLinearity) {
			this.stop();

			this._el = el;
			this._inProgress = true;
			this._duration = duration || 0.25;
			this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);

			this._startPos = getPosition$1(el);
			this._offset = newPos.subtract(this._startPos);
			this._startTime = +new Date();

			// @event start: Event
			// Fired when the animation starts
			this.fire('start');

			this._animate();
		},

		// @method stop()
		// Stops the animation (if currently running).
		stop: function () {
			if (!this._inProgress) { return; }

			this._step(true);
			this._complete();
		},

		_animate: function () {
			// animation loop
			this._animId = requestAnimFrame(this._animate, this);
			this._step();
		},

		_step: function (round) {
			var elapsed = (+new Date()) - this._startTime,
			    duration = this._duration * 1000;

			if (elapsed < duration) {
				this._runFrame(this._easeOut(elapsed / duration), round);
			} else {
				this._runFrame(1);
				this._complete();
			}
		},

		_runFrame: function (progress, round) {
			var pos = this._startPos.add(this._offset.multiplyBy(progress));
			if (round) {
				pos._round();
			}
			setPosition(this._el, pos);

			// @event step: Event
			// Fired continuously during the animation.
			this.fire('step');
		},

		_complete: function () {
			cancelAnimFrame(this._animId);

			this._inProgress = false;
			// @event end: Event
			// Fired when the animation ends.
			this.fire('end');
		},

		_easeOut: function (t) {
			return 1 - Math.pow(1 - t, this._easeOutPower);
		}
	});

	/*
	 * @class Map
	 * @aka L.Map
	 * @inherits Evented
	 *
	 * The central class of the API — it is used to create a map on a page and manipulate it.
	 *
	 * @example
	 *
	 * ```js
	 * // initialize the map on the "map" div with a given center and zoom
	 * var map = L.map('map', {
	 * 	center: [51.505, -0.09],
	 * 	zoom: 13
	 * });
	 * ```
	 *
	 */

	var Map$1 = Evented.extend({

		options: {
			// @section Map State Options
			// @option crs: CRS = L.CRS.EPSG3857
			// The [Coordinate Reference System](#crs) to use. Don't change this if you're not
			// sure what it means.
			crs: EPSG3857,

			// @option center: LatLng = undefined
			// Initial geographic center of the map
			center: undefined,

			// @option zoom: Number = undefined
			// Initial map zoom level
			zoom: undefined,

			// @option minZoom: Number = *
			// Minimum zoom level of the map.
			// If not specified and at least one `GridLayer` or `TileLayer` is in the map,
			// the lowest of their `minZoom` options will be used instead.
			minZoom: undefined,

			// @option maxZoom: Number = *
			// Maximum zoom level of the map.
			// If not specified and at least one `GridLayer` or `TileLayer` is in the map,
			// the highest of their `maxZoom` options will be used instead.
			maxZoom: undefined,

			// @option layers: Layer[] = []
			// Array of layers that will be added to the map initially
			layers: [],

			// @option maxBounds: LatLngBounds = null
			// When this option is set, the map restricts the view to the given
			// geographical bounds, bouncing the user back if the user tries to pan
			// outside the view. To set the restriction dynamically, use
			// [`setMaxBounds`](#map-setmaxbounds) method.
			maxBounds: undefined,

			// @option renderer: Renderer = *
			// The default method for drawing vector layers on the map. `L.SVG`
			// or `L.Canvas` by default depending on browser support.
			renderer: undefined,


			// @section Animation Options
			// @option zoomAnimation: Boolean = true
			// Whether the map zoom animation is enabled. By default it's enabled
			// in all browsers that support CSS3 Transitions except Android.
			zoomAnimation: true,

			// @option zoomAnimationThreshold: Number = 4
			// Won't animate zoom if the zoom difference exceeds this value.
			zoomAnimationThreshold: 4,

			// @option fadeAnimation: Boolean = true
			// Whether the tile fade animation is enabled. By default it's enabled
			// in all browsers that support CSS3 Transitions except Android.
			fadeAnimation: true,

			// @option markerZoomAnimation: Boolean = true
			// Whether markers animate their zoom with the zoom animation, if disabled
			// they will disappear for the length of the animation. By default it's
			// enabled in all browsers that support CSS3 Transitions except Android.
			markerZoomAnimation: true,

			// @option transform3DLimit: Number = 2^23
			// Defines the maximum size of a CSS translation transform. The default
			// value should not be changed unless a web browser positions layers in
			// the wrong place after doing a large `panBy`.
			transform3DLimit: 8388608, // Precision limit of a 32-bit float

			// @section Interaction Options
			// @option zoomSnap: Number = 1
			// Forces the map's zoom level to always be a multiple of this, particularly
			// right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.
			// By default, the zoom level snaps to the nearest integer; lower values
			// (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`
			// means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.
			zoomSnap: 1,

			// @option zoomDelta: Number = 1
			// Controls how much the map's zoom level will change after a
			// [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`
			// or `-` on the keyboard, or using the [zoom controls](#control-zoom).
			// Values smaller than `1` (e.g. `0.5`) allow for greater granularity.
			zoomDelta: 1,

			// @option trackResize: Boolean = true
			// Whether the map automatically handles browser window resize to update itself.
			trackResize: true
		},

		initialize: function (id, options) { // (HTMLElement or String, Object)
			options = setOptions(this, options);

			// Make sure to assign internal flags at the beginning,
			// to avoid inconsistent state in some edge cases.
			this._handlers = [];
			this._layers = {};
			this._zoomBoundLayers = {};
			this._sizeChanged = true;

			this._initContainer(id);
			this._initLayout();

			// hack for https://github.com/Leaflet/Leaflet/issues/1980
			this._onResize = bind(this._onResize, this);

			this._initEvents();

			if (options.maxBounds) {
				this.setMaxBounds(options.maxBounds);
			}

			if (options.zoom !== undefined) {
				this._zoom = this._limitZoom(options.zoom);
			}

			if (options.center && options.zoom !== undefined) {
				this.setView(toLatLng(options.center), options.zoom, {reset: true});
			}

			this.callInitHooks();

			// don't animate on browsers without hardware-accelerated transitions or old Android/Opera
			this._zoomAnimated = TRANSITION && any3d && !mobileOpera &&
					this.options.zoomAnimation;

			// zoom transitions run with the same duration for all layers, so if one of transitionend events
			// happens after starting zoom animation (propagating to the map pane), we know that it ended globally
			if (this._zoomAnimated) {
				this._createAnimProxy();
				on(this._proxy, TRANSITION_END, this._catchTransitionEnd, this);
			}

			this._addLayers(this.options.layers);
		},


		// @section Methods for modifying map state

		// @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this
		// Sets the view of the map (geographical center and zoom) with the given
		// animation options.
		setView: function (center, zoom, options) {

			zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);
			center = this._limitCenter(toLatLng(center), zoom, this.options.maxBounds);
			options = options || {};

			this._stop();

			if (this._loaded && !options.reset && options !== true) {

				if (options.animate !== undefined) {
					options.zoom = extend$1({animate: options.animate}, options.zoom);
					options.pan = extend$1({animate: options.animate, duration: options.duration}, options.pan);
				}

				// try animating pan or zoom
				var moved = (this._zoom !== zoom) ?
					this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) :
					this._tryAnimatedPan(center, options.pan);

				if (moved) {
					// prevent resize handler call, the view will refresh after animation anyway
					clearTimeout(this._sizeTimer);
					return this;
				}
			}

			// animation didn't start, just reset the map view
			this._resetView(center, zoom);

			return this;
		},

		// @method setZoom(zoom: Number, options?: Zoom/pan options): this
		// Sets the zoom of the map.
		setZoom: function (zoom, options) {
			if (!this._loaded) {
				this._zoom = zoom;
				return this;
			}
			return this.setView(this.getCenter(), zoom, {zoom: options});
		},

		// @method zoomIn(delta?: Number, options?: Zoom options): this
		// Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
		zoomIn: function (delta, options) {
			delta = delta || (any3d ? this.options.zoomDelta : 1);
			return this.setZoom(this._zoom + delta, options);
		},

		// @method zoomOut(delta?: Number, options?: Zoom options): this
		// Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
		zoomOut: function (delta, options) {
			delta = delta || (any3d ? this.options.zoomDelta : 1);
			return this.setZoom(this._zoom - delta, options);
		},

		// @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this
		// Zooms the map while keeping a specified geographical point on the map
		// stationary (e.g. used internally for scroll zoom and double-click zoom).
		// @alternative
		// @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this
		// Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.
		setZoomAround: function (latlng, zoom, options) {
			var scale = this.getZoomScale(zoom),
			    viewHalf = this.getSize().divideBy(2),
			    containerPoint = latlng instanceof Point$1 ? latlng : this.latLngToContainerPoint(latlng),

			    centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),
			    newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));

			return this.setView(newCenter, zoom, {zoom: options});
		},

		_getBoundsCenterZoom: function (bounds, options) {

			options = options || {};
			bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);

			var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),
			    paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),

			    zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));

			zoom = (typeof options.maxZoom === 'number') ? Math.min(options.maxZoom, zoom) : zoom;

			if (zoom === Infinity) {
				return {
					center: bounds.getCenter(),
					zoom: zoom
				};
			}

			var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),

			    swPoint = this.project(bounds.getSouthWest(), zoom),
			    nePoint = this.project(bounds.getNorthEast(), zoom),
			    center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);

			return {
				center: center,
				zoom: zoom
			};
		},

		// @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this
		// Sets a map view that contains the given geographical bounds with the
		// maximum zoom level possible.
		fitBounds: function (bounds, options) {

			bounds = toLatLngBounds(bounds);

			if (!bounds.isValid()) {
				throw new Error('Bounds are not valid.');
			}

			var target = this._getBoundsCenterZoom(bounds, options);
			return this.setView(target.center, target.zoom, options);
		},

		// @method fitWorld(options?: fitBounds options): this
		// Sets a map view that mostly contains the whole world with the maximum
		// zoom level possible.
		fitWorld: function (options) {
			return this.fitBounds([[-90, -180], [90, 180]], options);
		},

		// @method panTo(latlng: LatLng, options?: Pan options): this
		// Pans the map to a given center.
		panTo: function (center, options) { // (LatLng)
			return this.setView(center, this._zoom, {pan: options});
		},

		// @method panBy(offset: Point, options?: Pan options): this
		// Pans the map by a given number of pixels (animated).
		panBy: function (offset, options) {
			offset = toPoint(offset).round();
			options = options || {};

			if (!offset.x && !offset.y) {
				return this.fire('moveend');
			}
			// If we pan too far, Chrome gets issues with tiles
			// and makes them disappear or appear in the wrong place (slightly offset) #2602
			if (options.animate !== true && !this.getSize().contains(offset)) {
				this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());
				return this;
			}

			if (!this._panAnim) {
				this._panAnim = new PosAnimation();

				this._panAnim.on({
					'step': this._onPanTransitionStep,
					'end': this._onPanTransitionEnd
				}, this);
			}

			// don't fire movestart if animating inertia
			if (!options.noMoveStart) {
				this.fire('movestart');
			}

			// animate pan unless animate: false specified
			if (options.animate !== false) {
				addClass(this._mapPane, 'leaflet-pan-anim');

				var newPos = this._getMapPanePos().subtract(offset).round();
				this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
			} else {
				this._rawPanBy(offset);
				this.fire('move').fire('moveend');
			}

			return this;
		},

		// @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this
		// Sets the view of the map (geographical center and zoom) performing a smooth
		// pan-zoom animation.
		flyTo: function (targetCenter, targetZoom, options) {

			options = options || {};
			if (options.animate === false || !any3d) {
				return this.setView(targetCenter, targetZoom, options);
			}

			this._stop();

			var from = this.project(this.getCenter()),
			    to = this.project(targetCenter),
			    size = this.getSize(),
			    startZoom = this._zoom;

			targetCenter = toLatLng(targetCenter);
			targetZoom = targetZoom === undefined ? startZoom : targetZoom;

			var w0 = Math.max(size.x, size.y),
			    w1 = w0 * this.getZoomScale(startZoom, targetZoom),
			    u1 = (to.distanceTo(from)) || 1,
			    rho = 1.42,
			    rho2 = rho * rho;

			function r(i) {
				var s1 = i ? -1 : 1,
				    s2 = i ? w1 : w0,
				    t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1,
				    b1 = 2 * s2 * rho2 * u1,
				    b = t1 / b1,
				    sq = Math.sqrt(b * b + 1) - b;

				    // workaround for floating point precision bug when sq = 0, log = -Infinite,
				    // thus triggering an infinite loop in flyTo
				    var log = sq < 0.000000001 ? -18 : Math.log(sq);

				return log;
			}

			function sinh(n) { return (Math.exp(n) - Math.exp(-n)) / 2; }
			function cosh(n) { return (Math.exp(n) + Math.exp(-n)) / 2; }
			function tanh(n) { return sinh(n) / cosh(n); }

			var r0 = r(0);

			function w(s) { return w0 * (cosh(r0) / cosh(r0 + rho * s)); }
			function u(s) { return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2; }

			function easeOut(t) { return 1 - Math.pow(1 - t, 1.5); }

			var start = Date.now(),
			    S = (r(1) - r0) / rho,
			    duration = options.duration ? 1000 * options.duration : 1000 * S * 0.8;

			function frame() {
				var t = (Date.now() - start) / duration,
				    s = easeOut(t) * S;

				if (t <= 1) {
					this._flyToFrame = requestAnimFrame(frame, this);

					this._move(
						this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom),
						this.getScaleZoom(w0 / w(s), startZoom),
						{flyTo: true});

				} else {
					this
						._move(targetCenter, targetZoom)
						._moveEnd(true);
				}
			}

			this._moveStart(true, options.noMoveStart);

			frame.call(this);
			return this;
		},

		// @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this
		// Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),
		// but takes a bounds parameter like [`fitBounds`](#map-fitbounds).
		flyToBounds: function (bounds, options) {
			var target = this._getBoundsCenterZoom(bounds, options);
			return this.flyTo(target.center, target.zoom, options);
		},

		// @method setMaxBounds(bounds: Bounds): this
		// Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).
		setMaxBounds: function (bounds) {
			bounds = toLatLngBounds(bounds);

			if (!bounds.isValid()) {
				this.options.maxBounds = null;
				return this.off('moveend', this._panInsideMaxBounds);
			} else if (this.options.maxBounds) {
				this.off('moveend', this._panInsideMaxBounds);
			}

			this.options.maxBounds = bounds;

			if (this._loaded) {
				this._panInsideMaxBounds();
			}

			return this.on('moveend', this._panInsideMaxBounds);
		},

		// @method setMinZoom(zoom: Number): this
		// Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).
		setMinZoom: function (zoom) {
			var oldZoom = this.options.minZoom;
			this.options.minZoom = zoom;

			if (this._loaded && oldZoom !== zoom) {
				this.fire('zoomlevelschange');

				if (this.getZoom() < this.options.minZoom) {
					return this.setZoom(zoom);
				}
			}

			return this;
		},

		// @method setMaxZoom(zoom: Number): this
		// Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).
		setMaxZoom: function (zoom) {
			var oldZoom = this.options.maxZoom;
			this.options.maxZoom = zoom;

			if (this._loaded && oldZoom !== zoom) {
				this.fire('zoomlevelschange');

				if (this.getZoom() > this.options.maxZoom) {
					return this.setZoom(zoom);
				}
			}

			return this;
		},

		// @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this
		// Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.
		panInsideBounds: function (bounds, options) {
			this._enforcingBounds = true;
			var center = this.getCenter(),
			    newCenter = this._limitCenter(center, this._zoom, toLatLngBounds(bounds));

			if (!center.equals(newCenter)) {
				this.panTo(newCenter, options);
			}

			this._enforcingBounds = false;
			return this;
		},

		// @method panInside(latlng: LatLng, options?: options): this
		// Pans the map the minimum amount to make the `latlng` visible. Use
		// `padding`, `paddingTopLeft` and `paddingTopRight` options to fit
		// the display to more restricted bounds, like [`fitBounds`](#map-fitbounds).
		// If `latlng` is already within the (optionally padded) display bounds,
		// the map will not be panned.
		panInside: function (latlng, options) {
			options = options || {};

			var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),
			    paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),
			    center = this.getCenter(),
			    pixelCenter = this.project(center),
			    pixelPoint = this.project(latlng),
			    pixelBounds = this.getPixelBounds(),
			    halfPixelBounds = pixelBounds.getSize().divideBy(2),
			    paddedBounds = toBounds([pixelBounds.min.add(paddingTL), pixelBounds.max.subtract(paddingBR)]);

			if (!paddedBounds.contains(pixelPoint)) {
				this._enforcingBounds = true;
				var diff = pixelCenter.subtract(pixelPoint),
				    newCenter = toPoint(pixelPoint.x + diff.x, pixelPoint.y + diff.y);

				if (pixelPoint.x < paddedBounds.min.x || pixelPoint.x > paddedBounds.max.x) {
					newCenter.x = pixelCenter.x - diff.x;
					if (diff.x > 0) {
						newCenter.x += halfPixelBounds.x - paddingTL.x;
					} else {
						newCenter.x -= halfPixelBounds.x - paddingBR.x;
					}
				}
				if (pixelPoint.y < paddedBounds.min.y || pixelPoint.y > paddedBounds.max.y) {
					newCenter.y = pixelCenter.y - diff.y;
					if (diff.y > 0) {
						newCenter.y += halfPixelBounds.y - paddingTL.y;
					} else {
						newCenter.y -= halfPixelBounds.y - paddingBR.y;
					}
				}
				this.panTo(this.unproject(newCenter), options);
				this._enforcingBounds = false;
			}
			return this;
		},

		// @method invalidateSize(options: Zoom/pan options): this
		// Checks if the map container size changed and updates the map if so —
		// call it after you've changed the map size dynamically, also animating
		// pan by default. If `options.pan` is `false`, panning will not occur.
		// If `options.debounceMoveend` is `true`, it will delay `moveend` event so
		// that it doesn't happen often even if the method is called many
		// times in a row.

		// @alternative
		// @method invalidateSize(animate: Boolean): this
		// Checks if the map container size changed and updates the map if so —
		// call it after you've changed the map size dynamically, also animating
		// pan by default.
		invalidateSize: function (options) {
			if (!this._loaded) { return this; }

			options = extend$1({
				animate: false,
				pan: true
			}, options === true ? {animate: true} : options);

			var oldSize = this.getSize();
			this._sizeChanged = true;
			this._lastCenter = null;

			var newSize = this.getSize(),
			    oldCenter = oldSize.divideBy(2).round(),
			    newCenter = newSize.divideBy(2).round(),
			    offset = oldCenter.subtract(newCenter);

			if (!offset.x && !offset.y) { return this; }

			if (options.animate && options.pan) {
				this.panBy(offset);

			} else {
				if (options.pan) {
					this._rawPanBy(offset);
				}

				this.fire('move');

				if (options.debounceMoveend) {
					clearTimeout(this._sizeTimer);
					this._sizeTimer = setTimeout(bind(this.fire, this, 'moveend'), 200);
				} else {
					this.fire('moveend');
				}
			}

			// @section Map state change events
			// @event resize: ResizeEvent
			// Fired when the map is resized.
			return this.fire('resize', {
				oldSize: oldSize,
				newSize: newSize
			});
		},

		// @section Methods for modifying map state
		// @method stop(): this
		// Stops the currently running `panTo` or `flyTo` animation, if any.
		stop: function () {
			this.setZoom(this._limitZoom(this._zoom));
			if (!this.options.zoomSnap) {
				this.fire('viewreset');
			}
			return this._stop();
		},

		// @section Geolocation methods
		// @method locate(options?: Locate options): this
		// Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)
		// event with location data on success or a [`locationerror`](#map-locationerror) event on failure,
		// and optionally sets the map view to the user's location with respect to
		// detection accuracy (or to the world view if geolocation failed).
		// Note that, if your page doesn't use HTTPS, this method will fail in
		// modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))
		// See `Locate options` for more details.
		locate: function (options) {

			options = this._locateOptions = extend$1({
				timeout: 10000,
				watch: false
				// setView: false
				// maxZoom: <Number>
				// maximumAge: 0
				// enableHighAccuracy: false
			}, options);

			if (!('geolocation' in navigator)) {
				this._handleGeolocationError({
					code: 0,
					message: 'Geolocation not supported.'
				});
				return this;
			}

			var onResponse = bind(this._handleGeolocationResponse, this),
			    onError = bind(this._handleGeolocationError, this);

			if (options.watch) {
				this._locationWatchId =
				        navigator.geolocation.watchPosition(onResponse, onError, options);
			} else {
				navigator.geolocation.getCurrentPosition(onResponse, onError, options);
			}
			return this;
		},

		// @method stopLocate(): this
		// Stops watching location previously initiated by `map.locate({watch: true})`
		// and aborts resetting the map view if map.locate was called with
		// `{setView: true}`.
		stopLocate: function () {
			if (navigator.geolocation && navigator.geolocation.clearWatch) {
				navigator.geolocation.clearWatch(this._locationWatchId);
			}
			if (this._locateOptions) {
				this._locateOptions.setView = false;
			}
			return this;
		},

		_handleGeolocationError: function (error) {
			var c = error.code,
			    message = error.message ||
			            (c === 1 ? 'permission denied' :
			            (c === 2 ? 'position unavailable' : 'timeout'));

			if (this._locateOptions.setView && !this._loaded) {
				this.fitWorld();
			}

			// @section Location events
			// @event locationerror: ErrorEvent
			// Fired when geolocation (using the [`locate`](#map-locate) method) failed.
			this.fire('locationerror', {
				code: c,
				message: 'Geolocation error: ' + message + '.'
			});
		},

		_handleGeolocationResponse: function (pos) {
			var lat = pos.coords.latitude,
			    lng = pos.coords.longitude,
			    latlng = new LatLng(lat, lng),
			    bounds = latlng.toBounds(pos.coords.accuracy * 2),
			    options = this._locateOptions;

			if (options.setView) {
				var zoom = this.getBoundsZoom(bounds);
				this.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom);
			}

			var data = {
				latlng: latlng,
				bounds: bounds,
				timestamp: pos.timestamp
			};

			for (var i in pos.coords) {
				if (typeof pos.coords[i] === 'number') {
					data[i] = pos.coords[i];
				}
			}

			// @event locationfound: LocationEvent
			// Fired when geolocation (using the [`locate`](#map-locate) method)
			// went successfully.
			this.fire('locationfound', data);
		},

		// TODO Appropriate docs section?
		// @section Other Methods
		// @method addHandler(name: String, HandlerClass: Function): this
		// Adds a new `Handler` to the map, given its name and constructor function.
		addHandler: function (name, HandlerClass) {
			if (!HandlerClass) { return this; }

			var handler = this[name] = new HandlerClass(this);

			this._handlers.push(handler);

			if (this.options[name]) {
				handler.enable();
			}

			return this;
		},

		// @method remove(): this
		// Destroys the map and clears all related event listeners.
		remove: function () {

			this._initEvents(true);

			if (this._containerId !== this._container._leaflet_id) {
				throw new Error('Map container is being reused by another instance');
			}

			try {
				// throws error in IE6-8
				delete this._container._leaflet_id;
				delete this._containerId;
			} catch (e) {
				/*eslint-disable */
				this._container._leaflet_id = undefined;
				/* eslint-enable */
				this._containerId = undefined;
			}

			if (this._locationWatchId !== undefined) {
				this.stopLocate();
			}

			this._stop();

			remove(this._mapPane);

			if (this._clearControlPos) {
				this._clearControlPos();
			}
			if (this._resizeRequest) {
				cancelAnimFrame(this._resizeRequest);
				this._resizeRequest = null;
			}

			this._clearHandlers();

			if (this._loaded) {
				// @section Map state change events
				// @event unload: Event
				// Fired when the map is destroyed with [remove](#map-remove) method.
				this.fire('unload');
			}

			var i;
			for (i in this._layers) {
				this._layers[i].remove();
			}
			for (i in this._panes) {
				remove(this._panes[i]);
			}

			this._layers = [];
			this._panes = [];
			delete this._mapPane;
			delete this._renderer;

			return this;
		},

		// @section Other Methods
		// @method createPane(name: String, container?: HTMLElement): HTMLElement
		// Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,
		// then returns it. The pane is created as a child of `container`, or
		// as a child of the main map pane if not set.
		createPane: function (name, container) {
			var className = 'leaflet-pane' + (name ? ' leaflet-' + name.replace('Pane', '') + '-pane' : ''),
			    pane = create$1$1('div', className, container || this._mapPane);

			if (name) {
				this._panes[name] = pane;
			}
			return pane;
		},

		// @section Methods for Getting Map State

		// @method getCenter(): LatLng
		// Returns the geographical center of the map view
		getCenter: function () {
			this._checkIfLoaded();

			if (this._lastCenter && !this._moved()) {
				return this._lastCenter;
			}
			return this.layerPointToLatLng(this._getCenterLayerPoint());
		},

		// @method getZoom(): Number
		// Returns the current zoom level of the map view
		getZoom: function () {
			return this._zoom;
		},

		// @method getBounds(): LatLngBounds
		// Returns the geographical bounds visible in the current map view
		getBounds: function () {
			var bounds = this.getPixelBounds(),
			    sw = this.unproject(bounds.getBottomLeft()),
			    ne = this.unproject(bounds.getTopRight());

			return new LatLngBounds(sw, ne);
		},

		// @method getMinZoom(): Number
		// Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.
		getMinZoom: function () {
			return this.options.minZoom === undefined ? this._layersMinZoom || 0 : this.options.minZoom;
		},

		// @method getMaxZoom(): Number
		// Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).
		getMaxZoom: function () {
			return this.options.maxZoom === undefined ?
				(this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom) :
				this.options.maxZoom;
		},

		// @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean, padding?: Point): Number
		// Returns the maximum zoom level on which the given bounds fit to the map
		// view in its entirety. If `inside` (optional) is set to `true`, the method
		// instead returns the minimum zoom level on which the map view fits into
		// the given bounds in its entirety.
		getBoundsZoom: function (bounds, inside, padding) { // (LatLngBounds[, Boolean, Point]) -> Number
			bounds = toLatLngBounds(bounds);
			padding = toPoint(padding || [0, 0]);

			var zoom = this.getZoom() || 0,
			    min = this.getMinZoom(),
			    max = this.getMaxZoom(),
			    nw = bounds.getNorthWest(),
			    se = bounds.getSouthEast(),
			    size = this.getSize().subtract(padding),
			    boundsSize = toBounds(this.project(se, zoom), this.project(nw, zoom)).getSize(),
			    snap = any3d ? this.options.zoomSnap : 1,
			    scalex = size.x / boundsSize.x,
			    scaley = size.y / boundsSize.y,
			    scale = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);

			zoom = this.getScaleZoom(scale, zoom);

			if (snap) {
				zoom = Math.round(zoom / (snap / 100)) * (snap / 100); // don't jump if within 1% of a snap level
				zoom = inside ? Math.ceil(zoom / snap) * snap : Math.floor(zoom / snap) * snap;
			}

			return Math.max(min, Math.min(max, zoom));
		},

		// @method getSize(): Point
		// Returns the current size of the map container (in pixels).
		getSize: function () {
			if (!this._size || this._sizeChanged) {
				this._size = new Point$1(
					this._container.clientWidth || 0,
					this._container.clientHeight || 0);

				this._sizeChanged = false;
			}
			return this._size.clone();
		},

		// @method getPixelBounds(): Bounds
		// Returns the bounds of the current map view in projected pixel
		// coordinates (sometimes useful in layer and overlay implementations).
		getPixelBounds: function (center, zoom) {
			var topLeftPoint = this._getTopLeftPoint(center, zoom);
			return new Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
		},

		// TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to
		// the map pane? "left point of the map layer" can be confusing, specially
		// since there can be negative offsets.
		// @method getPixelOrigin(): Point
		// Returns the projected pixel coordinates of the top left point of
		// the map layer (useful in custom layer and overlay implementations).
		getPixelOrigin: function () {
			this._checkIfLoaded();
			return this._pixelOrigin;
		},

		// @method getPixelWorldBounds(zoom?: Number): Bounds
		// Returns the world's bounds in pixel coordinates for zoom level `zoom`.
		// If `zoom` is omitted, the map's current zoom level is used.
		getPixelWorldBounds: function (zoom) {
			return this.options.crs.getProjectedBounds(zoom === undefined ? this.getZoom() : zoom);
		},

		// @section Other Methods

		// @method getPane(pane: String|HTMLElement): HTMLElement
		// Returns a [map pane](#map-pane), given its name or its HTML element (its identity).
		getPane: function (pane) {
			return typeof pane === 'string' ? this._panes[pane] : pane;
		},

		// @method getPanes(): Object
		// Returns a plain object containing the names of all [panes](#map-pane) as keys and
		// the panes as values.
		getPanes: function () {
			return this._panes;
		},

		// @method getContainer: HTMLElement
		// Returns the HTML element that contains the map.
		getContainer: function () {
			return this._container;
		},


		// @section Conversion Methods

		// @method getZoomScale(toZoom: Number, fromZoom: Number): Number
		// Returns the scale factor to be applied to a map transition from zoom level
		// `fromZoom` to `toZoom`. Used internally to help with zoom animations.
		getZoomScale: function (toZoom, fromZoom) {
			// TODO replace with universal implementation after refactoring projections
			var crs = this.options.crs;
			fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
			return crs.scale(toZoom) / crs.scale(fromZoom);
		},

		// @method getScaleZoom(scale: Number, fromZoom: Number): Number
		// Returns the zoom level that the map would end up at, if it is at `fromZoom`
		// level and everything is scaled by a factor of `scale`. Inverse of
		// [`getZoomScale`](#map-getZoomScale).
		getScaleZoom: function (scale, fromZoom) {
			var crs = this.options.crs;
			fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
			var zoom = crs.zoom(scale * crs.scale(fromZoom));
			return isNaN(zoom) ? Infinity : zoom;
		},

		// @method project(latlng: LatLng, zoom: Number): Point
		// Projects a geographical coordinate `LatLng` according to the projection
		// of the map's CRS, then scales it according to `zoom` and the CRS's
		// `Transformation`. The result is pixel coordinate relative to
		// the CRS origin.
		project: function (latlng, zoom) {
			zoom = zoom === undefined ? this._zoom : zoom;
			return this.options.crs.latLngToPoint(toLatLng(latlng), zoom);
		},

		// @method unproject(point: Point, zoom: Number): LatLng
		// Inverse of [`project`](#map-project).
		unproject: function (point, zoom) {
			zoom = zoom === undefined ? this._zoom : zoom;
			return this.options.crs.pointToLatLng(toPoint(point), zoom);
		},

		// @method layerPointToLatLng(point: Point): LatLng
		// Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
		// returns the corresponding geographical coordinate (for the current zoom level).
		layerPointToLatLng: function (point) {
			var projectedPoint = toPoint(point).add(this.getPixelOrigin());
			return this.unproject(projectedPoint);
		},

		// @method latLngToLayerPoint(latlng: LatLng): Point
		// Given a geographical coordinate, returns the corresponding pixel coordinate
		// relative to the [origin pixel](#map-getpixelorigin).
		latLngToLayerPoint: function (latlng) {
			var projectedPoint = this.project(toLatLng(latlng))._round();
			return projectedPoint._subtract(this.getPixelOrigin());
		},

		// @method wrapLatLng(latlng: LatLng): LatLng
		// Returns a `LatLng` where `lat` and `lng` has been wrapped according to the
		// map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the
		// CRS's bounds.
		// By default this means longitude is wrapped around the dateline so its
		// value is between -180 and +180 degrees.
		wrapLatLng: function (latlng) {
			return this.options.crs.wrapLatLng(toLatLng(latlng));
		},

		// @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
		// Returns a `LatLngBounds` with the same size as the given one, ensuring that
		// its center is within the CRS's bounds.
		// By default this means the center longitude is wrapped around the dateline so its
		// value is between -180 and +180 degrees, and the majority of the bounds
		// overlaps the CRS's bounds.
		wrapLatLngBounds: function (latlng) {
			return this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));
		},

		// @method distance(latlng1: LatLng, latlng2: LatLng): Number
		// Returns the distance between two geographical coordinates according to
		// the map's CRS. By default this measures distance in meters.
		distance: function (latlng1, latlng2) {
			return this.options.crs.distance(toLatLng(latlng1), toLatLng(latlng2));
		},

		// @method containerPointToLayerPoint(point: Point): Point
		// Given a pixel coordinate relative to the map container, returns the corresponding
		// pixel coordinate relative to the [origin pixel](#map-getpixelorigin).
		containerPointToLayerPoint: function (point) { // (Point)
			return toPoint(point).subtract(this._getMapPanePos());
		},

		// @method layerPointToContainerPoint(point: Point): Point
		// Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
		// returns the corresponding pixel coordinate relative to the map container.
		layerPointToContainerPoint: function (point) { // (Point)
			return toPoint(point).add(this._getMapPanePos());
		},

		// @method containerPointToLatLng(point: Point): LatLng
		// Given a pixel coordinate relative to the map container, returns
		// the corresponding geographical coordinate (for the current zoom level).
		containerPointToLatLng: function (point) {
			var layerPoint = this.containerPointToLayerPoint(toPoint(point));
			return this.layerPointToLatLng(layerPoint);
		},

		// @method latLngToContainerPoint(latlng: LatLng): Point
		// Given a geographical coordinate, returns the corresponding pixel coordinate
		// relative to the map container.
		latLngToContainerPoint: function (latlng) {
			return this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));
		},

		// @method mouseEventToContainerPoint(ev: MouseEvent): Point
		// Given a MouseEvent object, returns the pixel coordinate relative to the
		// map container where the event took place.
		mouseEventToContainerPoint: function (e) {
			return getMousePosition(e, this._container);
		},

		// @method mouseEventToLayerPoint(ev: MouseEvent): Point
		// Given a MouseEvent object, returns the pixel coordinate relative to
		// the [origin pixel](#map-getpixelorigin) where the event took place.
		mouseEventToLayerPoint: function (e) {
			return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
		},

		// @method mouseEventToLatLng(ev: MouseEvent): LatLng
		// Given a MouseEvent object, returns geographical coordinate where the
		// event took place.
		mouseEventToLatLng: function (e) { // (MouseEvent)
			return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
		},


		// map initialization methods

		_initContainer: function (id) {
			var container = this._container = get$1(id);

			if (!container) {
				throw new Error('Map container not found.');
			} else if (container._leaflet_id) {
				throw new Error('Map container is already initialized.');
			}

			on(container, 'scroll', this._onScroll, this);
			this._containerId = stamp(container);
		},

		_initLayout: function () {
			var container = this._container;

			this._fadeAnimated = this.options.fadeAnimation && any3d;

			addClass(container, 'leaflet-container' +
				(touch ? ' leaflet-touch' : '') +
				(retina ? ' leaflet-retina' : '') +
				(ielt9 ? ' leaflet-oldie' : '') +
				(safari ? ' leaflet-safari' : '') +
				(this._fadeAnimated ? ' leaflet-fade-anim' : ''));

			var position = getStyle(container, 'position');

			if (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {
				container.style.position = 'relative';
			}

			this._initPanes();

			if (this._initControlPos) {
				this._initControlPos();
			}
		},

		_initPanes: function () {
			var panes = this._panes = {};
			this._paneRenderers = {};

			// @section
			//
			// Panes are DOM elements used to control the ordering of layers on the map. You
			// can access panes with [`map.getPane`](#map-getpane) or
			// [`map.getPanes`](#map-getpanes) methods. New panes can be created with the
			// [`map.createPane`](#map-createpane) method.
			//
			// Every map has the following default panes that differ only in zIndex.
			//
			// @pane mapPane: HTMLElement = 'auto'
			// Pane that contains all other map panes

			this._mapPane = this.createPane('mapPane', this._container);
			setPosition(this._mapPane, new Point$1(0, 0));

			// @pane tilePane: HTMLElement = 200
			// Pane for `GridLayer`s and `TileLayer`s
			this.createPane('tilePane');
			// @pane overlayPane: HTMLElement = 400
			// Pane for vectors (`Path`s, like `Polyline`s and `Polygon`s), `ImageOverlay`s and `VideoOverlay`s
			this.createPane('shadowPane');
			// @pane shadowPane: HTMLElement = 500
			// Pane for overlay shadows (e.g. `Marker` shadows)
			this.createPane('overlayPane');
			// @pane markerPane: HTMLElement = 600
			// Pane for `Icon`s of `Marker`s
			this.createPane('markerPane');
			// @pane tooltipPane: HTMLElement = 650
			// Pane for `Tooltip`s.
			this.createPane('tooltipPane');
			// @pane popupPane: HTMLElement = 700
			// Pane for `Popup`s.
			this.createPane('popupPane');

			if (!this.options.markerZoomAnimation) {
				addClass(panes.markerPane, 'leaflet-zoom-hide');
				addClass(panes.shadowPane, 'leaflet-zoom-hide');
			}
		},


		// private methods that modify map state

		// @section Map state change events
		_resetView: function (center, zoom) {
			setPosition(this._mapPane, new Point$1(0, 0));

			var loading = !this._loaded;
			this._loaded = true;
			zoom = this._limitZoom(zoom);

			this.fire('viewprereset');

			var zoomChanged = this._zoom !== zoom;
			this
				._moveStart(zoomChanged, false)
				._move(center, zoom)
				._moveEnd(zoomChanged);

			// @event viewreset: Event
			// Fired when the map needs to redraw its content (this usually happens
			// on map zoom or load). Very useful for creating custom overlays.
			this.fire('viewreset');

			// @event load: Event
			// Fired when the map is initialized (when its center and zoom are set
			// for the first time).
			if (loading) {
				this.fire('load');
			}
		},

		_moveStart: function (zoomChanged, noMoveStart) {
			// @event zoomstart: Event
			// Fired when the map zoom is about to change (e.g. before zoom animation).
			// @event movestart: Event
			// Fired when the view of the map starts changing (e.g. user starts dragging the map).
			if (zoomChanged) {
				this.fire('zoomstart');
			}
			if (!noMoveStart) {
				this.fire('movestart');
			}
			return this;
		},

		_move: function (center, zoom, data) {
			if (zoom === undefined) {
				zoom = this._zoom;
			}
			var zoomChanged = this._zoom !== zoom;

			this._zoom = zoom;
			this._lastCenter = center;
			this._pixelOrigin = this._getNewPixelOrigin(center);

			// @event zoom: Event
			// Fired repeatedly during any change in zoom level, including zoom
			// and fly animations.
			if (zoomChanged || (data && data.pinch)) {	// Always fire 'zoom' if pinching because #3530
				this.fire('zoom', data);
			}

			// @event move: Event
			// Fired repeatedly during any movement of the map, including pan and
			// fly animations.
			return this.fire('move', data);
		},

		_moveEnd: function (zoomChanged) {
			// @event zoomend: Event
			// Fired when the map has changed, after any animations.
			if (zoomChanged) {
				this.fire('zoomend');
			}

			// @event moveend: Event
			// Fired when the center of the map stops changing (e.g. user stopped
			// dragging the map).
			return this.fire('moveend');
		},

		_stop: function () {
			cancelAnimFrame(this._flyToFrame);
			if (this._panAnim) {
				this._panAnim.stop();
			}
			return this;
		},

		_rawPanBy: function (offset) {
			setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
		},

		_getZoomSpan: function () {
			return this.getMaxZoom() - this.getMinZoom();
		},

		_panInsideMaxBounds: function () {
			if (!this._enforcingBounds) {
				this.panInsideBounds(this.options.maxBounds);
			}
		},

		_checkIfLoaded: function () {
			if (!this._loaded) {
				throw new Error('Set map center and zoom first.');
			}
		},

		// DOM event handling

		// @section Interaction events
		_initEvents: function (remove$$1) {
			this._targets = {};
			this._targets[stamp(this._container)] = this;

			var onOff = remove$$1 ? off : on;

			// @event click: MouseEvent
			// Fired when the user clicks (or taps) the map.
			// @event dblclick: MouseEvent
			// Fired when the user double-clicks (or double-taps) the map.
			// @event mousedown: MouseEvent
			// Fired when the user pushes the mouse button on the map.
			// @event mouseup: MouseEvent
			// Fired when the user releases the mouse button on the map.
			// @event mouseover: MouseEvent
			// Fired when the mouse enters the map.
			// @event mouseout: MouseEvent
			// Fired when the mouse leaves the map.
			// @event mousemove: MouseEvent
			// Fired while the mouse moves over the map.
			// @event contextmenu: MouseEvent
			// Fired when the user pushes the right mouse button on the map, prevents
			// default browser context menu from showing if there are listeners on
			// this event. Also fired on mobile when the user holds a single touch
			// for a second (also called long press).
			// @event keypress: KeyboardEvent
			// Fired when the user presses a key from the keyboard that produces a character value while the map is focused.
			// @event keydown: KeyboardEvent
			// Fired when the user presses a key from the keyboard while the map is focused. Unlike the `keypress` event,
			// the `keydown` event is fired for keys that produce a character value and for keys
			// that do not produce a character value.
			// @event keyup: KeyboardEvent
			// Fired when the user releases a key from the keyboard while the map is focused.
			onOff(this._container, 'click dblclick mousedown mouseup ' +
				'mouseover mouseout mousemove contextmenu keypress keydown keyup', this._handleDOMEvent, this);

			if (this.options.trackResize) {
				onOff(window, 'resize', this._onResize, this);
			}

			if (any3d && this.options.transform3DLimit) {
				(remove$$1 ? this.off : this.on).call(this, 'moveend', this._onMoveEnd);
			}
		},

		_onResize: function () {
			cancelAnimFrame(this._resizeRequest);
			this._resizeRequest = requestAnimFrame(
			        function () { this.invalidateSize({debounceMoveend: true}); }, this);
		},

		_onScroll: function () {
			this._container.scrollTop  = 0;
			this._container.scrollLeft = 0;
		},

		_onMoveEnd: function () {
			var pos = this._getMapPanePos();
			if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {
				// https://bugzilla.mozilla.org/show_bug.cgi?id=1203873 but Webkit also have
				// a pixel offset on very high values, see: http://jsfiddle.net/dg6r5hhb/
				this._resetView(this.getCenter(), this.getZoom());
			}
		},

		_findEventTargets: function (e, type) {
			var targets = [],
			    target,
			    isHover = type === 'mouseout' || type === 'mouseover',
			    src = e.target || e.srcElement,
			    dragging = false;

			while (src) {
				target = this._targets[stamp(src)];
				if (target && (type === 'click' || type === 'preclick') && !e._simulated && this._draggableMoved(target)) {
					// Prevent firing click after you just dragged an object.
					dragging = true;
					break;
				}
				if (target && target.listens(type, true)) {
					if (isHover && !isExternalTarget(src, e)) { break; }
					targets.push(target);
					if (isHover) { break; }
				}
				if (src === this._container) { break; }
				src = src.parentNode;
			}
			if (!targets.length && !dragging && !isHover && isExternalTarget(src, e)) {
				targets = [this];
			}
			return targets;
		},

		_handleDOMEvent: function (e) {
			if (!this._loaded || skipped(e)) { return; }

			var type = e.type;

			if (type === 'mousedown' || type === 'keypress' || type === 'keyup' || type === 'keydown') {
				// prevents outline when clicking on keyboard-focusable element
				preventOutline(e.target || e.srcElement);
			}

			this._fireDOMEvent(e, type);
		},

		_mouseEvents: ['click', 'dblclick', 'mouseover', 'mouseout', 'contextmenu'],

		_fireDOMEvent: function (e, type, targets) {

			if (e.type === 'click') {
				// Fire a synthetic 'preclick' event which propagates up (mainly for closing popups).
				// @event preclick: MouseEvent
				// Fired before mouse click on the map (sometimes useful when you
				// want something to happen on click before any existing click
				// handlers start running).
				var synth = extend$1({}, e);
				synth.type = 'preclick';
				this._fireDOMEvent(synth, synth.type, targets);
			}

			if (e._stopped) { return; }

			// Find the layer the event is propagating from and its parents.
			targets = (targets || []).concat(this._findEventTargets(e, type));

			if (!targets.length) { return; }

			var target = targets[0];
			if (type === 'contextmenu' && target.listens(type, true)) {
				preventDefault(e);
			}

			var data = {
				originalEvent: e
			};

			if (e.type !== 'keypress' && e.type !== 'keydown' && e.type !== 'keyup') {
				var isMarker = target.getLatLng && (!target._radius || target._radius <= 10);
				data.containerPoint = isMarker ?
					this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);
				data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);
				data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);
			}

			for (var i = 0; i < targets.length; i++) {
				targets[i].fire(type, data, true);
				if (data.originalEvent._stopped ||
					(targets[i].options.bubblingMouseEvents === false && indexOf(this._mouseEvents, type) !== -1)) { return; }
			}
		},

		_draggableMoved: function (obj) {
			obj = obj.dragging && obj.dragging.enabled() ? obj : this;
			return (obj.dragging && obj.dragging.moved()) || (this.boxZoom && this.boxZoom.moved());
		},

		_clearHandlers: function () {
			for (var i = 0, len = this._handlers.length; i < len; i++) {
				this._handlers[i].disable();
			}
		},

		// @section Other Methods

		// @method whenReady(fn: Function, context?: Object): this
		// Runs the given function `fn` when the map gets initialized with
		// a view (center and zoom) and at least one layer, or immediately
		// if it's already initialized, optionally passing a function context.
		whenReady: function (callback, context) {
			if (this._loaded) {
				callback.call(context || this, {target: this});
			} else {
				this.on('load', callback, context);
			}
			return this;
		},


		// private methods for getting map state

		_getMapPanePos: function () {
			return getPosition$1(this._mapPane) || new Point$1(0, 0);
		},

		_moved: function () {
			var pos = this._getMapPanePos();
			return pos && !pos.equals([0, 0]);
		},

		_getTopLeftPoint: function (center, zoom) {
			var pixelOrigin = center && zoom !== undefined ?
				this._getNewPixelOrigin(center, zoom) :
				this.getPixelOrigin();
			return pixelOrigin.subtract(this._getMapPanePos());
		},

		_getNewPixelOrigin: function (center, zoom) {
			var viewHalf = this.getSize()._divideBy(2);
			return this.project(center, zoom)._subtract(viewHalf)._add(this._getMapPanePos())._round();
		},

		_latLngToNewLayerPoint: function (latlng, zoom, center) {
			var topLeft = this._getNewPixelOrigin(center, zoom);
			return this.project(latlng, zoom)._subtract(topLeft);
		},

		_latLngBoundsToNewLayerBounds: function (latLngBounds, zoom, center) {
			var topLeft = this._getNewPixelOrigin(center, zoom);
			return toBounds([
				this.project(latLngBounds.getSouthWest(), zoom)._subtract(topLeft),
				this.project(latLngBounds.getNorthWest(), zoom)._subtract(topLeft),
				this.project(latLngBounds.getSouthEast(), zoom)._subtract(topLeft),
				this.project(latLngBounds.getNorthEast(), zoom)._subtract(topLeft)
			]);
		},

		// layer point of the current center
		_getCenterLayerPoint: function () {
			return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
		},

		// offset of the specified place to the current center in pixels
		_getCenterOffset: function (latlng) {
			return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
		},

		// adjust center for view to get inside bounds
		_limitCenter: function (center, zoom, bounds) {

			if (!bounds) { return center; }

			var centerPoint = this.project(center, zoom),
			    viewHalf = this.getSize().divideBy(2),
			    viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),
			    offset = this._getBoundsOffset(viewBounds, bounds, zoom);

			// If offset is less than a pixel, ignore.
			// This prevents unstable projections from getting into
			// an infinite loop of tiny offsets.
			if (offset.round().equals([0, 0])) {
				return center;
			}

			return this.unproject(centerPoint.add(offset), zoom);
		},

		// adjust offset for view to get inside bounds
		_limitOffset: function (offset, bounds) {
			if (!bounds) { return offset; }

			var viewBounds = this.getPixelBounds(),
			    newBounds = new Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));

			return offset.add(this._getBoundsOffset(newBounds, bounds));
		},

		// returns offset needed for pxBounds to get inside maxBounds at a specified zoom
		_getBoundsOffset: function (pxBounds, maxBounds, zoom) {
			var projectedMaxBounds = toBounds(
			        this.project(maxBounds.getNorthEast(), zoom),
			        this.project(maxBounds.getSouthWest(), zoom)
			    ),
			    minOffset = projectedMaxBounds.min.subtract(pxBounds.min),
			    maxOffset = projectedMaxBounds.max.subtract(pxBounds.max),

			    dx = this._rebound(minOffset.x, -maxOffset.x),
			    dy = this._rebound(minOffset.y, -maxOffset.y);

			return new Point$1(dx, dy);
		},

		_rebound: function (left, right) {
			return left + right > 0 ?
				Math.round(left - right) / 2 :
				Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
		},

		_limitZoom: function (zoom) {
			var min = this.getMinZoom(),
			    max = this.getMaxZoom(),
			    snap = any3d ? this.options.zoomSnap : 1;
			if (snap) {
				zoom = Math.round(zoom / snap) * snap;
			}
			return Math.max(min, Math.min(max, zoom));
		},

		_onPanTransitionStep: function () {
			this.fire('move');
		},

		_onPanTransitionEnd: function () {
			removeClass(this._mapPane, 'leaflet-pan-anim');
			this.fire('moveend');
		},

		_tryAnimatedPan: function (center, options) {
			// difference between the new and current centers in pixels
			var offset = this._getCenterOffset(center)._trunc();

			// don't animate too far unless animate: true specified in options
			if ((options && options.animate) !== true && !this.getSize().contains(offset)) { return false; }

			this.panBy(offset, options);

			return true;
		},

		_createAnimProxy: function () {

			var proxy = this._proxy = create$1$1('div', 'leaflet-proxy leaflet-zoom-animated');
			this._panes.mapPane.appendChild(proxy);

			this.on('zoomanim', function (e) {
				var prop = TRANSFORM,
				    transform = this._proxy.style[prop];

				setTransform(this._proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1));

				// workaround for case when transform is the same and so transitionend event is not fired
				if (transform === this._proxy.style[prop] && this._animatingZoom) {
					this._onZoomTransitionEnd();
				}
			}, this);

			this.on('load moveend', this._animMoveEnd, this);

			this._on('unload', this._destroyAnimProxy, this);
		},

		_destroyAnimProxy: function () {
			remove(this._proxy);
			this.off('load moveend', this._animMoveEnd, this);
			delete this._proxy;
		},

		_animMoveEnd: function () {
			var c = this.getCenter(),
			    z = this.getZoom();
			setTransform(this._proxy, this.project(c, z), this.getZoomScale(z, 1));
		},

		_catchTransitionEnd: function (e) {
			if (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {
				this._onZoomTransitionEnd();
			}
		},

		_nothingToAnimate: function () {
			return !this._container.getElementsByClassName('leaflet-zoom-animated').length;
		},

		_tryAnimatedZoom: function (center, zoom, options) {

			if (this._animatingZoom) { return true; }

			options = options || {};

			// don't animate if disabled, not supported or zoom difference is too large
			if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() ||
			        Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) { return false; }

			// offset is the pixel coords of the zoom origin relative to the current center
			var scale = this.getZoomScale(zoom),
			    offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale);

			// don't animate if the zoom origin isn't within one screen from the current center, unless forced
			if (options.animate !== true && !this.getSize().contains(offset)) { return false; }

			requestAnimFrame(function () {
				this
				    ._moveStart(true, false)
				    ._animateZoom(center, zoom, true);
			}, this);

			return true;
		},

		_animateZoom: function (center, zoom, startAnim, noUpdate) {
			if (!this._mapPane) { return; }

			if (startAnim) {
				this._animatingZoom = true;

				// remember what center/zoom to set after animation
				this._animateToCenter = center;
				this._animateToZoom = zoom;

				addClass(this._mapPane, 'leaflet-zoom-anim');
			}

			// @section Other Events
			// @event zoomanim: ZoomAnimEvent
			// Fired at least once per zoom animation. For continuous zoom, like pinch zooming, fired once per frame during zoom.
			this.fire('zoomanim', {
				center: center,
				zoom: zoom,
				noUpdate: noUpdate
			});

			// Work around webkit not firing 'transitionend', see https://github.com/Leaflet/Leaflet/issues/3689, 2693
			setTimeout(bind(this._onZoomTransitionEnd, this), 250);
		},

		_onZoomTransitionEnd: function () {
			if (!this._animatingZoom) { return; }

			if (this._mapPane) {
				removeClass(this._mapPane, 'leaflet-zoom-anim');
			}

			this._animatingZoom = false;

			this._move(this._animateToCenter, this._animateToZoom);

			// This anim frame should prevent an obscure iOS webkit tile loading race condition.
			requestAnimFrame(function () {
				this._moveEnd(true);
			}, this);
		}
	});

	/*
	 * @class Control
	 * @aka L.Control
	 * @inherits Class
	 *
	 * L.Control is a base class for implementing map controls. Handles positioning.
	 * All other controls extend from this class.
	 */

	var Control = Class.extend({
		// @section
		// @aka Control options
		options: {
			// @option position: String = 'topright'
			// The position of the control (one of the map corners). Possible values are `'topleft'`,
			// `'topright'`, `'bottomleft'` or `'bottomright'`
			position: 'topright'
		},

		initialize: function (options) {
			setOptions(this, options);
		},

		/* @section
		 * Classes extending L.Control will inherit the following methods:
		 *
		 * @method getPosition: string
		 * Returns the position of the control.
		 */
		getPosition: function () {
			return this.options.position;
		},

		// @method setPosition(position: string): this
		// Sets the position of the control.
		setPosition: function (position) {
			var map = this._map;

			if (map) {
				map.removeControl(this);
			}

			this.options.position = position;

			if (map) {
				map.addControl(this);
			}

			return this;
		},

		// @method getContainer: HTMLElement
		// Returns the HTMLElement that contains the control.
		getContainer: function () {
			return this._container;
		},

		// @method addTo(map: Map): this
		// Adds the control to the given map.
		addTo: function (map) {
			this.remove();
			this._map = map;

			var container = this._container = this.onAdd(map),
			    pos = this.getPosition(),
			    corner = map._controlCorners[pos];

			addClass(container, 'leaflet-control');

			if (pos.indexOf('bottom') !== -1) {
				corner.insertBefore(container, corner.firstChild);
			} else {
				corner.appendChild(container);
			}

			this._map.on('unload', this.remove, this);

			return this;
		},

		// @method remove: this
		// Removes the control from the map it is currently active on.
		remove: function () {
			if (!this._map) {
				return this;
			}

			remove(this._container);

			if (this.onRemove) {
				this.onRemove(this._map);
			}

			this._map.off('unload', this.remove, this);
			this._map = null;

			return this;
		},

		_refocusOnMap: function (e) {
			// if map exists and event is not a keyboard event
			if (this._map && e && e.screenX > 0 && e.screenY > 0) {
				this._map.getContainer().focus();
			}
		}
	});

	/* @section Extension methods
	 * @uninheritable
	 *
	 * Every control should extend from `L.Control` and (re-)implement the following methods.
	 *
	 * @method onAdd(map: Map): HTMLElement
	 * Should return the container DOM element for the control and add listeners on relevant map events. Called on [`control.addTo(map)`](#control-addTo).
	 *
	 * @method onRemove(map: Map)
	 * Optional method. Should contain all clean up code that removes the listeners previously added in [`onAdd`](#control-onadd). Called on [`control.remove()`](#control-remove).
	 */

	/* @namespace Map
	 * @section Methods for Layers and Controls
	 */
	Map$1.include({
		// @method addControl(control: Control): this
		// Adds the given control to the map
		addControl: function (control) {
			control.addTo(this);
			return this;
		},

		// @method removeControl(control: Control): this
		// Removes the given control from the map
		removeControl: function (control) {
			control.remove();
			return this;
		},

		_initControlPos: function () {
			var corners = this._controlCorners = {},
			    l = 'leaflet-',
			    container = this._controlContainer =
			            create$1$1('div', l + 'control-container', this._container);

			function createCorner(vSide, hSide) {
				var className = l + vSide + ' ' + l + hSide;

				corners[vSide + hSide] = create$1$1('div', className, container);
			}

			createCorner('top', 'left');
			createCorner('top', 'right');
			createCorner('bottom', 'left');
			createCorner('bottom', 'right');
		},

		_clearControlPos: function () {
			for (var i in this._controlCorners) {
				remove(this._controlCorners[i]);
			}
			remove(this._controlContainer);
			delete this._controlCorners;
			delete this._controlContainer;
		}
	});

	/*
	 * @class Control.Layers
	 * @aka L.Control.Layers
	 * @inherits Control
	 *
	 * The layers control gives users the ability to switch between different base layers and switch overlays on/off (check out the [detailed example](http://leafletjs.com/examples/layers-control/)). Extends `Control`.
	 *
	 * @example
	 *
	 * ```js
	 * var baseLayers = {
	 * 	"Mapbox": mapbox,
	 * 	"OpenStreetMap": osm
	 * };
	 *
	 * var overlays = {
	 * 	"Marker": marker,
	 * 	"Roads": roadsLayer
	 * };
	 *
	 * L.control.layers(baseLayers, overlays).addTo(map);
	 * ```
	 *
	 * The `baseLayers` and `overlays` parameters are object literals with layer names as keys and `Layer` objects as values:
	 *
	 * ```js
	 * {
	 *     "<someName1>": layer1,
	 *     "<someName2>": layer2
	 * }
	 * ```
	 *
	 * The layer names can contain HTML, which allows you to add additional styling to the items:
	 *
	 * ```js
	 * {"<img src='my-layer-icon' /> <span class='my-layer-item'>My Layer</span>": myLayer}
	 * ```
	 */

	var Layers = Control.extend({
		// @section
		// @aka Control.Layers options
		options: {
			// @option collapsed: Boolean = true
			// If `true`, the control will be collapsed into an icon and expanded on mouse hover or touch.
			collapsed: true,
			position: 'topright',

			// @option autoZIndex: Boolean = true
			// If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.
			autoZIndex: true,

			// @option hideSingleBase: Boolean = false
			// If `true`, the base layers in the control will be hidden when there is only one.
			hideSingleBase: false,

			// @option sortLayers: Boolean = false
			// Whether to sort the layers. When `false`, layers will keep the order
			// in which they were added to the control.
			sortLayers: false,

			// @option sortFunction: Function = *
			// A [compare function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
			// that will be used for sorting the layers, when `sortLayers` is `true`.
			// The function receives both the `L.Layer` instances and their names, as in
			// `sortFunction(layerA, layerB, nameA, nameB)`.
			// By default, it sorts layers alphabetically by their name.
			sortFunction: function (layerA, layerB, nameA, nameB) {
				return nameA < nameB ? -1 : (nameB < nameA ? 1 : 0);
			}
		},

		initialize: function (baseLayers, overlays, options) {
			setOptions(this, options);

			this._layerControlInputs = [];
			this._layers = [];
			this._lastZIndex = 0;
			this._handlingClick = false;

			for (var i in baseLayers) {
				this._addLayer(baseLayers[i], i);
			}

			for (i in overlays) {
				this._addLayer(overlays[i], i, true);
			}
		},

		onAdd: function (map) {
			this._initLayout();
			this._update();

			this._map = map;
			map.on('zoomend', this._checkDisabledLayers, this);

			for (var i = 0; i < this._layers.length; i++) {
				this._layers[i].layer.on('add remove', this._onLayerChange, this);
			}

			return this._container;
		},

		addTo: function (map) {
			Control.prototype.addTo.call(this, map);
			// Trigger expand after Layers Control has been inserted into DOM so that is now has an actual height.
			return this._expandIfNotCollapsed();
		},

		onRemove: function () {
			this._map.off('zoomend', this._checkDisabledLayers, this);

			for (var i = 0; i < this._layers.length; i++) {
				this._layers[i].layer.off('add remove', this._onLayerChange, this);
			}
		},

		// @method addBaseLayer(layer: Layer, name: String): this
		// Adds a base layer (radio button entry) with the given name to the control.
		addBaseLayer: function (layer, name) {
			this._addLayer(layer, name);
			return (this._map) ? this._update() : this;
		},

		// @method addOverlay(layer: Layer, name: String): this
		// Adds an overlay (checkbox entry) with the given name to the control.
		addOverlay: function (layer, name) {
			this._addLayer(layer, name, true);
			return (this._map) ? this._update() : this;
		},

		// @method removeLayer(layer: Layer): this
		// Remove the given layer from the control.
		removeLayer: function (layer) {
			layer.off('add remove', this._onLayerChange, this);

			var obj = this._getLayer(stamp(layer));
			if (obj) {
				this._layers.splice(this._layers.indexOf(obj), 1);
			}
			return (this._map) ? this._update() : this;
		},

		// @method expand(): this
		// Expand the control container if collapsed.
		expand: function () {
			addClass(this._container, 'leaflet-control-layers-expanded');
			this._section.style.height = null;
			var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);
			if (acceptableHeight < this._section.clientHeight) {
				addClass(this._section, 'leaflet-control-layers-scrollbar');
				this._section.style.height = acceptableHeight + 'px';
			} else {
				removeClass(this._section, 'leaflet-control-layers-scrollbar');
			}
			this._checkDisabledLayers();
			return this;
		},

		// @method collapse(): this
		// Collapse the control container if expanded.
		collapse: function () {
			removeClass(this._container, 'leaflet-control-layers-expanded');
			return this;
		},

		_initLayout: function () {
			var className = 'leaflet-control-layers',
			    container = this._container = create$1$1('div', className),
			    collapsed = this.options.collapsed;

			// makes this work on IE touch devices by stopping it from firing a mouseout event when the touch is released
			container.setAttribute('aria-haspopup', true);

			disableClickPropagation(container);
			disableScrollPropagation(container);

			var section = this._section = create$1$1('section', className + '-list');

			if (collapsed) {
				this._map.on('click', this.collapse, this);

				if (!android) {
					on(container, {
						mouseenter: this.expand,
						mouseleave: this.collapse
					}, this);
				}
			}

			var link = this._layersLink = create$1$1('a', className + '-toggle', container);
			link.href = '#';
			link.title = 'Layers';

			if (touch) {
				on(link, 'click', stop);
				on(link, 'click', this.expand, this);
			} else {
				on(link, 'focus', this.expand, this);
			}

			if (!collapsed) {
				this.expand();
			}

			this._baseLayersList = create$1$1('div', className + '-base', section);
			this._separator = create$1$1('div', className + '-separator', section);
			this._overlaysList = create$1$1('div', className + '-overlays', section);

			container.appendChild(section);
		},

		_getLayer: function (id) {
			for (var i = 0; i < this._layers.length; i++) {

				if (this._layers[i] && stamp(this._layers[i].layer) === id) {
					return this._layers[i];
				}
			}
		},

		_addLayer: function (layer, name, overlay) {
			if (this._map) {
				layer.on('add remove', this._onLayerChange, this);
			}

			this._layers.push({
				layer: layer,
				name: name,
				overlay: overlay
			});

			if (this.options.sortLayers) {
				this._layers.sort(bind(function (a, b) {
					return this.options.sortFunction(a.layer, b.layer, a.name, b.name);
				}, this));
			}

			if (this.options.autoZIndex && layer.setZIndex) {
				this._lastZIndex++;
				layer.setZIndex(this._lastZIndex);
			}

			this._expandIfNotCollapsed();
		},

		_update: function () {
			if (!this._container) { return this; }

			empty$1(this._baseLayersList);
			empty$1(this._overlaysList);

			this._layerControlInputs = [];
			var baseLayersPresent, overlaysPresent, i, obj, baseLayersCount = 0;

			for (i = 0; i < this._layers.length; i++) {
				obj = this._layers[i];
				this._addItem(obj);
				overlaysPresent = overlaysPresent || obj.overlay;
				baseLayersPresent = baseLayersPresent || !obj.overlay;
				baseLayersCount += !obj.overlay ? 1 : 0;
			}

			// Hide base layers section if there's only one layer.
			if (this.options.hideSingleBase) {
				baseLayersPresent = baseLayersPresent && baseLayersCount > 1;
				this._baseLayersList.style.display = baseLayersPresent ? '' : 'none';
			}

			this._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';

			return this;
		},

		_onLayerChange: function (e) {
			if (!this._handlingClick) {
				this._update();
			}

			var obj = this._getLayer(stamp(e.target));

			// @namespace Map
			// @section Layer events
			// @event baselayerchange: LayersControlEvent
			// Fired when the base layer is changed through the [layer control](#control-layers).
			// @event overlayadd: LayersControlEvent
			// Fired when an overlay is selected through the [layer control](#control-layers).
			// @event overlayremove: LayersControlEvent
			// Fired when an overlay is deselected through the [layer control](#control-layers).
			// @namespace Control.Layers
			var type = obj.overlay ?
				(e.type === 'add' ? 'overlayadd' : 'overlayremove') :
				(e.type === 'add' ? 'baselayerchange' : null);

			if (type) {
				this._map.fire(type, obj);
			}
		},

		// IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see http://bit.ly/PqYLBe)
		_createRadioElement: function (name, checked) {

			var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' +
					name + '"' + (checked ? ' checked="checked"' : '') + '/>';

			var radioFragment = document.createElement('div');
			radioFragment.innerHTML = radioHtml;

			return radioFragment.firstChild;
		},

		_addItem: function (obj) {
			var label = document.createElement('label'),
			    checked = this._map.hasLayer(obj.layer),
			    input;

			if (obj.overlay) {
				input = document.createElement('input');
				input.type = 'checkbox';
				input.className = 'leaflet-control-layers-selector';
				input.defaultChecked = checked;
			} else {
				input = this._createRadioElement('leaflet-base-layers_' + stamp(this), checked);
			}

			this._layerControlInputs.push(input);
			input.layerId = stamp(obj.layer);

			on(input, 'click', this._onInputClick, this);

			var name = document.createElement('span');
			name.innerHTML = ' ' + obj.name;

			// Helps from preventing layer control flicker when checkboxes are disabled
			// https://github.com/Leaflet/Leaflet/issues/2771
			var holder = document.createElement('div');

			label.appendChild(holder);
			holder.appendChild(input);
			holder.appendChild(name);

			var container = obj.overlay ? this._overlaysList : this._baseLayersList;
			container.appendChild(label);

			this._checkDisabledLayers();
			return label;
		},

		_onInputClick: function () {
			var inputs = this._layerControlInputs,
			    input, layer;
			var addedLayers = [],
			    removedLayers = [];

			this._handlingClick = true;

			for (var i = inputs.length - 1; i >= 0; i--) {
				input = inputs[i];
				layer = this._getLayer(input.layerId).layer;

				if (input.checked) {
					addedLayers.push(layer);
				} else if (!input.checked) {
					removedLayers.push(layer);
				}
			}

			// Bugfix issue 2318: Should remove all old layers before readding new ones
			for (i = 0; i < removedLayers.length; i++) {
				if (this._map.hasLayer(removedLayers[i])) {
					this._map.removeLayer(removedLayers[i]);
				}
			}
			for (i = 0; i < addedLayers.length; i++) {
				if (!this._map.hasLayer(addedLayers[i])) {
					this._map.addLayer(addedLayers[i]);
				}
			}

			this._handlingClick = false;

			this._refocusOnMap();
		},

		_checkDisabledLayers: function () {
			var inputs = this._layerControlInputs,
			    input,
			    layer,
			    zoom = this._map.getZoom();

			for (var i = inputs.length - 1; i >= 0; i--) {
				input = inputs[i];
				layer = this._getLayer(input.layerId).layer;
				input.disabled = (layer.options.minZoom !== undefined && zoom < layer.options.minZoom) ||
				                 (layer.options.maxZoom !== undefined && zoom > layer.options.maxZoom);

			}
		},

		_expandIfNotCollapsed: function () {
			if (this._map && !this.options.collapsed) {
				this.expand();
			}
			return this;
		},

		_expand: function () {
			// Backward compatibility, remove me in 1.1.
			return this.expand();
		},

		_collapse: function () {
			// Backward compatibility, remove me in 1.1.
			return this.collapse();
		}

	});

	/*
	 * @class Control.Zoom
	 * @aka L.Control.Zoom
	 * @inherits Control
	 *
	 * A basic zoom control with two buttons (zoom in and zoom out). It is put on the map by default unless you set its [`zoomControl` option](#map-zoomcontrol) to `false`. Extends `Control`.
	 */

	var Zoom = Control.extend({
		// @section
		// @aka Control.Zoom options
		options: {
			position: 'topleft',

			// @option zoomInText: String = '+'
			// The text set on the 'zoom in' button.
			zoomInText: '+',

			// @option zoomInTitle: String = 'Zoom in'
			// The title set on the 'zoom in' button.
			zoomInTitle: 'Zoom in',

			// @option zoomOutText: String = '&#x2212;'
			// The text set on the 'zoom out' button.
			zoomOutText: '&#x2212;',

			// @option zoomOutTitle: String = 'Zoom out'
			// The title set on the 'zoom out' button.
			zoomOutTitle: 'Zoom out'
		},

		onAdd: function (map) {
			var zoomName = 'leaflet-control-zoom',
			    container = create$1$1('div', zoomName + ' leaflet-bar'),
			    options = this.options;

			this._zoomInButton  = this._createButton(options.zoomInText, options.zoomInTitle,
			        zoomName + '-in',  container, this._zoomIn);
			this._zoomOutButton = this._createButton(options.zoomOutText, options.zoomOutTitle,
			        zoomName + '-out', container, this._zoomOut);

			this._updateDisabled();
			map.on('zoomend zoomlevelschange', this._updateDisabled, this);

			return container;
		},

		onRemove: function (map) {
			map.off('zoomend zoomlevelschange', this._updateDisabled, this);
		},

		disable: function () {
			this._disabled = true;
			this._updateDisabled();
			return this;
		},

		enable: function () {
			this._disabled = false;
			this._updateDisabled();
			return this;
		},

		_zoomIn: function (e) {
			if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {
				this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
			}
		},

		_zoomOut: function (e) {
			if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {
				this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
			}
		},

		_createButton: function (html, title, className, container, fn) {
			var link = create$1$1('a', className, container);
			link.innerHTML = html;
			link.href = '#';
			link.title = title;

			/*
			 * Will force screen readers like VoiceOver to read this as "Zoom in - button"
			 */
			link.setAttribute('role', 'button');
			link.setAttribute('aria-label', title);

			disableClickPropagation(link);
			on(link, 'click', stop);
			on(link, 'click', fn, this);
			on(link, 'click', this._refocusOnMap, this);

			return link;
		},

		_updateDisabled: function () {
			var map = this._map,
			    className = 'leaflet-disabled';

			removeClass(this._zoomInButton, className);
			removeClass(this._zoomOutButton, className);

			if (this._disabled || map._zoom === map.getMinZoom()) {
				addClass(this._zoomOutButton, className);
			}
			if (this._disabled || map._zoom === map.getMaxZoom()) {
				addClass(this._zoomInButton, className);
			}
		}
	});

	// @namespace Map
	// @section Control options
	// @option zoomControl: Boolean = true
	// Whether a [zoom control](#control-zoom) is added to the map by default.
	Map$1.mergeOptions({
		zoomControl: true
	});

	Map$1.addInitHook(function () {
		if (this.options.zoomControl) {
			// @section Controls
			// @property zoomControl: Control.Zoom
			// The default zoom control (only available if the
			// [`zoomControl` option](#map-zoomcontrol) was `true` when creating the map).
			this.zoomControl = new Zoom();
			this.addControl(this.zoomControl);
		}
	});

	/*
	 * @class Control.Scale
	 * @aka L.Control.Scale
	 * @inherits Control
	 *
	 * A simple scale control that shows the scale of the current center of screen in metric (m/km) and imperial (mi/ft) systems. Extends `Control`.
	 *
	 * @example
	 *
	 * ```js
	 * L.control.scale().addTo(map);
	 * ```
	 */

	var Scale = Control.extend({
		// @section
		// @aka Control.Scale options
		options: {
			position: 'bottomleft',

			// @option maxWidth: Number = 100
			// Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).
			maxWidth: 100,

			// @option metric: Boolean = True
			// Whether to show the metric scale line (m/km).
			metric: true,

			// @option imperial: Boolean = True
			// Whether to show the imperial scale line (mi/ft).
			imperial: true

			// @option updateWhenIdle: Boolean = false
			// If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).
		},

		onAdd: function (map) {
			var className = 'leaflet-control-scale',
			    container = create$1$1('div', className),
			    options = this.options;

			this._addScales(options, className + '-line', container);

			map.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
			map.whenReady(this._update, this);

			return container;
		},

		onRemove: function (map) {
			map.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
		},

		_addScales: function (options, className, container) {
			if (options.metric) {
				this._mScale = create$1$1('div', className, container);
			}
			if (options.imperial) {
				this._iScale = create$1$1('div', className, container);
			}
		},

		_update: function () {
			var map = this._map,
			    y = map.getSize().y / 2;

			var maxMeters = map.distance(
				map.containerPointToLatLng([0, y]),
				map.containerPointToLatLng([this.options.maxWidth, y]));

			this._updateScales(maxMeters);
		},

		_updateScales: function (maxMeters) {
			if (this.options.metric && maxMeters) {
				this._updateMetric(maxMeters);
			}
			if (this.options.imperial && maxMeters) {
				this._updateImperial(maxMeters);
			}
		},

		_updateMetric: function (maxMeters) {
			var meters = this._getRoundNum(maxMeters),
			    label = meters < 1000 ? meters + ' m' : (meters / 1000) + ' km';

			this._updateScale(this._mScale, label, meters / maxMeters);
		},

		_updateImperial: function (maxMeters) {
			var maxFeet = maxMeters * 3.2808399,
			    maxMiles, miles, feet;

			if (maxFeet > 5280) {
				maxMiles = maxFeet / 5280;
				miles = this._getRoundNum(maxMiles);
				this._updateScale(this._iScale, miles + ' mi', miles / maxMiles);

			} else {
				feet = this._getRoundNum(maxFeet);
				this._updateScale(this._iScale, feet + ' ft', feet / maxFeet);
			}
		},

		_updateScale: function (scale, text, ratio) {
			scale.style.width = Math.round(this.options.maxWidth * ratio) + 'px';
			scale.innerHTML = text;
		},

		_getRoundNum: function (num) {
			var pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),
			    d = num / pow10;

			d = d >= 10 ? 10 :
			    d >= 5 ? 5 :
			    d >= 3 ? 3 :
			    d >= 2 ? 2 : 1;

			return pow10 * d;
		}
	});

	/*
	 * @class Control.Attribution
	 * @aka L.Control.Attribution
	 * @inherits Control
	 *
	 * The attribution control allows you to display attribution data in a small text box on a map. It is put on the map by default unless you set its [`attributionControl` option](#map-attributioncontrol) to `false`, and it fetches attribution texts from layers with the [`getAttribution` method](#layer-getattribution) automatically. Extends Control.
	 */

	var Attribution = Control.extend({
		// @section
		// @aka Control.Attribution options
		options: {
			position: 'bottomright',

			// @option prefix: String = 'Leaflet'
			// The HTML text shown before the attributions. Pass `false` to disable.
			prefix: '<a href="https://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'
		},

		initialize: function (options) {
			setOptions(this, options);

			this._attributions = {};
		},

		onAdd: function (map) {
			map.attributionControl = this;
			this._container = create$1$1('div', 'leaflet-control-attribution');
			disableClickPropagation(this._container);

			// TODO ugly, refactor
			for (var i in map._layers) {
				if (map._layers[i].getAttribution) {
					this.addAttribution(map._layers[i].getAttribution());
				}
			}

			this._update();

			return this._container;
		},

		// @method setPrefix(prefix: String): this
		// Sets the text before the attributions.
		setPrefix: function (prefix) {
			this.options.prefix = prefix;
			this._update();
			return this;
		},

		// @method addAttribution(text: String): this
		// Adds an attribution text (e.g. `'Vector data &copy; Mapbox'`).
		addAttribution: function (text) {
			if (!text) { return this; }

			if (!this._attributions[text]) {
				this._attributions[text] = 0;
			}
			this._attributions[text]++;

			this._update();

			return this;
		},

		// @method removeAttribution(text: String): this
		// Removes an attribution text.
		removeAttribution: function (text) {
			if (!text) { return this; }

			if (this._attributions[text]) {
				this._attributions[text]--;
				this._update();
			}

			return this;
		},

		_update: function () {
			if (!this._map) { return; }

			var attribs = [];

			for (var i in this._attributions) {
				if (this._attributions[i]) {
					attribs.push(i);
				}
			}

			var prefixAndAttribs = [];

			if (this.options.prefix) {
				prefixAndAttribs.push(this.options.prefix);
			}
			if (attribs.length) {
				prefixAndAttribs.push(attribs.join(', '));
			}

			this._container.innerHTML = prefixAndAttribs.join(' | ');
		}
	});

	// @namespace Map
	// @section Control options
	// @option attributionControl: Boolean = true
	// Whether a [attribution control](#control-attribution) is added to the map by default.
	Map$1.mergeOptions({
		attributionControl: true
	});

	Map$1.addInitHook(function () {
		if (this.options.attributionControl) {
			new Attribution().addTo(this);
		}
	});

	Control.Layers = Layers;
	Control.Zoom = Zoom;
	Control.Scale = Scale;
	Control.Attribution = Attribution;

	/*
		L.Handler is a base class for handler classes that are used internally to inject
		interaction features like dragging to classes like Map and Marker.
	*/

	// @class Handler
	// @aka L.Handler
	// Abstract class for map interaction handlers

	var Handler = Class.extend({
		initialize: function (map) {
			this._map = map;
		},

		// @method enable(): this
		// Enables the handler
		enable: function () {
			if (this._enabled) { return this; }

			this._enabled = true;
			this.addHooks();
			return this;
		},

		// @method disable(): this
		// Disables the handler
		disable: function () {
			if (!this._enabled) { return this; }

			this._enabled = false;
			this.removeHooks();
			return this;
		},

		// @method enabled(): Boolean
		// Returns `true` if the handler is enabled
		enabled: function () {
			return !!this._enabled;
		}

		// @section Extension methods
		// Classes inheriting from `Handler` must implement the two following methods:
		// @method addHooks()
		// Called when the handler is enabled, should add event hooks.
		// @method removeHooks()
		// Called when the handler is disabled, should remove the event hooks added previously.
	});

	// @section There is static function which can be called without instantiating L.Handler:
	// @function addTo(map: Map, name: String): this
	// Adds a new Handler to the given map with the given name.
	Handler.addTo = function (map, name) {
		map.addHandler(name, this);
		return this;
	};

	/*
	 * @class Draggable
	 * @aka L.Draggable
	 * @inherits Evented
	 *
	 * A class for making DOM elements draggable (including touch support).
	 * Used internally for map and marker dragging. Only works for elements
	 * that were positioned with [`L.DomUtil.setPosition`](#domutil-setposition).
	 *
	 * @example
	 * ```js
	 * var draggable = new L.Draggable(elementToDrag);
	 * draggable.enable();
	 * ```
	 */

	var START = touch ? 'touchstart mousedown' : 'mousedown';
	var END = {
		mousedown: 'mouseup',
		touchstart: 'touchend',
		pointerdown: 'touchend',
		MSPointerDown: 'touchend'
	};
	var MOVE = {
		mousedown: 'mousemove',
		touchstart: 'touchmove',
		pointerdown: 'touchmove',
		MSPointerDown: 'touchmove'
	};


	var Draggable = Evented.extend({

		options: {
			// @section
			// @aka Draggable options
			// @option clickTolerance: Number = 3
			// The max number of pixels a user can shift the mouse pointer during a click
			// for it to be considered a valid click (as opposed to a mouse drag).
			clickTolerance: 3
		},

		// @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline?: Boolean, options?: Draggable options)
		// Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).
		initialize: function (element, dragStartTarget, preventOutline$$1, options) {
			setOptions(this, options);

			this._element = element;
			this._dragStartTarget = dragStartTarget || element;
			this._preventOutline = preventOutline$$1;
		},

		// @method enable()
		// Enables the dragging ability
		enable: function () {
			if (this._enabled) { return; }

			on(this._dragStartTarget, START, this._onDown, this);

			this._enabled = true;
		},

		// @method disable()
		// Disables the dragging ability
		disable: function () {
			if (!this._enabled) { return; }

			// If we're currently dragging this draggable,
			// disabling it counts as first ending the drag.
			if (Draggable._dragging === this) {
				this.finishDrag();
			}

			off(this._dragStartTarget, START, this._onDown, this);

			this._enabled = false;
			this._moved = false;
		},

		_onDown: function (e) {
			// Ignore simulated events, since we handle both touch and
			// mouse explicitly; otherwise we risk getting duplicates of
			// touch events, see #4315.
			// Also ignore the event if disabled; this happens in IE11
			// under some circumstances, see #3666.
			if (e._simulated || !this._enabled) { return; }

			this._moved = false;

			if (hasClass(this._element, 'leaflet-zoom-anim')) { return; }

			if (Draggable._dragging || e.shiftKey || ((e.which !== 1) && (e.button !== 1) && !e.touches)) { return; }
			Draggable._dragging = this;  // Prevent dragging multiple objects at once.

			if (this._preventOutline) {
				preventOutline(this._element);
			}

			disableImageDrag();
			disableTextSelection();

			if (this._moving) { return; }

			// @event down: Event
			// Fired when a drag is about to start.
			this.fire('down');

			var first = e.touches ? e.touches[0] : e,
			    sizedParent = getSizedParentNode(this._element);

			this._startPoint = new Point$1(first.clientX, first.clientY);

			// Cache the scale, so that we can continuously compensate for it during drag (_onMove).
			this._parentScale = getScale(sizedParent);

			on(document, MOVE[e.type], this._onMove, this);
			on(document, END[e.type], this._onUp, this);
		},

		_onMove: function (e) {
			// Ignore simulated events, since we handle both touch and
			// mouse explicitly; otherwise we risk getting duplicates of
			// touch events, see #4315.
			// Also ignore the event if disabled; this happens in IE11
			// under some circumstances, see #3666.
			if (e._simulated || !this._enabled) { return; }

			if (e.touches && e.touches.length > 1) {
				this._moved = true;
				return;
			}

			var first = (e.touches && e.touches.length === 1 ? e.touches[0] : e),
			    offset = new Point$1(first.clientX, first.clientY)._subtract(this._startPoint);

			if (!offset.x && !offset.y) { return; }
			if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) { return; }

			// We assume that the parent container's position, border and scale do not change for the duration of the drag.
			// Therefore there is no need to account for the position and border (they are eliminated by the subtraction)
			// and we can use the cached value for the scale.
			offset.x /= this._parentScale.x;
			offset.y /= this._parentScale.y;

			preventDefault(e);

			if (!this._moved) {
				// @event dragstart: Event
				// Fired when a drag starts
				this.fire('dragstart');

				this._moved = true;
				this._startPos = getPosition$1(this._element).subtract(offset);

				addClass(document.body, 'leaflet-dragging');

				this._lastTarget = e.target || e.srcElement;
				// IE and Edge do not give the <use> element, so fetch it
				// if necessary
				if ((window.SVGElementInstance) && (this._lastTarget instanceof SVGElementInstance)) {
					this._lastTarget = this._lastTarget.correspondingUseElement;
				}
				addClass(this._lastTarget, 'leaflet-drag-target');
			}

			this._newPos = this._startPos.add(offset);
			this._moving = true;

			cancelAnimFrame(this._animRequest);
			this._lastEvent = e;
			this._animRequest = requestAnimFrame(this._updatePosition, this, true);
		},

		_updatePosition: function () {
			var e = {originalEvent: this._lastEvent};

			// @event predrag: Event
			// Fired continuously during dragging *before* each corresponding
			// update of the element's position.
			this.fire('predrag', e);
			setPosition(this._element, this._newPos);

			// @event drag: Event
			// Fired continuously during dragging.
			this.fire('drag', e);
		},

		_onUp: function (e) {
			// Ignore simulated events, since we handle both touch and
			// mouse explicitly; otherwise we risk getting duplicates of
			// touch events, see #4315.
			// Also ignore the event if disabled; this happens in IE11
			// under some circumstances, see #3666.
			if (e._simulated || !this._enabled) { return; }
			this.finishDrag();
		},

		finishDrag: function () {
			removeClass(document.body, 'leaflet-dragging');

			if (this._lastTarget) {
				removeClass(this._lastTarget, 'leaflet-drag-target');
				this._lastTarget = null;
			}

			for (var i in MOVE) {
				off(document, MOVE[i], this._onMove, this);
				off(document, END[i], this._onUp, this);
			}

			enableImageDrag();
			enableTextSelection();

			if (this._moved && this._moving) {
				// ensure drag is not fired after dragend
				cancelAnimFrame(this._animRequest);

				// @event dragend: DragEndEvent
				// Fired when the drag ends.
				this.fire('dragend', {
					distance: this._newPos.distanceTo(this._startPos)
				});
			}

			this._moving = false;
			Draggable._dragging = false;
		}

	});

	/*
	 * @namespace LineUtil
	 *
	 * Various utility functions for polyline points processing, used by Leaflet internally to make polylines lightning-fast.
	 */

	// Simplify polyline with vertex reduction and Douglas-Peucker simplification.
	// Improves rendering performance dramatically by lessening the number of points to draw.

	// @function simplify(points: Point[], tolerance: Number): Point[]
	// Dramatically reduces the number of points in a polyline while retaining
	// its shape and returns a new array of simplified points, using the
	// [Douglas-Peucker algorithm](http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm).
	// Used for a huge performance boost when processing/displaying Leaflet polylines for
	// each zoom level and also reducing visual noise. tolerance affects the amount of
	// simplification (lesser value means higher quality but slower and with more points).
	// Also released as a separated micro-library [Simplify.js](http://mourner.github.com/simplify-js/).
	function simplify(points, tolerance) {
		if (!tolerance || !points.length) {
			return points.slice();
		}

		var sqTolerance = tolerance * tolerance;

		    // stage 1: vertex reduction
		    points = _reducePoints(points, sqTolerance);

		    // stage 2: Douglas-Peucker simplification
		    points = _simplifyDP(points, sqTolerance);

		return points;
	}

	// @function pointToSegmentDistance(p: Point, p1: Point, p2: Point): Number
	// Returns the distance between point `p` and segment `p1` to `p2`.
	function pointToSegmentDistance(p, p1, p2) {
		return Math.sqrt(_sqClosestPointOnSegment(p, p1, p2, true));
	}

	// @function closestPointOnSegment(p: Point, p1: Point, p2: Point): Number
	// Returns the closest point from a point `p` on a segment `p1` to `p2`.
	function closestPointOnSegment(p, p1, p2) {
		return _sqClosestPointOnSegment(p, p1, p2);
	}

	// Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm
	function _simplifyDP(points, sqTolerance) {

		var len = points.length,
		    ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,
		    markers = new ArrayConstructor(len);

		    markers[0] = markers[len - 1] = 1;

		_simplifyDPStep(points, markers, sqTolerance, 0, len - 1);

		var i,
		    newPoints = [];

		for (i = 0; i < len; i++) {
			if (markers[i]) {
				newPoints.push(points[i]);
			}
		}

		return newPoints;
	}

	function _simplifyDPStep(points, markers, sqTolerance, first, last) {

		var maxSqDist = 0,
		index, i, sqDist;

		for (i = first + 1; i <= last - 1; i++) {
			sqDist = _sqClosestPointOnSegment(points[i], points[first], points[last], true);

			if (sqDist > maxSqDist) {
				index = i;
				maxSqDist = sqDist;
			}
		}

		if (maxSqDist > sqTolerance) {
			markers[index] = 1;

			_simplifyDPStep(points, markers, sqTolerance, first, index);
			_simplifyDPStep(points, markers, sqTolerance, index, last);
		}
	}

	// reduce points that are too close to each other to a single point
	function _reducePoints(points, sqTolerance) {
		var reducedPoints = [points[0]];

		for (var i = 1, prev = 0, len = points.length; i < len; i++) {
			if (_sqDist(points[i], points[prev]) > sqTolerance) {
				reducedPoints.push(points[i]);
				prev = i;
			}
		}
		if (prev < len - 1) {
			reducedPoints.push(points[len - 1]);
		}
		return reducedPoints;
	}

	var _lastCode;

	// @function clipSegment(a: Point, b: Point, bounds: Bounds, useLastCode?: Boolean, round?: Boolean): Point[]|Boolean
	// Clips the segment a to b by rectangular bounds with the
	// [Cohen-Sutherland algorithm](https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm)
	// (modifying the segment points directly!). Used by Leaflet to only show polyline
	// points that are on the screen or near, increasing performance.
	function clipSegment(a, b, bounds, useLastCode, round) {
		var codeA = useLastCode ? _lastCode : _getBitCode(a, bounds),
		    codeB = _getBitCode(b, bounds),

		    codeOut, p, newCode;

		    // save 2nd code to avoid calculating it on the next segment
		    _lastCode = codeB;

		while (true) {
			// if a,b is inside the clip window (trivial accept)
			if (!(codeA | codeB)) {
				return [a, b];
			}

			// if a,b is outside the clip window (trivial reject)
			if (codeA & codeB) {
				return false;
			}

			// other cases
			codeOut = codeA || codeB;
			p = _getEdgeIntersection(a, b, codeOut, bounds, round);
			newCode = _getBitCode(p, bounds);

			if (codeOut === codeA) {
				a = p;
				codeA = newCode;
			} else {
				b = p;
				codeB = newCode;
			}
		}
	}

	function _getEdgeIntersection(a, b, code, bounds, round) {
		var dx = b.x - a.x,
		    dy = b.y - a.y,
		    min = bounds.min,
		    max = bounds.max,
		    x, y;

		if (code & 8) { // top
			x = a.x + dx * (max.y - a.y) / dy;
			y = max.y;

		} else if (code & 4) { // bottom
			x = a.x + dx * (min.y - a.y) / dy;
			y = min.y;

		} else if (code & 2) { // right
			x = max.x;
			y = a.y + dy * (max.x - a.x) / dx;

		} else if (code & 1) { // left
			x = min.x;
			y = a.y + dy * (min.x - a.x) / dx;
		}

		return new Point$1(x, y, round);
	}

	function _getBitCode(p, bounds) {
		var code = 0;

		if (p.x < bounds.min.x) { // left
			code |= 1;
		} else if (p.x > bounds.max.x) { // right
			code |= 2;
		}

		if (p.y < bounds.min.y) { // bottom
			code |= 4;
		} else if (p.y > bounds.max.y) { // top
			code |= 8;
		}

		return code;
	}

	// square distance (to avoid unnecessary Math.sqrt calls)
	function _sqDist(p1, p2) {
		var dx = p2.x - p1.x,
		    dy = p2.y - p1.y;
		return dx * dx + dy * dy;
	}

	// return closest point on segment or distance to that point
	function _sqClosestPointOnSegment(p, p1, p2, sqDist) {
		var x = p1.x,
		    y = p1.y,
		    dx = p2.x - x,
		    dy = p2.y - y,
		    dot = dx * dx + dy * dy,
		    t;

		if (dot > 0) {
			t = ((p.x - x) * dx + (p.y - y) * dy) / dot;

			if (t > 1) {
				x = p2.x;
				y = p2.y;
			} else if (t > 0) {
				x += dx * t;
				y += dy * t;
			}
		}

		dx = p.x - x;
		dy = p.y - y;

		return sqDist ? dx * dx + dy * dy : new Point$1(x, y);
	}


	// @function isFlat(latlngs: LatLng[]): Boolean
	// Returns true if `latlngs` is a flat array, false is nested.
	function isFlat(latlngs) {
		return !isArray$2(latlngs[0]) || (typeof latlngs[0][0] !== 'object' && typeof latlngs[0][0] !== 'undefined');
	}

	function _flat(latlngs) {
		console.warn('Deprecated use of _flat, please use L.LineUtil.isFlat instead.');
		return isFlat(latlngs);
	}


	var LineUtil = (Object.freeze || Object)({
		simplify: simplify,
		pointToSegmentDistance: pointToSegmentDistance,
		closestPointOnSegment: closestPointOnSegment,
		clipSegment: clipSegment,
		_getEdgeIntersection: _getEdgeIntersection,
		_getBitCode: _getBitCode,
		_sqClosestPointOnSegment: _sqClosestPointOnSegment,
		isFlat: isFlat,
		_flat: _flat
	});

	/*
	 * @namespace PolyUtil
	 * Various utility functions for polygon geometries.
	 */

	/* @function clipPolygon(points: Point[], bounds: Bounds, round?: Boolean): Point[]
	 * Clips the polygon geometry defined by the given `points` by the given bounds (using the [Sutherland-Hodgman algorithm](https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm)).
	 * Used by Leaflet to only show polygon points that are on the screen or near, increasing
	 * performance. Note that polygon points needs different algorithm for clipping
	 * than polyline, so there's a separate method for it.
	 */
	function clipPolygon(points, bounds, round) {
		var clippedPoints,
		    edges = [1, 4, 2, 8],
		    i, j, k,
		    a, b,
		    len, edge, p;

		for (i = 0, len = points.length; i < len; i++) {
			points[i]._code = _getBitCode(points[i], bounds);
		}

		// for each edge (left, bottom, right, top)
		for (k = 0; k < 4; k++) {
			edge = edges[k];
			clippedPoints = [];

			for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
				a = points[i];
				b = points[j];

				// if a is inside the clip window
				if (!(a._code & edge)) {
					// if b is outside the clip window (a->b goes out of screen)
					if (b._code & edge) {
						p = _getEdgeIntersection(b, a, edge, bounds, round);
						p._code = _getBitCode(p, bounds);
						clippedPoints.push(p);
					}
					clippedPoints.push(a);

				// else if b is inside the clip window (a->b enters the screen)
				} else if (!(b._code & edge)) {
					p = _getEdgeIntersection(b, a, edge, bounds, round);
					p._code = _getBitCode(p, bounds);
					clippedPoints.push(p);
				}
			}
			points = clippedPoints;
		}

		return points;
	}


	var PolyUtil = (Object.freeze || Object)({
		clipPolygon: clipPolygon
	});

	/*
	 * @namespace Projection
	 * @section
	 * Leaflet comes with a set of already defined Projections out of the box:
	 *
	 * @projection L.Projection.LonLat
	 *
	 * Equirectangular, or Plate Carree projection — the most simple projection,
	 * mostly used by GIS enthusiasts. Directly maps `x` as longitude, and `y` as
	 * latitude. Also suitable for flat worlds, e.g. game maps. Used by the
	 * `EPSG:4326` and `Simple` CRS.
	 */

	var LonLat = {
		project: function (latlng) {
			return new Point$1(latlng.lng, latlng.lat);
		},

		unproject: function (point) {
			return new LatLng(point.y, point.x);
		},

		bounds: new Bounds([-180, -90], [180, 90])
	};

	/*
	 * @namespace Projection
	 * @projection L.Projection.Mercator
	 *
	 * Elliptical Mercator projection — more complex than Spherical Mercator. Assumes that Earth is an ellipsoid. Used by the EPSG:3395 CRS.
	 */

	var Mercator = {
		R: 6378137,
		R_MINOR: 6356752.314245179,

		bounds: new Bounds([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]),

		project: function (latlng) {
			var d = Math.PI / 180,
			    r = this.R,
			    y = latlng.lat * d,
			    tmp = this.R_MINOR / r,
			    e = Math.sqrt(1 - tmp * tmp),
			    con = e * Math.sin(y);

			var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);
			y = -r * Math.log(Math.max(ts, 1E-10));

			return new Point$1(latlng.lng * d * r, y);
		},

		unproject: function (point) {
			var d = 180 / Math.PI,
			    r = this.R,
			    tmp = this.R_MINOR / r,
			    e = Math.sqrt(1 - tmp * tmp),
			    ts = Math.exp(-point.y / r),
			    phi = Math.PI / 2 - 2 * Math.atan(ts);

			for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {
				con = e * Math.sin(phi);
				con = Math.pow((1 - con) / (1 + con), e / 2);
				dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
				phi += dphi;
			}

			return new LatLng(phi * d, point.x * d / r);
		}
	};

	/*
	 * @class Projection

	 * An object with methods for projecting geographical coordinates of the world onto
	 * a flat surface (and back). See [Map projection](http://en.wikipedia.org/wiki/Map_projection).

	 * @property bounds: Bounds
	 * The bounds (specified in CRS units) where the projection is valid

	 * @method project(latlng: LatLng): Point
	 * Projects geographical coordinates into a 2D point.
	 * Only accepts actual `L.LatLng` instances, not arrays.

	 * @method unproject(point: Point): LatLng
	 * The inverse of `project`. Projects a 2D point into a geographical location.
	 * Only accepts actual `L.Point` instances, not arrays.

	 * Note that the projection instances do not inherit from Leafet's `Class` object,
	 * and can't be instantiated. Also, new classes can't inherit from them,
	 * and methods can't be added to them with the `include` function.

	 */




	var index$1 = (Object.freeze || Object)({
		LonLat: LonLat,
		Mercator: Mercator,
		SphericalMercator: SphericalMercator
	});

	/*
	 * @namespace CRS
	 * @crs L.CRS.EPSG3395
	 *
	 * Rarely used by some commercial tile providers. Uses Elliptical Mercator projection.
	 */
	var EPSG3395 = extend$1({}, Earth, {
		code: 'EPSG:3395',
		projection: Mercator,

		transformation: (function () {
			var scale = 0.5 / (Math.PI * Mercator.R);
			return toTransformation(scale, 0.5, -scale, 0.5);
		}())
	});

	/*
	 * @namespace CRS
	 * @crs L.CRS.EPSG4326
	 *
	 * A common CRS among GIS enthusiasts. Uses simple Equirectangular projection.
	 *
	 * Leaflet 1.0.x complies with the [TMS coordinate scheme for EPSG:4326](https://wiki.osgeo.org/wiki/Tile_Map_Service_Specification#global-geodetic),
	 * which is a breaking change from 0.7.x behaviour.  If you are using a `TileLayer`
	 * with this CRS, ensure that there are two 256x256 pixel tiles covering the
	 * whole earth at zoom level zero, and that the tile coordinate origin is (-180,+90),
	 * or (-180,-90) for `TileLayer`s with [the `tms` option](#tilelayer-tms) set.
	 */

	var EPSG4326 = extend$1({}, Earth, {
		code: 'EPSG:4326',
		projection: LonLat,
		transformation: toTransformation(1 / 180, 1, -1 / 180, 0.5)
	});

	/*
	 * @namespace CRS
	 * @crs L.CRS.Simple
	 *
	 * A simple CRS that maps longitude and latitude into `x` and `y` directly.
	 * May be used for maps of flat surfaces (e.g. game maps). Note that the `y`
	 * axis should still be inverted (going from bottom to top). `distance()` returns
	 * simple euclidean distance.
	 */

	var Simple = extend$1({}, CRS, {
		projection: LonLat,
		transformation: toTransformation(1, 0, -1, 0),

		scale: function (zoom) {
			return Math.pow(2, zoom);
		},

		zoom: function (scale) {
			return Math.log(scale) / Math.LN2;
		},

		distance: function (latlng1, latlng2) {
			var dx = latlng2.lng - latlng1.lng,
			    dy = latlng2.lat - latlng1.lat;

			return Math.sqrt(dx * dx + dy * dy);
		},

		infinite: true
	});

	CRS.Earth = Earth;
	CRS.EPSG3395 = EPSG3395;
	CRS.EPSG3857 = EPSG3857;
	CRS.EPSG900913 = EPSG900913;
	CRS.EPSG4326 = EPSG4326;
	CRS.Simple = Simple;

	/*
	 * @class Layer
	 * @inherits Evented
	 * @aka L.Layer
	 * @aka ILayer
	 *
	 * A set of methods from the Layer base class that all Leaflet layers use.
	 * Inherits all methods, options and events from `L.Evented`.
	 *
	 * @example
	 *
	 * ```js
	 * var layer = L.marker(latlng).addTo(map);
	 * layer.addTo(map);
	 * layer.remove();
	 * ```
	 *
	 * @event add: Event
	 * Fired after the layer is added to a map
	 *
	 * @event remove: Event
	 * Fired after the layer is removed from a map
	 */


	var Layer = Evented.extend({

		// Classes extending `L.Layer` will inherit the following options:
		options: {
			// @option pane: String = 'overlayPane'
			// By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.
			pane: 'overlayPane',

			// @option attribution: String = null
			// String to be shown in the attribution control, e.g. "© OpenStreetMap contributors". It describes the layer data and is often a legal obligation towards copyright holders and tile providers.
			attribution: null,

			bubblingMouseEvents: true
		},

		/* @section
		 * Classes extending `L.Layer` will inherit the following methods:
		 *
		 * @method addTo(map: Map|LayerGroup): this
		 * Adds the layer to the given map or layer group.
		 */
		addTo: function (map) {
			map.addLayer(this);
			return this;
		},

		// @method remove: this
		// Removes the layer from the map it is currently active on.
		remove: function () {
			return this.removeFrom(this._map || this._mapToAdd);
		},

		// @method removeFrom(map: Map): this
		// Removes the layer from the given map
		removeFrom: function (obj) {
			if (obj) {
				obj.removeLayer(this);
			}
			return this;
		},

		// @method getPane(name? : String): HTMLElement
		// Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.
		getPane: function (name) {
			return this._map.getPane(name ? (this.options[name] || name) : this.options.pane);
		},

		addInteractiveTarget: function (targetEl) {
			this._map._targets[stamp(targetEl)] = this;
			return this;
		},

		removeInteractiveTarget: function (targetEl) {
			delete this._map._targets[stamp(targetEl)];
			return this;
		},

		// @method getAttribution: String
		// Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).
		getAttribution: function () {
			return this.options.attribution;
		},

		_layerAdd: function (e) {
			var map = e.target;

			// check in case layer gets added and then removed before the map is ready
			if (!map.hasLayer(this)) { return; }

			this._map = map;
			this._zoomAnimated = map._zoomAnimated;

			if (this.getEvents) {
				var events = this.getEvents();
				map.on(events, this);
				this.once('remove', function () {
					map.off(events, this);
				}, this);
			}

			this.onAdd(map);

			if (this.getAttribution && map.attributionControl) {
				map.attributionControl.addAttribution(this.getAttribution());
			}

			this.fire('add');
			map.fire('layeradd', {layer: this});
		}
	});

	/* @section Extension methods
	 * @uninheritable
	 *
	 * Every layer should extend from `L.Layer` and (re-)implement the following methods.
	 *
	 * @method onAdd(map: Map): this
	 * Should contain code that creates DOM elements for the layer, adds them to `map panes` where they should belong and puts listeners on relevant map events. Called on [`map.addLayer(layer)`](#map-addlayer).
	 *
	 * @method onRemove(map: Map): this
	 * Should contain all clean up code that removes the layer's elements from the DOM and removes listeners previously added in [`onAdd`](#layer-onadd). Called on [`map.removeLayer(layer)`](#map-removelayer).
	 *
	 * @method getEvents(): Object
	 * This optional method should return an object like `{ viewreset: this._reset }` for [`addEventListener`](#evented-addeventlistener). The event handlers in this object will be automatically added and removed from the map with your layer.
	 *
	 * @method getAttribution(): String
	 * This optional method should return a string containing HTML to be shown on the `Attribution control` whenever the layer is visible.
	 *
	 * @method beforeAdd(map: Map): this
	 * Optional method. Called on [`map.addLayer(layer)`](#map-addlayer), before the layer is added to the map, before events are initialized, without waiting until the map is in a usable state. Use for early initialization only.
	 */


	/* @namespace Map
	 * @section Layer events
	 *
	 * @event layeradd: LayerEvent
	 * Fired when a new layer is added to the map.
	 *
	 * @event layerremove: LayerEvent
	 * Fired when some layer is removed from the map
	 *
	 * @section Methods for Layers and Controls
	 */
	Map$1.include({
		// @method addLayer(layer: Layer): this
		// Adds the given layer to the map
		addLayer: function (layer) {
			if (!layer._layerAdd) {
				throw new Error('The provided object is not a Layer.');
			}

			var id = stamp(layer);
			if (this._layers[id]) { return this; }
			this._layers[id] = layer;

			layer._mapToAdd = this;

			if (layer.beforeAdd) {
				layer.beforeAdd(this);
			}

			this.whenReady(layer._layerAdd, layer);

			return this;
		},

		// @method removeLayer(layer: Layer): this
		// Removes the given layer from the map.
		removeLayer: function (layer) {
			var id = stamp(layer);

			if (!this._layers[id]) { return this; }

			if (this._loaded) {
				layer.onRemove(this);
			}

			if (layer.getAttribution && this.attributionControl) {
				this.attributionControl.removeAttribution(layer.getAttribution());
			}

			delete this._layers[id];

			if (this._loaded) {
				this.fire('layerremove', {layer: layer});
				layer.fire('remove');
			}

			layer._map = layer._mapToAdd = null;

			return this;
		},

		// @method hasLayer(layer: Layer): Boolean
		// Returns `true` if the given layer is currently added to the map
		hasLayer: function (layer) {
			return !!layer && (stamp(layer) in this._layers);
		},

		/* @method eachLayer(fn: Function, context?: Object): this
		 * Iterates over the layers of the map, optionally specifying context of the iterator function.
		 * ```
		 * map.eachLayer(function(layer){
		 *     layer.bindPopup('Hello');
		 * });
		 * ```
		 */
		eachLayer: function (method, context) {
			for (var i in this._layers) {
				method.call(context, this._layers[i]);
			}
			return this;
		},

		_addLayers: function (layers) {
			layers = layers ? (isArray$2(layers) ? layers : [layers]) : [];

			for (var i = 0, len = layers.length; i < len; i++) {
				this.addLayer(layers[i]);
			}
		},

		_addZoomLimit: function (layer) {
			if (isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {
				this._zoomBoundLayers[stamp(layer)] = layer;
				this._updateZoomLevels();
			}
		},

		_removeZoomLimit: function (layer) {
			var id = stamp(layer);

			if (this._zoomBoundLayers[id]) {
				delete this._zoomBoundLayers[id];
				this._updateZoomLevels();
			}
		},

		_updateZoomLevels: function () {
			var minZoom = Infinity,
			    maxZoom = -Infinity,
			    oldZoomSpan = this._getZoomSpan();

			for (var i in this._zoomBoundLayers) {
				var options = this._zoomBoundLayers[i].options;

				minZoom = options.minZoom === undefined ? minZoom : Math.min(minZoom, options.minZoom);
				maxZoom = options.maxZoom === undefined ? maxZoom : Math.max(maxZoom, options.maxZoom);
			}

			this._layersMaxZoom = maxZoom === -Infinity ? undefined : maxZoom;
			this._layersMinZoom = minZoom === Infinity ? undefined : minZoom;

			// @section Map state change events
			// @event zoomlevelschange: Event
			// Fired when the number of zoomlevels on the map is changed due
			// to adding or removing a layer.
			if (oldZoomSpan !== this._getZoomSpan()) {
				this.fire('zoomlevelschange');
			}

			if (this.options.maxZoom === undefined && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) {
				this.setZoom(this._layersMaxZoom);
			}
			if (this.options.minZoom === undefined && this._layersMinZoom && this.getZoom() < this._layersMinZoom) {
				this.setZoom(this._layersMinZoom);
			}
		}
	});

	/*
	 * @class LayerGroup
	 * @aka L.LayerGroup
	 * @inherits Layer
	 *
	 * Used to group several layers and handle them as one. If you add it to the map,
	 * any layers added or removed from the group will be added/removed on the map as
	 * well. Extends `Layer`.
	 *
	 * @example
	 *
	 * ```js
	 * L.layerGroup([marker1, marker2])
	 * 	.addLayer(polyline)
	 * 	.addTo(map);
	 * ```
	 */

	var LayerGroup = Layer.extend({

		initialize: function (layers, options) {
			setOptions(this, options);

			this._layers = {};

			var i, len;

			if (layers) {
				for (i = 0, len = layers.length; i < len; i++) {
					this.addLayer(layers[i]);
				}
			}
		},

		// @method addLayer(layer: Layer): this
		// Adds the given layer to the group.
		addLayer: function (layer) {
			var id = this.getLayerId(layer);

			this._layers[id] = layer;

			if (this._map) {
				this._map.addLayer(layer);
			}

			return this;
		},

		// @method removeLayer(layer: Layer): this
		// Removes the given layer from the group.
		// @alternative
		// @method removeLayer(id: Number): this
		// Removes the layer with the given internal ID from the group.
		removeLayer: function (layer) {
			var id = layer in this._layers ? layer : this.getLayerId(layer);

			if (this._map && this._layers[id]) {
				this._map.removeLayer(this._layers[id]);
			}

			delete this._layers[id];

			return this;
		},

		// @method hasLayer(layer: Layer): Boolean
		// Returns `true` if the given layer is currently added to the group.
		// @alternative
		// @method hasLayer(id: Number): Boolean
		// Returns `true` if the given internal ID is currently added to the group.
		hasLayer: function (layer) {
			return !!layer && (layer in this._layers || this.getLayerId(layer) in this._layers);
		},

		// @method clearLayers(): this
		// Removes all the layers from the group.
		clearLayers: function () {
			return this.eachLayer(this.removeLayer, this);
		},

		// @method invoke(methodName: String, …): this
		// Calls `methodName` on every layer contained in this group, passing any
		// additional parameters. Has no effect if the layers contained do not
		// implement `methodName`.
		invoke: function (methodName) {
			var args = Array.prototype.slice.call(arguments, 1),
			    i, layer;

			for (i in this._layers) {
				layer = this._layers[i];

				if (layer[methodName]) {
					layer[methodName].apply(layer, args);
				}
			}

			return this;
		},

		onAdd: function (map) {
			this.eachLayer(map.addLayer, map);
		},

		onRemove: function (map) {
			this.eachLayer(map.removeLayer, map);
		},

		// @method eachLayer(fn: Function, context?: Object): this
		// Iterates over the layers of the group, optionally specifying context of the iterator function.
		// ```js
		// group.eachLayer(function (layer) {
		// 	layer.bindPopup('Hello');
		// });
		// ```
		eachLayer: function (method, context) {
			for (var i in this._layers) {
				method.call(context, this._layers[i]);
			}
			return this;
		},

		// @method getLayer(id: Number): Layer
		// Returns the layer with the given internal ID.
		getLayer: function (id) {
			return this._layers[id];
		},

		// @method getLayers(): Layer[]
		// Returns an array of all the layers added to the group.
		getLayers: function () {
			var layers = [];
			this.eachLayer(layers.push, layers);
			return layers;
		},

		// @method setZIndex(zIndex: Number): this
		// Calls `setZIndex` on every layer contained in this group, passing the z-index.
		setZIndex: function (zIndex) {
			return this.invoke('setZIndex', zIndex);
		},

		// @method getLayerId(layer: Layer): Number
		// Returns the internal ID for a layer
		getLayerId: function (layer) {
			return stamp(layer);
		}
	});

	/*
	 * @class FeatureGroup
	 * @aka L.FeatureGroup
	 * @inherits LayerGroup
	 *
	 * Extended `LayerGroup` that makes it easier to do the same thing to all its member layers:
	 *  * [`bindPopup`](#layer-bindpopup) binds a popup to all of the layers at once (likewise with [`bindTooltip`](#layer-bindtooltip))
	 *  * Events are propagated to the `FeatureGroup`, so if the group has an event
	 * handler, it will handle events from any of the layers. This includes mouse events
	 * and custom events.
	 *  * Has `layeradd` and `layerremove` events
	 *
	 * @example
	 *
	 * ```js
	 * L.featureGroup([marker1, marker2, polyline])
	 * 	.bindPopup('Hello world!')
	 * 	.on('click', function() { alert('Clicked on a member of the group!'); })
	 * 	.addTo(map);
	 * ```
	 */

	var FeatureGroup = LayerGroup.extend({

		addLayer: function (layer) {
			if (this.hasLayer(layer)) {
				return this;
			}

			layer.addEventParent(this);

			LayerGroup.prototype.addLayer.call(this, layer);

			// @event layeradd: LayerEvent
			// Fired when a layer is added to this `FeatureGroup`
			return this.fire('layeradd', {layer: layer});
		},

		removeLayer: function (layer) {
			if (!this.hasLayer(layer)) {
				return this;
			}
			if (layer in this._layers) {
				layer = this._layers[layer];
			}

			layer.removeEventParent(this);

			LayerGroup.prototype.removeLayer.call(this, layer);

			// @event layerremove: LayerEvent
			// Fired when a layer is removed from this `FeatureGroup`
			return this.fire('layerremove', {layer: layer});
		},

		// @method setStyle(style: Path options): this
		// Sets the given path options to each layer of the group that has a `setStyle` method.
		setStyle: function (style) {
			return this.invoke('setStyle', style);
		},

		// @method bringToFront(): this
		// Brings the layer group to the top of all other layers
		bringToFront: function () {
			return this.invoke('bringToFront');
		},

		// @method bringToBack(): this
		// Brings the layer group to the back of all other layers
		bringToBack: function () {
			return this.invoke('bringToBack');
		},

		// @method getBounds(): LatLngBounds
		// Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).
		getBounds: function () {
			var bounds = new LatLngBounds();

			for (var id in this._layers) {
				var layer = this._layers[id];
				bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());
			}
			return bounds;
		}
	});

	/*
	 * @class Icon
	 * @aka L.Icon
	 *
	 * Represents an icon to provide when creating a marker.
	 *
	 * @example
	 *
	 * ```js
	 * var myIcon = L.icon({
	 *     iconUrl: 'my-icon.png',
	 *     iconRetinaUrl: 'my-icon@2x.png',
	 *     iconSize: [38, 95],
	 *     iconAnchor: [22, 94],
	 *     popupAnchor: [-3, -76],
	 *     shadowUrl: 'my-icon-shadow.png',
	 *     shadowRetinaUrl: 'my-icon-shadow@2x.png',
	 *     shadowSize: [68, 95],
	 *     shadowAnchor: [22, 94]
	 * });
	 *
	 * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
	 * ```
	 *
	 * `L.Icon.Default` extends `L.Icon` and is the blue icon Leaflet uses for markers by default.
	 *
	 */

	var Icon = Class.extend({

		/* @section
		 * @aka Icon options
		 *
		 * @option iconUrl: String = null
		 * **(required)** The URL to the icon image (absolute or relative to your script path).
		 *
		 * @option iconRetinaUrl: String = null
		 * The URL to a retina sized version of the icon image (absolute or relative to your
		 * script path). Used for Retina screen devices.
		 *
		 * @option iconSize: Point = null
		 * Size of the icon image in pixels.
		 *
		 * @option iconAnchor: Point = null
		 * The coordinates of the "tip" of the icon (relative to its top left corner). The icon
		 * will be aligned so that this point is at the marker's geographical location. Centered
		 * by default if size is specified, also can be set in CSS with negative margins.
		 *
		 * @option popupAnchor: Point = [0, 0]
		 * The coordinates of the point from which popups will "open", relative to the icon anchor.
		 *
		 * @option tooltipAnchor: Point = [0, 0]
		 * The coordinates of the point from which tooltips will "open", relative to the icon anchor.
		 *
		 * @option shadowUrl: String = null
		 * The URL to the icon shadow image. If not specified, no shadow image will be created.
		 *
		 * @option shadowRetinaUrl: String = null
		 *
		 * @option shadowSize: Point = null
		 * Size of the shadow image in pixels.
		 *
		 * @option shadowAnchor: Point = null
		 * The coordinates of the "tip" of the shadow (relative to its top left corner) (the same
		 * as iconAnchor if not specified).
		 *
		 * @option className: String = ''
		 * A custom class name to assign to both icon and shadow images. Empty by default.
		 */

		options: {
			popupAnchor: [0, 0],
			tooltipAnchor: [0, 0]
		},

		initialize: function (options) {
			setOptions(this, options);
		},

		// @method createIcon(oldIcon?: HTMLElement): HTMLElement
		// Called internally when the icon has to be shown, returns a `<img>` HTML element
		// styled according to the options.
		createIcon: function (oldIcon) {
			return this._createIcon('icon', oldIcon);
		},

		// @method createShadow(oldIcon?: HTMLElement): HTMLElement
		// As `createIcon`, but for the shadow beneath it.
		createShadow: function (oldIcon) {
			return this._createIcon('shadow', oldIcon);
		},

		_createIcon: function (name, oldIcon) {
			var src = this._getIconUrl(name);

			if (!src) {
				if (name === 'icon') {
					throw new Error('iconUrl not set in Icon options (see the docs).');
				}
				return null;
			}

			var img = this._createImg(src, oldIcon && oldIcon.tagName === 'IMG' ? oldIcon : null);
			this._setIconStyles(img, name);

			return img;
		},

		_setIconStyles: function (img, name) {
			var options = this.options;
			var sizeOption = options[name + 'Size'];

			if (typeof sizeOption === 'number') {
				sizeOption = [sizeOption, sizeOption];
			}

			var size = toPoint(sizeOption),
			    anchor = toPoint(name === 'shadow' && options.shadowAnchor || options.iconAnchor ||
			            size && size.divideBy(2, true));

			img.className = 'leaflet-marker-' + name + ' ' + (options.className || '');

			if (anchor) {
				img.style.marginLeft = (-anchor.x) + 'px';
				img.style.marginTop  = (-anchor.y) + 'px';
			}

			if (size) {
				img.style.width  = size.x + 'px';
				img.style.height = size.y + 'px';
			}
		},

		_createImg: function (src, el) {
			el = el || document.createElement('img');
			el.src = src;
			return el;
		},

		_getIconUrl: function (name) {
			return retina && this.options[name + 'RetinaUrl'] || this.options[name + 'Url'];
		}
	});

	/*
	 * @miniclass Icon.Default (Icon)
	 * @aka L.Icon.Default
	 * @section
	 *
	 * A trivial subclass of `Icon`, represents the icon to use in `Marker`s when
	 * no icon is specified. Points to the blue marker image distributed with Leaflet
	 * releases.
	 *
	 * In order to customize the default icon, just change the properties of `L.Icon.Default.prototype.options`
	 * (which is a set of `Icon options`).
	 *
	 * If you want to _completely_ replace the default icon, override the
	 * `L.Marker.prototype.options.icon` with your own icon instead.
	 */

	var IconDefault = Icon.extend({

		options: {
			iconUrl:       'marker-icon.png',
			iconRetinaUrl: 'marker-icon-2x.png',
			shadowUrl:     'marker-shadow.png',
			iconSize:    [25, 41],
			iconAnchor:  [12, 41],
			popupAnchor: [1, -34],
			tooltipAnchor: [16, -28],
			shadowSize:  [41, 41]
		},

		_getIconUrl: function (name) {
			if (!IconDefault.imagePath) {	// Deprecated, backwards-compatibility only
				IconDefault.imagePath = this._detectIconPath();
			}

			// @option imagePath: String
			// `Icon.Default` will try to auto-detect the location of the
			// blue icon images. If you are placing these images in a non-standard
			// way, set this option to point to the right path.
			return (this.options.imagePath || IconDefault.imagePath) + Icon.prototype._getIconUrl.call(this, name);
		},

		_detectIconPath: function () {
			var el = create$1$1('div',  'leaflet-default-icon-path', document.body);
			var path = getStyle(el, 'background-image') ||
			           getStyle(el, 'backgroundImage');	// IE8

			document.body.removeChild(el);

			if (path === null || path.indexOf('url') !== 0) {
				path = '';
			} else {
				path = path.replace(/^url\(["']?/, '').replace(/marker-icon\.png["']?\)$/, '');
			}

			return path;
		}
	});

	/*
	 * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.
	 */


	/* @namespace Marker
	 * @section Interaction handlers
	 *
	 * Interaction handlers are properties of a marker instance that allow you to control interaction behavior in runtime, enabling or disabling certain features such as dragging (see `Handler` methods). Example:
	 *
	 * ```js
	 * marker.dragging.disable();
	 * ```
	 *
	 * @property dragging: Handler
	 * Marker dragging handler (by both mouse and touch). Only valid when the marker is on the map (Otherwise set [`marker.options.draggable`](#marker-draggable)).
	 */

	var MarkerDrag = Handler.extend({
		initialize: function (marker) {
			this._marker = marker;
		},

		addHooks: function () {
			var icon = this._marker._icon;

			if (!this._draggable) {
				this._draggable = new Draggable(icon, icon, true);
			}

			this._draggable.on({
				dragstart: this._onDragStart,
				predrag: this._onPreDrag,
				drag: this._onDrag,
				dragend: this._onDragEnd
			}, this).enable();

			addClass(icon, 'leaflet-marker-draggable');
		},

		removeHooks: function () {
			this._draggable.off({
				dragstart: this._onDragStart,
				predrag: this._onPreDrag,
				drag: this._onDrag,
				dragend: this._onDragEnd
			}, this).disable();

			if (this._marker._icon) {
				removeClass(this._marker._icon, 'leaflet-marker-draggable');
			}
		},

		moved: function () {
			return this._draggable && this._draggable._moved;
		},

		_adjustPan: function (e) {
			var marker = this._marker,
			    map = marker._map,
			    speed = this._marker.options.autoPanSpeed,
			    padding = this._marker.options.autoPanPadding,
			    iconPos = getPosition$1(marker._icon),
			    bounds = map.getPixelBounds(),
			    origin = map.getPixelOrigin();

			var panBounds = toBounds(
				bounds.min._subtract(origin).add(padding),
				bounds.max._subtract(origin).subtract(padding)
			);

			if (!panBounds.contains(iconPos)) {
				// Compute incremental movement
				var movement = toPoint(
					(Math.max(panBounds.max.x, iconPos.x) - panBounds.max.x) / (bounds.max.x - panBounds.max.x) -
					(Math.min(panBounds.min.x, iconPos.x) - panBounds.min.x) / (bounds.min.x - panBounds.min.x),

					(Math.max(panBounds.max.y, iconPos.y) - panBounds.max.y) / (bounds.max.y - panBounds.max.y) -
					(Math.min(panBounds.min.y, iconPos.y) - panBounds.min.y) / (bounds.min.y - panBounds.min.y)
				).multiplyBy(speed);

				map.panBy(movement, {animate: false});

				this._draggable._newPos._add(movement);
				this._draggable._startPos._add(movement);

				setPosition(marker._icon, this._draggable._newPos);
				this._onDrag(e);

				this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
			}
		},

		_onDragStart: function () {
			// @section Dragging events
			// @event dragstart: Event
			// Fired when the user starts dragging the marker.

			// @event movestart: Event
			// Fired when the marker starts moving (because of dragging).

			this._oldLatLng = this._marker.getLatLng();
			this._marker
			    .closePopup()
			    .fire('movestart')
			    .fire('dragstart');
		},

		_onPreDrag: function (e) {
			if (this._marker.options.autoPan) {
				cancelAnimFrame(this._panRequest);
				this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
			}
		},

		_onDrag: function (e) {
			var marker = this._marker,
			    shadow = marker._shadow,
			    iconPos = getPosition$1(marker._icon),
			    latlng = marker._map.layerPointToLatLng(iconPos);

			// update shadow position
			if (shadow) {
				setPosition(shadow, iconPos);
			}

			marker._latlng = latlng;
			e.latlng = latlng;
			e.oldLatLng = this._oldLatLng;

			// @event drag: Event
			// Fired repeatedly while the user drags the marker.
			marker
			    .fire('move', e)
			    .fire('drag', e);
		},

		_onDragEnd: function (e) {
			// @event dragend: DragEndEvent
			// Fired when the user stops dragging the marker.

			 cancelAnimFrame(this._panRequest);

			// @event moveend: Event
			// Fired when the marker stops moving (because of dragging).
			delete this._oldLatLng;
			this._marker
			    .fire('moveend')
			    .fire('dragend', e);
		}
	});

	/*
	 * @class Marker
	 * @inherits Interactive layer
	 * @aka L.Marker
	 * L.Marker is used to display clickable/draggable icons on the map. Extends `Layer`.
	 *
	 * @example
	 *
	 * ```js
	 * L.marker([50.5, 30.5]).addTo(map);
	 * ```
	 */

	var Marker = Layer.extend({

		// @section
		// @aka Marker options
		options: {
			// @option icon: Icon = *
			// Icon instance to use for rendering the marker.
			// See [Icon documentation](#L.Icon) for details on how to customize the marker icon.
			// If not specified, a common instance of `L.Icon.Default` is used.
			icon: new IconDefault(),

			// Option inherited from "Interactive layer" abstract class
			interactive: true,

			// @option keyboard: Boolean = true
			// Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.
			keyboard: true,

			// @option title: String = ''
			// Text for the browser tooltip that appear on marker hover (no tooltip by default).
			title: '',

			// @option alt: String = ''
			// Text for the `alt` attribute of the icon image (useful for accessibility).
			alt: '',

			// @option zIndexOffset: Number = 0
			// By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).
			zIndexOffset: 0,

			// @option opacity: Number = 1.0
			// The opacity of the marker.
			opacity: 1,

			// @option riseOnHover: Boolean = false
			// If `true`, the marker will get on top of others when you hover the mouse over it.
			riseOnHover: false,

			// @option riseOffset: Number = 250
			// The z-index offset used for the `riseOnHover` feature.
			riseOffset: 250,

			// @option pane: String = 'markerPane'
			// `Map pane` where the markers icon will be added.
			pane: 'markerPane',

			// @option pane: String = 'shadowPane'
			// `Map pane` where the markers shadow will be added.
			shadowPane: 'shadowPane',

			// @option bubblingMouseEvents: Boolean = false
			// When `true`, a mouse event on this marker will trigger the same event on the map
			// (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
			bubblingMouseEvents: false,

			// @section Draggable marker options
			// @option draggable: Boolean = false
			// Whether the marker is draggable with mouse/touch or not.
			draggable: false,

			// @option autoPan: Boolean = false
			// Whether to pan the map when dragging this marker near its edge or not.
			autoPan: false,

			// @option autoPanPadding: Point = Point(50, 50)
			// Distance (in pixels to the left/right and to the top/bottom) of the
			// map edge to start panning the map.
			autoPanPadding: [50, 50],

			// @option autoPanSpeed: Number = 10
			// Number of pixels the map should pan by.
			autoPanSpeed: 10
		},

		/* @section
		 *
		 * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:
		 */

		initialize: function (latlng, options) {
			setOptions(this, options);
			this._latlng = toLatLng(latlng);
		},

		onAdd: function (map) {
			this._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;

			if (this._zoomAnimated) {
				map.on('zoomanim', this._animateZoom, this);
			}

			this._initIcon();
			this.update();
		},

		onRemove: function (map) {
			if (this.dragging && this.dragging.enabled()) {
				this.options.draggable = true;
				this.dragging.removeHooks();
			}
			delete this.dragging;

			if (this._zoomAnimated) {
				map.off('zoomanim', this._animateZoom, this);
			}

			this._removeIcon();
			this._removeShadow();
		},

		getEvents: function () {
			return {
				zoom: this.update,
				viewreset: this.update
			};
		},

		// @method getLatLng: LatLng
		// Returns the current geographical position of the marker.
		getLatLng: function () {
			return this._latlng;
		},

		// @method setLatLng(latlng: LatLng): this
		// Changes the marker position to the given point.
		setLatLng: function (latlng) {
			var oldLatLng = this._latlng;
			this._latlng = toLatLng(latlng);
			this.update();

			// @event move: Event
			// Fired when the marker is moved via [`setLatLng`](#marker-setlatlng) or by [dragging](#marker-dragging). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.
			return this.fire('move', {oldLatLng: oldLatLng, latlng: this._latlng});
		},

		// @method setZIndexOffset(offset: Number): this
		// Changes the [zIndex offset](#marker-zindexoffset) of the marker.
		setZIndexOffset: function (offset) {
			this.options.zIndexOffset = offset;
			return this.update();
		},

		// @method getIcon: Icon
		// Returns the current icon used by the marker
		getIcon: function () {
			return this.options.icon;
		},

		// @method setIcon(icon: Icon): this
		// Changes the marker icon.
		setIcon: function (icon) {

			this.options.icon = icon;

			if (this._map) {
				this._initIcon();
				this.update();
			}

			if (this._popup) {
				this.bindPopup(this._popup, this._popup.options);
			}

			return this;
		},

		getElement: function () {
			return this._icon;
		},

		update: function () {

			if (this._icon && this._map) {
				var pos = this._map.latLngToLayerPoint(this._latlng).round();
				this._setPos(pos);
			}

			return this;
		},

		_initIcon: function () {
			var options = this.options,
			    classToAdd = 'leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');

			var icon = options.icon.createIcon(this._icon),
			    addIcon = false;

			// if we're not reusing the icon, remove the old one and init new one
			if (icon !== this._icon) {
				if (this._icon) {
					this._removeIcon();
				}
				addIcon = true;

				if (options.title) {
					icon.title = options.title;
				}

				if (icon.tagName === 'IMG') {
					icon.alt = options.alt || '';
				}
			}

			addClass(icon, classToAdd);

			if (options.keyboard) {
				icon.tabIndex = '0';
			}

			this._icon = icon;

			if (options.riseOnHover) {
				this.on({
					mouseover: this._bringToFront,
					mouseout: this._resetZIndex
				});
			}

			var newShadow = options.icon.createShadow(this._shadow),
			    addShadow = false;

			if (newShadow !== this._shadow) {
				this._removeShadow();
				addShadow = true;
			}

			if (newShadow) {
				addClass(newShadow, classToAdd);
				newShadow.alt = '';
			}
			this._shadow = newShadow;


			if (options.opacity < 1) {
				this._updateOpacity();
			}


			if (addIcon) {
				this.getPane().appendChild(this._icon);
			}
			this._initInteraction();
			if (newShadow && addShadow) {
				this.getPane(options.shadowPane).appendChild(this._shadow);
			}
		},

		_removeIcon: function () {
			if (this.options.riseOnHover) {
				this.off({
					mouseover: this._bringToFront,
					mouseout: this._resetZIndex
				});
			}

			remove(this._icon);
			this.removeInteractiveTarget(this._icon);

			this._icon = null;
		},

		_removeShadow: function () {
			if (this._shadow) {
				remove(this._shadow);
			}
			this._shadow = null;
		},

		_setPos: function (pos) {

			if (this._icon) {
				setPosition(this._icon, pos);
			}

			if (this._shadow) {
				setPosition(this._shadow, pos);
			}

			this._zIndex = pos.y + this.options.zIndexOffset;

			this._resetZIndex();
		},

		_updateZIndex: function (offset) {
			if (this._icon) {
				this._icon.style.zIndex = this._zIndex + offset;
			}
		},

		_animateZoom: function (opt) {
			var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();

			this._setPos(pos);
		},

		_initInteraction: function () {

			if (!this.options.interactive) { return; }

			addClass(this._icon, 'leaflet-interactive');

			this.addInteractiveTarget(this._icon);

			if (MarkerDrag) {
				var draggable = this.options.draggable;
				if (this.dragging) {
					draggable = this.dragging.enabled();
					this.dragging.disable();
				}

				this.dragging = new MarkerDrag(this);

				if (draggable) {
					this.dragging.enable();
				}
			}
		},

		// @method setOpacity(opacity: Number): this
		// Changes the opacity of the marker.
		setOpacity: function (opacity) {
			this.options.opacity = opacity;
			if (this._map) {
				this._updateOpacity();
			}

			return this;
		},

		_updateOpacity: function () {
			var opacity = this.options.opacity;

			if (this._icon) {
				setOpacity(this._icon, opacity);
			}

			if (this._shadow) {
				setOpacity(this._shadow, opacity);
			}
		},

		_bringToFront: function () {
			this._updateZIndex(this.options.riseOffset);
		},

		_resetZIndex: function () {
			this._updateZIndex(0);
		},

		_getPopupAnchor: function () {
			return this.options.icon.options.popupAnchor;
		},

		_getTooltipAnchor: function () {
			return this.options.icon.options.tooltipAnchor;
		}
	});

	/*
	 * @class Path
	 * @aka L.Path
	 * @inherits Interactive layer
	 *
	 * An abstract class that contains options and constants shared between vector
	 * overlays (Polygon, Polyline, Circle). Do not use it directly. Extends `Layer`.
	 */

	var Path = Layer.extend({

		// @section
		// @aka Path options
		options: {
			// @option stroke: Boolean = true
			// Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.
			stroke: true,

			// @option color: String = '#3388ff'
			// Stroke color
			color: '#3388ff',

			// @option weight: Number = 3
			// Stroke width in pixels
			weight: 3,

			// @option opacity: Number = 1.0
			// Stroke opacity
			opacity: 1,

			// @option lineCap: String= 'round'
			// A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.
			lineCap: 'round',

			// @option lineJoin: String = 'round'
			// A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.
			lineJoin: 'round',

			// @option dashArray: String = null
			// A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
			dashArray: null,

			// @option dashOffset: String = null
			// A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
			dashOffset: null,

			// @option fill: Boolean = depends
			// Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.
			fill: false,

			// @option fillColor: String = *
			// Fill color. Defaults to the value of the [`color`](#path-color) option
			fillColor: null,

			// @option fillOpacity: Number = 0.2
			// Fill opacity.
			fillOpacity: 0.2,

			// @option fillRule: String = 'evenodd'
			// A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.
			fillRule: 'evenodd',

			// className: '',

			// Option inherited from "Interactive layer" abstract class
			interactive: true,

			// @option bubblingMouseEvents: Boolean = true
			// When `true`, a mouse event on this path will trigger the same event on the map
			// (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
			bubblingMouseEvents: true
		},

		beforeAdd: function (map) {
			// Renderer is set here because we need to call renderer.getEvents
			// before this.getEvents.
			this._renderer = map.getRenderer(this);
		},

		onAdd: function () {
			this._renderer._initPath(this);
			this._reset();
			this._renderer._addPath(this);
		},

		onRemove: function () {
			this._renderer._removePath(this);
		},

		// @method redraw(): this
		// Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.
		redraw: function () {
			if (this._map) {
				this._renderer._updatePath(this);
			}
			return this;
		},

		// @method setStyle(style: Path options): this
		// Changes the appearance of a Path based on the options in the `Path options` object.
		setStyle: function (style) {
			setOptions(this, style);
			if (this._renderer) {
				this._renderer._updateStyle(this);
				if (this.options.stroke && style && style.hasOwnProperty('weight')) {
					this._updateBounds();
				}
			}
			return this;
		},

		// @method bringToFront(): this
		// Brings the layer to the top of all path layers.
		bringToFront: function () {
			if (this._renderer) {
				this._renderer._bringToFront(this);
			}
			return this;
		},

		// @method bringToBack(): this
		// Brings the layer to the bottom of all path layers.
		bringToBack: function () {
			if (this._renderer) {
				this._renderer._bringToBack(this);
			}
			return this;
		},

		getElement: function () {
			return this._path;
		},

		_reset: function () {
			// defined in child classes
			this._project();
			this._update();
		},

		_clickTolerance: function () {
			// used when doing hit detection for Canvas layers
			return (this.options.stroke ? this.options.weight / 2 : 0) + this._renderer.options.tolerance;
		}
	});

	/*
	 * @class CircleMarker
	 * @aka L.CircleMarker
	 * @inherits Path
	 *
	 * A circle of a fixed size with radius specified in pixels. Extends `Path`.
	 */

	var CircleMarker = Path.extend({

		// @section
		// @aka CircleMarker options
		options: {
			fill: true,

			// @option radius: Number = 10
			// Radius of the circle marker, in pixels
			radius: 10
		},

		initialize: function (latlng, options) {
			setOptions(this, options);
			this._latlng = toLatLng(latlng);
			this._radius = this.options.radius;
		},

		// @method setLatLng(latLng: LatLng): this
		// Sets the position of a circle marker to a new location.
		setLatLng: function (latlng) {
			var oldLatLng = this._latlng;
			this._latlng = toLatLng(latlng);
			this.redraw();

			// @event move: Event
			// Fired when the marker is moved via [`setLatLng`](#circlemarker-setlatlng). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.
			return this.fire('move', {oldLatLng: oldLatLng, latlng: this._latlng});
		},

		// @method getLatLng(): LatLng
		// Returns the current geographical position of the circle marker
		getLatLng: function () {
			return this._latlng;
		},

		// @method setRadius(radius: Number): this
		// Sets the radius of a circle marker. Units are in pixels.
		setRadius: function (radius) {
			this.options.radius = this._radius = radius;
			return this.redraw();
		},

		// @method getRadius(): Number
		// Returns the current radius of the circle
		getRadius: function () {
			return this._radius;
		},

		setStyle : function (options) {
			var radius = options && options.radius || this._radius;
			Path.prototype.setStyle.call(this, options);
			this.setRadius(radius);
			return this;
		},

		_project: function () {
			this._point = this._map.latLngToLayerPoint(this._latlng);
			this._updateBounds();
		},

		_updateBounds: function () {
			var r = this._radius,
			    r2 = this._radiusY || r,
			    w = this._clickTolerance(),
			    p = [r + w, r2 + w];
			this._pxBounds = new Bounds(this._point.subtract(p), this._point.add(p));
		},

		_update: function () {
			if (this._map) {
				this._updatePath();
			}
		},

		_updatePath: function () {
			this._renderer._updateCircle(this);
		},

		_empty: function () {
			return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
		},

		// Needed by the `Canvas` renderer for interactivity
		_containsPoint: function (p) {
			return p.distanceTo(this._point) <= this._radius + this._clickTolerance();
		}
	});

	/*
	 * @class Circle
	 * @aka L.Circle
	 * @inherits CircleMarker
	 *
	 * A class for drawing circle overlays on a map. Extends `CircleMarker`.
	 *
	 * It's an approximation and starts to diverge from a real circle closer to poles (due to projection distortion).
	 *
	 * @example
	 *
	 * ```js
	 * L.circle([50.5, 30.5], {radius: 200}).addTo(map);
	 * ```
	 */

	var Circle = CircleMarker.extend({

		initialize: function (latlng, options, legacyOptions) {
			if (typeof options === 'number') {
				// Backwards compatibility with 0.7.x factory (latlng, radius, options?)
				options = extend$1({}, legacyOptions, {radius: options});
			}
			setOptions(this, options);
			this._latlng = toLatLng(latlng);

			if (isNaN(this.options.radius)) { throw new Error('Circle radius cannot be NaN'); }

			// @section
			// @aka Circle options
			// @option radius: Number; Radius of the circle, in meters.
			this._mRadius = this.options.radius;
		},

		// @method setRadius(radius: Number): this
		// Sets the radius of a circle. Units are in meters.
		setRadius: function (radius) {
			this._mRadius = radius;
			return this.redraw();
		},

		// @method getRadius(): Number
		// Returns the current radius of a circle. Units are in meters.
		getRadius: function () {
			return this._mRadius;
		},

		// @method getBounds(): LatLngBounds
		// Returns the `LatLngBounds` of the path.
		getBounds: function () {
			var half = [this._radius, this._radiusY || this._radius];

			return new LatLngBounds(
				this._map.layerPointToLatLng(this._point.subtract(half)),
				this._map.layerPointToLatLng(this._point.add(half)));
		},

		setStyle: Path.prototype.setStyle,

		_project: function () {

			var lng = this._latlng.lng,
			    lat = this._latlng.lat,
			    map = this._map,
			    crs = map.options.crs;

			if (crs.distance === Earth.distance) {
				var d = Math.PI / 180,
				    latR = (this._mRadius / Earth.R) / d,
				    top = map.project([lat + latR, lng]),
				    bottom = map.project([lat - latR, lng]),
				    p = top.add(bottom).divideBy(2),
				    lat2 = map.unproject(p).lat,
				    lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) /
				            (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;

				if (isNaN(lngR) || lngR === 0) {
					lngR = latR / Math.cos(Math.PI / 180 * lat); // Fallback for edge case, #2425
				}

				this._point = p.subtract(map.getPixelOrigin());
				this._radius = isNaN(lngR) ? 0 : p.x - map.project([lat2, lng - lngR]).x;
				this._radiusY = p.y - top.y;

			} else {
				var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));

				this._point = map.latLngToLayerPoint(this._latlng);
				this._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;
			}

			this._updateBounds();
		}
	});

	/*
	 * @class Polyline
	 * @aka L.Polyline
	 * @inherits Path
	 *
	 * A class for drawing polyline overlays on a map. Extends `Path`.
	 *
	 * @example
	 *
	 * ```js
	 * // create a red polyline from an array of LatLng points
	 * var latlngs = [
	 * 	[45.51, -122.68],
	 * 	[37.77, -122.43],
	 * 	[34.04, -118.2]
	 * ];
	 *
	 * var polyline = L.polyline(latlngs, {color: 'red'}).addTo(map);
	 *
	 * // zoom the map to the polyline
	 * map.fitBounds(polyline.getBounds());
	 * ```
	 *
	 * You can also pass a multi-dimensional array to represent a `MultiPolyline` shape:
	 *
	 * ```js
	 * // create a red polyline from an array of arrays of LatLng points
	 * var latlngs = [
	 * 	[[45.51, -122.68],
	 * 	 [37.77, -122.43],
	 * 	 [34.04, -118.2]],
	 * 	[[40.78, -73.91],
	 * 	 [41.83, -87.62],
	 * 	 [32.76, -96.72]]
	 * ];
	 * ```
	 */


	var Polyline$2 = Path.extend({

		// @section
		// @aka Polyline options
		options: {
			// @option smoothFactor: Number = 1.0
			// How much to simplify the polyline on each zoom level. More means
			// better performance and smoother look, and less means more accurate representation.
			smoothFactor: 1.0,

			// @option noClip: Boolean = false
			// Disable polyline clipping.
			noClip: false
		},

		initialize: function (latlngs, options) {
			setOptions(this, options);
			this._setLatLngs(latlngs);
		},

		// @method getLatLngs(): LatLng[]
		// Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.
		getLatLngs: function () {
			return this._latlngs;
		},

		// @method setLatLngs(latlngs: LatLng[]): this
		// Replaces all the points in the polyline with the given array of geographical points.
		setLatLngs: function (latlngs) {
			this._setLatLngs(latlngs);
			return this.redraw();
		},

		// @method isEmpty(): Boolean
		// Returns `true` if the Polyline has no LatLngs.
		isEmpty: function () {
			return !this._latlngs.length;
		},

		// @method closestLayerPoint(p: Point): Point
		// Returns the point closest to `p` on the Polyline.
		closestLayerPoint: function (p) {
			var minDistance = Infinity,
			    minPoint = null,
			    closest = _sqClosestPointOnSegment,
			    p1, p2;

			for (var j = 0, jLen = this._parts.length; j < jLen; j++) {
				var points = this._parts[j];

				for (var i = 1, len = points.length; i < len; i++) {
					p1 = points[i - 1];
					p2 = points[i];

					var sqDist = closest(p, p1, p2, true);

					if (sqDist < minDistance) {
						minDistance = sqDist;
						minPoint = closest(p, p1, p2);
					}
				}
			}
			if (minPoint) {
				minPoint.distance = Math.sqrt(minDistance);
			}
			return minPoint;
		},

		// @method getCenter(): LatLng
		// Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the polyline.
		getCenter: function () {
			// throws error when not yet added to map as this center calculation requires projected coordinates
			if (!this._map) {
				throw new Error('Must add layer to map before using getCenter()');
			}

			var i, halfDist, segDist, dist, p1, p2, ratio,
			    points = this._rings[0],
			    len = points.length;

			if (!len) { return null; }

			// polyline centroid algorithm; only uses the first ring if there are multiple

			for (i = 0, halfDist = 0; i < len - 1; i++) {
				halfDist += points[i].distanceTo(points[i + 1]) / 2;
			}

			// The line is so small in the current view that all points are on the same pixel.
			if (halfDist === 0) {
				return this._map.layerPointToLatLng(points[0]);
			}

			for (i = 0, dist = 0; i < len - 1; i++) {
				p1 = points[i];
				p2 = points[i + 1];
				segDist = p1.distanceTo(p2);
				dist += segDist;

				if (dist > halfDist) {
					ratio = (dist - halfDist) / segDist;
					return this._map.layerPointToLatLng([
						p2.x - ratio * (p2.x - p1.x),
						p2.y - ratio * (p2.y - p1.y)
					]);
				}
			}
		},

		// @method getBounds(): LatLngBounds
		// Returns the `LatLngBounds` of the path.
		getBounds: function () {
			return this._bounds;
		},

		// @method addLatLng(latlng: LatLng, latlngs? LatLng[]): this
		// Adds a given point to the polyline. By default, adds to the first ring of
		// the polyline in case of a multi-polyline, but can be overridden by passing
		// a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).
		addLatLng: function (latlng, latlngs) {
			latlngs = latlngs || this._defaultShape();
			latlng = toLatLng(latlng);
			latlngs.push(latlng);
			this._bounds.extend(latlng);
			return this.redraw();
		},

		_setLatLngs: function (latlngs) {
			this._bounds = new LatLngBounds();
			this._latlngs = this._convertLatLngs(latlngs);
		},

		_defaultShape: function () {
			return isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];
		},

		// recursively convert latlngs input into actual LatLng instances; calculate bounds along the way
		_convertLatLngs: function (latlngs) {
			var result = [],
			    flat = isFlat(latlngs);

			for (var i = 0, len = latlngs.length; i < len; i++) {
				if (flat) {
					result[i] = toLatLng(latlngs[i]);
					this._bounds.extend(result[i]);
				} else {
					result[i] = this._convertLatLngs(latlngs[i]);
				}
			}

			return result;
		},

		_project: function () {
			var pxBounds = new Bounds();
			this._rings = [];
			this._projectLatlngs(this._latlngs, this._rings, pxBounds);

			if (this._bounds.isValid() && pxBounds.isValid()) {
				this._rawPxBounds = pxBounds;
				this._updateBounds();
			}
		},

		_updateBounds: function () {
			var w = this._clickTolerance(),
			    p = new Point$1(w, w);
			this._pxBounds = new Bounds([
				this._rawPxBounds.min.subtract(p),
				this._rawPxBounds.max.add(p)
			]);
		},

		// recursively turns latlngs into a set of rings with projected coordinates
		_projectLatlngs: function (latlngs, result, projectedBounds) {
			var flat = latlngs[0] instanceof LatLng,
			    len = latlngs.length,
			    i, ring;

			if (flat) {
				ring = [];
				for (i = 0; i < len; i++) {
					ring[i] = this._map.latLngToLayerPoint(latlngs[i]);
					projectedBounds.extend(ring[i]);
				}
				result.push(ring);
			} else {
				for (i = 0; i < len; i++) {
					this._projectLatlngs(latlngs[i], result, projectedBounds);
				}
			}
		},

		// clip polyline by renderer bounds so that we have less to render for performance
		_clipPoints: function () {
			var bounds = this._renderer._bounds;

			this._parts = [];
			if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
				return;
			}

			if (this.options.noClip) {
				this._parts = this._rings;
				return;
			}

			var parts = this._parts,
			    i, j, k, len, len2, segment, points;

			for (i = 0, k = 0, len = this._rings.length; i < len; i++) {
				points = this._rings[i];

				for (j = 0, len2 = points.length; j < len2 - 1; j++) {
					segment = clipSegment(points[j], points[j + 1], bounds, j, true);

					if (!segment) { continue; }

					parts[k] = parts[k] || [];
					parts[k].push(segment[0]);

					// if segment goes out of screen, or it's the last one, it's the end of the line part
					if ((segment[1] !== points[j + 1]) || (j === len2 - 2)) {
						parts[k].push(segment[1]);
						k++;
					}
				}
			}
		},

		// simplify each clipped part of the polyline for performance
		_simplifyPoints: function () {
			var parts = this._parts,
			    tolerance = this.options.smoothFactor;

			for (var i = 0, len = parts.length; i < len; i++) {
				parts[i] = simplify(parts[i], tolerance);
			}
		},

		_update: function () {
			if (!this._map) { return; }

			this._clipPoints();
			this._simplifyPoints();
			this._updatePath();
		},

		_updatePath: function () {
			this._renderer._updatePoly(this);
		},

		// Needed by the `Canvas` renderer for interactivity
		_containsPoint: function (p, closed) {
			var i, j, k, len, len2, part,
			    w = this._clickTolerance();

			if (!this._pxBounds || !this._pxBounds.contains(p)) { return false; }

			// hit detection for polylines
			for (i = 0, len = this._parts.length; i < len; i++) {
				part = this._parts[i];

				for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
					if (!closed && (j === 0)) { continue; }

					if (pointToSegmentDistance(p, part[k], part[j]) <= w) {
						return true;
					}
				}
			}
			return false;
		}
	});

	// Retrocompat. Allow plugins to support Leaflet versions before and after 1.1.
	Polyline$2._flat = _flat;

	/*
	 * @class Polygon
	 * @aka L.Polygon
	 * @inherits Polyline
	 *
	 * A class for drawing polygon overlays on a map. Extends `Polyline`.
	 *
	 * Note that points you pass when creating a polygon shouldn't have an additional last point equal to the first one — it's better to filter out such points.
	 *
	 *
	 * @example
	 *
	 * ```js
	 * // create a red polygon from an array of LatLng points
	 * var latlngs = [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]];
	 *
	 * var polygon = L.polygon(latlngs, {color: 'red'}).addTo(map);
	 *
	 * // zoom the map to the polygon
	 * map.fitBounds(polygon.getBounds());
	 * ```
	 *
	 * You can also pass an array of arrays of latlngs, with the first array representing the outer shape and the other arrays representing holes in the outer shape:
	 *
	 * ```js
	 * var latlngs = [
	 *   [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring
	 *   [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole
	 * ];
	 * ```
	 *
	 * Additionally, you can pass a multi-dimensional array to represent a MultiPolygon shape.
	 *
	 * ```js
	 * var latlngs = [
	 *   [ // first polygon
	 *     [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring
	 *     [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole
	 *   ],
	 *   [ // second polygon
	 *     [[41, -111.03],[45, -111.04],[45, -104.05],[41, -104.05]]
	 *   ]
	 * ];
	 * ```
	 */

	var Polygon = Polyline$2.extend({

		options: {
			fill: true
		},

		isEmpty: function () {
			return !this._latlngs.length || !this._latlngs[0].length;
		},

		getCenter: function () {
			// throws error when not yet added to map as this center calculation requires projected coordinates
			if (!this._map) {
				throw new Error('Must add layer to map before using getCenter()');
			}

			var i, j, p1, p2, f, area, x, y, center,
			    points = this._rings[0],
			    len = points.length;

			if (!len) { return null; }

			// polygon centroid algorithm; only uses the first ring if there are multiple

			area = x = y = 0;

			for (i = 0, j = len - 1; i < len; j = i++) {
				p1 = points[i];
				p2 = points[j];

				f = p1.y * p2.x - p2.y * p1.x;
				x += (p1.x + p2.x) * f;
				y += (p1.y + p2.y) * f;
				area += f * 3;
			}

			if (area === 0) {
				// Polygon is so small that all points are on same pixel.
				center = points[0];
			} else {
				center = [x / area, y / area];
			}
			return this._map.layerPointToLatLng(center);
		},

		_convertLatLngs: function (latlngs) {
			var result = Polyline$2.prototype._convertLatLngs.call(this, latlngs),
			    len = result.length;

			// remove last point if it equals first one
			if (len >= 2 && result[0] instanceof LatLng && result[0].equals(result[len - 1])) {
				result.pop();
			}
			return result;
		},

		_setLatLngs: function (latlngs) {
			Polyline$2.prototype._setLatLngs.call(this, latlngs);
			if (isFlat(this._latlngs)) {
				this._latlngs = [this._latlngs];
			}
		},

		_defaultShape: function () {
			return isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
		},

		_clipPoints: function () {
			// polygons need a different clipping algorithm so we redefine that

			var bounds = this._renderer._bounds,
			    w = this.options.weight,
			    p = new Point$1(w, w);

			// increase clip padding by stroke width to avoid stroke on clip edges
			bounds = new Bounds(bounds.min.subtract(p), bounds.max.add(p));

			this._parts = [];
			if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
				return;
			}

			if (this.options.noClip) {
				this._parts = this._rings;
				return;
			}

			for (var i = 0, len = this._rings.length, clipped; i < len; i++) {
				clipped = clipPolygon(this._rings[i], bounds, true);
				if (clipped.length) {
					this._parts.push(clipped);
				}
			}
		},

		_updatePath: function () {
			this._renderer._updatePoly(this, true);
		},

		// Needed by the `Canvas` renderer for interactivity
		_containsPoint: function (p) {
			var inside = false,
			    part, p1, p2, i, j, k, len, len2;

			if (!this._pxBounds || !this._pxBounds.contains(p)) { return false; }

			// ray casting algorithm for detecting if point is in polygon
			for (i = 0, len = this._parts.length; i < len; i++) {
				part = this._parts[i];

				for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
					p1 = part[j];
					p2 = part[k];

					if (((p1.y > p.y) !== (p2.y > p.y)) && (p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {
						inside = !inside;
					}
				}
			}

			// also check if it's on polygon stroke
			return inside || Polyline$2.prototype._containsPoint.call(this, p, true);
		}

	});

	/*
	 * @class GeoJSON
	 * @aka L.GeoJSON
	 * @inherits FeatureGroup
	 *
	 * Represents a GeoJSON object or an array of GeoJSON objects. Allows you to parse
	 * GeoJSON data and display it on the map. Extends `FeatureGroup`.
	 *
	 * @example
	 *
	 * ```js
	 * L.geoJSON(data, {
	 * 	style: function (feature) {
	 * 		return {color: feature.properties.color};
	 * 	}
	 * }).bindPopup(function (layer) {
	 * 	return layer.feature.properties.description;
	 * }).addTo(map);
	 * ```
	 */

	var GeoJSON = FeatureGroup.extend({

		/* @section
		 * @aka GeoJSON options
		 *
		 * @option pointToLayer: Function = *
		 * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally
		 * called when data is added, passing the GeoJSON point feature and its `LatLng`.
		 * The default is to spawn a default `Marker`:
		 * ```js
		 * function(geoJsonPoint, latlng) {
		 * 	return L.marker(latlng);
		 * }
		 * ```
		 *
		 * @option style: Function = *
		 * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,
		 * called internally when data is added.
		 * The default value is to not override any defaults:
		 * ```js
		 * function (geoJsonFeature) {
		 * 	return {}
		 * }
		 * ```
		 *
		 * @option onEachFeature: Function = *
		 * A `Function` that will be called once for each created `Feature`, after it has
		 * been created and styled. Useful for attaching events and popups to features.
		 * The default is to do nothing with the newly created layers:
		 * ```js
		 * function (feature, layer) {}
		 * ```
		 *
		 * @option filter: Function = *
		 * A `Function` that will be used to decide whether to include a feature or not.
		 * The default is to include all features:
		 * ```js
		 * function (geoJsonFeature) {
		 * 	return true;
		 * }
		 * ```
		 * Note: dynamically changing the `filter` option will have effect only on newly
		 * added data. It will _not_ re-evaluate already included features.
		 *
		 * @option coordsToLatLng: Function = *
		 * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.
		 * The default is the `coordsToLatLng` static method.
		 *
		 * @option markersInheritOptions: Boolean = false
		 * Whether default Markers for "Point" type Features inherit from group options.
		 */

		initialize: function (geojson, options) {
			setOptions(this, options);

			this._layers = {};

			if (geojson) {
				this.addData(geojson);
			}
		},

		// @method addData( <GeoJSON> data ): this
		// Adds a GeoJSON object to the layer.
		addData: function (geojson) {
			var features = isArray$2(geojson) ? geojson : geojson.features,
			    i, len, feature;

			if (features) {
				for (i = 0, len = features.length; i < len; i++) {
					// only add this if geometry or geometries are set and not null
					feature = features[i];
					if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
						this.addData(feature);
					}
				}
				return this;
			}

			var options = this.options;

			if (options.filter && !options.filter(geojson)) { return this; }

			var layer = geometryToLayer(geojson, options);
			if (!layer) {
				return this;
			}
			layer.feature = asFeature(geojson);

			layer.defaultOptions = layer.options;
			this.resetStyle(layer);

			if (options.onEachFeature) {
				options.onEachFeature(geojson, layer);
			}

			return this.addLayer(layer);
		},

		// @method resetStyle( <Path> layer? ): this
		// Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.
		// If `layer` is omitted, the style of all features in the current layer is reset.
		resetStyle: function (layer) {
			if (layer === undefined) {
				return this.eachLayer(this.resetStyle, this);
			}
			// reset any custom styles
			layer.options = extend$1({}, layer.defaultOptions);
			this._setLayerStyle(layer, this.options.style);
			return this;
		},

		// @method setStyle( <Function> style ): this
		// Changes styles of GeoJSON vector layers with the given style function.
		setStyle: function (style) {
			return this.eachLayer(function (layer) {
				this._setLayerStyle(layer, style);
			}, this);
		},

		_setLayerStyle: function (layer, style) {
			if (layer.setStyle) {
				if (typeof style === 'function') {
					style = style(layer.feature);
				}
				layer.setStyle(style);
			}
		}
	});

	// @section
	// There are several static functions which can be called without instantiating L.GeoJSON:

	// @function geometryToLayer(featureData: Object, options?: GeoJSON options): Layer
	// Creates a `Layer` from a given GeoJSON feature. Can use a custom
	// [`pointToLayer`](#geojson-pointtolayer) and/or [`coordsToLatLng`](#geojson-coordstolatlng)
	// functions if provided as options.
	function geometryToLayer(geojson, options) {

		var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,
		    coords = geometry ? geometry.coordinates : null,
		    layers = [],
		    pointToLayer = options && options.pointToLayer,
		    _coordsToLatLng = options && options.coordsToLatLng || coordsToLatLng,
		    latlng, latlngs, i, len;

		if (!coords && !geometry) {
			return null;
		}

		switch (geometry.type) {
		case 'Point':
			latlng = _coordsToLatLng(coords);
			return _pointToLayer(pointToLayer, geojson, latlng, options);

		case 'MultiPoint':
			for (i = 0, len = coords.length; i < len; i++) {
				latlng = _coordsToLatLng(coords[i]);
				layers.push(_pointToLayer(pointToLayer, geojson, latlng, options));
			}
			return new FeatureGroup(layers);

		case 'LineString':
		case 'MultiLineString':
			latlngs = coordsToLatLngs(coords, geometry.type === 'LineString' ? 0 : 1, _coordsToLatLng);
			return new Polyline$2(latlngs, options);

		case 'Polygon':
		case 'MultiPolygon':
			latlngs = coordsToLatLngs(coords, geometry.type === 'Polygon' ? 1 : 2, _coordsToLatLng);
			return new Polygon(latlngs, options);

		case 'GeometryCollection':
			for (i = 0, len = geometry.geometries.length; i < len; i++) {
				var layer = geometryToLayer({
					geometry: geometry.geometries[i],
					type: 'Feature',
					properties: geojson.properties
				}, options);

				if (layer) {
					layers.push(layer);
				}
			}
			return new FeatureGroup(layers);

		default:
			throw new Error('Invalid GeoJSON object.');
		}
	}

	function _pointToLayer(pointToLayerFn, geojson, latlng, options) {
		return pointToLayerFn ?
			pointToLayerFn(geojson, latlng) :
			new Marker(latlng, options && options.markersInheritOptions && options);
	}

	// @function coordsToLatLng(coords: Array): LatLng
	// Creates a `LatLng` object from an array of 2 numbers (longitude, latitude)
	// or 3 numbers (longitude, latitude, altitude) used in GeoJSON for points.
	function coordsToLatLng(coords) {
		return new LatLng(coords[1], coords[0], coords[2]);
	}

	// @function coordsToLatLngs(coords: Array, levelsDeep?: Number, coordsToLatLng?: Function): Array
	// Creates a multidimensional array of `LatLng`s from a GeoJSON coordinates array.
	// `levelsDeep` specifies the nesting level (0 is for an array of points, 1 for an array of arrays of points, etc., 0 by default).
	// Can use a custom [`coordsToLatLng`](#geojson-coordstolatlng) function.
	function coordsToLatLngs(coords, levelsDeep, _coordsToLatLng) {
		var latlngs = [];

		for (var i = 0, len = coords.length, latlng; i < len; i++) {
			latlng = levelsDeep ?
				coordsToLatLngs(coords[i], levelsDeep - 1, _coordsToLatLng) :
				(_coordsToLatLng || coordsToLatLng)(coords[i]);

			latlngs.push(latlng);
		}

		return latlngs;
	}

	// @function latLngToCoords(latlng: LatLng, precision?: Number): Array
	// Reverse of [`coordsToLatLng`](#geojson-coordstolatlng)
	function latLngToCoords(latlng, precision) {
		precision = typeof precision === 'number' ? precision : 6;
		return latlng.alt !== undefined ?
			[formatNum(latlng.lng, precision), formatNum(latlng.lat, precision), formatNum(latlng.alt, precision)] :
			[formatNum(latlng.lng, precision), formatNum(latlng.lat, precision)];
	}

	// @function latLngsToCoords(latlngs: Array, levelsDeep?: Number, closed?: Boolean): Array
	// Reverse of [`coordsToLatLngs`](#geojson-coordstolatlngs)
	// `closed` determines whether the first point should be appended to the end of the array to close the feature, only used when `levelsDeep` is 0. False by default.
	function latLngsToCoords(latlngs, levelsDeep, closed, precision) {
		var coords = [];

		for (var i = 0, len = latlngs.length; i < len; i++) {
			coords.push(levelsDeep ?
				latLngsToCoords(latlngs[i], levelsDeep - 1, closed, precision) :
				latLngToCoords(latlngs[i], precision));
		}

		if (!levelsDeep && closed) {
			coords.push(coords[0]);
		}

		return coords;
	}

	function getFeature(layer, newGeometry) {
		return layer.feature ?
			extend$1({}, layer.feature, {geometry: newGeometry}) :
			asFeature(newGeometry);
	}

	// @function asFeature(geojson: Object): Object
	// Normalize GeoJSON geometries/features into GeoJSON features.
	function asFeature(geojson) {
		if (geojson.type === 'Feature' || geojson.type === 'FeatureCollection') {
			return geojson;
		}

		return {
			type: 'Feature',
			properties: {},
			geometry: geojson
		};
	}

	var PointToGeoJSON = {
		toGeoJSON: function (precision) {
			return getFeature(this, {
				type: 'Point',
				coordinates: latLngToCoords(this.getLatLng(), precision)
			});
		}
	};

	// @namespace Marker
	// @section Other methods
	// @method toGeoJSON(precision?: Number): Object
	// `precision` is the number of decimal places for coordinates.
	// The default value is 6 places.
	// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the marker (as a GeoJSON `Point` Feature).
	Marker.include(PointToGeoJSON);

	// @namespace CircleMarker
	// @method toGeoJSON(precision?: Number): Object
	// `precision` is the number of decimal places for coordinates.
	// The default value is 6 places.
	// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the circle marker (as a GeoJSON `Point` Feature).
	Circle.include(PointToGeoJSON);
	CircleMarker.include(PointToGeoJSON);


	// @namespace Polyline
	// @method toGeoJSON(precision?: Number): Object
	// `precision` is the number of decimal places for coordinates.
	// The default value is 6 places.
	// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polyline (as a GeoJSON `LineString` or `MultiLineString` Feature).
	Polyline$2.include({
		toGeoJSON: function (precision) {
			var multi = !isFlat(this._latlngs);

			var coords = latLngsToCoords(this._latlngs, multi ? 1 : 0, false, precision);

			return getFeature(this, {
				type: (multi ? 'Multi' : '') + 'LineString',
				coordinates: coords
			});
		}
	});

	// @namespace Polygon
	// @method toGeoJSON(precision?: Number): Object
	// `precision` is the number of decimal places for coordinates.
	// The default value is 6 places.
	// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polygon (as a GeoJSON `Polygon` or `MultiPolygon` Feature).
	Polygon.include({
		toGeoJSON: function (precision) {
			var holes = !isFlat(this._latlngs),
			    multi = holes && !isFlat(this._latlngs[0]);

			var coords = latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true, precision);

			if (!holes) {
				coords = [coords];
			}

			return getFeature(this, {
				type: (multi ? 'Multi' : '') + 'Polygon',
				coordinates: coords
			});
		}
	});


	// @namespace LayerGroup
	LayerGroup.include({
		toMultiPoint: function (precision) {
			var coords = [];

			this.eachLayer(function (layer) {
				coords.push(layer.toGeoJSON(precision).geometry.coordinates);
			});

			return getFeature(this, {
				type: 'MultiPoint',
				coordinates: coords
			});
		},

		// @method toGeoJSON(precision?: Number): Object
		// `precision` is the number of decimal places for coordinates.
		// The default value is 6 places.
		// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `FeatureCollection`, `GeometryCollection`, or `MultiPoint`).
		toGeoJSON: function (precision) {

			var type = this.feature && this.feature.geometry && this.feature.geometry.type;

			if (type === 'MultiPoint') {
				return this.toMultiPoint(precision);
			}

			var isGeometryCollection = type === 'GeometryCollection',
			    jsons = [];

			this.eachLayer(function (layer) {
				if (layer.toGeoJSON) {
					var json = layer.toGeoJSON(precision);
					if (isGeometryCollection) {
						jsons.push(json.geometry);
					} else {
						var feature = asFeature(json);
						// Squash nested feature collections
						if (feature.type === 'FeatureCollection') {
							jsons.push.apply(jsons, feature.features);
						} else {
							jsons.push(feature);
						}
					}
				}
			});

			if (isGeometryCollection) {
				return getFeature(this, {
					geometries: jsons,
					type: 'GeometryCollection'
				});
			}

			return {
				type: 'FeatureCollection',
				features: jsons
			};
		}
	});

	/*
	 * @class ImageOverlay
	 * @aka L.ImageOverlay
	 * @inherits Interactive layer
	 *
	 * Used to load and display a single image over specific bounds of the map. Extends `Layer`.
	 *
	 * @example
	 *
	 * ```js
	 * var imageUrl = 'http://www.lib.utexas.edu/maps/historical/newark_nj_1922.jpg',
	 * 	imageBounds = [[40.712216, -74.22655], [40.773941, -74.12544]];
	 * L.imageOverlay(imageUrl, imageBounds).addTo(map);
	 * ```
	 */

	var ImageOverlay = Layer.extend({

		// @section
		// @aka ImageOverlay options
		options: {
			// @option opacity: Number = 1.0
			// The opacity of the image overlay.
			opacity: 1,

			// @option alt: String = ''
			// Text for the `alt` attribute of the image (useful for accessibility).
			alt: '',

			// @option interactive: Boolean = false
			// If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.
			interactive: false,

			// @option crossOrigin: Boolean|String = false
			// Whether the crossOrigin attribute will be added to the image.
			// If a String is provided, the image will have its crossOrigin attribute set to the String provided. This is needed if you want to access image pixel data.
			// Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
			crossOrigin: false,

			// @option errorOverlayUrl: String = ''
			// URL to the overlay image to show in place of the overlay that failed to load.
			errorOverlayUrl: '',

			// @option zIndex: Number = 1
			// The explicit [zIndex](https://developer.mozilla.org/docs/Web/CSS/CSS_Positioning/Understanding_z_index) of the overlay layer.
			zIndex: 1,

			// @option className: String = ''
			// A custom class name to assign to the image. Empty by default.
			className: ''
		},

		initialize: function (url, bounds, options) { // (String, LatLngBounds, Object)
			this._url = url;
			this._bounds = toLatLngBounds(bounds);

			setOptions(this, options);
		},

		onAdd: function () {
			if (!this._image) {
				this._initImage();

				if (this.options.opacity < 1) {
					this._updateOpacity();
				}
			}

			if (this.options.interactive) {
				addClass(this._image, 'leaflet-interactive');
				this.addInteractiveTarget(this._image);
			}

			this.getPane().appendChild(this._image);
			this._reset();
		},

		onRemove: function () {
			remove(this._image);
			if (this.options.interactive) {
				this.removeInteractiveTarget(this._image);
			}
		},

		// @method setOpacity(opacity: Number): this
		// Sets the opacity of the overlay.
		setOpacity: function (opacity) {
			this.options.opacity = opacity;

			if (this._image) {
				this._updateOpacity();
			}
			return this;
		},

		setStyle: function (styleOpts) {
			if (styleOpts.opacity) {
				this.setOpacity(styleOpts.opacity);
			}
			return this;
		},

		// @method bringToFront(): this
		// Brings the layer to the top of all overlays.
		bringToFront: function () {
			if (this._map) {
				toFront(this._image);
			}
			return this;
		},

		// @method bringToBack(): this
		// Brings the layer to the bottom of all overlays.
		bringToBack: function () {
			if (this._map) {
				toBack(this._image);
			}
			return this;
		},

		// @method setUrl(url: String): this
		// Changes the URL of the image.
		setUrl: function (url) {
			this._url = url;

			if (this._image) {
				this._image.src = url;
			}
			return this;
		},

		// @method setBounds(bounds: LatLngBounds): this
		// Update the bounds that this ImageOverlay covers
		setBounds: function (bounds) {
			this._bounds = toLatLngBounds(bounds);

			if (this._map) {
				this._reset();
			}
			return this;
		},

		getEvents: function () {
			var events = {
				zoom: this._reset,
				viewreset: this._reset
			};

			if (this._zoomAnimated) {
				events.zoomanim = this._animateZoom;
			}

			return events;
		},

		// @method setZIndex(value: Number): this
		// Changes the [zIndex](#imageoverlay-zindex) of the image overlay.
		setZIndex: function (value) {
			this.options.zIndex = value;
			this._updateZIndex();
			return this;
		},

		// @method getBounds(): LatLngBounds
		// Get the bounds that this ImageOverlay covers
		getBounds: function () {
			return this._bounds;
		},

		// @method getElement(): HTMLElement
		// Returns the instance of [`HTMLImageElement`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)
		// used by this overlay.
		getElement: function () {
			return this._image;
		},

		_initImage: function () {
			var wasElementSupplied = this._url.tagName === 'IMG';
			var img = this._image = wasElementSupplied ? this._url : create$1$1('img');

			addClass(img, 'leaflet-image-layer');
			if (this._zoomAnimated) { addClass(img, 'leaflet-zoom-animated'); }
			if (this.options.className) { addClass(img, this.options.className); }

			img.onselectstart = falseFn;
			img.onmousemove = falseFn;

			// @event load: Event
			// Fired when the ImageOverlay layer has loaded its image
			img.onload = bind(this.fire, this, 'load');
			img.onerror = bind(this._overlayOnError, this, 'error');

			if (this.options.crossOrigin || this.options.crossOrigin === '') {
				img.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;
			}

			if (this.options.zIndex) {
				this._updateZIndex();
			}

			if (wasElementSupplied) {
				this._url = img.src;
				return;
			}

			img.src = this._url;
			img.alt = this.options.alt;
		},

		_animateZoom: function (e) {
			var scale = this._map.getZoomScale(e.zoom),
			    offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e.zoom, e.center).min;

			setTransform(this._image, offset, scale);
		},

		_reset: function () {
			var image = this._image,
			    bounds = new Bounds(
			        this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
			        this._map.latLngToLayerPoint(this._bounds.getSouthEast())),
			    size = bounds.getSize();

			setPosition(image, bounds.min);

			image.style.width  = size.x + 'px';
			image.style.height = size.y + 'px';
		},

		_updateOpacity: function () {
			setOpacity(this._image, this.options.opacity);
		},

		_updateZIndex: function () {
			if (this._image && this.options.zIndex !== undefined && this.options.zIndex !== null) {
				this._image.style.zIndex = this.options.zIndex;
			}
		},

		_overlayOnError: function () {
			// @event error: Event
			// Fired when the ImageOverlay layer fails to load its image
			this.fire('error');

			var errorUrl = this.options.errorOverlayUrl;
			if (errorUrl && this._url !== errorUrl) {
				this._url = errorUrl;
				this._image.src = errorUrl;
			}
		}
	});

	/*
	 * @class VideoOverlay
	 * @aka L.VideoOverlay
	 * @inherits ImageOverlay
	 *
	 * Used to load and display a video player over specific bounds of the map. Extends `ImageOverlay`.
	 *
	 * A video overlay uses the [`<video>`](https://developer.mozilla.org/docs/Web/HTML/Element/video)
	 * HTML5 element.
	 *
	 * @example
	 *
	 * ```js
	 * var videoUrl = 'https://www.mapbox.com/bites/00188/patricia_nasa.webm',
	 * 	videoBounds = [[ 32, -130], [ 13, -100]];
	 * L.videoOverlay(videoUrl, videoBounds ).addTo(map);
	 * ```
	 */

	var VideoOverlay = ImageOverlay.extend({

		// @section
		// @aka VideoOverlay options
		options: {
			// @option autoplay: Boolean = true
			// Whether the video starts playing automatically when loaded.
			autoplay: true,

			// @option loop: Boolean = true
			// Whether the video will loop back to the beginning when played.
			loop: true,

			// @option keepAspectRatio: Boolean = true
			// Whether the video will save aspect ratio after the projection.
			// Relevant for supported browsers. Browser compatibility- https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit
			keepAspectRatio: true
		},

		_initImage: function () {
			var wasElementSupplied = this._url.tagName === 'VIDEO';
			var vid = this._image = wasElementSupplied ? this._url : create$1$1('video');

			addClass(vid, 'leaflet-image-layer');
			if (this._zoomAnimated) { addClass(vid, 'leaflet-zoom-animated'); }
			if (this.options.className) { addClass(vid, this.options.className); }

			vid.onselectstart = falseFn;
			vid.onmousemove = falseFn;

			// @event load: Event
			// Fired when the video has finished loading the first frame
			vid.onloadeddata = bind(this.fire, this, 'load');

			if (wasElementSupplied) {
				var sourceElements = vid.getElementsByTagName('source');
				var sources = [];
				for (var j = 0; j < sourceElements.length; j++) {
					sources.push(sourceElements[j].src);
				}

				this._url = (sourceElements.length > 0) ? sources : [vid.src];
				return;
			}

			if (!isArray$2(this._url)) { this._url = [this._url]; }

			if (!this.options.keepAspectRatio && vid.style.hasOwnProperty('objectFit')) { vid.style['objectFit'] = 'fill'; }
			vid.autoplay = !!this.options.autoplay;
			vid.loop = !!this.options.loop;
			for (var i = 0; i < this._url.length; i++) {
				var source = create$1$1('source');
				source.src = this._url[i];
				vid.appendChild(source);
			}
		}

		// @method getElement(): HTMLVideoElement
		// Returns the instance of [`HTMLVideoElement`](https://developer.mozilla.org/docs/Web/API/HTMLVideoElement)
		// used by this overlay.
	});

	/*
	 * @class SVGOverlay
	 * @aka L.SVGOverlay
	 * @inherits ImageOverlay
	 *
	 * Used to load, display and provide DOM access to an SVG file over specific bounds of the map. Extends `ImageOverlay`.
	 *
	 * An SVG overlay uses the [`<svg>`](https://developer.mozilla.org/docs/Web/SVG/Element/svg) element.
	 *
	 * @example
	 *
	 * ```js
	 * var svgElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
	 * svgElement.setAttribute('xmlns', "http://www.w3.org/2000/svg");
	 * svgElement.setAttribute('viewBox', "0 0 200 200");
	 * svgElement.innerHTML = '<rect width="200" height="200"/><rect x="75" y="23" width="50" height="50" style="fill:red"/><rect x="75" y="123" width="50" height="50" style="fill:#0013ff"/>';
	 * var svgElementBounds = [ [ 32, -130 ], [ 13, -100 ] ];
	 * L.svgOverlay(svgElement, svgElementBounds).addTo(map);
	 * ```
	 */

	var SVGOverlay = ImageOverlay.extend({
		_initImage: function () {
			var el = this._image = this._url;

			addClass(el, 'leaflet-image-layer');
			if (this._zoomAnimated) { addClass(el, 'leaflet-zoom-animated'); }
			if (this.options.className) { addClass(el, this.options.className); }

			el.onselectstart = falseFn;
			el.onmousemove = falseFn;
		}

		// @method getElement(): SVGElement
		// Returns the instance of [`SVGElement`](https://developer.mozilla.org/docs/Web/API/SVGElement)
		// used by this overlay.
	});

	/*
	 * @class DivOverlay
	 * @inherits Layer
	 * @aka L.DivOverlay
	 * Base model for L.Popup and L.Tooltip. Inherit from it for custom popup like plugins.
	 */

	// @namespace DivOverlay
	var DivOverlay = Layer.extend({

		// @section
		// @aka DivOverlay options
		options: {
			// @option offset: Point = Point(0, 7)
			// The offset of the popup position. Useful to control the anchor
			// of the popup when opening it on some overlays.
			offset: [0, 7],

			// @option className: String = ''
			// A custom CSS class name to assign to the popup.
			className: '',

			// @option pane: String = 'popupPane'
			// `Map pane` where the popup will be added.
			pane: 'popupPane'
		},

		initialize: function (options, source) {
			setOptions(this, options);

			this._source = source;
		},

		onAdd: function (map) {
			this._zoomAnimated = map._zoomAnimated;

			if (!this._container) {
				this._initLayout();
			}

			if (map._fadeAnimated) {
				setOpacity(this._container, 0);
			}

			clearTimeout(this._removeTimeout);
			this.getPane().appendChild(this._container);
			this.update();

			if (map._fadeAnimated) {
				setOpacity(this._container, 1);
			}

			this.bringToFront();
		},

		onRemove: function (map) {
			if (map._fadeAnimated) {
				setOpacity(this._container, 0);
				this._removeTimeout = setTimeout(bind(remove, undefined, this._container), 200);
			} else {
				remove(this._container);
			}
		},

		// @namespace Popup
		// @method getLatLng: LatLng
		// Returns the geographical point of popup.
		getLatLng: function () {
			return this._latlng;
		},

		// @method setLatLng(latlng: LatLng): this
		// Sets the geographical point where the popup will open.
		setLatLng: function (latlng) {
			this._latlng = toLatLng(latlng);
			if (this._map) {
				this._updatePosition();
				this._adjustPan();
			}
			return this;
		},

		// @method getContent: String|HTMLElement
		// Returns the content of the popup.
		getContent: function () {
			return this._content;
		},

		// @method setContent(htmlContent: String|HTMLElement|Function): this
		// Sets the HTML content of the popup. If a function is passed the source layer will be passed to the function. The function should return a `String` or `HTMLElement` to be used in the popup.
		setContent: function (content) {
			this._content = content;
			this.update();
			return this;
		},

		// @method getElement: String|HTMLElement
		// Alias for [getContent()](#popup-getcontent)
		getElement: function () {
			return this._container;
		},

		// @method update: null
		// Updates the popup content, layout and position. Useful for updating the popup after something inside changed, e.g. image loaded.
		update: function () {
			if (!this._map) { return; }

			this._container.style.visibility = 'hidden';

			this._updateContent();
			this._updateLayout();
			this._updatePosition();

			this._container.style.visibility = '';

			this._adjustPan();
		},

		getEvents: function () {
			var events = {
				zoom: this._updatePosition,
				viewreset: this._updatePosition
			};

			if (this._zoomAnimated) {
				events.zoomanim = this._animateZoom;
			}
			return events;
		},

		// @method isOpen: Boolean
		// Returns `true` when the popup is visible on the map.
		isOpen: function () {
			return !!this._map && this._map.hasLayer(this);
		},

		// @method bringToFront: this
		// Brings this popup in front of other popups (in the same map pane).
		bringToFront: function () {
			if (this._map) {
				toFront(this._container);
			}
			return this;
		},

		// @method bringToBack: this
		// Brings this popup to the back of other popups (in the same map pane).
		bringToBack: function () {
			if (this._map) {
				toBack(this._container);
			}
			return this;
		},

		_prepareOpen: function (parent, layer, latlng) {
			if (!(layer instanceof Layer)) {
				latlng = layer;
				layer = parent;
			}

			if (layer instanceof FeatureGroup) {
				for (var id in parent._layers) {
					layer = parent._layers[id];
					break;
				}
			}

			if (!latlng) {
				if (layer.getCenter) {
					latlng = layer.getCenter();
				} else if (layer.getLatLng) {
					latlng = layer.getLatLng();
				} else {
					throw new Error('Unable to get source layer LatLng.');
				}
			}

			// set overlay source to this layer
			this._source = layer;

			// update the overlay (content, layout, ect...)
			this.update();

			return latlng;
		},

		_updateContent: function () {
			if (!this._content) { return; }

			var node = this._contentNode;
			var content = (typeof this._content === 'function') ? this._content(this._source || this) : this._content;

			if (typeof content === 'string') {
				node.innerHTML = content;
			} else {
				while (node.hasChildNodes()) {
					node.removeChild(node.firstChild);
				}
				node.appendChild(content);
			}
			this.fire('contentupdate');
		},

		_updatePosition: function () {
			if (!this._map) { return; }

			var pos = this._map.latLngToLayerPoint(this._latlng),
			    offset = toPoint(this.options.offset),
			    anchor = this._getAnchor();

			if (this._zoomAnimated) {
				setPosition(this._container, pos.add(anchor));
			} else {
				offset = offset.add(pos).add(anchor);
			}

			var bottom = this._containerBottom = -offset.y,
			    left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;

			// bottom position the popup in case the height of the popup changes (images loading etc)
			this._container.style.bottom = bottom + 'px';
			this._container.style.left = left + 'px';
		},

		_getAnchor: function () {
			return [0, 0];
		}

	});

	/*
	 * @class Popup
	 * @inherits DivOverlay
	 * @aka L.Popup
	 * Used to open popups in certain places of the map. Use [Map.openPopup](#map-openpopup) to
	 * open popups while making sure that only one popup is open at one time
	 * (recommended for usability), or use [Map.addLayer](#map-addlayer) to open as many as you want.
	 *
	 * @example
	 *
	 * If you want to just bind a popup to marker click and then open it, it's really easy:
	 *
	 * ```js
	 * marker.bindPopup(popupContent).openPopup();
	 * ```
	 * Path overlays like polylines also have a `bindPopup` method.
	 * Here's a more complicated way to open a popup on a map:
	 *
	 * ```js
	 * var popup = L.popup()
	 * 	.setLatLng(latlng)
	 * 	.setContent('<p>Hello world!<br />This is a nice popup.</p>')
	 * 	.openOn(map);
	 * ```
	 */


	// @namespace Popup
	var Popup = DivOverlay.extend({

		// @section
		// @aka Popup options
		options: {
			// @option maxWidth: Number = 300
			// Max width of the popup, in pixels.
			maxWidth: 300,

			// @option minWidth: Number = 50
			// Min width of the popup, in pixels.
			minWidth: 50,

			// @option maxHeight: Number = null
			// If set, creates a scrollable container of the given height
			// inside a popup if its content exceeds it.
			maxHeight: null,

			// @option autoPan: Boolean = true
			// Set it to `false` if you don't want the map to do panning animation
			// to fit the opened popup.
			autoPan: true,

			// @option autoPanPaddingTopLeft: Point = null
			// The margin between the popup and the top left corner of the map
			// view after autopanning was performed.
			autoPanPaddingTopLeft: null,

			// @option autoPanPaddingBottomRight: Point = null
			// The margin between the popup and the bottom right corner of the map
			// view after autopanning was performed.
			autoPanPaddingBottomRight: null,

			// @option autoPanPadding: Point = Point(5, 5)
			// Equivalent of setting both top left and bottom right autopan padding to the same value.
			autoPanPadding: [5, 5],

			// @option keepInView: Boolean = false
			// Set it to `true` if you want to prevent users from panning the popup
			// off of the screen while it is open.
			keepInView: false,

			// @option closeButton: Boolean = true
			// Controls the presence of a close button in the popup.
			closeButton: true,

			// @option autoClose: Boolean = true
			// Set it to `false` if you want to override the default behavior of
			// the popup closing when another popup is opened.
			autoClose: true,

			// @option closeOnEscapeKey: Boolean = true
			// Set it to `false` if you want to override the default behavior of
			// the ESC key for closing of the popup.
			closeOnEscapeKey: true,

			// @option closeOnClick: Boolean = *
			// Set it if you want to override the default behavior of the popup closing when user clicks
			// on the map. Defaults to the map's [`closePopupOnClick`](#map-closepopuponclick) option.

			// @option className: String = ''
			// A custom CSS class name to assign to the popup.
			className: ''
		},

		// @namespace Popup
		// @method openOn(map: Map): this
		// Adds the popup to the map and closes the previous one. The same as `map.openPopup(popup)`.
		openOn: function (map) {
			map.openPopup(this);
			return this;
		},

		onAdd: function (map) {
			DivOverlay.prototype.onAdd.call(this, map);

			// @namespace Map
			// @section Popup events
			// @event popupopen: PopupEvent
			// Fired when a popup is opened in the map
			map.fire('popupopen', {popup: this});

			if (this._source) {
				// @namespace Layer
				// @section Popup events
				// @event popupopen: PopupEvent
				// Fired when a popup bound to this layer is opened
				this._source.fire('popupopen', {popup: this}, true);
				// For non-path layers, we toggle the popup when clicking
				// again the layer, so prevent the map to reopen it.
				if (!(this._source instanceof Path)) {
					this._source.on('preclick', stopPropagation);
				}
			}
		},

		onRemove: function (map) {
			DivOverlay.prototype.onRemove.call(this, map);

			// @namespace Map
			// @section Popup events
			// @event popupclose: PopupEvent
			// Fired when a popup in the map is closed
			map.fire('popupclose', {popup: this});

			if (this._source) {
				// @namespace Layer
				// @section Popup events
				// @event popupclose: PopupEvent
				// Fired when a popup bound to this layer is closed
				this._source.fire('popupclose', {popup: this}, true);
				if (!(this._source instanceof Path)) {
					this._source.off('preclick', stopPropagation);
				}
			}
		},

		getEvents: function () {
			var events = DivOverlay.prototype.getEvents.call(this);

			if (this.options.closeOnClick !== undefined ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
				events.preclick = this._close;
			}

			if (this.options.keepInView) {
				events.moveend = this._adjustPan;
			}

			return events;
		},

		_close: function () {
			if (this._map) {
				this._map.closePopup(this);
			}
		},

		_initLayout: function () {
			var prefix = 'leaflet-popup',
			    container = this._container = create$1$1('div',
				prefix + ' ' + (this.options.className || '') +
				' leaflet-zoom-animated');

			var wrapper = this._wrapper = create$1$1('div', prefix + '-content-wrapper', container);
			this._contentNode = create$1$1('div', prefix + '-content', wrapper);

			disableClickPropagation(wrapper);
			disableScrollPropagation(this._contentNode);
			on(wrapper, 'contextmenu', stopPropagation);

			this._tipContainer = create$1$1('div', prefix + '-tip-container', container);
			this._tip = create$1$1('div', prefix + '-tip', this._tipContainer);

			if (this.options.closeButton) {
				var closeButton = this._closeButton = create$1$1('a', prefix + '-close-button', container);
				closeButton.href = '#close';
				closeButton.innerHTML = '&#215;';

				on(closeButton, 'click', this._onCloseButtonClick, this);
			}
		},

		_updateLayout: function () {
			var container = this._contentNode,
			    style = container.style;

			style.width = '';
			style.whiteSpace = 'nowrap';

			var width = container.offsetWidth;
			width = Math.min(width, this.options.maxWidth);
			width = Math.max(width, this.options.minWidth);

			style.width = (width + 1) + 'px';
			style.whiteSpace = '';

			style.height = '';

			var height = container.offsetHeight,
			    maxHeight = this.options.maxHeight,
			    scrolledClass = 'leaflet-popup-scrolled';

			if (maxHeight && height > maxHeight) {
				style.height = maxHeight + 'px';
				addClass(container, scrolledClass);
			} else {
				removeClass(container, scrolledClass);
			}

			this._containerWidth = this._container.offsetWidth;
		},

		_animateZoom: function (e) {
			var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center),
			    anchor = this._getAnchor();
			setPosition(this._container, pos.add(anchor));
		},

		_adjustPan: function () {
			if (!this.options.autoPan) { return; }
			if (this._map._panAnim) { this._map._panAnim.stop(); }

			var map = this._map,
			    marginBottom = parseInt(getStyle(this._container, 'marginBottom'), 10) || 0,
			    containerHeight = this._container.offsetHeight + marginBottom,
			    containerWidth = this._containerWidth,
			    layerPos = new Point$1(this._containerLeft, -containerHeight - this._containerBottom);

			layerPos._add(getPosition$1(this._container));

			var containerPos = map.layerPointToContainerPoint(layerPos),
			    padding = toPoint(this.options.autoPanPadding),
			    paddingTL = toPoint(this.options.autoPanPaddingTopLeft || padding),
			    paddingBR = toPoint(this.options.autoPanPaddingBottomRight || padding),
			    size = map.getSize(),
			    dx = 0,
			    dy = 0;

			if (containerPos.x + containerWidth + paddingBR.x > size.x) { // right
				dx = containerPos.x + containerWidth - size.x + paddingBR.x;
			}
			if (containerPos.x - dx - paddingTL.x < 0) { // left
				dx = containerPos.x - paddingTL.x;
			}
			if (containerPos.y + containerHeight + paddingBR.y > size.y) { // bottom
				dy = containerPos.y + containerHeight - size.y + paddingBR.y;
			}
			if (containerPos.y - dy - paddingTL.y < 0) { // top
				dy = containerPos.y - paddingTL.y;
			}

			// @namespace Map
			// @section Popup events
			// @event autopanstart: Event
			// Fired when the map starts autopanning when opening a popup.
			if (dx || dy) {
				map
				    .fire('autopanstart')
				    .panBy([dx, dy]);
			}
		},

		_onCloseButtonClick: function (e) {
			this._close();
			stop(e);
		},

		_getAnchor: function () {
			// Where should we anchor the popup on the source layer?
			return toPoint(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);
		}

	});


	/* @namespace Map
	 * @section Interaction Options
	 * @option closePopupOnClick: Boolean = true
	 * Set it to `false` if you don't want popups to close when user clicks the map.
	 */
	Map$1.mergeOptions({
		closePopupOnClick: true
	});


	// @namespace Map
	// @section Methods for Layers and Controls
	Map$1.include({
		// @method openPopup(popup: Popup): this
		// Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).
		// @alternative
		// @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this
		// Creates a popup with the specified content and options and opens it in the given point on a map.
		openPopup: function (popup, latlng, options) {
			if (!(popup instanceof Popup)) {
				popup = new Popup(options).setContent(popup);
			}

			if (latlng) {
				popup.setLatLng(latlng);
			}

			if (this.hasLayer(popup)) {
				return this;
			}

			if (this._popup && this._popup.options.autoClose) {
				this.closePopup();
			}

			this._popup = popup;
			return this.addLayer(popup);
		},

		// @method closePopup(popup?: Popup): this
		// Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).
		closePopup: function (popup) {
			if (!popup || popup === this._popup) {
				popup = this._popup;
				this._popup = null;
			}
			if (popup) {
				this.removeLayer(popup);
			}
			return this;
		}
	});

	/*
	 * @namespace Layer
	 * @section Popup methods example
	 *
	 * All layers share a set of methods convenient for binding popups to it.
	 *
	 * ```js
	 * var layer = L.Polygon(latlngs).bindPopup('Hi There!').addTo(map);
	 * layer.openPopup();
	 * layer.closePopup();
	 * ```
	 *
	 * Popups will also be automatically opened when the layer is clicked on and closed when the layer is removed from the map or another popup is opened.
	 */

	// @section Popup methods
	Layer.include({

		// @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this
		// Binds a popup to the layer with the passed `content` and sets up the
		// necessary event listeners. If a `Function` is passed it will receive
		// the layer as the first argument and should return a `String` or `HTMLElement`.
		bindPopup: function (content, options) {

			if (content instanceof Popup) {
				setOptions(content, options);
				this._popup = content;
				content._source = this;
			} else {
				if (!this._popup || options) {
					this._popup = new Popup(options, this);
				}
				this._popup.setContent(content);
			}

			if (!this._popupHandlersAdded) {
				this.on({
					click: this._openPopup,
					keypress: this._onKeyPress,
					remove: this.closePopup,
					move: this._movePopup
				});
				this._popupHandlersAdded = true;
			}

			return this;
		},

		// @method unbindPopup(): this
		// Removes the popup previously bound with `bindPopup`.
		unbindPopup: function () {
			if (this._popup) {
				this.off({
					click: this._openPopup,
					keypress: this._onKeyPress,
					remove: this.closePopup,
					move: this._movePopup
				});
				this._popupHandlersAdded = false;
				this._popup = null;
			}
			return this;
		},

		// @method openPopup(latlng?: LatLng): this
		// Opens the bound popup at the specified `latlng` or at the default popup anchor if no `latlng` is passed.
		openPopup: function (layer, latlng) {
			if (this._popup && this._map) {
				latlng = this._popup._prepareOpen(this, layer, latlng);

				// open the popup on the map
				this._map.openPopup(this._popup, latlng);
			}

			return this;
		},

		// @method closePopup(): this
		// Closes the popup bound to this layer if it is open.
		closePopup: function () {
			if (this._popup) {
				this._popup._close();
			}
			return this;
		},

		// @method togglePopup(): this
		// Opens or closes the popup bound to this layer depending on its current state.
		togglePopup: function (target) {
			if (this._popup) {
				if (this._popup._map) {
					this.closePopup();
				} else {
					this.openPopup(target);
				}
			}
			return this;
		},

		// @method isPopupOpen(): boolean
		// Returns `true` if the popup bound to this layer is currently open.
		isPopupOpen: function () {
			return (this._popup ? this._popup.isOpen() : false);
		},

		// @method setPopupContent(content: String|HTMLElement|Popup): this
		// Sets the content of the popup bound to this layer.
		setPopupContent: function (content) {
			if (this._popup) {
				this._popup.setContent(content);
			}
			return this;
		},

		// @method getPopup(): Popup
		// Returns the popup bound to this layer.
		getPopup: function () {
			return this._popup;
		},

		_openPopup: function (e) {
			var layer = e.layer || e.target;

			if (!this._popup) {
				return;
			}

			if (!this._map) {
				return;
			}

			// prevent map click
			stop(e);

			// if this inherits from Path its a vector and we can just
			// open the popup at the new location
			if (layer instanceof Path) {
				this.openPopup(e.layer || e.target, e.latlng);
				return;
			}

			// otherwise treat it like a marker and figure out
			// if we should toggle it open/closed
			if (this._map.hasLayer(this._popup) && this._popup._source === layer) {
				this.closePopup();
			} else {
				this.openPopup(layer, e.latlng);
			}
		},

		_movePopup: function (e) {
			this._popup.setLatLng(e.latlng);
		},

		_onKeyPress: function (e) {
			if (e.originalEvent.keyCode === 13) {
				this._openPopup(e);
			}
		}
	});

	/*
	 * @class Tooltip
	 * @inherits DivOverlay
	 * @aka L.Tooltip
	 * Used to display small texts on top of map layers.
	 *
	 * @example
	 *
	 * ```js
	 * marker.bindTooltip("my tooltip text").openTooltip();
	 * ```
	 * Note about tooltip offset. Leaflet takes two options in consideration
	 * for computing tooltip offsetting:
	 * - the `offset` Tooltip option: it defaults to [0, 0], and it's specific to one tooltip.
	 *   Add a positive x offset to move the tooltip to the right, and a positive y offset to
	 *   move it to the bottom. Negatives will move to the left and top.
	 * - the `tooltipAnchor` Icon option: this will only be considered for Marker. You
	 *   should adapt this value if you use a custom icon.
	 */


	// @namespace Tooltip
	var Tooltip = DivOverlay.extend({

		// @section
		// @aka Tooltip options
		options: {
			// @option pane: String = 'tooltipPane'
			// `Map pane` where the tooltip will be added.
			pane: 'tooltipPane',

			// @option offset: Point = Point(0, 0)
			// Optional offset of the tooltip position.
			offset: [0, 0],

			// @option direction: String = 'auto'
			// Direction where to open the tooltip. Possible values are: `right`, `left`,
			// `top`, `bottom`, `center`, `auto`.
			// `auto` will dynamically switch between `right` and `left` according to the tooltip
			// position on the map.
			direction: 'auto',

			// @option permanent: Boolean = false
			// Whether to open the tooltip permanently or only on mouseover.
			permanent: false,

			// @option sticky: Boolean = false
			// If true, the tooltip will follow the mouse instead of being fixed at the feature center.
			sticky: false,

			// @option interactive: Boolean = false
			// If true, the tooltip will listen to the feature events.
			interactive: false,

			// @option opacity: Number = 0.9
			// Tooltip container opacity.
			opacity: 0.9
		},

		onAdd: function (map) {
			DivOverlay.prototype.onAdd.call(this, map);
			this.setOpacity(this.options.opacity);

			// @namespace Map
			// @section Tooltip events
			// @event tooltipopen: TooltipEvent
			// Fired when a tooltip is opened in the map.
			map.fire('tooltipopen', {tooltip: this});

			if (this._source) {
				// @namespace Layer
				// @section Tooltip events
				// @event tooltipopen: TooltipEvent
				// Fired when a tooltip bound to this layer is opened.
				this._source.fire('tooltipopen', {tooltip: this}, true);
			}
		},

		onRemove: function (map) {
			DivOverlay.prototype.onRemove.call(this, map);

			// @namespace Map
			// @section Tooltip events
			// @event tooltipclose: TooltipEvent
			// Fired when a tooltip in the map is closed.
			map.fire('tooltipclose', {tooltip: this});

			if (this._source) {
				// @namespace Layer
				// @section Tooltip events
				// @event tooltipclose: TooltipEvent
				// Fired when a tooltip bound to this layer is closed.
				this._source.fire('tooltipclose', {tooltip: this}, true);
			}
		},

		getEvents: function () {
			var events = DivOverlay.prototype.getEvents.call(this);

			if (touch && !this.options.permanent) {
				events.preclick = this._close;
			}

			return events;
		},

		_close: function () {
			if (this._map) {
				this._map.closeTooltip(this);
			}
		},

		_initLayout: function () {
			var prefix = 'leaflet-tooltip',
			    className = prefix + ' ' + (this.options.className || '') + ' leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');

			this._contentNode = this._container = create$1$1('div', className);
		},

		_updateLayout: function () {},

		_adjustPan: function () {},

		_setPosition: function (pos) {
			var map = this._map,
			    container = this._container,
			    centerPoint = map.latLngToContainerPoint(map.getCenter()),
			    tooltipPoint = map.layerPointToContainerPoint(pos),
			    direction = this.options.direction,
			    tooltipWidth = container.offsetWidth,
			    tooltipHeight = container.offsetHeight,
			    offset = toPoint(this.options.offset),
			    anchor = this._getAnchor();

			if (direction === 'top') {
				pos = pos.add(toPoint(-tooltipWidth / 2 + offset.x, -tooltipHeight + offset.y + anchor.y, true));
			} else if (direction === 'bottom') {
				pos = pos.subtract(toPoint(tooltipWidth / 2 - offset.x, -offset.y, true));
			} else if (direction === 'center') {
				pos = pos.subtract(toPoint(tooltipWidth / 2 + offset.x, tooltipHeight / 2 - anchor.y + offset.y, true));
			} else if (direction === 'right' || direction === 'auto' && tooltipPoint.x < centerPoint.x) {
				direction = 'right';
				pos = pos.add(toPoint(offset.x + anchor.x, anchor.y - tooltipHeight / 2 + offset.y, true));
			} else {
				direction = 'left';
				pos = pos.subtract(toPoint(tooltipWidth + anchor.x - offset.x, tooltipHeight / 2 - anchor.y - offset.y, true));
			}

			removeClass(container, 'leaflet-tooltip-right');
			removeClass(container, 'leaflet-tooltip-left');
			removeClass(container, 'leaflet-tooltip-top');
			removeClass(container, 'leaflet-tooltip-bottom');
			addClass(container, 'leaflet-tooltip-' + direction);
			setPosition(container, pos);
		},

		_updatePosition: function () {
			var pos = this._map.latLngToLayerPoint(this._latlng);
			this._setPosition(pos);
		},

		setOpacity: function (opacity) {
			this.options.opacity = opacity;

			if (this._container) {
				setOpacity(this._container, opacity);
			}
		},

		_animateZoom: function (e) {
			var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);
			this._setPosition(pos);
		},

		_getAnchor: function () {
			// Where should we anchor the tooltip on the source layer?
			return toPoint(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);
		}

	});

	// @namespace Map
	// @section Methods for Layers and Controls
	Map$1.include({

		// @method openTooltip(tooltip: Tooltip): this
		// Opens the specified tooltip.
		// @alternative
		// @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this
		// Creates a tooltip with the specified content and options and open it.
		openTooltip: function (tooltip, latlng, options) {
			if (!(tooltip instanceof Tooltip)) {
				tooltip = new Tooltip(options).setContent(tooltip);
			}

			if (latlng) {
				tooltip.setLatLng(latlng);
			}

			if (this.hasLayer(tooltip)) {
				return this;
			}

			return this.addLayer(tooltip);
		},

		// @method closeTooltip(tooltip?: Tooltip): this
		// Closes the tooltip given as parameter.
		closeTooltip: function (tooltip) {
			if (tooltip) {
				this.removeLayer(tooltip);
			}
			return this;
		}

	});

	/*
	 * @namespace Layer
	 * @section Tooltip methods example
	 *
	 * All layers share a set of methods convenient for binding tooltips to it.
	 *
	 * ```js
	 * var layer = L.Polygon(latlngs).bindTooltip('Hi There!').addTo(map);
	 * layer.openTooltip();
	 * layer.closeTooltip();
	 * ```
	 */

	// @section Tooltip methods
	Layer.include({

		// @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this
		// Binds a tooltip to the layer with the passed `content` and sets up the
		// necessary event listeners. If a `Function` is passed it will receive
		// the layer as the first argument and should return a `String` or `HTMLElement`.
		bindTooltip: function (content, options) {

			if (content instanceof Tooltip) {
				setOptions(content, options);
				this._tooltip = content;
				content._source = this;
			} else {
				if (!this._tooltip || options) {
					this._tooltip = new Tooltip(options, this);
				}
				this._tooltip.setContent(content);

			}

			this._initTooltipInteractions();

			if (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {
				this.openTooltip();
			}

			return this;
		},

		// @method unbindTooltip(): this
		// Removes the tooltip previously bound with `bindTooltip`.
		unbindTooltip: function () {
			if (this._tooltip) {
				this._initTooltipInteractions(true);
				this.closeTooltip();
				this._tooltip = null;
			}
			return this;
		},

		_initTooltipInteractions: function (remove$$1) {
			if (!remove$$1 && this._tooltipHandlersAdded) { return; }
			var onOff = remove$$1 ? 'off' : 'on',
			    events = {
				remove: this.closeTooltip,
				move: this._moveTooltip
			    };
			if (!this._tooltip.options.permanent) {
				events.mouseover = this._openTooltip;
				events.mouseout = this.closeTooltip;
				if (this._tooltip.options.sticky) {
					events.mousemove = this._moveTooltip;
				}
				if (touch) {
					events.click = this._openTooltip;
				}
			} else {
				events.add = this._openTooltip;
			}
			this[onOff](events);
			this._tooltipHandlersAdded = !remove$$1;
		},

		// @method openTooltip(latlng?: LatLng): this
		// Opens the bound tooltip at the specified `latlng` or at the default tooltip anchor if no `latlng` is passed.
		openTooltip: function (layer, latlng) {
			if (this._tooltip && this._map) {
				latlng = this._tooltip._prepareOpen(this, layer, latlng);

				// open the tooltip on the map
				this._map.openTooltip(this._tooltip, latlng);

				// Tooltip container may not be defined if not permanent and never
				// opened.
				if (this._tooltip.options.interactive && this._tooltip._container) {
					addClass(this._tooltip._container, 'leaflet-clickable');
					this.addInteractiveTarget(this._tooltip._container);
				}
			}

			return this;
		},

		// @method closeTooltip(): this
		// Closes the tooltip bound to this layer if it is open.
		closeTooltip: function () {
			if (this._tooltip) {
				this._tooltip._close();
				if (this._tooltip.options.interactive && this._tooltip._container) {
					removeClass(this._tooltip._container, 'leaflet-clickable');
					this.removeInteractiveTarget(this._tooltip._container);
				}
			}
			return this;
		},

		// @method toggleTooltip(): this
		// Opens or closes the tooltip bound to this layer depending on its current state.
		toggleTooltip: function (target) {
			if (this._tooltip) {
				if (this._tooltip._map) {
					this.closeTooltip();
				} else {
					this.openTooltip(target);
				}
			}
			return this;
		},

		// @method isTooltipOpen(): boolean
		// Returns `true` if the tooltip bound to this layer is currently open.
		isTooltipOpen: function () {
			return this._tooltip.isOpen();
		},

		// @method setTooltipContent(content: String|HTMLElement|Tooltip): this
		// Sets the content of the tooltip bound to this layer.
		setTooltipContent: function (content) {
			if (this._tooltip) {
				this._tooltip.setContent(content);
			}
			return this;
		},

		// @method getTooltip(): Tooltip
		// Returns the tooltip bound to this layer.
		getTooltip: function () {
			return this._tooltip;
		},

		_openTooltip: function (e) {
			var layer = e.layer || e.target;

			if (!this._tooltip || !this._map) {
				return;
			}
			this.openTooltip(layer, this._tooltip.options.sticky ? e.latlng : undefined);
		},

		_moveTooltip: function (e) {
			var latlng = e.latlng, containerPoint, layerPoint;
			if (this._tooltip.options.sticky && e.originalEvent) {
				containerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);
				layerPoint = this._map.containerPointToLayerPoint(containerPoint);
				latlng = this._map.layerPointToLatLng(layerPoint);
			}
			this._tooltip.setLatLng(latlng);
		}
	});

	/*
	 * @class DivIcon
	 * @aka L.DivIcon
	 * @inherits Icon
	 *
	 * Represents a lightweight icon for markers that uses a simple `<div>`
	 * element instead of an image. Inherits from `Icon` but ignores the `iconUrl` and shadow options.
	 *
	 * @example
	 * ```js
	 * var myIcon = L.divIcon({className: 'my-div-icon'});
	 * // you can set .my-div-icon styles in CSS
	 *
	 * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
	 * ```
	 *
	 * By default, it has a 'leaflet-div-icon' CSS class and is styled as a little white square with a shadow.
	 */

	var DivIcon = Icon.extend({
		options: {
			// @section
			// @aka DivIcon options
			iconSize: [12, 12], // also can be set through CSS

			// iconAnchor: (Point),
			// popupAnchor: (Point),

			// @option html: String|HTMLElement = ''
			// Custom HTML code to put inside the div element, empty by default. Alternatively,
			// an instance of `HTMLElement`.
			html: false,

			// @option bgPos: Point = [0, 0]
			// Optional relative position of the background, in pixels
			bgPos: null,

			className: 'leaflet-div-icon'
		},

		createIcon: function (oldIcon) {
			var div = (oldIcon && oldIcon.tagName === 'DIV') ? oldIcon : document.createElement('div'),
			    options = this.options;

			if (options.html instanceof Element) {
				empty$1(div);
				div.appendChild(options.html);
			} else {
				div.innerHTML = options.html !== false ? options.html : '';
			}

			if (options.bgPos) {
				var bgPos = toPoint(options.bgPos);
				div.style.backgroundPosition = (-bgPos.x) + 'px ' + (-bgPos.y) + 'px';
			}
			this._setIconStyles(div, 'icon');

			return div;
		},

		createShadow: function () {
			return null;
		}
	});

	Icon.Default = IconDefault;

	/*
	 * @class GridLayer
	 * @inherits Layer
	 * @aka L.GridLayer
	 *
	 * Generic class for handling a tiled grid of HTML elements. This is the base class for all tile layers and replaces `TileLayer.Canvas`.
	 * GridLayer can be extended to create a tiled grid of HTML elements like `<canvas>`, `<img>` or `<div>`. GridLayer will handle creating and animating these DOM elements for you.
	 *
	 *
	 * @section Synchronous usage
	 * @example
	 *
	 * To create a custom layer, extend GridLayer and implement the `createTile()` method, which will be passed a `Point` object with the `x`, `y`, and `z` (zoom level) coordinates to draw your tile.
	 *
	 * ```js
	 * var CanvasLayer = L.GridLayer.extend({
	 *     createTile: function(coords){
	 *         // create a <canvas> element for drawing
	 *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
	 *
	 *         // setup tile width and height according to the options
	 *         var size = this.getTileSize();
	 *         tile.width = size.x;
	 *         tile.height = size.y;
	 *
	 *         // get a canvas context and draw something on it using coords.x, coords.y and coords.z
	 *         var ctx = tile.getContext('2d');
	 *
	 *         // return the tile so it can be rendered on screen
	 *         return tile;
	 *     }
	 * });
	 * ```
	 *
	 * @section Asynchronous usage
	 * @example
	 *
	 * Tile creation can also be asynchronous, this is useful when using a third-party drawing library. Once the tile is finished drawing it can be passed to the `done()` callback.
	 *
	 * ```js
	 * var CanvasLayer = L.GridLayer.extend({
	 *     createTile: function(coords, done){
	 *         var error;
	 *
	 *         // create a <canvas> element for drawing
	 *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
	 *
	 *         // setup tile width and height according to the options
	 *         var size = this.getTileSize();
	 *         tile.width = size.x;
	 *         tile.height = size.y;
	 *
	 *         // draw something asynchronously and pass the tile to the done() callback
	 *         setTimeout(function() {
	 *             done(error, tile);
	 *         }, 1000);
	 *
	 *         return tile;
	 *     }
	 * });
	 * ```
	 *
	 * @section
	 */


	var GridLayer = Layer.extend({

		// @section
		// @aka GridLayer options
		options: {
			// @option tileSize: Number|Point = 256
			// Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
			tileSize: 256,

			// @option opacity: Number = 1.0
			// Opacity of the tiles. Can be used in the `createTile()` function.
			opacity: 1,

			// @option updateWhenIdle: Boolean = (depends)
			// Load new tiles only when panning ends.
			// `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.
			// `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the
			// [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.
			updateWhenIdle: mobile,

			// @option updateWhenZooming: Boolean = true
			// By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.
			updateWhenZooming: true,

			// @option updateInterval: Number = 200
			// Tiles will not update more than once every `updateInterval` milliseconds when panning.
			updateInterval: 200,

			// @option zIndex: Number = 1
			// The explicit zIndex of the tile layer.
			zIndex: 1,

			// @option bounds: LatLngBounds = undefined
			// If set, tiles will only be loaded inside the set `LatLngBounds`.
			bounds: null,

			// @option minZoom: Number = 0
			// The minimum zoom level down to which this layer will be displayed (inclusive).
			minZoom: 0,

			// @option maxZoom: Number = undefined
			// The maximum zoom level up to which this layer will be displayed (inclusive).
			maxZoom: undefined,

			// @option maxNativeZoom: Number = undefined
			// Maximum zoom number the tile source has available. If it is specified,
			// the tiles on all zoom levels higher than `maxNativeZoom` will be loaded
			// from `maxNativeZoom` level and auto-scaled.
			maxNativeZoom: undefined,

			// @option minNativeZoom: Number = undefined
			// Minimum zoom number the tile source has available. If it is specified,
			// the tiles on all zoom levels lower than `minNativeZoom` will be loaded
			// from `minNativeZoom` level and auto-scaled.
			minNativeZoom: undefined,

			// @option noWrap: Boolean = false
			// Whether the layer is wrapped around the antimeridian. If `true`, the
			// GridLayer will only be displayed once at low zoom levels. Has no
			// effect when the [map CRS](#map-crs) doesn't wrap around. Can be used
			// in combination with [`bounds`](#gridlayer-bounds) to prevent requesting
			// tiles outside the CRS limits.
			noWrap: false,

			// @option pane: String = 'tilePane'
			// `Map pane` where the grid layer will be added.
			pane: 'tilePane',

			// @option className: String = ''
			// A custom class name to assign to the tile layer. Empty by default.
			className: '',

			// @option keepBuffer: Number = 2
			// When panning the map, keep this many rows and columns of tiles before unloading them.
			keepBuffer: 2
		},

		initialize: function (options) {
			setOptions(this, options);
		},

		onAdd: function () {
			this._initContainer();

			this._levels = {};
			this._tiles = {};

			this._resetView();
			this._update();
		},

		beforeAdd: function (map) {
			map._addZoomLimit(this);
		},

		onRemove: function (map) {
			this._removeAllTiles();
			remove(this._container);
			map._removeZoomLimit(this);
			this._container = null;
			this._tileZoom = undefined;
		},

		// @method bringToFront: this
		// Brings the tile layer to the top of all tile layers.
		bringToFront: function () {
			if (this._map) {
				toFront(this._container);
				this._setAutoZIndex(Math.max);
			}
			return this;
		},

		// @method bringToBack: this
		// Brings the tile layer to the bottom of all tile layers.
		bringToBack: function () {
			if (this._map) {
				toBack(this._container);
				this._setAutoZIndex(Math.min);
			}
			return this;
		},

		// @method getContainer: HTMLElement
		// Returns the HTML element that contains the tiles for this layer.
		getContainer: function () {
			return this._container;
		},

		// @method setOpacity(opacity: Number): this
		// Changes the [opacity](#gridlayer-opacity) of the grid layer.
		setOpacity: function (opacity) {
			this.options.opacity = opacity;
			this._updateOpacity();
			return this;
		},

		// @method setZIndex(zIndex: Number): this
		// Changes the [zIndex](#gridlayer-zindex) of the grid layer.
		setZIndex: function (zIndex) {
			this.options.zIndex = zIndex;
			this._updateZIndex();

			return this;
		},

		// @method isLoading: Boolean
		// Returns `true` if any tile in the grid layer has not finished loading.
		isLoading: function () {
			return this._loading;
		},

		// @method redraw: this
		// Causes the layer to clear all the tiles and request them again.
		redraw: function () {
			if (this._map) {
				this._removeAllTiles();
				this._update();
			}
			return this;
		},

		getEvents: function () {
			var events = {
				viewprereset: this._invalidateAll,
				viewreset: this._resetView,
				zoom: this._resetView,
				moveend: this._onMoveEnd
			};

			if (!this.options.updateWhenIdle) {
				// update tiles on move, but not more often than once per given interval
				if (!this._onMove) {
					this._onMove = throttle(this._onMoveEnd, this.options.updateInterval, this);
				}

				events.move = this._onMove;
			}

			if (this._zoomAnimated) {
				events.zoomanim = this._animateZoom;
			}

			return events;
		},

		// @section Extension methods
		// Layers extending `GridLayer` shall reimplement the following method.
		// @method createTile(coords: Object, done?: Function): HTMLElement
		// Called only internally, must be overridden by classes extending `GridLayer`.
		// Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback
		// is specified, it must be called when the tile has finished loading and drawing.
		createTile: function () {
			return document.createElement('div');
		},

		// @section
		// @method getTileSize: Point
		// Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.
		getTileSize: function () {
			var s = this.options.tileSize;
			return s instanceof Point$1 ? s : new Point$1(s, s);
		},

		_updateZIndex: function () {
			if (this._container && this.options.zIndex !== undefined && this.options.zIndex !== null) {
				this._container.style.zIndex = this.options.zIndex;
			}
		},

		_setAutoZIndex: function (compare) {
			// go through all other layers of the same pane, set zIndex to max + 1 (front) or min - 1 (back)

			var layers = this.getPane().children,
			    edgeZIndex = -compare(-Infinity, Infinity); // -Infinity for max, Infinity for min

			for (var i = 0, len = layers.length, zIndex; i < len; i++) {

				zIndex = layers[i].style.zIndex;

				if (layers[i] !== this._container && zIndex) {
					edgeZIndex = compare(edgeZIndex, +zIndex);
				}
			}

			if (isFinite(edgeZIndex)) {
				this.options.zIndex = edgeZIndex + compare(-1, 1);
				this._updateZIndex();
			}
		},

		_updateOpacity: function () {
			if (!this._map) { return; }

			// IE doesn't inherit filter opacity properly, so we're forced to set it on tiles
			if (ielt9) { return; }

			setOpacity(this._container, this.options.opacity);

			var now = +new Date(),
			    nextFrame = false,
			    willPrune = false;

			for (var key in this._tiles) {
				var tile = this._tiles[key];
				if (!tile.current || !tile.loaded) { continue; }

				var fade = Math.min(1, (now - tile.loaded) / 200);

				setOpacity(tile.el, fade);
				if (fade < 1) {
					nextFrame = true;
				} else {
					if (tile.active) {
						willPrune = true;
					} else {
						this._onOpaqueTile(tile);
					}
					tile.active = true;
				}
			}

			if (willPrune && !this._noPrune) { this._pruneTiles(); }

			if (nextFrame) {
				cancelAnimFrame(this._fadeFrame);
				this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
			}
		},

		_onOpaqueTile: falseFn,

		_initContainer: function () {
			if (this._container) { return; }

			this._container = create$1$1('div', 'leaflet-layer ' + (this.options.className || ''));
			this._updateZIndex();

			if (this.options.opacity < 1) {
				this._updateOpacity();
			}

			this.getPane().appendChild(this._container);
		},

		_updateLevels: function () {

			var zoom = this._tileZoom,
			    maxZoom = this.options.maxZoom;

			if (zoom === undefined) { return undefined; }

			for (var z in this._levels) {
				if (this._levels[z].el.children.length || z === zoom) {
					this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom - z);
					this._onUpdateLevel(z);
				} else {
					remove(this._levels[z].el);
					this._removeTilesAtZoom(z);
					this._onRemoveLevel(z);
					delete this._levels[z];
				}
			}

			var level = this._levels[zoom],
			    map = this._map;

			if (!level) {
				level = this._levels[zoom] = {};

				level.el = create$1$1('div', 'leaflet-tile-container leaflet-zoom-animated', this._container);
				level.el.style.zIndex = maxZoom;

				level.origin = map.project(map.unproject(map.getPixelOrigin()), zoom).round();
				level.zoom = zoom;

				this._setZoomTransform(level, map.getCenter(), map.getZoom());

				// force the browser to consider the newly added element for transition
				falseFn(level.el.offsetWidth);

				this._onCreateLevel(level);
			}

			this._level = level;

			return level;
		},

		_onUpdateLevel: falseFn,

		_onRemoveLevel: falseFn,

		_onCreateLevel: falseFn,

		_pruneTiles: function () {
			if (!this._map) {
				return;
			}

			var key, tile;

			var zoom = this._map.getZoom();
			if (zoom > this.options.maxZoom ||
				zoom < this.options.minZoom) {
				this._removeAllTiles();
				return;
			}

			for (key in this._tiles) {
				tile = this._tiles[key];
				tile.retain = tile.current;
			}

			for (key in this._tiles) {
				tile = this._tiles[key];
				if (tile.current && !tile.active) {
					var coords = tile.coords;
					if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {
						this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
					}
				}
			}

			for (key in this._tiles) {
				if (!this._tiles[key].retain) {
					this._removeTile(key);
				}
			}
		},

		_removeTilesAtZoom: function (zoom) {
			for (var key in this._tiles) {
				if (this._tiles[key].coords.z !== zoom) {
					continue;
				}
				this._removeTile(key);
			}
		},

		_removeAllTiles: function () {
			for (var key in this._tiles) {
				this._removeTile(key);
			}
		},

		_invalidateAll: function () {
			for (var z in this._levels) {
				remove(this._levels[z].el);
				this._onRemoveLevel(z);
				delete this._levels[z];
			}
			this._removeAllTiles();

			this._tileZoom = undefined;
		},

		_retainParent: function (x, y, z, minZoom) {
			var x2 = Math.floor(x / 2),
			    y2 = Math.floor(y / 2),
			    z2 = z - 1,
			    coords2 = new Point$1(+x2, +y2);
			coords2.z = +z2;

			var key = this._tileCoordsToKey(coords2),
			    tile = this._tiles[key];

			if (tile && tile.active) {
				tile.retain = true;
				return true;

			} else if (tile && tile.loaded) {
				tile.retain = true;
			}

			if (z2 > minZoom) {
				return this._retainParent(x2, y2, z2, minZoom);
			}

			return false;
		},

		_retainChildren: function (x, y, z, maxZoom) {

			for (var i = 2 * x; i < 2 * x + 2; i++) {
				for (var j = 2 * y; j < 2 * y + 2; j++) {

					var coords = new Point$1(i, j);
					coords.z = z + 1;

					var key = this._tileCoordsToKey(coords),
					    tile = this._tiles[key];

					if (tile && tile.active) {
						tile.retain = true;
						continue;

					} else if (tile && tile.loaded) {
						tile.retain = true;
					}

					if (z + 1 < maxZoom) {
						this._retainChildren(i, j, z + 1, maxZoom);
					}
				}
			}
		},

		_resetView: function (e) {
			var animating = e && (e.pinch || e.flyTo);
			this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);
		},

		_animateZoom: function (e) {
			this._setView(e.center, e.zoom, true, e.noUpdate);
		},

		_clampZoom: function (zoom) {
			var options = this.options;

			if (undefined !== options.minNativeZoom && zoom < options.minNativeZoom) {
				return options.minNativeZoom;
			}

			if (undefined !== options.maxNativeZoom && options.maxNativeZoom < zoom) {
				return options.maxNativeZoom;
			}

			return zoom;
		},

		_setView: function (center, zoom, noPrune, noUpdate) {
			var tileZoom = this._clampZoom(Math.round(zoom));
			if ((this.options.maxZoom !== undefined && tileZoom > this.options.maxZoom) ||
			    (this.options.minZoom !== undefined && tileZoom < this.options.minZoom)) {
				tileZoom = undefined;
			}

			var tileZoomChanged = this.options.updateWhenZooming && (tileZoom !== this._tileZoom);

			if (!noUpdate || tileZoomChanged) {

				this._tileZoom = tileZoom;

				if (this._abortLoading) {
					this._abortLoading();
				}

				this._updateLevels();
				this._resetGrid();

				if (tileZoom !== undefined) {
					this._update(center);
				}

				if (!noPrune) {
					this._pruneTiles();
				}

				// Flag to prevent _updateOpacity from pruning tiles during
				// a zoom anim or a pinch gesture
				this._noPrune = !!noPrune;
			}

			this._setZoomTransforms(center, zoom);
		},

		_setZoomTransforms: function (center, zoom) {
			for (var i in this._levels) {
				this._setZoomTransform(this._levels[i], center, zoom);
			}
		},

		_setZoomTransform: function (level, center, zoom) {
			var scale = this._map.getZoomScale(zoom, level.zoom),
			    translate = level.origin.multiplyBy(scale)
			        .subtract(this._map._getNewPixelOrigin(center, zoom)).round();

			if (any3d) {
				setTransform(level.el, translate, scale);
			} else {
				setPosition(level.el, translate);
			}
		},

		_resetGrid: function () {
			var map = this._map,
			    crs = map.options.crs,
			    tileSize = this._tileSize = this.getTileSize(),
			    tileZoom = this._tileZoom;

			var bounds = this._map.getPixelWorldBounds(this._tileZoom);
			if (bounds) {
				this._globalTileRange = this._pxBoundsToTileRange(bounds);
			}

			this._wrapX = crs.wrapLng && !this.options.noWrap && [
				Math.floor(map.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x),
				Math.ceil(map.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)
			];
			this._wrapY = crs.wrapLat && !this.options.noWrap && [
				Math.floor(map.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x),
				Math.ceil(map.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)
			];
		},

		_onMoveEnd: function () {
			if (!this._map || this._map._animatingZoom) { return; }

			this._update();
		},

		_getTiledPixelBounds: function (center) {
			var map = this._map,
			    mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(),
			    scale = map.getZoomScale(mapZoom, this._tileZoom),
			    pixelCenter = map.project(center, this._tileZoom).floor(),
			    halfSize = map.getSize().divideBy(scale * 2);

			return new Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));
		},

		// Private method to load tiles in the grid's active zoom level according to map bounds
		_update: function (center) {
			var map = this._map;
			if (!map) { return; }
			var zoom = this._clampZoom(map.getZoom());

			if (center === undefined) { center = map.getCenter(); }
			if (this._tileZoom === undefined) { return; }	// if out of minzoom/maxzoom

			var pixelBounds = this._getTiledPixelBounds(center),
			    tileRange = this._pxBoundsToTileRange(pixelBounds),
			    tileCenter = tileRange.getCenter(),
			    queue = [],
			    margin = this.options.keepBuffer,
			    noPruneRange = new Bounds(tileRange.getBottomLeft().subtract([margin, -margin]),
			                              tileRange.getTopRight().add([margin, -margin]));

			// Sanity check: panic if the tile range contains Infinity somewhere.
			if (!(isFinite(tileRange.min.x) &&
			      isFinite(tileRange.min.y) &&
			      isFinite(tileRange.max.x) &&
			      isFinite(tileRange.max.y))) { throw new Error('Attempted to load an infinite number of tiles'); }

			for (var key in this._tiles) {
				var c = this._tiles[key].coords;
				if (c.z !== this._tileZoom || !noPruneRange.contains(new Point$1(c.x, c.y))) {
					this._tiles[key].current = false;
				}
			}

			// _update just loads more tiles. If the tile zoom level differs too much
			// from the map's, let _setView reset levels and prune old tiles.
			if (Math.abs(zoom - this._tileZoom) > 1) { this._setView(center, zoom); return; }

			// create a queue of coordinates to load tiles from
			for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {
				for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {
					var coords = new Point$1(i, j);
					coords.z = this._tileZoom;

					if (!this._isValidTile(coords)) { continue; }

					var tile = this._tiles[this._tileCoordsToKey(coords)];
					if (tile) {
						tile.current = true;
					} else {
						queue.push(coords);
					}
				}
			}

			// sort tile queue to load tiles in order of their distance to center
			queue.sort(function (a, b) {
				return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);
			});

			if (queue.length !== 0) {
				// if it's the first batch of tiles to load
				if (!this._loading) {
					this._loading = true;
					// @event loading: Event
					// Fired when the grid layer starts loading tiles.
					this.fire('loading');
				}

				// create DOM fragment to append tiles in one batch
				var fragment = document.createDocumentFragment();

				for (i = 0; i < queue.length; i++) {
					this._addTile(queue[i], fragment);
				}

				this._level.el.appendChild(fragment);
			}
		},

		_isValidTile: function (coords) {
			var crs = this._map.options.crs;

			if (!crs.infinite) {
				// don't load tile if it's out of bounds and not wrapped
				var bounds = this._globalTileRange;
				if ((!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x)) ||
				    (!crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y))) { return false; }
			}

			if (!this.options.bounds) { return true; }

			// don't load tile if it doesn't intersect the bounds in options
			var tileBounds = this._tileCoordsToBounds(coords);
			return toLatLngBounds(this.options.bounds).overlaps(tileBounds);
		},

		_keyToBounds: function (key) {
			return this._tileCoordsToBounds(this._keyToTileCoords(key));
		},

		_tileCoordsToNwSe: function (coords) {
			var map = this._map,
			    tileSize = this.getTileSize(),
			    nwPoint = coords.scaleBy(tileSize),
			    sePoint = nwPoint.add(tileSize),
			    nw = map.unproject(nwPoint, coords.z),
			    se = map.unproject(sePoint, coords.z);
			return [nw, se];
		},

		// converts tile coordinates to its geographical bounds
		_tileCoordsToBounds: function (coords) {
			var bp = this._tileCoordsToNwSe(coords),
			    bounds = new LatLngBounds(bp[0], bp[1]);

			if (!this.options.noWrap) {
				bounds = this._map.wrapLatLngBounds(bounds);
			}
			return bounds;
		},
		// converts tile coordinates to key for the tile cache
		_tileCoordsToKey: function (coords) {
			return coords.x + ':' + coords.y + ':' + coords.z;
		},

		// converts tile cache key to coordinates
		_keyToTileCoords: function (key) {
			var k = key.split(':'),
			    coords = new Point$1(+k[0], +k[1]);
			coords.z = +k[2];
			return coords;
		},

		_removeTile: function (key) {
			var tile = this._tiles[key];
			if (!tile) { return; }

			remove(tile.el);

			delete this._tiles[key];

			// @event tileunload: TileEvent
			// Fired when a tile is removed (e.g. when a tile goes off the screen).
			this.fire('tileunload', {
				tile: tile.el,
				coords: this._keyToTileCoords(key)
			});
		},

		_initTile: function (tile) {
			addClass(tile, 'leaflet-tile');

			var tileSize = this.getTileSize();
			tile.style.width = tileSize.x + 'px';
			tile.style.height = tileSize.y + 'px';

			tile.onselectstart = falseFn;
			tile.onmousemove = falseFn;

			// update opacity on tiles in IE7-8 because of filter inheritance problems
			if (ielt9 && this.options.opacity < 1) {
				setOpacity(tile, this.options.opacity);
			}

			// without this hack, tiles disappear after zoom on Chrome for Android
			// https://github.com/Leaflet/Leaflet/issues/2078
			if (android && !android23) {
				tile.style.WebkitBackfaceVisibility = 'hidden';
			}
		},

		_addTile: function (coords, container) {
			var tilePos = this._getTilePos(coords),
			    key = this._tileCoordsToKey(coords);

			var tile = this.createTile(this._wrapCoords(coords), bind(this._tileReady, this, coords));

			this._initTile(tile);

			// if createTile is defined with a second argument ("done" callback),
			// we know that tile is async and will be ready later; otherwise
			if (this.createTile.length < 2) {
				// mark tile as ready, but delay one frame for opacity animation to happen
				requestAnimFrame(bind(this._tileReady, this, coords, null, tile));
			}

			setPosition(tile, tilePos);

			// save tile in cache
			this._tiles[key] = {
				el: tile,
				coords: coords,
				current: true
			};

			container.appendChild(tile);
			// @event tileloadstart: TileEvent
			// Fired when a tile is requested and starts loading.
			this.fire('tileloadstart', {
				tile: tile,
				coords: coords
			});
		},

		_tileReady: function (coords, err, tile) {
			if (err) {
				// @event tileerror: TileErrorEvent
				// Fired when there is an error loading a tile.
				this.fire('tileerror', {
					error: err,
					tile: tile,
					coords: coords
				});
			}

			var key = this._tileCoordsToKey(coords);

			tile = this._tiles[key];
			if (!tile) { return; }

			tile.loaded = +new Date();
			if (this._map._fadeAnimated) {
				setOpacity(tile.el, 0);
				cancelAnimFrame(this._fadeFrame);
				this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
			} else {
				tile.active = true;
				this._pruneTiles();
			}

			if (!err) {
				addClass(tile.el, 'leaflet-tile-loaded');

				// @event tileload: TileEvent
				// Fired when a tile loads.
				this.fire('tileload', {
					tile: tile.el,
					coords: coords
				});
			}

			if (this._noTilesToLoad()) {
				this._loading = false;
				// @event load: Event
				// Fired when the grid layer loaded all visible tiles.
				this.fire('load');

				if (ielt9 || !this._map._fadeAnimated) {
					requestAnimFrame(this._pruneTiles, this);
				} else {
					// Wait a bit more than 0.2 secs (the duration of the tile fade-in)
					// to trigger a pruning.
					setTimeout(bind(this._pruneTiles, this), 250);
				}
			}
		},

		_getTilePos: function (coords) {
			return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);
		},

		_wrapCoords: function (coords) {
			var newCoords = new Point$1(
				this._wrapX ? wrapNum(coords.x, this._wrapX) : coords.x,
				this._wrapY ? wrapNum(coords.y, this._wrapY) : coords.y);
			newCoords.z = coords.z;
			return newCoords;
		},

		_pxBoundsToTileRange: function (bounds) {
			var tileSize = this.getTileSize();
			return new Bounds(
				bounds.min.unscaleBy(tileSize).floor(),
				bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1]));
		},

		_noTilesToLoad: function () {
			for (var key in this._tiles) {
				if (!this._tiles[key].loaded) { return false; }
			}
			return true;
		}
	});

	/*
	 * @class TileLayer
	 * @inherits GridLayer
	 * @aka L.TileLayer
	 * Used to load and display tile layers on the map. Note that most tile servers require attribution, which you can set under `Layer`. Extends `GridLayer`.
	 *
	 * @example
	 *
	 * ```js
	 * L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png?{foo}', {foo: 'bar', attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors, <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>'}).addTo(map);
	 * ```
	 *
	 * @section URL template
	 * @example
	 *
	 * A string of the following form:
	 *
	 * ```
	 * 'http://{s}.somedomain.com/blabla/{z}/{x}/{y}{r}.png'
	 * ```
	 *
	 * `{s}` means one of the available subdomains (used sequentially to help with browser parallel requests per domain limitation; subdomain values are specified in options; `a`, `b` or `c` by default, can be omitted), `{z}` — zoom level, `{x}` and `{y}` — tile coordinates. `{r}` can be used to add "&commat;2x" to the URL to load retina tiles.
	 *
	 * You can use custom keys in the template, which will be [evaluated](#util-template) from TileLayer options, like this:
	 *
	 * ```
	 * L.tileLayer('http://{s}.somedomain.com/{foo}/{z}/{x}/{y}.png', {foo: 'bar'});
	 * ```
	 */


	var TileLayer = GridLayer.extend({

		// @section
		// @aka TileLayer options
		options: {
			// @option minZoom: Number = 0
			// The minimum zoom level down to which this layer will be displayed (inclusive).
			minZoom: 0,

			// @option maxZoom: Number = 18
			// The maximum zoom level up to which this layer will be displayed (inclusive).
			maxZoom: 18,

			// @option subdomains: String|String[] = 'abc'
			// Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.
			subdomains: 'abc',

			// @option errorTileUrl: String = ''
			// URL to the tile image to show in place of the tile that failed to load.
			errorTileUrl: '',

			// @option zoomOffset: Number = 0
			// The zoom number used in tile URLs will be offset with this value.
			zoomOffset: 0,

			// @option tms: Boolean = false
			// If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).
			tms: false,

			// @option zoomReverse: Boolean = false
			// If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)
			zoomReverse: false,

			// @option detectRetina: Boolean = false
			// If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.
			detectRetina: false,

			// @option crossOrigin: Boolean|String = false
			// Whether the crossOrigin attribute will be added to the tiles.
			// If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
			// Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
			crossOrigin: false
		},

		initialize: function (url, options) {

			this._url = url;

			options = setOptions(this, options);

			// detecting retina displays, adjusting tileSize and zoom levels
			if (options.detectRetina && retina && options.maxZoom > 0) {

				options.tileSize = Math.floor(options.tileSize / 2);

				if (!options.zoomReverse) {
					options.zoomOffset++;
					options.maxZoom--;
				} else {
					options.zoomOffset--;
					options.minZoom++;
				}

				options.minZoom = Math.max(0, options.minZoom);
			}

			if (typeof options.subdomains === 'string') {
				options.subdomains = options.subdomains.split('');
			}

			// for https://github.com/Leaflet/Leaflet/issues/137
			if (!android) {
				this.on('tileunload', this._onTileRemove);
			}
		},

		// @method setUrl(url: String, noRedraw?: Boolean): this
		// Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
		// If the URL does not change, the layer will not be redrawn unless
		// the noRedraw parameter is set to false.
		setUrl: function (url, noRedraw) {
			if (this._url === url && noRedraw === undefined) {
				noRedraw = true;
			}

			this._url = url;

			if (!noRedraw) {
				this.redraw();
			}
			return this;
		},

		// @method createTile(coords: Object, done?: Function): HTMLElement
		// Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)
		// to return an `<img>` HTML element with the appropriate image URL given `coords`. The `done`
		// callback is called when the tile has been loaded.
		createTile: function (coords, done) {
			var tile = document.createElement('img');

			on(tile, 'load', bind(this._tileOnLoad, this, done, tile));
			on(tile, 'error', bind(this._tileOnError, this, done, tile));

			if (this.options.crossOrigin || this.options.crossOrigin === '') {
				tile.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;
			}

			/*
			 Alt tag is set to empty string to keep screen readers from reading URL and for compliance reasons
			 http://www.w3.org/TR/WCAG20-TECHS/H67
			*/
			tile.alt = '';

			/*
			 Set role="presentation" to force screen readers to ignore this
			 https://www.w3.org/TR/wai-aria/roles#textalternativecomputation
			*/
			tile.setAttribute('role', 'presentation');

			tile.src = this.getTileUrl(coords);

			return tile;
		},

		// @section Extension methods
		// @uninheritable
		// Layers extending `TileLayer` might reimplement the following method.
		// @method getTileUrl(coords: Object): String
		// Called only internally, returns the URL for a tile given its coordinates.
		// Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.
		getTileUrl: function (coords) {
			var data = {
				r: retina ? '@2x' : '',
				s: this._getSubdomain(coords),
				x: coords.x,
				y: coords.y,
				z: this._getZoomForUrl()
			};
			if (this._map && !this._map.options.crs.infinite) {
				var invertedY = this._globalTileRange.max.y - coords.y;
				if (this.options.tms) {
					data['y'] = invertedY;
				}
				data['-y'] = invertedY;
			}

			return template(this._url, extend$1(data, this.options));
		},

		_tileOnLoad: function (done, tile) {
			// For https://github.com/Leaflet/Leaflet/issues/3332
			if (ielt9) {
				setTimeout(bind(done, this, null, tile), 0);
			} else {
				done(null, tile);
			}
		},

		_tileOnError: function (done, tile, e) {
			var errorUrl = this.options.errorTileUrl;
			if (errorUrl && tile.getAttribute('src') !== errorUrl) {
				tile.src = errorUrl;
			}
			done(e, tile);
		},

		_onTileRemove: function (e) {
			e.tile.onload = null;
		},

		_getZoomForUrl: function () {
			var zoom = this._tileZoom,
			maxZoom = this.options.maxZoom,
			zoomReverse = this.options.zoomReverse,
			zoomOffset = this.options.zoomOffset;

			if (zoomReverse) {
				zoom = maxZoom - zoom;
			}

			return zoom + zoomOffset;
		},

		_getSubdomain: function (tilePoint) {
			var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
			return this.options.subdomains[index];
		},

		// stops loading all tiles in the background layer
		_abortLoading: function () {
			var i, tile;
			for (i in this._tiles) {
				if (this._tiles[i].coords.z !== this._tileZoom) {
					tile = this._tiles[i].el;

					tile.onload = falseFn;
					tile.onerror = falseFn;

					if (!tile.complete) {
						tile.src = emptyImageUrl;
						remove(tile);
						delete this._tiles[i];
					}
				}
			}
		},

		_removeTile: function (key) {
			var tile = this._tiles[key];
			if (!tile) { return; }

			// Cancels any pending http requests associated with the tile
			// unless we're on Android's stock browser,
			// see https://github.com/Leaflet/Leaflet/issues/137
			if (!androidStock) {
				tile.el.setAttribute('src', emptyImageUrl);
			}

			return GridLayer.prototype._removeTile.call(this, key);
		},

		_tileReady: function (coords, err, tile) {
			if (!this._map || (tile && tile.getAttribute('src') === emptyImageUrl)) {
				return;
			}

			return GridLayer.prototype._tileReady.call(this, coords, err, tile);
		}
	});

	/*
	 * @class TileLayer.WMS
	 * @inherits TileLayer
	 * @aka L.TileLayer.WMS
	 * Used to display [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services as tile layers on the map. Extends `TileLayer`.
	 *
	 * @example
	 *
	 * ```js
	 * var nexrad = L.tileLayer.wms("http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi", {
	 * 	layers: 'nexrad-n0r-900913',
	 * 	format: 'image/png',
	 * 	transparent: true,
	 * 	attribution: "Weather data © 2012 IEM Nexrad"
	 * });
	 * ```
	 */

	var TileLayerWMS = TileLayer.extend({

		// @section
		// @aka TileLayer.WMS options
		// If any custom options not documented here are used, they will be sent to the
		// WMS server as extra parameters in each request URL. This can be useful for
		// [non-standard vendor WMS parameters](http://docs.geoserver.org/stable/en/user/services/wms/vendor.html).
		defaultWmsParams: {
			service: 'WMS',
			request: 'GetMap',

			// @option layers: String = ''
			// **(required)** Comma-separated list of WMS layers to show.
			layers: '',

			// @option styles: String = ''
			// Comma-separated list of WMS styles.
			styles: '',

			// @option format: String = 'image/jpeg'
			// WMS image format (use `'image/png'` for layers with transparency).
			format: 'image/jpeg',

			// @option transparent: Boolean = false
			// If `true`, the WMS service will return images with transparency.
			transparent: false,

			// @option version: String = '1.1.1'
			// Version of the WMS service to use
			version: '1.1.1'
		},

		options: {
			// @option crs: CRS = null
			// Coordinate Reference System to use for the WMS requests, defaults to
			// map CRS. Don't change this if you're not sure what it means.
			crs: null,

			// @option uppercase: Boolean = false
			// If `true`, WMS request parameter keys will be uppercase.
			uppercase: false
		},

		initialize: function (url, options) {

			this._url = url;

			var wmsParams = extend$1({}, this.defaultWmsParams);

			// all keys that are not TileLayer options go to WMS params
			for (var i in options) {
				if (!(i in this.options)) {
					wmsParams[i] = options[i];
				}
			}

			options = setOptions(this, options);

			var realRetina = options.detectRetina && retina ? 2 : 1;
			var tileSize = this.getTileSize();
			wmsParams.width = tileSize.x * realRetina;
			wmsParams.height = tileSize.y * realRetina;

			this.wmsParams = wmsParams;
		},

		onAdd: function (map) {

			this._crs = this.options.crs || map.options.crs;
			this._wmsVersion = parseFloat(this.wmsParams.version);

			var projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';
			this.wmsParams[projectionKey] = this._crs.code;

			TileLayer.prototype.onAdd.call(this, map);
		},

		getTileUrl: function (coords) {

			var tileBounds = this._tileCoordsToNwSe(coords),
			    crs = this._crs,
			    bounds = toBounds(crs.project(tileBounds[0]), crs.project(tileBounds[1])),
			    min = bounds.min,
			    max = bounds.max,
			    bbox = (this._wmsVersion >= 1.3 && this._crs === EPSG4326 ?
			    [min.y, min.x, max.y, max.x] :
			    [min.x, min.y, max.x, max.y]).join(','),
			    url = TileLayer.prototype.getTileUrl.call(this, coords);
			return url +
				getParamString(this.wmsParams, url, this.options.uppercase) +
				(this.options.uppercase ? '&BBOX=' : '&bbox=') + bbox;
		},

		// @method setParams(params: Object, noRedraw?: Boolean): this
		// Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).
		setParams: function (params, noRedraw) {

			extend$1(this.wmsParams, params);

			if (!noRedraw) {
				this.redraw();
			}

			return this;
		}
	});

	TileLayer.WMS = TileLayerWMS;

	/*
	 * @class Renderer
	 * @inherits Layer
	 * @aka L.Renderer
	 *
	 * Base class for vector renderer implementations (`SVG`, `Canvas`). Handles the
	 * DOM container of the renderer, its bounds, and its zoom animation.
	 *
	 * A `Renderer` works as an implicit layer group for all `Path`s - the renderer
	 * itself can be added or removed to the map. All paths use a renderer, which can
	 * be implicit (the map will decide the type of renderer and use it automatically)
	 * or explicit (using the [`renderer`](#path-renderer) option of the path).
	 *
	 * Do not use this class directly, use `SVG` and `Canvas` instead.
	 *
	 * @event update: Event
	 * Fired when the renderer updates its bounds, center and zoom, for example when
	 * its map has moved
	 */

	var Renderer = Layer.extend({

		// @section
		// @aka Renderer options
		options: {
			// @option padding: Number = 0.1
			// How much to extend the clip area around the map view (relative to its size)
			// e.g. 0.1 would be 10% of map view in each direction
			padding: 0.1,

			// @option tolerance: Number = 0
			// How much to extend click tolerance round a path/object on the map
			tolerance : 0
		},

		initialize: function (options) {
			setOptions(this, options);
			stamp(this);
			this._layers = this._layers || {};
		},

		onAdd: function () {
			if (!this._container) {
				this._initContainer(); // defined by renderer implementations

				if (this._zoomAnimated) {
					addClass(this._container, 'leaflet-zoom-animated');
				}
			}

			this.getPane().appendChild(this._container);
			this._update();
			this.on('update', this._updatePaths, this);
		},

		onRemove: function () {
			this.off('update', this._updatePaths, this);
			this._destroyContainer();
		},

		getEvents: function () {
			var events = {
				viewreset: this._reset,
				zoom: this._onZoom,
				moveend: this._update,
				zoomend: this._onZoomEnd
			};
			if (this._zoomAnimated) {
				events.zoomanim = this._onAnimZoom;
			}
			return events;
		},

		_onAnimZoom: function (ev) {
			this._updateTransform(ev.center, ev.zoom);
		},

		_onZoom: function () {
			this._updateTransform(this._map.getCenter(), this._map.getZoom());
		},

		_updateTransform: function (center, zoom) {
			var scale = this._map.getZoomScale(zoom, this._zoom),
			    position = getPosition$1(this._container),
			    viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding),
			    currentCenterPoint = this._map.project(this._center, zoom),
			    destCenterPoint = this._map.project(center, zoom),
			    centerOffset = destCenterPoint.subtract(currentCenterPoint),

			    topLeftOffset = viewHalf.multiplyBy(-scale).add(position).add(viewHalf).subtract(centerOffset);

			if (any3d) {
				setTransform(this._container, topLeftOffset, scale);
			} else {
				setPosition(this._container, topLeftOffset);
			}
		},

		_reset: function () {
			this._update();
			this._updateTransform(this._center, this._zoom);

			for (var id in this._layers) {
				this._layers[id]._reset();
			}
		},

		_onZoomEnd: function () {
			for (var id in this._layers) {
				this._layers[id]._project();
			}
		},

		_updatePaths: function () {
			for (var id in this._layers) {
				this._layers[id]._update();
			}
		},

		_update: function () {
			// Update pixel bounds of renderer container (for positioning/sizing/clipping later)
			// Subclasses are responsible of firing the 'update' event.
			var p = this.options.padding,
			    size = this._map.getSize(),
			    min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();

			this._bounds = new Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());

			this._center = this._map.getCenter();
			this._zoom = this._map.getZoom();
		}
	});

	/*
	 * @class Canvas
	 * @inherits Renderer
	 * @aka L.Canvas
	 *
	 * Allows vector layers to be displayed with [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).
	 * Inherits `Renderer`.
	 *
	 * Due to [technical limitations](http://caniuse.com/#search=canvas), Canvas is not
	 * available in all web browsers, notably IE8, and overlapping geometries might
	 * not display properly in some edge cases.
	 *
	 * @example
	 *
	 * Use Canvas by default for all paths in the map:
	 *
	 * ```js
	 * var map = L.map('map', {
	 * 	renderer: L.canvas()
	 * });
	 * ```
	 *
	 * Use a Canvas renderer with extra padding for specific vector geometries:
	 *
	 * ```js
	 * var map = L.map('map');
	 * var myRenderer = L.canvas({ padding: 0.5 });
	 * var line = L.polyline( coordinates, { renderer: myRenderer } );
	 * var circle = L.circle( center, { renderer: myRenderer } );
	 * ```
	 */

	var Canvas = Renderer.extend({
		getEvents: function () {
			var events = Renderer.prototype.getEvents.call(this);
			events.viewprereset = this._onViewPreReset;
			return events;
		},

		_onViewPreReset: function () {
			// Set a flag so that a viewprereset+moveend+viewreset only updates&redraws once
			this._postponeUpdatePaths = true;
		},

		onAdd: function () {
			Renderer.prototype.onAdd.call(this);

			// Redraw vectors since canvas is cleared upon removal,
			// in case of removing the renderer itself from the map.
			this._draw();
		},

		_initContainer: function () {
			var container = this._container = document.createElement('canvas');

			on(container, 'mousemove', this._onMouseMove, this);
			on(container, 'click dblclick mousedown mouseup contextmenu', this._onClick, this);
			on(container, 'mouseout', this._handleMouseOut, this);

			this._ctx = container.getContext('2d');
		},

		_destroyContainer: function () {
			cancelAnimFrame(this._redrawRequest);
			delete this._ctx;
			remove(this._container);
			off(this._container);
			delete this._container;
		},

		_updatePaths: function () {
			if (this._postponeUpdatePaths) { return; }

			var layer;
			this._redrawBounds = null;
			for (var id in this._layers) {
				layer = this._layers[id];
				layer._update();
			}
			this._redraw();
		},

		_update: function () {
			if (this._map._animatingZoom && this._bounds) { return; }

			Renderer.prototype._update.call(this);

			var b = this._bounds,
			    container = this._container,
			    size = b.getSize(),
			    m = retina ? 2 : 1;

			setPosition(container, b.min);

			// set canvas size (also clearing it); use double size on retina
			container.width = m * size.x;
			container.height = m * size.y;
			container.style.width = size.x + 'px';
			container.style.height = size.y + 'px';

			if (retina) {
				this._ctx.scale(2, 2);
			}

			// translate so we use the same path coordinates after canvas element moves
			this._ctx.translate(-b.min.x, -b.min.y);

			// Tell paths to redraw themselves
			this.fire('update');
		},

		_reset: function () {
			Renderer.prototype._reset.call(this);

			if (this._postponeUpdatePaths) {
				this._postponeUpdatePaths = false;
				this._updatePaths();
			}
		},

		_initPath: function (layer) {
			this._updateDashArray(layer);
			this._layers[stamp(layer)] = layer;

			var order = layer._order = {
				layer: layer,
				prev: this._drawLast,
				next: null
			};
			if (this._drawLast) { this._drawLast.next = order; }
			this._drawLast = order;
			this._drawFirst = this._drawFirst || this._drawLast;
		},

		_addPath: function (layer) {
			this._requestRedraw(layer);
		},

		_removePath: function (layer) {
			var order = layer._order;
			var next = order.next;
			var prev = order.prev;

			if (next) {
				next.prev = prev;
			} else {
				this._drawLast = prev;
			}
			if (prev) {
				prev.next = next;
			} else {
				this._drawFirst = next;
			}

			delete layer._order;

			delete this._layers[stamp(layer)];

			this._requestRedraw(layer);
		},

		_updatePath: function (layer) {
			// Redraw the union of the layer's old pixel
			// bounds and the new pixel bounds.
			this._extendRedrawBounds(layer);
			layer._project();
			layer._update();
			// The redraw will extend the redraw bounds
			// with the new pixel bounds.
			this._requestRedraw(layer);
		},

		_updateStyle: function (layer) {
			this._updateDashArray(layer);
			this._requestRedraw(layer);
		},

		_updateDashArray: function (layer) {
			if (typeof layer.options.dashArray === 'string') {
				var parts = layer.options.dashArray.split(/[, ]+/),
				    dashArray = [],
				    dashValue,
				    i;
				for (i = 0; i < parts.length; i++) {
					dashValue = Number(parts[i]);
					// Ignore dash array containing invalid lengths
					if (isNaN(dashValue)) { return; }
					dashArray.push(dashValue);
				}
				layer.options._dashArray = dashArray;
			} else {
				layer.options._dashArray = layer.options.dashArray;
			}
		},

		_requestRedraw: function (layer) {
			if (!this._map) { return; }

			this._extendRedrawBounds(layer);
			this._redrawRequest = this._redrawRequest || requestAnimFrame(this._redraw, this);
		},

		_extendRedrawBounds: function (layer) {
			if (layer._pxBounds) {
				var padding = (layer.options.weight || 0) + 1;
				this._redrawBounds = this._redrawBounds || new Bounds();
				this._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));
				this._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));
			}
		},

		_redraw: function () {
			this._redrawRequest = null;

			if (this._redrawBounds) {
				this._redrawBounds.min._floor();
				this._redrawBounds.max._ceil();
			}

			this._clear(); // clear layers in redraw bounds
			this._draw(); // draw layers

			this._redrawBounds = null;
		},

		_clear: function () {
			var bounds = this._redrawBounds;
			if (bounds) {
				var size = bounds.getSize();
				this._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);
			} else {
				this._ctx.clearRect(0, 0, this._container.width, this._container.height);
			}
		},

		_draw: function () {
			var layer, bounds = this._redrawBounds;
			this._ctx.save();
			if (bounds) {
				var size = bounds.getSize();
				this._ctx.beginPath();
				this._ctx.rect(bounds.min.x, bounds.min.y, size.x, size.y);
				this._ctx.clip();
			}

			this._drawing = true;

			for (var order = this._drawFirst; order; order = order.next) {
				layer = order.layer;
				if (!bounds || (layer._pxBounds && layer._pxBounds.intersects(bounds))) {
					layer._updatePath();
				}
			}

			this._drawing = false;

			this._ctx.restore();  // Restore state before clipping.
		},

		_updatePoly: function (layer, closed) {
			if (!this._drawing) { return; }

			var i, j, len2, p,
			    parts = layer._parts,
			    len = parts.length,
			    ctx = this._ctx;

			if (!len) { return; }

			ctx.beginPath();

			for (i = 0; i < len; i++) {
				for (j = 0, len2 = parts[i].length; j < len2; j++) {
					p = parts[i][j];
					ctx[j ? 'lineTo' : 'moveTo'](p.x, p.y);
				}
				if (closed) {
					ctx.closePath();
				}
			}

			this._fillStroke(ctx, layer);

			// TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature
		},

		_updateCircle: function (layer) {

			if (!this._drawing || layer._empty()) { return; }

			var p = layer._point,
			    ctx = this._ctx,
			    r = Math.max(Math.round(layer._radius), 1),
			    s = (Math.max(Math.round(layer._radiusY), 1) || r) / r;

			if (s !== 1) {
				ctx.save();
				ctx.scale(1, s);
			}

			ctx.beginPath();
			ctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);

			if (s !== 1) {
				ctx.restore();
			}

			this._fillStroke(ctx, layer);
		},

		_fillStroke: function (ctx, layer) {
			var options = layer.options;

			if (options.fill) {
				ctx.globalAlpha = options.fillOpacity;
				ctx.fillStyle = options.fillColor || options.color;
				ctx.fill(options.fillRule || 'evenodd');
			}

			if (options.stroke && options.weight !== 0) {
				if (ctx.setLineDash) {
					ctx.setLineDash(layer.options && layer.options._dashArray || []);
				}
				ctx.globalAlpha = options.opacity;
				ctx.lineWidth = options.weight;
				ctx.strokeStyle = options.color;
				ctx.lineCap = options.lineCap;
				ctx.lineJoin = options.lineJoin;
				ctx.stroke();
			}
		},

		// Canvas obviously doesn't have mouse events for individual drawn objects,
		// so we emulate that by calculating what's under the mouse on mousemove/click manually

		_onClick: function (e) {
			var point = this._map.mouseEventToLayerPoint(e), layer, clickedLayer;

			for (var order = this._drawFirst; order; order = order.next) {
				layer = order.layer;
				if (layer.options.interactive && layer._containsPoint(point) && !this._map._draggableMoved(layer)) {
					clickedLayer = layer;
				}
			}
			if (clickedLayer)  {
				fakeStop(e);
				this._fireEvent([clickedLayer], e);
			}
		},

		_onMouseMove: function (e) {
			if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) { return; }

			var point = this._map.mouseEventToLayerPoint(e);
			this._handleMouseHover(e, point);
		},


		_handleMouseOut: function (e) {
			var layer = this._hoveredLayer;
			if (layer) {
				// if we're leaving the layer, fire mouseout
				removeClass(this._container, 'leaflet-interactive');
				this._fireEvent([layer], e, 'mouseout');
				this._hoveredLayer = null;
				this._mouseHoverThrottled = false;
			}
		},

		_handleMouseHover: function (e, point) {
			if (this._mouseHoverThrottled) {
				return;
			}

			var layer, candidateHoveredLayer;

			for (var order = this._drawFirst; order; order = order.next) {
				layer = order.layer;
				if (layer.options.interactive && layer._containsPoint(point)) {
					candidateHoveredLayer = layer;
				}
			}

			if (candidateHoveredLayer !== this._hoveredLayer) {
				this._handleMouseOut(e);

				if (candidateHoveredLayer) {
					addClass(this._container, 'leaflet-interactive'); // change cursor
					this._fireEvent([candidateHoveredLayer], e, 'mouseover');
					this._hoveredLayer = candidateHoveredLayer;
				}
			}

			if (this._hoveredLayer) {
				this._fireEvent([this._hoveredLayer], e);
			}

			this._mouseHoverThrottled = true;
			setTimeout(L.bind(function () {
				this._mouseHoverThrottled = false;
			}, this), 32);
		},

		_fireEvent: function (layers, e, type) {
			this._map._fireDOMEvent(e, type || e.type, layers);
		},

		_bringToFront: function (layer) {
			var order = layer._order;

			if (!order) { return; }

			var next = order.next;
			var prev = order.prev;

			if (next) {
				next.prev = prev;
			} else {
				// Already last
				return;
			}
			if (prev) {
				prev.next = next;
			} else if (next) {
				// Update first entry unless this is the
				// single entry
				this._drawFirst = next;
			}

			order.prev = this._drawLast;
			this._drawLast.next = order;

			order.next = null;
			this._drawLast = order;

			this._requestRedraw(layer);
		},

		_bringToBack: function (layer) {
			var order = layer._order;

			if (!order) { return; }

			var next = order.next;
			var prev = order.prev;

			if (prev) {
				prev.next = next;
			} else {
				// Already first
				return;
			}
			if (next) {
				next.prev = prev;
			} else if (prev) {
				// Update last entry unless this is the
				// single entry
				this._drawLast = prev;
			}

			order.prev = null;

			order.next = this._drawFirst;
			this._drawFirst.prev = order;
			this._drawFirst = order;

			this._requestRedraw(layer);
		}
	});

	// @factory L.canvas(options?: Renderer options)
	// Creates a Canvas renderer with the given options.
	function canvas$1(options) {
		return canvas ? new Canvas(options) : null;
	}

	/*
	 * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!
	 */


	var vmlCreate = (function () {
		try {
			document.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');
			return function (name) {
				return document.createElement('<lvml:' + name + ' class="lvml">');
			};
		} catch (e) {
			return function (name) {
				return document.createElement('<' + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
			};
		}
	})();


	/*
	 * @class SVG
	 *
	 *
	 * VML was deprecated in 2012, which means VML functionality exists only for backwards compatibility
	 * with old versions of Internet Explorer.
	 */

	// mixin to redefine some SVG methods to handle VML syntax which is similar but with some differences
	var vmlMixin = {

		_initContainer: function () {
			this._container = create$1$1('div', 'leaflet-vml-container');
		},

		_update: function () {
			if (this._map._animatingZoom) { return; }
			Renderer.prototype._update.call(this);
			this.fire('update');
		},

		_initPath: function (layer) {
			var container = layer._container = vmlCreate('shape');

			addClass(container, 'leaflet-vml-shape ' + (this.options.className || ''));

			container.coordsize = '1 1';

			layer._path = vmlCreate('path');
			container.appendChild(layer._path);

			this._updateStyle(layer);
			this._layers[stamp(layer)] = layer;
		},

		_addPath: function (layer) {
			var container = layer._container;
			this._container.appendChild(container);

			if (layer.options.interactive) {
				layer.addInteractiveTarget(container);
			}
		},

		_removePath: function (layer) {
			var container = layer._container;
			remove(container);
			layer.removeInteractiveTarget(container);
			delete this._layers[stamp(layer)];
		},

		_updateStyle: function (layer) {
			var stroke = layer._stroke,
			    fill = layer._fill,
			    options = layer.options,
			    container = layer._container;

			container.stroked = !!options.stroke;
			container.filled = !!options.fill;

			if (options.stroke) {
				if (!stroke) {
					stroke = layer._stroke = vmlCreate('stroke');
				}
				container.appendChild(stroke);
				stroke.weight = options.weight + 'px';
				stroke.color = options.color;
				stroke.opacity = options.opacity;

				if (options.dashArray) {
					stroke.dashStyle = isArray$2(options.dashArray) ?
					    options.dashArray.join(' ') :
					    options.dashArray.replace(/( *, *)/g, ' ');
				} else {
					stroke.dashStyle = '';
				}
				stroke.endcap = options.lineCap.replace('butt', 'flat');
				stroke.joinstyle = options.lineJoin;

			} else if (stroke) {
				container.removeChild(stroke);
				layer._stroke = null;
			}

			if (options.fill) {
				if (!fill) {
					fill = layer._fill = vmlCreate('fill');
				}
				container.appendChild(fill);
				fill.color = options.fillColor || options.color;
				fill.opacity = options.fillOpacity;

			} else if (fill) {
				container.removeChild(fill);
				layer._fill = null;
			}
		},

		_updateCircle: function (layer) {
			var p = layer._point.round(),
			    r = Math.round(layer._radius),
			    r2 = Math.round(layer._radiusY || r);

			this._setPath(layer, layer._empty() ? 'M0 0' :
				'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r2 + ' 0,' + (65535 * 360));
		},

		_setPath: function (layer, path) {
			layer._path.v = path;
		},

		_bringToFront: function (layer) {
			toFront(layer._container);
		},

		_bringToBack: function (layer) {
			toBack(layer._container);
		}
	};

	var create$2$1 = vml ? vmlCreate : svgCreate;

	/*
	 * @class SVG
	 * @inherits Renderer
	 * @aka L.SVG
	 *
	 * Allows vector layers to be displayed with [SVG](https://developer.mozilla.org/docs/Web/SVG).
	 * Inherits `Renderer`.
	 *
	 * Due to [technical limitations](http://caniuse.com/#search=svg), SVG is not
	 * available in all web browsers, notably Android 2.x and 3.x.
	 *
	 * Although SVG is not available on IE7 and IE8, these browsers support
	 * [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language)
	 * (a now deprecated technology), and the SVG renderer will fall back to VML in
	 * this case.
	 *
	 * @example
	 *
	 * Use SVG by default for all paths in the map:
	 *
	 * ```js
	 * var map = L.map('map', {
	 * 	renderer: L.svg()
	 * });
	 * ```
	 *
	 * Use a SVG renderer with extra padding for specific vector geometries:
	 *
	 * ```js
	 * var map = L.map('map');
	 * var myRenderer = L.svg({ padding: 0.5 });
	 * var line = L.polyline( coordinates, { renderer: myRenderer } );
	 * var circle = L.circle( center, { renderer: myRenderer } );
	 * ```
	 */

	var SVG = Renderer.extend({

		getEvents: function () {
			var events = Renderer.prototype.getEvents.call(this);
			events.zoomstart = this._onZoomStart;
			return events;
		},

		_initContainer: function () {
			this._container = create$2$1('svg');

			// makes it possible to click through svg root; we'll reset it back in individual paths
			this._container.setAttribute('pointer-events', 'none');

			this._rootGroup = create$2$1('g');
			this._container.appendChild(this._rootGroup);
		},

		_destroyContainer: function () {
			remove(this._container);
			off(this._container);
			delete this._container;
			delete this._rootGroup;
			delete this._svgSize;
		},

		_onZoomStart: function () {
			// Drag-then-pinch interactions might mess up the center and zoom.
			// In this case, the easiest way to prevent this is re-do the renderer
			//   bounds and padding when the zooming starts.
			this._update();
		},

		_update: function () {
			if (this._map._animatingZoom && this._bounds) { return; }

			Renderer.prototype._update.call(this);

			var b = this._bounds,
			    size = b.getSize(),
			    container = this._container;

			// set size of svg-container if changed
			if (!this._svgSize || !this._svgSize.equals(size)) {
				this._svgSize = size;
				container.setAttribute('width', size.x);
				container.setAttribute('height', size.y);
			}

			// movement: update container viewBox so that we don't have to change coordinates of individual layers
			setPosition(container, b.min);
			container.setAttribute('viewBox', [b.min.x, b.min.y, size.x, size.y].join(' '));

			this.fire('update');
		},

		// methods below are called by vector layers implementations

		_initPath: function (layer) {
			var path = layer._path = create$2$1('path');

			// @namespace Path
			// @option className: String = null
			// Custom class name set on an element. Only for SVG renderer.
			if (layer.options.className) {
				addClass(path, layer.options.className);
			}

			if (layer.options.interactive) {
				addClass(path, 'leaflet-interactive');
			}

			this._updateStyle(layer);
			this._layers[stamp(layer)] = layer;
		},

		_addPath: function (layer) {
			if (!this._rootGroup) { this._initContainer(); }
			this._rootGroup.appendChild(layer._path);
			layer.addInteractiveTarget(layer._path);
		},

		_removePath: function (layer) {
			remove(layer._path);
			layer.removeInteractiveTarget(layer._path);
			delete this._layers[stamp(layer)];
		},

		_updatePath: function (layer) {
			layer._project();
			layer._update();
		},

		_updateStyle: function (layer) {
			var path = layer._path,
			    options = layer.options;

			if (!path) { return; }

			if (options.stroke) {
				path.setAttribute('stroke', options.color);
				path.setAttribute('stroke-opacity', options.opacity);
				path.setAttribute('stroke-width', options.weight);
				path.setAttribute('stroke-linecap', options.lineCap);
				path.setAttribute('stroke-linejoin', options.lineJoin);

				if (options.dashArray) {
					path.setAttribute('stroke-dasharray', options.dashArray);
				} else {
					path.removeAttribute('stroke-dasharray');
				}

				if (options.dashOffset) {
					path.setAttribute('stroke-dashoffset', options.dashOffset);
				} else {
					path.removeAttribute('stroke-dashoffset');
				}
			} else {
				path.setAttribute('stroke', 'none');
			}

			if (options.fill) {
				path.setAttribute('fill', options.fillColor || options.color);
				path.setAttribute('fill-opacity', options.fillOpacity);
				path.setAttribute('fill-rule', options.fillRule || 'evenodd');
			} else {
				path.setAttribute('fill', 'none');
			}
		},

		_updatePoly: function (layer, closed) {
			this._setPath(layer, pointsToPath(layer._parts, closed));
		},

		_updateCircle: function (layer) {
			var p = layer._point,
			    r = Math.max(Math.round(layer._radius), 1),
			    r2 = Math.max(Math.round(layer._radiusY), 1) || r,
			    arc = 'a' + r + ',' + r2 + ' 0 1,0 ';

			// drawing a circle with two half-arcs
			var d = layer._empty() ? 'M0 0' :
				'M' + (p.x - r) + ',' + p.y +
				arc + (r * 2) + ',0 ' +
				arc + (-r * 2) + ',0 ';

			this._setPath(layer, d);
		},

		_setPath: function (layer, path) {
			layer._path.setAttribute('d', path);
		},

		// SVG does not have the concept of zIndex so we resort to changing the DOM order of elements
		_bringToFront: function (layer) {
			toFront(layer._path);
		},

		_bringToBack: function (layer) {
			toBack(layer._path);
		}
	});

	if (vml) {
		SVG.include(vmlMixin);
	}

	// @namespace SVG
	// @factory L.svg(options?: Renderer options)
	// Creates a SVG renderer with the given options.
	function svg$1(options) {
		return svg || vml ? new SVG(options) : null;
	}

	Map$1.include({
		// @namespace Map; @method getRenderer(layer: Path): Renderer
		// Returns the instance of `Renderer` that should be used to render the given
		// `Path`. It will ensure that the `renderer` options of the map and paths
		// are respected, and that the renderers do exist on the map.
		getRenderer: function (layer) {
			// @namespace Path; @option renderer: Renderer
			// Use this specific instance of `Renderer` for this path. Takes
			// precedence over the map's [default renderer](#map-renderer).
			var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;

			if (!renderer) {
				renderer = this._renderer = this._createRenderer();
			}

			if (!this.hasLayer(renderer)) {
				this.addLayer(renderer);
			}
			return renderer;
		},

		_getPaneRenderer: function (name) {
			if (name === 'overlayPane' || name === undefined) {
				return false;
			}

			var renderer = this._paneRenderers[name];
			if (renderer === undefined) {
				renderer = this._createRenderer({pane: name});
				this._paneRenderers[name] = renderer;
			}
			return renderer;
		},

		_createRenderer: function (options) {
			// @namespace Map; @option preferCanvas: Boolean = false
			// Whether `Path`s should be rendered on a `Canvas` renderer.
			// By default, all `Path`s are rendered in a `SVG` renderer.
			return (this.options.preferCanvas && canvas$1(options)) || svg$1(options);
		}
	});

	/*
	 * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.
	 */

	/*
	 * @class Rectangle
	 * @aka L.Rectangle
	 * @inherits Polygon
	 *
	 * A class for drawing rectangle overlays on a map. Extends `Polygon`.
	 *
	 * @example
	 *
	 * ```js
	 * // define rectangle geographical bounds
	 * var bounds = [[54.559322, -5.767822], [56.1210604, -3.021240]];
	 *
	 * // create an orange rectangle
	 * L.rectangle(bounds, {color: "#ff7800", weight: 1}).addTo(map);
	 *
	 * // zoom the map to the rectangle bounds
	 * map.fitBounds(bounds);
	 * ```
	 *
	 */


	var Rectangle = Polygon.extend({
		initialize: function (latLngBounds, options) {
			Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);
		},

		// @method setBounds(latLngBounds: LatLngBounds): this
		// Redraws the rectangle with the passed bounds.
		setBounds: function (latLngBounds) {
			return this.setLatLngs(this._boundsToLatLngs(latLngBounds));
		},

		_boundsToLatLngs: function (latLngBounds) {
			latLngBounds = toLatLngBounds(latLngBounds);
			return [
				latLngBounds.getSouthWest(),
				latLngBounds.getNorthWest(),
				latLngBounds.getNorthEast(),
				latLngBounds.getSouthEast()
			];
		}
	});


	// @factory L.rectangle(latLngBounds: LatLngBounds, options?: Polyline options)
	function rectangle$1(latLngBounds, options) {
		return new Rectangle(latLngBounds, options);
	}

	SVG.create = create$2$1;
	SVG.pointsToPath = pointsToPath;

	GeoJSON.geometryToLayer = geometryToLayer;
	GeoJSON.coordsToLatLng = coordsToLatLng;
	GeoJSON.coordsToLatLngs = coordsToLatLngs;
	GeoJSON.latLngToCoords = latLngToCoords;
	GeoJSON.latLngsToCoords = latLngsToCoords;
	GeoJSON.getFeature = getFeature;
	GeoJSON.asFeature = asFeature;

	/*
	 * L.Handler.BoxZoom is used to add shift-drag zoom interaction to the map
	 * (zoom to a selected bounding box), enabled by default.
	 */

	// @namespace Map
	// @section Interaction Options
	Map$1.mergeOptions({
		// @option boxZoom: Boolean = true
		// Whether the map can be zoomed to a rectangular area specified by
		// dragging the mouse while pressing the shift key.
		boxZoom: true
	});

	var BoxZoom = Handler.extend({
		initialize: function (map) {
			this._map = map;
			this._container = map._container;
			this._pane = map._panes.overlayPane;
			this._resetStateTimeout = 0;
			map.on('unload', this._destroy, this);
		},

		addHooks: function () {
			on(this._container, 'mousedown', this._onMouseDown, this);
		},

		removeHooks: function () {
			off(this._container, 'mousedown', this._onMouseDown, this);
		},

		moved: function () {
			return this._moved;
		},

		_destroy: function () {
			remove(this._pane);
			delete this._pane;
		},

		_resetState: function () {
			this._resetStateTimeout = 0;
			this._moved = false;
		},

		_clearDeferredResetState: function () {
			if (this._resetStateTimeout !== 0) {
				clearTimeout(this._resetStateTimeout);
				this._resetStateTimeout = 0;
			}
		},

		_onMouseDown: function (e) {
			if (!e.shiftKey || ((e.which !== 1) && (e.button !== 1))) { return false; }

			// Clear the deferred resetState if it hasn't executed yet, otherwise it
			// will interrupt the interaction and orphan a box element in the container.
			this._clearDeferredResetState();
			this._resetState();

			disableTextSelection();
			disableImageDrag();

			this._startPoint = this._map.mouseEventToContainerPoint(e);

			on(document, {
				contextmenu: stop,
				mousemove: this._onMouseMove,
				mouseup: this._onMouseUp,
				keydown: this._onKeyDown
			}, this);
		},

		_onMouseMove: function (e) {
			if (!this._moved) {
				this._moved = true;

				this._box = create$1$1('div', 'leaflet-zoom-box', this._container);
				addClass(this._container, 'leaflet-crosshair');

				this._map.fire('boxzoomstart');
			}

			this._point = this._map.mouseEventToContainerPoint(e);

			var bounds = new Bounds(this._point, this._startPoint),
			    size = bounds.getSize();

			setPosition(this._box, bounds.min);

			this._box.style.width  = size.x + 'px';
			this._box.style.height = size.y + 'px';
		},

		_finish: function () {
			if (this._moved) {
				remove(this._box);
				removeClass(this._container, 'leaflet-crosshair');
			}

			enableTextSelection();
			enableImageDrag();

			off(document, {
				contextmenu: stop,
				mousemove: this._onMouseMove,
				mouseup: this._onMouseUp,
				keydown: this._onKeyDown
			}, this);
		},

		_onMouseUp: function (e) {
			if ((e.which !== 1) && (e.button !== 1)) { return; }

			this._finish();

			if (!this._moved) { return; }
			// Postpone to next JS tick so internal click event handling
			// still see it as "moved".
			this._clearDeferredResetState();
			this._resetStateTimeout = setTimeout(bind(this._resetState, this), 0);

			var bounds = new LatLngBounds(
			        this._map.containerPointToLatLng(this._startPoint),
			        this._map.containerPointToLatLng(this._point));

			this._map
				.fitBounds(bounds)
				.fire('boxzoomend', {boxZoomBounds: bounds});
		},

		_onKeyDown: function (e) {
			if (e.keyCode === 27) {
				this._finish();
			}
		}
	});

	// @section Handlers
	// @property boxZoom: Handler
	// Box (shift-drag with mouse) zoom handler.
	Map$1.addInitHook('addHandler', 'boxZoom', BoxZoom);

	/*
	 * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.
	 */

	// @namespace Map
	// @section Interaction Options

	Map$1.mergeOptions({
		// @option doubleClickZoom: Boolean|String = true
		// Whether the map can be zoomed in by double clicking on it and
		// zoomed out by double clicking while holding shift. If passed
		// `'center'`, double-click zoom will zoom to the center of the
		//  view regardless of where the mouse was.
		doubleClickZoom: true
	});

	var DoubleClickZoom = Handler.extend({
		addHooks: function () {
			this._map.on('dblclick', this._onDoubleClick, this);
		},

		removeHooks: function () {
			this._map.off('dblclick', this._onDoubleClick, this);
		},

		_onDoubleClick: function (e) {
			var map = this._map,
			    oldZoom = map.getZoom(),
			    delta = map.options.zoomDelta,
			    zoom = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;

			if (map.options.doubleClickZoom === 'center') {
				map.setZoom(zoom);
			} else {
				map.setZoomAround(e.containerPoint, zoom);
			}
		}
	});

	// @section Handlers
	//
	// Map properties include interaction handlers that allow you to control
	// interaction behavior in runtime, enabling or disabling certain features such
	// as dragging or touch zoom (see `Handler` methods). For example:
	//
	// ```js
	// map.doubleClickZoom.disable();
	// ```
	//
	// @property doubleClickZoom: Handler
	// Double click zoom handler.
	Map$1.addInitHook('addHandler', 'doubleClickZoom', DoubleClickZoom);

	/*
	 * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.
	 */

	// @namespace Map
	// @section Interaction Options
	Map$1.mergeOptions({
		// @option dragging: Boolean = true
		// Whether the map be draggable with mouse/touch or not.
		dragging: true,

		// @section Panning Inertia Options
		// @option inertia: Boolean = *
		// If enabled, panning of the map will have an inertia effect where
		// the map builds momentum while dragging and continues moving in
		// the same direction for some time. Feels especially nice on touch
		// devices. Enabled by default unless running on old Android devices.
		inertia: !android23,

		// @option inertiaDeceleration: Number = 3000
		// The rate with which the inertial movement slows down, in pixels/second².
		inertiaDeceleration: 3400, // px/s^2

		// @option inertiaMaxSpeed: Number = Infinity
		// Max speed of the inertial movement, in pixels/second.
		inertiaMaxSpeed: Infinity, // px/s

		// @option easeLinearity: Number = 0.2
		easeLinearity: 0.2,

		// TODO refactor, move to CRS
		// @option worldCopyJump: Boolean = false
		// With this option enabled, the map tracks when you pan to another "copy"
		// of the world and seamlessly jumps to the original one so that all overlays
		// like markers and vector layers are still visible.
		worldCopyJump: false,

		// @option maxBoundsViscosity: Number = 0.0
		// If `maxBounds` is set, this option will control how solid the bounds
		// are when dragging the map around. The default value of `0.0` allows the
		// user to drag outside the bounds at normal speed, higher values will
		// slow down map dragging outside bounds, and `1.0` makes the bounds fully
		// solid, preventing the user from dragging outside the bounds.
		maxBoundsViscosity: 0.0
	});

	var Drag = Handler.extend({
		addHooks: function () {
			if (!this._draggable) {
				var map = this._map;

				this._draggable = new Draggable(map._mapPane, map._container);

				this._draggable.on({
					dragstart: this._onDragStart,
					drag: this._onDrag,
					dragend: this._onDragEnd
				}, this);

				this._draggable.on('predrag', this._onPreDragLimit, this);
				if (map.options.worldCopyJump) {
					this._draggable.on('predrag', this._onPreDragWrap, this);
					map.on('zoomend', this._onZoomEnd, this);

					map.whenReady(this._onZoomEnd, this);
				}
			}
			addClass(this._map._container, 'leaflet-grab leaflet-touch-drag');
			this._draggable.enable();
			this._positions = [];
			this._times = [];
		},

		removeHooks: function () {
			removeClass(this._map._container, 'leaflet-grab');
			removeClass(this._map._container, 'leaflet-touch-drag');
			this._draggable.disable();
		},

		moved: function () {
			return this._draggable && this._draggable._moved;
		},

		moving: function () {
			return this._draggable && this._draggable._moving;
		},

		_onDragStart: function () {
			var map = this._map;

			map._stop();
			if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
				var bounds = toLatLngBounds(this._map.options.maxBounds);

				this._offsetLimit = toBounds(
					this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1),
					this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1)
						.add(this._map.getSize()));

				this._viscosity = Math.min(1.0, Math.max(0.0, this._map.options.maxBoundsViscosity));
			} else {
				this._offsetLimit = null;
			}

			map
			    .fire('movestart')
			    .fire('dragstart');

			if (map.options.inertia) {
				this._positions = [];
				this._times = [];
			}
		},

		_onDrag: function (e) {
			if (this._map.options.inertia) {
				var time = this._lastTime = +new Date(),
				    pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;

				this._positions.push(pos);
				this._times.push(time);

				this._prunePositions(time);
			}

			this._map
			    .fire('move', e)
			    .fire('drag', e);
		},

		_prunePositions: function (time) {
			while (this._positions.length > 1 && time - this._times[0] > 50) {
				this._positions.shift();
				this._times.shift();
			}
		},

		_onZoomEnd: function () {
			var pxCenter = this._map.getSize().divideBy(2),
			    pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);

			this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
			this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
		},

		_viscousLimit: function (value, threshold) {
			return value - (value - threshold) * this._viscosity;
		},

		_onPreDragLimit: function () {
			if (!this._viscosity || !this._offsetLimit) { return; }

			var offset = this._draggable._newPos.subtract(this._draggable._startPos);

			var limit = this._offsetLimit;
			if (offset.x < limit.min.x) { offset.x = this._viscousLimit(offset.x, limit.min.x); }
			if (offset.y < limit.min.y) { offset.y = this._viscousLimit(offset.y, limit.min.y); }
			if (offset.x > limit.max.x) { offset.x = this._viscousLimit(offset.x, limit.max.x); }
			if (offset.y > limit.max.y) { offset.y = this._viscousLimit(offset.y, limit.max.y); }

			this._draggable._newPos = this._draggable._startPos.add(offset);
		},

		_onPreDragWrap: function () {
			// TODO refactor to be able to adjust map pane position after zoom
			var worldWidth = this._worldWidth,
			    halfWidth = Math.round(worldWidth / 2),
			    dx = this._initialWorldOffset,
			    x = this._draggable._newPos.x,
			    newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,
			    newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,
			    newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;

			this._draggable._absPos = this._draggable._newPos.clone();
			this._draggable._newPos.x = newX;
		},

		_onDragEnd: function (e) {
			var map = this._map,
			    options = map.options,

			    noInertia = !options.inertia || this._times.length < 2;

			map.fire('dragend', e);

			if (noInertia) {
				map.fire('moveend');

			} else {
				this._prunePositions(+new Date());

				var direction = this._lastPos.subtract(this._positions[0]),
				    duration = (this._lastTime - this._times[0]) / 1000,
				    ease = options.easeLinearity,

				    speedVector = direction.multiplyBy(ease / duration),
				    speed = speedVector.distanceTo([0, 0]),

				    limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),
				    limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),

				    decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),
				    offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();

				if (!offset.x && !offset.y) {
					map.fire('moveend');

				} else {
					offset = map._limitOffset(offset, map.options.maxBounds);

					requestAnimFrame(function () {
						map.panBy(offset, {
							duration: decelerationDuration,
							easeLinearity: ease,
							noMoveStart: true,
							animate: true
						});
					});
				}
			}
		}
	});

	// @section Handlers
	// @property dragging: Handler
	// Map dragging handler (by both mouse and touch).
	Map$1.addInitHook('addHandler', 'dragging', Drag);

	/*
	 * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.
	 */

	// @namespace Map
	// @section Keyboard Navigation Options
	Map$1.mergeOptions({
		// @option keyboard: Boolean = true
		// Makes the map focusable and allows users to navigate the map with keyboard
		// arrows and `+`/`-` keys.
		keyboard: true,

		// @option keyboardPanDelta: Number = 80
		// Amount of pixels to pan when pressing an arrow key.
		keyboardPanDelta: 80
	});

	var Keyboard = Handler.extend({

		keyCodes: {
			left:    [37],
			right:   [39],
			down:    [40],
			up:      [38],
			zoomIn:  [187, 107, 61, 171],
			zoomOut: [189, 109, 54, 173]
		},

		initialize: function (map) {
			this._map = map;

			this._setPanDelta(map.options.keyboardPanDelta);
			this._setZoomDelta(map.options.zoomDelta);
		},

		addHooks: function () {
			var container = this._map._container;

			// make the container focusable by tabbing
			if (container.tabIndex <= 0) {
				container.tabIndex = '0';
			}

			on(container, {
				focus: this._onFocus,
				blur: this._onBlur,
				mousedown: this._onMouseDown
			}, this);

			this._map.on({
				focus: this._addHooks,
				blur: this._removeHooks
			}, this);
		},

		removeHooks: function () {
			this._removeHooks();

			off(this._map._container, {
				focus: this._onFocus,
				blur: this._onBlur,
				mousedown: this._onMouseDown
			}, this);

			this._map.off({
				focus: this._addHooks,
				blur: this._removeHooks
			}, this);
		},

		_onMouseDown: function () {
			if (this._focused) { return; }

			var body = document.body,
			    docEl = document.documentElement,
			    top = body.scrollTop || docEl.scrollTop,
			    left = body.scrollLeft || docEl.scrollLeft;

			this._map._container.focus();

			window.scrollTo(left, top);
		},

		_onFocus: function () {
			this._focused = true;
			this._map.fire('focus');
		},

		_onBlur: function () {
			this._focused = false;
			this._map.fire('blur');
		},

		_setPanDelta: function (panDelta) {
			var keys = this._panKeys = {},
			    codes = this.keyCodes,
			    i, len;

			for (i = 0, len = codes.left.length; i < len; i++) {
				keys[codes.left[i]] = [-1 * panDelta, 0];
			}
			for (i = 0, len = codes.right.length; i < len; i++) {
				keys[codes.right[i]] = [panDelta, 0];
			}
			for (i = 0, len = codes.down.length; i < len; i++) {
				keys[codes.down[i]] = [0, panDelta];
			}
			for (i = 0, len = codes.up.length; i < len; i++) {
				keys[codes.up[i]] = [0, -1 * panDelta];
			}
		},

		_setZoomDelta: function (zoomDelta) {
			var keys = this._zoomKeys = {},
			    codes = this.keyCodes,
			    i, len;

			for (i = 0, len = codes.zoomIn.length; i < len; i++) {
				keys[codes.zoomIn[i]] = zoomDelta;
			}
			for (i = 0, len = codes.zoomOut.length; i < len; i++) {
				keys[codes.zoomOut[i]] = -zoomDelta;
			}
		},

		_addHooks: function () {
			on(document, 'keydown', this._onKeyDown, this);
		},

		_removeHooks: function () {
			off(document, 'keydown', this._onKeyDown, this);
		},

		_onKeyDown: function (e) {
			if (e.altKey || e.ctrlKey || e.metaKey) { return; }

			var key = e.keyCode,
			    map = this._map,
			    offset;

			if (key in this._panKeys) {
				if (!map._panAnim || !map._panAnim._inProgress) {
					offset = this._panKeys[key];
					if (e.shiftKey) {
						offset = toPoint(offset).multiplyBy(3);
					}

					map.panBy(offset);

					if (map.options.maxBounds) {
						map.panInsideBounds(map.options.maxBounds);
					}
				}
			} else if (key in this._zoomKeys) {
				map.setZoom(map.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);

			} else if (key === 27 && map._popup && map._popup.options.closeOnEscapeKey) {
				map.closePopup();

			} else {
				return;
			}

			stop(e);
		}
	});

	// @section Handlers
	// @section Handlers
	// @property keyboard: Handler
	// Keyboard navigation handler.
	Map$1.addInitHook('addHandler', 'keyboard', Keyboard);

	/*
	 * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.
	 */

	// @namespace Map
	// @section Interaction Options
	Map$1.mergeOptions({
		// @section Mousewheel options
		// @option scrollWheelZoom: Boolean|String = true
		// Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,
		// it will zoom to the center of the view regardless of where the mouse was.
		scrollWheelZoom: true,

		// @option wheelDebounceTime: Number = 40
		// Limits the rate at which a wheel can fire (in milliseconds). By default
		// user can't zoom via wheel more often than once per 40 ms.
		wheelDebounceTime: 40,

		// @option wheelPxPerZoomLevel: Number = 60
		// How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))
		// mean a change of one full zoom level. Smaller values will make wheel-zooming
		// faster (and vice versa).
		wheelPxPerZoomLevel: 60
	});

	var ScrollWheelZoom = Handler.extend({
		addHooks: function () {
			on(this._map._container, 'mousewheel', this._onWheelScroll, this);

			this._delta = 0;
		},

		removeHooks: function () {
			off(this._map._container, 'mousewheel', this._onWheelScroll, this);
		},

		_onWheelScroll: function (e) {
			var delta = getWheelDelta(e);

			var debounce = this._map.options.wheelDebounceTime;

			this._delta += delta;
			this._lastMousePos = this._map.mouseEventToContainerPoint(e);

			if (!this._startTime) {
				this._startTime = +new Date();
			}

			var left = Math.max(debounce - (+new Date() - this._startTime), 0);

			clearTimeout(this._timer);
			this._timer = setTimeout(bind(this._performZoom, this), left);

			stop(e);
		},

		_performZoom: function () {
			var map = this._map,
			    zoom = map.getZoom(),
			    snap = this._map.options.zoomSnap || 0;

			map._stop(); // stop panning and fly animations if any

			// map the delta with a sigmoid function to -4..4 range leaning on -1..1
			var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4),
			    d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2,
			    d4 = snap ? Math.ceil(d3 / snap) * snap : d3,
			    delta = map._limitZoom(zoom + (this._delta > 0 ? d4 : -d4)) - zoom;

			this._delta = 0;
			this._startTime = null;

			if (!delta) { return; }

			if (map.options.scrollWheelZoom === 'center') {
				map.setZoom(zoom + delta);
			} else {
				map.setZoomAround(this._lastMousePos, zoom + delta);
			}
		}
	});

	// @section Handlers
	// @property scrollWheelZoom: Handler
	// Scroll wheel zoom handler.
	Map$1.addInitHook('addHandler', 'scrollWheelZoom', ScrollWheelZoom);

	/*
	 * L.Map.Tap is used to enable mobile hacks like quick taps and long hold.
	 */

	// @namespace Map
	// @section Interaction Options
	Map$1.mergeOptions({
		// @section Touch interaction options
		// @option tap: Boolean = true
		// Enables mobile hacks for supporting instant taps (fixing 200ms click
		// delay on iOS/Android) and touch holds (fired as `contextmenu` events).
		tap: true,

		// @option tapTolerance: Number = 15
		// The max number of pixels a user can shift his finger during touch
		// for it to be considered a valid tap.
		tapTolerance: 15
	});

	var Tap = Handler.extend({
		addHooks: function () {
			on(this._map._container, 'touchstart', this._onDown, this);
		},

		removeHooks: function () {
			off(this._map._container, 'touchstart', this._onDown, this);
		},

		_onDown: function (e) {
			if (!e.touches) { return; }

			preventDefault(e);

			this._fireClick = true;

			// don't simulate click or track longpress if more than 1 touch
			if (e.touches.length > 1) {
				this._fireClick = false;
				clearTimeout(this._holdTimeout);
				return;
			}

			var first = e.touches[0],
			    el = first.target;

			this._startPos = this._newPos = new Point$1(first.clientX, first.clientY);

			// if touching a link, highlight it
			if (el.tagName && el.tagName.toLowerCase() === 'a') {
				addClass(el, 'leaflet-active');
			}

			// simulate long hold but setting a timeout
			this._holdTimeout = setTimeout(bind(function () {
				if (this._isTapValid()) {
					this._fireClick = false;
					this._onUp();
					this._simulateEvent('contextmenu', first);
				}
			}, this), 1000);

			this._simulateEvent('mousedown', first);

			on(document, {
				touchmove: this._onMove,
				touchend: this._onUp
			}, this);
		},

		_onUp: function (e) {
			clearTimeout(this._holdTimeout);

			off(document, {
				touchmove: this._onMove,
				touchend: this._onUp
			}, this);

			if (this._fireClick && e && e.changedTouches) {

				var first = e.changedTouches[0],
				    el = first.target;

				if (el && el.tagName && el.tagName.toLowerCase() === 'a') {
					removeClass(el, 'leaflet-active');
				}

				this._simulateEvent('mouseup', first);

				// simulate click if the touch didn't move too much
				if (this._isTapValid()) {
					this._simulateEvent('click', first);
				}
			}
		},

		_isTapValid: function () {
			return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
		},

		_onMove: function (e) {
			var first = e.touches[0];
			this._newPos = new Point$1(first.clientX, first.clientY);
			this._simulateEvent('mousemove', first);
		},

		_simulateEvent: function (type, e) {
			var simulatedEvent = document.createEvent('MouseEvents');

			simulatedEvent._simulated = true;
			e.target._simulatedClick = true;

			simulatedEvent.initMouseEvent(
			        type, true, true, window, 1,
			        e.screenX, e.screenY,
			        e.clientX, e.clientY,
			        false, false, false, false, 0, null);

			e.target.dispatchEvent(simulatedEvent);
		}
	});

	// @section Handlers
	// @property tap: Handler
	// Mobile touch hacks (quick tap and touch hold) handler.
	if (touch && !pointer) {
		Map$1.addInitHook('addHandler', 'tap', Tap);
	}

	/*
	 * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.
	 */

	// @namespace Map
	// @section Interaction Options
	Map$1.mergeOptions({
		// @section Touch interaction options
		// @option touchZoom: Boolean|String = *
		// Whether the map can be zoomed by touch-dragging with two fingers. If
		// passed `'center'`, it will zoom to the center of the view regardless of
		// where the touch events (fingers) were. Enabled for touch-capable web
		// browsers except for old Androids.
		touchZoom: touch && !android23,

		// @option bounceAtZoomLimits: Boolean = true
		// Set it to false if you don't want the map to zoom beyond min/max zoom
		// and then bounce back when pinch-zooming.
		bounceAtZoomLimits: true
	});

	var TouchZoom = Handler.extend({
		addHooks: function () {
			addClass(this._map._container, 'leaflet-touch-zoom');
			on(this._map._container, 'touchstart', this._onTouchStart, this);
		},

		removeHooks: function () {
			removeClass(this._map._container, 'leaflet-touch-zoom');
			off(this._map._container, 'touchstart', this._onTouchStart, this);
		},

		_onTouchStart: function (e) {
			var map = this._map;
			if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) { return; }

			var p1 = map.mouseEventToContainerPoint(e.touches[0]),
			    p2 = map.mouseEventToContainerPoint(e.touches[1]);

			this._centerPoint = map.getSize()._divideBy(2);
			this._startLatLng = map.containerPointToLatLng(this._centerPoint);
			if (map.options.touchZoom !== 'center') {
				this._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));
			}

			this._startDist = p1.distanceTo(p2);
			this._startZoom = map.getZoom();

			this._moved = false;
			this._zooming = true;

			map._stop();

			on(document, 'touchmove', this._onTouchMove, this);
			on(document, 'touchend', this._onTouchEnd, this);

			preventDefault(e);
		},

		_onTouchMove: function (e) {
			if (!e.touches || e.touches.length !== 2 || !this._zooming) { return; }

			var map = this._map,
			    p1 = map.mouseEventToContainerPoint(e.touches[0]),
			    p2 = map.mouseEventToContainerPoint(e.touches[1]),
			    scale = p1.distanceTo(p2) / this._startDist;

			this._zoom = map.getScaleZoom(scale, this._startZoom);

			if (!map.options.bounceAtZoomLimits && (
				(this._zoom < map.getMinZoom() && scale < 1) ||
				(this._zoom > map.getMaxZoom() && scale > 1))) {
				this._zoom = map._limitZoom(this._zoom);
			}

			if (map.options.touchZoom === 'center') {
				this._center = this._startLatLng;
				if (scale === 1) { return; }
			} else {
				// Get delta from pinch to center, so centerLatLng is delta applied to initial pinchLatLng
				var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);
				if (scale === 1 && delta.x === 0 && delta.y === 0) { return; }
				this._center = map.unproject(map.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);
			}

			if (!this._moved) {
				map._moveStart(true, false);
				this._moved = true;
			}

			cancelAnimFrame(this._animRequest);

			var moveFn = bind(map._move, map, this._center, this._zoom, {pinch: true, round: false});
			this._animRequest = requestAnimFrame(moveFn, this, true);

			preventDefault(e);
		},

		_onTouchEnd: function () {
			if (!this._moved || !this._zooming) {
				this._zooming = false;
				return;
			}

			this._zooming = false;
			cancelAnimFrame(this._animRequest);

			off(document, 'touchmove', this._onTouchMove);
			off(document, 'touchend', this._onTouchEnd);

			// Pinch updates GridLayers' levels only when zoomSnap is off, so zoomSnap becomes noUpdate.
			if (this._map.options.zoomAnimation) {
				this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);
			} else {
				this._map._resetView(this._center, this._map._limitZoom(this._zoom));
			}
		}
	});

	// @section Handlers
	// @property touchZoom: Handler
	// Touch zoom handler.
	Map$1.addInitHook('addHandler', 'touchZoom', TouchZoom);

	Map$1.BoxZoom = BoxZoom;
	Map$1.DoubleClickZoom = DoubleClickZoom;
	Map$1.Drag = Drag;
	Map$1.Keyboard = Keyboard;
	Map$1.ScrollWheelZoom = ScrollWheelZoom;
	Map$1.Tap = Tap;
	Map$1.TouchZoom = TouchZoom;

	Object.freeze = freeze$2;

	/**
	 * @license
	 *
	 * OverviewMapForCesium
	 *
	 * See: https://github.com/leation/OverviewMapForCesium
	 *
	 * @author leation
	 *
	 *   Copyright 2019 leation
	 *
	 *   Licensed under the Apache License, Version 2.0 (the "License");
	 *   you may not use this file except in compliance with the License.
	 *   You may obtain a copy of the License at
	 *
	 *       http://www.apache.org/licenses/LICENSE-2.0
	 *
	 *   Unless required by applicable law or agreed to in writing, software
	 *   distributed under the License is distributed on an "AS IS" BASIS,
	 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *   See the License for the specific language governing permissions and
	 *   limitations under the License.
	 *
	 */

	var CesiumOverviewMapControl = function CesiumOverviewMapControl() {
	  this.init.apply(this, arguments);
	};

	CesiumOverviewMapControl.prototype = {
	  _container: null,
	  _miniMap: null,
	  _viewerMoving: false,
	  _miniMapMoving: false,
	  _userToggledDisplay: false,
	  _minimized: false,
	  vm: null,
	  viewer: null,
	  tileLayer: null,
	  options: {
	    position: 'bottomleft',
	    toggleDisplay: true,
	    zoomLevelOffset: -5,
	    zoomLevelFixed: false,
	    centerFixed: false,
	    zoomControl: false,
	    zoomAnimation: false,
	    autoToggleDisplay: false,
	    minimized: false,
	    width: 150,
	    height: 150,
	    collapsedWidth: 19,
	    collapsedHeight: 19,
	    aimingRectOptions: {
	      color: '#ff7800',
	      weight: 1,
	      interactive: false
	    },
	    shadowRectOptions: {
	      color: '#000000',
	      weight: 1,
	      interactive: false,
	      opacity: 0,
	      fillOpacity: 0
	    },
	    // strings: { hideText: '隐藏鹰眼', showText: '显示鹰眼' },
	    mapOptions: {
	      toggleDisplay: true,
	      aimingRectOptions: {
	        color: '#ff1100',
	        weight: 3
	      },
	      shadowRectOptions: {
	        color: '#0000AA',
	        weight: 1,
	        opacity: 0,
	        fillOpacity: 0
	      }
	    }
	  },
	  init: function init(viewer, layer, options, vm) {
	    this.viewer = viewer;
	    this.tileLayer = layer;
	    this._container = options.container;
	    this.vm = vm;
	    Util.setOptions(this, options);
	    this.options.aimingRectOptions.interactive = false;
	    this.options.shadowRectOptions.interactive = false;

	    this._initMap();

	    this._showInitView();
	  },
	  updateAimingRect: function updateAimingRect() {
	    var _this = this;

	    var rect = _this._getViewRange();

	    _this._aimingRect.setBounds(rect);
	  },
	  _initMap: function _initMap() {
	    var _this = this;

	    this._container.style.width = this.options.width + 'px';
	    this._container.style.height = this.options.height + 'px';
	    DomEvent.disableClickPropagation(_this._container);
	    DomEvent.on(_this._container, 'mousewheel', DomEvent.stopPropagation);
	    var mapOptions = {
	      attributionControl: false,
	      dragging: !_this.options.centerFixed,
	      zoomControl: _this.options.zoomControl,
	      zoomAnimation: _this.options.zoomAnimation,
	      autoToggleDisplay: _this.options.autoToggleDisplay,
	      touchZoom: _this.options.centerFixed ? 'center' : !_this._isZoomLevelFixed(),
	      scrollWheelZoom: _this.options.centerFixed ? 'center' : !_this._isZoomLevelFixed(),
	      doubleClickZoom: _this.options.centerFixed ? 'center' : !_this._isZoomLevelFixed(),
	      boxZoom: !_this._isZoomLevelFixed(),
	      crs: CRS.EPSG3857,
	      center: [30, 120],
	      zoom: 1
	    };
	    mapOptions = Util.extend(_this.options.mapOptions, mapOptions); // merge
	    // with
	    // priority
	    // of
	    // the
	    // local
	    // mapOptions
	    // object.

	    _this._miniMap = new Map$1(_this._container, mapOptions);
	    var layer = this.tileLayer;

	    _this._miniMap.addLayer(layer); // These bools are used to prevent infinite loops of the two maps
	    // notifying each other that they've moved.


	    _this._viewerMoving = true;
	    _this._miniMapMoving = false; // Keep a record of _this to prevent auto toggling when the user
	    // explicitly doesn't want it.

	    _this._userToggledDisplay = false;
	    _this._minimized = false;

	    if (this.options.toggleDisplay) {
	      this._addToggleButton();
	    }

	    _this._miniMap.whenReady(Util.bind(function () {
	      var bounds = _this._getViewRange();

	      _this._aimingRect = rectangle$1(bounds, _this.options.aimingRectOptions).addTo(_this._miniMap);
	      _this._shadowRect = rectangle$1(bounds, _this.options.shadowRectOptions).addTo(_this._miniMap);
	      var camera = _this.viewer.scene.camera;
	      camera.moveEnd.addEventListener(function (e) {
	        var rect = _this._getViewRange();

	        if (!_this._miniMapMoving) {
	          _this._viewerMoving = true;

	          var zrect = _this._getZoomOutRange(rect);

	          _this._miniMap.fitBounds(zrect);

	          _this._setDisplay(_this._decideMinimized());
	        } else {
	          _this._miniMapMoving = false;
	        }

	        _this._aimingRect.setBounds(rect);
	      });
	      camera.moveStart.addEventListener(function (e) {
	        var rect = _this._getViewRange();

	        _this._aimingRect.setBounds(rect);
	      });

	      _this._miniMap.on('movestart', _this._onMiniMapMoveStarted, _this);

	      _this._miniMap.on('move', _this._onMiniMapMoving, _this);

	      _this._miniMap.on('moveend', _this._onMiniMapMoved, _this);
	    }, _this));

	    return _this._container;
	  },
	  _addToggleButton: function _addToggleButton() {
	    this._toggleDisplayButton = this.options.toggleDisplay ? this._createButton('', this._toggleButtonInitialTitleText(), 'vc-leaflet-control-minimap-toggle-display vc-leaflet-control-minimap-toggle-display-' + this.options.position, this._container, this._toggleDisplayButtonClicked, this) : undefined; // this._toggleDisplayButton.style.zIndex = 99999;

	    this._toggleDisplayButton.style.width = this.options.collapsedWidth + 'px';
	    this._toggleDisplayButton.style.height = this.options.collapsedHeight + 'px';
	  },
	  _toggleButtonInitialTitleText: function _toggleButtonInitialTitleText() {
	    if (!this.options.minimized) {
	      return this.vm.$vc.lang.overviewmap.hidden;
	    }
	  },
	  _createButton: function _createButton(html, title, className, container, fn, context) {
	    var link = DomUtil.create('a', className, container);
	    link.innerHTML = html;
	    link.href = '#';
	    link.title = title;
	    var stop = DomEvent.stopPropagation;
	    DomEvent.on(link, 'click', stop).on(link, 'mousedown', stop).on(link, 'dblclick', stop).on(link, 'click', DomEvent.preventDefault).on(link, 'click', fn, context);
	    return link;
	  },
	  _toggleDisplayButtonClicked: function _toggleDisplayButtonClicked() {
	    this._userToggledDisplay = true;

	    if (!this._minimized) {
	      this._minimize();
	    } else {
	      this._restore();
	    }
	  },
	  _showInitView: function _showInitView() {
	    var rect = this._getViewRange();

	    var zrect = this._getZoomOutRange(rect);

	    this._miniMap.fitBounds(zrect);
	  },
	  _setDisplay: function _setDisplay(minimize) {
	    if (minimize !== this._minimized) {
	      if (!this._minimized) {
	        this._minimize();
	      } else {
	        this._restore();
	      }
	    }
	  },
	  _minimize: function _minimize() {
	    // hide the minimap
	    if (this.options.toggleDisplay) {
	      this._container.style.width = this.options.collapsedWidth + 'px';
	      this._container.style.height = this.options.collapsedHeight + 'px';
	      this._toggleDisplayButton.className += ' minimized-' + this.options.position;
	      this._toggleDisplayButton.title = this.vm.$vc.lang.overviewmap.show;
	    } else {
	      this._container.style.display = 'none';
	    }

	    this._minimized = true;

	    this._onToggle();
	  },
	  _restore: function _restore() {
	    if (this.options.toggleDisplay) {
	      this._container.style.width = this.options.width + 'px';
	      this._container.style.height = this.options.height + 'px';
	      this._toggleDisplayButton.className = this._toggleDisplayButton.className.replace('minimized-' + this.options.position, '');
	      this._toggleDisplayButton.title = this.vm.$vc.lang.overviewmap.hidden;
	    } else {
	      this._container.style.display = 'block';
	    }

	    this._minimized = false;

	    this._onToggle();
	  },
	  _onMiniMapMoveStarted: function _onMiniMapMoveStarted(e) {
	    if (!this.options.centerFixed) {
	      var lastAimingRect = this._aimingRect.getBounds();

	      var sw = this._miniMap.latLngToContainerPoint(lastAimingRect.getSouthWest());

	      var ne = this._miniMap.latLngToContainerPoint(lastAimingRect.getNorthEast());

	      this._lastAimingRectPosition = {
	        sw: sw,
	        ne: ne
	      };
	    }
	  },
	  _onMiniMapMoving: function _onMiniMapMoving(e) {
	    if (!this.options.centerFixed) {
	      if (!this._viewerMoving && this._lastAimingRectPosition) {
	        this._shadowRect.setBounds(new LatLngBounds(this._miniMap.containerPointToLatLng(this._lastAimingRectPosition.sw), this._miniMap.containerPointToLatLng(this._lastAimingRectPosition.ne)));

	        this._shadowRect.setStyle({
	          opacity: 1,
	          fillOpacity: 0.3
	        });
	      }
	    }
	  },
	  _onMiniMapMoved: function _onMiniMapMoved(e) {
	    if (!this._viewerMoving) {
	      this._miniMapMoving = true;

	      var rect = this._shadowRect.getBounds();

	      var west = rect.getWest();
	      var east = rect.getEast();
	      var north = rect.getNorth();
	      var south = rect.getSouth();
	      var destination = Cesium.Rectangle.fromDegrees(west, south, east, north);
	      var orientation = {
	        heading: Cesium.Math.toRadians(0),
	        pitch: Cesium.Math.toRadians(-90),
	        roll: 0.0
	      };
	      this.viewer.scene.camera.setView({
	        destination: destination,
	        orientation: orientation
	      });

	      this._shadowRect.setStyle({
	        opacity: 0,
	        fillOpacity: 0
	      });
	    } else {
	      this._viewerMoving = false;
	    }
	  },
	  _isZoomLevelFixed: function _isZoomLevelFixed() {
	    var zoomLevelFixed = this.options.zoomLevelFixed;
	    return this._isDefined(zoomLevelFixed) && this._isInteger(zoomLevelFixed);
	  },
	  _decideMinimized: function _decideMinimized() {
	    if (this._userToggledDisplay) {
	      return this._minimized;
	    }

	    if (this.options.autoToggleDisplay) {
	      var bounds = this._getViewRange();

	      if (bounds.contains(this._miniMap.getBounds())) {
	        return true;
	      }

	      return false;
	    }

	    return this._minimized;
	  },
	  _isInteger: function _isInteger(value) {
	    return typeof value === 'number';
	  },
	  _isDefined: function _isDefined(value) {
	    return typeof value !== 'undefined';
	  },
	  _onToggle: function _onToggle() {
	    Util.requestAnimFrame(function () {
	      DomEvent.on(this._container, 'transitionend', this._fireToggleEvents, this);

	      if (!Browser.any3d) {
	        Util.requestAnimFrame(this._fireToggleEvents, this);
	      }
	    }, this);
	  },
	  _fireToggleEvents: function _fireToggleEvents() {
	    DomEvent.off(this._container, 'transitionend', this._fireToggleEvents, this);
	  },
	  _getViewRange: function _getViewRange() {
	    var viewer = this.viewer;
	    var camera = viewer.scene.camera;
	    var range = camera.computeViewRectangle();
	    var west = range.west / Math.PI * 180;
	    var east = range.east / Math.PI * 180;
	    var north = range.north / Math.PI * 180;
	    var south = range.south / Math.PI * 180;
	    var bounds = new LatLngBounds(new LatLng(north, west), new LatLng(south, east));
	    return bounds;
	  },
	  _getZoomOutRange: function _getZoomOutRange(rect) {
	    var west = rect.getWest();
	    var east = rect.getEast();
	    var north = rect.getNorth();
	    var south = rect.getSouth();
	    var factor = 3.0;
	    var xdis = Math.abs(east - west);
	    var ydis = Math.abs(north - south);
	    var xoff = xdis * (factor - 1) / 2.0;
	    var yoff = ydis * (factor - 1) / 2.0;
	    west -= xoff;
	    east += xoff;
	    north += yoff;
	    south -= yoff;

	    if (west < -180) {
	      west = -180;
	    }

	    if (east > 180) {
	      east = 180;
	    }

	    if (north > 90) {
	      north = 90;
	    }

	    if (south < -90) {
	      south = -90;
	    }

	    var bounds = new LatLngBounds(new LatLng(north, west), new LatLng(south, east));
	    return bounds;
	  },
	  CLASS_NAME: 'CesiumOverviewMapControl'
	};

	var script$1N = {
	  name: 'vc-map-overview',
	  mixins: [cmp],
	  props: {
	    url: {
	      type: String,
	      default: 'https://webst01.is.autonavi.com/appmaptile?style=7&x={x}&y={y}&z={z}'
	    },
	    height: {
	      type: Number,
	      default: 150
	    },
	    width: {
	      type: Number,
	      default: 150
	    },
	    anchor: {
	      type: String,
	      default: 'bottomright'
	    },
	    aimingRectOptions: {
	      type: Object,
	      default: function _default() {
	        return {
	          color: '#ff1100',
	          weight: 3
	        };
	      }
	    },
	    shadowRectOptions: {
	      type: Object,
	      default: function _default() {
	        return {
	          color: '#0000AA',
	          weight: 1,
	          opacity: 0,
	          fillOpacity: 0
	        };
	      }
	    },
	    toggleDisplay: {
	      type: Boolean,
	      default: true
	    }
	  },
	  data: function data() {
	    return {
	      nowaiting: true,
	      bottom: 10,
	      right: 10,
	      top: 50,
	      left: 10
	    };
	  },
	  computed: {
	    ovStyle: function ovStyle() {
	      var anchor = this.anchor,
	          height = this.height,
	          width = this.width,
	          top = this.top,
	          left = this.left,
	          right = this.right,
	          bottom = this.bottom;
	      var style = {
	        height: height + 'px',
	        width: width + 'px'
	      };

	      if (anchor === 'topleft') {
	        style.top = top + 'px';
	        style.left = left + 'px';
	      }

	      if (anchor === 'topright') {
	        style.top = top + 'px';
	        style.right = right + 'px';
	      }

	      if (anchor === 'bottomright') {
	        style.bottom = bottom + 'px';
	        style.right = right + 'px';
	      }

	      if (anchor === 'bottomleft') {
	        style.bottom = bottom + 'px';
	        style.left = left + 'px';
	      }

	      return style;
	    }
	  },
	  methods: {
	    createCesiumObject: function createCesiumObject() {
	      var viewer, width, height, anchor, aimingRectOptions, shadowRectOptions, toggleDisplay, url, layer, container, options;
	      return regenerator.async(function createCesiumObject$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              viewer = this.viewer, width = this.width, height = this.height, anchor = this.anchor, aimingRectOptions = this.aimingRectOptions, shadowRectOptions = this.shadowRectOptions, toggleDisplay = this.toggleDisplay;
	              url = 'https://webst01.is.autonavi.com/appmaptile?style=7&x={x}&y={y}&z={z}';
	              layer = new TileLayer(url, {
	                minZoom: 0,
	                maxZoom: 20
	              });
	              container = this.$refs.leafletContainer;
	              options = {
	                container: container,
	                toggleDisplay: toggleDisplay,
	                width: width,
	                height: height,
	                position: anchor,
	                aimingRectOptions: aimingRectOptions,
	                shadowRectOptions: shadowRectOptions
	              };
	              viewer.widgetResized.addEventListener(this.widgetResized);
	              this.widgetResized();
	              return _context.abrupt("return", new CesiumOverviewMapControl(viewer, layer, options, this));

	            case 8:
	            case "end":
	              return _context.stop();
	          }
	        }
	      }, null, this);
	    },
	    widgetResized: function widgetResized() {
	      var _this = this;

	      var bottom = 10;
	      var right = 10;
	      var viewer = this.viewer,
	          anchor = this.anchor;
	      this.$nextTick(function () {
	        if (anchor === 'bottomright') {
	          if (viewer.timeline) {
	            bottom += viewer.timeline.container.getBoundingClientRect().height;
	          }

	          var vcDistance = document.querySelector('.vc-location-distance');

	          if (vcDistance) {
	            bottom += vcDistance.getBoundingClientRect().height;
	          }
	        } else if (anchor === 'bottomleft') {
	          if (viewer.animation) {
	            bottom += viewer.animation.container.getBoundingClientRect().height;
	          } else {
	            if (viewer.bottomContainer) {
	              bottom += viewer.bottomContainer.getBoundingClientRect().height;
	            }

	            if (viewer.timeline) {
	              bottom += viewer.timeline.container.getBoundingClientRect().height;
	            }
	          }
	        }

	        if (anchor === 'topright') {
	          var navigationNavs = document.querySelector('.vc-navigation-navs');

	          if (navigationNavs) {
	            right += navigationNavs.getBoundingClientRect().width + 16;
	          }
	        }

	        if (bottom === 10) {
	          var _right = 10;
	          viewer.fullscreenButton && (_right += viewer.fullscreenButton.container.getBoundingClientRect().width);
	          viewer.vrButton && (_right += viewer.vrButton.container.getBoundingClientRect().width);
	        }

	        _this.bottom = bottom;
	        _this.right = right;
	      });
	    },
	    mount: function mount() {
	      return regenerator.async(function mount$(_context2) {
	        while (1) {
	          switch (_context2.prev = _context2.next) {
	            case 0:
	              return _context2.abrupt("return", true);

	            case 1:
	            case "end":
	              return _context2.stop();
	          }
	        }
	      });
	    },
	    unmount: function unmount() {
	      return regenerator.async(function unmount$(_context3) {
	        while (1) {
	          switch (_context3.prev = _context3.next) {
	            case 0:
	              this.viewer.widgetResized.removeEventListener(this.widgetResized);
	              return _context3.abrupt("return", true);

	            case 2:
	            case "end":
	              return _context3.stop();
	          }
	        }
	      }, null, this);
	    }
	  },
	  created: function created() {
	    var _this2 = this;

	    defineProperties$1(this, {
	      element: {
	        enumerable: true,
	        get: function get() {
	          return _this2.cesiumObject;
	        }
	      }
	    });
	  }
	};

	/* script */
	var __vue_script__$1N = script$1N;
	/* template */

	var __vue_render__$k = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('div', {
	    ref: "leafletContainer",
	    staticClass: "vc-leaflet-control-minimap",
	    style: _vm.ovStyle,
	    attrs: {
	      "id": "vc-overview-map"
	    }
	  });
	};

	var __vue_staticRenderFns__$k = [];
	/* style */

	var __vue_inject_styles__$1N = undefined;
	/* scoped */

	var __vue_scope_id__$1N = undefined;
	/* functional template */

	var __vue_is_functional_template__$1N = false;
	/* component normalizer */

	function __vue_normalize__$1N(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "VcOverviewMap.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var VcOverviewMap = __vue_normalize__$1N({
	  render: __vue_render__$k,
	  staticRenderFns: __vue_staticRenderFns__$k
	}, __vue_inject_styles__$1N, __vue_script__$1N, __vue_scope_id__$1N, __vue_is_functional_template__$1N);

	function plugin$1D(Vue) {

	  if (plugin$1D.installed) {
	    return;
	  }

	  plugin$1D.installed = true;
	  Vue.component(VcOverviewMap.name, VcOverviewMap);
	}

	var index$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$1D,
		VcOverviewMap: VcOverviewMap,
		install: plugin$1D
	});

	var script$1O = {
	  name: 'vc-analytics-flood',
	  data: function data() {
	    return {
	      geometry: null,
	      attributes: null,
	      extrudedHeight: 0.1,
	      flooding: false,
	      appearance: null,
	      nowaiting: true
	    };
	  },
	  mixins: [cmp],
	  props: {
	    minHeight: {
	      type: Number,
	      default: 0
	    },
	    maxHeight: Number,
	    polygonHierarchy: Array,
	    speed: {
	      type: Number,
	      default: 10
	    },
	    color: {
	      type: [Object, Array, String],
	      default: 'rgba(40,150,200,0.6)'
	    }
	  },
	  watch: {
	    flooding: function flooding(val) {
	      var listener = this.$listeners.activeEvt;

	      if (val) {
	        if (this.floodDone) {
	          this.extrudedHeight = this.extrudedHeight >= this.minHeight ? this.minHeight : 0.1;
	          this.floodDone = false;
	        }

	        this._mounted = true;
	        this.viewer.clock.onTick.addEventListener(this.onTick);
	        listener && this.$emit('activeEvt', {
	          isActive: val
	        });
	      } else {
	        this.viewer.clock.onTick.removeEventListener(this.onTick);
	        listener && this.$emit('activeEvt', {
	          isActive: val
	        });
	      }
	    },
	    minHeight: function minHeight(val) {
	      this.extrudedHeight = val;
	    }
	  },
	  methods: {
	    createCesiumObject: function createCesiumObject() {
	      var _this = this;

	      var Cesium, minHeight, color;
	      return regenerator.async(function createCesiumObject$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              Cesium = this.Cesium, minHeight = this.minHeight, color = this.color;
	              this.attributes = {
	                color: Cesium.ColorGeometryInstanceAttribute.fromColor(makeColor(color))
	              };
	              this.extrudedHeight = minHeight;
	              return _context.abrupt("return", this.$refs.primitive.createPromise.then(function (_ref) {
	                var Cesium = _ref.Cesium,
	                    viewer = _ref.viewer,
	                    cesiumObject = _ref.cesiumObject;

	                if (!_this.$refs.primitive._mounted) {
	                  return _this.$refs.primitive.load().then(function (_ref2) {
	                    var Cesium = _ref2.Cesium,
	                        viewer = _ref2.viewer,
	                        cesiumObject = _ref2.cesiumObject;
	                    return cesiumObject;
	                  });
	                } else {
	                  return cesiumObject;
	                }
	              }));

	            case 4:
	            case "end":
	              return _context.stop();
	          }
	        }
	      }, null, this);
	    },
	    onTick: function onTick() {
	      var maxHeight = this.maxHeight,
	          speed = this.speed;

	      if (this.extrudedHeight < maxHeight) {
	        this.extrudedHeight = this.extrudedHeight + speed;
	      } else {
	        this.floodDone = true;
	        this.flooding = false;
	      }
	    },
	    clear: function clear() {},
	    mount: function mount() {
	      return regenerator.async(function mount$(_context2) {
	        while (1) {
	          switch (_context2.prev = _context2.next) {
	            case 0:
	              return _context2.abrupt("return", true);

	            case 1:
	            case "end":
	              return _context2.stop();
	          }
	        }
	      });
	    },
	    unmount: function unmount() {
	      return regenerator.async(function unmount$(_context3) {
	        while (1) {
	          switch (_context3.prev = _context3.next) {
	            case 0:
	              this.extrudedHeight = this.minHeight;
	              this.flooding = false;
	              this.$refs.primitive && this.$refs.primitive.unload();

	            case 3:
	            case "end":
	              return _context3.stop();
	          }
	        }
	      }, null, this);
	    }
	  },
	  created: function created() {
	    var _this2 = this;

	    defineProperties$1(this, {
	      floodObject: {
	        enumerable: true,
	        get: function get() {
	          return _this2.$services && _this2.cesiumObject;
	        }
	      }
	    });
	  }
	};

	/* script */
	var __vue_script__$1O = script$1O;
	/* template */

	var __vue_render__$l = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('i', {
	    class: _vm.$options.name,
	    staticStyle: {
	      "display": "none !important"
	    }
	  }, [_c('vc-primitive-classification', {
	    ref: "primitive",
	    attrs: {
	      "appearance": _vm.appearance,
	      "asynchronous": false,
	      "show": _vm.extrudedHeight !== 0 && _vm.extrudedHeight !== ''
	    }
	  }, [_c('vc-instance-geometry', {
	    attrs: {
	      "attributes": _vm.attributes,
	      "geometry": _vm.geometry
	    },
	    on: {
	      "update:geometry": function updateGeometry($event) {
	        _vm.geometry = $event;
	      }
	    }
	  }, [_c('vc-geometry-polygon', {
	    attrs: {
	      "extrudedHeight": _vm.extrudedHeight,
	      "polygonHierarchy": _vm.polygonHierarchy
	    }
	  })], 1)], 1)], 1);
	};

	var __vue_staticRenderFns__$l = [];
	/* style */

	var __vue_inject_styles__$1O = undefined;
	/* scoped */

	var __vue_scope_id__$1O = undefined;
	/* functional template */

	var __vue_is_functional_template__$1O = false;
	/* component normalizer */

	function __vue_normalize__$1O(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "VcFlood.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var VcFlood = __vue_normalize__$1O({
	  render: __vue_render__$l,
	  staticRenderFns: __vue_staticRenderFns__$l
	}, __vue_inject_styles__$1O, __vue_script__$1O, __vue_scope_id__$1O, __vue_is_functional_template__$1O);

	function plugin$1E(Vue) {

	  if (plugin$1E.installed) {
	    return;
	  }

	  plugin$1E.installed = true;
	  Vue.use(ClassificationPrimitive$1);
	  Vue.use(GeometryInstance$1);
	  Vue.use(PolygonGeometry$1);
	  Vue.component(VcFlood.name, VcFlood);
	}

	var VcFlood$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$1E,
		VcFlood: VcFlood,
		install: plugin$1E
	});

	var $JSON$1 = _core.JSON || (_core.JSON = { stringify: JSON.stringify });
	var stringify = function stringify(it) { // eslint-disable-line no-unused-vars
	  return $JSON$1.stringify.apply($JSON$1, arguments);
	};

	var stringify$1 = stringify;

	var heatmap = createCommonjsModule(function (module) {
	(function (name, context, factory) {

	  // Supports UMD. AMD, CommonJS/Node.js and browser context
	  if ( module.exports) {
	    module.exports = factory();
	  } else {
	    context[name] = factory();
	  }

	})("h337", commonjsGlobal, function () {

	// Heatmap Config stores default values and will be merged with instance config
	var HeatmapConfig = {
	  defaultRadius: 40,
	  defaultRenderer: 'canvas2d',
	  defaultGradient: { 0.25: "rgb(0,0,255)", 0.55: "rgb(0,255,0)", 0.85: "yellow", 1.0: "rgb(255,0,0)"},
	  defaultMaxOpacity: 1,
	  defaultMinOpacity: 0,
	  defaultBlur: .85,
	  defaultXField: 'x',
	  defaultYField: 'y',
	  defaultValueField: 'value', 
	  plugins: {}
	};
	var Store = (function StoreClosure() {

	  var Store = function Store(config) {
	    this._coordinator = {};
	    this._data = [];
	    this._radi = [];
	    this._min = 10;
	    this._max = 1;
	    this._xField = config['xField'] || config.defaultXField;
	    this._yField = config['yField'] || config.defaultYField;
	    this._valueField = config['valueField'] || config.defaultValueField;

	    if (config["radius"]) {
	      this._cfgRadius = config["radius"];
	    }
	  };

	  var defaultRadius = HeatmapConfig.defaultRadius;

	  Store.prototype = {
	    // when forceRender = false -> called from setData, omits renderall event
	    _organiseData: function(dataPoint, forceRender) {
	        var x = dataPoint[this._xField];
	        var y = dataPoint[this._yField];
	        var radi = this._radi;
	        var store = this._data;
	        var max = this._max;
	        var min = this._min;
	        var value = dataPoint[this._valueField] || 1;
	        var radius = dataPoint.radius || this._cfgRadius || defaultRadius;

	        if (!store[x]) {
	          store[x] = [];
	          radi[x] = [];
	        }

	        if (!store[x][y]) {
	          store[x][y] = value;
	          radi[x][y] = radius;
	        } else {
	          store[x][y] += value;
	        }
	        var storedVal = store[x][y];

	        if (storedVal > max) {
	          if (!forceRender) {
	            this._max = storedVal;
	          } else {
	            this.setDataMax(storedVal);
	          }
	          return false;
	        } else if (storedVal < min) {
	          if (!forceRender) {
	            this._min = storedVal;
	          } else {
	            this.setDataMin(storedVal);
	          }
	          return false;
	        } else {
	          return { 
	            x: x, 
	            y: y,
	            value: value, 
	            radius: radius,
	            min: min,
	            max: max 
	          };
	        }
	    },
	    _unOrganizeData: function() {
	      var unorganizedData = [];
	      var data = this._data;
	      var radi = this._radi;

	      for (var x in data) {
	        for (var y in data[x]) {

	          unorganizedData.push({
	            x: x,
	            y: y,
	            radius: radi[x][y],
	            value: data[x][y]
	          });

	        }
	      }
	      return {
	        min: this._min,
	        max: this._max,
	        data: unorganizedData
	      };
	    },
	    _onExtremaChange: function() {
	      this._coordinator.emit('extremachange', {
	        min: this._min,
	        max: this._max
	      });
	    },
	    addData: function() {
	      if (arguments[0].length > 0) {
	        var dataArr = arguments[0];
	        var dataLen = dataArr.length;
	        while (dataLen--) {
	          this.addData.call(this, dataArr[dataLen]);
	        }
	      } else {
	        // add to store  
	        var organisedEntry = this._organiseData(arguments[0], true);
	        if (organisedEntry) {
	          // if it's the first datapoint initialize the extremas with it
	          if (this._data.length === 0) {
	            this._min = this._max = organisedEntry.value;
	          }
	          this._coordinator.emit('renderpartial', {
	            min: this._min,
	            max: this._max,
	            data: [organisedEntry]
	          });
	        }
	      }
	      return this;
	    },
	    setData: function(data) {
	      var dataPoints = data.data;
	      var pointsLen = dataPoints.length;


	      // reset data arrays
	      this._data = [];
	      this._radi = [];

	      for(var i = 0; i < pointsLen; i++) {
	        this._organiseData(dataPoints[i], false);
	      }
	      this._max = data.max;
	      this._min = data.min || 0;
	      
	      this._onExtremaChange();
	      this._coordinator.emit('renderall', this._getInternalData());
	      return this;
	    },
	    removeData: function() {
	      // TODO: implement
	    },
	    setDataMax: function(max) {
	      this._max = max;
	      this._onExtremaChange();
	      this._coordinator.emit('renderall', this._getInternalData());
	      return this;
	    },
	    setDataMin: function(min) {
	      this._min = min;
	      this._onExtremaChange();
	      this._coordinator.emit('renderall', this._getInternalData());
	      return this;
	    },
	    setCoordinator: function(coordinator) {
	      this._coordinator = coordinator;
	    },
	    _getInternalData: function() {
	      return { 
	        max: this._max,
	        min: this._min, 
	        data: this._data,
	        radi: this._radi 
	      };
	    },
	    getData: function() {
	      return this._unOrganizeData();
	    }/*,

	      TODO: rethink.

	    getValueAt: function(point) {
	      var value;
	      var radius = 100;
	      var x = point.x;
	      var y = point.y;
	      var data = this._data;

	      if (data[x] && data[x][y]) {
	        return data[x][y];
	      } else {
	        var values = [];
	        // radial search for datapoints based on default radius
	        for(var distance = 1; distance < radius; distance++) {
	          var neighbors = distance * 2 +1;
	          var startX = x - distance;
	          var startY = y - distance;

	          for(var i = 0; i < neighbors; i++) {
	            for (var o = 0; o < neighbors; o++) {
	              if ((i == 0 || i == neighbors-1) || (o == 0 || o == neighbors-1)) {
	                if (data[startY+i] && data[startY+i][startX+o]) {
	                  values.push(data[startY+i][startX+o]);
	                }
	              } else {
	                continue;
	              } 
	            }
	          }
	        }
	        if (values.length > 0) {
	          return Math.max.apply(Math, values);
	        }
	      }
	      return false;
	    }*/
	  };


	  return Store;
	})();

	var Canvas2dRenderer = (function Canvas2dRendererClosure() {

	  var _getColorPalette = function(config) {
	    var gradientConfig = config.gradient || config.defaultGradient;
	    var paletteCanvas = document.createElement('canvas');
	    var paletteCtx = paletteCanvas.getContext('2d');

	    paletteCanvas.width = 256;
	    paletteCanvas.height = 1;

	    var gradient = paletteCtx.createLinearGradient(0, 0, 256, 1);
	    for (var key in gradientConfig) {
	      gradient.addColorStop(key, gradientConfig[key]);
	    }

	    paletteCtx.fillStyle = gradient;
	    paletteCtx.fillRect(0, 0, 256, 1);

	    return paletteCtx.getImageData(0, 0, 256, 1).data;
	  };

	  var _getPointTemplate = function(radius, blurFactor) {
	    var tplCanvas = document.createElement('canvas');
	    var tplCtx = tplCanvas.getContext('2d');
	    var x = radius;
	    var y = radius;
	    tplCanvas.width = tplCanvas.height = radius*2;

	    if (blurFactor == 1) {
	      tplCtx.beginPath();
	      tplCtx.arc(x, y, radius, 0, 2 * Math.PI, false);
	      tplCtx.fillStyle = 'rgba(0,0,0,1)';
	      tplCtx.fill();
	    } else {
	      var gradient = tplCtx.createRadialGradient(x, y, radius*blurFactor, x, y, radius);
	      gradient.addColorStop(0, 'rgba(0,0,0,1)');
	      gradient.addColorStop(1, 'rgba(0,0,0,0)');
	      tplCtx.fillStyle = gradient;
	      tplCtx.fillRect(0, 0, 2*radius, 2*radius);
	    }



	    return tplCanvas;
	  };

	  var _prepareData = function(data) {
	    var renderData = [];
	    var min = data.min;
	    var max = data.max;
	    var radi = data.radi;
	    var data = data.data;

	    var xValues = Object.keys(data);
	    var xValuesLen = xValues.length;

	    while(xValuesLen--) {
	      var xValue = xValues[xValuesLen];
	      var yValues = Object.keys(data[xValue]);
	      var yValuesLen = yValues.length;
	      while(yValuesLen--) {
	        var yValue = yValues[yValuesLen];
	        var value = data[xValue][yValue];
	        var radius = radi[xValue][yValue];
	        renderData.push({
	          x: xValue,
	          y: yValue,
	          value: value,
	          radius: radius
	        });
	      }
	    }

	    return {
	      min: min,
	      max: max,
	      data: renderData
	    };
	  };


	  function Canvas2dRenderer(config) {
	    var container = config.container;
	    var shadowCanvas = this.shadowCanvas = document.createElement('canvas');
	    var canvas = this.canvas = config.canvas || document.createElement('canvas');
	    var renderBoundaries = this._renderBoundaries = [10000, 10000, 0, 0];

	    var computed = getComputedStyle(config.container) || {};

	    canvas.className = 'heatmap-canvas';

	    this._width = canvas.width = shadowCanvas.width = config.width || +(computed.width.replace(/px/,''));
	    this._height = canvas.height = shadowCanvas.height = config.height || +(computed.height.replace(/px/,''));

	    this.shadowCtx = shadowCanvas.getContext('2d');
	    this.ctx = canvas.getContext('2d');

	    // @TODO:
	    // conditional wrapper

	    canvas.style.cssText = shadowCanvas.style.cssText = 'position:absolute;left:0;top:0;';

	    container.style.position = 'relative';
	    container.appendChild(canvas);

	    this._palette = _getColorPalette(config);
	    this._templates = {};

	    this._setStyles(config);
	  }
	  Canvas2dRenderer.prototype = {
	    renderPartial: function(data) {
	      if (data.data.length > 0) {
	        this._drawAlpha(data);
	        this._colorize();
	      }
	    },
	    renderAll: function(data) {
	      // reset render boundaries
	      this._clear();
	      if (data.data.length > 0) {
	        this._drawAlpha(_prepareData(data));
	        this._colorize();
	      }
	    },
	    _updateGradient: function(config) {
	      this._palette = _getColorPalette(config);
	    },
	    updateConfig: function(config) {
	      if (config['gradient']) {
	        this._updateGradient(config);
	      }
	      this._setStyles(config);
	    },
	    setDimensions: function(width, height) {
	      this._width = width;
	      this._height = height;
	      this.canvas.width = this.shadowCanvas.width = width;
	      this.canvas.height = this.shadowCanvas.height = height;
	    },
	    _clear: function() {
	      this.shadowCtx.clearRect(0, 0, this._width, this._height);
	      this.ctx.clearRect(0, 0, this._width, this._height);
	    },
	    _setStyles: function(config) {
	      this._blur = (config.blur == 0)?0:(config.blur || config.defaultBlur);

	      if (config.backgroundColor) {
	        this.canvas.style.backgroundColor = config.backgroundColor;
	      }

	      this._width = this.canvas.width = this.shadowCanvas.width = config.width || this._width;
	      this._height = this.canvas.height = this.shadowCanvas.height = config.height || this._height;


	      this._opacity = (config.opacity || 0) * 255;
	      this._maxOpacity = (config.maxOpacity || config.defaultMaxOpacity) * 255;
	      this._minOpacity = (config.minOpacity || config.defaultMinOpacity) * 255;
	      this._useGradientOpacity = !!config.useGradientOpacity;
	    },
	    _drawAlpha: function(data) {
	      var min = this._min = data.min;
	      var max = this._max = data.max;
	      var data = data.data || [];
	      var dataLen = data.length;
	      // on a point basis?
	      var blur = 1 - this._blur;

	      while(dataLen--) {

	        var point = data[dataLen];

	        var x = point.x;
	        var y = point.y;
	        var radius = point.radius;
	        // if value is bigger than max
	        // use max as value
	        var value = Math.min(point.value, max);
	        var rectX = x - radius;
	        var rectY = y - radius;
	        var shadowCtx = this.shadowCtx;




	        var tpl;
	        if (!this._templates[radius]) {
	          this._templates[radius] = tpl = _getPointTemplate(radius, blur);
	        } else {
	          tpl = this._templates[radius];
	        }
	        // value from minimum / value range
	        // => [0, 1]
	        var templateAlpha = (value-min)/(max-min);
	        // this fixes #176: small values are not visible because globalAlpha < .01 cannot be read from imageData
	        shadowCtx.globalAlpha = templateAlpha < .01 ? .01 : templateAlpha;

	        shadowCtx.drawImage(tpl, rectX, rectY);

	        // update renderBoundaries
	        if (rectX < this._renderBoundaries[0]) {
	            this._renderBoundaries[0] = rectX;
	          }
	          if (rectY < this._renderBoundaries[1]) {
	            this._renderBoundaries[1] = rectY;
	          }
	          if (rectX + 2*radius > this._renderBoundaries[2]) {
	            this._renderBoundaries[2] = rectX + 2*radius;
	          }
	          if (rectY + 2*radius > this._renderBoundaries[3]) {
	            this._renderBoundaries[3] = rectY + 2*radius;
	          }

	      }
	    },
	    _colorize: function() {
	      var x = this._renderBoundaries[0];
	      var y = this._renderBoundaries[1];
	      var width = this._renderBoundaries[2] - x;
	      var height = this._renderBoundaries[3] - y;
	      var maxWidth = this._width;
	      var maxHeight = this._height;
	      var opacity = this._opacity;
	      var maxOpacity = this._maxOpacity;
	      var minOpacity = this._minOpacity;
	      var useGradientOpacity = this._useGradientOpacity;

	      if (x < 0) {
	        x = 0;
	      }
	      if (y < 0) {
	        y = 0;
	      }
	      if (x + width > maxWidth) {
	        width = maxWidth - x;
	      }
	      if (y + height > maxHeight) {
	        height = maxHeight - y;
	      }

	      var img = this.shadowCtx.getImageData(x, y, width, height);
	      var imgData = img.data;
	      var len = imgData.length;
	      var palette = this._palette;


	      for (var i = 3; i < len; i+= 4) {
	        var alpha = imgData[i];
	        var offset = alpha * 4;


	        if (!offset) {
	          continue;
	        }

	        var finalAlpha;
	        if (opacity > 0) {
	          finalAlpha = opacity;
	        } else {
	          if (alpha < maxOpacity) {
	            if (alpha < minOpacity) {
	              finalAlpha = minOpacity;
	            } else {
	              finalAlpha = alpha;
	            }
	          } else {
	            finalAlpha = maxOpacity;
	          }
	        }

	        imgData[i-3] = palette[offset];
	        imgData[i-2] = palette[offset + 1];
	        imgData[i-1] = palette[offset + 2];
	        imgData[i] = useGradientOpacity ? palette[offset + 3] : finalAlpha;

	      }

	      img.data = imgData;
	      this.ctx.putImageData(img, x, y);

	      this._renderBoundaries = [1000, 1000, 0, 0];

	    },
	    getValueAt: function(point) {
	      var value;
	      var shadowCtx = this.shadowCtx;
	      var img = shadowCtx.getImageData(point.x, point.y, 1, 1);
	      var data = img.data[3];
	      var max = this._max;
	      var min = this._min;

	      value = (Math.abs(max-min) * (data/255)) >> 0;

	      return value;
	    },
	    getDataURL: function() {
	      return this.canvas.toDataURL();
	    }
	  };


	  return Canvas2dRenderer;
	})();


	var Renderer = (function RendererClosure() {

	  var rendererFn = false;

	  if (HeatmapConfig['defaultRenderer'] === 'canvas2d') {
	    rendererFn = Canvas2dRenderer;
	  }

	  return rendererFn;
	})();


	var Util = {
	  merge: function() {
	    var merged = {};
	    var argsLen = arguments.length;
	    for (var i = 0; i < argsLen; i++) {
	      var obj = arguments[i];
	      for (var key in obj) {
	        merged[key] = obj[key];
	      }
	    }
	    return merged;
	  }
	};
	// Heatmap Constructor
	var Heatmap = (function HeatmapClosure() {

	  var Coordinator = (function CoordinatorClosure() {

	    function Coordinator() {
	      this.cStore = {};
	    }
	    Coordinator.prototype = {
	      on: function(evtName, callback, scope) {
	        var cStore = this.cStore;

	        if (!cStore[evtName]) {
	          cStore[evtName] = [];
	        }
	        cStore[evtName].push((function(data) {
	            return callback.call(scope, data);
	        }));
	      },
	      emit: function(evtName, data) {
	        var cStore = this.cStore;
	        if (cStore[evtName]) {
	          var len = cStore[evtName].length;
	          for (var i=0; i<len; i++) {
	            var callback = cStore[evtName][i];
	            callback(data);
	          }
	        }
	      }
	    };

	    return Coordinator;
	  })();


	  var _connect = function(scope) {
	    var renderer = scope._renderer;
	    var coordinator = scope._coordinator;
	    var store = scope._store;

	    coordinator.on('renderpartial', renderer.renderPartial, renderer);
	    coordinator.on('renderall', renderer.renderAll, renderer);
	    coordinator.on('extremachange', function(data) {
	      scope._config.onExtremaChange &&
	      scope._config.onExtremaChange({
	        min: data.min,
	        max: data.max,
	        gradient: scope._config['gradient'] || scope._config['defaultGradient']
	      });
	    });
	    store.setCoordinator(coordinator);
	  };


	  function Heatmap() {
	    var config = this._config = Util.merge(HeatmapConfig, arguments[0] || {});
	    this._coordinator = new Coordinator();
	    if (config['plugin']) {
	      var pluginToLoad = config['plugin'];
	      if (!HeatmapConfig.plugins[pluginToLoad]) {
	        throw new Error('Plugin \''+ pluginToLoad + '\' not found. Maybe it was not registered.');
	      } else {
	        var plugin = HeatmapConfig.plugins[pluginToLoad];
	        // set plugin renderer and store
	        this._renderer = new plugin.renderer(config);
	        this._store = new plugin.store(config);
	      }
	    } else {
	      this._renderer = new Renderer(config);
	      this._store = new Store(config);
	    }
	    _connect(this);
	  }
	  // @TODO:
	  // add API documentation
	  Heatmap.prototype = {
	    addData: function() {
	      this._store.addData.apply(this._store, arguments);
	      return this;
	    },
	    removeData: function() {
	      this._store.removeData && this._store.removeData.apply(this._store, arguments);
	      return this;
	    },
	    setData: function() {
	      this._store.setData.apply(this._store, arguments);
	      return this;
	    },
	    setDataMax: function() {
	      this._store.setDataMax.apply(this._store, arguments);
	      return this;
	    },
	    setDataMin: function() {
	      this._store.setDataMin.apply(this._store, arguments);
	      return this;
	    },
	    configure: function(config) {
	      this._config = Util.merge(this._config, config);
	      this._renderer.updateConfig(this._config);
	      this._coordinator.emit('renderall', this._store._getInternalData());
	      return this;
	    },
	    repaint: function() {
	      this._coordinator.emit('renderall', this._store._getInternalData());
	      return this;
	    },
	    getData: function() {
	      return this._store.getData();
	    },
	    getDataURL: function() {
	      return this._renderer.getDataURL();
	    },
	    getValueAt: function(point) {

	      if (this._store.getValueAt) {
	        return this._store.getValueAt(point);
	      } else  if (this._renderer.getValueAt) {
	        return this._renderer.getValueAt(point);
	      } else {
	        return null;
	      }
	    }
	  };

	  return Heatmap;

	})();


	// core
	var heatmapFactory = {
	  create: function(config) {
	    return new Heatmap(config);
	  },
	  register: function(pluginKey, plugin) {
	    HeatmapConfig.plugins[pluginKey] = plugin;
	  }
	};

	return heatmapFactory;


	});
	});

	var script$1P = {
	  name: 'vc-heatmap',
	  data: function data() {
	    return {
	      defaultOptions: {
	        useEntitiesIfAvailable: true,
	        // whether to use entities if a Viewer is supplied or always use an ImageryProvider
	        minCanvasSize: 700,
	        // minimum size (in pixels) for the heatmap canvas
	        maxCanvasSize: 2000,
	        // maximum size (in pixels) for the heatmap canvas
	        radiusFactor: 60,
	        // data point size factor used if no radius is given (the greater of height and width divided by this number yields the used radius)
	        spacingFactor: 1.5,
	        // extra space around the borders (point radius multiplied by this number yields the spacing)
	        maxOpacity: 0.8,
	        // the maximum opacity used if not given in the heatmap options object
	        minOpacity: 0.1,
	        // the minimum opacity used if not given in the heatmap options object
	        blur: 0.85,
	        // the blur used if not given in the heatmap options object
	        gradient: {
	          // the gradient used if not given in the heatmap options object
	          '.3': 'blue',
	          '.65': 'yellow',
	          '.8': 'orange',
	          '.95': 'red'
	        }
	      },
	      material: null,
	      appearance: null,
	      geometry: null,
	      coordinates: {
	        west: 0,
	        south: 0,
	        east: 0,
	        north: 0
	      },
	      layerUrl: '',
	      nowaiting: true
	    };
	  },
	  mixins: [cmp],
	  props: {
	    type: {
	      type: Number,
	      default: 0
	    },
	    bounds: Object,
	    options: Object,
	    min: Number,
	    max: Number,
	    data: Array,
	    show: {
	      type: Boolean,
	      default: true
	    }
	  },
	  computed: {
	    changeProps: function changeProps() {
	      var bounds = this.bounds,
	          options = this.options,
	          min = this.min,
	          max = this.max,
	          data = this.data;
	      return {
	        bounds: bounds,
	        options: options,
	        min: min,
	        max: max,
	        data: data
	      };
	    }
	  },
	  watch: {
	    changeProps: {
	      handler: function handler(val, oldValue) {
	        var _heatmapInstance;

	        return regenerator.async(function handler$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                _context.next = 2;
	                return regenerator.awrap(this.getParent(this.$parent).createPromise);

	              case 2:
	                if (!(stringify$1(val) === stringify$1(oldValue))) {
	                  _context.next = 4;
	                  break;
	                }

	                return _context.abrupt("return");

	              case 4:
	                _heatmapInstance = this._heatmapInstance;

	                if (stringify$1(val.bounds) !== stringify$1(oldValue.bounds)) {
	                  this.setBounds(val.bounds);
	                }

	                val.min !== oldValue.min && _heatmapInstance.setDataMin(val.min);
	                val.max !== oldValue.max && _heatmapInstance.setDataMin(val.max);
	                stringify$1(val.options) !== stringify$1(oldValue.options) && _heatmapInstance.configure(val.options);
	                stringify$1(val.data) !== stringify$1(oldValue.data) && this.setWGS84Data(val.min, val.max, val.data);
	                this.layerUrl = _heatmapInstance.getDataURL();
	                this.appearance.material.uniforms.image = this.layerUrl;

	              case 12:
	              case "end":
	                return _context.stop();
	            }
	          }
	        }, null, this);
	      },
	      deep: true
	    }
	  },
	  mounted: function mounted() {
	    var _this = this;

	    this.getParent(this.$parent).createPromise.then(function (_ref) {
	      var Cesium = _ref.Cesium,
	          viewer = _ref.viewer;
	      var bounds = _this.bounds,
	          options = _this.options,
	          min = _this.min,
	          max = _this.max,
	          data = _this.data,
	          defaultOptions = _this.defaultOptions;
	      _this._WMP = new Cesium.WebMercatorProjection();
	      _this._id = _this.getID();
	      options.gradient = options.gradient ? options.gradient : defaultOptions.gradient;
	      options.maxOpacity = options.maxOpacity ? options.maxOpacity : defaultOptions.maxOpacity;
	      options.minOpacity = options.minOpacity ? options.minOpacity : defaultOptions.minOpacity;
	      options.blur = options.blur ? options.blur : defaultOptions.blur;

	      _this.setBounds(bounds);

	      _this._container = _this.getContainer(_this.width, _this.height, _this._id);
	      _this.options.container = _this._container;
	      _this._heatmapInstance = heatmap.create(_this.options);

	      _this._container.children[0].setAttribute('id', _this._id + '-hm');

	      if (_this.setWGS84Data(min, max, data)) {
	        _this.layerUrl = _this._heatmapInstance.getDataURL();
	      }

	      _this.material = new Cesium.ImageMaterialProperty({
	        image: new Cesium.CallbackProperty(_this.materialCallback, false),
	        transparent: true
	      });
	      _this.appearance = new Cesium.MaterialAppearance({
	        material: new Cesium.Material({
	          fabric: {
	            type: 'Image',
	            uniforms: {
	              image: _this.layerUrl
	            }
	          }
	        })
	      });
	    });
	  },
	  methods: {
	    createCesiumObject: function createCesiumObject() {
	      var _this2 = this;

	      var type;
	      return regenerator.async(function createCesiumObject$(_context2) {
	        while (1) {
	          switch (_context2.prev = _context2.next) {
	            case 0:
	              type = this.type;
	              return _context2.abrupt("return", this.$refs[type].createPromise.then(function (_ref2) {
	                var Cesium = _ref2.Cesium,
	                    viewer = _ref2.viewer,
	                    cesiumObject = _ref2.cesiumObject;

	                if (!_this2.$refs[type]._mounted) {
	                  return _this2.$refs[type].load().then(function (_ref3) {
	                    var Cesium = _ref3.Cesium,
	                        viewer = _ref3.viewer,
	                        cesiumObject = _ref3.cesiumObject;
	                    return cesiumObject;
	                  });
	                } else {
	                  return cesiumObject;
	                }
	              }));

	            case 2:
	            case "end":
	              return _context2.stop();
	          }
	        }
	      }, null, this);
	    },
	    materialCallback: function materialCallback() {
	      return this.layerUrl;
	    },
	    setBounds: function setBounds(bounds) {
	      var options = this.options,
	          defaultOptions = this.defaultOptions;
	      this._mBounds = this.wgs84ToMercatorBounds(bounds);
	      this.setWidthAndHeight(this._mBounds);
	      options.radius = Math.round(options.radius ? options.radius : this.width > this.height ? this.width / defaultOptions.radiusFactor : this.height / defaultOptions.radiusFactor);
	      this._spacing = options.radius * defaultOptions.spacingFactor;
	      this._xoffset = this._mBounds.west;
	      this._yoffset = this._mBounds.south;
	      this.width = Math.round(this.width + this._spacing * 2);
	      this.height = Math.round(this.height + this._spacing * 2);
	      this._mBounds.west -= this._spacing * this._factor;
	      this._mBounds.east += this._spacing * this._factor;
	      this._mBounds.south -= this._spacing * this._factor;
	      this._mBounds.north += this._spacing * this._factor;
	      this._bounds = this.mercatorToWgs84Bounds(this._mBounds);
	      this.coordinates = this._bounds;
	    },
	    mount: function mount() {
	      return regenerator.async(function mount$(_context3) {
	        while (1) {
	          switch (_context3.prev = _context3.next) {
	            case 0:
	              return _context3.abrupt("return", true);

	            case 1:
	            case "end":
	              return _context3.stop();
	          }
	        }
	      });
	    },
	    unmount: function unmount() {
	      var type;
	      return regenerator.async(function unmount$(_context4) {
	        while (1) {
	          switch (_context4.prev = _context4.next) {
	            case 0:
	              document.body.removeChild(this._container);
	              type = this.type;
	              return _context4.abrupt("return", this.$refs[type] && this.$refs[type].unload());

	            case 3:
	            case "end":
	              return _context4.stop();
	          }
	        }
	      }, null, this);
	    },
	    setWidthAndHeight: function setWidthAndHeight(mbb) {
	      var defaultOptions = this.defaultOptions;
	      this.width = mbb.east > 0 && mbb.west < 0 ? mbb.east + Math.abs(mbb.west) : Math.abs(mbb.east - mbb.west);
	      this.height = mbb.north > 0 && mbb.south < 0 ? mbb.north + Math.abs(mbb.south) : Math.abs(mbb.north - mbb.south);
	      this._factor = 1;

	      if (this.width > this.height && this.width > defaultOptions.maxCanvasSize) {
	        this._factor = this.width / defaultOptions.maxCanvasSize;

	        if (this.height / this._factor < defaultOptions.minCanvasSize) {
	          this._factor = this.height / defaultOptions.minCanvasSize;
	        }
	      } else if (this.height > this.width && this.height > defaultOptions.maxCanvasSize) {
	        this._factor = this.height / defaultOptions.maxCanvasSize;

	        if (this.width / this._factor < defaultOptions.minCanvasSize) {
	          this._factor = this.width / defaultOptions.minCanvasSize;
	        }
	      } else if (this.width < this.height && this.width < defaultOptions.minCanvasSize) {
	        this._factor = this.width / defaultOptions.minCanvasSize;

	        if (this.height / this._factor > defaultOptions.maxCanvasSize) {
	          this._factor = this.height / defaultOptions.maxCanvasSize;
	        }
	      } else if (this.height < this.width && this.height < defaultOptions.minCanvasSize) {
	        this._factor = this.height / defaultOptions.minCanvasSize;

	        if (this.width / this._factor > defaultOptions.maxCanvasSize) {
	          this._factor = this.width / defaultOptions.maxCanvasSize;
	        }
	      }

	      this.width = this.width / this._factor;
	      this.height = this.height / this._factor;
	    },
	    getContainer: function getContainer(width, height, id) {
	      var c = document.createElement('div');

	      if (id) {
	        c.setAttribute('id', id);
	      }

	      c.setAttribute('style', 'width: ' + width + 'px; height: ' + height + 'px; margin: 0px; display: none;');
	      document.body.appendChild(c);
	      return c;
	    },
	    getID: function getID(len) {
	      var text = '';
	      var possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';

	      for (var i = 0; i < (len || 8); i++) {
	        text += possible.charAt(Math.floor(Math.random() * possible.length));
	      }

	      return text;
	    },

	    /*  Convert a WGS84 location into a mercator location
	      *
	      *  p: the WGS84 location like {x: lon, y: lat}
	      */
	    wgs84ToMercator: function wgs84ToMercator(p) {
	      var mp = this._WMP.project(Cesium.Cartographic.fromDegrees(p.x, p.y));

	      return {
	        x: mp.x,
	        y: mp.y
	      };
	    },

	    /*  Convert a WGS84 bounding box into a mercator bounding box
	      *
	      *  bb: the WGS84 bounding box like {north, east, south, west}
	      */
	    wgs84ToMercatorBounds: function wgs84ToMercatorBounds(bounds) {
	      var sw = this._WMP.project(Cesium.Cartographic.fromDegrees(bounds.west, bounds.south));

	      var ne = this._WMP.project(Cesium.Cartographic.fromDegrees(bounds.east, bounds.north));

	      return {
	        north: ne.y,
	        east: ne.x,
	        south: sw.y,
	        west: sw.x
	      };
	    },

	    /*  Convert a mercator location into a WGS84 location
	      *
	      *  p: the mercator lcation like {x, y}
	      */
	    mercatorToWgs84: function mercatorToWgs84(p) {
	      var wp = this._WMP.unproject(new Cesium.Cartesian3(p.x, p.y));

	      return {
	        x: wp.longitude,
	        y: wp.latitude
	      };
	    },

	    /*  Convert a mercator bounding box into a WGS84 bounding box
	      *
	      *  bb: the mercator bounding box like {north, east, south, west}
	      */
	    mercatorToWgs84Bounds: function mercatorToWgs84Bounds(bb) {
	      var sw = this._WMP.unproject(new Cesium.Cartesian3(bb.west, bb.south));

	      var ne = this._WMP.unproject(new Cesium.Cartesian3(bb.east, bb.north));

	      return {
	        north: this.rad2deg(ne.latitude),
	        east: this.rad2deg(ne.longitude),
	        south: this.rad2deg(sw.latitude),
	        west: this.rad2deg(sw.longitude)
	      };
	    },

	    /*  Convert degrees into radians
	      *
	      *  d: the degrees to be converted to radians
	      */
	    deg2rad: function deg2rad(d) {
	      var r = d * (Math.PI / 180.0);
	      return r;
	    },

	    /*  Convert radians into degrees
	      *
	      *  r: the radians to be converted to degrees
	      */
	    rad2deg: function rad2deg(r) {
	      var d = r / (Math.PI / 180.0);
	      return d;
	    },

	    /*  Set an array of heatmap locations
	     *
	     *  min:  the minimum allowed value for the data values
	     *  max:  the maximum allowed value for the data values
	     *  data: an array of data points in heatmap coordinates and values like {x, y, value}
	     */
	    setData: function setData(min, max, data) {
	      if (data && data.length > 0 && min !== null && min !== false && max !== null && max !== false) {
	        this._heatmapInstance.setData({
	          min: min,
	          max: max,
	          data: data
	        }); // this.updateLayer()


	        return true;
	      }

	      return false;
	    },

	    /*  Set an array of WGS84 locations
	     *
	     *  min:  the minimum allowed value for the data values
	     *  max:  the maximum allowed value for the data values
	     *  data: an array of data points in WGS84 coordinates and values like { x:lon, y:lat, value }
	     */
	    setWGS84Data: function setWGS84Data(min, max, data) {
	      if (data && data.length > 0 && min !== null && min !== false && max !== null && max !== false) {
	        var convdata = [];

	        for (var i = 0; i < data.length; i++) {
	          var gp = data[i];
	          var hp = this.wgs84PointToHeatmapPoint(gp);

	          if (gp.value || gp.value === 0) {
	            hp.value = gp.value;
	          }

	          convdata.push(hp);
	        }

	        return this.setData(min, max, convdata);
	      }

	      return false;
	    },

	    /*  Convert a WGS84 location to the corresponding heatmap location
	     *
	     *  p: a WGS84 location like {x:lon, y:lat}
	     */
	    wgs84PointToHeatmapPoint: function wgs84PointToHeatmapPoint(p) {
	      return this.mercatorPointToHeatmapPoint(this.wgs84ToMercator(p));
	    },

	    /*  Convert a mercator location to the corresponding heatmap location
	     *
	     *  p: a WGS84 location like {x: lon, y:lat}
	     */
	    mercatorPointToHeatmapPoint: function mercatorPointToHeatmapPoint(p) {
	      var pn = {};
	      pn.x = Math.round((p.x - this._xoffset) / this._factor + this._spacing);
	      pn.y = Math.round((p.y - this._yoffset) / this._factor + this._spacing);
	      pn.y = this.height - pn.y;
	      return pn;
	    }
	  },
	  created: function created() {
	    var _this3 = this;

	    defineProperties$1(this, {
	      heatMapInstance: {
	        enumerable: true,
	        get: function get() {
	          return _this3.$services && _this3.cesiumObject;
	        }
	      }
	    });
	  }
	};

	/* script */
	var __vue_script__$1P = script$1P;
	/* template */

	var __vue_render__$m = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('i', {
	    class: _vm.$options.name,
	    staticStyle: {
	      "display": "none !important"
	    }
	  }, [_vm.type === 1 ? _c('vc-entity', {
	    ref: "1",
	    attrs: {
	      "show": _vm.show
	    }
	  }, [_c('vc-graphics-rectangle', {
	    attrs: {
	      "coordinates": _vm.coordinates,
	      "material": _vm.material
	    }
	  })], 1) : _vm.type === 0 ? _c('vc-primitive-ground', {
	    ref: "0",
	    attrs: {
	      "appearance": _vm.appearance,
	      "show": _vm.show
	    }
	  }, [_c('vc-instance-geometry', {
	    attrs: {
	      "geometry": _vm.geometry
	    },
	    on: {
	      "update:geometry": function updateGeometry($event) {
	        _vm.geometry = $event;
	      }
	    }
	  }, [_c('vc-geometry-rectangle', {
	    attrs: {
	      "rectangle": _vm.coordinates
	    }
	  })], 1)], 1) : _vm.type === 2 ? _c('vc-layer-imagery', {
	    ref: "2",
	    attrs: {
	      "show": _vm.show
	    }
	  }, [_c('vc-provider-imagery-tile-single', {
	    attrs: {
	      "rectangle": _vm.coordinates,
	      "url": _vm.layerUrl
	    }
	  })], 1) : _vm._e()], 1);
	};

	var __vue_staticRenderFns__$m = [];
	/* style */

	var __vue_inject_styles__$1P = undefined;
	/* scoped */

	var __vue_scope_id__$1P = undefined;
	/* functional template */

	var __vue_is_functional_template__$1P = false;
	/* component normalizer */

	function __vue_normalize__$1P(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "VcHeatMap.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var VcHeatMap = __vue_normalize__$1P({
	  render: __vue_render__$m,
	  staticRenderFns: __vue_staticRenderFns__$m
	}, __vue_inject_styles__$1P, __vue_script__$1P, __vue_scope_id__$1P, __vue_is_functional_template__$1P);

	function plugin$1F(Vue) {

	  if (plugin$1F.installed) {
	    return;
	  }

	  Vue.use(Entity$1);
	  Vue.use(RectangleGraphics$1);
	  Vue.use(GroundPrimitive$1);
	  Vue.use(GeometryInstance$1);
	  Vue.use(RectangleGeometry$1);
	  Vue.use(ImageryLayer$1);
	  Vue.use(SingleTileImageryProvider$1);
	  plugin$1F.installed = true;
	  Vue.component(VcHeatMap.name, VcHeatMap);
	}

	var VcHeatMap$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$1F,
		VcHeatMap: VcHeatMap,
		install: plugin$1F
	});

	var kriging = createCommonjsModule(function (module, exports) {
	/*!
	 * author: [object Object] 
	 * @sakitam-gis/kriging v0.1.0
	 * build-time: 2019-7-6 20:41
	 * LICENSE: MIT
	 * (c) 2019-2019 https://github.com/sakitam-gis/kriging.js
	 */
	(function (global, factory) {
	   factory(exports) ;
	}(commonjsGlobal, function (exports) {
	  function max(source) {
	      return Math.max.apply(null, source);
	  }
	  function min(source) {
	      return Math.min.apply(null, source);
	  }
	  function rep(source, n) {
	      var array = [];
	      for (var i = 0; i < n; i++) {
	          array.push(source);
	      }
	      return array;
	  }
	  function pip(source, x, y) {
	      var i = 0;
	      var j = source.length - 1;
	      var c = false;
	      var length = source.length;
	      for (; i < length; j = i++) {
	          if (((source[i][1] > y) !== (source[j][1] > y))
	              && (x < (source[j][0] - source[i][0]) * (y - source[i][1]) / (source[j][1] - source[i][1]) + source[i][0])) {
	              c = !c;
	          }
	      }
	      return c;
	  }
	  function matrixDiag(c, n) {
	      var i = 0;
	      var Z = rep(0, n * n);
	      for (; i < n; i++) {
	          Z[i * n + i] = c;
	      }
	      return Z;
	  }
	  function matrixTranspose(X, n, m) {
	      var i = 0;
	      var j;
	      var Z = Array(m * n);
	      for (; i < n; i++) {
	          j = 0;
	          for (; j < m; j++) {
	              Z[j * n + i] = X[i * m + j];
	          }
	      }
	      return Z;
	  }
	  function matrixAdd(X, Y, n, m) {
	      var i = 0;
	      var j;
	      var Z = Array(n * m);
	      for (; i < n; i++) {
	          j = 0;
	          for (; j < m; j++) {
	              Z[i * m + j] = X[i * m + j] + Y[i * m + j];
	          }
	      }
	      return Z;
	  }
	  function matrixMultiply(X, Y, n, m, p) {
	      var i = 0;
	      var j;
	      var k;
	      var Z = Array(n * p);
	      for (; i < n; i++) {
	          j = 0;
	          for (; j < p; j++) {
	              Z[i * p + j] = 0;
	              k = 0;
	              for (; k < m; k++) {
	                  Z[i * p + j] += X[i * m + k] * Y[k * p + j];
	              }
	          }
	      }
	      return Z;
	  }
	  function matrixChol(X, n) {
	      var i;
	      var j;
	      var k;
	      var p = Array(n);
	      for (i = 0; i < n; i++)
	          p[i] = X[i * n + i];
	      for (i = 0; i < n; i++) {
	          for (j = 0; j < i; j++)
	              p[i] -= X[i * n + j] * X[i * n + j];
	          if (p[i] <= 0)
	              return false;
	          p[i] = Math.sqrt(p[i]);
	          for (j = i + 1; j < n; j++) {
	              for (k = 0; k < i; k++)
	                  X[j * n + i] -= X[j * n + k] * X[i * n + k];
	              X[j * n + i] /= p[i];
	          }
	      }
	      for (i = 0; i < n; i++)
	          X[i * n + i] = p[i];
	      return true;
	  }
	  function matrixChol2inv(X, n) {
	      var i;
	      var j;
	      var k;
	      var sum;
	      for (i = 0; i < n; i++) {
	          X[i * n + i] = 1 / X[i * n + i];
	          for (j = i + 1; j < n; j++) {
	              sum = 0;
	              for (k = i; k < j; k++)
	                  sum -= X[j * n + k] * X[k * n + i];
	              X[j * n + i] = sum / X[j * n + j];
	          }
	      }
	      for (i = 0; i < n; i++)
	          for (j = i + 1; j < n; j++)
	              X[i * n + j] = 0;
	      for (i = 0; i < n; i++) {
	          X[i * n + i] *= X[i * n + i];
	          for (k = i + 1; k < n; k++)
	              X[i * n + i] += X[k * n + i] * X[k * n + i];
	          for (j = i + 1; j < n; j++)
	              for (k = j; k < n; k++)
	                  X[i * n + j] += X[k * n + i] * X[k * n + j];
	      }
	      for (i = 0; i < n; i++)
	          for (j = 0; j < i; j++)
	              X[i * n + j] = X[j * n + i];
	  }
	  function matrixSolve(X, n) {
	      var m = n;
	      var b = Array(n * n);
	      var indxc = Array(n);
	      var indxr = Array(n);
	      var ipiv = Array(n);
	      var i;
	      var icol = 0;
	      var irow = 0;
	      var j;
	      var k;
	      var l;
	      var ll;
	      var big;
	      var dum;
	      var pivinv;
	      var temp;
	      for (i = 0; i < n; i++) {
	          for (j = 0; j < n; j++) {
	              if (i === j)
	                  b[i * n + j] = 1;
	              else
	                  b[i * n + j] = 0;
	          }
	      }
	      for (j = 0; j < n; j++)
	          ipiv[j] = 0;
	      for (i = 0; i < n; i++) {
	          big = 0;
	          for (j = 0; j < n; j++) {
	              if (ipiv[j] !== 1) {
	                  for (k = 0; k < n; k++) {
	                      if (ipiv[k] === 0) {
	                          if (Math.abs(X[j * n + k]) >= big) {
	                              big = Math.abs(X[j * n + k]);
	                              irow = j;
	                              icol = k;
	                          }
	                      }
	                  }
	              }
	          }
	          ++(ipiv[icol]);
	          if (irow !== icol) {
	              for (l = 0; l < n; l++) {
	                  temp = X[irow * n + l];
	                  X[irow * n + l] = X[icol * n + l];
	                  X[icol * n + l] = temp;
	              }
	              for (l = 0; l < m; l++) {
	                  temp = b[irow * n + l];
	                  b[irow * n + l] = b[icol * n + l];
	                  b[icol * n + l] = temp;
	              }
	          }
	          indxr[i] = irow;
	          indxc[i] = icol;
	          if (X[icol * n + icol] === 0)
	              return false;
	          pivinv = 1 / X[icol * n + icol];
	          X[icol * n + icol] = 1;
	          for (l = 0; l < n; l++)
	              X[icol * n + l] *= pivinv;
	          for (l = 0; l < m; l++)
	              b[icol * n + l] *= pivinv;
	          for (ll = 0; ll < n; ll++) {
	              if (ll !== icol) {
	                  dum = X[ll * n + icol];
	                  X[ll * n + icol] = 0;
	                  for (l = 0; l < n; l++)
	                      X[ll * n + l] -= X[icol * n + l] * dum;
	                  for (l = 0; l < m; l++)
	                      b[ll * n + l] -= b[icol * n + l] * dum;
	              }
	          }
	      }
	      for (l = (n - 1); l >= 0; l--) {
	          if (indxr[l] !== indxc[l]) {
	              for (k = 0; k < n; k++) {
	                  temp = X[k * n + indxr[l]];
	                  X[k * n + indxr[l]] = X[k * n + indxc[l]];
	                  X[k * n + indxc[l]] = temp;
	              }
	          }
	      }
	      return true;
	  }
	  function variogramGaussian(h, nugget, range, sill, A) {
	      return nugget + ((sill - nugget) / range)
	          * (1.0 - Math.exp(-(1.0 / A) * Math.pow(h / range, 2)));
	  }
	  function variogramExponential(h, nugget, range, sill, A) {
	      return nugget + ((sill - nugget) / range)
	          * (1.0 - Math.exp(-(1.0 / A) * (h / range)));
	  }
	  function variogramSpherical(h, nugget, range, sill) {
	      if (h > range)
	          return nugget + (sill - nugget) / range;
	      return nugget + ((sill - nugget) / range)
	          * (1.5 * (h / range) - 0.5 * Math.pow(h / range, 3));
	  }

	  function train(t, x, y, model, sigma2, alpha) {
	      var variogram = {
	          t: t,
	          x: x,
	          y: y,
	          nugget: 0.0,
	          range: 0.0,
	          sill: 0.0,
	          A: 1 / 3,
	          n: 0,
	          model: variogramExponential,
	          K: [],
	          M: [],
	      };
	      switch (model) {
	          case 'gaussian':
	              variogram.model = variogramGaussian;
	              break;
	          case 'exponential':
	              variogram.model = variogramExponential;
	              break;
	          case 'spherical':
	              variogram.model = variogramSpherical;
	              break;
	          default:
	              variogram.model = variogramExponential;
	      }
	      var i;
	      var j;
	      var k;
	      var l;
	      var n = t.length;
	      var distance = Array((n * n - n) / 2);
	      for (i = 0, k = 0; i < n; i++) {
	          for (j = 0; j < i; j++, k++) {
	              distance[k] = Array(2);
	              distance[k][0] = Math.pow(Math.pow(x[i] - x[j], 2)
	                  + Math.pow(y[i] - y[j], 2), 0.5);
	              distance[k][1] = Math.abs(t[i] - t[j]);
	          }
	      }
	      distance.sort(function (a, b) { return a[0] - b[0]; });
	      variogram.range = distance[(n * n - n) / 2 - 1][0];
	      var lags = ((n * n - n) / 2) > 30 ? 30 : (n * n - n) / 2;
	      var tolerance = variogram.range / lags;
	      var lag = rep(0, lags);
	      var semi = rep(0, lags);
	      if (lags < 30) {
	          for (l = 0; l < lags; l++) {
	              lag[l] = distance[l][0];
	              semi[l] = distance[l][1];
	          }
	      }
	      else {
	          for (i = 0, j = 0, k = 0, l = 0; i < lags && j < ((n * n - n) / 2); i++, k = 0) {
	              while (distance[j][0] <= ((i + 1) * tolerance)) {
	                  lag[l] += distance[j][0];
	                  semi[l] += distance[j][1];
	                  j++;
	                  k++;
	                  if (j >= ((n * n - n) / 2))
	                      break;
	              }
	              if (k > 0) {
	                  lag[l] /= k;
	                  semi[l] /= k;
	                  l++;
	              }
	          }
	          if (l < 2)
	              return variogram;
	      }
	      n = l;
	      variogram.range = lag[n - 1] - lag[0];
	      var X = rep(1, 2 * n);
	      var Y = Array(n);
	      var A = variogram.A;
	      for (i = 0; i < n; i++) {
	          switch (model) {
	              case 'gaussian':
	                  X[i * 2 + 1] = 1.0 - Math.exp(-(1.0 / A) * Math.pow(lag[i] / variogram.range, 2));
	                  break;
	              case 'exponential':
	                  X[i * 2 + 1] = 1.0 - Math.exp(-(1.0 / A) * lag[i] / variogram.range);
	                  break;
	              case 'spherical':
	                  X[i * 2 + 1] = 1.5 * (lag[i] / variogram.range)
	                      - 0.5 * Math.pow(lag[i] / variogram.range, 3);
	                  break;
	          }
	          Y[i] = semi[i];
	      }
	      var Xt = matrixTranspose(X, n, 2);
	      var Z = matrixMultiply(Xt, X, 2, n, 2);
	      Z = matrixAdd(Z, matrixDiag(1 / alpha, 2), 2, 2);
	      var cloneZ = Z.slice(0);
	      if (matrixChol(Z, 2)) {
	          matrixChol2inv(Z, 2);
	      }
	      else {
	          matrixSolve(cloneZ, 2);
	          Z = cloneZ;
	      }
	      var W = matrixMultiply(matrixMultiply(Z, Xt, 2, 2, n), Y, 2, n, 1);
	      variogram.nugget = W[0];
	      variogram.sill = W[1] * variogram.range + variogram.nugget;
	      variogram.n = x.length;
	      n = x.length;
	      var K = Array(n * n);
	      for (i = 0; i < n; i++) {
	          for (j = 0; j < i; j++) {
	              K[i * n + j] = variogram.model(Math.pow(Math.pow(x[i] - x[j], 2)
	                  + Math.pow(y[i] - y[j], 2), 0.5), variogram.nugget, variogram.range, variogram.sill, variogram.A);
	              K[j * n + i] = K[i * n + j];
	          }
	          K[i * n + i] = variogram.model(0, variogram.nugget, variogram.range, variogram.sill, variogram.A);
	      }
	      var C = matrixAdd(K, matrixDiag(sigma2, n), n, n);
	      var cloneC = C.slice(0);
	      if (matrixChol(C, n)) {
	          matrixChol2inv(C, n);
	      }
	      else {
	          matrixSolve(cloneC, n);
	          C = cloneC;
	      }
	      var K1 = C.slice(0);
	      var M = matrixMultiply(C, t, n, n, 1);
	      variogram.K = K1;
	      variogram.M = M;
	      return variogram;
	  }
	  function predict(x, y, variogram) {
	      var i;
	      var k = Array(variogram.n);
	      for (i = 0; i < variogram.n; i++) {
	          k[i] = variogram.model(Math.pow(Math.pow(x - variogram.x[i], 2)
	              + Math.pow(y - variogram.y[i], 2), 0.5), variogram.nugget, variogram.range, variogram.sill, variogram.A);
	      }
	      return matrixMultiply(k, variogram.M, 1, variogram.n, 1)[0];
	  }
	  function variance(x, y, variogram) {
	      var i;
	      var k = Array(variogram.n);
	      for (i = 0; i < variogram.n; i++) {
	          k[i] = variogram.model(Math.pow(Math.pow(x - variogram.x[i], 2) + Math.pow(y - variogram.y[i], 2), 0.5), variogram.nugget, variogram.range, variogram.sill, variogram.A);
	      }
	      var val = matrixMultiply(matrixMultiply(k, variogram.K, 1, variogram.n, variogram.n), k, 1, variogram.n, 1)[0];
	      return variogram.model(0, variogram.nugget, variogram.range, variogram.sill, variogram.A) + val;
	  }
	  function grid(polygons, variogram, width) {
	      var i;
	      var j;
	      var k;
	      var n = polygons.length;
	      if (n === 0)
	          return;
	      var xlim = [polygons[0][0][0], polygons[0][0][0]];
	      var ylim = [polygons[0][0][1], polygons[0][0][1]];
	      for (i = 0; i < n; i++) {
	          for (j = 0; j < polygons[i].length; j++) {
	              if (polygons[i][j][0] < xlim[0])
	                  xlim[0] = polygons[i][j][0];
	              if (polygons[i][j][0] > xlim[1])
	                  xlim[1] = polygons[i][j][0];
	              if (polygons[i][j][1] < ylim[0])
	                  ylim[0] = polygons[i][j][1];
	              if (polygons[i][j][1] > ylim[1])
	                  ylim[1] = polygons[i][j][1];
	          }
	      }
	      var xtarget;
	      var ytarget;
	      var a = Array(2);
	      var b = Array(2);
	      var lxlim = Array(2);
	      var lylim = Array(2);
	      var x = Math.ceil((xlim[1] - xlim[0]) / width);
	      var y = Math.ceil((ylim[1] - ylim[0]) / width);
	      var A = Array(x + 1);
	      for (i = 0; i <= x; i++)
	          A[i] = Array(y + 1);
	      for (i = 0; i < n; i++) {
	          lxlim[0] = polygons[i][0][0];
	          lxlim[1] = lxlim[0];
	          lylim[0] = polygons[i][0][1];
	          lylim[1] = lylim[0];
	          for (j = 1; j < polygons[i].length; j++) {
	              if (polygons[i][j][0] < lxlim[0])
	                  lxlim[0] = polygons[i][j][0];
	              if (polygons[i][j][0] > lxlim[1])
	                  lxlim[1] = polygons[i][j][0];
	              if (polygons[i][j][1] < lylim[0])
	                  lylim[0] = polygons[i][j][1];
	              if (polygons[i][j][1] > lylim[1])
	                  lylim[1] = polygons[i][j][1];
	          }
	          a[0] = Math.floor(((lxlim[0] - ((lxlim[0] - xlim[0]) % width)) - xlim[0]) / width);
	          a[1] = Math.ceil(((lxlim[1] - ((lxlim[1] - xlim[1]) % width)) - xlim[0]) / width);
	          b[0] = Math.floor(((lylim[0] - ((lylim[0] - ylim[0]) % width)) - ylim[0]) / width);
	          b[1] = Math.ceil(((lylim[1] - ((lylim[1] - ylim[1]) % width)) - ylim[0]) / width);
	          for (j = a[0]; j <= a[1]; j++) {
	              for (k = b[0]; k <= b[1]; k++) {
	                  xtarget = xlim[0] + j * width;
	                  ytarget = ylim[0] + k * width;
	                  if (pip(polygons[i], xtarget, ytarget)) {
	                      A[j][k] = predict(xtarget, ytarget, variogram);
	                  }
	              }
	          }
	      }
	      return {
	          xlim: xlim,
	          ylim: ylim,
	          width: width,
	          data: A,
	          zlim: [min(variogram.t), max(variogram.t)],
	      };
	  }
	  function plot(canvas, grid, xlim, ylim, colors) {
	      var ctx = canvas.getContext('2d');
	      var data = grid.data, zlim = grid.zlim, width = grid.width;
	      if (ctx) {
	          ctx.clearRect(0, 0, canvas.width, canvas.height);
	          var range = [xlim[1] - xlim[0], ylim[1] - ylim[0], zlim[1] - zlim[0]];
	          var i = void 0;
	          var j = void 0;
	          var x = void 0;
	          var y = void 0;
	          var z = void 0;
	          var n = data.length;
	          var m = data[0].length;
	          var wx = Math.ceil(width * canvas.width / (xlim[1] - xlim[0]));
	          var wy = Math.ceil(width * canvas.height / (ylim[1] - ylim[0]));
	          for (i = 0; i < n; i++) {
	              for (j = 0; j < m; j++) {
	                  if (data[i][j] === undefined)
	                      continue;
	                  x = canvas.width * (i * width + grid.xlim[0] - xlim[0]) / range[0];
	                  y = canvas.height * (1 - (j * width + grid.ylim[0] - ylim[0]) / range[1]);
	                  z = (data[i][j] - zlim[0]) / range[2];
	                  if (z < 0.0)
	                      z = 0.0;
	                  if (z > 1.0)
	                      z = 1.0;
	                  ctx.fillStyle = colors[Math.floor((colors.length - 1) * z)];
	                  ctx.fillRect(Math.round(x - wx / 2), Math.round(y - wy / 2), wx, wy);
	              }
	          }
	      }
	  }
	  var index = {
	      train: train,
	      predict: predict,
	      variance: variance,
	      grid: grid,
	      plot: plot,
	      max: max,
	      min: min,
	      pip: pip,
	      rep: rep,
	      matrixDiag: matrixDiag,
	      matrixTranspose: matrixTranspose,
	      matrixAdd: matrixAdd,
	      matrixMultiply: matrixMultiply,
	      matrixChol: matrixChol,
	      matrixChol2inv: matrixChol2inv,
	      matrixSolve: matrixSolve,
	      variogramGaussian: variogramGaussian,
	      variogramExponential: variogramExponential,
	      variogramSpherical: variogramSpherical,
	  };

	  exports.default = index;
	  exports.grid = grid;
	  exports.matrixAdd = matrixAdd;
	  exports.matrixChol = matrixChol;
	  exports.matrixChol2inv = matrixChol2inv;
	  exports.matrixDiag = matrixDiag;
	  exports.matrixMultiply = matrixMultiply;
	  exports.matrixSolve = matrixSolve;
	  exports.matrixTranspose = matrixTranspose;
	  exports.max = max;
	  exports.min = min;
	  exports.pip = pip;
	  exports.plot = plot;
	  exports.predict = predict;
	  exports.rep = rep;
	  exports.train = train;
	  exports.variance = variance;
	  exports.variogramExponential = variogramExponential;
	  exports.variogramGaussian = variogramGaussian;
	  exports.variogramSpherical = variogramSpherical;

	  Object.defineProperty(exports, '__esModule', { value: true });

	}));

	});

	var kriging$1 = unwrapExports(kriging);

	var main = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, '__esModule', { value: true });

	/**
	 * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.
	 */
	var earthRadius = 6371008.8;

	/**
	 * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.
	 */
	var factors = {
	    meters: earthRadius,
	    metres: earthRadius,
	    millimeters: earthRadius * 1000,
	    millimetres: earthRadius * 1000,
	    centimeters: earthRadius * 100,
	    centimetres: earthRadius * 100,
	    kilometers: earthRadius / 1000,
	    kilometres: earthRadius / 1000,
	    miles: earthRadius / 1609.344,
	    nauticalmiles: earthRadius / 1852,
	    inches: earthRadius * 39.370,
	    yards: earthRadius / 1.0936,
	    feet: earthRadius * 3.28084,
	    radians: 1,
	    degrees: earthRadius / 111325,
	};

	/**
	 * Units of measurement factors based on 1 meter.
	 */
	var unitsFactors = {
	    meters: 1,
	    metres: 1,
	    millimeters: 1000,
	    millimetres: 1000,
	    centimeters: 100,
	    centimetres: 100,
	    kilometers: 1 / 1000,
	    kilometres: 1 / 1000,
	    miles: 1 / 1609.344,
	    nauticalmiles: 1 / 1852,
	    inches: 39.370,
	    yards: 1 / 1.0936,
	    feet: 3.28084,
	    radians: 1 / earthRadius,
	    degrees: 1 / 111325,
	};

	/**
	 * Area of measurement factors based on 1 square meter.
	 */
	var areaFactors = {
	    meters: 1,
	    metres: 1,
	    millimeters: 1000000,
	    millimetres: 1000000,
	    centimeters: 10000,
	    centimetres: 10000,
	    kilometers: 0.000001,
	    kilometres: 0.000001,
	    acres: 0.000247105,
	    miles: 3.86e-7,
	    yards: 1.195990046,
	    feet: 10.763910417,
	    inches: 1550.003100006
	};

	/**
	 * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.
	 *
	 * @name feature
	 * @param {Geometry} geometry input geometry
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature} a GeoJSON Feature
	 * @example
	 * var geometry = {
	 *   "type": "Point",
	 *   "coordinates": [110, 50]
	 * };
	 *
	 * var feature = turf.feature(geometry);
	 *
	 * //=feature
	 */
	function feature(geometry, properties, options) {
	    // Optional Parameters
	    options = options || {};
	    if (!isObject(options)) throw new Error('options is invalid');
	    var bbox = options.bbox;
	    var id = options.id;

	    // Validation
	    if (geometry === undefined) throw new Error('geometry is required');
	    if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');
	    if (bbox) validateBBox(bbox);
	    if (id) validateId(id);

	    // Main
	    var feat = {type: 'Feature'};
	    if (id) feat.id = id;
	    if (bbox) feat.bbox = bbox;
	    feat.properties = properties || {};
	    feat.geometry = geometry;
	    return feat;
	}

	/**
	 * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.
	 * For GeometryCollection type use `helpers.geometryCollection`
	 *
	 * @name geometry
	 * @param {string} type Geometry Type
	 * @param {Array<number>} coordinates Coordinates
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Geometry
	 * @returns {Geometry} a GeoJSON Geometry
	 * @example
	 * var type = 'Point';
	 * var coordinates = [110, 50];
	 *
	 * var geometry = turf.geometry(type, coordinates);
	 *
	 * //=geometry
	 */
	function geometry(type, coordinates, options) {
	    // Optional Parameters
	    options = options || {};
	    if (!isObject(options)) throw new Error('options is invalid');
	    var bbox = options.bbox;

	    // Validation
	    if (!type) throw new Error('type is required');
	    if (!coordinates) throw new Error('coordinates is required');
	    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');
	    if (bbox) validateBBox(bbox);

	    // Main
	    var geom;
	    switch (type) {
	    case 'Point': geom = point(coordinates).geometry; break;
	    case 'LineString': geom = lineString(coordinates).geometry; break;
	    case 'Polygon': geom = polygon(coordinates).geometry; break;
	    case 'MultiPoint': geom = multiPoint(coordinates).geometry; break;
	    case 'MultiLineString': geom = multiLineString(coordinates).geometry; break;
	    case 'MultiPolygon': geom = multiPolygon(coordinates).geometry; break;
	    default: throw new Error(type + ' is invalid');
	    }
	    if (bbox) geom.bbox = bbox;
	    return geom;
	}

	/**
	 * Creates a {@link Point} {@link Feature} from a Position.
	 *
	 * @name point
	 * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature<Point>} a Point feature
	 * @example
	 * var point = turf.point([-75.343, 39.984]);
	 *
	 * //=point
	 */
	function point(coordinates, properties, options) {
	    if (!coordinates) throw new Error('coordinates is required');
	    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');
	    if (coordinates.length < 2) throw new Error('coordinates must be at least 2 numbers long');
	    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) throw new Error('coordinates must contain numbers');

	    return feature({
	        type: 'Point',
	        coordinates: coordinates
	    }, properties, options);
	}

	/**
	 * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.
	 *
	 * @name points
	 * @param {Array<Array<number>>} coordinates an array of Points
	 * @param {Object} [properties={}] Translate these properties to each Feature
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection
	 * @param {string|number} [options.id] Identifier associated with the FeatureCollection
	 * @returns {FeatureCollection<Point>} Point Feature
	 * @example
	 * var points = turf.points([
	 *   [-75, 39],
	 *   [-80, 45],
	 *   [-78, 50]
	 * ]);
	 *
	 * //=points
	 */
	function points(coordinates, properties, options) {
	    if (!coordinates) throw new Error('coordinates is required');
	    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');

	    return featureCollection(coordinates.map(function (coords) {
	        return point(coords, properties);
	    }), options);
	}

	/**
	 * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.
	 *
	 * @name polygon
	 * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature<Polygon>} Polygon Feature
	 * @example
	 * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });
	 *
	 * //=polygon
	 */
	function polygon(coordinates, properties, options) {
	    if (!coordinates) throw new Error('coordinates is required');

	    for (var i = 0; i < coordinates.length; i++) {
	        var ring = coordinates[i];
	        if (ring.length < 4) {
	            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');
	        }
	        for (var j = 0; j < ring[ring.length - 1].length; j++) {
	            // Check if first point of Polygon contains two numbers
	            if (i === 0 && j === 0 && !isNumber(ring[0][0]) || !isNumber(ring[0][1])) throw new Error('coordinates must contain numbers');
	            if (ring[ring.length - 1][j] !== ring[0][j]) {
	                throw new Error('First and last Position are not equivalent.');
	            }
	        }
	    }

	    return feature({
	        type: 'Polygon',
	        coordinates: coordinates
	    }, properties, options);
	}

	/**
	 * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.
	 *
	 * @name polygons
	 * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the FeatureCollection
	 * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection
	 * @example
	 * var polygons = turf.polygons([
	 *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],
	 *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],
	 * ]);
	 *
	 * //=polygons
	 */
	function polygons(coordinates, properties, options) {
	    if (!coordinates) throw new Error('coordinates is required');
	    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');

	    return featureCollection(coordinates.map(function (coords) {
	        return polygon(coords, properties);
	    }), options);
	}

	/**
	 * Creates a {@link LineString} {@link Feature} from an Array of Positions.
	 *
	 * @name lineString
	 * @param {Array<Array<number>>} coordinates an array of Positions
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature<LineString>} LineString Feature
	 * @example
	 * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});
	 * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});
	 *
	 * //=linestring1
	 * //=linestring2
	 */
	function lineString(coordinates, properties, options) {
	    if (!coordinates) throw new Error('coordinates is required');
	    if (coordinates.length < 2) throw new Error('coordinates must be an array of two or more positions');
	    // Check if first point of LineString contains two numbers
	    if (!isNumber(coordinates[0][1]) || !isNumber(coordinates[0][1])) throw new Error('coordinates must contain numbers');

	    return feature({
	        type: 'LineString',
	        coordinates: coordinates
	    }, properties, options);
	}

	/**
	 * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.
	 *
	 * @name lineStrings
	 * @param {Array<Array<number>>} coordinates an array of LinearRings
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection
	 * @param {string|number} [options.id] Identifier associated with the FeatureCollection
	 * @returns {FeatureCollection<LineString>} LineString FeatureCollection
	 * @example
	 * var linestrings = turf.lineStrings([
	 *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],
	 *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]
	 * ]);
	 *
	 * //=linestrings
	 */
	function lineStrings(coordinates, properties, options) {
	    if (!coordinates) throw new Error('coordinates is required');
	    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');

	    return featureCollection(coordinates.map(function (coords) {
	        return lineString(coords, properties);
	    }), options);
	}

	/**
	 * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.
	 *
	 * @name featureCollection
	 * @param {Feature[]} features input features
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {FeatureCollection} FeatureCollection of Features
	 * @example
	 * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});
	 * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});
	 * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});
	 *
	 * var collection = turf.featureCollection([
	 *   locationA,
	 *   locationB,
	 *   locationC
	 * ]);
	 *
	 * //=collection
	 */
	function featureCollection(features, options) {
	    // Optional Parameters
	    options = options || {};
	    if (!isObject(options)) throw new Error('options is invalid');
	    var bbox = options.bbox;
	    var id = options.id;

	    // Validation
	    if (!features) throw new Error('No features passed');
	    if (!Array.isArray(features)) throw new Error('features must be an Array');
	    if (bbox) validateBBox(bbox);
	    if (id) validateId(id);

	    // Main
	    var fc = {type: 'FeatureCollection'};
	    if (id) fc.id = id;
	    if (bbox) fc.bbox = bbox;
	    fc.features = features;
	    return fc;
	}

	/**
	 * Creates a {@link Feature<MultiLineString>} based on a
	 * coordinate array. Properties can be added optionally.
	 *
	 * @name multiLineString
	 * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature<MultiLineString>} a MultiLineString feature
	 * @throws {Error} if no coordinates are passed
	 * @example
	 * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);
	 *
	 * //=multiLine
	 */
	function multiLineString(coordinates, properties, options) {
	    if (!coordinates) throw new Error('coordinates is required');

	    return feature({
	        type: 'MultiLineString',
	        coordinates: coordinates
	    }, properties, options);
	}

	/**
	 * Creates a {@link Feature<MultiPoint>} based on a
	 * coordinate array. Properties can be added optionally.
	 *
	 * @name multiPoint
	 * @param {Array<Array<number>>} coordinates an array of Positions
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature<MultiPoint>} a MultiPoint feature
	 * @throws {Error} if no coordinates are passed
	 * @example
	 * var multiPt = turf.multiPoint([[0,0],[10,10]]);
	 *
	 * //=multiPt
	 */
	function multiPoint(coordinates, properties, options) {
	    if (!coordinates) throw new Error('coordinates is required');

	    return feature({
	        type: 'MultiPoint',
	        coordinates: coordinates
	    }, properties, options);
	}

	/**
	 * Creates a {@link Feature<MultiPolygon>} based on a
	 * coordinate array. Properties can be added optionally.
	 *
	 * @name multiPolygon
	 * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature<MultiPolygon>} a multipolygon feature
	 * @throws {Error} if no coordinates are passed
	 * @example
	 * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);
	 *
	 * //=multiPoly
	 *
	 */
	function multiPolygon(coordinates, properties, options) {
	    if (!coordinates) throw new Error('coordinates is required');

	    return feature({
	        type: 'MultiPolygon',
	        coordinates: coordinates
	    }, properties, options);
	}

	/**
	 * Creates a {@link Feature<GeometryCollection>} based on a
	 * coordinate array. Properties can be added optionally.
	 *
	 * @name geometryCollection
	 * @param {Array<Geometry>} geometries an array of GeoJSON Geometries
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature
	 * @example
	 * var pt = {
	 *     "type": "Point",
	 *       "coordinates": [100, 0]
	 *     };
	 * var line = {
	 *     "type": "LineString",
	 *     "coordinates": [ [101, 0], [102, 1] ]
	 *   };
	 * var collection = turf.geometryCollection([pt, line]);
	 *
	 * //=collection
	 */
	function geometryCollection(geometries, properties, options) {
	    if (!geometries) throw new Error('geometries is required');
	    if (!Array.isArray(geometries)) throw new Error('geometries must be an Array');

	    return feature({
	        type: 'GeometryCollection',
	        geometries: geometries
	    }, properties, options);
	}

	/**
	 * Round number to precision
	 *
	 * @param {number} num Number
	 * @param {number} [precision=0] Precision
	 * @returns {number} rounded number
	 * @example
	 * turf.round(120.4321)
	 * //=120
	 *
	 * turf.round(120.4321, 2)
	 * //=120.43
	 */
	function round(num, precision) {
	    if (num === undefined || num === null || isNaN(num)) throw new Error('num is required');
	    if (precision && !(precision >= 0)) throw new Error('precision must be a positive number');
	    var multiplier = Math.pow(10, precision || 0);
	    return Math.round(num * multiplier) / multiplier;
	}

	/**
	 * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.
	 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
	 *
	 * @name radiansToLength
	 * @param {number} radians in radians across the sphere
	 * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.
	 * @returns {number} distance
	 */
	function radiansToLength(radians, units) {
	    if (radians === undefined || radians === null) throw new Error('radians is required');

	    if (units && typeof units !== 'string') throw new Error('units must be a string');
	    var factor = factors[units || 'kilometers'];
	    if (!factor) throw new Error(units + ' units is invalid');
	    return radians * factor;
	}

	/**
	 * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians
	 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
	 *
	 * @name lengthToRadians
	 * @param {number} distance in real units
	 * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.
	 * @returns {number} radians
	 */
	function lengthToRadians(distance, units) {
	    if (distance === undefined || distance === null) throw new Error('distance is required');

	    if (units && typeof units !== 'string') throw new Error('units must be a string');
	    var factor = factors[units || 'kilometers'];
	    if (!factor) throw new Error(units + ' units is invalid');
	    return distance / factor;
	}

	/**
	 * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees
	 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet
	 *
	 * @name lengthToDegrees
	 * @param {number} distance in real units
	 * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.
	 * @returns {number} degrees
	 */
	function lengthToDegrees(distance, units) {
	    return radiansToDegrees(lengthToRadians(distance, units));
	}

	/**
	 * Converts any bearing angle from the north line direction (positive clockwise)
	 * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line
	 *
	 * @name bearingToAzimuth
	 * @param {number} bearing angle, between -180 and +180 degrees
	 * @returns {number} angle between 0 and 360 degrees
	 */
	function bearingToAzimuth(bearing) {
	    if (bearing === null || bearing === undefined) throw new Error('bearing is required');

	    var angle = bearing % 360;
	    if (angle < 0) angle += 360;
	    return angle;
	}

	/**
	 * Converts an angle in radians to degrees
	 *
	 * @name radiansToDegrees
	 * @param {number} radians angle in radians
	 * @returns {number} degrees between 0 and 360 degrees
	 */
	function radiansToDegrees(radians) {
	    if (radians === null || radians === undefined) throw new Error('radians is required');

	    var degrees = radians % (2 * Math.PI);
	    return degrees * 180 / Math.PI;
	}

	/**
	 * Converts an angle in degrees to radians
	 *
	 * @name degreesToRadians
	 * @param {number} degrees angle between 0 and 360 degrees
	 * @returns {number} angle in radians
	 */
	function degreesToRadians(degrees) {
	    if (degrees === null || degrees === undefined) throw new Error('degrees is required');

	    var radians = degrees % 360;
	    return radians * Math.PI / 180;
	}

	/**
	 * Converts a length to the requested unit.
	 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
	 *
	 * @param {number} length to be converted
	 * @param {string} originalUnit of the length
	 * @param {string} [finalUnit='kilometers'] returned unit
	 * @returns {number} the converted length
	 */
	function convertLength(length, originalUnit, finalUnit) {
	    if (length === null || length === undefined) throw new Error('length is required');
	    if (!(length >= 0)) throw new Error('length must be a positive number');

	    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit || 'kilometers');
	}

	/**
	 * Converts a area to the requested unit.
	 * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches
	 * @param {number} area to be converted
	 * @param {string} [originalUnit='meters'] of the distance
	 * @param {string} [finalUnit='kilometers'] returned unit
	 * @returns {number} the converted distance
	 */
	function convertArea(area, originalUnit, finalUnit) {
	    if (area === null || area === undefined) throw new Error('area is required');
	    if (!(area >= 0)) throw new Error('area must be a positive number');

	    var startFactor = areaFactors[originalUnit || 'meters'];
	    if (!startFactor) throw new Error('invalid original units');

	    var finalFactor = areaFactors[finalUnit || 'kilometers'];
	    if (!finalFactor) throw new Error('invalid final units');

	    return (area / startFactor) * finalFactor;
	}

	/**
	 * isNumber
	 *
	 * @param {*} num Number to validate
	 * @returns {boolean} true/false
	 * @example
	 * turf.isNumber(123)
	 * //=true
	 * turf.isNumber('foo')
	 * //=false
	 */
	function isNumber(num) {
	    return !isNaN(num) && num !== null && !Array.isArray(num);
	}

	/**
	 * isObject
	 *
	 * @param {*} input variable to validate
	 * @returns {boolean} true/false
	 * @example
	 * turf.isObject({elevation: 10})
	 * //=true
	 * turf.isObject('foo')
	 * //=false
	 */
	function isObject(input) {
	    return (!!input) && (input.constructor === Object);
	}

	/**
	 * Validate BBox
	 *
	 * @private
	 * @param {Array<number>} bbox BBox to validate
	 * @returns {void}
	 * @throws Error if BBox is not valid
	 * @example
	 * validateBBox([-180, -40, 110, 50])
	 * //=OK
	 * validateBBox([-180, -40])
	 * //=Error
	 * validateBBox('Foo')
	 * //=Error
	 * validateBBox(5)
	 * //=Error
	 * validateBBox(null)
	 * //=Error
	 * validateBBox(undefined)
	 * //=Error
	 */
	function validateBBox(bbox) {
	    if (!bbox) throw new Error('bbox is required');
	    if (!Array.isArray(bbox)) throw new Error('bbox must be an Array');
	    if (bbox.length !== 4 && bbox.length !== 6) throw new Error('bbox must be an Array of 4 or 6 numbers');
	    bbox.forEach(function (num) {
	        if (!isNumber(num)) throw new Error('bbox must only contain numbers');
	    });
	}

	/**
	 * Validate Id
	 *
	 * @private
	 * @param {string|number} id Id to validate
	 * @returns {void}
	 * @throws Error if Id is not valid
	 * @example
	 * validateId([-180, -40, 110, 50])
	 * //=Error
	 * validateId([-180, -40])
	 * //=Error
	 * validateId('Foo')
	 * //=OK
	 * validateId(5)
	 * //=OK
	 * validateId(null)
	 * //=Error
	 * validateId(undefined)
	 * //=Error
	 */
	function validateId(id) {
	    if (!id) throw new Error('id is required');
	    if (['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');
	}

	// Deprecated methods
	function radians2degrees() {
	    throw new Error('method has been renamed to `radiansToDegrees`');
	}

	function degrees2radians() {
	    throw new Error('method has been renamed to `degreesToRadians`');
	}

	function distanceToDegrees() {
	    throw new Error('method has been renamed to `lengthToDegrees`');
	}

	function distanceToRadians() {
	    throw new Error('method has been renamed to `lengthToRadians`');
	}

	function radiansToDistance() {
	    throw new Error('method has been renamed to `radiansToLength`');
	}

	function bearingToAngle() {
	    throw new Error('method has been renamed to `bearingToAzimuth`');
	}

	function convertDistance() {
	    throw new Error('method has been renamed to `convertLength`');
	}

	exports.earthRadius = earthRadius;
	exports.factors = factors;
	exports.unitsFactors = unitsFactors;
	exports.areaFactors = areaFactors;
	exports.feature = feature;
	exports.geometry = geometry;
	exports.point = point;
	exports.points = points;
	exports.polygon = polygon;
	exports.polygons = polygons;
	exports.lineString = lineString;
	exports.lineStrings = lineStrings;
	exports.featureCollection = featureCollection;
	exports.multiLineString = multiLineString;
	exports.multiPoint = multiPoint;
	exports.multiPolygon = multiPolygon;
	exports.geometryCollection = geometryCollection;
	exports.round = round;
	exports.radiansToLength = radiansToLength;
	exports.lengthToRadians = lengthToRadians;
	exports.lengthToDegrees = lengthToDegrees;
	exports.bearingToAzimuth = bearingToAzimuth;
	exports.radiansToDegrees = radiansToDegrees;
	exports.degreesToRadians = degreesToRadians;
	exports.convertLength = convertLength;
	exports.convertArea = convertArea;
	exports.isNumber = isNumber;
	exports.isObject = isObject;
	exports.validateBBox = validateBBox;
	exports.validateId = validateId;
	exports.radians2degrees = radians2degrees;
	exports.degrees2radians = degrees2radians;
	exports.distanceToDegrees = distanceToDegrees;
	exports.distanceToRadians = distanceToRadians;
	exports.radiansToDistance = radiansToDistance;
	exports.bearingToAngle = bearingToAngle;
	exports.convertDistance = convertDistance;
	});

	unwrapExports(main);
	var main_1 = main.earthRadius;
	var main_2 = main.factors;
	var main_3 = main.unitsFactors;
	var main_4 = main.areaFactors;
	var main_5 = main.feature;
	var main_6 = main.geometry;
	var main_7 = main.point;
	var main_8 = main.points;
	var main_9 = main.polygon;
	var main_10 = main.polygons;
	var main_11 = main.lineString;
	var main_12 = main.lineStrings;
	var main_13 = main.featureCollection;
	var main_14 = main.multiLineString;
	var main_15 = main.multiPoint;
	var main_16 = main.multiPolygon;
	var main_17 = main.geometryCollection;
	var main_18 = main.round;
	var main_19 = main.radiansToLength;
	var main_20 = main.lengthToRadians;
	var main_21 = main.lengthToDegrees;
	var main_22 = main.bearingToAzimuth;
	var main_23 = main.radiansToDegrees;
	var main_24 = main.degreesToRadians;
	var main_25 = main.convertLength;
	var main_26 = main.convertArea;
	var main_27 = main.isNumber;
	var main_28 = main.isObject;
	var main_29 = main.validateBBox;
	var main_30 = main.validateId;
	var main_31 = main.radians2degrees;
	var main_32 = main.degrees2radians;
	var main_33 = main.distanceToDegrees;
	var main_34 = main.distanceToRadians;
	var main_35 = main.radiansToDistance;
	var main_36 = main.bearingToAngle;
	var main_37 = main.convertDistance;

	var main$1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, '__esModule', { value: true });



	/**
	 * Callback for coordEach
	 *
	 * @callback coordEachCallback
	 * @param {Array<number>} currentCoord The current coordinate being processed.
	 * @param {number} coordIndex The current index of the coordinate being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
	 * @param {number} geometryIndex The current index of the Geometry being processed.
	 */

	/**
	 * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()
	 *
	 * @name coordEach
	 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
	 * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)
	 * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.
	 * @returns {void}
	 * @example
	 * var features = turf.featureCollection([
	 *   turf.point([26, 37], {"foo": "bar"}),
	 *   turf.point([36, 53], {"hello": "world"})
	 * ]);
	 *
	 * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
	 *   //=currentCoord
	 *   //=coordIndex
	 *   //=featureIndex
	 *   //=multiFeatureIndex
	 *   //=geometryIndex
	 * });
	 */
	function coordEach(geojson, callback, excludeWrapCoord) {
	    // Handles null Geometry -- Skips this GeoJSON
	    if (geojson === null) return;
	    var j, k, l, geometry, stopG, coords,
	        geometryMaybeCollection,
	        wrapShrink = 0,
	        coordIndex = 0,
	        isGeometryCollection,
	        type = geojson.type,
	        isFeatureCollection = type === 'FeatureCollection',
	        isFeature = type === 'Feature',
	        stop = isFeatureCollection ? geojson.features.length : 1;

	    // This logic may look a little weird. The reason why it is that way
	    // is because it's trying to be fast. GeoJSON supports multiple kinds
	    // of objects at its root: FeatureCollection, Features, Geometries.
	    // This function has the responsibility of handling all of them, and that
	    // means that some of the `for` loops you see below actually just don't apply
	    // to certain inputs. For instance, if you give this just a
	    // Point geometry, then both loops are short-circuited and all we do
	    // is gradually rename the input until it's called 'geometry'.
	    //
	    // This also aims to allocate as few resources as possible: just a
	    // few numbers and booleans, rather than any temporary arrays as would
	    // be required with the normalization approach.
	    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {
	        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :
	            (isFeature ? geojson.geometry : geojson));
	        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;
	        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

	        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {
	            var multiFeatureIndex = 0;
	            var geometryIndex = 0;
	            geometry = isGeometryCollection ?
	                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;

	            // Handles null Geometry -- Skips this geometry
	            if (geometry === null) continue;
	            coords = geometry.coordinates;
	            var geomType = geometry.type;

	            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;

	            switch (geomType) {
	            case null:
	                break;
	            case 'Point':
	                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
	                coordIndex++;
	                multiFeatureIndex++;
	                break;
	            case 'LineString':
	            case 'MultiPoint':
	                for (j = 0; j < coords.length; j++) {
	                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
	                    coordIndex++;
	                    if (geomType === 'MultiPoint') multiFeatureIndex++;
	                }
	                if (geomType === 'LineString') multiFeatureIndex++;
	                break;
	            case 'Polygon':
	            case 'MultiLineString':
	                for (j = 0; j < coords.length; j++) {
	                    for (k = 0; k < coords[j].length - wrapShrink; k++) {
	                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
	                        coordIndex++;
	                    }
	                    if (geomType === 'MultiLineString') multiFeatureIndex++;
	                    if (geomType === 'Polygon') geometryIndex++;
	                }
	                if (geomType === 'Polygon') multiFeatureIndex++;
	                break;
	            case 'MultiPolygon':
	                for (j = 0; j < coords.length; j++) {
	                    if (geomType === 'MultiPolygon') geometryIndex = 0;
	                    for (k = 0; k < coords[j].length; k++) {
	                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
	                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
	                            coordIndex++;
	                        }
	                        geometryIndex++;
	                    }
	                    multiFeatureIndex++;
	                }
	                break;
	            case 'GeometryCollection':
	                for (j = 0; j < geometry.geometries.length; j++)
	                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;
	                break;
	            default:
	                throw new Error('Unknown Geometry Type');
	            }
	        }
	    }
	}

	/**
	 * Callback for coordReduce
	 *
	 * The first time the callback function is called, the values provided as arguments depend
	 * on whether the reduce method has an initialValue argument.
	 *
	 * If an initialValue is provided to the reduce method:
	 *  - The previousValue argument is initialValue.
	 *  - The currentValue argument is the value of the first element present in the array.
	 *
	 * If an initialValue is not provided:
	 *  - The previousValue argument is the value of the first element present in the array.
	 *  - The currentValue argument is the value of the second element present in the array.
	 *
	 * @callback coordReduceCallback
	 * @param {*} previousValue The accumulated value previously returned in the last invocation
	 * of the callback, or initialValue, if supplied.
	 * @param {Array<number>} currentCoord The current coordinate being processed.
	 * @param {number} coordIndex The current index of the coordinate being processed.
	 * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
	 * @param {number} geometryIndex The current index of the Geometry being processed.
	 */

	/**
	 * Reduce coordinates in any GeoJSON object, similar to Array.reduce()
	 *
	 * @name coordReduce
	 * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object
	 * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)
	 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
	 * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.
	 * @returns {*} The value that results from the reduction.
	 * @example
	 * var features = turf.featureCollection([
	 *   turf.point([26, 37], {"foo": "bar"}),
	 *   turf.point([36, 53], {"hello": "world"})
	 * ]);
	 *
	 * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
	 *   //=previousValue
	 *   //=currentCoord
	 *   //=coordIndex
	 *   //=featureIndex
	 *   //=multiFeatureIndex
	 *   //=geometryIndex
	 *   return currentCoord;
	 * });
	 */
	function coordReduce(geojson, callback, initialValue, excludeWrapCoord) {
	    var previousValue = initialValue;
	    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
	        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;
	        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);
	    }, excludeWrapCoord);
	    return previousValue;
	}

	/**
	 * Callback for propEach
	 *
	 * @callback propEachCallback
	 * @param {Object} currentProperties The current Properties being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 */

	/**
	 * Iterate over properties in any GeoJSON object, similar to Array.forEach()
	 *
	 * @name propEach
	 * @param {FeatureCollection|Feature} geojson any GeoJSON object
	 * @param {Function} callback a method that takes (currentProperties, featureIndex)
	 * @returns {void}
	 * @example
	 * var features = turf.featureCollection([
	 *     turf.point([26, 37], {foo: 'bar'}),
	 *     turf.point([36, 53], {hello: 'world'})
	 * ]);
	 *
	 * turf.propEach(features, function (currentProperties, featureIndex) {
	 *   //=currentProperties
	 *   //=featureIndex
	 * });
	 */
	function propEach(geojson, callback) {
	    var i;
	    switch (geojson.type) {
	    case 'FeatureCollection':
	        for (i = 0; i < geojson.features.length; i++) {
	            if (callback(geojson.features[i].properties, i) === false) break;
	        }
	        break;
	    case 'Feature':
	        callback(geojson.properties, 0);
	        break;
	    }
	}


	/**
	 * Callback for propReduce
	 *
	 * The first time the callback function is called, the values provided as arguments depend
	 * on whether the reduce method has an initialValue argument.
	 *
	 * If an initialValue is provided to the reduce method:
	 *  - The previousValue argument is initialValue.
	 *  - The currentValue argument is the value of the first element present in the array.
	 *
	 * If an initialValue is not provided:
	 *  - The previousValue argument is the value of the first element present in the array.
	 *  - The currentValue argument is the value of the second element present in the array.
	 *
	 * @callback propReduceCallback
	 * @param {*} previousValue The accumulated value previously returned in the last invocation
	 * of the callback, or initialValue, if supplied.
	 * @param {*} currentProperties The current Properties being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 */

	/**
	 * Reduce properties in any GeoJSON object into a single value,
	 * similar to how Array.reduce works. However, in this case we lazily run
	 * the reduction, so an array of all properties is unnecessary.
	 *
	 * @name propReduce
	 * @param {FeatureCollection|Feature} geojson any GeoJSON object
	 * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)
	 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
	 * @returns {*} The value that results from the reduction.
	 * @example
	 * var features = turf.featureCollection([
	 *     turf.point([26, 37], {foo: 'bar'}),
	 *     turf.point([36, 53], {hello: 'world'})
	 * ]);
	 *
	 * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {
	 *   //=previousValue
	 *   //=currentProperties
	 *   //=featureIndex
	 *   return currentProperties
	 * });
	 */
	function propReduce(geojson, callback, initialValue) {
	    var previousValue = initialValue;
	    propEach(geojson, function (currentProperties, featureIndex) {
	        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;
	        else previousValue = callback(previousValue, currentProperties, featureIndex);
	    });
	    return previousValue;
	}

	/**
	 * Callback for featureEach
	 *
	 * @callback featureEachCallback
	 * @param {Feature<any>} currentFeature The current Feature being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 */

	/**
	 * Iterate over features in any GeoJSON object, similar to
	 * Array.forEach.
	 *
	 * @name featureEach
	 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
	 * @param {Function} callback a method that takes (currentFeature, featureIndex)
	 * @returns {void}
	 * @example
	 * var features = turf.featureCollection([
	 *   turf.point([26, 37], {foo: 'bar'}),
	 *   turf.point([36, 53], {hello: 'world'})
	 * ]);
	 *
	 * turf.featureEach(features, function (currentFeature, featureIndex) {
	 *   //=currentFeature
	 *   //=featureIndex
	 * });
	 */
	function featureEach(geojson, callback) {
	    if (geojson.type === 'Feature') {
	        callback(geojson, 0);
	    } else if (geojson.type === 'FeatureCollection') {
	        for (var i = 0; i < geojson.features.length; i++) {
	            if (callback(geojson.features[i], i) === false) break;
	        }
	    }
	}

	/**
	 * Callback for featureReduce
	 *
	 * The first time the callback function is called, the values provided as arguments depend
	 * on whether the reduce method has an initialValue argument.
	 *
	 * If an initialValue is provided to the reduce method:
	 *  - The previousValue argument is initialValue.
	 *  - The currentValue argument is the value of the first element present in the array.
	 *
	 * If an initialValue is not provided:
	 *  - The previousValue argument is the value of the first element present in the array.
	 *  - The currentValue argument is the value of the second element present in the array.
	 *
	 * @callback featureReduceCallback
	 * @param {*} previousValue The accumulated value previously returned in the last invocation
	 * of the callback, or initialValue, if supplied.
	 * @param {Feature} currentFeature The current Feature being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 */

	/**
	 * Reduce features in any GeoJSON object, similar to Array.reduce().
	 *
	 * @name featureReduce
	 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
	 * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)
	 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
	 * @returns {*} The value that results from the reduction.
	 * @example
	 * var features = turf.featureCollection([
	 *   turf.point([26, 37], {"foo": "bar"}),
	 *   turf.point([36, 53], {"hello": "world"})
	 * ]);
	 *
	 * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {
	 *   //=previousValue
	 *   //=currentFeature
	 *   //=featureIndex
	 *   return currentFeature
	 * });
	 */
	function featureReduce(geojson, callback, initialValue) {
	    var previousValue = initialValue;
	    featureEach(geojson, function (currentFeature, featureIndex) {
	        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;
	        else previousValue = callback(previousValue, currentFeature, featureIndex);
	    });
	    return previousValue;
	}

	/**
	 * Get all coordinates from any GeoJSON object.
	 *
	 * @name coordAll
	 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
	 * @returns {Array<Array<number>>} coordinate position array
	 * @example
	 * var features = turf.featureCollection([
	 *   turf.point([26, 37], {foo: 'bar'}),
	 *   turf.point([36, 53], {hello: 'world'})
	 * ]);
	 *
	 * var coords = turf.coordAll(features);
	 * //= [[26, 37], [36, 53]]
	 */
	function coordAll(geojson) {
	    var coords = [];
	    coordEach(geojson, function (coord) {
	        coords.push(coord);
	    });
	    return coords;
	}

	/**
	 * Callback for geomEach
	 *
	 * @callback geomEachCallback
	 * @param {Geometry} currentGeometry The current Geometry being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 * @param {Object} featureProperties The current Feature Properties being processed.
	 * @param {Array<number>} featureBBox The current Feature BBox being processed.
	 * @param {number|string} featureId The current Feature Id being processed.
	 */

	/**
	 * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()
	 *
	 * @name geomEach
	 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
	 * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)
	 * @returns {void}
	 * @example
	 * var features = turf.featureCollection([
	 *     turf.point([26, 37], {foo: 'bar'}),
	 *     turf.point([36, 53], {hello: 'world'})
	 * ]);
	 *
	 * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
	 *   //=currentGeometry
	 *   //=featureIndex
	 *   //=featureProperties
	 *   //=featureBBox
	 *   //=featureId
	 * });
	 */
	function geomEach(geojson, callback) {
	    var i, j, g, geometry, stopG,
	        geometryMaybeCollection,
	        isGeometryCollection,
	        featureProperties,
	        featureBBox,
	        featureId,
	        featureIndex = 0,
	        isFeatureCollection = geojson.type === 'FeatureCollection',
	        isFeature = geojson.type === 'Feature',
	        stop = isFeatureCollection ? geojson.features.length : 1;

	    // This logic may look a little weird. The reason why it is that way
	    // is because it's trying to be fast. GeoJSON supports multiple kinds
	    // of objects at its root: FeatureCollection, Features, Geometries.
	    // This function has the responsibility of handling all of them, and that
	    // means that some of the `for` loops you see below actually just don't apply
	    // to certain inputs. For instance, if you give this just a
	    // Point geometry, then both loops are short-circuited and all we do
	    // is gradually rename the input until it's called 'geometry'.
	    //
	    // This also aims to allocate as few resources as possible: just a
	    // few numbers and booleans, rather than any temporary arrays as would
	    // be required with the normalization approach.
	    for (i = 0; i < stop; i++) {

	        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :
	            (isFeature ? geojson.geometry : geojson));
	        featureProperties = (isFeatureCollection ? geojson.features[i].properties :
	            (isFeature ? geojson.properties : {}));
	        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :
	            (isFeature ? geojson.bbox : undefined));
	        featureId = (isFeatureCollection ? geojson.features[i].id :
	            (isFeature ? geojson.id : undefined));
	        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;
	        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

	        for (g = 0; g < stopG; g++) {
	            geometry = isGeometryCollection ?
	                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;

	            // Handle null Geometry
	            if (geometry === null) {
	                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;
	                continue;
	            }
	            switch (geometry.type) {
	            case 'Point':
	            case 'LineString':
	            case 'MultiPoint':
	            case 'Polygon':
	            case 'MultiLineString':
	            case 'MultiPolygon': {
	                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;
	                break;
	            }
	            case 'GeometryCollection': {
	                for (j = 0; j < geometry.geometries.length; j++) {
	                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;
	                }
	                break;
	            }
	            default:
	                throw new Error('Unknown Geometry Type');
	            }
	        }
	        // Only increase `featureIndex` per each feature
	        featureIndex++;
	    }
	}

	/**
	 * Callback for geomReduce
	 *
	 * The first time the callback function is called, the values provided as arguments depend
	 * on whether the reduce method has an initialValue argument.
	 *
	 * If an initialValue is provided to the reduce method:
	 *  - The previousValue argument is initialValue.
	 *  - The currentValue argument is the value of the first element present in the array.
	 *
	 * If an initialValue is not provided:
	 *  - The previousValue argument is the value of the first element present in the array.
	 *  - The currentValue argument is the value of the second element present in the array.
	 *
	 * @callback geomReduceCallback
	 * @param {*} previousValue The accumulated value previously returned in the last invocation
	 * of the callback, or initialValue, if supplied.
	 * @param {Geometry} currentGeometry The current Geometry being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 * @param {Object} featureProperties The current Feature Properties being processed.
	 * @param {Array<number>} featureBBox The current Feature BBox being processed.
	 * @param {number|string} featureId The current Feature Id being processed.
	 */

	/**
	 * Reduce geometry in any GeoJSON object, similar to Array.reduce().
	 *
	 * @name geomReduce
	 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
	 * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)
	 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
	 * @returns {*} The value that results from the reduction.
	 * @example
	 * var features = turf.featureCollection([
	 *     turf.point([26, 37], {foo: 'bar'}),
	 *     turf.point([36, 53], {hello: 'world'})
	 * ]);
	 *
	 * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
	 *   //=previousValue
	 *   //=currentGeometry
	 *   //=featureIndex
	 *   //=featureProperties
	 *   //=featureBBox
	 *   //=featureId
	 *   return currentGeometry
	 * });
	 */
	function geomReduce(geojson, callback, initialValue) {
	    var previousValue = initialValue;
	    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
	        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;
	        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);
	    });
	    return previousValue;
	}

	/**
	 * Callback for flattenEach
	 *
	 * @callback flattenEachCallback
	 * @param {Feature} currentFeature The current flattened feature being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
	 */

	/**
	 * Iterate over flattened features in any GeoJSON object, similar to
	 * Array.forEach.
	 *
	 * @name flattenEach
	 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
	 * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)
	 * @example
	 * var features = turf.featureCollection([
	 *     turf.point([26, 37], {foo: 'bar'}),
	 *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})
	 * ]);
	 *
	 * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {
	 *   //=currentFeature
	 *   //=featureIndex
	 *   //=multiFeatureIndex
	 * });
	 */
	function flattenEach(geojson, callback) {
	    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {
	        // Callback for single geometry
	        var type = (geometry === null) ? null : geometry.type;
	        switch (type) {
	        case null:
	        case 'Point':
	        case 'LineString':
	        case 'Polygon':
	            if (callback(main.feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;
	            return;
	        }

	        var geomType;

	        // Callback for multi-geometry
	        switch (type) {
	        case 'MultiPoint':
	            geomType = 'Point';
	            break;
	        case 'MultiLineString':
	            geomType = 'LineString';
	            break;
	        case 'MultiPolygon':
	            geomType = 'Polygon';
	            break;
	        }

	        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {
	            var coordinate = geometry.coordinates[multiFeatureIndex];
	            var geom = {
	                type: geomType,
	                coordinates: coordinate
	            };
	            if (callback(main.feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;
	        }
	    });
	}

	/**
	 * Callback for flattenReduce
	 *
	 * The first time the callback function is called, the values provided as arguments depend
	 * on whether the reduce method has an initialValue argument.
	 *
	 * If an initialValue is provided to the reduce method:
	 *  - The previousValue argument is initialValue.
	 *  - The currentValue argument is the value of the first element present in the array.
	 *
	 * If an initialValue is not provided:
	 *  - The previousValue argument is the value of the first element present in the array.
	 *  - The currentValue argument is the value of the second element present in the array.
	 *
	 * @callback flattenReduceCallback
	 * @param {*} previousValue The accumulated value previously returned in the last invocation
	 * of the callback, or initialValue, if supplied.
	 * @param {Feature} currentFeature The current Feature being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
	 */

	/**
	 * Reduce flattened features in any GeoJSON object, similar to Array.reduce().
	 *
	 * @name flattenReduce
	 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
	 * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)
	 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
	 * @returns {*} The value that results from the reduction.
	 * @example
	 * var features = turf.featureCollection([
	 *     turf.point([26, 37], {foo: 'bar'}),
	 *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})
	 * ]);
	 *
	 * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {
	 *   //=previousValue
	 *   //=currentFeature
	 *   //=featureIndex
	 *   //=multiFeatureIndex
	 *   return currentFeature
	 * });
	 */
	function flattenReduce(geojson, callback, initialValue) {
	    var previousValue = initialValue;
	    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {
	        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;
	        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);
	    });
	    return previousValue;
	}

	/**
	 * Callback for segmentEach
	 *
	 * @callback segmentEachCallback
	 * @param {Feature<LineString>} currentSegment The current Segment being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
	 * @param {number} geometryIndex The current index of the Geometry being processed.
	 * @param {number} segmentIndex The current index of the Segment being processed.
	 * @returns {void}
	 */

	/**
	 * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()
	 * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
	 *
	 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON
	 * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)
	 * @returns {void}
	 * @example
	 * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
	 *
	 * // Iterate over GeoJSON by 2-vertex segments
	 * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
	 *   //=currentSegment
	 *   //=featureIndex
	 *   //=multiFeatureIndex
	 *   //=geometryIndex
	 *   //=segmentIndex
	 * });
	 *
	 * // Calculate the total number of segments
	 * var total = 0;
	 * turf.segmentEach(polygon, function () {
	 *     total++;
	 * });
	 */
	function segmentEach(geojson, callback) {
	    flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {
	        var segmentIndex = 0;

	        // Exclude null Geometries
	        if (!feature$$1.geometry) return;
	        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
	        var type = feature$$1.geometry.type;
	        if (type === 'Point' || type === 'MultiPoint') return;

	        // Generate 2-vertex line segments
	        var previousCoords;
	        if (coordEach(feature$$1, function (currentCoord, coordIndex, featureIndexCoord, mutliPartIndexCoord, geometryIndex) {
	            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`
	            if (previousCoords === undefined) {
	                previousCoords = currentCoord;
	                return;
	            }
	            var currentSegment = main.lineString([previousCoords, currentCoord], feature$$1.properties);
	            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;
	            segmentIndex++;
	            previousCoords = currentCoord;
	        }) === false) return false;
	    });
	}

	/**
	 * Callback for segmentReduce
	 *
	 * The first time the callback function is called, the values provided as arguments depend
	 * on whether the reduce method has an initialValue argument.
	 *
	 * If an initialValue is provided to the reduce method:
	 *  - The previousValue argument is initialValue.
	 *  - The currentValue argument is the value of the first element present in the array.
	 *
	 * If an initialValue is not provided:
	 *  - The previousValue argument is the value of the first element present in the array.
	 *  - The currentValue argument is the value of the second element present in the array.
	 *
	 * @callback segmentReduceCallback
	 * @param {*} previousValue The accumulated value previously returned in the last invocation
	 * of the callback, or initialValue, if supplied.
	 * @param {Feature<LineString>} currentSegment The current Segment being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
	 * @param {number} geometryIndex The current index of the Geometry being processed.
	 * @param {number} segmentIndex The current index of the Segment being processed.
	 */

	/**
	 * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()
	 * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
	 *
	 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON
	 * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)
	 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
	 * @returns {void}
	 * @example
	 * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
	 *
	 * // Iterate over GeoJSON by 2-vertex segments
	 * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
	 *   //= previousSegment
	 *   //= currentSegment
	 *   //= featureIndex
	 *   //= multiFeatureIndex
	 *   //= geometryIndex
	 *   //= segmentInex
	 *   return currentSegment
	 * });
	 *
	 * // Calculate the total number of segments
	 * var initialValue = 0
	 * var total = turf.segmentReduce(polygon, function (previousValue) {
	 *     previousValue++;
	 *     return previousValue;
	 * }, initialValue);
	 */
	function segmentReduce(geojson, callback, initialValue) {
	    var previousValue = initialValue;
	    var started = false;
	    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
	        if (started === false && initialValue === undefined) previousValue = currentSegment;
	        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);
	        started = true;
	    });
	    return previousValue;
	}

	/**
	 * Callback for lineEach
	 *
	 * @callback lineEachCallback
	 * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed
	 * @param {number} featureIndex The current index of the Feature being processed
	 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed
	 * @param {number} geometryIndex The current index of the Geometry being processed
	 */

	/**
	 * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,
	 * similar to Array.forEach.
	 *
	 * @name lineEach
	 * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object
	 * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)
	 * @example
	 * var multiLine = turf.multiLineString([
	 *   [[26, 37], [35, 45]],
	 *   [[36, 53], [38, 50], [41, 55]]
	 * ]);
	 *
	 * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
	 *   //=currentLine
	 *   //=featureIndex
	 *   //=multiFeatureIndex
	 *   //=geometryIndex
	 * });
	 */
	function lineEach(geojson, callback) {
	    // validation
	    if (!geojson) throw new Error('geojson is required');

	    flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {
	        if (feature$$1.geometry === null) return;
	        var type = feature$$1.geometry.type;
	        var coords = feature$$1.geometry.coordinates;
	        switch (type) {
	        case 'LineString':
	            if (callback(feature$$1, featureIndex, multiFeatureIndex, 0, 0) === false) return false;
	            break;
	        case 'Polygon':
	            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {
	                if (callback(main.lineString(coords[geometryIndex], feature$$1.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
	            }
	            break;
	        }
	    });
	}

	/**
	 * Callback for lineReduce
	 *
	 * The first time the callback function is called, the values provided as arguments depend
	 * on whether the reduce method has an initialValue argument.
	 *
	 * If an initialValue is provided to the reduce method:
	 *  - The previousValue argument is initialValue.
	 *  - The currentValue argument is the value of the first element present in the array.
	 *
	 * If an initialValue is not provided:
	 *  - The previousValue argument is the value of the first element present in the array.
	 *  - The currentValue argument is the value of the second element present in the array.
	 *
	 * @callback lineReduceCallback
	 * @param {*} previousValue The accumulated value previously returned in the last invocation
	 * of the callback, or initialValue, if supplied.
	 * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.
	 * @param {number} featureIndex The current index of the Feature being processed
	 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed
	 * @param {number} geometryIndex The current index of the Geometry being processed
	 */

	/**
	 * Reduce features in any GeoJSON object, similar to Array.reduce().
	 *
	 * @name lineReduce
	 * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object
	 * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)
	 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
	 * @returns {*} The value that results from the reduction.
	 * @example
	 * var multiPoly = turf.multiPolygon([
	 *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),
	 *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])
	 * ]);
	 *
	 * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
	 *   //=previousValue
	 *   //=currentLine
	 *   //=featureIndex
	 *   //=multiFeatureIndex
	 *   //=geometryIndex
	 *   return currentLine
	 * });
	 */
	function lineReduce(geojson, callback, initialValue) {
	    var previousValue = initialValue;
	    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
	        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;
	        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);
	    });
	    return previousValue;
	}

	/**
	 * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.
	 *
	 * Negative indexes are permitted.
	 * Point & MultiPoint will always return null.
	 *
	 * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry
	 * @param {Object} [options={}] Optional parameters
	 * @param {number} [options.featureIndex=0] Feature Index
	 * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index
	 * @param {number} [options.geometryIndex=0] Geometry Index
	 * @param {number} [options.segmentIndex=0] Segment Index
	 * @param {Object} [options.properties={}] Translate Properties to output LineString
	 * @param {BBox} [options.bbox={}] Translate BBox to output LineString
	 * @param {number|string} [options.id={}] Translate Id to output LineString
	 * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString
	 * @example
	 * var multiLine = turf.multiLineString([
	 *     [[10, 10], [50, 30], [30, 40]],
	 *     [[-10, -10], [-50, -30], [-30, -40]]
	 * ]);
	 *
	 * // First Segment (defaults are 0)
	 * turf.findSegment(multiLine);
	 * // => Feature<LineString<[[10, 10], [50, 30]]>>
	 *
	 * // First Segment of 2nd Multi Feature
	 * turf.findSegment(multiLine, {multiFeatureIndex: 1});
	 * // => Feature<LineString<[[-10, -10], [-50, -30]]>>
	 *
	 * // Last Segment of Last Multi Feature
	 * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});
	 * // => Feature<LineString<[[-50, -30], [-30, -40]]>>
	 */
	function findSegment(geojson, options) {
	    // Optional Parameters
	    options = options || {};
	    if (!main.isObject(options)) throw new Error('options is invalid');
	    var featureIndex = options.featureIndex || 0;
	    var multiFeatureIndex = options.multiFeatureIndex || 0;
	    var geometryIndex = options.geometryIndex || 0;
	    var segmentIndex = options.segmentIndex || 0;

	    // Find FeatureIndex
	    var properties = options.properties;
	    var geometry;

	    switch (geojson.type) {
	    case 'FeatureCollection':
	        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;
	        properties = properties || geojson.features[featureIndex].properties;
	        geometry = geojson.features[featureIndex].geometry;
	        break;
	    case 'Feature':
	        properties = properties || geojson.properties;
	        geometry = geojson.geometry;
	        break;
	    case 'Point':
	    case 'MultiPoint':
	        return null;
	    case 'LineString':
	    case 'Polygon':
	    case 'MultiLineString':
	    case 'MultiPolygon':
	        geometry = geojson;
	        break;
	    default:
	        throw new Error('geojson is invalid');
	    }

	    // Find SegmentIndex
	    if (geometry === null) return null;
	    var coords = geometry.coordinates;
	    switch (geometry.type) {
	    case 'Point':
	    case 'MultiPoint':
	        return null;
	    case 'LineString':
	        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;
	        return main.lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);
	    case 'Polygon':
	        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;
	        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;
	        return main.lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);
	    case 'MultiLineString':
	        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
	        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;
	        return main.lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);
	    case 'MultiPolygon':
	        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
	        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
	        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;
	        return main.lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);
	    }
	    throw new Error('geojson is invalid');
	}

	/**
	 * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.
	 *
	 * Negative indexes are permitted.
	 *
	 * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry
	 * @param {Object} [options={}] Optional parameters
	 * @param {number} [options.featureIndex=0] Feature Index
	 * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index
	 * @param {number} [options.geometryIndex=0] Geometry Index
	 * @param {number} [options.coordIndex=0] Coord Index
	 * @param {Object} [options.properties={}] Translate Properties to output Point
	 * @param {BBox} [options.bbox={}] Translate BBox to output Point
	 * @param {number|string} [options.id={}] Translate Id to output Point
	 * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point
	 * @example
	 * var multiLine = turf.multiLineString([
	 *     [[10, 10], [50, 30], [30, 40]],
	 *     [[-10, -10], [-50, -30], [-30, -40]]
	 * ]);
	 *
	 * // First Segment (defaults are 0)
	 * turf.findPoint(multiLine);
	 * // => Feature<Point<[10, 10]>>
	 *
	 * // First Segment of the 2nd Multi-Feature
	 * turf.findPoint(multiLine, {multiFeatureIndex: 1});
	 * // => Feature<Point<[-10, -10]>>
	 *
	 * // Last Segment of last Multi-Feature
	 * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});
	 * // => Feature<Point<[-30, -40]>>
	 */
	function findPoint(geojson, options) {
	    // Optional Parameters
	    options = options || {};
	    if (!main.isObject(options)) throw new Error('options is invalid');
	    var featureIndex = options.featureIndex || 0;
	    var multiFeatureIndex = options.multiFeatureIndex || 0;
	    var geometryIndex = options.geometryIndex || 0;
	    var coordIndex = options.coordIndex || 0;

	    // Find FeatureIndex
	    var properties = options.properties;
	    var geometry;

	    switch (geojson.type) {
	    case 'FeatureCollection':
	        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;
	        properties = properties || geojson.features[featureIndex].properties;
	        geometry = geojson.features[featureIndex].geometry;
	        break;
	    case 'Feature':
	        properties = properties || geojson.properties;
	        geometry = geojson.geometry;
	        break;
	    case 'Point':
	    case 'MultiPoint':
	        return null;
	    case 'LineString':
	    case 'Polygon':
	    case 'MultiLineString':
	    case 'MultiPolygon':
	        geometry = geojson;
	        break;
	    default:
	        throw new Error('geojson is invalid');
	    }

	    // Find Coord Index
	    if (geometry === null) return null;
	    var coords = geometry.coordinates;
	    switch (geometry.type) {
	    case 'Point':
	        return main.point(coords, properties, options);
	    case 'MultiPoint':
	        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
	        return main.point(coords[multiFeatureIndex], properties, options);
	    case 'LineString':
	        if (coordIndex < 0) coordIndex = coords.length + coordIndex;
	        return main.point(coords[coordIndex], properties, options);
	    case 'Polygon':
	        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;
	        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;
	        return main.point(coords[geometryIndex][coordIndex], properties, options);
	    case 'MultiLineString':
	        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
	        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;
	        return main.point(coords[multiFeatureIndex][coordIndex], properties, options);
	    case 'MultiPolygon':
	        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
	        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
	        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;
	        return main.point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);
	    }
	    throw new Error('geojson is invalid');
	}

	exports.coordEach = coordEach;
	exports.coordReduce = coordReduce;
	exports.propEach = propEach;
	exports.propReduce = propReduce;
	exports.featureEach = featureEach;
	exports.featureReduce = featureReduce;
	exports.coordAll = coordAll;
	exports.geomEach = geomEach;
	exports.geomReduce = geomReduce;
	exports.flattenEach = flattenEach;
	exports.flattenReduce = flattenReduce;
	exports.segmentEach = segmentEach;
	exports.segmentReduce = segmentReduce;
	exports.lineEach = lineEach;
	exports.lineReduce = lineReduce;
	exports.findSegment = findSegment;
	exports.findPoint = findPoint;
	});

	unwrapExports(main$1);
	var main_1$1 = main$1.coordEach;
	var main_2$1 = main$1.coordReduce;
	var main_3$1 = main$1.propEach;
	var main_4$1 = main$1.propReduce;
	var main_5$1 = main$1.featureEach;
	var main_6$1 = main$1.featureReduce;
	var main_7$1 = main$1.coordAll;
	var main_8$1 = main$1.geomEach;
	var main_9$1 = main$1.geomReduce;
	var main_10$1 = main$1.flattenEach;
	var main_11$1 = main$1.flattenReduce;
	var main_12$1 = main$1.segmentEach;
	var main_13$1 = main$1.segmentReduce;
	var main_14$1 = main$1.lineEach;
	var main_15$1 = main$1.lineReduce;
	var main_16$1 = main$1.findSegment;
	var main_17$1 = main$1.findPoint;

	/**
	 * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.
	 *
	 * @name bbox
	 * @param {GeoJSON} geojson any GeoJSON object
	 * @returns {BBox} bbox extent in [minX, minY, maxX, maxY] order
	 * @example
	 * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);
	 * var bbox = turf.bbox(line);
	 * var bboxPolygon = turf.bboxPolygon(bbox);
	 *
	 * //addToMap
	 * var addToMap = [line, bboxPolygon]
	 */
	function bbox(geojson) {
	    var BBox = [Infinity, Infinity, -Infinity, -Infinity];
	    main$1.coordEach(geojson, function (coord) {
	        if (BBox[0] > coord[0]) BBox[0] = coord[0];
	        if (BBox[1] > coord[1]) BBox[1] = coord[1];
	        if (BBox[2] < coord[0]) BBox[2] = coord[0];
	        if (BBox[3] < coord[1]) BBox[3] = coord[1];
	    });
	    return BBox;
	}

	var main$2 = bbox;
	var default_1 = bbox;
	main$2.default = default_1;

	var main$3 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, '__esModule', { value: true });

	/**
	 * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.
	 */
	var earthRadius = 6371008.8;

	/**
	 * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.
	 */
	var factors = {
	    meters: earthRadius,
	    metres: earthRadius,
	    millimeters: earthRadius * 1000,
	    millimetres: earthRadius * 1000,
	    centimeters: earthRadius * 100,
	    centimetres: earthRadius * 100,
	    kilometers: earthRadius / 1000,
	    kilometres: earthRadius / 1000,
	    miles: earthRadius / 1609.344,
	    nauticalmiles: earthRadius / 1852,
	    inches: earthRadius * 39.370,
	    yards: earthRadius / 1.0936,
	    feet: earthRadius * 3.28084,
	    radians: 1,
	    degrees: earthRadius / 111325,
	};

	/**
	 * Units of measurement factors based on 1 meter.
	 */
	var unitsFactors = {
	    meters: 1,
	    metres: 1,
	    millimeters: 1000,
	    millimetres: 1000,
	    centimeters: 100,
	    centimetres: 100,
	    kilometers: 1 / 1000,
	    kilometres: 1 / 1000,
	    miles: 1 / 1609.344,
	    nauticalmiles: 1 / 1852,
	    inches: 39.370,
	    yards: 1 / 1.0936,
	    feet: 3.28084,
	    radians: 1 / earthRadius,
	    degrees: 1 / 111325,
	};

	/**
	 * Area of measurement factors based on 1 square meter.
	 */
	var areaFactors = {
	    meters: 1,
	    metres: 1,
	    millimeters: 1000000,
	    millimetres: 1000000,
	    centimeters: 10000,
	    centimetres: 10000,
	    kilometers: 0.000001,
	    kilometres: 0.000001,
	    acres: 0.000247105,
	    miles: 3.86e-7,
	    yards: 1.195990046,
	    feet: 10.763910417,
	    inches: 1550.003100006
	};

	/**
	 * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.
	 *
	 * @name feature
	 * @param {Geometry} geometry input geometry
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature} a GeoJSON Feature
	 * @example
	 * var geometry = {
	 *   "type": "Point",
	 *   "coordinates": [110, 50]
	 * };
	 *
	 * var feature = turf.feature(geometry);
	 *
	 * //=feature
	 */
	function feature(geometry, properties, options) {
	    // Optional Parameters
	    options = options || {};
	    if (!isObject(options)) throw new Error('options is invalid');
	    var bbox = options.bbox;
	    var id = options.id;

	    // Validation
	    if (geometry === undefined) throw new Error('geometry is required');
	    if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');
	    if (bbox) validateBBox(bbox);
	    if (id) validateId(id);

	    // Main
	    var feat = {type: 'Feature'};
	    if (id) feat.id = id;
	    if (bbox) feat.bbox = bbox;
	    feat.properties = properties || {};
	    feat.geometry = geometry;
	    return feat;
	}

	/**
	 * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.
	 * For GeometryCollection type use `helpers.geometryCollection`
	 *
	 * @name geometry
	 * @param {string} type Geometry Type
	 * @param {Array<number>} coordinates Coordinates
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Geometry
	 * @returns {Geometry} a GeoJSON Geometry
	 * @example
	 * var type = 'Point';
	 * var coordinates = [110, 50];
	 *
	 * var geometry = turf.geometry(type, coordinates);
	 *
	 * //=geometry
	 */
	function geometry(type, coordinates, options) {
	    // Optional Parameters
	    options = options || {};
	    if (!isObject(options)) throw new Error('options is invalid');
	    var bbox = options.bbox;

	    // Validation
	    if (!type) throw new Error('type is required');
	    if (!coordinates) throw new Error('coordinates is required');
	    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');
	    if (bbox) validateBBox(bbox);

	    // Main
	    var geom;
	    switch (type) {
	    case 'Point': geom = point(coordinates).geometry; break;
	    case 'LineString': geom = lineString(coordinates).geometry; break;
	    case 'Polygon': geom = polygon(coordinates).geometry; break;
	    case 'MultiPoint': geom = multiPoint(coordinates).geometry; break;
	    case 'MultiLineString': geom = multiLineString(coordinates).geometry; break;
	    case 'MultiPolygon': geom = multiPolygon(coordinates).geometry; break;
	    default: throw new Error(type + ' is invalid');
	    }
	    if (bbox) geom.bbox = bbox;
	    return geom;
	}

	/**
	 * Creates a {@link Point} {@link Feature} from a Position.
	 *
	 * @name point
	 * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature<Point>} a Point feature
	 * @example
	 * var point = turf.point([-75.343, 39.984]);
	 *
	 * //=point
	 */
	function point(coordinates, properties, options) {
	    if (!coordinates) throw new Error('coordinates is required');
	    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');
	    if (coordinates.length < 2) throw new Error('coordinates must be at least 2 numbers long');
	    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) throw new Error('coordinates must contain numbers');

	    return feature({
	        type: 'Point',
	        coordinates: coordinates
	    }, properties, options);
	}

	/**
	 * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.
	 *
	 * @name points
	 * @param {Array<Array<number>>} coordinates an array of Points
	 * @param {Object} [properties={}] Translate these properties to each Feature
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection
	 * @param {string|number} [options.id] Identifier associated with the FeatureCollection
	 * @returns {FeatureCollection<Point>} Point Feature
	 * @example
	 * var points = turf.points([
	 *   [-75, 39],
	 *   [-80, 45],
	 *   [-78, 50]
	 * ]);
	 *
	 * //=points
	 */
	function points(coordinates, properties, options) {
	    if (!coordinates) throw new Error('coordinates is required');
	    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');

	    return featureCollection(coordinates.map(function (coords) {
	        return point(coords, properties);
	    }), options);
	}

	/**
	 * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.
	 *
	 * @name polygon
	 * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature<Polygon>} Polygon Feature
	 * @example
	 * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });
	 *
	 * //=polygon
	 */
	function polygon(coordinates, properties, options) {
	    if (!coordinates) throw new Error('coordinates is required');

	    for (var i = 0; i < coordinates.length; i++) {
	        var ring = coordinates[i];
	        if (ring.length < 4) {
	            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');
	        }
	        for (var j = 0; j < ring[ring.length - 1].length; j++) {
	            // Check if first point of Polygon contains two numbers
	            if (i === 0 && j === 0 && !isNumber(ring[0][0]) || !isNumber(ring[0][1])) throw new Error('coordinates must contain numbers');
	            if (ring[ring.length - 1][j] !== ring[0][j]) {
	                throw new Error('First and last Position are not equivalent.');
	            }
	        }
	    }

	    return feature({
	        type: 'Polygon',
	        coordinates: coordinates
	    }, properties, options);
	}

	/**
	 * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.
	 *
	 * @name polygons
	 * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the FeatureCollection
	 * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection
	 * @example
	 * var polygons = turf.polygons([
	 *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],
	 *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],
	 * ]);
	 *
	 * //=polygons
	 */
	function polygons(coordinates, properties, options) {
	    if (!coordinates) throw new Error('coordinates is required');
	    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');

	    return featureCollection(coordinates.map(function (coords) {
	        return polygon(coords, properties);
	    }), options);
	}

	/**
	 * Creates a {@link LineString} {@link Feature} from an Array of Positions.
	 *
	 * @name lineString
	 * @param {Array<Array<number>>} coordinates an array of Positions
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature<LineString>} LineString Feature
	 * @example
	 * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});
	 * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});
	 *
	 * //=linestring1
	 * //=linestring2
	 */
	function lineString(coordinates, properties, options) {
	    if (!coordinates) throw new Error('coordinates is required');
	    if (coordinates.length < 2) throw new Error('coordinates must be an array of two or more positions');
	    // Check if first point of LineString contains two numbers
	    if (!isNumber(coordinates[0][1]) || !isNumber(coordinates[0][1])) throw new Error('coordinates must contain numbers');

	    return feature({
	        type: 'LineString',
	        coordinates: coordinates
	    }, properties, options);
	}

	/**
	 * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.
	 *
	 * @name lineStrings
	 * @param {Array<Array<number>>} coordinates an array of LinearRings
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection
	 * @param {string|number} [options.id] Identifier associated with the FeatureCollection
	 * @returns {FeatureCollection<LineString>} LineString FeatureCollection
	 * @example
	 * var linestrings = turf.lineStrings([
	 *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],
	 *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]
	 * ]);
	 *
	 * //=linestrings
	 */
	function lineStrings(coordinates, properties, options) {
	    if (!coordinates) throw new Error('coordinates is required');
	    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');

	    return featureCollection(coordinates.map(function (coords) {
	        return lineString(coords, properties);
	    }), options);
	}

	/**
	 * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.
	 *
	 * @name featureCollection
	 * @param {Feature[]} features input features
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {FeatureCollection} FeatureCollection of Features
	 * @example
	 * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});
	 * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});
	 * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});
	 *
	 * var collection = turf.featureCollection([
	 *   locationA,
	 *   locationB,
	 *   locationC
	 * ]);
	 *
	 * //=collection
	 */
	function featureCollection(features, options) {
	    // Optional Parameters
	    options = options || {};
	    if (!isObject(options)) throw new Error('options is invalid');
	    var bbox = options.bbox;
	    var id = options.id;

	    // Validation
	    if (!features) throw new Error('No features passed');
	    if (!Array.isArray(features)) throw new Error('features must be an Array');
	    if (bbox) validateBBox(bbox);
	    if (id) validateId(id);

	    // Main
	    var fc = {type: 'FeatureCollection'};
	    if (id) fc.id = id;
	    if (bbox) fc.bbox = bbox;
	    fc.features = features;
	    return fc;
	}

	/**
	 * Creates a {@link Feature<MultiLineString>} based on a
	 * coordinate array. Properties can be added optionally.
	 *
	 * @name multiLineString
	 * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature<MultiLineString>} a MultiLineString feature
	 * @throws {Error} if no coordinates are passed
	 * @example
	 * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);
	 *
	 * //=multiLine
	 */
	function multiLineString(coordinates, properties, options) {
	    if (!coordinates) throw new Error('coordinates is required');

	    return feature({
	        type: 'MultiLineString',
	        coordinates: coordinates
	    }, properties, options);
	}

	/**
	 * Creates a {@link Feature<MultiPoint>} based on a
	 * coordinate array. Properties can be added optionally.
	 *
	 * @name multiPoint
	 * @param {Array<Array<number>>} coordinates an array of Positions
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature<MultiPoint>} a MultiPoint feature
	 * @throws {Error} if no coordinates are passed
	 * @example
	 * var multiPt = turf.multiPoint([[0,0],[10,10]]);
	 *
	 * //=multiPt
	 */
	function multiPoint(coordinates, properties, options) {
	    if (!coordinates) throw new Error('coordinates is required');

	    return feature({
	        type: 'MultiPoint',
	        coordinates: coordinates
	    }, properties, options);
	}

	/**
	 * Creates a {@link Feature<MultiPolygon>} based on a
	 * coordinate array. Properties can be added optionally.
	 *
	 * @name multiPolygon
	 * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature<MultiPolygon>} a multipolygon feature
	 * @throws {Error} if no coordinates are passed
	 * @example
	 * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);
	 *
	 * //=multiPoly
	 *
	 */
	function multiPolygon(coordinates, properties, options) {
	    if (!coordinates) throw new Error('coordinates is required');

	    return feature({
	        type: 'MultiPolygon',
	        coordinates: coordinates
	    }, properties, options);
	}

	/**
	 * Creates a {@link Feature<GeometryCollection>} based on a
	 * coordinate array. Properties can be added optionally.
	 *
	 * @name geometryCollection
	 * @param {Array<Geometry>} geometries an array of GeoJSON Geometries
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature
	 * @example
	 * var pt = {
	 *     "type": "Point",
	 *       "coordinates": [100, 0]
	 *     };
	 * var line = {
	 *     "type": "LineString",
	 *     "coordinates": [ [101, 0], [102, 1] ]
	 *   };
	 * var collection = turf.geometryCollection([pt, line]);
	 *
	 * //=collection
	 */
	function geometryCollection(geometries, properties, options) {
	    if (!geometries) throw new Error('geometries is required');
	    if (!Array.isArray(geometries)) throw new Error('geometries must be an Array');

	    return feature({
	        type: 'GeometryCollection',
	        geometries: geometries
	    }, properties, options);
	}

	/**
	 * Round number to precision
	 *
	 * @param {number} num Number
	 * @param {number} [precision=0] Precision
	 * @returns {number} rounded number
	 * @example
	 * turf.round(120.4321)
	 * //=120
	 *
	 * turf.round(120.4321, 2)
	 * //=120.43
	 */
	function round(num, precision) {
	    if (num === undefined || num === null || isNaN(num)) throw new Error('num is required');
	    if (precision && !(precision >= 0)) throw new Error('precision must be a positive number');
	    var multiplier = Math.pow(10, precision || 0);
	    return Math.round(num * multiplier) / multiplier;
	}

	/**
	 * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.
	 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
	 *
	 * @name radiansToLength
	 * @param {number} radians in radians across the sphere
	 * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.
	 * @returns {number} distance
	 */
	function radiansToLength(radians, units) {
	    if (radians === undefined || radians === null) throw new Error('radians is required');

	    if (units && typeof units !== 'string') throw new Error('units must be a string');
	    var factor = factors[units || 'kilometers'];
	    if (!factor) throw new Error(units + ' units is invalid');
	    return radians * factor;
	}

	/**
	 * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians
	 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
	 *
	 * @name lengthToRadians
	 * @param {number} distance in real units
	 * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.
	 * @returns {number} radians
	 */
	function lengthToRadians(distance, units) {
	    if (distance === undefined || distance === null) throw new Error('distance is required');

	    if (units && typeof units !== 'string') throw new Error('units must be a string');
	    var factor = factors[units || 'kilometers'];
	    if (!factor) throw new Error(units + ' units is invalid');
	    return distance / factor;
	}

	/**
	 * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees
	 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet
	 *
	 * @name lengthToDegrees
	 * @param {number} distance in real units
	 * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.
	 * @returns {number} degrees
	 */
	function lengthToDegrees(distance, units) {
	    return radiansToDegrees(lengthToRadians(distance, units));
	}

	/**
	 * Converts any bearing angle from the north line direction (positive clockwise)
	 * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line
	 *
	 * @name bearingToAzimuth
	 * @param {number} bearing angle, between -180 and +180 degrees
	 * @returns {number} angle between 0 and 360 degrees
	 */
	function bearingToAzimuth(bearing) {
	    if (bearing === null || bearing === undefined) throw new Error('bearing is required');

	    var angle = bearing % 360;
	    if (angle < 0) angle += 360;
	    return angle;
	}

	/**
	 * Converts an angle in radians to degrees
	 *
	 * @name radiansToDegrees
	 * @param {number} radians angle in radians
	 * @returns {number} degrees between 0 and 360 degrees
	 */
	function radiansToDegrees(radians) {
	    if (radians === null || radians === undefined) throw new Error('radians is required');

	    var degrees = radians % (2 * Math.PI);
	    return degrees * 180 / Math.PI;
	}

	/**
	 * Converts an angle in degrees to radians
	 *
	 * @name degreesToRadians
	 * @param {number} degrees angle between 0 and 360 degrees
	 * @returns {number} angle in radians
	 */
	function degreesToRadians(degrees) {
	    if (degrees === null || degrees === undefined) throw new Error('degrees is required');

	    var radians = degrees % 360;
	    return radians * Math.PI / 180;
	}

	/**
	 * Converts a length to the requested unit.
	 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
	 *
	 * @param {number} length to be converted
	 * @param {string} originalUnit of the length
	 * @param {string} [finalUnit='kilometers'] returned unit
	 * @returns {number} the converted length
	 */
	function convertLength(length, originalUnit, finalUnit) {
	    if (length === null || length === undefined) throw new Error('length is required');
	    if (!(length >= 0)) throw new Error('length must be a positive number');

	    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit || 'kilometers');
	}

	/**
	 * Converts a area to the requested unit.
	 * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches
	 * @param {number} area to be converted
	 * @param {string} [originalUnit='meters'] of the distance
	 * @param {string} [finalUnit='kilometers'] returned unit
	 * @returns {number} the converted distance
	 */
	function convertArea(area, originalUnit, finalUnit) {
	    if (area === null || area === undefined) throw new Error('area is required');
	    if (!(area >= 0)) throw new Error('area must be a positive number');

	    var startFactor = areaFactors[originalUnit || 'meters'];
	    if (!startFactor) throw new Error('invalid original units');

	    var finalFactor = areaFactors[finalUnit || 'kilometers'];
	    if (!finalFactor) throw new Error('invalid final units');

	    return (area / startFactor) * finalFactor;
	}

	/**
	 * isNumber
	 *
	 * @param {*} num Number to validate
	 * @returns {boolean} true/false
	 * @example
	 * turf.isNumber(123)
	 * //=true
	 * turf.isNumber('foo')
	 * //=false
	 */
	function isNumber(num) {
	    return !isNaN(num) && num !== null && !Array.isArray(num);
	}

	/**
	 * isObject
	 *
	 * @param {*} input variable to validate
	 * @returns {boolean} true/false
	 * @example
	 * turf.isObject({elevation: 10})
	 * //=true
	 * turf.isObject('foo')
	 * //=false
	 */
	function isObject(input) {
	    return (!!input) && (input.constructor === Object);
	}

	/**
	 * Validate BBox
	 *
	 * @private
	 * @param {Array<number>} bbox BBox to validate
	 * @returns {void}
	 * @throws Error if BBox is not valid
	 * @example
	 * validateBBox([-180, -40, 110, 50])
	 * //=OK
	 * validateBBox([-180, -40])
	 * //=Error
	 * validateBBox('Foo')
	 * //=Error
	 * validateBBox(5)
	 * //=Error
	 * validateBBox(null)
	 * //=Error
	 * validateBBox(undefined)
	 * //=Error
	 */
	function validateBBox(bbox) {
	    if (!bbox) throw new Error('bbox is required');
	    if (!Array.isArray(bbox)) throw new Error('bbox must be an Array');
	    if (bbox.length !== 4 && bbox.length !== 6) throw new Error('bbox must be an Array of 4 or 6 numbers');
	    bbox.forEach(function (num) {
	        if (!isNumber(num)) throw new Error('bbox must only contain numbers');
	    });
	}

	/**
	 * Validate Id
	 *
	 * @private
	 * @param {string|number} id Id to validate
	 * @returns {void}
	 * @throws Error if Id is not valid
	 * @example
	 * validateId([-180, -40, 110, 50])
	 * //=Error
	 * validateId([-180, -40])
	 * //=Error
	 * validateId('Foo')
	 * //=OK
	 * validateId(5)
	 * //=OK
	 * validateId(null)
	 * //=Error
	 * validateId(undefined)
	 * //=Error
	 */
	function validateId(id) {
	    if (!id) throw new Error('id is required');
	    if (['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');
	}

	// Deprecated methods
	function radians2degrees() {
	    throw new Error('method has been renamed to `radiansToDegrees`');
	}

	function degrees2radians() {
	    throw new Error('method has been renamed to `degreesToRadians`');
	}

	function distanceToDegrees() {
	    throw new Error('method has been renamed to `lengthToDegrees`');
	}

	function distanceToRadians() {
	    throw new Error('method has been renamed to `lengthToRadians`');
	}

	function radiansToDistance() {
	    throw new Error('method has been renamed to `radiansToLength`');
	}

	function bearingToAngle() {
	    throw new Error('method has been renamed to `bearingToAzimuth`');
	}

	function convertDistance() {
	    throw new Error('method has been renamed to `convertLength`');
	}

	exports.earthRadius = earthRadius;
	exports.factors = factors;
	exports.unitsFactors = unitsFactors;
	exports.areaFactors = areaFactors;
	exports.feature = feature;
	exports.geometry = geometry;
	exports.point = point;
	exports.points = points;
	exports.polygon = polygon;
	exports.polygons = polygons;
	exports.lineString = lineString;
	exports.lineStrings = lineStrings;
	exports.featureCollection = featureCollection;
	exports.multiLineString = multiLineString;
	exports.multiPoint = multiPoint;
	exports.multiPolygon = multiPolygon;
	exports.geometryCollection = geometryCollection;
	exports.round = round;
	exports.radiansToLength = radiansToLength;
	exports.lengthToRadians = lengthToRadians;
	exports.lengthToDegrees = lengthToDegrees;
	exports.bearingToAzimuth = bearingToAzimuth;
	exports.radiansToDegrees = radiansToDegrees;
	exports.degreesToRadians = degreesToRadians;
	exports.convertLength = convertLength;
	exports.convertArea = convertArea;
	exports.isNumber = isNumber;
	exports.isObject = isObject;
	exports.validateBBox = validateBBox;
	exports.validateId = validateId;
	exports.radians2degrees = radians2degrees;
	exports.degrees2radians = degrees2radians;
	exports.distanceToDegrees = distanceToDegrees;
	exports.distanceToRadians = distanceToRadians;
	exports.radiansToDistance = radiansToDistance;
	exports.bearingToAngle = bearingToAngle;
	exports.convertDistance = convertDistance;
	});

	unwrapExports(main$3);
	var main_1$2 = main$3.earthRadius;
	var main_2$2 = main$3.factors;
	var main_3$2 = main$3.unitsFactors;
	var main_4$2 = main$3.areaFactors;
	var main_5$2 = main$3.feature;
	var main_6$2 = main$3.geometry;
	var main_7$2 = main$3.point;
	var main_8$2 = main$3.points;
	var main_9$2 = main$3.polygon;
	var main_10$2 = main$3.polygons;
	var main_11$2 = main$3.lineString;
	var main_12$2 = main$3.lineStrings;
	var main_13$2 = main$3.featureCollection;
	var main_14$2 = main$3.multiLineString;
	var main_15$2 = main$3.multiPoint;
	var main_16$2 = main$3.multiPolygon;
	var main_17$2 = main$3.geometryCollection;
	var main_18$1 = main$3.round;
	var main_19$1 = main$3.radiansToLength;
	var main_20$1 = main$3.lengthToRadians;
	var main_21$1 = main$3.lengthToDegrees;
	var main_22$1 = main$3.bearingToAzimuth;
	var main_23$1 = main$3.radiansToDegrees;
	var main_24$1 = main$3.degreesToRadians;
	var main_25$1 = main$3.convertLength;
	var main_26$1 = main$3.convertArea;
	var main_27$1 = main$3.isNumber;
	var main_28$1 = main$3.isObject;
	var main_29$1 = main$3.validateBBox;
	var main_30$1 = main$3.validateId;
	var main_31$1 = main$3.radians2degrees;
	var main_32$1 = main$3.degrees2radians;
	var main_33$1 = main$3.distanceToDegrees;
	var main_34$1 = main$3.distanceToRadians;
	var main_35$1 = main$3.radiansToDistance;
	var main_36$1 = main$3.bearingToAngle;
	var main_37$1 = main$3.convertDistance;

	var main$4 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, '__esModule', { value: true });



	/**
	 * Callback for coordEach
	 *
	 * @callback coordEachCallback
	 * @param {Array<number>} currentCoord The current coordinate being processed.
	 * @param {number} coordIndex The current index of the coordinate being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
	 * @param {number} geometryIndex The current index of the Geometry being processed.
	 */

	/**
	 * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()
	 *
	 * @name coordEach
	 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
	 * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)
	 * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.
	 * @returns {void}
	 * @example
	 * var features = turf.featureCollection([
	 *   turf.point([26, 37], {"foo": "bar"}),
	 *   turf.point([36, 53], {"hello": "world"})
	 * ]);
	 *
	 * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
	 *   //=currentCoord
	 *   //=coordIndex
	 *   //=featureIndex
	 *   //=multiFeatureIndex
	 *   //=geometryIndex
	 * });
	 */
	function coordEach(geojson, callback, excludeWrapCoord) {
	    // Handles null Geometry -- Skips this GeoJSON
	    if (geojson === null) return;
	    var j, k, l, geometry, stopG, coords,
	        geometryMaybeCollection,
	        wrapShrink = 0,
	        coordIndex = 0,
	        isGeometryCollection,
	        type = geojson.type,
	        isFeatureCollection = type === 'FeatureCollection',
	        isFeature = type === 'Feature',
	        stop = isFeatureCollection ? geojson.features.length : 1;

	    // This logic may look a little weird. The reason why it is that way
	    // is because it's trying to be fast. GeoJSON supports multiple kinds
	    // of objects at its root: FeatureCollection, Features, Geometries.
	    // This function has the responsibility of handling all of them, and that
	    // means that some of the `for` loops you see below actually just don't apply
	    // to certain inputs. For instance, if you give this just a
	    // Point geometry, then both loops are short-circuited and all we do
	    // is gradually rename the input until it's called 'geometry'.
	    //
	    // This also aims to allocate as few resources as possible: just a
	    // few numbers and booleans, rather than any temporary arrays as would
	    // be required with the normalization approach.
	    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {
	        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :
	            (isFeature ? geojson.geometry : geojson));
	        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;
	        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

	        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {
	            var multiFeatureIndex = 0;
	            var geometryIndex = 0;
	            geometry = isGeometryCollection ?
	                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;

	            // Handles null Geometry -- Skips this geometry
	            if (geometry === null) continue;
	            coords = geometry.coordinates;
	            var geomType = geometry.type;

	            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;

	            switch (geomType) {
	            case null:
	                break;
	            case 'Point':
	                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
	                coordIndex++;
	                multiFeatureIndex++;
	                break;
	            case 'LineString':
	            case 'MultiPoint':
	                for (j = 0; j < coords.length; j++) {
	                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
	                    coordIndex++;
	                    if (geomType === 'MultiPoint') multiFeatureIndex++;
	                }
	                if (geomType === 'LineString') multiFeatureIndex++;
	                break;
	            case 'Polygon':
	            case 'MultiLineString':
	                for (j = 0; j < coords.length; j++) {
	                    for (k = 0; k < coords[j].length - wrapShrink; k++) {
	                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
	                        coordIndex++;
	                    }
	                    if (geomType === 'MultiLineString') multiFeatureIndex++;
	                    if (geomType === 'Polygon') geometryIndex++;
	                }
	                if (geomType === 'Polygon') multiFeatureIndex++;
	                break;
	            case 'MultiPolygon':
	                for (j = 0; j < coords.length; j++) {
	                    if (geomType === 'MultiPolygon') geometryIndex = 0;
	                    for (k = 0; k < coords[j].length; k++) {
	                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
	                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
	                            coordIndex++;
	                        }
	                        geometryIndex++;
	                    }
	                    multiFeatureIndex++;
	                }
	                break;
	            case 'GeometryCollection':
	                for (j = 0; j < geometry.geometries.length; j++)
	                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;
	                break;
	            default:
	                throw new Error('Unknown Geometry Type');
	            }
	        }
	    }
	}

	/**
	 * Callback for coordReduce
	 *
	 * The first time the callback function is called, the values provided as arguments depend
	 * on whether the reduce method has an initialValue argument.
	 *
	 * If an initialValue is provided to the reduce method:
	 *  - The previousValue argument is initialValue.
	 *  - The currentValue argument is the value of the first element present in the array.
	 *
	 * If an initialValue is not provided:
	 *  - The previousValue argument is the value of the first element present in the array.
	 *  - The currentValue argument is the value of the second element present in the array.
	 *
	 * @callback coordReduceCallback
	 * @param {*} previousValue The accumulated value previously returned in the last invocation
	 * of the callback, or initialValue, if supplied.
	 * @param {Array<number>} currentCoord The current coordinate being processed.
	 * @param {number} coordIndex The current index of the coordinate being processed.
	 * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
	 * @param {number} geometryIndex The current index of the Geometry being processed.
	 */

	/**
	 * Reduce coordinates in any GeoJSON object, similar to Array.reduce()
	 *
	 * @name coordReduce
	 * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object
	 * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)
	 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
	 * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.
	 * @returns {*} The value that results from the reduction.
	 * @example
	 * var features = turf.featureCollection([
	 *   turf.point([26, 37], {"foo": "bar"}),
	 *   turf.point([36, 53], {"hello": "world"})
	 * ]);
	 *
	 * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
	 *   //=previousValue
	 *   //=currentCoord
	 *   //=coordIndex
	 *   //=featureIndex
	 *   //=multiFeatureIndex
	 *   //=geometryIndex
	 *   return currentCoord;
	 * });
	 */
	function coordReduce(geojson, callback, initialValue, excludeWrapCoord) {
	    var previousValue = initialValue;
	    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
	        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;
	        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);
	    }, excludeWrapCoord);
	    return previousValue;
	}

	/**
	 * Callback for propEach
	 *
	 * @callback propEachCallback
	 * @param {Object} currentProperties The current Properties being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 */

	/**
	 * Iterate over properties in any GeoJSON object, similar to Array.forEach()
	 *
	 * @name propEach
	 * @param {FeatureCollection|Feature} geojson any GeoJSON object
	 * @param {Function} callback a method that takes (currentProperties, featureIndex)
	 * @returns {void}
	 * @example
	 * var features = turf.featureCollection([
	 *     turf.point([26, 37], {foo: 'bar'}),
	 *     turf.point([36, 53], {hello: 'world'})
	 * ]);
	 *
	 * turf.propEach(features, function (currentProperties, featureIndex) {
	 *   //=currentProperties
	 *   //=featureIndex
	 * });
	 */
	function propEach(geojson, callback) {
	    var i;
	    switch (geojson.type) {
	    case 'FeatureCollection':
	        for (i = 0; i < geojson.features.length; i++) {
	            if (callback(geojson.features[i].properties, i) === false) break;
	        }
	        break;
	    case 'Feature':
	        callback(geojson.properties, 0);
	        break;
	    }
	}


	/**
	 * Callback for propReduce
	 *
	 * The first time the callback function is called, the values provided as arguments depend
	 * on whether the reduce method has an initialValue argument.
	 *
	 * If an initialValue is provided to the reduce method:
	 *  - The previousValue argument is initialValue.
	 *  - The currentValue argument is the value of the first element present in the array.
	 *
	 * If an initialValue is not provided:
	 *  - The previousValue argument is the value of the first element present in the array.
	 *  - The currentValue argument is the value of the second element present in the array.
	 *
	 * @callback propReduceCallback
	 * @param {*} previousValue The accumulated value previously returned in the last invocation
	 * of the callback, or initialValue, if supplied.
	 * @param {*} currentProperties The current Properties being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 */

	/**
	 * Reduce properties in any GeoJSON object into a single value,
	 * similar to how Array.reduce works. However, in this case we lazily run
	 * the reduction, so an array of all properties is unnecessary.
	 *
	 * @name propReduce
	 * @param {FeatureCollection|Feature} geojson any GeoJSON object
	 * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)
	 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
	 * @returns {*} The value that results from the reduction.
	 * @example
	 * var features = turf.featureCollection([
	 *     turf.point([26, 37], {foo: 'bar'}),
	 *     turf.point([36, 53], {hello: 'world'})
	 * ]);
	 *
	 * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {
	 *   //=previousValue
	 *   //=currentProperties
	 *   //=featureIndex
	 *   return currentProperties
	 * });
	 */
	function propReduce(geojson, callback, initialValue) {
	    var previousValue = initialValue;
	    propEach(geojson, function (currentProperties, featureIndex) {
	        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;
	        else previousValue = callback(previousValue, currentProperties, featureIndex);
	    });
	    return previousValue;
	}

	/**
	 * Callback for featureEach
	 *
	 * @callback featureEachCallback
	 * @param {Feature<any>} currentFeature The current Feature being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 */

	/**
	 * Iterate over features in any GeoJSON object, similar to
	 * Array.forEach.
	 *
	 * @name featureEach
	 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
	 * @param {Function} callback a method that takes (currentFeature, featureIndex)
	 * @returns {void}
	 * @example
	 * var features = turf.featureCollection([
	 *   turf.point([26, 37], {foo: 'bar'}),
	 *   turf.point([36, 53], {hello: 'world'})
	 * ]);
	 *
	 * turf.featureEach(features, function (currentFeature, featureIndex) {
	 *   //=currentFeature
	 *   //=featureIndex
	 * });
	 */
	function featureEach(geojson, callback) {
	    if (geojson.type === 'Feature') {
	        callback(geojson, 0);
	    } else if (geojson.type === 'FeatureCollection') {
	        for (var i = 0; i < geojson.features.length; i++) {
	            if (callback(geojson.features[i], i) === false) break;
	        }
	    }
	}

	/**
	 * Callback for featureReduce
	 *
	 * The first time the callback function is called, the values provided as arguments depend
	 * on whether the reduce method has an initialValue argument.
	 *
	 * If an initialValue is provided to the reduce method:
	 *  - The previousValue argument is initialValue.
	 *  - The currentValue argument is the value of the first element present in the array.
	 *
	 * If an initialValue is not provided:
	 *  - The previousValue argument is the value of the first element present in the array.
	 *  - The currentValue argument is the value of the second element present in the array.
	 *
	 * @callback featureReduceCallback
	 * @param {*} previousValue The accumulated value previously returned in the last invocation
	 * of the callback, or initialValue, if supplied.
	 * @param {Feature} currentFeature The current Feature being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 */

	/**
	 * Reduce features in any GeoJSON object, similar to Array.reduce().
	 *
	 * @name featureReduce
	 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
	 * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)
	 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
	 * @returns {*} The value that results from the reduction.
	 * @example
	 * var features = turf.featureCollection([
	 *   turf.point([26, 37], {"foo": "bar"}),
	 *   turf.point([36, 53], {"hello": "world"})
	 * ]);
	 *
	 * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {
	 *   //=previousValue
	 *   //=currentFeature
	 *   //=featureIndex
	 *   return currentFeature
	 * });
	 */
	function featureReduce(geojson, callback, initialValue) {
	    var previousValue = initialValue;
	    featureEach(geojson, function (currentFeature, featureIndex) {
	        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;
	        else previousValue = callback(previousValue, currentFeature, featureIndex);
	    });
	    return previousValue;
	}

	/**
	 * Get all coordinates from any GeoJSON object.
	 *
	 * @name coordAll
	 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
	 * @returns {Array<Array<number>>} coordinate position array
	 * @example
	 * var features = turf.featureCollection([
	 *   turf.point([26, 37], {foo: 'bar'}),
	 *   turf.point([36, 53], {hello: 'world'})
	 * ]);
	 *
	 * var coords = turf.coordAll(features);
	 * //= [[26, 37], [36, 53]]
	 */
	function coordAll(geojson) {
	    var coords = [];
	    coordEach(geojson, function (coord) {
	        coords.push(coord);
	    });
	    return coords;
	}

	/**
	 * Callback for geomEach
	 *
	 * @callback geomEachCallback
	 * @param {Geometry} currentGeometry The current Geometry being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 * @param {Object} featureProperties The current Feature Properties being processed.
	 * @param {Array<number>} featureBBox The current Feature BBox being processed.
	 * @param {number|string} featureId The current Feature Id being processed.
	 */

	/**
	 * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()
	 *
	 * @name geomEach
	 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
	 * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)
	 * @returns {void}
	 * @example
	 * var features = turf.featureCollection([
	 *     turf.point([26, 37], {foo: 'bar'}),
	 *     turf.point([36, 53], {hello: 'world'})
	 * ]);
	 *
	 * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
	 *   //=currentGeometry
	 *   //=featureIndex
	 *   //=featureProperties
	 *   //=featureBBox
	 *   //=featureId
	 * });
	 */
	function geomEach(geojson, callback) {
	    var i, j, g, geometry, stopG,
	        geometryMaybeCollection,
	        isGeometryCollection,
	        featureProperties,
	        featureBBox,
	        featureId,
	        featureIndex = 0,
	        isFeatureCollection = geojson.type === 'FeatureCollection',
	        isFeature = geojson.type === 'Feature',
	        stop = isFeatureCollection ? geojson.features.length : 1;

	    // This logic may look a little weird. The reason why it is that way
	    // is because it's trying to be fast. GeoJSON supports multiple kinds
	    // of objects at its root: FeatureCollection, Features, Geometries.
	    // This function has the responsibility of handling all of them, and that
	    // means that some of the `for` loops you see below actually just don't apply
	    // to certain inputs. For instance, if you give this just a
	    // Point geometry, then both loops are short-circuited and all we do
	    // is gradually rename the input until it's called 'geometry'.
	    //
	    // This also aims to allocate as few resources as possible: just a
	    // few numbers and booleans, rather than any temporary arrays as would
	    // be required with the normalization approach.
	    for (i = 0; i < stop; i++) {

	        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :
	            (isFeature ? geojson.geometry : geojson));
	        featureProperties = (isFeatureCollection ? geojson.features[i].properties :
	            (isFeature ? geojson.properties : {}));
	        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :
	            (isFeature ? geojson.bbox : undefined));
	        featureId = (isFeatureCollection ? geojson.features[i].id :
	            (isFeature ? geojson.id : undefined));
	        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;
	        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

	        for (g = 0; g < stopG; g++) {
	            geometry = isGeometryCollection ?
	                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;

	            // Handle null Geometry
	            if (geometry === null) {
	                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;
	                continue;
	            }
	            switch (geometry.type) {
	            case 'Point':
	            case 'LineString':
	            case 'MultiPoint':
	            case 'Polygon':
	            case 'MultiLineString':
	            case 'MultiPolygon': {
	                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;
	                break;
	            }
	            case 'GeometryCollection': {
	                for (j = 0; j < geometry.geometries.length; j++) {
	                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;
	                }
	                break;
	            }
	            default:
	                throw new Error('Unknown Geometry Type');
	            }
	        }
	        // Only increase `featureIndex` per each feature
	        featureIndex++;
	    }
	}

	/**
	 * Callback for geomReduce
	 *
	 * The first time the callback function is called, the values provided as arguments depend
	 * on whether the reduce method has an initialValue argument.
	 *
	 * If an initialValue is provided to the reduce method:
	 *  - The previousValue argument is initialValue.
	 *  - The currentValue argument is the value of the first element present in the array.
	 *
	 * If an initialValue is not provided:
	 *  - The previousValue argument is the value of the first element present in the array.
	 *  - The currentValue argument is the value of the second element present in the array.
	 *
	 * @callback geomReduceCallback
	 * @param {*} previousValue The accumulated value previously returned in the last invocation
	 * of the callback, or initialValue, if supplied.
	 * @param {Geometry} currentGeometry The current Geometry being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 * @param {Object} featureProperties The current Feature Properties being processed.
	 * @param {Array<number>} featureBBox The current Feature BBox being processed.
	 * @param {number|string} featureId The current Feature Id being processed.
	 */

	/**
	 * Reduce geometry in any GeoJSON object, similar to Array.reduce().
	 *
	 * @name geomReduce
	 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
	 * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)
	 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
	 * @returns {*} The value that results from the reduction.
	 * @example
	 * var features = turf.featureCollection([
	 *     turf.point([26, 37], {foo: 'bar'}),
	 *     turf.point([36, 53], {hello: 'world'})
	 * ]);
	 *
	 * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
	 *   //=previousValue
	 *   //=currentGeometry
	 *   //=featureIndex
	 *   //=featureProperties
	 *   //=featureBBox
	 *   //=featureId
	 *   return currentGeometry
	 * });
	 */
	function geomReduce(geojson, callback, initialValue) {
	    var previousValue = initialValue;
	    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
	        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;
	        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);
	    });
	    return previousValue;
	}

	/**
	 * Callback for flattenEach
	 *
	 * @callback flattenEachCallback
	 * @param {Feature} currentFeature The current flattened feature being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
	 */

	/**
	 * Iterate over flattened features in any GeoJSON object, similar to
	 * Array.forEach.
	 *
	 * @name flattenEach
	 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
	 * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)
	 * @example
	 * var features = turf.featureCollection([
	 *     turf.point([26, 37], {foo: 'bar'}),
	 *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})
	 * ]);
	 *
	 * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {
	 *   //=currentFeature
	 *   //=featureIndex
	 *   //=multiFeatureIndex
	 * });
	 */
	function flattenEach(geojson, callback) {
	    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {
	        // Callback for single geometry
	        var type = (geometry === null) ? null : geometry.type;
	        switch (type) {
	        case null:
	        case 'Point':
	        case 'LineString':
	        case 'Polygon':
	            if (callback(main$3.feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;
	            return;
	        }

	        var geomType;

	        // Callback for multi-geometry
	        switch (type) {
	        case 'MultiPoint':
	            geomType = 'Point';
	            break;
	        case 'MultiLineString':
	            geomType = 'LineString';
	            break;
	        case 'MultiPolygon':
	            geomType = 'Polygon';
	            break;
	        }

	        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {
	            var coordinate = geometry.coordinates[multiFeatureIndex];
	            var geom = {
	                type: geomType,
	                coordinates: coordinate
	            };
	            if (callback(main$3.feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;
	        }
	    });
	}

	/**
	 * Callback for flattenReduce
	 *
	 * The first time the callback function is called, the values provided as arguments depend
	 * on whether the reduce method has an initialValue argument.
	 *
	 * If an initialValue is provided to the reduce method:
	 *  - The previousValue argument is initialValue.
	 *  - The currentValue argument is the value of the first element present in the array.
	 *
	 * If an initialValue is not provided:
	 *  - The previousValue argument is the value of the first element present in the array.
	 *  - The currentValue argument is the value of the second element present in the array.
	 *
	 * @callback flattenReduceCallback
	 * @param {*} previousValue The accumulated value previously returned in the last invocation
	 * of the callback, or initialValue, if supplied.
	 * @param {Feature} currentFeature The current Feature being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
	 */

	/**
	 * Reduce flattened features in any GeoJSON object, similar to Array.reduce().
	 *
	 * @name flattenReduce
	 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
	 * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)
	 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
	 * @returns {*} The value that results from the reduction.
	 * @example
	 * var features = turf.featureCollection([
	 *     turf.point([26, 37], {foo: 'bar'}),
	 *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})
	 * ]);
	 *
	 * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {
	 *   //=previousValue
	 *   //=currentFeature
	 *   //=featureIndex
	 *   //=multiFeatureIndex
	 *   return currentFeature
	 * });
	 */
	function flattenReduce(geojson, callback, initialValue) {
	    var previousValue = initialValue;
	    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {
	        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;
	        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);
	    });
	    return previousValue;
	}

	/**
	 * Callback for segmentEach
	 *
	 * @callback segmentEachCallback
	 * @param {Feature<LineString>} currentSegment The current Segment being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
	 * @param {number} geometryIndex The current index of the Geometry being processed.
	 * @param {number} segmentIndex The current index of the Segment being processed.
	 * @returns {void}
	 */

	/**
	 * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()
	 * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
	 *
	 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON
	 * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)
	 * @returns {void}
	 * @example
	 * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
	 *
	 * // Iterate over GeoJSON by 2-vertex segments
	 * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
	 *   //=currentSegment
	 *   //=featureIndex
	 *   //=multiFeatureIndex
	 *   //=geometryIndex
	 *   //=segmentIndex
	 * });
	 *
	 * // Calculate the total number of segments
	 * var total = 0;
	 * turf.segmentEach(polygon, function () {
	 *     total++;
	 * });
	 */
	function segmentEach(geojson, callback) {
	    flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {
	        var segmentIndex = 0;

	        // Exclude null Geometries
	        if (!feature$$1.geometry) return;
	        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
	        var type = feature$$1.geometry.type;
	        if (type === 'Point' || type === 'MultiPoint') return;

	        // Generate 2-vertex line segments
	        var previousCoords;
	        if (coordEach(feature$$1, function (currentCoord, coordIndex, featureIndexCoord, mutliPartIndexCoord, geometryIndex) {
	            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`
	            if (previousCoords === undefined) {
	                previousCoords = currentCoord;
	                return;
	            }
	            var currentSegment = main$3.lineString([previousCoords, currentCoord], feature$$1.properties);
	            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;
	            segmentIndex++;
	            previousCoords = currentCoord;
	        }) === false) return false;
	    });
	}

	/**
	 * Callback for segmentReduce
	 *
	 * The first time the callback function is called, the values provided as arguments depend
	 * on whether the reduce method has an initialValue argument.
	 *
	 * If an initialValue is provided to the reduce method:
	 *  - The previousValue argument is initialValue.
	 *  - The currentValue argument is the value of the first element present in the array.
	 *
	 * If an initialValue is not provided:
	 *  - The previousValue argument is the value of the first element present in the array.
	 *  - The currentValue argument is the value of the second element present in the array.
	 *
	 * @callback segmentReduceCallback
	 * @param {*} previousValue The accumulated value previously returned in the last invocation
	 * of the callback, or initialValue, if supplied.
	 * @param {Feature<LineString>} currentSegment The current Segment being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
	 * @param {number} geometryIndex The current index of the Geometry being processed.
	 * @param {number} segmentIndex The current index of the Segment being processed.
	 */

	/**
	 * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()
	 * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
	 *
	 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON
	 * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)
	 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
	 * @returns {void}
	 * @example
	 * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
	 *
	 * // Iterate over GeoJSON by 2-vertex segments
	 * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
	 *   //= previousSegment
	 *   //= currentSegment
	 *   //= featureIndex
	 *   //= multiFeatureIndex
	 *   //= geometryIndex
	 *   //= segmentInex
	 *   return currentSegment
	 * });
	 *
	 * // Calculate the total number of segments
	 * var initialValue = 0
	 * var total = turf.segmentReduce(polygon, function (previousValue) {
	 *     previousValue++;
	 *     return previousValue;
	 * }, initialValue);
	 */
	function segmentReduce(geojson, callback, initialValue) {
	    var previousValue = initialValue;
	    var started = false;
	    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
	        if (started === false && initialValue === undefined) previousValue = currentSegment;
	        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);
	        started = true;
	    });
	    return previousValue;
	}

	/**
	 * Callback for lineEach
	 *
	 * @callback lineEachCallback
	 * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed
	 * @param {number} featureIndex The current index of the Feature being processed
	 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed
	 * @param {number} geometryIndex The current index of the Geometry being processed
	 */

	/**
	 * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,
	 * similar to Array.forEach.
	 *
	 * @name lineEach
	 * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object
	 * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)
	 * @example
	 * var multiLine = turf.multiLineString([
	 *   [[26, 37], [35, 45]],
	 *   [[36, 53], [38, 50], [41, 55]]
	 * ]);
	 *
	 * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
	 *   //=currentLine
	 *   //=featureIndex
	 *   //=multiFeatureIndex
	 *   //=geometryIndex
	 * });
	 */
	function lineEach(geojson, callback) {
	    // validation
	    if (!geojson) throw new Error('geojson is required');

	    flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {
	        if (feature$$1.geometry === null) return;
	        var type = feature$$1.geometry.type;
	        var coords = feature$$1.geometry.coordinates;
	        switch (type) {
	        case 'LineString':
	            if (callback(feature$$1, featureIndex, multiFeatureIndex, 0, 0) === false) return false;
	            break;
	        case 'Polygon':
	            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {
	                if (callback(main$3.lineString(coords[geometryIndex], feature$$1.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
	            }
	            break;
	        }
	    });
	}

	/**
	 * Callback for lineReduce
	 *
	 * The first time the callback function is called, the values provided as arguments depend
	 * on whether the reduce method has an initialValue argument.
	 *
	 * If an initialValue is provided to the reduce method:
	 *  - The previousValue argument is initialValue.
	 *  - The currentValue argument is the value of the first element present in the array.
	 *
	 * If an initialValue is not provided:
	 *  - The previousValue argument is the value of the first element present in the array.
	 *  - The currentValue argument is the value of the second element present in the array.
	 *
	 * @callback lineReduceCallback
	 * @param {*} previousValue The accumulated value previously returned in the last invocation
	 * of the callback, or initialValue, if supplied.
	 * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.
	 * @param {number} featureIndex The current index of the Feature being processed
	 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed
	 * @param {number} geometryIndex The current index of the Geometry being processed
	 */

	/**
	 * Reduce features in any GeoJSON object, similar to Array.reduce().
	 *
	 * @name lineReduce
	 * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object
	 * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)
	 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
	 * @returns {*} The value that results from the reduction.
	 * @example
	 * var multiPoly = turf.multiPolygon([
	 *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),
	 *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])
	 * ]);
	 *
	 * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
	 *   //=previousValue
	 *   //=currentLine
	 *   //=featureIndex
	 *   //=multiFeatureIndex
	 *   //=geometryIndex
	 *   return currentLine
	 * });
	 */
	function lineReduce(geojson, callback, initialValue) {
	    var previousValue = initialValue;
	    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
	        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;
	        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);
	    });
	    return previousValue;
	}

	/**
	 * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.
	 *
	 * Negative indexes are permitted.
	 * Point & MultiPoint will always return null.
	 *
	 * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry
	 * @param {Object} [options={}] Optional parameters
	 * @param {number} [options.featureIndex=0] Feature Index
	 * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index
	 * @param {number} [options.geometryIndex=0] Geometry Index
	 * @param {number} [options.segmentIndex=0] Segment Index
	 * @param {Object} [options.properties={}] Translate Properties to output LineString
	 * @param {BBox} [options.bbox={}] Translate BBox to output LineString
	 * @param {number|string} [options.id={}] Translate Id to output LineString
	 * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString
	 * @example
	 * var multiLine = turf.multiLineString([
	 *     [[10, 10], [50, 30], [30, 40]],
	 *     [[-10, -10], [-50, -30], [-30, -40]]
	 * ]);
	 *
	 * // First Segment (defaults are 0)
	 * turf.findSegment(multiLine);
	 * // => Feature<LineString<[[10, 10], [50, 30]]>>
	 *
	 * // First Segment of 2nd Multi Feature
	 * turf.findSegment(multiLine, {multiFeatureIndex: 1});
	 * // => Feature<LineString<[[-10, -10], [-50, -30]]>>
	 *
	 * // Last Segment of Last Multi Feature
	 * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});
	 * // => Feature<LineString<[[-50, -30], [-30, -40]]>>
	 */
	function findSegment(geojson, options) {
	    // Optional Parameters
	    options = options || {};
	    if (!main$3.isObject(options)) throw new Error('options is invalid');
	    var featureIndex = options.featureIndex || 0;
	    var multiFeatureIndex = options.multiFeatureIndex || 0;
	    var geometryIndex = options.geometryIndex || 0;
	    var segmentIndex = options.segmentIndex || 0;

	    // Find FeatureIndex
	    var properties = options.properties;
	    var geometry;

	    switch (geojson.type) {
	    case 'FeatureCollection':
	        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;
	        properties = properties || geojson.features[featureIndex].properties;
	        geometry = geojson.features[featureIndex].geometry;
	        break;
	    case 'Feature':
	        properties = properties || geojson.properties;
	        geometry = geojson.geometry;
	        break;
	    case 'Point':
	    case 'MultiPoint':
	        return null;
	    case 'LineString':
	    case 'Polygon':
	    case 'MultiLineString':
	    case 'MultiPolygon':
	        geometry = geojson;
	        break;
	    default:
	        throw new Error('geojson is invalid');
	    }

	    // Find SegmentIndex
	    if (geometry === null) return null;
	    var coords = geometry.coordinates;
	    switch (geometry.type) {
	    case 'Point':
	    case 'MultiPoint':
	        return null;
	    case 'LineString':
	        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;
	        return main$3.lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);
	    case 'Polygon':
	        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;
	        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;
	        return main$3.lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);
	    case 'MultiLineString':
	        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
	        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;
	        return main$3.lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);
	    case 'MultiPolygon':
	        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
	        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
	        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;
	        return main$3.lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);
	    }
	    throw new Error('geojson is invalid');
	}

	/**
	 * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.
	 *
	 * Negative indexes are permitted.
	 *
	 * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry
	 * @param {Object} [options={}] Optional parameters
	 * @param {number} [options.featureIndex=0] Feature Index
	 * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index
	 * @param {number} [options.geometryIndex=0] Geometry Index
	 * @param {number} [options.coordIndex=0] Coord Index
	 * @param {Object} [options.properties={}] Translate Properties to output Point
	 * @param {BBox} [options.bbox={}] Translate BBox to output Point
	 * @param {number|string} [options.id={}] Translate Id to output Point
	 * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point
	 * @example
	 * var multiLine = turf.multiLineString([
	 *     [[10, 10], [50, 30], [30, 40]],
	 *     [[-10, -10], [-50, -30], [-30, -40]]
	 * ]);
	 *
	 * // First Segment (defaults are 0)
	 * turf.findPoint(multiLine);
	 * // => Feature<Point<[10, 10]>>
	 *
	 * // First Segment of the 2nd Multi-Feature
	 * turf.findPoint(multiLine, {multiFeatureIndex: 1});
	 * // => Feature<Point<[-10, -10]>>
	 *
	 * // Last Segment of last Multi-Feature
	 * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});
	 * // => Feature<Point<[-30, -40]>>
	 */
	function findPoint(geojson, options) {
	    // Optional Parameters
	    options = options || {};
	    if (!main$3.isObject(options)) throw new Error('options is invalid');
	    var featureIndex = options.featureIndex || 0;
	    var multiFeatureIndex = options.multiFeatureIndex || 0;
	    var geometryIndex = options.geometryIndex || 0;
	    var coordIndex = options.coordIndex || 0;

	    // Find FeatureIndex
	    var properties = options.properties;
	    var geometry;

	    switch (geojson.type) {
	    case 'FeatureCollection':
	        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;
	        properties = properties || geojson.features[featureIndex].properties;
	        geometry = geojson.features[featureIndex].geometry;
	        break;
	    case 'Feature':
	        properties = properties || geojson.properties;
	        geometry = geojson.geometry;
	        break;
	    case 'Point':
	    case 'MultiPoint':
	        return null;
	    case 'LineString':
	    case 'Polygon':
	    case 'MultiLineString':
	    case 'MultiPolygon':
	        geometry = geojson;
	        break;
	    default:
	        throw new Error('geojson is invalid');
	    }

	    // Find Coord Index
	    if (geometry === null) return null;
	    var coords = geometry.coordinates;
	    switch (geometry.type) {
	    case 'Point':
	        return main$3.point(coords, properties, options);
	    case 'MultiPoint':
	        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
	        return main$3.point(coords[multiFeatureIndex], properties, options);
	    case 'LineString':
	        if (coordIndex < 0) coordIndex = coords.length + coordIndex;
	        return main$3.point(coords[coordIndex], properties, options);
	    case 'Polygon':
	        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;
	        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;
	        return main$3.point(coords[geometryIndex][coordIndex], properties, options);
	    case 'MultiLineString':
	        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
	        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;
	        return main$3.point(coords[multiFeatureIndex][coordIndex], properties, options);
	    case 'MultiPolygon':
	        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
	        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
	        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;
	        return main$3.point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);
	    }
	    throw new Error('geojson is invalid');
	}

	exports.coordEach = coordEach;
	exports.coordReduce = coordReduce;
	exports.propEach = propEach;
	exports.propReduce = propReduce;
	exports.featureEach = featureEach;
	exports.featureReduce = featureReduce;
	exports.coordAll = coordAll;
	exports.geomEach = geomEach;
	exports.geomReduce = geomReduce;
	exports.flattenEach = flattenEach;
	exports.flattenReduce = flattenReduce;
	exports.segmentEach = segmentEach;
	exports.segmentReduce = segmentReduce;
	exports.lineEach = lineEach;
	exports.lineReduce = lineReduce;
	exports.findSegment = findSegment;
	exports.findPoint = findPoint;
	});

	unwrapExports(main$4);
	var main_1$3 = main$4.coordEach;
	var main_2$3 = main$4.coordReduce;
	var main_3$3 = main$4.propEach;
	var main_4$3 = main$4.propReduce;
	var main_5$3 = main$4.featureEach;
	var main_6$3 = main$4.featureReduce;
	var main_7$3 = main$4.coordAll;
	var main_8$3 = main$4.geomEach;
	var main_9$3 = main$4.geomReduce;
	var main_10$3 = main$4.flattenEach;
	var main_11$3 = main$4.flattenReduce;
	var main_12$3 = main$4.segmentEach;
	var main_13$3 = main$4.segmentReduce;
	var main_14$3 = main$4.lineEach;
	var main_15$3 = main$4.lineReduce;
	var main_16$3 = main$4.findSegment;
	var main_17$3 = main$4.findPoint;

	/**
	 * Takes one or more features and returns their area in square meters.
	 *
	 * @name area
	 * @param {GeoJSON} geojson input GeoJSON feature(s)
	 * @returns {number} area in square meters
	 * @example
	 * var polygon = turf.polygon([[[125, -15], [113, -22], [154, -27], [144, -15], [125, -15]]]);
	 *
	 * var area = turf.area(polygon);
	 *
	 * //addToMap
	 * var addToMap = [polygon]
	 * polygon.properties.area = area
	 */
	function area$1(geojson) {
	    return main$4.geomReduce(geojson, function (value, geom) {
	        return value + calculateArea(geom);
	    }, 0);
	}

	var RADIUS = 6378137;
	// var FLATTENING_DENOM = 298.257223563;
	// var FLATTENING = 1 / FLATTENING_DENOM;
	// var POLAR_RADIUS = RADIUS * (1 - FLATTENING);

	/**
	 * Calculate Area
	 *
	 * @private
	 * @param {GeoJSON} geojson GeoJSON
	 * @returns {number} area
	 */
	function calculateArea(geojson) {
	    var area = 0, i;
	    switch (geojson.type) {
	    case 'Polygon':
	        return polygonArea(geojson.coordinates);
	    case 'MultiPolygon':
	        for (i = 0; i < geojson.coordinates.length; i++) {
	            area += polygonArea(geojson.coordinates[i]);
	        }
	        return area;
	    case 'Point':
	    case 'MultiPoint':
	    case 'LineString':
	    case 'MultiLineString':
	        return 0;
	    case 'GeometryCollection':
	        for (i = 0; i < geojson.geometries.length; i++) {
	            area += calculateArea(geojson.geometries[i]);
	        }
	        return area;
	    }
	}

	function polygonArea(coords) {
	    var area = 0;
	    if (coords && coords.length > 0) {
	        area += Math.abs(ringArea(coords[0]));
	        for (var i = 1; i < coords.length; i++) {
	            area -= Math.abs(ringArea(coords[i]));
	        }
	    }
	    return area;
	}

	/**
	 * @private
	 * Calculate the approximate area of the polygon were it projected onto the earth.
	 * Note that this area will be positive if ring is oriented clockwise, otherwise it will be negative.
	 *
	 * Reference:
	 * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
	 * Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409
	 *
	 * @param {Array<Array<number>>} coords Ring Coordinates
	 * @returns {number} The approximate signed geodesic area of the polygon in square meters.
	 */
	function ringArea(coords) {
	    var p1;
	    var p2;
	    var p3;
	    var lowerIndex;
	    var middleIndex;
	    var upperIndex;
	    var i;
	    var area = 0;
	    var coordsLength = coords.length;

	    if (coordsLength > 2) {
	        for (i = 0; i < coordsLength; i++) {
	            if (i === coordsLength - 2) { // i = N-2
	                lowerIndex = coordsLength - 2;
	                middleIndex = coordsLength - 1;
	                upperIndex = 0;
	            } else if (i === coordsLength - 1) { // i = N-1
	                lowerIndex = coordsLength - 1;
	                middleIndex = 0;
	                upperIndex = 1;
	            } else { // i = 0 to N-3
	                lowerIndex = i;
	                middleIndex = i + 1;
	                upperIndex = i + 2;
	            }
	            p1 = coords[lowerIndex];
	            p2 = coords[middleIndex];
	            p3 = coords[upperIndex];
	            area += (rad(p3[0]) - rad(p1[0])) * Math.sin(rad(p2[1]));
	        }

	        area = area * RADIUS * RADIUS / 2;
	    }

	    return area;
	}

	function rad(_) {
	    return _ * Math.PI / 180;
	}

	var main$5 = area$1;
	var default_1$1 = area$1;
	main$5.default = default_1$1;

	var main$6 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, '__esModule', { value: true });

	/**
	 * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.
	 */
	var earthRadius = 6371008.8;

	/**
	 * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.
	 */
	var factors = {
	    meters: earthRadius,
	    metres: earthRadius,
	    millimeters: earthRadius * 1000,
	    millimetres: earthRadius * 1000,
	    centimeters: earthRadius * 100,
	    centimetres: earthRadius * 100,
	    kilometers: earthRadius / 1000,
	    kilometres: earthRadius / 1000,
	    miles: earthRadius / 1609.344,
	    nauticalmiles: earthRadius / 1852,
	    inches: earthRadius * 39.370,
	    yards: earthRadius / 1.0936,
	    feet: earthRadius * 3.28084,
	    radians: 1,
	    degrees: earthRadius / 111325,
	};

	/**
	 * Units of measurement factors based on 1 meter.
	 */
	var unitsFactors = {
	    meters: 1,
	    metres: 1,
	    millimeters: 1000,
	    millimetres: 1000,
	    centimeters: 100,
	    centimetres: 100,
	    kilometers: 1 / 1000,
	    kilometres: 1 / 1000,
	    miles: 1 / 1609.344,
	    nauticalmiles: 1 / 1852,
	    inches: 39.370,
	    yards: 1 / 1.0936,
	    feet: 3.28084,
	    radians: 1 / earthRadius,
	    degrees: 1 / 111325,
	};

	/**
	 * Area of measurement factors based on 1 square meter.
	 */
	var areaFactors = {
	    meters: 1,
	    metres: 1,
	    millimeters: 1000000,
	    millimetres: 1000000,
	    centimeters: 10000,
	    centimetres: 10000,
	    kilometers: 0.000001,
	    kilometres: 0.000001,
	    acres: 0.000247105,
	    miles: 3.86e-7,
	    yards: 1.195990046,
	    feet: 10.763910417,
	    inches: 1550.003100006
	};

	/**
	 * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.
	 *
	 * @name feature
	 * @param {Geometry} geometry input geometry
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature} a GeoJSON Feature
	 * @example
	 * var geometry = {
	 *   "type": "Point",
	 *   "coordinates": [110, 50]
	 * };
	 *
	 * var feature = turf.feature(geometry);
	 *
	 * //=feature
	 */
	function feature(geometry, properties, options) {
	    // Optional Parameters
	    options = options || {};
	    if (!isObject(options)) throw new Error('options is invalid');
	    var bbox = options.bbox;
	    var id = options.id;

	    // Validation
	    if (geometry === undefined) throw new Error('geometry is required');
	    if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');
	    if (bbox) validateBBox(bbox);
	    if (id) validateId(id);

	    // Main
	    var feat = {type: 'Feature'};
	    if (id) feat.id = id;
	    if (bbox) feat.bbox = bbox;
	    feat.properties = properties || {};
	    feat.geometry = geometry;
	    return feat;
	}

	/**
	 * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.
	 * For GeometryCollection type use `helpers.geometryCollection`
	 *
	 * @name geometry
	 * @param {string} type Geometry Type
	 * @param {Array<number>} coordinates Coordinates
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Geometry
	 * @returns {Geometry} a GeoJSON Geometry
	 * @example
	 * var type = 'Point';
	 * var coordinates = [110, 50];
	 *
	 * var geometry = turf.geometry(type, coordinates);
	 *
	 * //=geometry
	 */
	function geometry(type, coordinates, options) {
	    // Optional Parameters
	    options = options || {};
	    if (!isObject(options)) throw new Error('options is invalid');
	    var bbox = options.bbox;

	    // Validation
	    if (!type) throw new Error('type is required');
	    if (!coordinates) throw new Error('coordinates is required');
	    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');
	    if (bbox) validateBBox(bbox);

	    // Main
	    var geom;
	    switch (type) {
	    case 'Point': geom = point(coordinates).geometry; break;
	    case 'LineString': geom = lineString(coordinates).geometry; break;
	    case 'Polygon': geom = polygon(coordinates).geometry; break;
	    case 'MultiPoint': geom = multiPoint(coordinates).geometry; break;
	    case 'MultiLineString': geom = multiLineString(coordinates).geometry; break;
	    case 'MultiPolygon': geom = multiPolygon(coordinates).geometry; break;
	    default: throw new Error(type + ' is invalid');
	    }
	    if (bbox) geom.bbox = bbox;
	    return geom;
	}

	/**
	 * Creates a {@link Point} {@link Feature} from a Position.
	 *
	 * @name point
	 * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature<Point>} a Point feature
	 * @example
	 * var point = turf.point([-75.343, 39.984]);
	 *
	 * //=point
	 */
	function point(coordinates, properties, options) {
	    if (!coordinates) throw new Error('coordinates is required');
	    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');
	    if (coordinates.length < 2) throw new Error('coordinates must be at least 2 numbers long');
	    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) throw new Error('coordinates must contain numbers');

	    return feature({
	        type: 'Point',
	        coordinates: coordinates
	    }, properties, options);
	}

	/**
	 * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.
	 *
	 * @name points
	 * @param {Array<Array<number>>} coordinates an array of Points
	 * @param {Object} [properties={}] Translate these properties to each Feature
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection
	 * @param {string|number} [options.id] Identifier associated with the FeatureCollection
	 * @returns {FeatureCollection<Point>} Point Feature
	 * @example
	 * var points = turf.points([
	 *   [-75, 39],
	 *   [-80, 45],
	 *   [-78, 50]
	 * ]);
	 *
	 * //=points
	 */
	function points(coordinates, properties, options) {
	    if (!coordinates) throw new Error('coordinates is required');
	    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');

	    return featureCollection(coordinates.map(function (coords) {
	        return point(coords, properties);
	    }), options);
	}

	/**
	 * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.
	 *
	 * @name polygon
	 * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature<Polygon>} Polygon Feature
	 * @example
	 * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });
	 *
	 * //=polygon
	 */
	function polygon(coordinates, properties, options) {
	    if (!coordinates) throw new Error('coordinates is required');

	    for (var i = 0; i < coordinates.length; i++) {
	        var ring = coordinates[i];
	        if (ring.length < 4) {
	            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');
	        }
	        for (var j = 0; j < ring[ring.length - 1].length; j++) {
	            // Check if first point of Polygon contains two numbers
	            if (i === 0 && j === 0 && !isNumber(ring[0][0]) || !isNumber(ring[0][1])) throw new Error('coordinates must contain numbers');
	            if (ring[ring.length - 1][j] !== ring[0][j]) {
	                throw new Error('First and last Position are not equivalent.');
	            }
	        }
	    }

	    return feature({
	        type: 'Polygon',
	        coordinates: coordinates
	    }, properties, options);
	}

	/**
	 * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.
	 *
	 * @name polygons
	 * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the FeatureCollection
	 * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection
	 * @example
	 * var polygons = turf.polygons([
	 *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],
	 *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],
	 * ]);
	 *
	 * //=polygons
	 */
	function polygons(coordinates, properties, options) {
	    if (!coordinates) throw new Error('coordinates is required');
	    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');

	    return featureCollection(coordinates.map(function (coords) {
	        return polygon(coords, properties);
	    }), options);
	}

	/**
	 * Creates a {@link LineString} {@link Feature} from an Array of Positions.
	 *
	 * @name lineString
	 * @param {Array<Array<number>>} coordinates an array of Positions
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature<LineString>} LineString Feature
	 * @example
	 * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});
	 * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});
	 *
	 * //=linestring1
	 * //=linestring2
	 */
	function lineString(coordinates, properties, options) {
	    if (!coordinates) throw new Error('coordinates is required');
	    if (coordinates.length < 2) throw new Error('coordinates must be an array of two or more positions');
	    // Check if first point of LineString contains two numbers
	    if (!isNumber(coordinates[0][1]) || !isNumber(coordinates[0][1])) throw new Error('coordinates must contain numbers');

	    return feature({
	        type: 'LineString',
	        coordinates: coordinates
	    }, properties, options);
	}

	/**
	 * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.
	 *
	 * @name lineStrings
	 * @param {Array<Array<number>>} coordinates an array of LinearRings
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection
	 * @param {string|number} [options.id] Identifier associated with the FeatureCollection
	 * @returns {FeatureCollection<LineString>} LineString FeatureCollection
	 * @example
	 * var linestrings = turf.lineStrings([
	 *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],
	 *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]
	 * ]);
	 *
	 * //=linestrings
	 */
	function lineStrings(coordinates, properties, options) {
	    if (!coordinates) throw new Error('coordinates is required');
	    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');

	    return featureCollection(coordinates.map(function (coords) {
	        return lineString(coords, properties);
	    }), options);
	}

	/**
	 * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.
	 *
	 * @name featureCollection
	 * @param {Feature[]} features input features
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {FeatureCollection} FeatureCollection of Features
	 * @example
	 * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});
	 * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});
	 * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});
	 *
	 * var collection = turf.featureCollection([
	 *   locationA,
	 *   locationB,
	 *   locationC
	 * ]);
	 *
	 * //=collection
	 */
	function featureCollection(features, options) {
	    // Optional Parameters
	    options = options || {};
	    if (!isObject(options)) throw new Error('options is invalid');
	    var bbox = options.bbox;
	    var id = options.id;

	    // Validation
	    if (!features) throw new Error('No features passed');
	    if (!Array.isArray(features)) throw new Error('features must be an Array');
	    if (bbox) validateBBox(bbox);
	    if (id) validateId(id);

	    // Main
	    var fc = {type: 'FeatureCollection'};
	    if (id) fc.id = id;
	    if (bbox) fc.bbox = bbox;
	    fc.features = features;
	    return fc;
	}

	/**
	 * Creates a {@link Feature<MultiLineString>} based on a
	 * coordinate array. Properties can be added optionally.
	 *
	 * @name multiLineString
	 * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature<MultiLineString>} a MultiLineString feature
	 * @throws {Error} if no coordinates are passed
	 * @example
	 * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);
	 *
	 * //=multiLine
	 */
	function multiLineString(coordinates, properties, options) {
	    if (!coordinates) throw new Error('coordinates is required');

	    return feature({
	        type: 'MultiLineString',
	        coordinates: coordinates
	    }, properties, options);
	}

	/**
	 * Creates a {@link Feature<MultiPoint>} based on a
	 * coordinate array. Properties can be added optionally.
	 *
	 * @name multiPoint
	 * @param {Array<Array<number>>} coordinates an array of Positions
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature<MultiPoint>} a MultiPoint feature
	 * @throws {Error} if no coordinates are passed
	 * @example
	 * var multiPt = turf.multiPoint([[0,0],[10,10]]);
	 *
	 * //=multiPt
	 */
	function multiPoint(coordinates, properties, options) {
	    if (!coordinates) throw new Error('coordinates is required');

	    return feature({
	        type: 'MultiPoint',
	        coordinates: coordinates
	    }, properties, options);
	}

	/**
	 * Creates a {@link Feature<MultiPolygon>} based on a
	 * coordinate array. Properties can be added optionally.
	 *
	 * @name multiPolygon
	 * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature<MultiPolygon>} a multipolygon feature
	 * @throws {Error} if no coordinates are passed
	 * @example
	 * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);
	 *
	 * //=multiPoly
	 *
	 */
	function multiPolygon(coordinates, properties, options) {
	    if (!coordinates) throw new Error('coordinates is required');

	    return feature({
	        type: 'MultiPolygon',
	        coordinates: coordinates
	    }, properties, options);
	}

	/**
	 * Creates a {@link Feature<GeometryCollection>} based on a
	 * coordinate array. Properties can be added optionally.
	 *
	 * @name geometryCollection
	 * @param {Array<Geometry>} geometries an array of GeoJSON Geometries
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature
	 * @example
	 * var pt = {
	 *     "type": "Point",
	 *       "coordinates": [100, 0]
	 *     };
	 * var line = {
	 *     "type": "LineString",
	 *     "coordinates": [ [101, 0], [102, 1] ]
	 *   };
	 * var collection = turf.geometryCollection([pt, line]);
	 *
	 * //=collection
	 */
	function geometryCollection(geometries, properties, options) {
	    if (!geometries) throw new Error('geometries is required');
	    if (!Array.isArray(geometries)) throw new Error('geometries must be an Array');

	    return feature({
	        type: 'GeometryCollection',
	        geometries: geometries
	    }, properties, options);
	}

	/**
	 * Round number to precision
	 *
	 * @param {number} num Number
	 * @param {number} [precision=0] Precision
	 * @returns {number} rounded number
	 * @example
	 * turf.round(120.4321)
	 * //=120
	 *
	 * turf.round(120.4321, 2)
	 * //=120.43
	 */
	function round(num, precision) {
	    if (num === undefined || num === null || isNaN(num)) throw new Error('num is required');
	    if (precision && !(precision >= 0)) throw new Error('precision must be a positive number');
	    var multiplier = Math.pow(10, precision || 0);
	    return Math.round(num * multiplier) / multiplier;
	}

	/**
	 * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.
	 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
	 *
	 * @name radiansToLength
	 * @param {number} radians in radians across the sphere
	 * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.
	 * @returns {number} distance
	 */
	function radiansToLength(radians, units) {
	    if (radians === undefined || radians === null) throw new Error('radians is required');

	    if (units && typeof units !== 'string') throw new Error('units must be a string');
	    var factor = factors[units || 'kilometers'];
	    if (!factor) throw new Error(units + ' units is invalid');
	    return radians * factor;
	}

	/**
	 * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians
	 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
	 *
	 * @name lengthToRadians
	 * @param {number} distance in real units
	 * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.
	 * @returns {number} radians
	 */
	function lengthToRadians(distance, units) {
	    if (distance === undefined || distance === null) throw new Error('distance is required');

	    if (units && typeof units !== 'string') throw new Error('units must be a string');
	    var factor = factors[units || 'kilometers'];
	    if (!factor) throw new Error(units + ' units is invalid');
	    return distance / factor;
	}

	/**
	 * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees
	 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet
	 *
	 * @name lengthToDegrees
	 * @param {number} distance in real units
	 * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.
	 * @returns {number} degrees
	 */
	function lengthToDegrees(distance, units) {
	    return radiansToDegrees(lengthToRadians(distance, units));
	}

	/**
	 * Converts any bearing angle from the north line direction (positive clockwise)
	 * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line
	 *
	 * @name bearingToAzimuth
	 * @param {number} bearing angle, between -180 and +180 degrees
	 * @returns {number} angle between 0 and 360 degrees
	 */
	function bearingToAzimuth(bearing) {
	    if (bearing === null || bearing === undefined) throw new Error('bearing is required');

	    var angle = bearing % 360;
	    if (angle < 0) angle += 360;
	    return angle;
	}

	/**
	 * Converts an angle in radians to degrees
	 *
	 * @name radiansToDegrees
	 * @param {number} radians angle in radians
	 * @returns {number} degrees between 0 and 360 degrees
	 */
	function radiansToDegrees(radians) {
	    if (radians === null || radians === undefined) throw new Error('radians is required');

	    var degrees = radians % (2 * Math.PI);
	    return degrees * 180 / Math.PI;
	}

	/**
	 * Converts an angle in degrees to radians
	 *
	 * @name degreesToRadians
	 * @param {number} degrees angle between 0 and 360 degrees
	 * @returns {number} angle in radians
	 */
	function degreesToRadians(degrees) {
	    if (degrees === null || degrees === undefined) throw new Error('degrees is required');

	    var radians = degrees % 360;
	    return radians * Math.PI / 180;
	}

	/**
	 * Converts a length to the requested unit.
	 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
	 *
	 * @param {number} length to be converted
	 * @param {string} originalUnit of the length
	 * @param {string} [finalUnit='kilometers'] returned unit
	 * @returns {number} the converted length
	 */
	function convertLength(length, originalUnit, finalUnit) {
	    if (length === null || length === undefined) throw new Error('length is required');
	    if (!(length >= 0)) throw new Error('length must be a positive number');

	    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit || 'kilometers');
	}

	/**
	 * Converts a area to the requested unit.
	 * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches
	 * @param {number} area to be converted
	 * @param {string} [originalUnit='meters'] of the distance
	 * @param {string} [finalUnit='kilometers'] returned unit
	 * @returns {number} the converted distance
	 */
	function convertArea(area, originalUnit, finalUnit) {
	    if (area === null || area === undefined) throw new Error('area is required');
	    if (!(area >= 0)) throw new Error('area must be a positive number');

	    var startFactor = areaFactors[originalUnit || 'meters'];
	    if (!startFactor) throw new Error('invalid original units');

	    var finalFactor = areaFactors[finalUnit || 'kilometers'];
	    if (!finalFactor) throw new Error('invalid final units');

	    return (area / startFactor) * finalFactor;
	}

	/**
	 * isNumber
	 *
	 * @param {*} num Number to validate
	 * @returns {boolean} true/false
	 * @example
	 * turf.isNumber(123)
	 * //=true
	 * turf.isNumber('foo')
	 * //=false
	 */
	function isNumber(num) {
	    return !isNaN(num) && num !== null && !Array.isArray(num);
	}

	/**
	 * isObject
	 *
	 * @param {*} input variable to validate
	 * @returns {boolean} true/false
	 * @example
	 * turf.isObject({elevation: 10})
	 * //=true
	 * turf.isObject('foo')
	 * //=false
	 */
	function isObject(input) {
	    return (!!input) && (input.constructor === Object);
	}

	/**
	 * Validate BBox
	 *
	 * @private
	 * @param {Array<number>} bbox BBox to validate
	 * @returns {void}
	 * @throws Error if BBox is not valid
	 * @example
	 * validateBBox([-180, -40, 110, 50])
	 * //=OK
	 * validateBBox([-180, -40])
	 * //=Error
	 * validateBBox('Foo')
	 * //=Error
	 * validateBBox(5)
	 * //=Error
	 * validateBBox(null)
	 * //=Error
	 * validateBBox(undefined)
	 * //=Error
	 */
	function validateBBox(bbox) {
	    if (!bbox) throw new Error('bbox is required');
	    if (!Array.isArray(bbox)) throw new Error('bbox must be an Array');
	    if (bbox.length !== 4 && bbox.length !== 6) throw new Error('bbox must be an Array of 4 or 6 numbers');
	    bbox.forEach(function (num) {
	        if (!isNumber(num)) throw new Error('bbox must only contain numbers');
	    });
	}

	/**
	 * Validate Id
	 *
	 * @private
	 * @param {string|number} id Id to validate
	 * @returns {void}
	 * @throws Error if Id is not valid
	 * @example
	 * validateId([-180, -40, 110, 50])
	 * //=Error
	 * validateId([-180, -40])
	 * //=Error
	 * validateId('Foo')
	 * //=OK
	 * validateId(5)
	 * //=OK
	 * validateId(null)
	 * //=Error
	 * validateId(undefined)
	 * //=Error
	 */
	function validateId(id) {
	    if (!id) throw new Error('id is required');
	    if (['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');
	}

	// Deprecated methods
	function radians2degrees() {
	    throw new Error('method has been renamed to `radiansToDegrees`');
	}

	function degrees2radians() {
	    throw new Error('method has been renamed to `degreesToRadians`');
	}

	function distanceToDegrees() {
	    throw new Error('method has been renamed to `lengthToDegrees`');
	}

	function distanceToRadians() {
	    throw new Error('method has been renamed to `lengthToRadians`');
	}

	function radiansToDistance() {
	    throw new Error('method has been renamed to `radiansToLength`');
	}

	function bearingToAngle() {
	    throw new Error('method has been renamed to `bearingToAzimuth`');
	}

	function convertDistance() {
	    throw new Error('method has been renamed to `convertLength`');
	}

	exports.earthRadius = earthRadius;
	exports.factors = factors;
	exports.unitsFactors = unitsFactors;
	exports.areaFactors = areaFactors;
	exports.feature = feature;
	exports.geometry = geometry;
	exports.point = point;
	exports.points = points;
	exports.polygon = polygon;
	exports.polygons = polygons;
	exports.lineString = lineString;
	exports.lineStrings = lineStrings;
	exports.featureCollection = featureCollection;
	exports.multiLineString = multiLineString;
	exports.multiPoint = multiPoint;
	exports.multiPolygon = multiPolygon;
	exports.geometryCollection = geometryCollection;
	exports.round = round;
	exports.radiansToLength = radiansToLength;
	exports.lengthToRadians = lengthToRadians;
	exports.lengthToDegrees = lengthToDegrees;
	exports.bearingToAzimuth = bearingToAzimuth;
	exports.radiansToDegrees = radiansToDegrees;
	exports.degreesToRadians = degreesToRadians;
	exports.convertLength = convertLength;
	exports.convertArea = convertArea;
	exports.isNumber = isNumber;
	exports.isObject = isObject;
	exports.validateBBox = validateBBox;
	exports.validateId = validateId;
	exports.radians2degrees = radians2degrees;
	exports.degrees2radians = degrees2radians;
	exports.distanceToDegrees = distanceToDegrees;
	exports.distanceToRadians = distanceToRadians;
	exports.radiansToDistance = radiansToDistance;
	exports.bearingToAngle = bearingToAngle;
	exports.convertDistance = convertDistance;
	});

	unwrapExports(main$6);
	var main_1$4 = main$6.earthRadius;
	var main_2$4 = main$6.factors;
	var main_3$4 = main$6.unitsFactors;
	var main_4$4 = main$6.areaFactors;
	var main_5$4 = main$6.feature;
	var main_6$4 = main$6.geometry;
	var main_7$4 = main$6.point;
	var main_8$4 = main$6.points;
	var main_9$4 = main$6.polygon;
	var main_10$4 = main$6.polygons;
	var main_11$4 = main$6.lineString;
	var main_12$4 = main$6.lineStrings;
	var main_13$4 = main$6.featureCollection;
	var main_14$4 = main$6.multiLineString;
	var main_15$4 = main$6.multiPoint;
	var main_16$4 = main$6.multiPolygon;
	var main_17$4 = main$6.geometryCollection;
	var main_18$2 = main$6.round;
	var main_19$2 = main$6.radiansToLength;
	var main_20$2 = main$6.lengthToRadians;
	var main_21$2 = main$6.lengthToDegrees;
	var main_22$2 = main$6.bearingToAzimuth;
	var main_23$2 = main$6.radiansToDegrees;
	var main_24$2 = main$6.degreesToRadians;
	var main_25$2 = main$6.convertLength;
	var main_26$2 = main$6.convertArea;
	var main_27$2 = main$6.isNumber;
	var main_28$2 = main$6.isObject;
	var main_29$2 = main$6.validateBBox;
	var main_30$2 = main$6.validateId;
	var main_31$2 = main$6.radians2degrees;
	var main_32$2 = main$6.degrees2radians;
	var main_33$2 = main$6.distanceToDegrees;
	var main_34$2 = main$6.distanceToRadians;
	var main_35$2 = main$6.radiansToDistance;
	var main_36$2 = main$6.bearingToAngle;
	var main_37$2 = main$6.convertDistance;

	var main$7 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, '__esModule', { value: true });



	/**
	 * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.
	 *
	 * @name getCoord
	 * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers
	 * @returns {Array<number>} coordinates
	 * @example
	 * var pt = turf.point([10, 10]);
	 *
	 * var coord = turf.getCoord(pt);
	 * //= [10, 10]
	 */
	function getCoord(coord) {
	    if (!coord) throw new Error('coord is required');
	    if (coord.type === 'Feature' && coord.geometry !== null && coord.geometry.type === 'Point') return coord.geometry.coordinates;
	    if (coord.type === 'Point') return coord.coordinates;
	    if (Array.isArray(coord) && coord.length >= 2 && coord[0].length === undefined && coord[1].length === undefined) return coord;

	    throw new Error('coord must be GeoJSON Point or an Array of numbers');
	}

	/**
	 * Unwrap coordinates from a Feature, Geometry Object or an Array
	 *
	 * @name getCoords
	 * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array
	 * @returns {Array<any>} coordinates
	 * @example
	 * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);
	 *
	 * var coords = turf.getCoords(poly);
	 * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]
	 */
	function getCoords(coords) {
	    if (!coords) throw new Error('coords is required');

	    // Feature
	    if (coords.type === 'Feature' && coords.geometry !== null) return coords.geometry.coordinates;

	    // Geometry
	    if (coords.coordinates) return coords.coordinates;

	    // Array of numbers
	    if (Array.isArray(coords)) return coords;

	    throw new Error('coords must be GeoJSON Feature, Geometry Object or an Array');
	}

	/**
	 * Checks if coordinates contains a number
	 *
	 * @name containsNumber
	 * @param {Array<any>} coordinates GeoJSON Coordinates
	 * @returns {boolean} true if Array contains a number
	 */
	function containsNumber(coordinates) {
	    if (coordinates.length > 1 && main$6.isNumber(coordinates[0]) && main$6.isNumber(coordinates[1])) {
	        return true;
	    }

	    if (Array.isArray(coordinates[0]) && coordinates[0].length) {
	        return containsNumber(coordinates[0]);
	    }
	    throw new Error('coordinates must only contain numbers');
	}

	/**
	 * Enforce expectations about types of GeoJSON objects for Turf.
	 *
	 * @name geojsonType
	 * @param {GeoJSON} value any GeoJSON object
	 * @param {string} type expected GeoJSON type
	 * @param {string} name name of calling function
	 * @throws {Error} if value is not the expected type.
	 */
	function geojsonType(value, type, name) {
	    if (!type || !name) throw new Error('type and name required');

	    if (!value || value.type !== type) {
	        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + value.type);
	    }
	}

	/**
	 * Enforce expectations about types of {@link Feature} inputs for Turf.
	 * Internally this uses {@link geojsonType} to judge geometry types.
	 *
	 * @name featureOf
	 * @param {Feature} feature a feature with an expected geometry type
	 * @param {string} type expected GeoJSON type
	 * @param {string} name name of calling function
	 * @throws {Error} error if value is not the expected type.
	 */
	function featureOf(feature, type, name) {
	    if (!feature) throw new Error('No feature passed');
	    if (!name) throw new Error('.featureOf() requires a name');
	    if (!feature || feature.type !== 'Feature' || !feature.geometry) {
	        throw new Error('Invalid input to ' + name + ', Feature with geometry required');
	    }
	    if (!feature.geometry || feature.geometry.type !== type) {
	        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);
	    }
	}

	/**
	 * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.
	 * Internally this uses {@link geojsonType} to judge geometry types.
	 *
	 * @name collectionOf
	 * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged
	 * @param {string} type expected GeoJSON type
	 * @param {string} name name of calling function
	 * @throws {Error} if value is not the expected type.
	 */
	function collectionOf(featureCollection, type, name) {
	    if (!featureCollection) throw new Error('No featureCollection passed');
	    if (!name) throw new Error('.collectionOf() requires a name');
	    if (!featureCollection || featureCollection.type !== 'FeatureCollection') {
	        throw new Error('Invalid input to ' + name + ', FeatureCollection required');
	    }
	    for (var i = 0; i < featureCollection.features.length; i++) {
	        var feature = featureCollection.features[i];
	        if (!feature || feature.type !== 'Feature' || !feature.geometry) {
	            throw new Error('Invalid input to ' + name + ', Feature with geometry required');
	        }
	        if (!feature.geometry || feature.geometry.type !== type) {
	            throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);
	        }
	    }
	}

	/**
	 * Get Geometry from Feature or Geometry Object
	 *
	 * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object
	 * @returns {Geometry|null} GeoJSON Geometry Object
	 * @throws {Error} if geojson is not a Feature or Geometry Object
	 * @example
	 * var point = {
	 *   "type": "Feature",
	 *   "properties": {},
	 *   "geometry": {
	 *     "type": "Point",
	 *     "coordinates": [110, 40]
	 *   }
	 * }
	 * var geom = turf.getGeom(point)
	 * //={"type": "Point", "coordinates": [110, 40]}
	 */
	function getGeom(geojson) {
	    if (!geojson) throw new Error('geojson is required');
	    if (geojson.geometry !== undefined) return geojson.geometry;
	    if (geojson.coordinates || geojson.geometries) return geojson;
	    throw new Error('geojson must be a valid Feature or Geometry Object');
	}

	/**
	 * Get Geometry Type from Feature or Geometry Object
	 *
	 * @throws {Error} **DEPRECATED** in v5.0.0 in favor of getType
	 */
	function getGeomType() {
	    throw new Error('invariant.getGeomType has been deprecated in v5.0 in favor of invariant.getType');
	}

	/**
	 * Get GeoJSON object's type, Geometry type is prioritize.
	 *
	 * @param {GeoJSON} geojson GeoJSON object
	 * @param {string} [name="geojson"] name of the variable to display in error message
	 * @returns {string} GeoJSON type
	 * @example
	 * var point = {
	 *   "type": "Feature",
	 *   "properties": {},
	 *   "geometry": {
	 *     "type": "Point",
	 *     "coordinates": [110, 40]
	 *   }
	 * }
	 * var geom = turf.getType(point)
	 * //="Point"
	 */
	function getType(geojson, name) {
	    if (!geojson) throw new Error((name || 'geojson') + ' is required');
	    // GeoJSON Feature & GeometryCollection
	    if (geojson.geometry && geojson.geometry.type) return geojson.geometry.type;
	    // GeoJSON Geometry & FeatureCollection
	    if (geojson.type) return geojson.type;
	    throw new Error((name || 'geojson') + ' is invalid');
	}

	exports.getCoord = getCoord;
	exports.getCoords = getCoords;
	exports.containsNumber = containsNumber;
	exports.geojsonType = geojsonType;
	exports.featureOf = featureOf;
	exports.collectionOf = collectionOf;
	exports.getGeom = getGeom;
	exports.getGeomType = getGeomType;
	exports.getType = getType;
	});

	unwrapExports(main$7);
	var main_1$5 = main$7.getCoord;
	var main_2$5 = main$7.getCoords;
	var main_3$5 = main$7.containsNumber;
	var main_4$5 = main$7.geojsonType;
	var main_5$5 = main$7.featureOf;
	var main_6$5 = main$7.collectionOf;
	var main_7$5 = main$7.getGeom;
	var main_8$5 = main$7.getGeomType;
	var main_9$5 = main$7.getType;

	// http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule
	// modified from: https://github.com/substack/point-in-polygon/blob/master/index.js
	// which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html

	/**
	 * Takes a {@link Point} and a {@link Polygon} or {@link MultiPolygon} and determines if the point resides inside the polygon. The polygon can
	 * be convex or concave. The function accounts for holes.
	 *
	 * @name booleanPointInPolygon
	 * @param {Coord} point input point
	 * @param {Feature<Polygon|MultiPolygon>} polygon input polygon or multipolygon
	 * @param {Object} [options={}] Optional parameters
	 * @param {boolean} [options.ignoreBoundary=false] True if polygon boundary should be ignored when determining if the point is inside the polygon otherwise false.
	 * @returns {boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon
	 * @example
	 * var pt = turf.point([-77, 44]);
	 * var poly = turf.polygon([[
	 *   [-81, 41],
	 *   [-81, 47],
	 *   [-72, 47],
	 *   [-72, 41],
	 *   [-81, 41]
	 * ]]);
	 *
	 * turf.booleanPointInPolygon(pt, poly);
	 * //= true
	 */
	function booleanPointInPolygon(point, polygon, options) {
	    // Optional parameters
	    options = options || {};
	    if (typeof options !== 'object') throw new Error('options is invalid');
	    var ignoreBoundary = options.ignoreBoundary;

	    // validation
	    if (!point) throw new Error('point is required');
	    if (!polygon) throw new Error('polygon is required');

	    var pt = main$7.getCoord(point);
	    var polys = main$7.getCoords(polygon);
	    var type = (polygon.geometry) ? polygon.geometry.type : polygon.type;
	    var bbox = polygon.bbox;

	    // Quick elimination if point is not inside bbox
	    if (bbox && inBBox(pt, bbox) === false) return false;

	    // normalize to multipolygon
	    if (type === 'Polygon') polys = [polys];

	    for (var i = 0, insidePoly = false; i < polys.length && !insidePoly; i++) {
	        // check if it is in the outer ring first
	        if (inRing(pt, polys[i][0], ignoreBoundary)) {
	            var inHole = false;
	            var k = 1;
	            // check for the point in any of the holes
	            while (k < polys[i].length && !inHole) {
	                if (inRing(pt, polys[i][k], !ignoreBoundary)) {
	                    inHole = true;
	                }
	                k++;
	            }
	            if (!inHole) insidePoly = true;
	        }
	    }
	    return insidePoly;
	}

	/**
	 * inRing
	 *
	 * @private
	 * @param {Array<number>} pt [x,y]
	 * @param {Array<Array<number>>} ring [[x,y], [x,y],..]
	 * @param {boolean} ignoreBoundary ignoreBoundary
	 * @returns {boolean} inRing
	 */
	function inRing(pt, ring, ignoreBoundary) {
	    var isInside = false;
	    if (ring[0][0] === ring[ring.length - 1][0] && ring[0][1] === ring[ring.length - 1][1]) ring = ring.slice(0, ring.length - 1);

	    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
	        var xi = ring[i][0], yi = ring[i][1];
	        var xj = ring[j][0], yj = ring[j][1];
	        var onBoundary = (pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0) &&
	            ((xi - pt[0]) * (xj - pt[0]) <= 0) && ((yi - pt[1]) * (yj - pt[1]) <= 0);
	        if (onBoundary) return !ignoreBoundary;
	        var intersect = ((yi > pt[1]) !== (yj > pt[1])) &&
	        (pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi);
	        if (intersect) isInside = !isInside;
	    }
	    return isInside;
	}

	/**
	 * inBBox
	 *
	 * @private
	 * @param {Position} pt point [x,y]
	 * @param {BBox} bbox BBox [west, south, east, north]
	 * @returns {boolean} true/false if point is inside BBox
	 */
	function inBBox(pt, bbox) {
	    return bbox[0] <= pt[0] &&
	           bbox[1] <= pt[1] &&
	           bbox[2] >= pt[0] &&
	           bbox[3] >= pt[1];
	}

	var main$8 = booleanPointInPolygon;
	var default_1$2 = booleanPointInPolygon;
	main$8.default = default_1$2;

	var main$9 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, '__esModule', { value: true });

	/**
	 * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.
	 */
	var earthRadius = 6371008.8;

	/**
	 * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.
	 */
	var factors = {
	    meters: earthRadius,
	    metres: earthRadius,
	    millimeters: earthRadius * 1000,
	    millimetres: earthRadius * 1000,
	    centimeters: earthRadius * 100,
	    centimetres: earthRadius * 100,
	    kilometers: earthRadius / 1000,
	    kilometres: earthRadius / 1000,
	    miles: earthRadius / 1609.344,
	    nauticalmiles: earthRadius / 1852,
	    inches: earthRadius * 39.370,
	    yards: earthRadius / 1.0936,
	    feet: earthRadius * 3.28084,
	    radians: 1,
	    degrees: earthRadius / 111325,
	};

	/**
	 * Units of measurement factors based on 1 meter.
	 */
	var unitsFactors = {
	    meters: 1,
	    metres: 1,
	    millimeters: 1000,
	    millimetres: 1000,
	    centimeters: 100,
	    centimetres: 100,
	    kilometers: 1 / 1000,
	    kilometres: 1 / 1000,
	    miles: 1 / 1609.344,
	    nauticalmiles: 1 / 1852,
	    inches: 39.370,
	    yards: 1 / 1.0936,
	    feet: 3.28084,
	    radians: 1 / earthRadius,
	    degrees: 1 / 111325,
	};

	/**
	 * Area of measurement factors based on 1 square meter.
	 */
	var areaFactors = {
	    meters: 1,
	    metres: 1,
	    millimeters: 1000000,
	    millimetres: 1000000,
	    centimeters: 10000,
	    centimetres: 10000,
	    kilometers: 0.000001,
	    kilometres: 0.000001,
	    acres: 0.000247105,
	    miles: 3.86e-7,
	    yards: 1.195990046,
	    feet: 10.763910417,
	    inches: 1550.003100006
	};

	/**
	 * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.
	 *
	 * @name feature
	 * @param {Geometry} geometry input geometry
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature} a GeoJSON Feature
	 * @example
	 * var geometry = {
	 *   "type": "Point",
	 *   "coordinates": [110, 50]
	 * };
	 *
	 * var feature = turf.feature(geometry);
	 *
	 * //=feature
	 */
	function feature(geometry, properties, options) {
	    // Optional Parameters
	    options = options || {};
	    if (!isObject(options)) throw new Error('options is invalid');
	    var bbox = options.bbox;
	    var id = options.id;

	    // Validation
	    if (geometry === undefined) throw new Error('geometry is required');
	    if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');
	    if (bbox) validateBBox(bbox);
	    if (id) validateId(id);

	    // Main
	    var feat = {type: 'Feature'};
	    if (id) feat.id = id;
	    if (bbox) feat.bbox = bbox;
	    feat.properties = properties || {};
	    feat.geometry = geometry;
	    return feat;
	}

	/**
	 * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.
	 * For GeometryCollection type use `helpers.geometryCollection`
	 *
	 * @name geometry
	 * @param {string} type Geometry Type
	 * @param {Array<number>} coordinates Coordinates
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Geometry
	 * @returns {Geometry} a GeoJSON Geometry
	 * @example
	 * var type = 'Point';
	 * var coordinates = [110, 50];
	 *
	 * var geometry = turf.geometry(type, coordinates);
	 *
	 * //=geometry
	 */
	function geometry(type, coordinates, options) {
	    // Optional Parameters
	    options = options || {};
	    if (!isObject(options)) throw new Error('options is invalid');
	    var bbox = options.bbox;

	    // Validation
	    if (!type) throw new Error('type is required');
	    if (!coordinates) throw new Error('coordinates is required');
	    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');
	    if (bbox) validateBBox(bbox);

	    // Main
	    var geom;
	    switch (type) {
	    case 'Point': geom = point(coordinates).geometry; break;
	    case 'LineString': geom = lineString(coordinates).geometry; break;
	    case 'Polygon': geom = polygon(coordinates).geometry; break;
	    case 'MultiPoint': geom = multiPoint(coordinates).geometry; break;
	    case 'MultiLineString': geom = multiLineString(coordinates).geometry; break;
	    case 'MultiPolygon': geom = multiPolygon(coordinates).geometry; break;
	    default: throw new Error(type + ' is invalid');
	    }
	    if (bbox) geom.bbox = bbox;
	    return geom;
	}

	/**
	 * Creates a {@link Point} {@link Feature} from a Position.
	 *
	 * @name point
	 * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature<Point>} a Point feature
	 * @example
	 * var point = turf.point([-75.343, 39.984]);
	 *
	 * //=point
	 */
	function point(coordinates, properties, options) {
	    if (!coordinates) throw new Error('coordinates is required');
	    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');
	    if (coordinates.length < 2) throw new Error('coordinates must be at least 2 numbers long');
	    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) throw new Error('coordinates must contain numbers');

	    return feature({
	        type: 'Point',
	        coordinates: coordinates
	    }, properties, options);
	}

	/**
	 * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.
	 *
	 * @name points
	 * @param {Array<Array<number>>} coordinates an array of Points
	 * @param {Object} [properties={}] Translate these properties to each Feature
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection
	 * @param {string|number} [options.id] Identifier associated with the FeatureCollection
	 * @returns {FeatureCollection<Point>} Point Feature
	 * @example
	 * var points = turf.points([
	 *   [-75, 39],
	 *   [-80, 45],
	 *   [-78, 50]
	 * ]);
	 *
	 * //=points
	 */
	function points(coordinates, properties, options) {
	    if (!coordinates) throw new Error('coordinates is required');
	    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');

	    return featureCollection(coordinates.map(function (coords) {
	        return point(coords, properties);
	    }), options);
	}

	/**
	 * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.
	 *
	 * @name polygon
	 * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature<Polygon>} Polygon Feature
	 * @example
	 * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });
	 *
	 * //=polygon
	 */
	function polygon(coordinates, properties, options) {
	    if (!coordinates) throw new Error('coordinates is required');

	    for (var i = 0; i < coordinates.length; i++) {
	        var ring = coordinates[i];
	        if (ring.length < 4) {
	            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');
	        }
	        for (var j = 0; j < ring[ring.length - 1].length; j++) {
	            // Check if first point of Polygon contains two numbers
	            if (i === 0 && j === 0 && !isNumber(ring[0][0]) || !isNumber(ring[0][1])) throw new Error('coordinates must contain numbers');
	            if (ring[ring.length - 1][j] !== ring[0][j]) {
	                throw new Error('First and last Position are not equivalent.');
	            }
	        }
	    }

	    return feature({
	        type: 'Polygon',
	        coordinates: coordinates
	    }, properties, options);
	}

	/**
	 * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.
	 *
	 * @name polygons
	 * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the FeatureCollection
	 * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection
	 * @example
	 * var polygons = turf.polygons([
	 *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],
	 *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],
	 * ]);
	 *
	 * //=polygons
	 */
	function polygons(coordinates, properties, options) {
	    if (!coordinates) throw new Error('coordinates is required');
	    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');

	    return featureCollection(coordinates.map(function (coords) {
	        return polygon(coords, properties);
	    }), options);
	}

	/**
	 * Creates a {@link LineString} {@link Feature} from an Array of Positions.
	 *
	 * @name lineString
	 * @param {Array<Array<number>>} coordinates an array of Positions
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature<LineString>} LineString Feature
	 * @example
	 * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});
	 * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});
	 *
	 * //=linestring1
	 * //=linestring2
	 */
	function lineString(coordinates, properties, options) {
	    if (!coordinates) throw new Error('coordinates is required');
	    if (coordinates.length < 2) throw new Error('coordinates must be an array of two or more positions');
	    // Check if first point of LineString contains two numbers
	    if (!isNumber(coordinates[0][1]) || !isNumber(coordinates[0][1])) throw new Error('coordinates must contain numbers');

	    return feature({
	        type: 'LineString',
	        coordinates: coordinates
	    }, properties, options);
	}

	/**
	 * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.
	 *
	 * @name lineStrings
	 * @param {Array<Array<number>>} coordinates an array of LinearRings
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection
	 * @param {string|number} [options.id] Identifier associated with the FeatureCollection
	 * @returns {FeatureCollection<LineString>} LineString FeatureCollection
	 * @example
	 * var linestrings = turf.lineStrings([
	 *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],
	 *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]
	 * ]);
	 *
	 * //=linestrings
	 */
	function lineStrings(coordinates, properties, options) {
	    if (!coordinates) throw new Error('coordinates is required');
	    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');

	    return featureCollection(coordinates.map(function (coords) {
	        return lineString(coords, properties);
	    }), options);
	}

	/**
	 * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.
	 *
	 * @name featureCollection
	 * @param {Feature[]} features input features
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {FeatureCollection} FeatureCollection of Features
	 * @example
	 * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});
	 * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});
	 * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});
	 *
	 * var collection = turf.featureCollection([
	 *   locationA,
	 *   locationB,
	 *   locationC
	 * ]);
	 *
	 * //=collection
	 */
	function featureCollection(features, options) {
	    // Optional Parameters
	    options = options || {};
	    if (!isObject(options)) throw new Error('options is invalid');
	    var bbox = options.bbox;
	    var id = options.id;

	    // Validation
	    if (!features) throw new Error('No features passed');
	    if (!Array.isArray(features)) throw new Error('features must be an Array');
	    if (bbox) validateBBox(bbox);
	    if (id) validateId(id);

	    // Main
	    var fc = {type: 'FeatureCollection'};
	    if (id) fc.id = id;
	    if (bbox) fc.bbox = bbox;
	    fc.features = features;
	    return fc;
	}

	/**
	 * Creates a {@link Feature<MultiLineString>} based on a
	 * coordinate array. Properties can be added optionally.
	 *
	 * @name multiLineString
	 * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature<MultiLineString>} a MultiLineString feature
	 * @throws {Error} if no coordinates are passed
	 * @example
	 * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);
	 *
	 * //=multiLine
	 */
	function multiLineString(coordinates, properties, options) {
	    if (!coordinates) throw new Error('coordinates is required');

	    return feature({
	        type: 'MultiLineString',
	        coordinates: coordinates
	    }, properties, options);
	}

	/**
	 * Creates a {@link Feature<MultiPoint>} based on a
	 * coordinate array. Properties can be added optionally.
	 *
	 * @name multiPoint
	 * @param {Array<Array<number>>} coordinates an array of Positions
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature<MultiPoint>} a MultiPoint feature
	 * @throws {Error} if no coordinates are passed
	 * @example
	 * var multiPt = turf.multiPoint([[0,0],[10,10]]);
	 *
	 * //=multiPt
	 */
	function multiPoint(coordinates, properties, options) {
	    if (!coordinates) throw new Error('coordinates is required');

	    return feature({
	        type: 'MultiPoint',
	        coordinates: coordinates
	    }, properties, options);
	}

	/**
	 * Creates a {@link Feature<MultiPolygon>} based on a
	 * coordinate array. Properties can be added optionally.
	 *
	 * @name multiPolygon
	 * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature<MultiPolygon>} a multipolygon feature
	 * @throws {Error} if no coordinates are passed
	 * @example
	 * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);
	 *
	 * //=multiPoly
	 *
	 */
	function multiPolygon(coordinates, properties, options) {
	    if (!coordinates) throw new Error('coordinates is required');

	    return feature({
	        type: 'MultiPolygon',
	        coordinates: coordinates
	    }, properties, options);
	}

	/**
	 * Creates a {@link Feature<GeometryCollection>} based on a
	 * coordinate array. Properties can be added optionally.
	 *
	 * @name geometryCollection
	 * @param {Array<Geometry>} geometries an array of GeoJSON Geometries
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature
	 * @example
	 * var pt = {
	 *     "type": "Point",
	 *       "coordinates": [100, 0]
	 *     };
	 * var line = {
	 *     "type": "LineString",
	 *     "coordinates": [ [101, 0], [102, 1] ]
	 *   };
	 * var collection = turf.geometryCollection([pt, line]);
	 *
	 * //=collection
	 */
	function geometryCollection(geometries, properties, options) {
	    if (!geometries) throw new Error('geometries is required');
	    if (!Array.isArray(geometries)) throw new Error('geometries must be an Array');

	    return feature({
	        type: 'GeometryCollection',
	        geometries: geometries
	    }, properties, options);
	}

	/**
	 * Round number to precision
	 *
	 * @param {number} num Number
	 * @param {number} [precision=0] Precision
	 * @returns {number} rounded number
	 * @example
	 * turf.round(120.4321)
	 * //=120
	 *
	 * turf.round(120.4321, 2)
	 * //=120.43
	 */
	function round(num, precision) {
	    if (num === undefined || num === null || isNaN(num)) throw new Error('num is required');
	    if (precision && !(precision >= 0)) throw new Error('precision must be a positive number');
	    var multiplier = Math.pow(10, precision || 0);
	    return Math.round(num * multiplier) / multiplier;
	}

	/**
	 * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.
	 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
	 *
	 * @name radiansToLength
	 * @param {number} radians in radians across the sphere
	 * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.
	 * @returns {number} distance
	 */
	function radiansToLength(radians, units) {
	    if (radians === undefined || radians === null) throw new Error('radians is required');

	    if (units && typeof units !== 'string') throw new Error('units must be a string');
	    var factor = factors[units || 'kilometers'];
	    if (!factor) throw new Error(units + ' units is invalid');
	    return radians * factor;
	}

	/**
	 * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians
	 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
	 *
	 * @name lengthToRadians
	 * @param {number} distance in real units
	 * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.
	 * @returns {number} radians
	 */
	function lengthToRadians(distance, units) {
	    if (distance === undefined || distance === null) throw new Error('distance is required');

	    if (units && typeof units !== 'string') throw new Error('units must be a string');
	    var factor = factors[units || 'kilometers'];
	    if (!factor) throw new Error(units + ' units is invalid');
	    return distance / factor;
	}

	/**
	 * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees
	 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet
	 *
	 * @name lengthToDegrees
	 * @param {number} distance in real units
	 * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.
	 * @returns {number} degrees
	 */
	function lengthToDegrees(distance, units) {
	    return radiansToDegrees(lengthToRadians(distance, units));
	}

	/**
	 * Converts any bearing angle from the north line direction (positive clockwise)
	 * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line
	 *
	 * @name bearingToAzimuth
	 * @param {number} bearing angle, between -180 and +180 degrees
	 * @returns {number} angle between 0 and 360 degrees
	 */
	function bearingToAzimuth(bearing) {
	    if (bearing === null || bearing === undefined) throw new Error('bearing is required');

	    var angle = bearing % 360;
	    if (angle < 0) angle += 360;
	    return angle;
	}

	/**
	 * Converts an angle in radians to degrees
	 *
	 * @name radiansToDegrees
	 * @param {number} radians angle in radians
	 * @returns {number} degrees between 0 and 360 degrees
	 */
	function radiansToDegrees(radians) {
	    if (radians === null || radians === undefined) throw new Error('radians is required');

	    var degrees = radians % (2 * Math.PI);
	    return degrees * 180 / Math.PI;
	}

	/**
	 * Converts an angle in degrees to radians
	 *
	 * @name degreesToRadians
	 * @param {number} degrees angle between 0 and 360 degrees
	 * @returns {number} angle in radians
	 */
	function degreesToRadians(degrees) {
	    if (degrees === null || degrees === undefined) throw new Error('degrees is required');

	    var radians = degrees % 360;
	    return radians * Math.PI / 180;
	}

	/**
	 * Converts a length to the requested unit.
	 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
	 *
	 * @param {number} length to be converted
	 * @param {string} originalUnit of the length
	 * @param {string} [finalUnit='kilometers'] returned unit
	 * @returns {number} the converted length
	 */
	function convertLength(length, originalUnit, finalUnit) {
	    if (length === null || length === undefined) throw new Error('length is required');
	    if (!(length >= 0)) throw new Error('length must be a positive number');

	    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit || 'kilometers');
	}

	/**
	 * Converts a area to the requested unit.
	 * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches
	 * @param {number} area to be converted
	 * @param {string} [originalUnit='meters'] of the distance
	 * @param {string} [finalUnit='kilometers'] returned unit
	 * @returns {number} the converted distance
	 */
	function convertArea(area, originalUnit, finalUnit) {
	    if (area === null || area === undefined) throw new Error('area is required');
	    if (!(area >= 0)) throw new Error('area must be a positive number');

	    var startFactor = areaFactors[originalUnit || 'meters'];
	    if (!startFactor) throw new Error('invalid original units');

	    var finalFactor = areaFactors[finalUnit || 'kilometers'];
	    if (!finalFactor) throw new Error('invalid final units');

	    return (area / startFactor) * finalFactor;
	}

	/**
	 * isNumber
	 *
	 * @param {*} num Number to validate
	 * @returns {boolean} true/false
	 * @example
	 * turf.isNumber(123)
	 * //=true
	 * turf.isNumber('foo')
	 * //=false
	 */
	function isNumber(num) {
	    return !isNaN(num) && num !== null && !Array.isArray(num);
	}

	/**
	 * isObject
	 *
	 * @param {*} input variable to validate
	 * @returns {boolean} true/false
	 * @example
	 * turf.isObject({elevation: 10})
	 * //=true
	 * turf.isObject('foo')
	 * //=false
	 */
	function isObject(input) {
	    return (!!input) && (input.constructor === Object);
	}

	/**
	 * Validate BBox
	 *
	 * @private
	 * @param {Array<number>} bbox BBox to validate
	 * @returns {void}
	 * @throws Error if BBox is not valid
	 * @example
	 * validateBBox([-180, -40, 110, 50])
	 * //=OK
	 * validateBBox([-180, -40])
	 * //=Error
	 * validateBBox('Foo')
	 * //=Error
	 * validateBBox(5)
	 * //=Error
	 * validateBBox(null)
	 * //=Error
	 * validateBBox(undefined)
	 * //=Error
	 */
	function validateBBox(bbox) {
	    if (!bbox) throw new Error('bbox is required');
	    if (!Array.isArray(bbox)) throw new Error('bbox must be an Array');
	    if (bbox.length !== 4 && bbox.length !== 6) throw new Error('bbox must be an Array of 4 or 6 numbers');
	    bbox.forEach(function (num) {
	        if (!isNumber(num)) throw new Error('bbox must only contain numbers');
	    });
	}

	/**
	 * Validate Id
	 *
	 * @private
	 * @param {string|number} id Id to validate
	 * @returns {void}
	 * @throws Error if Id is not valid
	 * @example
	 * validateId([-180, -40, 110, 50])
	 * //=Error
	 * validateId([-180, -40])
	 * //=Error
	 * validateId('Foo')
	 * //=OK
	 * validateId(5)
	 * //=OK
	 * validateId(null)
	 * //=Error
	 * validateId(undefined)
	 * //=Error
	 */
	function validateId(id) {
	    if (!id) throw new Error('id is required');
	    if (['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');
	}

	// Deprecated methods
	function radians2degrees() {
	    throw new Error('method has been renamed to `radiansToDegrees`');
	}

	function degrees2radians() {
	    throw new Error('method has been renamed to `degreesToRadians`');
	}

	function distanceToDegrees() {
	    throw new Error('method has been renamed to `lengthToDegrees`');
	}

	function distanceToRadians() {
	    throw new Error('method has been renamed to `lengthToRadians`');
	}

	function radiansToDistance() {
	    throw new Error('method has been renamed to `radiansToLength`');
	}

	function bearingToAngle() {
	    throw new Error('method has been renamed to `bearingToAzimuth`');
	}

	function convertDistance() {
	    throw new Error('method has been renamed to `convertLength`');
	}

	exports.earthRadius = earthRadius;
	exports.factors = factors;
	exports.unitsFactors = unitsFactors;
	exports.areaFactors = areaFactors;
	exports.feature = feature;
	exports.geometry = geometry;
	exports.point = point;
	exports.points = points;
	exports.polygon = polygon;
	exports.polygons = polygons;
	exports.lineString = lineString;
	exports.lineStrings = lineStrings;
	exports.featureCollection = featureCollection;
	exports.multiLineString = multiLineString;
	exports.multiPoint = multiPoint;
	exports.multiPolygon = multiPolygon;
	exports.geometryCollection = geometryCollection;
	exports.round = round;
	exports.radiansToLength = radiansToLength;
	exports.lengthToRadians = lengthToRadians;
	exports.lengthToDegrees = lengthToDegrees;
	exports.bearingToAzimuth = bearingToAzimuth;
	exports.radiansToDegrees = radiansToDegrees;
	exports.degreesToRadians = degreesToRadians;
	exports.convertLength = convertLength;
	exports.convertArea = convertArea;
	exports.isNumber = isNumber;
	exports.isObject = isObject;
	exports.validateBBox = validateBBox;
	exports.validateId = validateId;
	exports.radians2degrees = radians2degrees;
	exports.degrees2radians = degrees2radians;
	exports.distanceToDegrees = distanceToDegrees;
	exports.distanceToRadians = distanceToRadians;
	exports.radiansToDistance = radiansToDistance;
	exports.bearingToAngle = bearingToAngle;
	exports.convertDistance = convertDistance;
	});

	unwrapExports(main$9);
	var main_1$6 = main$9.earthRadius;
	var main_2$6 = main$9.factors;
	var main_3$6 = main$9.unitsFactors;
	var main_4$6 = main$9.areaFactors;
	var main_5$6 = main$9.feature;
	var main_6$6 = main$9.geometry;
	var main_7$6 = main$9.point;
	var main_8$6 = main$9.points;
	var main_9$6 = main$9.polygon;
	var main_10$5 = main$9.polygons;
	var main_11$5 = main$9.lineString;
	var main_12$5 = main$9.lineStrings;
	var main_13$5 = main$9.featureCollection;
	var main_14$5 = main$9.multiLineString;
	var main_15$5 = main$9.multiPoint;
	var main_16$5 = main$9.multiPolygon;
	var main_17$5 = main$9.geometryCollection;
	var main_18$3 = main$9.round;
	var main_19$3 = main$9.radiansToLength;
	var main_20$3 = main$9.lengthToRadians;
	var main_21$3 = main$9.lengthToDegrees;
	var main_22$3 = main$9.bearingToAzimuth;
	var main_23$3 = main$9.radiansToDegrees;
	var main_24$3 = main$9.degreesToRadians;
	var main_25$3 = main$9.convertLength;
	var main_26$3 = main$9.convertArea;
	var main_27$3 = main$9.isNumber;
	var main_28$3 = main$9.isObject;
	var main_29$3 = main$9.validateBBox;
	var main_30$3 = main$9.validateId;
	var main_31$3 = main$9.radians2degrees;
	var main_32$3 = main$9.degrees2radians;
	var main_33$3 = main$9.distanceToDegrees;
	var main_34$3 = main$9.distanceToRadians;
	var main_35$3 = main$9.radiansToDistance;
	var main_36$3 = main$9.bearingToAngle;
	var main_37$3 = main$9.convertDistance;

	var main$a = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, '__esModule', { value: true });



	/**
	 * Callback for coordEach
	 *
	 * @callback coordEachCallback
	 * @param {Array<number>} currentCoord The current coordinate being processed.
	 * @param {number} coordIndex The current index of the coordinate being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
	 * @param {number} geometryIndex The current index of the Geometry being processed.
	 */

	/**
	 * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()
	 *
	 * @name coordEach
	 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
	 * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)
	 * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.
	 * @returns {void}
	 * @example
	 * var features = turf.featureCollection([
	 *   turf.point([26, 37], {"foo": "bar"}),
	 *   turf.point([36, 53], {"hello": "world"})
	 * ]);
	 *
	 * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
	 *   //=currentCoord
	 *   //=coordIndex
	 *   //=featureIndex
	 *   //=multiFeatureIndex
	 *   //=geometryIndex
	 * });
	 */
	function coordEach(geojson, callback, excludeWrapCoord) {
	    // Handles null Geometry -- Skips this GeoJSON
	    if (geojson === null) return;
	    var j, k, l, geometry, stopG, coords,
	        geometryMaybeCollection,
	        wrapShrink = 0,
	        coordIndex = 0,
	        isGeometryCollection,
	        type = geojson.type,
	        isFeatureCollection = type === 'FeatureCollection',
	        isFeature = type === 'Feature',
	        stop = isFeatureCollection ? geojson.features.length : 1;

	    // This logic may look a little weird. The reason why it is that way
	    // is because it's trying to be fast. GeoJSON supports multiple kinds
	    // of objects at its root: FeatureCollection, Features, Geometries.
	    // This function has the responsibility of handling all of them, and that
	    // means that some of the `for` loops you see below actually just don't apply
	    // to certain inputs. For instance, if you give this just a
	    // Point geometry, then both loops are short-circuited and all we do
	    // is gradually rename the input until it's called 'geometry'.
	    //
	    // This also aims to allocate as few resources as possible: just a
	    // few numbers and booleans, rather than any temporary arrays as would
	    // be required with the normalization approach.
	    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {
	        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :
	            (isFeature ? geojson.geometry : geojson));
	        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;
	        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

	        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {
	            var multiFeatureIndex = 0;
	            var geometryIndex = 0;
	            geometry = isGeometryCollection ?
	                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;

	            // Handles null Geometry -- Skips this geometry
	            if (geometry === null) continue;
	            coords = geometry.coordinates;
	            var geomType = geometry.type;

	            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;

	            switch (geomType) {
	            case null:
	                break;
	            case 'Point':
	                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
	                coordIndex++;
	                multiFeatureIndex++;
	                break;
	            case 'LineString':
	            case 'MultiPoint':
	                for (j = 0; j < coords.length; j++) {
	                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
	                    coordIndex++;
	                    if (geomType === 'MultiPoint') multiFeatureIndex++;
	                }
	                if (geomType === 'LineString') multiFeatureIndex++;
	                break;
	            case 'Polygon':
	            case 'MultiLineString':
	                for (j = 0; j < coords.length; j++) {
	                    for (k = 0; k < coords[j].length - wrapShrink; k++) {
	                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
	                        coordIndex++;
	                    }
	                    if (geomType === 'MultiLineString') multiFeatureIndex++;
	                    if (geomType === 'Polygon') geometryIndex++;
	                }
	                if (geomType === 'Polygon') multiFeatureIndex++;
	                break;
	            case 'MultiPolygon':
	                for (j = 0; j < coords.length; j++) {
	                    if (geomType === 'MultiPolygon') geometryIndex = 0;
	                    for (k = 0; k < coords[j].length; k++) {
	                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
	                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
	                            coordIndex++;
	                        }
	                        geometryIndex++;
	                    }
	                    multiFeatureIndex++;
	                }
	                break;
	            case 'GeometryCollection':
	                for (j = 0; j < geometry.geometries.length; j++)
	                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;
	                break;
	            default:
	                throw new Error('Unknown Geometry Type');
	            }
	        }
	    }
	}

	/**
	 * Callback for coordReduce
	 *
	 * The first time the callback function is called, the values provided as arguments depend
	 * on whether the reduce method has an initialValue argument.
	 *
	 * If an initialValue is provided to the reduce method:
	 *  - The previousValue argument is initialValue.
	 *  - The currentValue argument is the value of the first element present in the array.
	 *
	 * If an initialValue is not provided:
	 *  - The previousValue argument is the value of the first element present in the array.
	 *  - The currentValue argument is the value of the second element present in the array.
	 *
	 * @callback coordReduceCallback
	 * @param {*} previousValue The accumulated value previously returned in the last invocation
	 * of the callback, or initialValue, if supplied.
	 * @param {Array<number>} currentCoord The current coordinate being processed.
	 * @param {number} coordIndex The current index of the coordinate being processed.
	 * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
	 * @param {number} geometryIndex The current index of the Geometry being processed.
	 */

	/**
	 * Reduce coordinates in any GeoJSON object, similar to Array.reduce()
	 *
	 * @name coordReduce
	 * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object
	 * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)
	 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
	 * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.
	 * @returns {*} The value that results from the reduction.
	 * @example
	 * var features = turf.featureCollection([
	 *   turf.point([26, 37], {"foo": "bar"}),
	 *   turf.point([36, 53], {"hello": "world"})
	 * ]);
	 *
	 * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
	 *   //=previousValue
	 *   //=currentCoord
	 *   //=coordIndex
	 *   //=featureIndex
	 *   //=multiFeatureIndex
	 *   //=geometryIndex
	 *   return currentCoord;
	 * });
	 */
	function coordReduce(geojson, callback, initialValue, excludeWrapCoord) {
	    var previousValue = initialValue;
	    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
	        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;
	        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);
	    }, excludeWrapCoord);
	    return previousValue;
	}

	/**
	 * Callback for propEach
	 *
	 * @callback propEachCallback
	 * @param {Object} currentProperties The current Properties being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 */

	/**
	 * Iterate over properties in any GeoJSON object, similar to Array.forEach()
	 *
	 * @name propEach
	 * @param {FeatureCollection|Feature} geojson any GeoJSON object
	 * @param {Function} callback a method that takes (currentProperties, featureIndex)
	 * @returns {void}
	 * @example
	 * var features = turf.featureCollection([
	 *     turf.point([26, 37], {foo: 'bar'}),
	 *     turf.point([36, 53], {hello: 'world'})
	 * ]);
	 *
	 * turf.propEach(features, function (currentProperties, featureIndex) {
	 *   //=currentProperties
	 *   //=featureIndex
	 * });
	 */
	function propEach(geojson, callback) {
	    var i;
	    switch (geojson.type) {
	    case 'FeatureCollection':
	        for (i = 0; i < geojson.features.length; i++) {
	            if (callback(geojson.features[i].properties, i) === false) break;
	        }
	        break;
	    case 'Feature':
	        callback(geojson.properties, 0);
	        break;
	    }
	}


	/**
	 * Callback for propReduce
	 *
	 * The first time the callback function is called, the values provided as arguments depend
	 * on whether the reduce method has an initialValue argument.
	 *
	 * If an initialValue is provided to the reduce method:
	 *  - The previousValue argument is initialValue.
	 *  - The currentValue argument is the value of the first element present in the array.
	 *
	 * If an initialValue is not provided:
	 *  - The previousValue argument is the value of the first element present in the array.
	 *  - The currentValue argument is the value of the second element present in the array.
	 *
	 * @callback propReduceCallback
	 * @param {*} previousValue The accumulated value previously returned in the last invocation
	 * of the callback, or initialValue, if supplied.
	 * @param {*} currentProperties The current Properties being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 */

	/**
	 * Reduce properties in any GeoJSON object into a single value,
	 * similar to how Array.reduce works. However, in this case we lazily run
	 * the reduction, so an array of all properties is unnecessary.
	 *
	 * @name propReduce
	 * @param {FeatureCollection|Feature} geojson any GeoJSON object
	 * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)
	 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
	 * @returns {*} The value that results from the reduction.
	 * @example
	 * var features = turf.featureCollection([
	 *     turf.point([26, 37], {foo: 'bar'}),
	 *     turf.point([36, 53], {hello: 'world'})
	 * ]);
	 *
	 * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {
	 *   //=previousValue
	 *   //=currentProperties
	 *   //=featureIndex
	 *   return currentProperties
	 * });
	 */
	function propReduce(geojson, callback, initialValue) {
	    var previousValue = initialValue;
	    propEach(geojson, function (currentProperties, featureIndex) {
	        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;
	        else previousValue = callback(previousValue, currentProperties, featureIndex);
	    });
	    return previousValue;
	}

	/**
	 * Callback for featureEach
	 *
	 * @callback featureEachCallback
	 * @param {Feature<any>} currentFeature The current Feature being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 */

	/**
	 * Iterate over features in any GeoJSON object, similar to
	 * Array.forEach.
	 *
	 * @name featureEach
	 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
	 * @param {Function} callback a method that takes (currentFeature, featureIndex)
	 * @returns {void}
	 * @example
	 * var features = turf.featureCollection([
	 *   turf.point([26, 37], {foo: 'bar'}),
	 *   turf.point([36, 53], {hello: 'world'})
	 * ]);
	 *
	 * turf.featureEach(features, function (currentFeature, featureIndex) {
	 *   //=currentFeature
	 *   //=featureIndex
	 * });
	 */
	function featureEach(geojson, callback) {
	    if (geojson.type === 'Feature') {
	        callback(geojson, 0);
	    } else if (geojson.type === 'FeatureCollection') {
	        for (var i = 0; i < geojson.features.length; i++) {
	            if (callback(geojson.features[i], i) === false) break;
	        }
	    }
	}

	/**
	 * Callback for featureReduce
	 *
	 * The first time the callback function is called, the values provided as arguments depend
	 * on whether the reduce method has an initialValue argument.
	 *
	 * If an initialValue is provided to the reduce method:
	 *  - The previousValue argument is initialValue.
	 *  - The currentValue argument is the value of the first element present in the array.
	 *
	 * If an initialValue is not provided:
	 *  - The previousValue argument is the value of the first element present in the array.
	 *  - The currentValue argument is the value of the second element present in the array.
	 *
	 * @callback featureReduceCallback
	 * @param {*} previousValue The accumulated value previously returned in the last invocation
	 * of the callback, or initialValue, if supplied.
	 * @param {Feature} currentFeature The current Feature being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 */

	/**
	 * Reduce features in any GeoJSON object, similar to Array.reduce().
	 *
	 * @name featureReduce
	 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
	 * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)
	 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
	 * @returns {*} The value that results from the reduction.
	 * @example
	 * var features = turf.featureCollection([
	 *   turf.point([26, 37], {"foo": "bar"}),
	 *   turf.point([36, 53], {"hello": "world"})
	 * ]);
	 *
	 * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {
	 *   //=previousValue
	 *   //=currentFeature
	 *   //=featureIndex
	 *   return currentFeature
	 * });
	 */
	function featureReduce(geojson, callback, initialValue) {
	    var previousValue = initialValue;
	    featureEach(geojson, function (currentFeature, featureIndex) {
	        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;
	        else previousValue = callback(previousValue, currentFeature, featureIndex);
	    });
	    return previousValue;
	}

	/**
	 * Get all coordinates from any GeoJSON object.
	 *
	 * @name coordAll
	 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
	 * @returns {Array<Array<number>>} coordinate position array
	 * @example
	 * var features = turf.featureCollection([
	 *   turf.point([26, 37], {foo: 'bar'}),
	 *   turf.point([36, 53], {hello: 'world'})
	 * ]);
	 *
	 * var coords = turf.coordAll(features);
	 * //= [[26, 37], [36, 53]]
	 */
	function coordAll(geojson) {
	    var coords = [];
	    coordEach(geojson, function (coord) {
	        coords.push(coord);
	    });
	    return coords;
	}

	/**
	 * Callback for geomEach
	 *
	 * @callback geomEachCallback
	 * @param {Geometry} currentGeometry The current Geometry being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 * @param {Object} featureProperties The current Feature Properties being processed.
	 * @param {Array<number>} featureBBox The current Feature BBox being processed.
	 * @param {number|string} featureId The current Feature Id being processed.
	 */

	/**
	 * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()
	 *
	 * @name geomEach
	 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
	 * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)
	 * @returns {void}
	 * @example
	 * var features = turf.featureCollection([
	 *     turf.point([26, 37], {foo: 'bar'}),
	 *     turf.point([36, 53], {hello: 'world'})
	 * ]);
	 *
	 * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
	 *   //=currentGeometry
	 *   //=featureIndex
	 *   //=featureProperties
	 *   //=featureBBox
	 *   //=featureId
	 * });
	 */
	function geomEach(geojson, callback) {
	    var i, j, g, geometry, stopG,
	        geometryMaybeCollection,
	        isGeometryCollection,
	        featureProperties,
	        featureBBox,
	        featureId,
	        featureIndex = 0,
	        isFeatureCollection = geojson.type === 'FeatureCollection',
	        isFeature = geojson.type === 'Feature',
	        stop = isFeatureCollection ? geojson.features.length : 1;

	    // This logic may look a little weird. The reason why it is that way
	    // is because it's trying to be fast. GeoJSON supports multiple kinds
	    // of objects at its root: FeatureCollection, Features, Geometries.
	    // This function has the responsibility of handling all of them, and that
	    // means that some of the `for` loops you see below actually just don't apply
	    // to certain inputs. For instance, if you give this just a
	    // Point geometry, then both loops are short-circuited and all we do
	    // is gradually rename the input until it's called 'geometry'.
	    //
	    // This also aims to allocate as few resources as possible: just a
	    // few numbers and booleans, rather than any temporary arrays as would
	    // be required with the normalization approach.
	    for (i = 0; i < stop; i++) {

	        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :
	            (isFeature ? geojson.geometry : geojson));
	        featureProperties = (isFeatureCollection ? geojson.features[i].properties :
	            (isFeature ? geojson.properties : {}));
	        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :
	            (isFeature ? geojson.bbox : undefined));
	        featureId = (isFeatureCollection ? geojson.features[i].id :
	            (isFeature ? geojson.id : undefined));
	        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;
	        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

	        for (g = 0; g < stopG; g++) {
	            geometry = isGeometryCollection ?
	                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;

	            // Handle null Geometry
	            if (geometry === null) {
	                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;
	                continue;
	            }
	            switch (geometry.type) {
	            case 'Point':
	            case 'LineString':
	            case 'MultiPoint':
	            case 'Polygon':
	            case 'MultiLineString':
	            case 'MultiPolygon': {
	                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;
	                break;
	            }
	            case 'GeometryCollection': {
	                for (j = 0; j < geometry.geometries.length; j++) {
	                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;
	                }
	                break;
	            }
	            default:
	                throw new Error('Unknown Geometry Type');
	            }
	        }
	        // Only increase `featureIndex` per each feature
	        featureIndex++;
	    }
	}

	/**
	 * Callback for geomReduce
	 *
	 * The first time the callback function is called, the values provided as arguments depend
	 * on whether the reduce method has an initialValue argument.
	 *
	 * If an initialValue is provided to the reduce method:
	 *  - The previousValue argument is initialValue.
	 *  - The currentValue argument is the value of the first element present in the array.
	 *
	 * If an initialValue is not provided:
	 *  - The previousValue argument is the value of the first element present in the array.
	 *  - The currentValue argument is the value of the second element present in the array.
	 *
	 * @callback geomReduceCallback
	 * @param {*} previousValue The accumulated value previously returned in the last invocation
	 * of the callback, or initialValue, if supplied.
	 * @param {Geometry} currentGeometry The current Geometry being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 * @param {Object} featureProperties The current Feature Properties being processed.
	 * @param {Array<number>} featureBBox The current Feature BBox being processed.
	 * @param {number|string} featureId The current Feature Id being processed.
	 */

	/**
	 * Reduce geometry in any GeoJSON object, similar to Array.reduce().
	 *
	 * @name geomReduce
	 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
	 * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)
	 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
	 * @returns {*} The value that results from the reduction.
	 * @example
	 * var features = turf.featureCollection([
	 *     turf.point([26, 37], {foo: 'bar'}),
	 *     turf.point([36, 53], {hello: 'world'})
	 * ]);
	 *
	 * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
	 *   //=previousValue
	 *   //=currentGeometry
	 *   //=featureIndex
	 *   //=featureProperties
	 *   //=featureBBox
	 *   //=featureId
	 *   return currentGeometry
	 * });
	 */
	function geomReduce(geojson, callback, initialValue) {
	    var previousValue = initialValue;
	    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
	        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;
	        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);
	    });
	    return previousValue;
	}

	/**
	 * Callback for flattenEach
	 *
	 * @callback flattenEachCallback
	 * @param {Feature} currentFeature The current flattened feature being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
	 */

	/**
	 * Iterate over flattened features in any GeoJSON object, similar to
	 * Array.forEach.
	 *
	 * @name flattenEach
	 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
	 * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)
	 * @example
	 * var features = turf.featureCollection([
	 *     turf.point([26, 37], {foo: 'bar'}),
	 *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})
	 * ]);
	 *
	 * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {
	 *   //=currentFeature
	 *   //=featureIndex
	 *   //=multiFeatureIndex
	 * });
	 */
	function flattenEach(geojson, callback) {
	    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {
	        // Callback for single geometry
	        var type = (geometry === null) ? null : geometry.type;
	        switch (type) {
	        case null:
	        case 'Point':
	        case 'LineString':
	        case 'Polygon':
	            if (callback(main$9.feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;
	            return;
	        }

	        var geomType;

	        // Callback for multi-geometry
	        switch (type) {
	        case 'MultiPoint':
	            geomType = 'Point';
	            break;
	        case 'MultiLineString':
	            geomType = 'LineString';
	            break;
	        case 'MultiPolygon':
	            geomType = 'Polygon';
	            break;
	        }

	        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {
	            var coordinate = geometry.coordinates[multiFeatureIndex];
	            var geom = {
	                type: geomType,
	                coordinates: coordinate
	            };
	            if (callback(main$9.feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;
	        }
	    });
	}

	/**
	 * Callback for flattenReduce
	 *
	 * The first time the callback function is called, the values provided as arguments depend
	 * on whether the reduce method has an initialValue argument.
	 *
	 * If an initialValue is provided to the reduce method:
	 *  - The previousValue argument is initialValue.
	 *  - The currentValue argument is the value of the first element present in the array.
	 *
	 * If an initialValue is not provided:
	 *  - The previousValue argument is the value of the first element present in the array.
	 *  - The currentValue argument is the value of the second element present in the array.
	 *
	 * @callback flattenReduceCallback
	 * @param {*} previousValue The accumulated value previously returned in the last invocation
	 * of the callback, or initialValue, if supplied.
	 * @param {Feature} currentFeature The current Feature being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
	 */

	/**
	 * Reduce flattened features in any GeoJSON object, similar to Array.reduce().
	 *
	 * @name flattenReduce
	 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
	 * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)
	 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
	 * @returns {*} The value that results from the reduction.
	 * @example
	 * var features = turf.featureCollection([
	 *     turf.point([26, 37], {foo: 'bar'}),
	 *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})
	 * ]);
	 *
	 * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {
	 *   //=previousValue
	 *   //=currentFeature
	 *   //=featureIndex
	 *   //=multiFeatureIndex
	 *   return currentFeature
	 * });
	 */
	function flattenReduce(geojson, callback, initialValue) {
	    var previousValue = initialValue;
	    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {
	        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;
	        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);
	    });
	    return previousValue;
	}

	/**
	 * Callback for segmentEach
	 *
	 * @callback segmentEachCallback
	 * @param {Feature<LineString>} currentSegment The current Segment being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
	 * @param {number} geometryIndex The current index of the Geometry being processed.
	 * @param {number} segmentIndex The current index of the Segment being processed.
	 * @returns {void}
	 */

	/**
	 * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()
	 * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
	 *
	 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON
	 * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)
	 * @returns {void}
	 * @example
	 * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
	 *
	 * // Iterate over GeoJSON by 2-vertex segments
	 * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
	 *   //=currentSegment
	 *   //=featureIndex
	 *   //=multiFeatureIndex
	 *   //=geometryIndex
	 *   //=segmentIndex
	 * });
	 *
	 * // Calculate the total number of segments
	 * var total = 0;
	 * turf.segmentEach(polygon, function () {
	 *     total++;
	 * });
	 */
	function segmentEach(geojson, callback) {
	    flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {
	        var segmentIndex = 0;

	        // Exclude null Geometries
	        if (!feature$$1.geometry) return;
	        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
	        var type = feature$$1.geometry.type;
	        if (type === 'Point' || type === 'MultiPoint') return;

	        // Generate 2-vertex line segments
	        var previousCoords;
	        if (coordEach(feature$$1, function (currentCoord, coordIndex, featureIndexCoord, mutliPartIndexCoord, geometryIndex) {
	            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`
	            if (previousCoords === undefined) {
	                previousCoords = currentCoord;
	                return;
	            }
	            var currentSegment = main$9.lineString([previousCoords, currentCoord], feature$$1.properties);
	            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;
	            segmentIndex++;
	            previousCoords = currentCoord;
	        }) === false) return false;
	    });
	}

	/**
	 * Callback for segmentReduce
	 *
	 * The first time the callback function is called, the values provided as arguments depend
	 * on whether the reduce method has an initialValue argument.
	 *
	 * If an initialValue is provided to the reduce method:
	 *  - The previousValue argument is initialValue.
	 *  - The currentValue argument is the value of the first element present in the array.
	 *
	 * If an initialValue is not provided:
	 *  - The previousValue argument is the value of the first element present in the array.
	 *  - The currentValue argument is the value of the second element present in the array.
	 *
	 * @callback segmentReduceCallback
	 * @param {*} previousValue The accumulated value previously returned in the last invocation
	 * of the callback, or initialValue, if supplied.
	 * @param {Feature<LineString>} currentSegment The current Segment being processed.
	 * @param {number} featureIndex The current index of the Feature being processed.
	 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
	 * @param {number} geometryIndex The current index of the Geometry being processed.
	 * @param {number} segmentIndex The current index of the Segment being processed.
	 */

	/**
	 * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()
	 * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
	 *
	 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON
	 * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)
	 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
	 * @returns {void}
	 * @example
	 * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
	 *
	 * // Iterate over GeoJSON by 2-vertex segments
	 * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
	 *   //= previousSegment
	 *   //= currentSegment
	 *   //= featureIndex
	 *   //= multiFeatureIndex
	 *   //= geometryIndex
	 *   //= segmentInex
	 *   return currentSegment
	 * });
	 *
	 * // Calculate the total number of segments
	 * var initialValue = 0
	 * var total = turf.segmentReduce(polygon, function (previousValue) {
	 *     previousValue++;
	 *     return previousValue;
	 * }, initialValue);
	 */
	function segmentReduce(geojson, callback, initialValue) {
	    var previousValue = initialValue;
	    var started = false;
	    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
	        if (started === false && initialValue === undefined) previousValue = currentSegment;
	        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);
	        started = true;
	    });
	    return previousValue;
	}

	/**
	 * Callback for lineEach
	 *
	 * @callback lineEachCallback
	 * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed
	 * @param {number} featureIndex The current index of the Feature being processed
	 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed
	 * @param {number} geometryIndex The current index of the Geometry being processed
	 */

	/**
	 * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,
	 * similar to Array.forEach.
	 *
	 * @name lineEach
	 * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object
	 * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)
	 * @example
	 * var multiLine = turf.multiLineString([
	 *   [[26, 37], [35, 45]],
	 *   [[36, 53], [38, 50], [41, 55]]
	 * ]);
	 *
	 * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
	 *   //=currentLine
	 *   //=featureIndex
	 *   //=multiFeatureIndex
	 *   //=geometryIndex
	 * });
	 */
	function lineEach(geojson, callback) {
	    // validation
	    if (!geojson) throw new Error('geojson is required');

	    flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {
	        if (feature$$1.geometry === null) return;
	        var type = feature$$1.geometry.type;
	        var coords = feature$$1.geometry.coordinates;
	        switch (type) {
	        case 'LineString':
	            if (callback(feature$$1, featureIndex, multiFeatureIndex, 0, 0) === false) return false;
	            break;
	        case 'Polygon':
	            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {
	                if (callback(main$9.lineString(coords[geometryIndex], feature$$1.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
	            }
	            break;
	        }
	    });
	}

	/**
	 * Callback for lineReduce
	 *
	 * The first time the callback function is called, the values provided as arguments depend
	 * on whether the reduce method has an initialValue argument.
	 *
	 * If an initialValue is provided to the reduce method:
	 *  - The previousValue argument is initialValue.
	 *  - The currentValue argument is the value of the first element present in the array.
	 *
	 * If an initialValue is not provided:
	 *  - The previousValue argument is the value of the first element present in the array.
	 *  - The currentValue argument is the value of the second element present in the array.
	 *
	 * @callback lineReduceCallback
	 * @param {*} previousValue The accumulated value previously returned in the last invocation
	 * of the callback, or initialValue, if supplied.
	 * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.
	 * @param {number} featureIndex The current index of the Feature being processed
	 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed
	 * @param {number} geometryIndex The current index of the Geometry being processed
	 */

	/**
	 * Reduce features in any GeoJSON object, similar to Array.reduce().
	 *
	 * @name lineReduce
	 * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object
	 * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)
	 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
	 * @returns {*} The value that results from the reduction.
	 * @example
	 * var multiPoly = turf.multiPolygon([
	 *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),
	 *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])
	 * ]);
	 *
	 * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
	 *   //=previousValue
	 *   //=currentLine
	 *   //=featureIndex
	 *   //=multiFeatureIndex
	 *   //=geometryIndex
	 *   return currentLine
	 * });
	 */
	function lineReduce(geojson, callback, initialValue) {
	    var previousValue = initialValue;
	    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
	        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;
	        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);
	    });
	    return previousValue;
	}

	/**
	 * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.
	 *
	 * Negative indexes are permitted.
	 * Point & MultiPoint will always return null.
	 *
	 * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry
	 * @param {Object} [options={}] Optional parameters
	 * @param {number} [options.featureIndex=0] Feature Index
	 * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index
	 * @param {number} [options.geometryIndex=0] Geometry Index
	 * @param {number} [options.segmentIndex=0] Segment Index
	 * @param {Object} [options.properties={}] Translate Properties to output LineString
	 * @param {BBox} [options.bbox={}] Translate BBox to output LineString
	 * @param {number|string} [options.id={}] Translate Id to output LineString
	 * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString
	 * @example
	 * var multiLine = turf.multiLineString([
	 *     [[10, 10], [50, 30], [30, 40]],
	 *     [[-10, -10], [-50, -30], [-30, -40]]
	 * ]);
	 *
	 * // First Segment (defaults are 0)
	 * turf.findSegment(multiLine);
	 * // => Feature<LineString<[[10, 10], [50, 30]]>>
	 *
	 * // First Segment of 2nd Multi Feature
	 * turf.findSegment(multiLine, {multiFeatureIndex: 1});
	 * // => Feature<LineString<[[-10, -10], [-50, -30]]>>
	 *
	 * // Last Segment of Last Multi Feature
	 * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});
	 * // => Feature<LineString<[[-50, -30], [-30, -40]]>>
	 */
	function findSegment(geojson, options) {
	    // Optional Parameters
	    options = options || {};
	    if (!main$9.isObject(options)) throw new Error('options is invalid');
	    var featureIndex = options.featureIndex || 0;
	    var multiFeatureIndex = options.multiFeatureIndex || 0;
	    var geometryIndex = options.geometryIndex || 0;
	    var segmentIndex = options.segmentIndex || 0;

	    // Find FeatureIndex
	    var properties = options.properties;
	    var geometry;

	    switch (geojson.type) {
	    case 'FeatureCollection':
	        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;
	        properties = properties || geojson.features[featureIndex].properties;
	        geometry = geojson.features[featureIndex].geometry;
	        break;
	    case 'Feature':
	        properties = properties || geojson.properties;
	        geometry = geojson.geometry;
	        break;
	    case 'Point':
	    case 'MultiPoint':
	        return null;
	    case 'LineString':
	    case 'Polygon':
	    case 'MultiLineString':
	    case 'MultiPolygon':
	        geometry = geojson;
	        break;
	    default:
	        throw new Error('geojson is invalid');
	    }

	    // Find SegmentIndex
	    if (geometry === null) return null;
	    var coords = geometry.coordinates;
	    switch (geometry.type) {
	    case 'Point':
	    case 'MultiPoint':
	        return null;
	    case 'LineString':
	        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;
	        return main$9.lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);
	    case 'Polygon':
	        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;
	        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;
	        return main$9.lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);
	    case 'MultiLineString':
	        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
	        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;
	        return main$9.lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);
	    case 'MultiPolygon':
	        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
	        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
	        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;
	        return main$9.lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);
	    }
	    throw new Error('geojson is invalid');
	}

	/**
	 * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.
	 *
	 * Negative indexes are permitted.
	 *
	 * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry
	 * @param {Object} [options={}] Optional parameters
	 * @param {number} [options.featureIndex=0] Feature Index
	 * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index
	 * @param {number} [options.geometryIndex=0] Geometry Index
	 * @param {number} [options.coordIndex=0] Coord Index
	 * @param {Object} [options.properties={}] Translate Properties to output Point
	 * @param {BBox} [options.bbox={}] Translate BBox to output Point
	 * @param {number|string} [options.id={}] Translate Id to output Point
	 * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point
	 * @example
	 * var multiLine = turf.multiLineString([
	 *     [[10, 10], [50, 30], [30, 40]],
	 *     [[-10, -10], [-50, -30], [-30, -40]]
	 * ]);
	 *
	 * // First Segment (defaults are 0)
	 * turf.findPoint(multiLine);
	 * // => Feature<Point<[10, 10]>>
	 *
	 * // First Segment of the 2nd Multi-Feature
	 * turf.findPoint(multiLine, {multiFeatureIndex: 1});
	 * // => Feature<Point<[-10, -10]>>
	 *
	 * // Last Segment of last Multi-Feature
	 * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});
	 * // => Feature<Point<[-30, -40]>>
	 */
	function findPoint(geojson, options) {
	    // Optional Parameters
	    options = options || {};
	    if (!main$9.isObject(options)) throw new Error('options is invalid');
	    var featureIndex = options.featureIndex || 0;
	    var multiFeatureIndex = options.multiFeatureIndex || 0;
	    var geometryIndex = options.geometryIndex || 0;
	    var coordIndex = options.coordIndex || 0;

	    // Find FeatureIndex
	    var properties = options.properties;
	    var geometry;

	    switch (geojson.type) {
	    case 'FeatureCollection':
	        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;
	        properties = properties || geojson.features[featureIndex].properties;
	        geometry = geojson.features[featureIndex].geometry;
	        break;
	    case 'Feature':
	        properties = properties || geojson.properties;
	        geometry = geojson.geometry;
	        break;
	    case 'Point':
	    case 'MultiPoint':
	        return null;
	    case 'LineString':
	    case 'Polygon':
	    case 'MultiLineString':
	    case 'MultiPolygon':
	        geometry = geojson;
	        break;
	    default:
	        throw new Error('geojson is invalid');
	    }

	    // Find Coord Index
	    if (geometry === null) return null;
	    var coords = geometry.coordinates;
	    switch (geometry.type) {
	    case 'Point':
	        return main$9.point(coords, properties, options);
	    case 'MultiPoint':
	        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
	        return main$9.point(coords[multiFeatureIndex], properties, options);
	    case 'LineString':
	        if (coordIndex < 0) coordIndex = coords.length + coordIndex;
	        return main$9.point(coords[coordIndex], properties, options);
	    case 'Polygon':
	        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;
	        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;
	        return main$9.point(coords[geometryIndex][coordIndex], properties, options);
	    case 'MultiLineString':
	        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
	        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;
	        return main$9.point(coords[multiFeatureIndex][coordIndex], properties, options);
	    case 'MultiPolygon':
	        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
	        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
	        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;
	        return main$9.point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);
	    }
	    throw new Error('geojson is invalid');
	}

	exports.coordEach = coordEach;
	exports.coordReduce = coordReduce;
	exports.propEach = propEach;
	exports.propReduce = propReduce;
	exports.featureEach = featureEach;
	exports.featureReduce = featureReduce;
	exports.coordAll = coordAll;
	exports.geomEach = geomEach;
	exports.geomReduce = geomReduce;
	exports.flattenEach = flattenEach;
	exports.flattenReduce = flattenReduce;
	exports.segmentEach = segmentEach;
	exports.segmentReduce = segmentReduce;
	exports.lineEach = lineEach;
	exports.lineReduce = lineReduce;
	exports.findSegment = findSegment;
	exports.findPoint = findPoint;
	});

	unwrapExports(main$a);
	var main_1$7 = main$a.coordEach;
	var main_2$7 = main$a.coordReduce;
	var main_3$7 = main$a.propEach;
	var main_4$7 = main$a.propReduce;
	var main_5$7 = main$a.featureEach;
	var main_6$7 = main$a.featureReduce;
	var main_7$7 = main$a.coordAll;
	var main_8$7 = main$a.geomEach;
	var main_9$7 = main$a.geomReduce;
	var main_10$6 = main$a.flattenEach;
	var main_11$6 = main$a.flattenReduce;
	var main_12$6 = main$a.segmentEach;
	var main_13$6 = main$a.segmentReduce;
	var main_14$6 = main$a.lineEach;
	var main_15$6 = main$a.lineReduce;
	var main_16$6 = main$a.findSegment;
	var main_17$6 = main$a.findPoint;

	/**
	 * Takes a feature or set of features and returns all positions as {@link Point|points}.
	 *
	 * @name explode
	 * @param {GeoJSON} geojson input features
	 * @returns {FeatureCollection<point>} points representing the exploded input features
	 * @throws {Error} if it encounters an unknown geometry type
	 * @example
	 * var polygon = turf.polygon([[[-81, 41], [-88, 36], [-84, 31], [-80, 33], [-77, 39], [-81, 41]]]);
	 *
	 * var explode = turf.explode(polygon);
	 *
	 * //addToMap
	 * var addToMap = [polygon, explode]
	 */
	function explode(geojson) {
	    var points = [];
	    if (geojson.type === 'FeatureCollection') {
	        main$a.featureEach(geojson, function (feature) {
	            main$a.coordEach(feature, function (coord) {
	                points.push(main$9.point(coord, feature.properties));
	            });
	        });
	    } else {
	        main$a.coordEach(geojson, function (coord) {
	            points.push(main$9.point(coord, geojson.properties));
	        });
	    }
	    return main$9.featureCollection(points);
	}

	var main$b = explode;
	var default_1$3 = explode;
	main$b.default = default_1$3;

	function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

	var bbox$1 = _interopDefault(main$2);
	var area$2 = _interopDefault(main$5);
	var booleanPointInPolygon$1 = _interopDefault(main$8);
	var explode$1 = _interopDefault(main$b);




	/**
	 * Takes a {@link Point} grid and returns a correspondent matrix {Array<Array<number>>}
	 * of the 'property' values
	 *
	 * @name gridToMatrix
	 * @param {FeatureCollection<Point>} grid of points
	 * @param {Object} [options={}] Optional parameters
	 * @param {string} [options.zProperty='elevation'] the property name in `points` from which z-values will be pulled
	 * @param {boolean} [options.flip=false] returns the matrix upside-down
	 * @param {boolean} [options.flags=false] flags, adding a `matrixPosition` array field ([row, column]) to its properties,
	 * the grid points with coordinates on the matrix
	 * @returns {Array<Array<number>>} matrix of property values
	 * @example
	 *   var extent = [-70.823364, -33.553984, -70.473175, -33.302986];
	 *   var cellSize = 3;
	 *   var grid = turf.pointGrid(extent, cellSize);
	 *   // add a random property to each point between 0 and 60
	 *   for (var i = 0; i < grid.features.length; i++) {
	 *     grid.features[i].properties.elevation = (Math.random() * 60);
	 *   }
	 *   gridToMatrix(grid);
	 *   //= [
	 *     [ 1, 13, 10,  9, 10, 13, 18],
	 *     [34,  8,  5,  4,  5,  8, 13],
	 *     [10,  5,  2,  1,  2,  5,  4],
	 *     [ 0,  4, 56, 19,  1,  4,  9],
	 *     [10,  5,  2,  1,  2,  5, 10],
	 *     [57,  8,  5,  4,  5,  0, 57],
	 *     [ 3, 13, 10,  9,  5, 13, 18],
	 *     [18, 13, 10,  9, 78, 13, 18]
	 *   ]
	 */
	function gridToMatrix(grid, options) {
	    // Optional parameters
	    options = options || {};
	    if (!main$3.isObject(options)) throw new Error('options is invalid');
	    var zProperty = options.zProperty || 'elevation';
	    var flip = options.flip;
	    var flags = options.flags;

	    // validation
	    main$7.collectionOf(grid, 'Point', 'input must contain Points');

	    var pointsMatrix = sortPointsByLatLng(grid, flip);

	    var matrix = [];
	    // create property matrix from sorted points
	    // looping order matters here
	    for (var r = 0; r < pointsMatrix.length; r++) {
	        var pointRow = pointsMatrix[r];
	        var row = [];
	        for (var c = 0; c < pointRow.length; c++) {
	            var point = pointRow[c];
	            // Check if zProperty exist
	            if (point.properties[zProperty]) row.push(point.properties[zProperty]);
	            else row.push(0);
	            // add flags
	            if (flags === true) point.properties.matrixPosition = [r, c];
	        }
	        matrix.push(row);
	    }

	    return matrix;
	}

	/**
	 * Sorts points by latitude and longitude, creating a 2-dimensional array of points
	 *
	 * @private
	 * @param {FeatureCollection<Point>} points GeoJSON Point features
	 * @param {boolean} [flip=false] returns the matrix upside-down
	 * @returns {Array<Array<Point>>} points ordered by latitude and longitude
	 */
	function sortPointsByLatLng(points, flip) {
	    var pointsByLatitude = {};

	    // divide points by rows with the same latitude
	    main$4.featureEach(points, function (point) {
	        var lat = main$7.getCoords(point)[1];
	        if (!pointsByLatitude[lat]) pointsByLatitude[lat] = [];
	        pointsByLatitude[lat].push(point);
	    });

	    // sort points (with the same latitude) by longitude
	    var orderedRowsByLatitude = Object.keys(pointsByLatitude).map(function (lat) {
	        var row = pointsByLatitude[lat];
	        var rowOrderedByLongitude = row.sort(function (a, b) {
	            return main$7.getCoords(a)[0] - main$7.getCoords(b)[0];
	        });
	        return rowOrderedByLongitude;
	    });

	    // sort rows (of points with the same latitude) by latitude
	    var pointMatrix = orderedRowsByLatitude.sort(function (a, b) {
	        if (flip) return main$7.getCoords(a[0])[1] - main$7.getCoords(b[0])[1];
	        else return main$7.getCoords(b[0])[1] - main$7.getCoords(a[0])[1];
	    });

	    return pointMatrix;
	}

	/*!
	* @license GNU Affero General Public License.
	* Copyright (c) 2015, 2015 Ronny Lorenz <ronny@tbi.univie.ac.at>
	* v. 1.2.0
	* https://github.com/RaumZeit/MarchingSquares.js
	*/

	var defaultSettings = {
	    successCallback: null,
	    verbose: false,
	    polygons: false
	};

	var settings = {};

	/*
	  Compute isobands(s) of a scalar 2D field given a certain
	  threshold and a bandwidth by applying the Marching Squares
	  Algorithm. The function returns a list of path coordinates
	  either for individual polygons within each grid cell, or the
	  outline of connected polygons.
	*/
	function isoBands(data, minV, bandwidth, options) {
	    /* process options */
	    options = options ? options : {};

	    var optionKeys = Object.keys(defaultSettings);

	    for (var i = 0; i < optionKeys.length; i++) {
	        var key = optionKeys[i];
	        var val = options[key];
	        val = ((typeof val !== 'undefined') && (val !== null)) ? val : defaultSettings[key];

	        settings[key] = val;
	    }

	    if (settings.verbose)
	        console.log('MarchingSquaresJS-isoBands: computing isobands for [' + minV + ':' + (minV + bandwidth) + ']');

	    var grid = computeBandGrid(data, minV, bandwidth);

	    var ret;
	    if (settings.polygons) {
	        if (settings.verbose)
	            console.log('MarchingSquaresJS-isoBands: returning single polygons for each grid cell');
	        ret = BandGrid2Areas(grid);
	    } else {
	        if (settings.verbose)
	            console.log('MarchingSquaresJS-isoBands: returning polygon paths for entire data grid');
	        ret = BandGrid2AreaPaths(grid);
	    }

	    if (typeof settings.successCallback === 'function')
	        settings.successCallback(ret);

	    return ret;
	}

	/*
	  Thats all for the public interface, below follows the actual
	  implementation
	*/

	/* Some private variables */
	var Node0 = 64;
	var Node1 = 16;
	var Node2 = 4;
	var Node3 = 1;

	/*
	  The look-up tables for tracing back the contour path
	  of isoBands
	*/

	var isoBandNextXTL = [];
	var isoBandNextYTL = [];
	var isoBandNextOTL = [];

	var isoBandNextXTR = [];
	var isoBandNextYTR = [];
	var isoBandNextOTR = [];

	var isoBandNextXRT = [];
	var isoBandNextYRT = [];
	var isoBandNextORT = [];

	var isoBandNextXRB = [];
	var isoBandNextYRB = [];
	var isoBandNextORB = [];

	var isoBandNextXBL = [];
	var isoBandNextYBL = [];
	var isoBandNextOBL = [];

	var isoBandNextXBR = [];
	var isoBandNextYBR = [];
	var isoBandNextOBR = [];

	var isoBandNextXLT = [];
	var isoBandNextYLT = [];
	var isoBandNextOLT = [];

	var isoBandNextXLB = [];
	var isoBandNextYLB = [];
	var isoBandNextOLB = [];

	isoBandNextXRT[85] = isoBandNextXRB[85] = -1;
	isoBandNextYRT[85] = isoBandNextYRB[85] = 0;
	isoBandNextORT[85] = isoBandNextORB[85] = 1;
	isoBandNextXLT[85] = isoBandNextXLB[85] = 1;
	isoBandNextYLT[85] = isoBandNextYLB[85] = 0;
	isoBandNextOLT[85] = isoBandNextOLB[85] = 1;

	isoBandNextXTL[85] = isoBandNextXTR[85] = 0;
	isoBandNextYTL[85] = isoBandNextYTR[85] = -1;
	isoBandNextOTL[85] = isoBandNextOBL[85] = 0;
	isoBandNextXBR[85] = isoBandNextXBL[85] = 0;
	isoBandNextYBR[85] = isoBandNextYBL[85] = 1;
	isoBandNextOTR[85] = isoBandNextOBR[85] = 1;


	/* triangle cases */
	isoBandNextXLB[1] = isoBandNextXLB[169] = 0;
	isoBandNextYLB[1] = isoBandNextYLB[169] = -1;
	isoBandNextOLB[1] = isoBandNextOLB[169] = 0;
	isoBandNextXBL[1] = isoBandNextXBL[169] = -1;
	isoBandNextYBL[1] = isoBandNextYBL[169] = 0;
	isoBandNextOBL[1] = isoBandNextOBL[169] = 0;

	isoBandNextXRB[4] = isoBandNextXRB[166] = 0;
	isoBandNextYRB[4] = isoBandNextYRB[166] = -1;
	isoBandNextORB[4] = isoBandNextORB[166] = 1;
	isoBandNextXBR[4] = isoBandNextXBR[166] = 1;
	isoBandNextYBR[4] = isoBandNextYBR[166] = 0;
	isoBandNextOBR[4] = isoBandNextOBR[166] = 0;

	isoBandNextXRT[16] = isoBandNextXRT[154] = 0;
	isoBandNextYRT[16] = isoBandNextYRT[154] = 1;
	isoBandNextORT[16] = isoBandNextORT[154] = 1;
	isoBandNextXTR[16] = isoBandNextXTR[154] = 1;
	isoBandNextYTR[16] = isoBandNextYTR[154] = 0;
	isoBandNextOTR[16] = isoBandNextOTR[154] = 1;

	isoBandNextXLT[64] = isoBandNextXLT[106] = 0;
	isoBandNextYLT[64] = isoBandNextYLT[106] = 1;
	isoBandNextOLT[64] = isoBandNextOLT[106] = 0;
	isoBandNextXTL[64] = isoBandNextXTL[106] = -1;
	isoBandNextYTL[64] = isoBandNextYTL[106] = 0;
	isoBandNextOTL[64] = isoBandNextOTL[106] = 1;

	/* single trapezoid cases */
	isoBandNextXLT[2] = isoBandNextXLT[168] = 0;
	isoBandNextYLT[2] = isoBandNextYLT[168] = -1;
	isoBandNextOLT[2] = isoBandNextOLT[168] = 1;
	isoBandNextXLB[2] = isoBandNextXLB[168] = 0;
	isoBandNextYLB[2] = isoBandNextYLB[168] = -1;
	isoBandNextOLB[2] = isoBandNextOLB[168] = 0;
	isoBandNextXBL[2] = isoBandNextXBL[168] = -1;
	isoBandNextYBL[2] = isoBandNextYBL[168] = 0;
	isoBandNextOBL[2] = isoBandNextOBL[168] = 0;
	isoBandNextXBR[2] = isoBandNextXBR[168] = -1;
	isoBandNextYBR[2] = isoBandNextYBR[168] = 0;
	isoBandNextOBR[2] = isoBandNextOBR[168] = 1;

	isoBandNextXRT[8] = isoBandNextXRT[162] = 0;
	isoBandNextYRT[8] = isoBandNextYRT[162] = -1;
	isoBandNextORT[8] = isoBandNextORT[162] = 0;
	isoBandNextXRB[8] = isoBandNextXRB[162] = 0;
	isoBandNextYRB[8] = isoBandNextYRB[162] = -1;
	isoBandNextORB[8] = isoBandNextORB[162] = 1;
	isoBandNextXBL[8] = isoBandNextXBL[162] = 1;
	isoBandNextYBL[8] = isoBandNextYBL[162] = 0;
	isoBandNextOBL[8] = isoBandNextOBL[162] = 1;
	isoBandNextXBR[8] = isoBandNextXBR[162] = 1;
	isoBandNextYBR[8] = isoBandNextYBR[162] = 0;
	isoBandNextOBR[8] = isoBandNextOBR[162] = 0;

	isoBandNextXRT[32] = isoBandNextXRT[138] = 0;
	isoBandNextYRT[32] = isoBandNextYRT[138] = 1;
	isoBandNextORT[32] = isoBandNextORT[138] = 1;
	isoBandNextXRB[32] = isoBandNextXRB[138] = 0;
	isoBandNextYRB[32] = isoBandNextYRB[138] = 1;
	isoBandNextORB[32] = isoBandNextORB[138] = 0;
	isoBandNextXTL[32] = isoBandNextXTL[138] = 1;
	isoBandNextYTL[32] = isoBandNextYTL[138] = 0;
	isoBandNextOTL[32] = isoBandNextOTL[138] = 0;
	isoBandNextXTR[32] = isoBandNextXTR[138] = 1;
	isoBandNextYTR[32] = isoBandNextYTR[138] = 0;
	isoBandNextOTR[32] = isoBandNextOTR[138] = 1;

	isoBandNextXLB[128] = isoBandNextXLB[42] = 0;
	isoBandNextYLB[128] = isoBandNextYLB[42] = 1;
	isoBandNextOLB[128] = isoBandNextOLB[42] = 1;
	isoBandNextXLT[128] = isoBandNextXLT[42] = 0;
	isoBandNextYLT[128] = isoBandNextYLT[42] = 1;
	isoBandNextOLT[128] = isoBandNextOLT[42] = 0;
	isoBandNextXTL[128] = isoBandNextXTL[42] = -1;
	isoBandNextYTL[128] = isoBandNextYTL[42] = 0;
	isoBandNextOTL[128] = isoBandNextOTL[42] = 1;
	isoBandNextXTR[128] = isoBandNextXTR[42] = -1;
	isoBandNextYTR[128] = isoBandNextYTR[42] = 0;
	isoBandNextOTR[128] = isoBandNextOTR[42] = 0;

	/* single rectangle cases */
	isoBandNextXRB[5] = isoBandNextXRB[165] = -1;
	isoBandNextYRB[5] = isoBandNextYRB[165] = 0;
	isoBandNextORB[5] = isoBandNextORB[165] = 0;
	isoBandNextXLB[5] = isoBandNextXLB[165] = 1;
	isoBandNextYLB[5] = isoBandNextYLB[165] = 0;
	isoBandNextOLB[5] = isoBandNextOLB[165] = 0;

	isoBandNextXBR[20] = isoBandNextXBR[150] = 0;
	isoBandNextYBR[20] = isoBandNextYBR[150] = 1;
	isoBandNextOBR[20] = isoBandNextOBR[150] = 1;
	isoBandNextXTR[20] = isoBandNextXTR[150] = 0;
	isoBandNextYTR[20] = isoBandNextYTR[150] = -1;
	isoBandNextOTR[20] = isoBandNextOTR[150] = 1;

	isoBandNextXRT[80] = isoBandNextXRT[90] = -1;
	isoBandNextYRT[80] = isoBandNextYRT[90] = 0;
	isoBandNextORT[80] = isoBandNextORT[90] = 1;
	isoBandNextXLT[80] = isoBandNextXLT[90] = 1;
	isoBandNextYLT[80] = isoBandNextYLT[90] = 0;
	isoBandNextOLT[80] = isoBandNextOLT[90] = 1;

	isoBandNextXBL[65] = isoBandNextXBL[105] = 0;
	isoBandNextYBL[65] = isoBandNextYBL[105] = 1;
	isoBandNextOBL[65] = isoBandNextOBL[105] = 0;
	isoBandNextXTL[65] = isoBandNextXTL[105] = 0;
	isoBandNextYTL[65] = isoBandNextYTL[105] = -1;
	isoBandNextOTL[65] = isoBandNextOTL[105] = 0;

	isoBandNextXRT[160] = isoBandNextXRT[10] = -1;
	isoBandNextYRT[160] = isoBandNextYRT[10] = 0;
	isoBandNextORT[160] = isoBandNextORT[10] = 1;
	isoBandNextXRB[160] = isoBandNextXRB[10] = -1;
	isoBandNextYRB[160] = isoBandNextYRB[10] = 0;
	isoBandNextORB[160] = isoBandNextORB[10] = 0;
	isoBandNextXLB[160] = isoBandNextXLB[10] = 1;
	isoBandNextYLB[160] = isoBandNextYLB[10] = 0;
	isoBandNextOLB[160] = isoBandNextOLB[10] = 0;
	isoBandNextXLT[160] = isoBandNextXLT[10] = 1;
	isoBandNextYLT[160] = isoBandNextYLT[10] = 0;
	isoBandNextOLT[160] = isoBandNextOLT[10] = 1;

	isoBandNextXBR[130] = isoBandNextXBR[40] = 0;
	isoBandNextYBR[130] = isoBandNextYBR[40] = 1;
	isoBandNextOBR[130] = isoBandNextOBR[40] = 1;
	isoBandNextXBL[130] = isoBandNextXBL[40] = 0;
	isoBandNextYBL[130] = isoBandNextYBL[40] = 1;
	isoBandNextOBL[130] = isoBandNextOBL[40] = 0;
	isoBandNextXTL[130] = isoBandNextXTL[40] = 0;
	isoBandNextYTL[130] = isoBandNextYTL[40] = -1;
	isoBandNextOTL[130] = isoBandNextOTL[40] = 0;
	isoBandNextXTR[130] = isoBandNextXTR[40] = 0;
	isoBandNextYTR[130] = isoBandNextYTR[40] = -1;
	isoBandNextOTR[130] = isoBandNextOTR[40] = 1;

	/* single hexagon cases */
	isoBandNextXRB[37] = isoBandNextXRB[133] = 0;
	isoBandNextYRB[37] = isoBandNextYRB[133] = 1;
	isoBandNextORB[37] = isoBandNextORB[133] = 1;
	isoBandNextXLB[37] = isoBandNextXLB[133] = 0;
	isoBandNextYLB[37] = isoBandNextYLB[133] = 1;
	isoBandNextOLB[37] = isoBandNextOLB[133] = 0;
	isoBandNextXTL[37] = isoBandNextXTL[133] = -1;
	isoBandNextYTL[37] = isoBandNextYTL[133] = 0;
	isoBandNextOTL[37] = isoBandNextOTL[133] = 0;
	isoBandNextXTR[37] = isoBandNextXTR[133] = 1;
	isoBandNextYTR[37] = isoBandNextYTR[133] = 0;
	isoBandNextOTR[37] = isoBandNextOTR[133] = 0;

	isoBandNextXBR[148] = isoBandNextXBR[22] = -1;
	isoBandNextYBR[148] = isoBandNextYBR[22] = 0;
	isoBandNextOBR[148] = isoBandNextOBR[22] = 0;
	isoBandNextXLB[148] = isoBandNextXLB[22] = 0;
	isoBandNextYLB[148] = isoBandNextYLB[22] = -1;
	isoBandNextOLB[148] = isoBandNextOLB[22] = 1;
	isoBandNextXLT[148] = isoBandNextXLT[22] = 0;
	isoBandNextYLT[148] = isoBandNextYLT[22] = 1;
	isoBandNextOLT[148] = isoBandNextOLT[22] = 1;
	isoBandNextXTR[148] = isoBandNextXTR[22] = -1;
	isoBandNextYTR[148] = isoBandNextYTR[22] = 0;
	isoBandNextOTR[148] = isoBandNextOTR[22] = 1;

	isoBandNextXRT[82] = isoBandNextXRT[88] = 0;
	isoBandNextYRT[82] = isoBandNextYRT[88] = -1;
	isoBandNextORT[82] = isoBandNextORT[88] = 1;
	isoBandNextXBR[82] = isoBandNextXBR[88] = 1;
	isoBandNextYBR[82] = isoBandNextYBR[88] = 0;
	isoBandNextOBR[82] = isoBandNextOBR[88] = 1;
	isoBandNextXBL[82] = isoBandNextXBL[88] = -1;
	isoBandNextYBL[82] = isoBandNextYBL[88] = 0;
	isoBandNextOBL[82] = isoBandNextOBL[88] = 1;
	isoBandNextXLT[82] = isoBandNextXLT[88] = 0;
	isoBandNextYLT[82] = isoBandNextYLT[88] = -1;
	isoBandNextOLT[82] = isoBandNextOLT[88] = 0;

	isoBandNextXRT[73] = isoBandNextXRT[97] = 0;
	isoBandNextYRT[73] = isoBandNextYRT[97] = 1;
	isoBandNextORT[73] = isoBandNextORT[97] = 0;
	isoBandNextXRB[73] = isoBandNextXRB[97] = 0;
	isoBandNextYRB[73] = isoBandNextYRB[97] = -1;
	isoBandNextORB[73] = isoBandNextORB[97] = 0;
	isoBandNextXBL[73] = isoBandNextXBL[97] = 1;
	isoBandNextYBL[73] = isoBandNextYBL[97] = 0;
	isoBandNextOBL[73] = isoBandNextOBL[97] = 0;
	isoBandNextXTL[73] = isoBandNextXTL[97] = 1;
	isoBandNextYTL[73] = isoBandNextYTL[97] = 0;
	isoBandNextOTL[73] = isoBandNextOTL[97] = 1;

	isoBandNextXRT[145] = isoBandNextXRT[25] = 0;
	isoBandNextYRT[145] = isoBandNextYRT[25] = -1;
	isoBandNextORT[145] = isoBandNextORT[25] = 0;
	isoBandNextXBL[145] = isoBandNextXBL[25] = 1;
	isoBandNextYBL[145] = isoBandNextYBL[25] = 0;
	isoBandNextOBL[145] = isoBandNextOBL[25] = 1;
	isoBandNextXLB[145] = isoBandNextXLB[25] = 0;
	isoBandNextYLB[145] = isoBandNextYLB[25] = 1;
	isoBandNextOLB[145] = isoBandNextOLB[25] = 1;
	isoBandNextXTR[145] = isoBandNextXTR[25] = -1;
	isoBandNextYTR[145] = isoBandNextYTR[25] = 0;
	isoBandNextOTR[145] = isoBandNextOTR[25] = 0;

	isoBandNextXRB[70] = isoBandNextXRB[100] = 0;
	isoBandNextYRB[70] = isoBandNextYRB[100] = 1;
	isoBandNextORB[70] = isoBandNextORB[100] = 0;
	isoBandNextXBR[70] = isoBandNextXBR[100] = -1;
	isoBandNextYBR[70] = isoBandNextYBR[100] = 0;
	isoBandNextOBR[70] = isoBandNextOBR[100] = 1;
	isoBandNextXLT[70] = isoBandNextXLT[100] = 0;
	isoBandNextYLT[70] = isoBandNextYLT[100] = -1;
	isoBandNextOLT[70] = isoBandNextOLT[100] = 1;
	isoBandNextXTL[70] = isoBandNextXTL[100] = 1;
	isoBandNextYTL[70] = isoBandNextYTL[100] = 0;
	isoBandNextOTL[70] = isoBandNextOTL[100] = 0;

	/* single pentagon cases */
	isoBandNextXRB[101] = isoBandNextXRB[69] = 0;
	isoBandNextYRB[101] = isoBandNextYRB[69] = 1;
	isoBandNextORB[101] = isoBandNextORB[69] = 0;
	isoBandNextXTL[101] = isoBandNextXTL[69] = 1;
	isoBandNextYTL[101] = isoBandNextYTL[69] = 0;
	isoBandNextOTL[101] = isoBandNextOTL[69] = 0;

	isoBandNextXLB[149] = isoBandNextXLB[21] = 0;
	isoBandNextYLB[149] = isoBandNextYLB[21] = 1;
	isoBandNextOLB[149] = isoBandNextOLB[21] = 1;
	isoBandNextXTR[149] = isoBandNextXTR[21] = -1;
	isoBandNextYTR[149] = isoBandNextYTR[21] = 0;
	isoBandNextOTR[149] = isoBandNextOTR[21] = 0;

	isoBandNextXBR[86] = isoBandNextXBR[84] = -1;
	isoBandNextYBR[86] = isoBandNextYBR[84] = 0;
	isoBandNextOBR[86] = isoBandNextOBR[84] = 1;
	isoBandNextXLT[86] = isoBandNextXLT[84] = 0;
	isoBandNextYLT[86] = isoBandNextYLT[84] = -1;
	isoBandNextOLT[86] = isoBandNextOLT[84] = 1;

	isoBandNextXRT[89] = isoBandNextXRT[81] = 0;
	isoBandNextYRT[89] = isoBandNextYRT[81] = -1;
	isoBandNextORT[89] = isoBandNextORT[81] = 0;
	isoBandNextXBL[89] = isoBandNextXBL[81] = 1;
	isoBandNextYBL[89] = isoBandNextYBL[81] = 0;
	isoBandNextOBL[89] = isoBandNextOBL[81] = 1;

	isoBandNextXRT[96] = isoBandNextXRT[74] = 0;
	isoBandNextYRT[96] = isoBandNextYRT[74] = 1;
	isoBandNextORT[96] = isoBandNextORT[74] = 0;
	isoBandNextXRB[96] = isoBandNextXRB[74] = -1;
	isoBandNextYRB[96] = isoBandNextYRB[74] = 0;
	isoBandNextORB[96] = isoBandNextORB[74] = 1;
	isoBandNextXLT[96] = isoBandNextXLT[74] = 1;
	isoBandNextYLT[96] = isoBandNextYLT[74] = 0;
	isoBandNextOLT[96] = isoBandNextOLT[74] = 0;
	isoBandNextXTL[96] = isoBandNextXTL[74] = 1;
	isoBandNextYTL[96] = isoBandNextYTL[74] = 0;
	isoBandNextOTL[96] = isoBandNextOTL[74] = 1;

	isoBandNextXRT[24] = isoBandNextXRT[146] = 0;
	isoBandNextYRT[24] = isoBandNextYRT[146] = -1;
	isoBandNextORT[24] = isoBandNextORT[146] = 1;
	isoBandNextXBR[24] = isoBandNextXBR[146] = 1;
	isoBandNextYBR[24] = isoBandNextYBR[146] = 0;
	isoBandNextOBR[24] = isoBandNextOBR[146] = 1;
	isoBandNextXBL[24] = isoBandNextXBL[146] = 0;
	isoBandNextYBL[24] = isoBandNextYBL[146] = 1;
	isoBandNextOBL[24] = isoBandNextOBL[146] = 1;
	isoBandNextXTR[24] = isoBandNextXTR[146] = 0;
	isoBandNextYTR[24] = isoBandNextYTR[146] = -1;
	isoBandNextOTR[24] = isoBandNextOTR[146] = 0;

	isoBandNextXRB[6] = isoBandNextXRB[164] = -1;
	isoBandNextYRB[6] = isoBandNextYRB[164] = 0;
	isoBandNextORB[6] = isoBandNextORB[164] = 1;
	isoBandNextXBR[6] = isoBandNextXBR[164] = -1;
	isoBandNextYBR[6] = isoBandNextYBR[164] = 0;
	isoBandNextOBR[6] = isoBandNextOBR[164] = 0;
	isoBandNextXLB[6] = isoBandNextXLB[164] = 0;
	isoBandNextYLB[6] = isoBandNextYLB[164] = -1;
	isoBandNextOLB[6] = isoBandNextOLB[164] = 1;
	isoBandNextXLT[6] = isoBandNextXLT[164] = 1;
	isoBandNextYLT[6] = isoBandNextYLT[164] = 0;
	isoBandNextOLT[6] = isoBandNextOLT[164] = 0;

	isoBandNextXBL[129] = isoBandNextXBL[41] = 0;
	isoBandNextYBL[129] = isoBandNextYBL[41] = 1;
	isoBandNextOBL[129] = isoBandNextOBL[41] = 1;
	isoBandNextXLB[129] = isoBandNextXLB[41] = 0;
	isoBandNextYLB[129] = isoBandNextYLB[41] = 1;
	isoBandNextOLB[129] = isoBandNextOLB[41] = 0;
	isoBandNextXTL[129] = isoBandNextXTL[41] = -1;
	isoBandNextYTL[129] = isoBandNextYTL[41] = 0;
	isoBandNextOTL[129] = isoBandNextOTL[41] = 0;
	isoBandNextXTR[129] = isoBandNextXTR[41] = 0;
	isoBandNextYTR[129] = isoBandNextYTR[41] = -1;
	isoBandNextOTR[129] = isoBandNextOTR[41] = 0;

	isoBandNextXBR[66] = isoBandNextXBR[104] = 0;
	isoBandNextYBR[66] = isoBandNextYBR[104] = 1;
	isoBandNextOBR[66] = isoBandNextOBR[104] = 0;
	isoBandNextXBL[66] = isoBandNextXBL[104] = -1;
	isoBandNextYBL[66] = isoBandNextYBL[104] = 0;
	isoBandNextOBL[66] = isoBandNextOBL[104] = 1;
	isoBandNextXLT[66] = isoBandNextXLT[104] = 0;
	isoBandNextYLT[66] = isoBandNextYLT[104] = -1;
	isoBandNextOLT[66] = isoBandNextOLT[104] = 0;
	isoBandNextXTL[66] = isoBandNextXTL[104] = 0;
	isoBandNextYTL[66] = isoBandNextYTL[104] = -1;
	isoBandNextOTL[66] = isoBandNextOTL[104] = 1;

	isoBandNextXRT[144] = isoBandNextXRT[26] = -1;
	isoBandNextYRT[144] = isoBandNextYRT[26] = 0;
	isoBandNextORT[144] = isoBandNextORT[26] = 0;
	isoBandNextXLB[144] = isoBandNextXLB[26] = 1;
	isoBandNextYLB[144] = isoBandNextYLB[26] = 0;
	isoBandNextOLB[144] = isoBandNextOLB[26] = 1;
	isoBandNextXLT[144] = isoBandNextXLT[26] = 0;
	isoBandNextYLT[144] = isoBandNextYLT[26] = 1;
	isoBandNextOLT[144] = isoBandNextOLT[26] = 1;
	isoBandNextXTR[144] = isoBandNextXTR[26] = -1;
	isoBandNextYTR[144] = isoBandNextYTR[26] = 0;
	isoBandNextOTR[144] = isoBandNextOTR[26] = 1;

	isoBandNextXRB[36] = isoBandNextXRB[134] = 0;
	isoBandNextYRB[36] = isoBandNextYRB[134] = 1;
	isoBandNextORB[36] = isoBandNextORB[134] = 1;
	isoBandNextXBR[36] = isoBandNextXBR[134] = 0;
	isoBandNextYBR[36] = isoBandNextYBR[134] = 1;
	isoBandNextOBR[36] = isoBandNextOBR[134] = 0;
	isoBandNextXTL[36] = isoBandNextXTL[134] = 0;
	isoBandNextYTL[36] = isoBandNextYTL[134] = -1;
	isoBandNextOTL[36] = isoBandNextOTL[134] = 1;
	isoBandNextXTR[36] = isoBandNextXTR[134] = 1;
	isoBandNextYTR[36] = isoBandNextYTR[134] = 0;
	isoBandNextOTR[36] = isoBandNextOTR[134] = 0;

	isoBandNextXRT[9] = isoBandNextXRT[161] = -1;
	isoBandNextYRT[9] = isoBandNextYRT[161] = 0;
	isoBandNextORT[9] = isoBandNextORT[161] = 0;
	isoBandNextXRB[9] = isoBandNextXRB[161] = 0;
	isoBandNextYRB[9] = isoBandNextYRB[161] = -1;
	isoBandNextORB[9] = isoBandNextORB[161] = 0;
	isoBandNextXBL[9] = isoBandNextXBL[161] = 1;
	isoBandNextYBL[9] = isoBandNextYBL[161] = 0;
	isoBandNextOBL[9] = isoBandNextOBL[161] = 0;
	isoBandNextXLB[9] = isoBandNextXLB[161] = 1;
	isoBandNextYLB[9] = isoBandNextYLB[161] = 0;
	isoBandNextOLB[9] = isoBandNextOLB[161] = 1;

	/* 8-sided cases */
	isoBandNextXRT[136] = 0;
	isoBandNextYRT[136] = 1;
	isoBandNextORT[136] = 1;
	isoBandNextXRB[136] = 0;
	isoBandNextYRB[136] = 1;
	isoBandNextORB[136] = 0;
	isoBandNextXBR[136] = -1;
	isoBandNextYBR[136] = 0;
	isoBandNextOBR[136] = 1;
	isoBandNextXBL[136] = -1;
	isoBandNextYBL[136] = 0;
	isoBandNextOBL[136] = 0;
	isoBandNextXLB[136] = 0;
	isoBandNextYLB[136] = -1;
	isoBandNextOLB[136] = 0;
	isoBandNextXLT[136] = 0;
	isoBandNextYLT[136] = -1;
	isoBandNextOLT[136] = 1;
	isoBandNextXTL[136] = 1;
	isoBandNextYTL[136] = 0;
	isoBandNextOTL[136] = 0;
	isoBandNextXTR[136] = 1;
	isoBandNextYTR[136] = 0;
	isoBandNextOTR[136] = 1;

	isoBandNextXRT[34] = 0;
	isoBandNextYRT[34] = -1;
	isoBandNextORT[34] = 0;
	isoBandNextXRB[34] = 0;
	isoBandNextYRB[34] = -1;
	isoBandNextORB[34] = 1;
	isoBandNextXBR[34] = 1;
	isoBandNextYBR[34] = 0;
	isoBandNextOBR[34] = 0;
	isoBandNextXBL[34] = 1;
	isoBandNextYBL[34] = 0;
	isoBandNextOBL[34] = 1;
	isoBandNextXLB[34] = 0;
	isoBandNextYLB[34] = 1;
	isoBandNextOLB[34] = 1;
	isoBandNextXLT[34] = 0;
	isoBandNextYLT[34] = 1;
	isoBandNextOLT[34] = 0;
	isoBandNextXTL[34] = -1;
	isoBandNextYTL[34] = 0;
	isoBandNextOTL[34] = 1;
	isoBandNextXTR[34] = -1;
	isoBandNextYTR[34] = 0;
	isoBandNextOTR[34] = 0;

	isoBandNextXRT[35] = 0;
	isoBandNextYRT[35] = 1;
	isoBandNextORT[35] = 1;
	isoBandNextXRB[35] = 0;
	isoBandNextYRB[35] = -1;
	isoBandNextORB[35] = 1;
	isoBandNextXBR[35] = 1;
	isoBandNextYBR[35] = 0;
	isoBandNextOBR[35] = 0;
	isoBandNextXBL[35] = -1;
	isoBandNextYBL[35] = 0;
	isoBandNextOBL[35] = 0;
	isoBandNextXLB[35] = 0;
	isoBandNextYLB[35] = -1;
	isoBandNextOLB[35] = 0;
	isoBandNextXLT[35] = 0;
	isoBandNextYLT[35] = 1;
	isoBandNextOLT[35] = 0;
	isoBandNextXTL[35] = -1;
	isoBandNextYTL[35] = 0;
	isoBandNextOTL[35] = 1;
	isoBandNextXTR[35] = 1;
	isoBandNextYTR[35] = 0;
	isoBandNextOTR[35] = 1;

	/* 6-sided cases */
	isoBandNextXRT[153] = 0;
	isoBandNextYRT[153] = 1;
	isoBandNextORT[153] = 1;
	isoBandNextXBL[153] = -1;
	isoBandNextYBL[153] = 0;
	isoBandNextOBL[153] = 0;
	isoBandNextXLB[153] = 0;
	isoBandNextYLB[153] = -1;
	isoBandNextOLB[153] = 0;
	isoBandNextXTR[153] = 1;
	isoBandNextYTR[153] = 0;
	isoBandNextOTR[153] = 1;

	isoBandNextXRB[102] = 0;
	isoBandNextYRB[102] = -1;
	isoBandNextORB[102] = 1;
	isoBandNextXBR[102] = 1;
	isoBandNextYBR[102] = 0;
	isoBandNextOBR[102] = 0;
	isoBandNextXLT[102] = 0;
	isoBandNextYLT[102] = 1;
	isoBandNextOLT[102] = 0;
	isoBandNextXTL[102] = -1;
	isoBandNextYTL[102] = 0;
	isoBandNextOTL[102] = 1;

	isoBandNextXRT[155] = 0;
	isoBandNextYRT[155] = -1;
	isoBandNextORT[155] = 0;
	isoBandNextXBL[155] = 1;
	isoBandNextYBL[155] = 0;
	isoBandNextOBL[155] = 1;
	isoBandNextXLB[155] = 0;
	isoBandNextYLB[155] = 1;
	isoBandNextOLB[155] = 1;
	isoBandNextXTR[155] = -1;
	isoBandNextYTR[155] = 0;
	isoBandNextOTR[155] = 0;

	isoBandNextXRB[103] = 0;
	isoBandNextYRB[103] = 1;
	isoBandNextORB[103] = 0;
	isoBandNextXBR[103] = -1;
	isoBandNextYBR[103] = 0;
	isoBandNextOBR[103] = 1;
	isoBandNextXLT[103] = 0;
	isoBandNextYLT[103] = -1;
	isoBandNextOLT[103] = 1;
	isoBandNextXTL[103] = 1;
	isoBandNextYTL[103] = 0;
	isoBandNextOTL[103] = 0;

	/* 7-sided cases */
	isoBandNextXRT[152] = 0;
	isoBandNextYRT[152] = 1;
	isoBandNextORT[152] = 1;
	isoBandNextXBR[152] = -1;
	isoBandNextYBR[152] = 0;
	isoBandNextOBR[152] = 1;
	isoBandNextXBL[152] = -1;
	isoBandNextYBL[152] = 0;
	isoBandNextOBL[152] = 0;
	isoBandNextXLB[152] = 0;
	isoBandNextYLB[152] = -1;
	isoBandNextOLB[152] = 0;
	isoBandNextXLT[152] = 0;
	isoBandNextYLT[152] = -1;
	isoBandNextOLT[152] = 1;
	isoBandNextXTR[152] = 1;
	isoBandNextYTR[152] = 0;
	isoBandNextOTR[152] = 1;

	isoBandNextXRT[156] = 0;
	isoBandNextYRT[156] = -1;
	isoBandNextORT[156] = 1;
	isoBandNextXBR[156] = 1;
	isoBandNextYBR[156] = 0;
	isoBandNextOBR[156] = 1;
	isoBandNextXBL[156] = -1;
	isoBandNextYBL[156] = 0;
	isoBandNextOBL[156] = 0;
	isoBandNextXLB[156] = 0;
	isoBandNextYLB[156] = -1;
	isoBandNextOLB[156] = 0;
	isoBandNextXLT[156] = 0;
	isoBandNextYLT[156] = 1;
	isoBandNextOLT[156] = 1;
	isoBandNextXTR[156] = -1;
	isoBandNextYTR[156] = 0;
	isoBandNextOTR[156] = 1;

	isoBandNextXRT[137] = 0;
	isoBandNextYRT[137] = 1;
	isoBandNextORT[137] = 1;
	isoBandNextXRB[137] = 0;
	isoBandNextYRB[137] = 1;
	isoBandNextORB[137] = 0;
	isoBandNextXBL[137] = -1;
	isoBandNextYBL[137] = 0;
	isoBandNextOBL[137] = 0;
	isoBandNextXLB[137] = 0;
	isoBandNextYLB[137] = -1;
	isoBandNextOLB[137] = 0;
	isoBandNextXTL[137] = 1;
	isoBandNextYTL[137] = 0;
	isoBandNextOTL[137] = 0;
	isoBandNextXTR[137] = 1;
	isoBandNextYTR[137] = 0;
	isoBandNextOTR[137] = 1;

	isoBandNextXRT[139] = 0;
	isoBandNextYRT[139] = 1;
	isoBandNextORT[139] = 1;
	isoBandNextXRB[139] = 0;
	isoBandNextYRB[139] = -1;
	isoBandNextORB[139] = 0;
	isoBandNextXBL[139] = 1;
	isoBandNextYBL[139] = 0;
	isoBandNextOBL[139] = 0;
	isoBandNextXLB[139] = 0;
	isoBandNextYLB[139] = 1;
	isoBandNextOLB[139] = 0;
	isoBandNextXTL[139] = -1;
	isoBandNextYTL[139] = 0;
	isoBandNextOTL[139] = 0;
	isoBandNextXTR[139] = 1;
	isoBandNextYTR[139] = 0;
	isoBandNextOTR[139] = 1;

	isoBandNextXRT[98] = 0;
	isoBandNextYRT[98] = -1;
	isoBandNextORT[98] = 0;
	isoBandNextXRB[98] = 0;
	isoBandNextYRB[98] = -1;
	isoBandNextORB[98] = 1;
	isoBandNextXBR[98] = 1;
	isoBandNextYBR[98] = 0;
	isoBandNextOBR[98] = 0;
	isoBandNextXBL[98] = 1;
	isoBandNextYBL[98] = 0;
	isoBandNextOBL[98] = 1;
	isoBandNextXLT[98] = 0;
	isoBandNextYLT[98] = 1;
	isoBandNextOLT[98] = 0;
	isoBandNextXTL[98] = -1;
	isoBandNextYTL[98] = 0;
	isoBandNextOTL[98] = 1;

	isoBandNextXRT[99] = 0;
	isoBandNextYRT[99] = 1;
	isoBandNextORT[99] = 0;
	isoBandNextXRB[99] = 0;
	isoBandNextYRB[99] = -1;
	isoBandNextORB[99] = 1;
	isoBandNextXBR[99] = 1;
	isoBandNextYBR[99] = 0;
	isoBandNextOBR[99] = 0;
	isoBandNextXBL[99] = -1;
	isoBandNextYBL[99] = 0;
	isoBandNextOBL[99] = 1;
	isoBandNextXLT[99] = 0;
	isoBandNextYLT[99] = -1;
	isoBandNextOLT[99] = 0;
	isoBandNextXTL[99] = 1;
	isoBandNextYTL[99] = 0;
	isoBandNextOTL[99] = 1;

	isoBandNextXRB[38] = 0;
	isoBandNextYRB[38] = -1;
	isoBandNextORB[38] = 1;
	isoBandNextXBR[38] = 1;
	isoBandNextYBR[38] = 0;
	isoBandNextOBR[38] = 0;
	isoBandNextXLB[38] = 0;
	isoBandNextYLB[38] = 1;
	isoBandNextOLB[38] = 1;
	isoBandNextXLT[38] = 0;
	isoBandNextYLT[38] = 1;
	isoBandNextOLT[38] = 0;
	isoBandNextXTL[38] = -1;
	isoBandNextYTL[38] = 0;
	isoBandNextOTL[38] = 1;
	isoBandNextXTR[38] = -1;
	isoBandNextYTR[38] = 0;
	isoBandNextOTR[38] = 0;

	isoBandNextXRB[39] = 0;
	isoBandNextYRB[39] = 1;
	isoBandNextORB[39] = 1;
	isoBandNextXBR[39] = -1;
	isoBandNextYBR[39] = 0;
	isoBandNextOBR[39] = 0;
	isoBandNextXLB[39] = 0;
	isoBandNextYLB[39] = -1;
	isoBandNextOLB[39] = 1;
	isoBandNextXLT[39] = 0;
	isoBandNextYLT[39] = 1;
	isoBandNextOLT[39] = 0;
	isoBandNextXTL[39] = -1;
	isoBandNextYTL[39] = 0;
	isoBandNextOTL[39] = 1;
	isoBandNextXTR[39] = 1;
	isoBandNextYTR[39] = 0;
	isoBandNextOTR[39] = 0;


	/*
	  Define helper functions for the polygon_table
	  */

	/* triangle cases */
	var p00 = function (cell) {
	    return [[cell.bottomleft, 0], [0, 0], [0, cell.leftbottom]];
	};
	var p01 = function (cell) {
	    return [[1, cell.rightbottom], [1, 0], [cell.bottomright, 0]];
	};
	var p02 = function (cell) {
	    return [[cell.topright, 1], [1, 1], [1, cell.righttop]];
	};
	var p03 = function (cell) {
	    return [[0, cell.lefttop], [0, 1], [cell.topleft, 1]];
	};
	/* trapezoid cases */
	var p04 = function (cell) {
	    return [[cell.bottomright, 0], [cell.bottomleft, 0], [0, cell.leftbottom], [0, cell.lefttop]];
	};
	var p05 = function (cell) {
	    return [[cell.bottomright, 0], [cell.bottomleft, 0], [1, cell.righttop], [1, cell.rightbottom]];
	};
	var p06 = function (cell) {
	    return [[1, cell.righttop], [1, cell.rightbottom], [cell.topleft, 1], [cell.topright, 1]];
	};
	var p07 = function (cell) {
	    return [[0, cell.leftbottom], [0, cell.lefttop], [cell.topleft, 1], [cell.topright, 1]];
	};
	/* rectangle cases */
	var p08 = function (cell) {
	    return [[0, 0], [0, cell.leftbottom], [1, cell.rightbottom], [1, 0]];
	};
	var p09 = function (cell) {
	    return [[1, 0], [cell.bottomright, 0], [cell.topright, 1], [1, 1]];
	};
	var p10 = function (cell) {
	    return [[1, 1], [1, cell.righttop], [0, cell.lefttop], [0, 1]];
	};
	var p11 = function (cell) {
	    return [[cell.bottomleft, 0], [0, 0], [0, 1], [cell.topleft, 1]];
	};
	var p12 = function (cell) {
	    return [[1, cell.righttop], [1, cell.rightbottom], [0, cell.leftbottom], [0, cell.lefttop]];
	};
	var p13 = function (cell) {
	    return [[cell.topleft, 1], [cell.topright, 1], [cell.bottomright, 0], [cell.bottomleft, 0]];
	};
	/* square case */
	var p14 = function () {
	    return [[0, 0], [0, 1], [1, 1], [1, 0]];
	};
	/* pentagon cases */
	var p15 = function (cell) {
	    return [[1, cell.rightbottom], [1, 0], [0, 0], [0, 1], [cell.topleft, 1]];
	};
	/* 1211 || 1011 */
	var p16 = function (cell) {
	    return [[cell.topright, 1], [1, 1], [1, 0], [0, 0], [0, cell.leftbottom]];
	};
	/* 2111 || 0111 */
	var p17 = function (cell) {
	    return [[1, 0], [cell.bottomright, 0], [0, cell.lefttop], [0, 1], [1, 1]];
	};
	/* 1112 || 1110 */
	var p18 = function (cell) {
	    return [[1, 1], [1, cell.righttop], [cell.bottomleft, 0], [0, 0], [0, 1]];
	};
	/* 1121 || 1101 */
	var p19 = function (cell) {
	    return [[1, cell.righttop], [1, cell.rightbottom], [0, cell.lefttop], [0, 1], [cell.topleft, 1]];
	};
	/* 1200 || 1022 */
	var p20 = function (cell) {
	    return [[1, 1], [1, cell.righttop], [cell.bottomright, 0], [cell.bottomleft, 0], [cell.topright, 1]];
	};
	/* 0120 || 2102 */
	var p21 = function (cell) {
	    return [[1, cell.rightbottom], [1, 0], [cell.bottomright, 0], [0, cell.leftbottom], [0, cell.lefttop]];
	};
	/* 0012 || 2210 */
	var p22 = function (cell) {
	    return [[cell.topright, 1], [cell.bottomleft, 0], [0, 0], [0, cell.leftbottom], [cell.topleft, 1]];
	};
	/* 2001 || 0221 */
	var p23 = function (cell) {
	    return [[cell.bottomright, 0], [cell.bottomleft, 0], [0, cell.lefttop], [0, 1], [cell.topleft, 1]];
	};
	/* 1002 || 1220 */
	var p24 = function (cell) {
	    return [[1, 1], [1, cell.righttop], [0, cell.leftbottom], [0, cell.lefttop], [cell.topright, 1]];
	};
	/* 2100 || 0122 */
	var p25 = function (cell) {
	    return [[1, cell.rightbottom], [1, 0], [cell.bottomright, 0], [cell.topleft, 1], [cell.topright, 1]];
	};
	/* 0210 || 2012 */
	var p26 = function (cell) {
	    return [[1, cell.righttop], [1, cell.rightbottom], [cell.bottomleft, 0], [0, 0], [0, cell.leftbottom]];
	};
	/* 0021 || 2201 */
	/*hexagon cases */
	var p27 = function (cell) {
	    return [[1, cell.rightbottom], [1, 0], [0, 0], [0, cell.leftbottom], [cell.topleft, 1], [cell.topright, 1]];
	};
	/* 0211 || 2011 */
	var p28 = function (cell) {
	    return [[1, 1], [1, 0], [cell.bottomright, 0], [0, cell.leftbottom], [0, cell.lefttop], [cell.topright, 1]];
	};
	/* 2110 || 0112 */
	var p29 = function (cell) {
	    return [[1, 1], [1, cell.righttop], [cell.bottomright, 0], [cell.bottomleft, 0], [0, cell.lefttop], [0, 1]];
	};
	/* 1102 || 1120 */
	var p30 = function (cell) {
	    return [[1, cell.righttop], [1, cell.rightbottom], [cell.bottomleft, 0], [0, 0], [0, 1], [cell.topleft, 1]];
	};
	/* 1021 || 1201 */
	var p31 = function (cell) {
	    return [[1, 1], [1, cell.righttop], [cell.bottomleft, 0], [0, 0], [0, cell.leftbottom], [cell.topright, 1]];
	};
	/* 2101 || 0121 */
	var p32 = function (cell) {
	    return [[1, cell.rightbottom], [1, 0], [cell.bottomright, 0], [0, cell.lefttop], [0, 1], [cell.topleft, 1]];
	};
	/* 1012 || 1210 */
	/* 8-sided cases */
	var p33 = function (cell) {
	    return [[1, cell.righttop], [1, cell.rightbottom], [cell.bottomright, 0], [cell.bottomleft, 0], [0, cell.leftbottom], [0, cell.lefttop], [cell.topleft, 1], [cell.topright, 1]];
	};
	/* flipped == 1 state for 0202 and 2020 */
	/* 6-sided cases */
	var p34 = function (cell) {
	    return [[1, 1], [1, cell.righttop], [cell.bottomleft, 0], [0, 0], [0, cell.leftbottom], [cell.topright, 1]];
	};
	/* 0101 with flipped == 1 || 2121 with flipped == 1 */
	var p35 = function (cell) {
	    return [[1, cell.rightbottom], [1, 0], [cell.bottomright, 0], [0, cell.lefttop], [0, 1], [cell.topleft, 1]];
	};
	/* 1010 with flipped == 1 || 1212 with flipped == 1 */
	/* 7-sided cases */
	var p36 = function (cell) {
	    return [[1, 1], [1, cell.righttop], [cell.bottomright, 0], [cell.bottomleft, 0], [0, cell.leftbottom], [0, cell.lefttop], [cell.topright, 1]];
	};
	/* 2120 with flipped == 1 || 0102 with flipped == 1 */
	var p37 = function (cell) {
	    return [[1, cell.righttop], [1, cell.rightbottom], [cell.bottomleft, 0], [0, 0], [0, cell.leftbottom], [cell.topleft, 1], [cell.topright, 1]];
	};
	/* 2021 with flipped == 1 || 0201 with flipped == 1 */
	var p38 = function (cell) {
	    return [[1, cell.righttop], [1, cell.rightbottom], [cell.bottomright, 0], [cell.bottomleft, 0], [0, cell.lefttop], [0, 1], [cell.topleft, 1]];
	};
	/* 1202 with flipped == 1 || 1020 with flipped == 1 */
	var p39 = function (cell) {
	    return [[1, cell.rightbottom], [1, 0], [cell.bottomright, 0], [0, cell.leftbottom], [0, cell.lefttop], [cell.topleft, 1], [cell.topright, 1]];
	};
	/* 0212 with flipped == 1 || 2010 with flipped == 1 */



	/*
	  The lookup tables for edge number given the polygon
	  is entered at a specific location
	*/

	var isoBandEdgeRT = [];
	var isoBandEdgeRB = [];
	var isoBandEdgeBR = [];
	var isoBandEdgeBL = [];
	var isoBandEdgeLB = [];
	var isoBandEdgeLT = [];
	var isoBandEdgeTL = [];
	var isoBandEdgeTR = [];

	/* triangle cases */
	isoBandEdgeBL[1]    = isoBandEdgeLB[1]    = 18;
	isoBandEdgeBL[169]  = isoBandEdgeLB[169]  = 18;
	isoBandEdgeBR[4]    = isoBandEdgeRB[4]    = 12;
	isoBandEdgeBR[166]  = isoBandEdgeRB[166]  = 12;
	isoBandEdgeRT[16]   = isoBandEdgeTR[16]   = 4;
	isoBandEdgeRT[154]  = isoBandEdgeTR[154]  = 4;
	isoBandEdgeLT[64]   = isoBandEdgeTL[64]   = 22;
	isoBandEdgeLT[106]  = isoBandEdgeTL[106]  = 22;

	/* trapezoid cases */
	isoBandEdgeBR[2]    = isoBandEdgeLT[2]    = 17;
	isoBandEdgeBL[2]    = isoBandEdgeLB[2]    = 18;
	isoBandEdgeBR[168]  = isoBandEdgeLT[168]  = 17;
	isoBandEdgeBL[168]  = isoBandEdgeLB[168]  = 18;
	isoBandEdgeRT[8]    = isoBandEdgeBL[8]    = 9;
	isoBandEdgeRB[8]    = isoBandEdgeBR[8]    = 12;
	isoBandEdgeRT[162]  = isoBandEdgeBL[162]  = 9;
	isoBandEdgeRB[162]  = isoBandEdgeBR[162]  = 12;
	isoBandEdgeRT[32]   = isoBandEdgeTR[32]   = 4;
	isoBandEdgeRB[32]   = isoBandEdgeTL[32]   = 1;
	isoBandEdgeRT[138]  = isoBandEdgeTR[138]  = 4;
	isoBandEdgeRB[138]  = isoBandEdgeTL[138]  = 1;
	isoBandEdgeLB[128]  = isoBandEdgeTR[128]  = 21;
	isoBandEdgeLT[128]  = isoBandEdgeTL[128]  = 22;
	isoBandEdgeLB[42]   = isoBandEdgeTR[42]   = 21;
	isoBandEdgeLT[42]   = isoBandEdgeTL[42]   = 22;

	/* rectangle cases */
	isoBandEdgeRB[5] = isoBandEdgeLB[5] = 14;
	isoBandEdgeRB[165] = isoBandEdgeLB[165] = 14;
	isoBandEdgeBR[20] = isoBandEdgeTR[20] = 6;
	isoBandEdgeBR[150] = isoBandEdgeTR[150] = 6;
	isoBandEdgeRT[80] = isoBandEdgeLT[80] = 11;
	isoBandEdgeRT[90] = isoBandEdgeLT[90] = 11;
	isoBandEdgeBL[65] = isoBandEdgeTL[65] = 3;
	isoBandEdgeBL[105] = isoBandEdgeTL[105] = 3;
	isoBandEdgeRT[160] = isoBandEdgeLT[160] = 11;
	isoBandEdgeRB[160] = isoBandEdgeLB[160] = 14;
	isoBandEdgeRT[10] = isoBandEdgeLT[10] = 11;
	isoBandEdgeRB[10] = isoBandEdgeLB[10] = 14;
	isoBandEdgeBR[130] = isoBandEdgeTR[130] = 6;
	isoBandEdgeBL[130] = isoBandEdgeTL[130] = 3;
	isoBandEdgeBR[40] = isoBandEdgeTR[40] = 6;
	isoBandEdgeBL[40] = isoBandEdgeTL[40] = 3;

	/* pentagon cases */
	isoBandEdgeRB[101] = isoBandEdgeTL[101] = 1;
	isoBandEdgeRB[69] = isoBandEdgeTL[69] = 1;
	isoBandEdgeLB[149] = isoBandEdgeTR[149] = 21;
	isoBandEdgeLB[21] = isoBandEdgeTR[21] = 21;
	isoBandEdgeBR[86] = isoBandEdgeLT[86] = 17;
	isoBandEdgeBR[84] = isoBandEdgeLT[84] = 17;
	isoBandEdgeRT[89] = isoBandEdgeBL[89] = 9;
	isoBandEdgeRT[81] = isoBandEdgeBL[81] = 9;
	isoBandEdgeRT[96] = isoBandEdgeTL[96] = 0;
	isoBandEdgeRB[96] = isoBandEdgeLT[96] = 15;
	isoBandEdgeRT[74] = isoBandEdgeTL[74] = 0;
	isoBandEdgeRB[74] = isoBandEdgeLT[74] = 15;
	isoBandEdgeRT[24] = isoBandEdgeBR[24] = 8;
	isoBandEdgeBL[24] = isoBandEdgeTR[24] = 7;
	isoBandEdgeRT[146] = isoBandEdgeBR[146] = 8;
	isoBandEdgeBL[146] = isoBandEdgeTR[146] = 7;
	isoBandEdgeRB[6] = isoBandEdgeLT[6] = 15;
	isoBandEdgeBR[6] = isoBandEdgeLB[6] = 16;
	isoBandEdgeRB[164] = isoBandEdgeLT[164] = 15;
	isoBandEdgeBR[164] = isoBandEdgeLB[164] = 16;
	isoBandEdgeBL[129] = isoBandEdgeTR[129] = 7;
	isoBandEdgeLB[129] = isoBandEdgeTL[129] = 20;
	isoBandEdgeBL[41] = isoBandEdgeTR[41] = 7;
	isoBandEdgeLB[41] = isoBandEdgeTL[41] = 20;
	isoBandEdgeBR[66] = isoBandEdgeTL[66] = 2;
	isoBandEdgeBL[66] = isoBandEdgeLT[66] = 19;
	isoBandEdgeBR[104] = isoBandEdgeTL[104] = 2;
	isoBandEdgeBL[104] = isoBandEdgeLT[104] = 19;
	isoBandEdgeRT[144] = isoBandEdgeLB[144] = 10;
	isoBandEdgeLT[144] = isoBandEdgeTR[144] = 23;
	isoBandEdgeRT[26] = isoBandEdgeLB[26] = 10;
	isoBandEdgeLT[26] = isoBandEdgeTR[26] = 23;
	isoBandEdgeRB[36] = isoBandEdgeTR[36] = 5;
	isoBandEdgeBR[36] = isoBandEdgeTL[36] = 2;
	isoBandEdgeRB[134] = isoBandEdgeTR[134] = 5;
	isoBandEdgeBR[134] = isoBandEdgeTL[134] = 2;
	isoBandEdgeRT[9] = isoBandEdgeLB[9] = 10;
	isoBandEdgeRB[9] = isoBandEdgeBL[9] = 13;
	isoBandEdgeRT[161] = isoBandEdgeLB[161] = 10;
	isoBandEdgeRB[161] = isoBandEdgeBL[161] = 13;

	/* hexagon cases */
	isoBandEdgeRB[37] = isoBandEdgeTR[37] = 5;
	isoBandEdgeLB[37] = isoBandEdgeTL[37] = 20;
	isoBandEdgeRB[133] = isoBandEdgeTR[133] = 5;
	isoBandEdgeLB[133] = isoBandEdgeTL[133] = 20;
	isoBandEdgeBR[148] = isoBandEdgeLB[148] = 16;
	isoBandEdgeLT[148] = isoBandEdgeTR[148] = 23;
	isoBandEdgeBR[22] = isoBandEdgeLB[22] = 16;
	isoBandEdgeLT[22] = isoBandEdgeTR[22] = 23;
	isoBandEdgeRT[82] = isoBandEdgeBR[82] = 8;
	isoBandEdgeBL[82] = isoBandEdgeLT[82] = 19;
	isoBandEdgeRT[88] = isoBandEdgeBR[88] = 8;
	isoBandEdgeBL[88] = isoBandEdgeLT[88] = 19;
	isoBandEdgeRT[73] = isoBandEdgeTL[73] = 0;
	isoBandEdgeRB[73] = isoBandEdgeBL[73] = 13;
	isoBandEdgeRT[97] = isoBandEdgeTL[97] = 0;
	isoBandEdgeRB[97] = isoBandEdgeBL[97] = 13;
	isoBandEdgeRT[145] = isoBandEdgeBL[145] = 9;
	isoBandEdgeLB[145] = isoBandEdgeTR[145] = 21;
	isoBandEdgeRT[25] = isoBandEdgeBL[25] = 9;
	isoBandEdgeLB[25] = isoBandEdgeTR[25] = 21;
	isoBandEdgeRB[70] = isoBandEdgeTL[70] = 1;
	isoBandEdgeBR[70] = isoBandEdgeLT[70] = 17;
	isoBandEdgeRB[100] = isoBandEdgeTL[100] = 1;
	isoBandEdgeBR[100] = isoBandEdgeLT[100] = 17;

	/* 8-sided cases */
	isoBandEdgeRT[34] = isoBandEdgeBL[34] = 9;
	isoBandEdgeRB[34] = isoBandEdgeBR[34] = 12;
	isoBandEdgeLB[34] = isoBandEdgeTR[34] = 21;
	isoBandEdgeLT[34] = isoBandEdgeTL[34] = 22;
	isoBandEdgeRT[136] = isoBandEdgeTR[136] = 4;
	isoBandEdgeRB[136] = isoBandEdgeTL[136] = 1;
	isoBandEdgeBR[136] = isoBandEdgeLT[136] = 17;
	isoBandEdgeBL[136] = isoBandEdgeLB[136] = 18;
	isoBandEdgeRT[35] = isoBandEdgeTR[35] = 4;
	isoBandEdgeRB[35] = isoBandEdgeBR[35] = 12;
	isoBandEdgeBL[35] = isoBandEdgeLB[35] = 18;
	isoBandEdgeLT[35] = isoBandEdgeTL[35] = 22;

	/* 6-sided cases */
	isoBandEdgeRT[153] = isoBandEdgeTR[153] = 4;
	isoBandEdgeBL[153] = isoBandEdgeLB[153] = 18;
	isoBandEdgeRB[102] = isoBandEdgeBR[102] = 12;
	isoBandEdgeLT[102] = isoBandEdgeTL[102] = 22;
	isoBandEdgeRT[155] = isoBandEdgeBL[155] = 9;
	isoBandEdgeLB[155] = isoBandEdgeTR[155] = 23;
	isoBandEdgeRB[103] = isoBandEdgeTL[103] = 1;
	isoBandEdgeBR[103] = isoBandEdgeLT[103] = 17;

	/* 7-sided cases */
	isoBandEdgeRT[152] = isoBandEdgeTR[152] = 4;
	isoBandEdgeBR[152] = isoBandEdgeLT[152] = 17;
	isoBandEdgeBL[152] = isoBandEdgeLB[152] = 18;
	isoBandEdgeRT[156] = isoBandEdgeBR[156] = 8;
	isoBandEdgeBL[156] = isoBandEdgeLB[156] = 18;
	isoBandEdgeLT[156] = isoBandEdgeTR[156] = 23;
	isoBandEdgeRT[137] = isoBandEdgeTR[137] = 4;
	isoBandEdgeRB[137] = isoBandEdgeTL[137] = 1;
	isoBandEdgeBL[137] = isoBandEdgeLB[137] = 18;
	isoBandEdgeRT[139] = isoBandEdgeTR[139] = 4;
	isoBandEdgeRB[139] = isoBandEdgeBL[139] = 13;
	isoBandEdgeLB[139] = isoBandEdgeTL[139] = 20;
	isoBandEdgeRT[98] = isoBandEdgeBL[98] = 9;
	isoBandEdgeRB[98] = isoBandEdgeBR[98] = 12;
	isoBandEdgeLT[98] = isoBandEdgeTL[98] = 22;
	isoBandEdgeRT[99] = isoBandEdgeTL[99] = 0;
	isoBandEdgeRB[99] = isoBandEdgeBR[99] = 12;
	isoBandEdgeBL[99] = isoBandEdgeLT[99] = 19;
	isoBandEdgeRB[38] = isoBandEdgeBR[38] = 12;
	isoBandEdgeLB[38] = isoBandEdgeTR[38] = 21;
	isoBandEdgeLT[38] = isoBandEdgeTL[38] = 22;
	isoBandEdgeRB[39] = isoBandEdgeTR[39] = 5;
	isoBandEdgeBR[39] = isoBandEdgeLB[39] = 16;
	isoBandEdgeLT[39] = isoBandEdgeTL[39] = 22;

	/*
	  The lookup tables for all different polygons that
	  may appear within a grid cell
	*/

	var polygon_table = [];

	/* triangle cases */
	polygon_table[1] = polygon_table[169] = p00; /* 2221 || 0001 */
	polygon_table[4] = polygon_table[166] = p01; /* 2212 || 0010 */
	polygon_table[16] = polygon_table[154] = p02; /* 2122 || 0100 */
	polygon_table[64] = polygon_table[106] = p03; /* 1222 || 1000 */

	/* trapezoid cases */
	polygon_table[168] = polygon_table[2] = p04; /* 2220 || 0002 */
	polygon_table[162] = polygon_table[8] = p05; /* 2202 || 0020 */
	polygon_table[138] = polygon_table[32] = p06; /* 2022 || 0200 */
	polygon_table[42] = polygon_table[128] = p07; /* 0222 || 2000 */

	/* rectangle cases */
	polygon_table[5] = polygon_table[165] = p08; /* 0011 || 2211 */
	polygon_table[20] = polygon_table[150] = p09; /* 0110 || 2112 */
	polygon_table[80] = polygon_table[90] = p10; /* 1100 || 1122 */
	polygon_table[65] = polygon_table[105] = p11; /* 1001 || 1221 */
	polygon_table[160] = polygon_table[10] = p12; /* 2200 || 0022 */
	polygon_table[130] = polygon_table[40] = p13; /* 2002 || 0220 */

	/* square case */
	polygon_table[85] = p14; /* 1111 */

	/* pentagon cases */
	polygon_table[101] = polygon_table[69] = p15; /* 1211 || 1011 */
	polygon_table[149] = polygon_table[21] = p16; /* 2111 || 0111 */
	polygon_table[86] = polygon_table[84] = p17; /* 1112 || 1110 */
	polygon_table[89] = polygon_table[81] = p18; /* 1121 || 1101 */
	polygon_table[96] = polygon_table[74] = p19; /* 1200 || 1022 */
	polygon_table[24] = polygon_table[146] = p20; /* 0120 || 2102 */
	polygon_table[6] = polygon_table[164] = p21; /* 0012 || 2210 */
	polygon_table[129] = polygon_table[41] = p22; /* 2001 || 0221 */
	polygon_table[66] = polygon_table[104] = p23; /* 1002 || 1220 */
	polygon_table[144] = polygon_table[26] = p24; /* 2100 || 0122 */
	polygon_table[36] = polygon_table[134] = p25; /* 0210 || 2012 */
	polygon_table[9] = polygon_table[161] = p26; /* 0021 || 2201 */

	/* hexagon cases */
	polygon_table[37] = polygon_table[133] = p27; /* 0211 || 2011 */
	polygon_table[148] = polygon_table[22] = p28; /* 2110 || 0112 */
	polygon_table[82] = polygon_table[88] = p29; /* 1102 || 1120 */
	polygon_table[73] = polygon_table[97] = p30; /* 1021 || 1201 */
	polygon_table[145] = polygon_table[25] = p31; /* 2101 || 0121 */
	polygon_table[70] = polygon_table[100] = p32; /* 1012 || 1210 */

	/* 8-sided cases */
	polygon_table[34] = function (c) { return [p07(c), p05(c)]; }; /* 0202 || 2020 with flipped == 0 */
	polygon_table[35] = p33; /* flipped == 1 state for 0202 and 2020 */
	polygon_table[136] = function (c) { return [p06(c), p04(c)]; }; /* 2020 || 0202 with flipped == 0 */

	/* 6-sided cases */
	polygon_table[153] = function (c) { return [p02(c), p00(c)]; }; /* 0101 with flipped == 0 || 2121 with flipped == 2 */
	polygon_table[102] = function (c) { return [p01(c), p03(c)]; }; /* 1010 with flipped == 0 || 1212 with flipped == 2 */
	polygon_table[155] = p34; /* 0101 with flipped == 1 || 2121 with flipped == 1 */
	polygon_table[103] = p35; /* 1010 with flipped == 1 || 1212 with flipped == 1 */

	/* 7-sided cases */
	polygon_table[152] = function (c) { return [p02(c), p04(c)]; }; /* 2120 with flipped == 2 || 0102 with flipped == 0 */
	polygon_table[156] = p36; /* 2120 with flipped == 1 || 0102 with flipped == 1 */
	polygon_table[137] = function (c) { return [p06(c), p00(c)]; }; /* 2021 with flipped == 2 || 0201 with flipped == 0 */
	polygon_table[139] = p37; /* 2021 with flipped == 1 || 0201 with flipped == 1 */
	polygon_table[98] = function (c) { return [p05(c), p03(c)]; }; /* 1202 with flipped == 2 || 1020 with flipped == 0 */
	polygon_table[99] = p38; /* 1202 with flipped == 1 || 1020 with flipped == 1 */
	polygon_table[38] = function (c) { return [p01(c), p07(c)]; }; /* 0212 with flipped == 2 || 2010 with flipped == 0 */
	polygon_table[39] = p39; /* 0212 with flipped == 1 || 2010 with flipped == 1 */


	/*
	####################################
	Some small helper functions
	####################################
	*/

	/* assume that x1 == 1 &&  x0 == 0 */
	function interpolateX(y, y0, y1) {
	    return (y - y0) / (y1 - y0);
	}

	function isArray$3(myArray) {
	    return myArray.constructor.toString().indexOf('Array') > -1;
	}

	/*
	####################################
	Below is the actual Marching Squares implementation
	####################################
	*/

	function computeBandGrid(data, minV, bandwidth) {
	    var rows = data.length - 1;
	    var cols = data[0].length - 1;
	    var BandGrid = { rows: rows, cols: cols, cells: [] };

	    var maxV = minV + Math.abs(bandwidth);

	    for (var j = 0; j < rows; ++j) {
	        BandGrid.cells[j] = [];
	        for (var i = 0; i < cols; ++i) {
	            /*  compose the 4-trit corner representation */
	            var cval = 0;

	            var tl = data[j + 1][i];
	            var tr = data[j + 1][i + 1];
	            var br = data[j][i + 1];
	            var bl = data[j][i];

	            if (isNaN(tl) || isNaN(tr) || isNaN(br) || isNaN(bl)) {
	                continue;
	            }

	            cval |= (tl < minV) ? 0 : (tl > maxV) ? 128 : 64;
	            cval |= (tr < minV) ? 0 : (tr > maxV) ? 32 : 16;
	            cval |= (br < minV) ? 0 : (br > maxV) ? 8 : 4;
	            cval |= (bl < minV) ? 0 : (bl > maxV) ? 2 : 1;

	            var cval_real = +cval;

	            /* resolve ambiguity via averaging */
	            var flipped = 0;
	            if ((cval === 17)  || /* 0101 */
	          (cval === 18)  || /* 0102 */
	          (cval === 33)  || /* 0201 */
	          (cval === 34)  || /* 0202 */
	          (cval === 38)  || /* 0212 */
	          (cval === 68)  || /* 1010 */
	          (cval === 72)  || /* 1020 */
	          (cval === 98)  || /* 1202 */
	          (cval === 102)  || /* 1212 */
	          (cval === 132)  || /* 2010 */
	          (cval === 136)  || /* 2020 */
	          (cval === 137)  || /* 2021 */
	          (cval === 152)  || /* 2120 */
	          (cval === 153) /* 2121 */
	            ) {
	                var average = (tl + tr + br + bl) / 4;
	                /* set flipped state */
	                flipped = (average > maxV) ? 2 : (average < minV) ? 0 : 1;

	                /* adjust cval for flipped cases */

	                /* 8-sided cases */
	                if (cval === 34) {
	                    if (flipped === 1) {
	                        cval = 35;
	                    } else if (flipped === 0) {
	                        cval = 136;
	                    }
	                } else if (cval === 136) {
	                    if (flipped === 1) {
	                        cval = 35;
	                        flipped = 4;
	                    } else if (flipped === 0) {
	                        cval = 34;
	                    }
	                }

	                /* 6-sided polygon cases */
	                else if (cval === 17) {
	                    if (flipped === 1) {
	                        cval = 155;
	                        flipped = 4;
	                    } else if (flipped === 0) {
	                        cval = 153;
	                    }
	                } else if (cval === 68) {
	                    if (flipped === 1) {
	                        cval = 103;
	                        flipped = 4;
	                    } else if (flipped === 0) {
	                        cval = 102;
	                    }
	                } else if (cval === 153) {
	                    if (flipped === 1)
	                        cval = 155;
	                } else if (cval === 102) {
	                    if (flipped === 1)
	                        cval = 103;
	                }

	                /* 7-sided polygon cases */
	                else if (cval === 152) {
	                    if (flipped < 2) {
	                        cval    = 156;
	                        flipped = 1;
	                    }
	                } else if (cval === 137) {
	                    if (flipped < 2) {
	                        cval = 139;
	                        flipped = 1;
	                    }
	                } else if (cval === 98) {
	                    if (flipped < 2) {
	                        cval    = 99;
	                        flipped = 1;
	                    }
	                } else if (cval === 38) {
	                    if (flipped < 2) {
	                        cval    = 39;
	                        flipped = 1;
	                    }
	                } else if (cval === 18) {
	                    if (flipped > 0) {
	                        cval = 156;
	                        flipped = 4;
	                    } else {
	                        cval = 152;
	                    }
	                } else if (cval === 33) {
	                    if (flipped > 0) {
	                        cval = 139;
	                        flipped = 4;
	                    } else {
	                        cval = 137;
	                    }
	                } else if (cval === 72) {
	                    if (flipped > 0) {
	                        cval = 99;
	                        flipped = 4;
	                    } else {
	                        cval = 98;
	                    }
	                } else if (cval === 132) {
	                    if (flipped > 0) {
	                        cval = 39;
	                        flipped = 4;
	                    } else {
	                        cval = 38;
	                    }
	                }
	            }

	            /* add cell to BandGrid if it contains at least one polygon-side */
	            if ((cval != 0) && (cval != 170)) {
	                var topleft, topright, bottomleft, bottomright,
	                    righttop, rightbottom, lefttop, leftbottom;

	                topleft = topright = bottomleft = bottomright = righttop =
	                rightbottom = lefttop = leftbottom = 0.5;

	                var edges = [];

	                /* do interpolation here */
	                /* 1st Triangles */
	                if (cval === 1) { /* 0001 */
	                    bottomleft = 1 - interpolateX(minV, br, bl);
	                    leftbottom = 1 - interpolateX(minV, tl, bl);
	                    edges.push(isoBandEdgeBL[cval]);
	                } else if (cval === 169) { /* 2221 */
	                    bottomleft = interpolateX(maxV, bl, br);
	                    leftbottom = interpolateX(maxV, bl, tl);
	                    edges.push(isoBandEdgeBL[cval]);
	                } else if (cval === 4) { /* 0010 */
	                    rightbottom = 1 - interpolateX(minV, tr, br);
	                    bottomright = interpolateX(minV, bl, br);
	                    edges.push(isoBandEdgeRB[cval]);
	                } else if (cval === 166) { /* 2212 */
	                    rightbottom = interpolateX(maxV, br, tr);
	                    bottomright = 1 - interpolateX(maxV, br, bl);
	                    edges.push(isoBandEdgeRB[cval]);
	                } else if (cval === 16) { /* 0100 */
	                    righttop = interpolateX(minV, br, tr);
	                    topright = interpolateX(minV, tl, tr);
	                    edges.push(isoBandEdgeRT[cval]);
	                } else if (cval === 154) { /* 2122 */
	                    righttop = 1 - interpolateX(maxV, tr, br);
	                    topright = 1 - interpolateX(maxV, tr, tl);
	                    edges.push(isoBandEdgeRT[cval]);
	                } else if (cval === 64) { /* 1000 */
	                    lefttop = interpolateX(minV, bl, tl);
	                    topleft = 1 - interpolateX(minV, tr, tl);
	                    edges.push(isoBandEdgeLT[cval]);
	                } else if (cval === 106) { /* 1222 */
	                    lefttop = 1 - interpolateX(maxV, tl, bl);
	                    topleft = interpolateX(maxV, tl, tr);
	                    edges.push(isoBandEdgeLT[cval]);
	                }
	                /* 2nd Trapezoids */
	                else if (cval === 168) { /* 2220 */
	                    bottomright = interpolateX(maxV, bl, br);
	                    bottomleft = interpolateX(minV, bl, br);
	                    leftbottom = interpolateX(minV, bl, tl);
	                    lefttop = interpolateX(maxV, bl, tl);
	                    edges.push(isoBandEdgeBR[cval]);
	                    edges.push(isoBandEdgeBL[cval]);
	                } else if (cval === 2) { /* 0002 */
	                    bottomright = 1 - interpolateX(minV, br, bl);
	                    bottomleft = 1 - interpolateX(maxV, br, bl);
	                    leftbottom = 1 - interpolateX(maxV, tl, bl);
	                    lefttop = 1 - interpolateX(minV, tl, bl);
	                    edges.push(isoBandEdgeBR[cval]);
	                    edges.push(isoBandEdgeBL[cval]);
	                } else if (cval === 162) { /* 2202 */
	                    righttop = interpolateX(maxV, br, tr);
	                    rightbottom = interpolateX(minV, br, tr);
	                    bottomright = 1 - interpolateX(minV, br, bl);
	                    bottomleft = 1 - interpolateX(maxV, br, bl);
	                    edges.push(isoBandEdgeBR[cval]);
	                    edges.push(isoBandEdgeBL[cval]);
	                } else if (cval === 8) { /* 0020 */
	                    righttop = 1 - interpolateX(minV, tr, br);
	                    rightbottom = 1 - interpolateX(maxV, tr, br);
	                    bottomright = interpolateX(maxV, bl, br);
	                    bottomleft = interpolateX(minV, bl, br);
	                    edges.push(isoBandEdgeRT[cval]);
	                    edges.push(isoBandEdgeRB[cval]);
	                } else if (cval === 138) { /* 2022 */
	                    righttop = 1 - interpolateX(minV, tr, br);
	                    rightbottom = 1 - interpolateX(maxV, tr, br);
	                    topleft = 1 - interpolateX(maxV, tr, tl);
	                    topright = 1 - interpolateX(minV, tr, tl);
	                    edges.push(isoBandEdgeRT[cval]);
	                    edges.push(isoBandEdgeRB[cval]);
	                } else if (cval === 32) { /* 0200 */
	                    righttop = interpolateX(maxV, br, tr);
	                    rightbottom = interpolateX(minV, br, tr);
	                    topleft = interpolateX(minV, tl, tr);
	                    topright = interpolateX(maxV, tl, tr);
	                    edges.push(isoBandEdgeRT[cval]);
	                    edges.push(isoBandEdgeRB[cval]);
	                } else if (cval === 42) { /* 0222 */
	                    leftbottom = 1 - interpolateX(maxV, tl, bl);
	                    lefttop = 1 - interpolateX(minV, tl, bl);
	                    topleft = interpolateX(minV, tl, tr);
	                    topright = interpolateX(maxV, tl, tr);
	                    edges.push(isoBandEdgeLB[cval]);
	                    edges.push(isoBandEdgeLT[cval]);
	                } else if (cval === 128) { /* 2000 */
	                    leftbottom = interpolateX(minV, bl, tl);
	                    lefttop = interpolateX(maxV, bl, tl);
	                    topleft = 1 - interpolateX(maxV, tr, tl);
	                    topright = 1 - interpolateX(minV, tr, tl);
	                    edges.push(isoBandEdgeLB[cval]);
	                    edges.push(isoBandEdgeLT[cval]);
	                }

	                /* 3rd rectangle cases */
	                if (cval === 5) { /* 0011 */
	                    rightbottom = 1 - interpolateX(minV, tr, br);
	                    leftbottom = 1 - interpolateX(minV, tl, bl);
	                    edges.push(isoBandEdgeRB[cval]);
	                } else if (cval === 165) { /* 2211 */
	                    rightbottom = interpolateX(maxV, br, tr);
	                    leftbottom = interpolateX(maxV, bl, tl);
	                    edges.push(isoBandEdgeRB[cval]);
	                } else if (cval === 20) { /* 0110 */
	                    bottomright = interpolateX(minV, bl, br);
	                    topright = interpolateX(minV, tl, tr);
	                    edges.push(isoBandEdgeBR[cval]);
	                } else if (cval === 150) { /* 2112 */
	                    bottomright = 1 - interpolateX(maxV, br, bl);
	                    topright = 1 - interpolateX(maxV, tr, tl);
	                    edges.push(isoBandEdgeBR[cval]);
	                } else if (cval === 80) { /* 1100 */
	                    righttop = interpolateX(minV, br, tr);
	                    lefttop = interpolateX(minV, bl, tl);
	                    edges.push(isoBandEdgeRT[cval]);
	                } else if (cval === 90) { /* 1122 */
	                    righttop = 1 - interpolateX(maxV, tr, br);
	                    lefttop = 1 - interpolateX(maxV, tl, bl);
	                    edges.push(isoBandEdgeRT[cval]);
	                } else if (cval === 65) { /* 1001 */
	                    bottomleft = 1 - interpolateX(minV, br, bl);
	                    topleft = 1 - interpolateX(minV, tr, tl);
	                    edges.push(isoBandEdgeBL[cval]);
	                } else if (cval === 105) { /* 1221 */
	                    bottomleft = interpolateX(maxV, bl, br);
	                    topleft = interpolateX(maxV, tl, tr);
	                    edges.push(isoBandEdgeBL[cval]);
	                } else if (cval === 160) { /* 2200 */
	                    righttop = interpolateX(maxV, br, tr);
	                    rightbottom = interpolateX(minV, br, tr);
	                    leftbottom = interpolateX(minV, bl, tl);
	                    lefttop = interpolateX(maxV, bl, tl);
	                    edges.push(isoBandEdgeRT[cval]);
	                    edges.push(isoBandEdgeRB[cval]);
	                } else if (cval === 10) { /* 0022 */
	                    righttop = 1 - interpolateX(minV, tr, br);
	                    rightbottom = 1 - interpolateX(maxV, tr, br);
	                    leftbottom = 1 - interpolateX(maxV, tl, bl);
	                    lefttop = 1 - interpolateX(minV, tl, bl);
	                    edges.push(isoBandEdgeRT[cval]);
	                    edges.push(isoBandEdgeRB[cval]);
	                } else if (cval === 130) { /* 2002 */
	                    bottomright = 1 - interpolateX(minV, br, bl);
	                    bottomleft = 1 - interpolateX(maxV, br, bl);
	                    topleft = 1 - interpolateX(maxV, tr, tl);
	                    topright = 1 - interpolateX(minV, tr, tl);
	                    edges.push(isoBandEdgeBR[cval]);
	                    edges.push(isoBandEdgeBL[cval]);
	                } else if (cval === 40) { /* 0220 */
	                    bottomright = interpolateX(maxV, bl, br);
	                    bottomleft = interpolateX(minV, bl, br);
	                    topleft = interpolateX(minV, tl, tr);
	                    topright = interpolateX(maxV, tl, tr);
	                    edges.push(isoBandEdgeBR[cval]);
	                    edges.push(isoBandEdgeBL[cval]);
	                }

	                /* 4th single pentagon cases */
	                else if (cval === 101) { /* 1211 */
	                    rightbottom = interpolateX(maxV, br, tr);
	                    topleft = interpolateX(maxV, tl, tr);
	                    edges.push(isoBandEdgeRB[cval]);
	                } else if (cval === 69) { /* 1011 */
	                    rightbottom = 1 - interpolateX(minV, tr, br);
	                    topleft = 1 - interpolateX(minV, tr, tl);
	                    edges.push(isoBandEdgeRB[cval]);
	                } else if (cval === 149) { /* 2111 */
	                    leftbottom = interpolateX(maxV, bl, tl);
	                    topright = 1 - interpolateX(maxV, tr, tl);
	                    edges.push(isoBandEdgeLB[cval]);
	                } else if (cval === 21) { /* 0111 */
	                    leftbottom = 1 - interpolateX(minV, tl, bl);
	                    topright = interpolateX(minV, tl, tr);
	                    edges.push(isoBandEdgeLB[cval]);
	                } else if (cval === 86) { /* 1112 */
	                    bottomright = 1 - interpolateX(maxV, br, bl);
	                    lefttop = 1 - interpolateX(maxV, tl, bl);
	                    edges.push(isoBandEdgeBR[cval]);
	                } else if (cval === 84) { /* 1110 */
	                    bottomright = interpolateX(minV, bl, br);
	                    lefttop = interpolateX(minV, bl, tl);
	                    edges.push(isoBandEdgeBR[cval]);
	                } else if (cval === 89) { /* 1121 */
	                    righttop = 1 - interpolateX(maxV, tr, br);
	                    bottomleft = interpolateX(maxV, bl, br);
	                    edges.push(isoBandEdgeBL[cval]);
	                } else if (cval === 81) { /* 1101 */
	                    righttop = interpolateX(minV, br, tr);
	                    bottomleft = 1 - interpolateX(minV, br, bl);
	                    edges.push(isoBandEdgeBL[cval]);
	                } else if (cval === 96) { /* 1200 */
	                    righttop = interpolateX(maxV, br, tr);
	                    rightbottom = interpolateX(minV, br, tr);
	                    lefttop = interpolateX(minV, bl, tl);
	                    topleft = interpolateX(maxV, tl, tr);
	                    edges.push(isoBandEdgeRT[cval]);
	                    edges.push(isoBandEdgeRB[cval]);
	                } else if (cval === 74) { /* 1022 */
	                    righttop = 1 - interpolateX(minV, tr, br);
	                    rightbottom = 1 - interpolateX(maxV, tr, br);
	                    lefttop = 1 - interpolateX(maxV, tl, bl);
	                    topleft = 1 - interpolateX(minV, tr, tl);
	                    edges.push(isoBandEdgeRT[cval]);
	                    edges.push(isoBandEdgeRB[cval]);
	                } else if (cval === 24) { /* 0120 */
	                    righttop = 1 - interpolateX(maxV, tr, br);
	                    bottomright = interpolateX(maxV, bl, br);
	                    bottomleft = interpolateX(minV, bl, br);
	                    topright = interpolateX(minV, tl, tr);
	                    edges.push(isoBandEdgeRT[cval]);
	                    edges.push(isoBandEdgeBL[cval]);
	                } else if (cval === 146) { /* 2102 */
	                    righttop = interpolateX(minV, br, tr);
	                    bottomright = 1 - interpolateX(minV, br, bl);
	                    bottomleft = 1 - interpolateX(maxV, br, bl);
	                    topright = 1 - interpolateX(maxV, tr, tl);
	                    edges.push(isoBandEdgeRT[cval]);
	                    edges.push(isoBandEdgeBL[cval]);
	                } else if (cval === 6) { /* 0012 */
	                    rightbottom = 1 - interpolateX(minV, tr, br);
	                    bottomright = 1 - interpolateX(maxV, br, bl);
	                    leftbottom = 1 - interpolateX(maxV, tl, bl);
	                    lefttop = 1 - interpolateX(minV, tl, bl);
	                    edges.push(isoBandEdgeRB[cval]);
	                    edges.push(isoBandEdgeBR[cval]);
	                } else if (cval === 164) { /* 2210 */
	                    rightbottom = interpolateX(maxV, br, tr);
	                    bottomright = interpolateX(minV, bl, br);
	                    leftbottom = interpolateX(minV, bl, tl);
	                    lefttop = interpolateX(maxV, bl, tl);
	                    edges.push(isoBandEdgeRB[cval]);
	                    edges.push(isoBandEdgeBR[cval]);
	                } else if (cval === 129) { /* 2001 */
	                    bottomleft = 1 - interpolateX(minV, br, bl);
	                    leftbottom = interpolateX(maxV, bl, tl);
	                    topleft = 1 - interpolateX(maxV, tr, tl);
	                    topright = 1 - interpolateX(minV, tr, tl);
	                    edges.push(isoBandEdgeBL[cval]);
	                    edges.push(isoBandEdgeLB[cval]);
	                } else if (cval === 41) { /* 0221 */
	                    bottomleft = interpolateX(maxV, bl, br);
	                    leftbottom = 1 - interpolateX(minV, tl, bl);
	                    topleft = interpolateX(minV, tl, tr);
	                    topright = interpolateX(maxV, tl, tr);
	                    edges.push(isoBandEdgeBL[cval]);
	                    edges.push(isoBandEdgeLB[cval]);
	                } else if (cval === 66) { /* 1002 */
	                    bottomright = 1 - interpolateX(minV, br, bl);
	                    bottomleft = 1 - interpolateX(maxV, br, bl);
	                    lefttop = 1 - interpolateX(maxV, tl, bl);
	                    topleft = 1 - interpolateX(minV, tr, tl);
	                    edges.push(isoBandEdgeBR[cval]);
	                    edges.push(isoBandEdgeBL[cval]);
	                } else if (cval === 104) { /* 1220 */
	                    bottomright = interpolateX(maxV, bl, br);
	                    bottomleft = interpolateX(minV, bl, br);
	                    lefttop = interpolateX(minV, bl, tl);
	                    topleft = interpolateX(maxV, tl, tr);
	                    edges.push(isoBandEdgeBL[cval]);
	                    edges.push(isoBandEdgeTL[cval]);
	                } else if (cval === 144) { /* 2100 */
	                    righttop = interpolateX(minV, br, tr);
	                    leftbottom = interpolateX(minV, bl, tl);
	                    lefttop = interpolateX(maxV, bl, tl);
	                    topright = 1 - interpolateX(maxV, tr, tl);
	                    edges.push(isoBandEdgeRT[cval]);
	                    edges.push(isoBandEdgeLT[cval]);
	                } else if (cval === 26) { /* 0122 */
	                    righttop = 1 - interpolateX(maxV, tr, br);
	                    leftbottom = 1 - interpolateX(maxV, tl, bl);
	                    lefttop = 1 - interpolateX(minV, tl, bl);
	                    topright = interpolateX(minV, tl, tr);
	                    edges.push(isoBandEdgeRT[cval]);
	                    edges.push(isoBandEdgeLT[cval]);
	                } else if (cval === 36) { /* 0210 */
	                    rightbottom = interpolateX(maxV, br, tr);
	                    bottomright = interpolateX(minV, bl, br);
	                    topleft = interpolateX(minV, tl, tr);
	                    topright = interpolateX(maxV, tl, tr);
	                    edges.push(isoBandEdgeRB[cval]);
	                    edges.push(isoBandEdgeBR[cval]);
	                } else if (cval === 134) { /* 2012 */
	                    rightbottom = 1 - interpolateX(minV, tr, br);
	                    bottomright = 1 - interpolateX(maxV, br, bl);
	                    topleft = 1 - interpolateX(maxV, tr, tl);
	                    topright = 1 - interpolateX(minV, tr, tl);
	                    edges.push(isoBandEdgeRB[cval]);
	                    edges.push(isoBandEdgeBR[cval]);
	                } else if (cval === 9) { /* 0021 */
	                    righttop = 1 - interpolateX(minV, tr, br);
	                    rightbottom = 1 - interpolateX(maxV, tr, br);
	                    bottomleft = interpolateX(maxV, bl, br);
	                    leftbottom = 1 - interpolateX(minV, tl, bl);
	                    edges.push(isoBandEdgeRT[cval]);
	                    edges.push(isoBandEdgeRB[cval]);
	                } else if (cval === 161) { /* 2201 */
	                    righttop = interpolateX(maxV, br, tr);
	                    rightbottom = interpolateX(minV, br, tr);
	                    bottomleft = 1 - interpolateX(minV, br, bl);
	                    leftbottom = interpolateX(maxV, bl, tl);
	                    edges.push(isoBandEdgeRT[cval]);
	                    edges.push(isoBandEdgeRB[cval]);
	                }

	                /* 5th single hexagon cases */
	                else if (cval === 37) { /* 0211 */
	                    rightbottom = interpolateX(maxV, br, tr);
	                    leftbottom = 1 - interpolateX(minV, tl, bl);
	                    topleft = interpolateX(minV, tl, tr);
	                    topright = interpolateX(maxV, tl, tr);
	                    edges.push(isoBandEdgeRB[cval]);
	                    edges.push(isoBandEdgeLB[cval]);
	                } else if (cval === 133) { /* 2011 */
	                    rightbottom = 1 - interpolateX(minV, tr, br);
	                    leftbottom = interpolateX(maxV, bl, tl);
	                    topleft = 1 - interpolateX(maxV, tr, tl);
	                    topright = 1 - interpolateX(minV, tr, tl);
	                    edges.push(isoBandEdgeRB[cval]);
	                    edges.push(isoBandEdgeLB[cval]);
	                } else if (cval === 148) { /* 2110 */
	                    bottomright = interpolateX(minV, bl, br);
	                    leftbottom = interpolateX(minV, bl, tl);
	                    lefttop = interpolateX(maxV, bl, tl);
	                    topright = 1 - interpolateX(maxV, tr, tl);
	                    edges.push(isoBandEdgeBR[cval]);
	                    edges.push(isoBandEdgeLT[cval]);
	                } else if (cval === 22) { /* 0112 */
	                    bottomright = 1 - interpolateX(maxV, br, bl);
	                    leftbottom = 1 - interpolateX(maxV, tl, bl);
	                    lefttop = 1 - interpolateX(minV, tl, bl);
	                    topright = interpolateX(minV, tl, tr);
	                    edges.push(isoBandEdgeBR[cval]);
	                    edges.push(isoBandEdgeLT[cval]);
	                } else if (cval === 82) { /* 1102 */
	                    righttop = interpolateX(minV, br, tr);
	                    bottomright = 1 - interpolateX(minV, br, bl);
	                    bottomleft = 1 - interpolateX(maxV, br, bl);
	                    lefttop = 1 - interpolateX(maxV, tl, bl);
	                    edges.push(isoBandEdgeRT[cval]);
	                    edges.push(isoBandEdgeBL[cval]);
	                } else if (cval === 88) { /* 1120 */
	                    righttop = 1 - interpolateX(maxV, tr, br);
	                    bottomright = interpolateX(maxV, bl, br);
	                    bottomleft = interpolateX(minV, bl, br);
	                    lefttop = interpolateX(minV, bl, tl);
	                    edges.push(isoBandEdgeRT[cval]);
	                    edges.push(isoBandEdgeBL[cval]);
	                } else if (cval === 73) { /* 1021 */
	                    righttop = 1 - interpolateX(minV, tr, br);
	                    rightbottom = 1 - interpolateX(maxV, tr, br);
	                    bottomleft = interpolateX(maxV, bl, br);
	                    topleft = 1 - interpolateX(minV, tr, tl);
	                    edges.push(isoBandEdgeRT[cval]);
	                    edges.push(isoBandEdgeRB[cval]);
	                } else if (cval === 97) { /* 1201 */
	                    righttop = interpolateX(maxV, br, tr);
	                    rightbottom = interpolateX(minV, br, tr);
	                    bottomleft = 1 - interpolateX(minV, br, bl);
	                    topleft = interpolateX(maxV, tl, tr);
	                    edges.push(isoBandEdgeRT[cval]);
	                    edges.push(isoBandEdgeRB[cval]);
	                } else if (cval === 145) { /* 2101 */
	                    righttop = interpolateX(minV, br, tr);
	                    bottomleft = 1 - interpolateX(minV, br, bl);
	                    leftbottom = interpolateX(maxV, bl, tl);
	                    topright = 1 - interpolateX(maxV, tr, tl);
	                    edges.push(isoBandEdgeRT[cval]);
	                    edges.push(isoBandEdgeLB[cval]);
	                } else if (cval === 25) { /* 0121 */
	                    righttop = 1 - interpolateX(maxV, tr, br);
	                    bottomleft = interpolateX(maxV, bl, br);
	                    leftbottom = 1 - interpolateX(minV, tl, bl);
	                    topright = interpolateX(minV, tl, tr);
	                    edges.push(isoBandEdgeRT[cval]);
	                    edges.push(isoBandEdgeLB[cval]);
	                } else if (cval === 70) { /* 1012 */
	                    rightbottom = 1 - interpolateX(minV, tr, br);
	                    bottomright = 1 - interpolateX(maxV, br, bl);
	                    lefttop = 1 - interpolateX(maxV, tl, bl);
	                    topleft = 1 - interpolateX(minV, tr, tl);
	                    edges.push(isoBandEdgeRB[cval]);
	                    edges.push(isoBandEdgeBR[cval]);
	                } else if (cval === 100) { /* 1210 */
	                    rightbottom = interpolateX(maxV, br, tr);
	                    bottomright = interpolateX(minV, bl, br);
	                    lefttop = interpolateX(minV, bl, tl);
	                    topleft = interpolateX(maxV, tl, tr);
	                    edges.push(isoBandEdgeRB[cval]);
	                    edges.push(isoBandEdgeBR[cval]);
	                }

	                /* 8-sided cases */
	                else if (cval === 34) { /* 0202 || 2020 with flipped == 0 */
	                    if (flipped === 0) {
	                        righttop = 1 - interpolateX(minV, tr, br);
	                        rightbottom = 1 - interpolateX(maxV, tr, br);
	                        bottomright = interpolateX(maxV, bl, br);
	                        bottomleft = interpolateX(minV, bl, br);
	                        leftbottom = interpolateX(minV, bl, tl);
	                        lefttop = interpolateX(maxV, bl, tl);
	                        topleft = 1 - interpolateX(maxV, tr, tl);
	                        topright = 1 - interpolateX(minV, tr, tl);
	                    } else {
	                        righttop = interpolateX(maxV, br, tr);
	                        rightbottom = interpolateX(minV, br, tr);
	                        bottomright = 1 - interpolateX(minV, br, bl);
	                        bottomleft = 1 - interpolateX(maxV, br, bl);
	                        leftbottom = 1 - interpolateX(maxV, tl, bl);
	                        lefttop = 1 - interpolateX(minV, tl, bl);
	                        topleft = interpolateX(minV, tl, tr);
	                        topright = interpolateX(maxV, tl, tr);
	                    }
	                    edges.push(isoBandEdgeRT[cval]);
	                    edges.push(isoBandEdgeRB[cval]);
	                    edges.push(isoBandEdgeLB[cval]);
	                    edges.push(isoBandEdgeLT[cval]);
	                } else if (cval === 35) { /* flipped == 1 state for 0202, and 2020 with flipped == 4*/
	                    if (flipped === 4) {
	                        righttop = 1 - interpolateX(minV, tr, br);
	                        rightbottom = 1 - interpolateX(maxV, tr, br);
	                        bottomright = interpolateX(maxV, bl, br);
	                        bottomleft = interpolateX(minV, bl, br);
	                        leftbottom = interpolateX(minV, bl, tl);
	                        lefttop = interpolateX(maxV, bl, tl);
	                        topleft = 1 - interpolateX(maxV, tr, tl);
	                        topright = 1 - interpolateX(minV, tr, tl);
	                    } else {
	                        righttop = interpolateX(maxV, br, tr);
	                        rightbottom = interpolateX(minV, br, tr);
	                        bottomright = 1 - interpolateX(minV, br, bl);
	                        bottomleft = 1 - interpolateX(maxV, br, bl);
	                        leftbottom = 1 - interpolateX(maxV, tl, bl);
	                        lefttop = 1 - interpolateX(minV, tl, bl);
	                        topleft = interpolateX(minV, tl, tr);
	                        topright = interpolateX(maxV, tl, tr);
	                    }
	                    edges.push(isoBandEdgeRT[cval]);
	                    edges.push(isoBandEdgeRB[cval]);
	                    edges.push(isoBandEdgeBL[cval]);
	                    edges.push(isoBandEdgeLT[cval]);
	                } else if (cval === 136) { /* 2020 || 0202 with flipped == 0 */
	                    if (flipped === 0) {
	                        righttop = interpolateX(maxV, br, tr);
	                        rightbottom = interpolateX(minV, br, tr);
	                        bottomright = 1 - interpolateX(minV, br, bl);
	                        bottomleft = 1 - interpolateX(maxV, br, bl);
	                        leftbottom = 1 - interpolateX(maxV, tl, bl);
	                        lefttop = 1 - interpolateX(minV, tl, bl);
	                        topleft = interpolateX(minV, tl, tr);
	                        topright = interpolateX(maxV, tl, tr);
	                    } else {
	                        righttop = 1 - interpolateX(minV, tr, br);
	                        rightbottom = 1 - interpolateX(maxV, tr, br);
	                        bottomright = interpolateX(maxV, bl, br);
	                        bottomleft = interpolateX(minV, bl, br);
	                        leftbottom = interpolateX(minV, bl, tl);
	                        lefttop = interpolateX(maxV, bl, tl);
	                        topleft = 1 - interpolateX(maxV, tr, tl);
	                        topright = 1 - interpolateX(minV, tr, tl);
	                    }
	                    edges.push(isoBandEdgeRT[cval]);
	                    edges.push(isoBandEdgeRB[cval]);
	                    edges.push(isoBandEdgeLB[cval]);
	                    edges.push(isoBandEdgeLT[cval]);
	                }

	                /* 6-sided polygon cases */
	                else if (cval === 153) { /* 0101 with flipped == 0 || 2121 with flipped == 2 */
	                    if (flipped === 0) {
	                        righttop = interpolateX(minV, br, tr);
	                        bottomleft = 1 - interpolateX(minV, br, bl);
	                        leftbottom = 1 - interpolateX(minV, tl, bl);
	                        topright = interpolateX(minV, tl, tr);
	                    } else {
	                        righttop = 1 - interpolateX(maxV, tr, br);
	                        bottomleft = interpolateX(maxV, bl, br);
	                        leftbottom = interpolateX(maxV, bl, tl);
	                        topright = 1 - interpolateX(maxV, tr, tl);
	                    }
	                    edges.push(isoBandEdgeRT[cval]);
	                    edges.push(isoBandEdgeBL[cval]);
	                } else if (cval === 102) { /* 1010 with flipped == 0 || 1212 with flipped == 2 */
	                    if (flipped === 0) {
	                        rightbottom = 1 - interpolateX(minV, tr, br);
	                        bottomright = interpolateX(minV, bl, br);
	                        lefttop = interpolateX(minV, bl, tl);
	                        topleft = 1 - interpolateX(minV, tr, tl);
	                    } else {
	                        rightbottom = interpolateX(maxV, br, tr);
	                        bottomright = 1 - interpolateX(maxV, br, bl);
	                        lefttop = 1 - interpolateX(maxV, tl, bl);
	                        topleft = interpolateX(maxV, tl, tr);
	                    }
	                    edges.push(isoBandEdgeRB[cval]);
	                    edges.push(isoBandEdgeLT[cval]);
	                } else if (cval === 155) { /* 0101 with flipped == 4 || 2121 with flipped == 1 */
	                    if (flipped === 4) {
	                        righttop = interpolateX(minV, br, tr);
	                        bottomleft = 1 - interpolateX(minV, br, bl);
	                        leftbottom = 1 - interpolateX(minV, tl, bl);
	                        topright = interpolateX(minV, tl, tr);
	                    } else {
	                        righttop = 1 - interpolateX(maxV, tr, br);
	                        bottomleft = interpolateX(maxV, bl, br);
	                        leftbottom = interpolateX(maxV, bl, tl);
	                        topright = 1 - interpolateX(maxV, tr, tl);
	                    }
	                    edges.push(isoBandEdgeRT[cval]);
	                    edges.push(isoBandEdgeLB[cval]);
	                } else if (cval === 103) { /* 1010 with flipped == 4 || 1212 with flipped == 1 */
	                    if (flipped === 4) {
	                        rightbottom = 1 - interpolateX(minV, tr, br);
	                        bottomright = interpolateX(minV, bl, br);
	                        lefttop = interpolateX(minV, bl, tl);
	                        topleft = 1 - interpolateX(minV, tr, tl);
	                    } else {
	                        rightbottom = interpolateX(maxV, br, tr);
	                        bottomright = 1 - interpolateX(maxV, br, bl);
	                        lefttop = 1 - interpolateX(maxV, tl, bl);
	                        topleft = interpolateX(maxV, tl, tr);
	                    }
	                    edges.push(isoBandEdgeRB[cval]);
	                    edges.push(isoBandEdgeBR[cval]);
	                }

	                /* 7-sided polygon cases */
	                else if (cval === 152) { /* 2120 with flipped == 2 || 0102 with flipped == 0 */
	                    if (flipped === 0) {
	                        righttop = interpolateX(minV, br, tr);
	                        bottomright = 1 - interpolateX(minV, br, bl);
	                        bottomleft = 1 - interpolateX(maxV, br, bl);
	                        leftbottom = 1 - interpolateX(maxV, tl, bl);
	                        lefttop = 1 - interpolateX(minV, tl, bl);
	                        topright = interpolateX(minV, tl, tr);
	                    } else {
	                        righttop = 1 - interpolateX(maxV, tr, br);
	                        bottomright = interpolateX(maxV, bl, br);
	                        bottomleft = interpolateX(minV, bl, br);
	                        leftbottom = interpolateX(minV, bl, tl);
	                        lefttop = interpolateX(maxV, bl, tl);
	                        topright = 1 - interpolateX(maxV, tr, tl);
	                    }
	                    edges.push(isoBandEdgeRT[cval]);
	                    edges.push(isoBandEdgeBR[cval]);
	                    edges.push(isoBandEdgeBL[cval]);
	                } else if (cval === 156) { /* 2120 with flipped == 1 || 0102 with flipped == 4 */
	                    if (flipped === 4) {
	                        righttop = interpolateX(minV, br, tr);
	                        bottomright = 1 - interpolateX(minV, br, bl);
	                        bottomleft = 1 - interpolateX(maxV, br, bl);
	                        leftbottom = 1 - interpolateX(maxV, tl, bl);
	                        lefttop = 1 - interpolateX(minV, tl, bl);
	                        topright = interpolateX(minV, tl, tr);
	                    } else {
	                        righttop = 1 - interpolateX(maxV, tr, br);
	                        bottomright = interpolateX(maxV, bl, br);
	                        bottomleft = interpolateX(minV, bl, br);
	                        leftbottom = interpolateX(minV, bl, tl);
	                        lefttop = interpolateX(maxV, bl, tl);
	                        topright = 1 - interpolateX(maxV, tr, tl);
	                    }
	                    edges.push(isoBandEdgeRT[cval]);
	                    edges.push(isoBandEdgeBL[cval]);
	                    edges.push(isoBandEdgeLT[cval]);
	                } else if (cval === 137) { /* 2021 with flipped == 2 || 0201 with flipped == 0 */
	                    if (flipped === 0) {
	                        righttop = interpolateX(maxV, br, tr);
	                        rightbottom = interpolateX(minV, br, tr);
	                        bottomleft = 1 - interpolateX(minV, br, bl);
	                        leftbottom = 1 - interpolateX(minV, tl, bl);
	                        topleft = interpolateX(minV, tl, tr);
	                        topright = interpolateX(maxV, tl, tr);
	                    } else {
	                        righttop = 1 - interpolateX(minV, tr, br);
	                        rightbottom = 1 - interpolateX(maxV, tr, br);
	                        bottomleft = interpolateX(maxV, bl, br);
	                        leftbottom = interpolateX(maxV, bl, tl);
	                        topleft = 1 - interpolateX(maxV, tr, tl);
	                        topright = 1 - interpolateX(minV, tr, tl);
	                    }
	                    edges.push(isoBandEdgeRT[cval]);
	                    edges.push(isoBandEdgeRB[cval]);
	                    edges.push(isoBandEdgeBL[cval]);
	                } else if (cval === 139) { /* 2021 with flipped == 1 || 0201 with flipped == 4 */
	                    if (flipped === 4) {
	                        righttop = interpolateX(maxV, br, tr);
	                        rightbottom = interpolateX(minV, br, tr);
	                        bottomleft = 1 - interpolateX(minV, br, bl);
	                        leftbottom = 1 - interpolateX(minV, tl, bl);
	                        topleft = interpolateX(minV, tl, tr);
	                        topright = interpolateX(maxV, tl, tr);
	                    } else {
	                        righttop = 1 - interpolateX(minV, tr, br);
	                        rightbottom = 1 - interpolateX(maxV, tr, br);
	                        bottomleft = interpolateX(maxV, bl, br);
	                        leftbottom = interpolateX(maxV, bl, tl);
	                        topleft = 1 - interpolateX(maxV, tr, tl);
	                        topright = 1 - interpolateX(minV, tr, tl);
	                    }
	                    edges.push(isoBandEdgeRT[cval]);
	                    edges.push(isoBandEdgeRB[cval]);
	                    edges.push(isoBandEdgeLB[cval]);
	                } else if (cval === 98) { /* 1202 with flipped == 2 || 1020 with flipped == 0 */
	                    if (flipped === 0) {
	                        righttop = 1 - interpolateX(minV, tr, br);
	                        rightbottom = 1 - interpolateX(maxV, tr, br);
	                        bottomright = interpolateX(maxV, bl, br);
	                        bottomleft = interpolateX(minV, bl, br);
	                        lefttop = interpolateX(minV, bl, tl);
	                        topleft = 1 - interpolateX(minV, tr, tl);
	                    } else {
	                        righttop = interpolateX(maxV, br, tr);
	                        rightbottom = interpolateX(minV, br, tr);
	                        bottomright = 1 - interpolateX(minV, br, bl);
	                        bottomleft = 1 - interpolateX(maxV, br, bl);
	                        lefttop = 1 - interpolateX(maxV, tl, bl);
	                        topleft = interpolateX(maxV, tl, tr);
	                    }
	                    edges.push(isoBandEdgeRT[cval]);
	                    edges.push(isoBandEdgeRB[cval]);
	                    edges.push(isoBandEdgeLT[cval]);
	                } else if (cval === 99) { /* 1202 with flipped == 1 || 1020 with flipped == 4 */
	                    if (flipped === 4) {
	                        righttop = 1 - interpolateX(minV, tr, br);
	                        rightbottom = 1 - interpolateX(maxV, tr, br);
	                        bottomright = interpolateX(maxV, bl, br);
	                        bottomleft = interpolateX(minV, bl, br);
	                        lefttop = interpolateX(minV, bl, tl);
	                        topleft = 1 - interpolateX(minV, tr, tl);
	                    } else {
	                        righttop = interpolateX(maxV, br, tr);
	                        rightbottom = interpolateX(minV, br, tr);
	                        bottomright = 1 - interpolateX(minV, br, bl);
	                        bottomleft = 1 - interpolateX(maxV, br, bl);
	                        lefttop = 1 - interpolateX(maxV, tl, bl);
	                        topleft = interpolateX(maxV, tl, tr);
	                    }
	                    edges.push(isoBandEdgeRT[cval]);
	                    edges.push(isoBandEdgeRB[cval]);
	                    edges.push(isoBandEdgeBL[cval]);
	                } else if (cval === 38) { /* 0212 with flipped == 2 || 2010 with flipped == 0 */
	                    if (flipped === 0) {
	                        rightbottom = 1 - interpolateX(minV, tr, br);
	                        bottomright = interpolateX(minV, bl, br);
	                        leftbottom = interpolateX(minV, bl, tl);
	                        lefttop = interpolateX(maxV, bl, tl);
	                        topleft = 1 - interpolateX(maxV, tr, tl);
	                        topright = 1 - interpolateX(minV, tr, tl);
	                    } else {
	                        rightbottom = interpolateX(maxV, br, tr);
	                        bottomright = 1 - interpolateX(maxV, br, bl);
	                        leftbottom = 1 - interpolateX(maxV, tl, bl);
	                        lefttop = 1 - interpolateX(minV, tl, bl);
	                        topleft = interpolateX(minV, tl, tr);
	                        topright = interpolateX(maxV, tl, tr);
	                    }
	                    edges.push(isoBandEdgeRB[cval]);
	                    edges.push(isoBandEdgeLB[cval]);
	                    edges.push(isoBandEdgeLT[cval]);
	                } else if (cval === 39) { /* 0212 with flipped == 1 || 2010 with flipped == 4 */
	                    if (flipped === 4) {
	                        rightbottom = 1 - interpolateX(minV, tr, br);
	                        bottomright = interpolateX(minV, bl, br);
	                        leftbottom = interpolateX(minV, bl, tl);
	                        lefttop = interpolateX(maxV, bl, tl);
	                        topleft = 1 - interpolateX(maxV, tr, tl);
	                        topright = 1 - interpolateX(minV, tr, tl);
	                    } else {
	                        rightbottom = interpolateX(maxV, br, tr);
	                        bottomright = 1 - interpolateX(maxV, br, bl);
	                        leftbottom = 1 - interpolateX(maxV, tl, bl);
	                        lefttop = 1 - interpolateX(minV, tl, bl);
	                        topleft = interpolateX(minV, tl, tr);
	                        topright = interpolateX(maxV, tl, tr);
	                    }
	                    edges.push(isoBandEdgeRB[cval]);
	                    edges.push(isoBandEdgeBR[cval]);
	                    edges.push(isoBandEdgeLT[cval]);
	                } else if (cval === 85) {
	                    righttop = 1;
	                    rightbottom = 0;
	                    bottomright = 1;
	                    bottomleft = 0;
	                    leftbottom = 0;
	                    lefttop = 1;
	                    topleft = 0;
	                    topright = 1;
	                }

	                if (topleft < 0 || topleft > 1 || topright < 0 || topright > 1 || righttop < 0 || righttop > 1 || bottomright < 0 || bottomright > 1 || leftbottom < 0 || leftbottom > 1 || lefttop < 0 || lefttop > 1) {
	                    console.log('MarchingSquaresJS-isoBands: ' + cval + ' ' + cval_real + ' ' + tl + ',' + tr + ',' + br + ',' + bl + ' ' + flipped + ' ' + topleft + ' ' + topright + ' ' + righttop + ' ' + rightbottom + ' ' + bottomright + ' ' + bottomleft + ' ' + leftbottom + ' ' + lefttop);
	                }

	                BandGrid.cells[j][i] = {
	                    cval: cval,
	                    cval_real: cval_real,
	                    flipped: flipped,
	                    topleft: topleft,
	                    topright: topright,
	                    righttop: righttop,
	                    rightbottom: rightbottom,
	                    bottomright: bottomright,
	                    bottomleft: bottomleft,
	                    leftbottom: leftbottom,
	                    lefttop: lefttop,
	                    edges: edges
	                };
	            }
	        }
	    }

	    return BandGrid;
	}

	function BandGrid2AreaPaths(grid) {
	    var areas = [];
	    var rows = grid.rows;
	    var cols = grid.cols;
	    var currentPolygon = [];

	    for (var j = 0; j < rows; j++) {
	        for (var i = 0; i < cols; i++) {
	            if ((typeof grid.cells[j][i] !== 'undefined') && (grid.cells[j][i].edges.length > 0)) {
	                /* trace back polygon path starting from this cell */

	                var cell = grid.cells[j][i];

	                /* get start coordinates */

	                var prev  = getStartXY(cell),
	                    next  = null,
	                    p     = i,
	                    q     = j;

	                if (prev !== null) {
	                    currentPolygon.push([prev.p[0] + p, prev.p[1] + q]);
	                    //console.log(cell);
	                    //console.log("coords: " + (prev.p[0] + p) + " " + (prev.p[1] + q));
	                }

	                do {
	                    //console.log(p + "," + q);
	                    //console.log(grid.cells[q][p]);
	                    //console.log(grid.cells[q][p].edges);
	                    //console.log("from : " + prev.x + " " + prev.y + " " + prev.o);

	                    next = getExitXY(grid.cells[q][p], prev.x, prev.y, prev.o);
	                    if (next !== null) {
	                        //console.log("coords: " + (next.p[0] + p) + " " + (next.p[1] + q));
	                        currentPolygon.push([next.p[0] + p, next.p[1] + q]);
	                        p += next.x;
	                        q += next.y;
	                        prev = next;
	                    } else {
	                        //console.log("getExitXY() returned null!");
	                        break;
	                    }
	                    //console.log("to : " + next.x + " " + next.y + " " + next.o);
	                    /* special case, where we've reached the grid boundaries */
	                    if ((q < 0) || (q >= rows) || (p < 0) || (p >= cols) || (typeof grid.cells[q][p] === 'undefined')) {
	                        /* to create a closed path, we need to trace our way
	                arround the missing data, until we find an entry
	                point again
	            */

	                        /* set back coordinates of current cell */
	                        p -= next.x;
	                        q -= next.y;

	                        //console.log("reached boundary at " + p + " " + q);

	                        var missing = traceOutOfGridPath(grid, p, q, next.x, next.y, next.o);
	                        if (missing !== null) {
	                            missing.path.forEach(function (pp) {
	                                //console.log("coords: " + (pp[0]) + " " + (pp[1]));
	                                currentPolygon.push(pp);
	                            });
	                            p = missing.i;
	                            q = missing.j;
	                            prev = missing;
	                        } else {
	                            break;
	                        }
	                        //console.log(grid.cells[q][p]);
	                    }
	                } while ((typeof grid.cells[q][p] !== 'undefined') &&
	                  (grid.cells[q][p].edges.length > 0));

	                areas.push(currentPolygon);
	                //console.log("next polygon");
	                //console.log(currentPolygon);
	                currentPolygon = [];
	                if (grid.cells[j][i].edges.length > 0)
	                    i--;
	            }
	        }
	    }
	    return areas;
	}

	function traceOutOfGridPath(grid, i, j, d_x, d_y, d_o) {
	    var cell = grid.cells[j][i];
	    var cval = cell.cval_real;
	    var p = i + d_x,
	        q = j + d_y;
	    var path = [];
	    var closed = false;

	    while (!closed) {
	    //console.log("processing cell " + p + "," + q + " " + d_x + " " + d_y + " " + d_o);
	        if ((typeof grid.cells[q] === 'undefined') || (typeof grid.cells[q][p] === 'undefined')) {
	            //console.log("which is undefined");
	            /* we can't move on, so we have to change direction to proceed further */

	            /* go back to previous cell */
	            q -= d_y;
	            p -= d_x;
	            cell = grid.cells[q][p];
	            cval = cell.cval_real;

	            /* check where we've left defined cells of the grid... */
	            if (d_y === -1) { /* we came from top */
	                if (d_o === 0) {  /* exit left */
	                    if (cval & Node3) { /* lower left node is within range, so we move left */
	                        path.push([p, q]);
	                        d_x = -1;
	                        d_y = 0;
	                        d_o = 0;
	                    } else if (cval & Node2) { /* lower right node is within range, so we move right */
	                        path.push([p + 1, q]);
	                        d_x = 1;
	                        d_y = 0;
	                        d_o = 0;
	                    } else { /* close the path */
	                        path.push([p + cell.bottomright, q]);
	                        d_x = 0;
	                        d_y = 1;
	                        d_o = 1;
	                        closed = true;
	                        break;
	                    }
	                } else if (cval & Node3) {
	                    path.push([p, q]);
	                    d_x = -1;
	                    d_y = 0;
	                    d_o = 0;
	                } else if (cval & Node2) {
	                    path.push([p + cell.bottomright, q]);
	                    d_x = 0;
	                    d_y = 1;
	                    d_o = 1;
	                    closed = true;
	                    break;
	                } else {
	                    path.push([p + cell.bottomleft, q]);
	                    d_x = 0;
	                    d_y = 1;
	                    d_o = 0;
	                    closed = true;
	                    break;
	                }
	            } else if (d_y === 1) { /* we came from bottom */
	                //console.log("we came from bottom and hit a non-existing cell " + (p + d_x) + "," + (q + d_y) + "!");
	                if (d_o === 0) { /* exit left */
	                    if (cval & Node1) { /* top right node is within range, so we move right */
	                        path.push([p + 1, q + 1]);
	                        d_x = 1;
	                        d_y = 0;
	                        d_o = 1;
	                    } else if (!(cval & Node0)) { /* found entry within same cell */
	                        path.push([p + cell.topright, q + 1]);
	                        d_x = 0;
	                        d_y = -1;
	                        d_o = 1;
	                        closed = true;
	                        //console.log("found entry from bottom at " + p + "," + q);
	                        break;
	                    } else {
	                        path.push([p + cell.topleft, q + 1]);
	                        d_x = 0;
	                        d_y = -1;
	                        d_o = 0;
	                        closed = true;
	                        break;
	                    }
	                } else if (cval & Node1) {
	                    path.push([p + 1, q + 1]);
	                    d_x = 1;
	                    d_y = 0;
	                    d_o = 1;
	                } else { /* move right */
	                    path.push([p + 1, q + 1]);
	                    d_x = 1;
	                    d_y = 0;
	                    d_o = 1;
	                    //console.log("wtf");
	                    //break;
	                }
	            } else if (d_x === -1) { /* we came from right */
	                //console.log("we came from right and hit a non-existing cell at " + (p + d_x) + "," + (q + d_y) + "!");
	                if (d_o === 0) {
	                    //console.log("continue at bottom");
	                    if (cval & Node0) {
	                        path.push([p, q + 1]);
	                        d_x = 0;
	                        d_y = 1;
	                        d_o = 0;
	                        //console.log("moving upwards to " + (p + d_x) + "," + (q + d_y) + "!");
	                    } else if (!(cval & Node3)) { /* there has to be an entry into the regular grid again! */
	                        //console.log("exiting top");
	                        path.push([p, q + cell.lefttop]);
	                        d_x = 1;
	                        d_y = 0;
	                        d_o = 1;
	                        closed = true;
	                        break;
	                    } else {
	                        //console.log("exiting bottom");
	                        path.push([p, q + cell.leftbottom]);
	                        d_x = 1;
	                        d_y = 0;
	                        d_o = 0;
	                        closed = true;
	                        break;
	                    }
	                } else {
	                    //console.log("continue at top");
	                    if (cval & Node0) {
	                        path.push([p, q + 1]);
	                        d_x = 0;
	                        d_y = 1;
	                        d_o = 0;
	                        //console.log("moving upwards to " + (p + d_x) + "," + (q + d_y) + "!");
	                    } else { /* */
	                        console.log('MarchingSquaresJS-isoBands: wtf');
	                        break;
	                    }
	                }
	            } else if (d_x === 1) { /* we came from left */
	                //console.log("we came from left and hit a non-existing cell " + (p + d_x) + "," + (q + d_y) + "!");
	                if (d_o === 0) { /* exit bottom */
	                    if (cval & Node2) {
	                        path.push([p + 1, q]);
	                        d_x = 0;
	                        d_y = -1;
	                        d_o = 1;
	                    } else {
	                        path.push([p + 1, q + cell.rightbottom]);
	                        d_x = -1;
	                        d_y = 0;
	                        d_o = 0;
	                        closed = true;
	                        break;
	                    }
	                } else { /* exit top */
	                    if (cval & Node2) {
	                        path.push([p + 1, q]);
	                        d_x = 0;
	                        d_y = -1;
	                        d_o = 1;
	                    } else if (!(cval & Node1)) {
	                        path.push([p + 1, q + cell.rightbottom]);
	                        d_x = -1;
	                        d_y = 0;
	                        d_o = 0;
	                        closed = true;
	                        break;
	                    } else {
	                        path.push([p + 1, q + cell.righttop]);
	                        d_x = -1;
	                        d_y = 0;
	                        d_o = 1;
	                        break;
	                    }
	                }
	            } else { /* we came from the same cell */
	                console.log('MarchingSquaresJS-isoBands: we came from nowhere!');
	                break;
	            }

	        } else { /* try to find an entry into the regular grid again! */
	            cell = grid.cells[q][p];
	            cval = cell.cval_real;
	            //console.log("which is defined");

	            if (d_x === -1) {
	                if (d_o === 0) {
	                    /* try to go downwards */
	                    if ((typeof grid.cells[q - 1] !== 'undefined') && (typeof grid.cells[q - 1][p] !== 'undefined')) {
	                        d_x = 0;
	                        d_y = -1;
	                        d_o = 1;
	                    } else if (cval & Node3) { /* proceed searching in x-direction */
	                        //console.log("proceeding in x-direction!");
	                        path.push([p, q]);
	                    } else { /* we must have found an entry into the regular grid */
	                        path.push([p + cell.bottomright, q]);
	                        d_x = 0;
	                        d_y = 1;
	                        d_o = 1;
	                        closed = true;
	                        //console.log("found entry from bottom at " + p + "," + q);
	                        break;
	                    }
	                } else if (cval & Node0) { /* proceed searchin in x-direction */
	                    console.log('MarchingSquaresJS-isoBands: proceeding in x-direction!');
	                } else { /* we must have found an entry into the regular grid */
	                    console.log('MarchingSquaresJS-isoBands: found entry from top at ' + p + ',' + q);
	                    break;
	                }
	            } else if (d_x === 1) {
	                if (d_o === 0) {
	                    console.log('MarchingSquaresJS-isoBands: wtf');
	                    break;
	                } else {
	                    /* try to go upwards */
	                    if ((typeof grid.cells[q + 1] !== 'undefined') && (typeof grid.cells[q + 1][p] !== 'undefined')) {
	                        d_x = 0;
	                        d_y = 1;
	                        d_o = 0;
	                    } else if (cval & Node1) {
	                        path.push([p + 1, q + 1]);
	                        d_x = 1;
	                        d_y = 0;
	                        d_o = 1;
	                    } else { /* found an entry point into regular grid! */
	                        path.push([p + cell.topleft, q + 1]);
	                        d_x = 0;
	                        d_y = -1;
	                        d_o = 0;
	                        closed = true;
	                        //console.log("found entry from bottom at " + p + "," + q);
	                        break;
	                    }
	                }
	            } else if (d_y === -1) {
	                if (d_o === 1) {
	                    /* try to go right */
	                    if (typeof grid.cells[q][p + 1] !== 'undefined') {
	                        d_x = 1;
	                        d_y = 0;
	                        d_o = 1;
	                    } else if (cval & Node2) {
	                        path.push([p + 1, q]);
	                        d_x = 0;
	                        d_y = -1;
	                        d_o = 1;
	                    } else { /* found entry into regular grid! */
	                        path.push([p + 1, q + cell.righttop]);
	                        d_x = -1;
	                        d_y = 0;
	                        d_o = 1;
	                        closed = true;
	                        //console.log("found entry from top at " + p + "," + q);
	                        break;
	                    }
	                } else {
	                    console.log('MarchingSquaresJS-isoBands: wtf');
	                    break;
	                }
	            } else if (d_y === 1) {
	                if (d_o === 0) {
	                    //console.log("we came from bottom left and proceed to the left");
	                    /* try to go left */
	                    if (typeof grid.cells[q][p - 1] !== 'undefined') {
	                        d_x = -1;
	                        d_y = 0;
	                        d_o = 0;
	                    } else if (cval & Node0) {
	                        path.push([p, q + 1]);
	                        d_x = 0;
	                        d_y = 1;
	                        d_o = 0;
	                    } else { /* found an entry point into regular grid! */
	                        path.push([p, q + cell.leftbottom]);
	                        d_x = 1;
	                        d_y = 0;
	                        d_o = 0;
	                        closed = true;
	                        //console.log("found entry from bottom at " + p + "," + q);
	                        break;
	                    }
	                } else {
	                    //console.log("we came from bottom right and proceed to the right");
	                    console.log('MarchingSquaresJS-isoBands: wtf');
	                    break;
	                }
	            } else {
	                console.log('MarchingSquaresJS-isoBands: where did we came from???');
	                break;
	            }

	        }

	        p += d_x;
	        q += d_y;
	        //console.log("going on to  " + p + "," + q + " via " + d_x + " " + d_y + " " + d_o);

	        if ((p === i) && (q === j)) { /* bail out, once we've closed a circle path */
	            break;
	        }

	    }

	    //console.log("exit with " + p + "," + q + " " + d_x + " " + d_y + " " + d_o);
	    return { path: path, i: p, j: q, x: d_x, y: d_y, o: d_o };
	}

	function deleteEdge(cell, edgeIdx) {
	    delete cell.edges[edgeIdx];
	    for (var k = edgeIdx + 1; k < cell.edges.length; k++) {
	        cell.edges[k - 1] = cell.edges[k];
	    }
	    cell.edges.pop();
	}

	function getStartXY(cell) {

	    if (cell.edges.length > 0) {
	        var e = cell.edges[cell.edges.length - 1];
	        //console.log("starting with edge " + e);
	        var cval = cell.cval_real;
	        switch (e) {
	        case 0:   if (cval & Node1) { /* node 1 within range */
	            return {p: [1, cell.righttop], x: -1, y: 0, o: 1};
	        } else { /* node 1 below or above threshold */
	            return {p: [cell.topleft, 1], x: 0, y: -1, o: 0};
	        }
	        case 1:   if (cval & Node2) {
	            return {p: [cell.topleft, 1], x: 0, y: -1, o: 0};
	        } else {
	            return {p: [1, cell.rightbottom], x: -1, y: 0, o: 0};
	        }
	        case 2:   if (cval & Node2) {
	            return {p: [cell.bottomright, 0], x: 0, y: 1, o: 1};
	        } else {
	            return {p: [cell.topleft, 1], x: 0, y: -1, o: 0};
	        }
	        case 3:   if (cval & Node3) {
	            return {p: [cell.topleft, 1], x: 0, y: -1, o: 0};
	        } else {
	            return {p: [cell.bottomleft, 0], x: 0, y: 1, o: 0};
	        }
	        case 4:   if (cval & Node1) {
	            return {p: [1, cell.righttop], x: -1, y: 0, o: 1};
	        } else {
	            return {p: [cell.topright, 1], x: 0, y: -1, o: 1};
	        }
	        case 5:   if (cval & Node2) {
	            return {p: [cell.topright, 1], x: 0, y: -1, o: 1};
	        } else {
	            return {p: [1, cell.rightbottom], x: -1, y: 0, o: 0};
	        }
	        case 6:   if (cval & Node2) {
	            return {p: [cell.bottomright, 0], x: 0, y: 1, o: 1};
	        } else {
	            return {p: [cell.topright, 1], x: 0, y: -1, o: 1};
	        }
	        case 7:   if (cval & Node3) {
	            return {p: [cell.topright, 1], x: 0, y: -1, o: 1};
	        } else {
	            return {p: [cell.bottomleft, 0], x: 0, y: 1, o: 0};
	        }
	        case 8:   if (cval & Node2) {
	            return {p: [cell.bottomright, 0], x: 0, y: 1, o: 1};
	        } else {
	            return {p: [1, cell.righttop], x: -1, y: 0, o: 1};
	        }
	        case 9:   if (cval & Node3) {
	            return {p: [1, cell.righttop], x: -1, y: 0, o: 1};
	        } else {
	            return {p: [cell.bottomleft, 0], x: 0, y: 1, o: 0};
	        }
	        case 10:  if (cval & Node3) {
	            return {p: [0, cell.leftbottom], x: 1, y: 0, o: 0};
	        } else {
	            return {p: [1, cell.righttop], x: -1, y: 0, o: 1};
	        }
	        case 11:  if (cval & Node0) {
	            return {p: [1, cell.righttop], x: -1, y: 0, o: 1};
	        } else {
	            return {p: [0, cell.lefttop], x: 1, y: 0, o: 1};
	        }
	        case 12:  if (cval & Node2) {
	            return {p: [cell.bottomright, 0], x: 0, y: 1, o: 1};
	        } else {
	            return {p: [1, cell.rightbottom], x: -1, y: 0, o: 0};
	        }
	        case 13:  if (cval & Node3) {
	            return {p: [1, cell.rightbottom], x: -1, y: 0, o: 0};
	        } else {
	            return {p: [cell.bottomleft, 0], x: 0, y: 1, o: 0};
	        }
	        case 14:  if (cval & Node3) {
	            return {p: [0, cell.leftbottom], x: 1, y: 0, o: 0};
	        } else {
	            return {p: [1, cell.rightbottom], x: -1, y: 0, o: 0};
	        }
	        case 15:  if (cval & Node0) {
	            return {p: [1, cell.rightbottom], x: -1, y: 0, o: 0};
	        } else {
	            return {p: [0, cell.lefttop], x: 1, y: 0, o: 1};
	        }
	        case 16:  if (cval & Node2) {
	            return {p: [cell.bottomright, 0], x: 0, y: 1, o: 1};
	        } else {
	            return {p: [0, cell.leftbottom], x: 1, y: 0, o: 0};
	        }
	        case 17:  if (cval & Node0) {
	            return {p: [cell.bottomright, 0], x: 0, y: 1, o: 1};
	        } else {
	            return {p: [0, cell.lefttop], x: 1, y: 0, o: 1};
	        }
	        case 18:  if (cval & Node3) {
	            return {p: [0, cell.leftbottom], x: 1, y: 0, o: 0};
	        } else {
	            return {p: [cell.bottomleft, 0], x: 0, y: 1, o: 0};
	        }
	        case 19:  if (cval & Node0) {
	            return {p: [cell.bottomleft, 0], x: 0, y: 1, o: 0};
	        } else {
	            return {p: [0, cell.lefttop], x: 1, y: 0, o: 1};
	        }
	        case 20:  if (cval & Node0) {
	            return {p: [cell.topleft, 1], x: 0, y: -1, o: 0};
	        } else {
	            return {p: [0, cell.leftbottom], x: 1, y: 0, o: 0};
	        }
	        case 21:  if (cval & Node1) {
	            return {p: [0, cell.leftbottom], x: 1, y: 0, o: 0};
	        } else {
	            return {p: [cell.topright, 1], x: 0, y: -1, o: 1};
	        }
	        case 22:  if (cval & Node0) {
	            return {p: [cell.topleft, 1], x: 0, y: -1, o: 0};
	        } else {
	            return {p: [0, cell.lefttop], x: 1, y: 0, o: 1};
	        }
	        case 23:  if (cval & Node1) {
	            return {p: [0, cell.lefttop], x: 1, y: 0, o: 1};
	        } else {
	            return {p: [cell.topright, 1], x: 0, y: -1, o: 1};
	        }
	        default:  console.log('MarchingSquaresJS-isoBands: edge index out of range!');
	            console.log(cell);
	            break;
	        }
	    }

	    return null;
	}

	function getExitXY(cell, x, y, o) {

	    var e, id_x, d_x, d_y, cval = cell.cval;
	    var d_o;

	    switch (x) {
	    case -1:  switch (o) {
	    case 0:   e = isoBandEdgeRB[cval];
	        d_x = isoBandNextXRB[cval];
	        d_y = isoBandNextYRB[cval];
	        d_o = isoBandNextORB[cval];
	        break;
	    default:  e = isoBandEdgeRT[cval];
	        d_x = isoBandNextXRT[cval];
	        d_y = isoBandNextYRT[cval];
	        d_o = isoBandNextORT[cval];
	        break;
	        }
	        break;
	    case 1:   switch (o) {
	    case 0:   e = isoBandEdgeLB[cval];
	        d_x = isoBandNextXLB[cval];
	        d_y = isoBandNextYLB[cval];
	        d_o = isoBandNextOLB[cval];
	        break;
	    default:  e = isoBandEdgeLT[cval];
	        d_x = isoBandNextXLT[cval];
	        d_y = isoBandNextYLT[cval];
	        d_o = isoBandNextOLT[cval];
	        break;
	        }
	        break;
	    default:  switch (y) {
	    case -1:  switch (o) {
	    case 0:   e = isoBandEdgeTL[cval];
	        d_x = isoBandNextXTL[cval];
	        d_y = isoBandNextYTL[cval];
	        d_o = isoBandNextOTL[cval];
	        break;
	    default:  e = isoBandEdgeTR[cval];
	        d_x = isoBandNextXTR[cval];
	        d_y = isoBandNextYTR[cval];
	        d_o = isoBandNextOTR[cval];
	        break;
	        }
	        break;
	    case 1:   switch (o) {
	    case 0:   e = isoBandEdgeBL[cval];
	        d_x = isoBandNextXBL[cval];
	        d_y = isoBandNextYBL[cval];
	        d_o = isoBandNextOBL[cval];
	        break;
	    default:  e = isoBandEdgeBR[cval];
	        d_x = isoBandNextXBR[cval];
	        d_y = isoBandNextYBR[cval];
	        d_o = isoBandNextOBR[cval];
	        break;
	        }
	        break;
	        }
	        break;
	    }

	    id_x = cell.edges.indexOf(e);
	    if (typeof cell.edges[id_x] !== 'undefined') {
	        deleteEdge(cell, id_x);
	    } else {
	    //console.log("wrong edges...");
	    //console.log(x + " " + y + " " + o);
	    //console.log(cell);
	        return null;
	    }

	    cval = cell.cval_real;

	    switch (e) {
	    case 0:   if (cval & Node1) { /* node 1 within range */
	        x = cell.topleft;
	        y = 1;
	    } else { /* node 1 below or above threshold */
	        x = 1;
	        y = cell.righttop;
	    }
	        break;
	    case 1:   if (cval & Node2) {
	        x = 1;
	        y = cell.rightbottom;
	    } else {
	        x = cell.topleft;
	        y = 1;
	    }
	        break;
	    case 2:   if (cval & Node2) {
	        x = cell.topleft;
	        y = 1;
	    } else {
	        x = cell.bottomright;
	        y = 0;
	    }
	        break;
	    case 3:   if (cval & Node3) {
	        x = cell.bottomleft;
	        y = 0;
	    } else {
	        x = cell.topleft;
	        y = 1;
	    }
	        break;
	    case 4:   if (cval & Node1) {
	        x = cell.topright;
	        y = 1;
	    } else {
	        x = 1;
	        y = cell.righttop;
	    }
	        break;
	    case 5:   if (cval & Node2) {
	        x = 1;
	        y = cell.rightbottom;
	    } else {
	        x = cell.topright;
	        y = 1;
	    }
	        break;
	    case 6:   if (cval & Node2) {
	        x = cell.topright;
	        y = 1;
	    } else {
	        x = cell.bottomright;
	        y = 0;
	    }
	        break;
	    case 7:   if (cval & Node3) {
	        x = cell.bottomleft;
	        y = 0;
	    } else {
	        x = cell.topright;
	        y = 1;
	    }
	        break;
	    case 8:   if (cval & Node2) {
	        x = 1;
	        y = cell.righttop;
	    } else {
	        x = cell.bottomright;
	        y = 0;
	    }
	        break;
	    case 9:   if (cval & Node3) {
	        x = cell.bottomleft;
	        y = 0;
	    } else {
	        x = 1;
	        y = cell.righttop;
	    }
	        break;
	    case 10:  if (cval & Node3) {
	        x = 1;
	        y = cell.righttop;
	    } else {
	        x = 0;
	        y = cell.leftbottom;
	    }
	        break;
	    case 11:  if (cval & Node0) {
	        x = 0;
	        y = cell.lefttop;
	    } else {
	        x = 1;
	        y = cell.righttop;
	    }
	        break;
	    case 12:  if (cval & Node2) {
	        x = 1;
	        y = cell.rightbottom;
	    } else {
	        x = cell.bottomright;
	        y = 0;
	    }
	        break;
	    case 13:  if (cval & Node3) {
	        x = cell.bottomleft;
	        y = 0;
	    } else {
	        x = 1;
	        y = cell.rightbottom;
	    }
	        break;
	    case 14:  if (cval & Node3) {
	        x = 1;
	        y = cell.rightbottom;
	    } else {
	        x = 0;
	        y = cell.leftbottom;
	    }
	        break;
	    case 15:  if (cval & Node0) {
	        x = 0;
	        y = cell.lefttop;
	    } else {
	        x = 1;
	        y = cell.rightbottom;
	    }
	        break;
	    case 16:  if (cval & Node2) {
	        x = 0;
	        y = cell.leftbottom;
	    } else {
	        x = cell.bottomright;
	        y = 0;
	    }
	        break;
	    case 17:  if (cval & Node0) {
	        x = 0;
	        y = cell.lefttop;
	    } else {
	        x = cell.bottomright;
	        y = 0;
	    }
	        break;
	    case 18:  if (cval & Node3) {
	        x = cell.bottomleft;
	        y = 0;
	    } else {
	        x = 0;
	        y = cell.leftbottom;
	    }
	        break;
	    case 19:  if (cval & Node0) {
	        x = 0;
	        y = cell.lefttop;
	    } else {
	        x = cell.bottomleft;
	        y = 0;
	    }
	        break;
	    case 20:  if (cval & Node0) {
	        x = 0;
	        y = cell.leftbottom;
	    } else {
	        x = cell.topleft;
	        y = 1;
	    }
	        break;
	    case 21:  if (cval & Node1) {
	        x = cell.topright;
	        y = 1;
	    } else {
	        x = 0;
	        y = cell.leftbottom;
	    }
	        break;
	    case 22:  if (cval & Node0) {
	        x = 0;
	        y = cell.lefttop;
	    } else {
	        x = cell.topleft;
	        y = 1;
	    }
	        break;
	    case 23:  if (cval & Node1) {
	        x = cell.topright;
	        y = 1;
	    } else {
	        x = 0;
	        y = cell.lefttop;
	    }
	        break;
	    default:  console.log('MarchingSquaresJS-isoBands: edge index out of range!');
	        console.log(cell);
	        return null;
	    }

	    if ((typeof x === 'undefined') || (typeof y === 'undefined') ||
	      (typeof d_x === 'undefined') || (typeof d_y === 'undefined') ||
	      (typeof d_o === 'undefined')) {
	        console.log('MarchingSquaresJS-isoBands: undefined value!');
	        console.log(cell);
	        console.log(x + ' ' + y + ' ' + d_x + ' ' + d_y + ' ' + d_o);
	    }
	    return {p: [x, y], x: d_x, y: d_y, o: d_o};
	}

	function BandGrid2Areas(grid) {
	    var areas = [];
	    var area_idx = 0;

	    grid.cells.forEach(function (g, j) {
	        g.forEach(function (gg, i) {
	            if (typeof gg !== 'undefined') {
	                var a = polygon_table[gg.cval](gg);
	                if ((typeof a === 'object') && isArray$3(a)) {
	                    if ((typeof a[0] === 'object') && isArray$3(a[0])) {
	                        if ((typeof a[0][0] === 'object') && isArray$3(a[0][0])) {
	                            a.forEach(function (aa) {
	                                aa.forEach(function (aaa) {
	                                    aaa[0] += i;
	                                    aaa[1] += j;
	                                });
	                                areas[area_idx++] = aa;
	                            });
	                        } else {
	                            a.forEach(function (aa) {
	                                aa[0] += i;
	                                aa[1] += j;
	                            });
	                            areas[area_idx++] = a;
	                        }
	                    } else {
	                        console.log('MarchingSquaresJS-isoBands: bandcell polygon with malformed coordinates');
	                    }
	                } else {
	                    console.log('MarchingSquaresJS-isoBands: bandcell polygon with null coordinates');
	                }
	            }
	        });
	    });

	    return areas;
	}

	/**
	 * Takes a grid {@link FeatureCollection} of {@link Point} features with z-values and an array of
	 * value breaks and generates filled contour isobands.
	 *
	 * @name isobands
	 * @param {FeatureCollection<Point>} pointGrid input points
	 * @param {Array<number>} breaks where to draw contours
	 * @param {Object} [options={}] options on output
	 * @param {string} [options.zProperty='elevation'] the property name in `points` from which z-values will be pulled
	 * @param {Object} [options.commonProperties={}] GeoJSON properties passed to ALL isobands
	 * @param {Array<Object>} [options.breaksProperties=[]] GeoJSON properties passed, in order, to the correspondent isoband (order defined by breaks)
	 * @returns {FeatureCollection<MultiPolygon>} a FeatureCollection of {@link MultiPolygon} features representing isobands
	 */
	function isobands(pointGrid, breaks, options) {
	    // Optional parameters
	    options = options || {};
	    if (!main$3.isObject(options)) throw new Error('options is invalid');
	    var zProperty = options.zProperty || 'elevation';
	    var commonProperties = options.commonProperties || {};
	    var breaksProperties = options.breaksProperties || [];

	    // Validation
	    main$7.collectionOf(pointGrid, 'Point', 'Input must contain Points');
	    if (!breaks) throw new Error('breaks is required');
	    if (!Array.isArray(breaks)) throw new Error('breaks is not an Array');
	    if (!main$3.isObject(commonProperties)) throw new Error('commonProperties is not an Object');
	    if (!Array.isArray(breaksProperties)) throw new Error('breaksProperties is not an Array');

	    // Isoband methods
	    var matrix = gridToMatrix(pointGrid, {zProperty: zProperty, flip: true});
	    var contours = createContourLines(matrix, breaks, zProperty);
	    contours = rescaleContours(contours, matrix, pointGrid);

	    var multipolygons = contours.map(function (contour, index) {
	        if (breaksProperties[index] && !main$3.isObject(breaksProperties[index])) {
	            throw new Error('Each mappedProperty is required to be an Object');
	        }
	        // collect all properties
	        var contourProperties = Object.assign(
	            {},
	            commonProperties,
	            breaksProperties[index]
	        );
	        contourProperties[zProperty] = contour[zProperty];
	        var multiP = main$3.multiPolygon(contour.groupedRings, contourProperties);
	        return multiP;
	    });

	    return main$3.featureCollection(multipolygons);
	}

	/**
	 * Creates the contours lines (featuresCollection of polygon features) from the 2D data grid
	 *
	 * Marchingsquares process the grid data as a 3D representation of a function on a 2D plane, therefore it
	 * assumes the points (x-y coordinates) are one 'unit' distance. The result of the IsoBands function needs to be
	 * rescaled, with turfjs, to the original area and proportions on the map
	 *
	 * @private
	 * @param {Array<Array<number>>} matrix Grid Data
	 * @param {Array<number>} breaks Breaks
	 * @param {string} [property='elevation'] Property
	 * @returns {Array<any>} contours
	 */
	function createContourLines(matrix, breaks, property) {

	    var contours = [];
	    for (var i = 1; i < breaks.length; i++) {
	        var lowerBand = +breaks[i - 1]; // make sure the breaks value is a number
	        var upperBand = +breaks[i];

	        var isobandsCoords = isoBands(matrix, lowerBand, upperBand - lowerBand);
	        // as per GeoJson rules for creating a Polygon, make sure the first element
	        // in the array of LinearRings represents the exterior ring (i.e. biggest area),
	        // and any subsequent elements represent interior rings (i.e. smaller area);
	        // this avoids rendering issues of the MultiPolygons on the map
	        var nestedRings = orderByArea(isobandsCoords);
	        var groupedRings = groupNestedRings(nestedRings);
	        var obj = {};
	        obj['groupedRings'] = groupedRings;
	        obj[property] = lowerBand + '-' + upperBand;
	        contours.push(obj);
	    }
	    return contours;
	}

	/**
	 * Transform isobands of 2D grid to polygons for the map
	 *
	 * @private
	 * @param {Array<any>} contours Contours
	 * @param {Array<Array<number>>} matrix Grid Data
	 * @param {Object} points Points by Latitude
	 * @returns {Array<any>} contours
	 */
	function rescaleContours(contours, matrix, points) {

	    // get dimensions (on the map) of the original grid
	    var gridBbox = bbox$1(points); // [ minX, minY, maxX, maxY ]
	    var originalWidth = gridBbox[2] - gridBbox[0];
	    var originalHeigth = gridBbox[3] - gridBbox[1];

	    // get origin, which is the first point of the last row on the rectangular data on the map
	    var x0 = gridBbox[0];
	    var y0 = gridBbox[1];
	    // get number of cells per side
	    var matrixWidth = matrix[0].length - 1;
	    var matrixHeight = matrix.length - 1;
	    // calculate the scaling factor between matrix and rectangular grid on the map
	    var scaleX = originalWidth / matrixWidth;
	    var scaleY = originalHeigth / matrixHeight;

	    var resize = function (point) {
	        point[0] = point[0] * scaleX + x0;
	        point[1] = point[1] * scaleY + y0;
	    };

	    // resize and shift each point/line of the isobands
	    contours.forEach(function (contour) {
	        contour.groupedRings.forEach(function (lineRingSet) {
	            lineRingSet.forEach(function (lineRing) {
	                lineRing.forEach(resize);
	            });
	        });
	    });
	    return contours;
	}


	/*  utility functions */


	/**
	 * Returns an array of coordinates (of LinearRings) in descending order by area
	 *
	 * @private
	 * @param {Array<LineString>} ringsCoords array of closed LineString
	 * @returns {Array} array of the input LineString ordered by area
	 */
	function orderByArea(ringsCoords) {
	    var ringsWithArea = [];
	    var areas = [];
	    ringsCoords.forEach(function (coords) {
	        // var poly = polygon([points]);
	        var ringArea = area$2(main$3.polygon([coords]));
	        // create an array of areas value
	        areas.push(ringArea);
	        // associate each lineRing with its area
	        ringsWithArea.push({ring: coords, area: ringArea});
	    });
	    areas.sort(function (a, b) { // bigger --> smaller
	        return b - a;
	    });
	    // create a new array of linearRings coordinates ordered by their area
	    var orderedByArea = [];
	    areas.forEach(function (area$$1) {
	        for (var lr = 0; lr < ringsWithArea.length; lr++) {
	            if (ringsWithArea[lr].area === area$$1) {
	                orderedByArea.push(ringsWithArea[lr].ring);
	                ringsWithArea.splice(lr, 1);
	                break;
	            }
	        }
	    });
	    return orderedByArea;
	}

	/**
	 * Returns an array of arrays of coordinates, each representing
	 * a set of (coordinates of) nested LinearRings,
	 * i.e. the first ring contains all the others
	 *
	 * @private
	 * @param {Array} orderedLinearRings array of coordinates (of LinearRings) in descending order by area
	 * @returns {Array<Array>} Array of coordinates of nested LinearRings
	 */
	function groupNestedRings(orderedLinearRings) {
	    // create a list of the (coordinates of) LinearRings
	    var lrList = orderedLinearRings.map(function (lr) {
	        return {lrCoordinates: lr, grouped: false};
	    });
	    var groupedLinearRingsCoords = [];
	    while (!allGrouped(lrList)) {
	        for (var i = 0; i < lrList.length; i++) {
	            if (!lrList[i].grouped) {
	                // create new group starting with the larger not already grouped ring
	                var group = [];
	                group.push(lrList[i].lrCoordinates);
	                lrList[i].grouped = true;
	                var outerMostPoly = main$3.polygon([lrList[i].lrCoordinates]);
	                // group all the rings contained by the outermost ring
	                for (var j = i + 1; j < lrList.length; j++) {
	                    if (!lrList[j].grouped) {
	                        var lrPoly = main$3.polygon([lrList[j].lrCoordinates]);
	                        if (isInside(lrPoly, outerMostPoly)) {
	                            group.push(lrList[j].lrCoordinates);
	                            lrList[j].grouped = true;
	                        }
	                    }
	                }
	                // insert the new group
	                groupedLinearRingsCoords.push(group);
	            }
	        }
	    }
	    return groupedLinearRingsCoords;
	}

	/**
	 * @private
	 * @param {Polygon} testPolygon polygon of interest
	 * @param {Polygon} targetPolygon polygon you want to compare with
	 * @returns {boolean} true if test-Polygon is inside target-Polygon
	 */
	function isInside(testPolygon, targetPolygon) {
	    var points = explode$1(testPolygon);
	    for (var i = 0; i < points.features.length; i++) {
	        if (!booleanPointInPolygon$1(points.features[i], targetPolygon)) {
	            return false;
	        }
	    }
	    return true;
	}

	/**
	 * @private
	 * @param {Array<Object>} list list of objects which might contain the 'group' attribute
	 * @returns {boolean} true if all the objects in the list are marked as grouped
	 */
	function allGrouped(list) {
	    for (var i = 0; i < list.length; i++) {
	        if (list[i].grouped === false) {
	            return false;
	        }
	    }
	    return true;
	}

	var main$c = isobands;
	var default_1$4 = isobands;
	main$c.default = default_1$4;

	var script$1Q = {
	  name: 'vc-kriging-map',
	  data: function data() {
	    return {
	      coordinates: {
	        west: 0,
	        south: 0,
	        east: 0,
	        north: 0
	      },
	      data: null,
	      datasourceOptions: {
	        clampToGround: true
	      },
	      nowaiting: true
	    };
	  },
	  mixins: [cmp],
	  props: {
	    values: Array,
	    lngs: Array,
	    lats: Array,
	    krigingModel: {
	      type: String,
	      default: 'exponential' // gaussian spherical exponential

	    },
	    krigingSigma2: {
	      type: Number,
	      default: 0
	    },
	    krigingAlpha: {
	      type: Number,
	      default: 100
	    },
	    canvasAlpha: {
	      type: Number,
	      default: 1
	    },
	    colors: {
	      type: Array,
	      default: function _default() {
	        return ['#006837', '#1a9850', '#66bd63', '#a6d96a', '#d9ef8b', '#ffffbf', '#fee08b', '#fdae61', '#f46d43', '#d73027', '#a50026'];
	      }
	    },
	    breaks: {
	      type: Array,
	      default: function _default() {
	        return [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0];
	      }
	    },
	    clipCoords: {
	      type: [Array, String],
	      default: function _default() {
	        return [];
	      }
	    },
	    show: {
	      type: Boolean,
	      default: true
	    },
	    cell: Number
	  },
	  created: function created() {
	    var _this = this;

	    this._creatPromise = new promise$1(function (resolve, reject) {
	      _this._resolve = resolve;
	      _this._reject = reject;
	    });
	  },
	  mounted: function mounted() {
	    var _this2 = this;

	    this.getParent(this.$parent).createPromise.then(function _callee(_ref) {
	      var Cesium, viewer, values, lngs, lats, krigingModel, krigingSigma2, breaks, clipCoords, krigingAlpha, variogram, coordinates, requstData, coords, i, j, rectangle, extent, grid, fc, collection, isobandsResult;
	      return regenerator.async(function _callee$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              Cesium = _ref.Cesium, viewer = _ref.viewer;
	              values = _this2.values, lngs = _this2.lngs, lats = _this2.lats, krigingModel = _this2.krigingModel, krigingSigma2 = _this2.krigingSigma2, breaks = _this2.breaks, clipCoords = _this2.clipCoords, krigingAlpha = _this2.krigingAlpha;
	              variogram = kriging$1.train(values, lngs, lats, krigingModel, krigingSigma2, krigingAlpha);
	              coordinates = [];

	              if (!(clipCoords instanceof Array)) {
	                _context.next = 8;
	                break;
	              }

	              if (clipCoords.length > 0 && clipCoords[0][0]) {
	                // 传的是 geojson 面
	                coordinates = clipCoords;
	              } else {
	                // 传的是一个 bounds 数组 (左下和右上)
	                coordinates.push([[clipCoords[0], clipCoords[1]], [clipCoords[0], clipCoords[3]], [clipCoords[2], clipCoords[3]], [clipCoords[2], clipCoords[1]]]);
	              }

	              _context.next = 13;
	              break;

	            case 8:
	              if (!(typeof clipCoords === 'string')) {
	                _context.next = 13;
	                break;
	              }

	              _context.next = 11;
	              return regenerator.awrap(Cesium.Resource.fetchJson(clipCoords));

	            case 11:
	              requstData = _context.sent;
	              coordinates = requstData.features[0].geometry.coordinates;

	            case 13:
	              coords = [];

	              for (i = 0; i < coordinates[0].length; i++) {
	                for (j = 0; j < 2; j++) {
	                  coords.push(coordinates[0][i][j]);
	                }
	              }

	              if (coords.length > 4) {
	                rectangle = Cesium.PolygonGeometry.computeRectangle({
	                  polygonHierarchy: new Cesium.PolygonHierarchy(Cesium.Cartesian3.fromDegreesArray(coords))
	                });
	              } else {
	                rectangle = Cesium.Rectangle.fromDegrees(coords[0], coords[1], coords[2], coords[3]);
	              }

	              _this2.coordinates = rectangle;
	              extent = [Cesium.Math.toDegrees(rectangle.west), Cesium.Math.toDegrees(rectangle.south), Cesium.Math.toDegrees(rectangle.east), Cesium.Math.toDegrees(rectangle.north)];
	              grid = kriging$1.grid(coordinates, variogram, _this2.cell ? _this2.cell : (extent[2] - extent[0]) / 200);
	              fc = _this2.gridFeatureCollection(grid, [extent[0], extent[2]], [extent[1], extent[3]]);
	              collection = helpers_13(fc); // console.log(collection)

	              isobandsResult = main$c(collection, breaks, {
	                zProperty: 'value'
	              }); // console.log(isobandsResult)
	              // const sortArea = (a, b) => {
	              //   return area(b) - area(a)
	              // }
	              // // 按照面积对图层进行排序，规避turf的一个bug
	              // isobandsResult.features.sort(sortArea)

	              _this2.data = isobandsResult;

	              _this2._resolve(true);

	            case 24:
	            case "end":
	              return _context.stop();
	          }
	        }
	      });
	    });
	  },
	  methods: {
	    createCesiumObject: function createCesiumObject() {
	      var _this3 = this;

	      return regenerator.async(function createCesiumObject$(_context2) {
	        while (1) {
	          switch (_context2.prev = _context2.next) {
	            case 0:
	              return _context2.abrupt("return", this._creatPromise.then(function () {
	                return _this3.$refs.geojsonDatasource.createPromise.then(function (_ref2) {
	                  var Cesium = _ref2.Cesium,
	                      viewer = _ref2.viewer,
	                      cesiumObject = _ref2.cesiumObject;
	                  var setPolygonColor = _this3.setPolygonColor;

	                  if (!_this3.$refs.geojsonDatasource._mounted) {
	                    return _this3.$refs.geojsonDatasource.load().then(function (_ref3) {
	                      var Cesium = _ref3.Cesium,
	                          viewer = _ref3.viewer,
	                          cesiumObject = _ref3.cesiumObject;
	                      return setPolygonColor(cesiumObject);
	                    });
	                  } else {
	                    return setPolygonColor(cesiumObject);
	                  }
	                });
	              }));

	            case 1:
	            case "end":
	              return _context2.stop();
	          }
	        }
	      }, null, this);
	    },
	    setPolygonColor: function setPolygonColor(cesiumObject) {
	      var breaks = this.breaks,
	          colors = this.colors,
	          canvasAlpha = this.canvasAlpha;
	      cesiumObject.entities.values.reduce(function (pre, cur) {
	        var value = cur.properties.getValue(Cesium.JulianDate.now).value;
	        var breakValue = value.substr(0, value.lastIndexOf('-'));
	        var index = breaks.indexOf(_parseFloat$2(breakValue));
	        cur.polygon.material = Cesium.Color.fromCssColorString(colors[index]).withAlpha(canvasAlpha);
	        cur.polygon.outline = false;
	        return true;
	      }, []);
	      return cesiumObject;
	    },
	    gridFeatureCollection: function gridFeatureCollection(grid, xlim, ylim) {
	      // var range = grid.zlim[1] - grid.zlim[0]
	      var i, j, x, y, z;
	      var n = grid.data.length; // 列数

	      var m = grid.data[0].length; // 行数

	      var pointArray = [];

	      for (i = 0; i < n; i++) {
	        for (j = 0; j < m; j++) {
	          x = i * grid.width + grid.xlim[0];
	          y = j * grid.width + grid.ylim[0]; // z = (grid.data[i][j] - grid.zlim[0]) / range

	          z = grid.data[i][j]; // if (z < 0.0) z = 0.0
	          // if (z > 1.0) z = 1.0

	          pointArray.push(helpers_7([x, y], {
	            value: z
	          }));
	        }
	      }

	      return pointArray;
	    },
	    mount: function mount() {
	      return regenerator.async(function mount$(_context3) {
	        while (1) {
	          switch (_context3.prev = _context3.next) {
	            case 0:
	              return _context3.abrupt("return", true);

	            case 1:
	            case "end":
	              return _context3.stop();
	          }
	        }
	      });
	    },
	    unmount: function unmount() {
	      return regenerator.async(function unmount$(_context4) {
	        while (1) {
	          switch (_context4.prev = _context4.next) {
	            case 0:
	              return _context4.abrupt("return", this.$refs.geojsonDatasource && this.$refs.geojsonDatasource.unload());

	            case 1:
	            case "end":
	              return _context4.stop();
	          }
	        }
	      }, null, this);
	    }
	  }
	};

	/* script */
	var __vue_script__$1Q = script$1Q;
	/* template */

	var __vue_render__$n = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('i', {
	    class: _vm.$options.name,
	    staticStyle: {
	      "display": "none !important"
	    }
	  }, [_vm.data !== null ? _c('vc-datasource-geojson', {
	    ref: "geojsonDatasource",
	    attrs: {
	      "data": _vm.data,
	      "options": _vm.datasourceOptions,
	      "show": _vm.show
	    }
	  }) : _vm._e()], 1);
	};

	var __vue_staticRenderFns__$n = [];
	/* style */

	var __vue_inject_styles__$1Q = undefined;
	/* scoped */

	var __vue_scope_id__$1Q = undefined;
	/* functional template */

	var __vue_is_functional_template__$1Q = false;
	/* component normalizer */

	function __vue_normalize__$1Q(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "VcKrigingMap.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var VcKrigingMap = __vue_normalize__$1Q({
	  render: __vue_render__$n,
	  staticRenderFns: __vue_staticRenderFns__$n
	}, __vue_inject_styles__$1Q, __vue_script__$1Q, __vue_scope_id__$1Q, __vue_is_functional_template__$1Q);

	function plugin$1G(Vue) {

	  if (plugin$1G.installed) {
	    return;
	  }

	  plugin$1G.installed = true;
	  Vue.use(GeoJsonDataSource$1);
	  Vue.component(VcKrigingMap.name, VcKrigingMap);
	}

	var VcKrigingMap$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$1G,
		VcKrigingMap: VcKrigingMap,
		install: plugin$1G
	});

	var colorTable = {
	  ncolors: 16,
	  colorTable: [0.015686, 0.054902, 0.847059, 0.12549, 0.313725, 1.0, 0.254902, 0.588235, 1.0, 0.427451, 0.756863, 1.0, 0.52549, 0.85098, 1.0, 0.611765, 0.933333, 1.0, 0.686275, 0.960784, 1.0, 0.807843, 1.0, 1.0, 1.0, 0.996078, 0.278431, 1.0, 0.921569, 0.0, 1.0, 0.768627, 0.0, 1.0, 0.564706, 0.0, 1.0, 0.282353, 0.0, 1.0, 0.0, 0.0, 0.835294, 0.0, 0.0, 0.619608, 0.0, 0.0]
	};

	var Util$1 = function () {
	  var fullscreenQuad = null;

	  var getFullscreenQuad = function getFullscreenQuad() {
	    if (!Cesium.defined(fullscreenQuad)) {
	      fullscreenQuad = new Cesium.Geometry({
	        attributes: new Cesium.GeometryAttributes({
	          position: new Cesium.GeometryAttribute({
	            componentDatatype: Cesium.ComponentDatatype.FLOAT,
	            componentsPerAttribute: 3,
	            //  v3----v2
	            //  |     |
	            //  |     |
	            //  v0----v1
	            values: new Float32Array([-1, -1, 0, // v0
	            1, -1, 0, // v1
	            1, 1, 0, // v2
	            -1, 1, 0 // v3
	            ])
	          }),
	          st: new Cesium.GeometryAttribute({
	            componentDatatype: Cesium.ComponentDatatype.FLOAT,
	            componentsPerAttribute: 2,
	            values: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1])
	          })
	        }),
	        indices: new Uint32Array([3, 2, 0, 0, 2, 1])
	      });
	    }

	    return fullscreenQuad;
	  };

	  var createTexture = function createTexture(options, typedArray) {
	    if (Cesium.defined(typedArray)) {
	      // typed array needs to be passed as source option, this is required by Cesium.Texture
	      var source = {};
	      source.arrayBufferView = typedArray;
	      options.source = source;
	    }

	    var texture = new Cesium.Texture(options);
	    return texture;
	  };

	  var createFramebuffer = function createFramebuffer(context, colorTexture, depthTexture) {
	    var framebuffer = new Cesium.Framebuffer({
	      context: context,
	      colorTextures: [colorTexture],
	      depthTexture: depthTexture
	    });
	    return framebuffer;
	  };

	  var createRawRenderState = function createRawRenderState(options) {
	    var translucent = true;
	    var closed = false;
	    var existing = {
	      viewport: options.viewport,
	      depthTest: options.depthTest,
	      depthMask: options.depthMask,
	      blending: options.blending
	    };
	    var rawRenderState = Cesium.Appearance.getDefaultRenderState(translucent, closed, existing);
	    return rawRenderState;
	  };

	  var viewRectangleToLonLatRange = function viewRectangleToLonLatRange(viewRectangle) {
	    var range = {};
	    var postiveWest = Cesium.Math.mod(viewRectangle.west, Cesium.Math.TWO_PI);
	    var postiveEast = Cesium.Math.mod(viewRectangle.east, Cesium.Math.TWO_PI);
	    var width = viewRectangle.width;
	    var longitudeMin;
	    var longitudeMax;

	    if (width > Cesium.Math.THREE_PI_OVER_TWO) {
	      longitudeMin = 0.0;
	      longitudeMax = Cesium.Math.TWO_PI;
	    } else {
	      if (postiveEast - postiveWest < width) {
	        longitudeMin = postiveWest;
	        longitudeMax = postiveWest + width;
	      } else {
	        longitudeMin = postiveWest;
	        longitudeMax = postiveEast;
	      }
	    }

	    range.lon = {
	      min: Cesium.Math.toDegrees(longitudeMin),
	      max: Cesium.Math.toDegrees(longitudeMax)
	    };
	    var south = viewRectangle.south;
	    var north = viewRectangle.north;
	    var height = viewRectangle.height;
	    var extendHeight = height > Cesium.Math.PI / 12 ? height / 2 : 0;
	    var extendedSouth = Cesium.Math.clampToLatitudeRange(south - extendHeight);
	    var extendedNorth = Cesium.Math.clampToLatitudeRange(north + extendHeight); // extend the bound in high latitude area to make sure it can cover all the visible area

	    if (extendedSouth < -Cesium.Math.PI_OVER_THREE) {
	      extendedSouth = -Cesium.Math.PI_OVER_TWO;
	    }

	    if (extendedNorth > Cesium.Math.PI_OVER_THREE) {
	      extendedNorth = Cesium.Math.PI_OVER_TWO;
	    }

	    range.lat = {
	      min: Cesium.Math.toDegrees(extendedSouth),
	      max: Cesium.Math.toDegrees(extendedNorth)
	    };
	    return range;
	  };

	  return {
	    getFullscreenQuad: getFullscreenQuad,
	    createTexture: createTexture,
	    createFramebuffer: createFramebuffer,
	    createRawRenderState: createRawRenderState,
	    viewRectangleToLonLatRange: viewRectangleToLonLatRange
	  };
	}();

	var CustomPrimitive =
	/*#__PURE__*/
	function () {
	  function CustomPrimitive(options) {
	    _classCallCheck(this, CustomPrimitive);

	    this.commandType = options.commandType;
	    this.geometry = options.geometry;
	    this.attributeLocations = options.attributeLocations;
	    this.primitiveType = options.primitiveType;
	    this.uniformMap = options.uniformMap;
	    this.vertexShaderSource = options.vertexShaderSource;
	    this.fragmentShaderSource = options.fragmentShaderSource;
	    this.rawRenderState = options.rawRenderState;
	    this.framebuffer = options.framebuffer;
	    this.outputTexture = options.outputTexture;
	    this.autoClear = Cesium.defaultValue(options.autoClear, false);
	    this.preExecute = options.preExecute;
	    this.show = true;
	    this.commandToExecute = undefined;
	    this.clearCommand = undefined;

	    if (this.autoClear) {
	      this.clearCommand = new Cesium.ClearCommand({
	        color: new Cesium.Color(0.0, 0.0, 0.0, 0.0),
	        depth: 1.0,
	        framebuffer: this.framebuffer,
	        pass: Cesium.Pass.OPAQUE
	      });
	    }
	  }

	  _createClass(CustomPrimitive, [{
	    key: "createCommand",
	    value: function createCommand(context) {
	      switch (this.commandType) {
	        case 'Draw':
	          {
	            var vertexArray = Cesium.VertexArray.fromGeometry({
	              context: context,
	              geometry: this.geometry,
	              attributeLocations: this.attributeLocations,
	              bufferUsage: Cesium.BufferUsage.STATIC_DRAW
	            });
	            var shaderProgram = Cesium.ShaderProgram.fromCache({
	              context: context,
	              attributeLocations: this.attributeLocations,
	              vertexShaderSource: this.vertexShaderSource,
	              fragmentShaderSource: this.fragmentShaderSource
	            });
	            var renderState = Cesium.RenderState.fromCache(this.rawRenderState);
	            return new Cesium.DrawCommand({
	              owner: this,
	              vertexArray: vertexArray,
	              primitiveType: this.primitiveType,
	              uniformMap: this.uniformMap,
	              modelMatrix: Cesium.Matrix4.IDENTITY,
	              shaderProgram: shaderProgram,
	              framebuffer: this.framebuffer,
	              renderState: renderState,
	              pass: Cesium.Pass.OPAQUE
	            });
	          }

	        case 'Compute':
	          {
	            return new Cesium.ComputeCommand({
	              owner: this,
	              fragmentShaderSource: this.fragmentShaderSource,
	              uniformMap: this.uniformMap,
	              outputTexture: this.outputTexture,
	              persists: true
	            });
	          }
	      }
	    }
	  }, {
	    key: "setGeometry",
	    value: function setGeometry(context, geometry) {
	      this.geometry = geometry;
	      var vertexArray = Cesium.VertexArray.fromGeometry({
	        context: context,
	        geometry: this.geometry,
	        attributeLocations: this.attributeLocations,
	        bufferUsage: Cesium.BufferUsage.STATIC_DRAW
	      });
	      this.commandToExecute.vertexArray = vertexArray;
	    }
	  }, {
	    key: "update",
	    value: function update(frameState) {
	      if (!this.show) {
	        return;
	      }

	      if (!Cesium.defined(this.commandToExecute)) {
	        this.commandToExecute = this.createCommand(frameState.context);
	      }

	      if (Cesium.defined(this.preExecute)) {
	        this.preExecute();
	      }

	      if (Cesium.defined(this.clearCommand)) {
	        frameState.commandList.push(this.clearCommand);
	      }

	      frameState.commandList.push(this.commandToExecute);
	    }
	  }, {
	    key: "isDestroyed",
	    value: function isDestroyed() {
	      return false;
	    }
	  }, {
	    key: "destroy",
	    value: function destroy() {
	      if (Cesium.defined(this.commandToExecute)) {
	        this.commandToExecute.shaderProgram = this.commandToExecute.shaderProgram && this.commandToExecute.shaderProgram.destroy();
	      }

	      return Cesium.destroyObject(this);
	    }
	  }]);

	  return CustomPrimitive;
	}();

	var fullscreenVert = "\nattribute vec3 position;\nattribute vec2 st;\n\nvarying vec2 textureCoordinate;\n\nvoid main() {\n    textureCoordinate = st;\n    gl_Position = vec4(position, 1.0);\n}\n";
	var getWindFrag = "\n// the size of UV textures: width = lon, height = lat*lev\nuniform sampler2D U; // eastward wind\nuniform sampler2D V; // northward wind\n\nuniform sampler2D currentParticlesPosition; // (lon, lat, lev)\n\nuniform vec3 dimension; // (lon, lat, lev)\nuniform vec3 minimum; // minimum of each dimension\nuniform vec3 maximum; // maximum of each dimension\nuniform vec3 interval; // interval of each dimension\n\nvarying vec2 v_textureCoordinates;\n\nvec2 mapPositionToNormalizedIndex2D(vec3 lonLatLev) {\n    // ensure the range of longitude and latitude\n    lonLatLev.x = mod(lonLatLev.x, 360.0);\n    lonLatLev.y = clamp(lonLatLev.y, -90.0, 90.0);\n\n    vec3 index3D = vec3(0.0);\n    index3D.x = (lonLatLev.x - minimum.x) / interval.x;\n    index3D.y = (lonLatLev.y - minimum.y) / interval.y;\n    index3D.z = (lonLatLev.z - minimum.z) / interval.z;\n\n    // the st texture coordinate corresponding to (col, row) index\n    // example\n    // data array is [0, 1, 2, 3, 4, 5], width = 3, height = 2\n    // the content of texture will be\n    // t 1.0\n    //    |  3 4 5\n    //    |\n    //    |  0 1 2\n    //   0.0------1.0 s\n\n    vec2 index2D = vec2(index3D.x, index3D.z * dimension.y + index3D.y);\n    vec2 normalizedIndex2D = vec2(index2D.x / dimension.x, index2D.y / (dimension.y * dimension.z));\n    return normalizedIndex2D;\n}\n\nfloat getWind(sampler2D windTexture, vec3 lonLatLev) {\n    vec2 normalizedIndex2D = mapPositionToNormalizedIndex2D(lonLatLev);\n    float result = texture2D(windTexture, normalizedIndex2D).r;\n    return result;\n}\n\nconst mat4 kernelMatrix = mat4(\n    0.0, -1.0, 2.0, -1.0, // first column\n    2.0, 0.0, -5.0, 3.0, // second column\n    0.0, 1.0, 4.0, -3.0, // third column\n    0.0, 0.0, -1.0, 1.0 // fourth column\n);\nfloat oneDimensionInterpolation(float t, float p0, float p1, float p2, float p3) {\n    vec4 tVec4 = vec4(1.0, t, t * t, t * t * t);\n    tVec4 = tVec4 / 2.0;\n    vec4 pVec4 = vec4(p0, p1, p2, p3);\n    return dot((tVec4 * kernelMatrix), pVec4);\n}\n\nfloat calculateB(sampler2D windTexture, float t, float lon, float lat, float lev) {\n    float lon0 = floor(lon) - 1.0 * interval.x;\n    float lon1 = floor(lon);\n    float lon2 = floor(lon) + 1.0 * interval.x;\n    float lon3 = floor(lon) + 2.0 * interval.x;\n\n    float p0 = getWind(windTexture, vec3(lon0, lat, lev));\n    float p1 = getWind(windTexture, vec3(lon1, lat, lev));\n    float p2 = getWind(windTexture, vec3(lon2, lat, lev));\n    float p3 = getWind(windTexture, vec3(lon3, lat, lev));\n\n    return oneDimensionInterpolation(t, p0, p1, p2, p3);\n}\n\nfloat interpolateOneTexture(sampler2D windTexture, vec3 lonLatLev) {\n    float lon = lonLatLev.x;\n    float lat = lonLatLev.y;\n    float lev = lonLatLev.z;\n\n    float lat0 = floor(lat) - 1.0 * interval.y;\n    float lat1 = floor(lat);\n    float lat2 = floor(lat) + 1.0 * interval.y;\n    float lat3 = floor(lat) + 2.0 * interval.y;\n\n    vec2 coef = lonLatLev.xy - floor(lonLatLev.xy);\n    float b0 = calculateB(windTexture, coef.x, lon, lat0, lev);\n    float b1 = calculateB(windTexture, coef.x, lon, lat1, lev);\n    float b2 = calculateB(windTexture, coef.x, lon, lat2, lev);\n    float b3 = calculateB(windTexture, coef.x, lon, lat3, lev);\n\n    return oneDimensionInterpolation(coef.y, b0, b1, b2, b3);\n}\n\nvec3 bicubic(vec3 lonLatLev) {\n    // https://en.wikipedia.org/wiki/Bicubic_interpolation#Bicubic_convolution_algorithm\n    float u = interpolateOneTexture(U, lonLatLev);\n    float v = interpolateOneTexture(V, lonLatLev);\n    float w = 0.0;\n    return vec3(u, v, w);\n}\n\nconst float h = 1.0;\nvec3 rungeKutta4(vec3 lonLatLev) {\n    vec3 p1 = lonLatLev;\n    vec3 k1 = bicubic(p1);\n\n    vec3 p2 = p1;\n    p2.xy = p2.xy + 0.5 * h * k1.xy;\n    vec3 k2 = bicubic(p2);\n\n    vec3 p3 = p1;\n    p3.xy = p3.xy + 0.5 * h * k2.xy;\n    vec3 k3 = bicubic(p3);\n\n    vec3 p4 = p1;\n    p4.xy = p4.xy + h * k3.xy;\n    vec3 k4 = bicubic(p4);\n\n    vec3 rk4 = (k1 + 2.0 * k2 + 2.0 * k3 + k4) / 6.0;\n    return rk4;\n}\n\nvoid main() {\n    // texture coordinate must be normalized\n    vec3 lonLatLev = texture2D(currentParticlesPosition, v_textureCoordinates).rgb;\n    vec3 windVector = rungeKutta4(lonLatLev);\n    gl_FragColor = vec4(windVector, 0.0);\n}\n";
	var postProcessingPositionFrag = "\nuniform sampler2D nextParticlesPosition;\nuniform sampler2D nextParticlesSpeed; // (u, v, w, normalization)\n\n// range (min, max)\nuniform vec2 lonRange;\nuniform vec2 latRange;\nuniform vec2 lonDataRange;\nuniform vec2 latDataRange;\n\nuniform float randomCoef; // use to improve the pseudo-random generator\nuniform float dropRate; // drop rate is a chance a particle will restart at random position to avoid degeneration\nuniform float dropRateBump;\n\nvarying vec2 v_textureCoordinates;\n\n// pseudo-random generator\nconst vec3 randomConstants = vec3(12.9898, 78.233, 4375.85453);\nconst vec2 normalRange = vec2(0.0, 1.0);\nfloat rand(vec2 seed, vec2 range) {\n    vec2 randomSeed = randomCoef * seed;\n    float temp = dot(randomConstants.xy, randomSeed);\n    temp = fract(sin(temp) * (randomConstants.z + temp));\n    return temp * (range.y - range.x) + range.x;\n}\n\nvec3 generateRandomParticle(vec2 seed, float lev) {\n    // ensure the longitude is in [0, 360]\n    float randomLon = mod(rand(seed, lonRange), 360.0);\n    float randomLat = rand(-seed, latRange);\n\n    return vec3(randomLon, randomLat, lev);\n}\n\nbool particleOutbound(vec3 particle) {\n    return particle.y < -90.0 || particle.y > 90.0 || particle.y < latDataRange.x || particle.y > latDataRange.y || particle.x < lonDataRange.x || particle.x > lonDataRange.y;\n}\n\nvoid main() {\n    vec3 nextParticle = texture2D(nextParticlesPosition, v_textureCoordinates).rgb;\n    vec4 nextSpeed = texture2D(nextParticlesSpeed, v_textureCoordinates);\n    float particleDropRate = dropRate + dropRateBump * nextSpeed.a;\n\n    vec2 seed1 = nextParticle.xy + v_textureCoordinates;\n    vec2 seed2 = nextSpeed.xy + v_textureCoordinates;\n    vec3 randomParticle = generateRandomParticle(seed1, nextParticle.z);\n    float randomNumber = rand(seed2, normalRange);\n\n    if (randomNumber < particleDropRate || particleOutbound(nextParticle)) {\n        gl_FragColor = vec4(randomParticle, 1.0); // 1.0 means this is a random particle\n    } else {\n        gl_FragColor = vec4(nextParticle, 0.0);\n    }\n}\n";
	var postProcessingSpeedFrag = "\nuniform sampler2D postProcessingPosition;\nuniform sampler2D nextParticlesSpeed;\n\nvarying vec2 v_textureCoordinates;\n\nvoid main() {\n    vec4 randomParticle = texture2D(postProcessingPosition, v_textureCoordinates);\n    vec4 particleSpeed = texture2D(nextParticlesSpeed, v_textureCoordinates);\n\n    if (randomParticle.a > 0.0) {\n        gl_FragColor = vec4(0.0);\n    } else {\n        gl_FragColor = particleSpeed;\n    }\n}\n";
	var screenDrawFrag = "\nuniform sampler2D trailsColorTexture;\nuniform sampler2D trailsDepthTexture;\n\nvarying vec2 textureCoordinate;\n\nvoid main() {\n    vec4 trailsColor = texture2D(trailsColorTexture, textureCoordinate);\n    float trailsDepth = texture2D(trailsDepthTexture, textureCoordinate).r;\n    float globeDepth = czm_unpackDepth(texture2D(czm_globeDepthTexture, textureCoordinate));\n\n    if (trailsDepth < globeDepth) {\n        gl_FragColor = trailsColor;\n    } else {\n        gl_FragColor = vec4(0.0);\n    }\n}\n";
	var segmentDrawFrag = "\nuniform sampler2D colorTable;\n\nvarying float speedNormalization;\n\nvoid main() {\n    gl_FragColor = texture2D(colorTable, vec2(speedNormalization, 0.0));\n}\n";
	var segmentDrawVert = "\nattribute vec2 st;\n// it is not normal itself, but used to control normal\nattribute vec3 normal; // (point to use, offset sign, not used component)\n\nuniform sampler2D currentParticlesPosition;\nuniform sampler2D postProcessingPosition;\nuniform sampler2D postProcessingSpeed;\n\nuniform float particleHeight;\n\nuniform float aspect;\nuniform float pixelSize;\nuniform float lineWidth;\n\nvarying float speedNormalization;\n\nvec3 convertCoordinate(vec3 lonLatLev) {\n    // WGS84 (lon, lat, lev) -> ECEF (x, y, z)\n    // see https://en.wikipedia.org/wiki/Geographic_coordinate_conversion#From_geodetic_to_ECEF_coordinates for detail\n\n    // WGS 84 geometric constants\n    float a = 6378137.0; // Semi-major axis\n    float b = 6356752.3142; // Semi-minor axis\n    float e2 = 6.69437999014e-3; // First eccentricity squared\n\n    float latitude = radians(lonLatLev.y);\n    float longitude = radians(lonLatLev.x);\n\n    float cosLat = cos(latitude);\n    float sinLat = sin(latitude);\n    float cosLon = cos(longitude);\n    float sinLon = sin(longitude);\n\n    float N_Phi = a / sqrt(1.0 - e2 * sinLat * sinLat);\n    float h = particleHeight; // it should be high enough otherwise the particle may not pass the terrain depth test\n\n    vec3 cartesian = vec3(0.0);\n    cartesian.x = (N_Phi + h) * cosLat * cosLon;\n    cartesian.y = (N_Phi + h) * cosLat * sinLon;\n    cartesian.z = ((b * b) / (a * a) * N_Phi + h) * sinLat;\n    return cartesian;\n}\n\nvec4 calcProjectedCoord(vec3 lonLatLev) {\n    // the range of longitude in Cesium is [-180, 180] but the range of longitude in the NetCDF file is [0, 360]\n    // [0, 180] is corresponding to [0, 180] and [180, 360] is corresponding to [-180, 0]\n    lonLatLev.x = mod(lonLatLev.x + 180.0, 360.0) - 180.0;\n    vec3 particlePosition = convertCoordinate(lonLatLev);\n    vec4 projectedCoord = czm_modelViewProjection * vec4(particlePosition, 1.0);\n    return projectedCoord;\n}\n\nvec4 calcOffset(vec4 currentProjectedCoord, vec4 nextProjectedCoord, float offsetSign) {\n    vec2 aspectVec2 = vec2(aspect, 1.0);\n    vec2 currentXY = (currentProjectedCoord.xy / currentProjectedCoord.w) * aspectVec2;\n    vec2 nextXY = (nextProjectedCoord.xy / nextProjectedCoord.w) * aspectVec2;\n\n    float offsetLength = lineWidth / 2.0;\n    vec2 direction = normalize(nextXY - currentXY);\n    vec2 normalVector = vec2(-direction.y, direction.x);\n    normalVector.x = normalVector.x / aspect;\n    normalVector = offsetLength * normalVector;\n\n    vec4 offset = vec4(offsetSign * normalVector, 0.0, 0.0);\n    return offset;\n}\n\nvoid main() {\n    vec2 particleIndex = st;\n\n    vec3 currentPosition = texture2D(currentParticlesPosition, particleIndex).rgb;\n    vec4 nextPosition = texture2D(postProcessingPosition, particleIndex);\n\n    vec4 currentProjectedCoord = vec4(0.0);\n    vec4 nextProjectedCoord = vec4(0.0);\n    if (nextPosition.w > 0.0) {\n      currentProjectedCoord = calcProjectedCoord(currentPosition);\n      nextProjectedCoord = calcProjectedCoord(currentPosition);\n    } else {\n        currentProjectedCoord = calcProjectedCoord(currentPosition);\n      nextProjectedCoord = calcProjectedCoord(nextPosition.xyz);\n    }\n\n    float pointToUse = normal.x; // -1 is currentProjectedCoord and +1 is nextProjectedCoord\n    float offsetSign = normal.y;\n\n    vec4 offset = pixelSize * calcOffset(currentProjectedCoord, nextProjectedCoord, offsetSign);\n    if (pointToUse < 0.0) {\n        gl_Position = currentProjectedCoord + offset;\n    } else {\n        gl_Position = nextProjectedCoord + offset;\n    }\n\n    speedNormalization = texture2D(postProcessingSpeed, particleIndex).a;\n}\n";
	var trailDrawFrag = "\nuniform sampler2D segmentsColorTexture;\nuniform sampler2D segmentsDepthTexture;\n\nuniform sampler2D currentTrailsColor;\nuniform sampler2D trailsDepthTexture;\n\nuniform float fadeOpacity;\n\nvarying vec2 textureCoordinate;\n\nvoid main() {\n    vec4 pointsColor = texture2D(segmentsColorTexture, textureCoordinate);\n    vec4 trailsColor = texture2D(currentTrailsColor, textureCoordinate);\n\n    trailsColor = floor(fadeOpacity * 255.0 * trailsColor) / 255.0; // make sure the trailsColor will be strictly decreased\n\n    float pointsDepth = texture2D(segmentsDepthTexture, textureCoordinate).r;\n    float trailsDepth = texture2D(trailsDepthTexture, textureCoordinate).r;\n    float globeDepth = czm_unpackDepth(texture2D(czm_globeDepthTexture, textureCoordinate));\n\n    gl_FragColor = vec4(0.0);\n    if (pointsDepth < globeDepth) {\n      gl_FragColor = gl_FragColor + pointsColor;\n    }\n    if (trailsDepth < globeDepth) {\n      gl_FragColor = gl_FragColor + trailsColor;\n    }\n    gl_FragDepthEXT = min(pointsDepth, trailsDepth);\n}\n";
	var updatePositionFrag = "\nuniform sampler2D currentParticlesPosition; // (lon, lat, lev)\nuniform sampler2D currentParticlesSpeed; // (u, v, w, normalization)\n\nvarying vec2 v_textureCoordinates;\n\nvec2 lengthOfLonLat(vec3 lonLatLev) {\n    // unit conversion: meters -> longitude latitude degrees\n    // see https://en.wikipedia.org/wiki/Geographic_coordinate_system#Length_of_a_degree for detail\n\n    // Calculate the length of a degree of latitude and longitude in meters\n    float latitude = radians(lonLatLev.y);\n\n    float term1 = 111132.92;\n    float term2 = 559.82 * cos(2.0 * latitude);\n    float term3 = 1.175 * cos(4.0 * latitude);\n    float term4 = 0.0023 * cos(6.0 * latitude);\n    float latLength = term1 - term2 + term3 - term4;\n\n    float term5 = 111412.84 * cos(latitude);\n    float term6 = 93.5 * cos(3.0 * latitude);\n    float term7 = 0.118 * cos(5.0 * latitude);\n    float longLength = term5 - term6 + term7;\n\n    return vec2(longLength, latLength);\n}\n\nvoid updatePosition(vec3 lonLatLev, vec3 speed) {\n    vec2 lonlatLengthgth = lengthOfLonLat(lonLatLev);\n    float u = speed.x / lonlatLengthgth.x;\n    float v = speed.y / lonlatLengthgth.y;\n    float w = 0.0;\n    vec3 windVectorInLonLatLev = vec3(u, v, w);\n\n    vec3 nextParticle = lonLatLev + windVectorInLonLatLev;\n\n    gl_FragColor = vec4(nextParticle, 0.0);\n}\n\nvoid main() {\n    // texture coordinate must be normalized\n    vec3 lonLatLev = texture2D(currentParticlesPosition, v_textureCoordinates).rgb;\n    vec3 speed = texture2D(currentParticlesSpeed, v_textureCoordinates).rgb;\n\n    updatePosition(lonLatLev, speed);\n}\n";
	var updateSpeedFrag = "\nuniform sampler2D currentParticlesSpeed; // (u, v, w, normalization)\nuniform sampler2D particlesWind;\n\n// use to calculate the relative speed\nuniform vec2 uSpeedRange; // (min, max);\nuniform vec2 vSpeedRange;\nuniform float pixelSize;\nuniform float speedFactor;\n\nvarying vec2 v_textureCoordinates;\n\nvec4 calcRelativeSpeed(vec3 speed) {\n    vec3 percent = vec3(0.0);\n    percent.x = (speed.x - uSpeedRange.x) / (uSpeedRange.y - uSpeedRange.x);\n    percent.y = (speed.y - vSpeedRange.x) / (vSpeedRange.y - vSpeedRange.x);\n    float normalization = length(percent);\n\n    float minRelativeSpeed = -speedFactor * pixelSize;\n    float maxRelativeSpeed = speedFactor * pixelSize;\n\n    vec3 relativeSpeed = vec3(0.0);\n    relativeSpeed.x = mix(minRelativeSpeed, maxRelativeSpeed, percent.x);\n    relativeSpeed.y = mix(minRelativeSpeed, maxRelativeSpeed, percent.y);\n\n    return vec4(relativeSpeed, normalization);\n}\n\nvoid main() {\n    // texture coordinate must be normalized\n    vec3 currentSpeed = texture2D(currentParticlesSpeed, v_textureCoordinates).rgb;\n    vec3 windVector = texture2D(particlesWind, v_textureCoordinates).rgb;\n\n    vec4 nextSpeed = calcRelativeSpeed(windVector);\n    gl_FragColor = nextSpeed;\n}\n";

	var ParticlesComputing =
	/*#__PURE__*/
	function () {
	  function ParticlesComputing(context, data, particleSystemOptions, viewerParameters) {
	    _classCallCheck(this, ParticlesComputing);

	    this.data = data;
	    this.createWindTextures(context, data);
	    this.createParticlesTextures(context, particleSystemOptions, viewerParameters);
	    this.createComputingPrimitives(data, particleSystemOptions, viewerParameters);
	  }

	  _createClass(ParticlesComputing, [{
	    key: "createWindTextures",
	    value: function createWindTextures(context, data) {
	      var windTextureOptions = {
	        context: context,
	        width: data.dimensions.lon,
	        height: data.dimensions.lat * data.dimensions.lev,
	        pixelFormat: Cesium.PixelFormat.LUMINANCE,
	        pixelDatatype: Cesium.PixelDatatype.FLOAT,
	        flipY: false,
	        sampler: new Cesium.Sampler({
	          // the values of texture will not be interpolated
	          minificationFilter: Cesium.TextureMinificationFilter.NEAREST,
	          magnificationFilter: Cesium.TextureMagnificationFilter.NEAREST
	        })
	      };
	      this.windTextures = {
	        U: Util$1.createTexture(windTextureOptions, data.U.array),
	        V: Util$1.createTexture(windTextureOptions, data.V.array)
	      };
	    }
	  }, {
	    key: "randomizeParticles",
	    value: function randomizeParticles(maxParticles, viewerParameters) {
	      var array = new Float32Array(4 * maxParticles);

	      for (var i = 0; i < maxParticles; i++) {
	        array[4 * i] = Cesium.Math.randomBetween(viewerParameters.lonRange.x, viewerParameters.lonRange.y);
	        array[4 * i + 1] = Cesium.Math.randomBetween(viewerParameters.latRange.x, viewerParameters.latRange.y);
	        array[4 * i + 2] = Cesium.Math.randomBetween(this.data.lev.min, this.data.lev.max);
	        array[4 * i + 3] = 0.0;
	      }

	      return array;
	    }
	  }, {
	    key: "createParticlesTextures",
	    value: function createParticlesTextures(context, particleSystemOptions, viewerParameters) {
	      var particlesTextureOptions = {
	        context: context,
	        width: particleSystemOptions.particlesTextureSize,
	        height: particleSystemOptions.particlesTextureSize,
	        pixelFormat: Cesium.PixelFormat.RGBA,
	        pixelDatatype: Cesium.PixelDatatype.FLOAT,
	        flipY: false,
	        sampler: new Cesium.Sampler({
	          // the values of texture will not be interpolated
	          minificationFilter: Cesium.TextureMinificationFilter.NEAREST,
	          magnificationFilter: Cesium.TextureMagnificationFilter.NEAREST
	        })
	      };
	      var particlesArray = this.randomizeParticles(particleSystemOptions.maxParticles, viewerParameters);
	      this.particlesTextures = {
	        particlesWind: Util$1.createTexture(particlesTextureOptions),
	        currentParticlesPosition: Util$1.createTexture(particlesTextureOptions, particlesArray),
	        nextParticlesPosition: Util$1.createTexture(particlesTextureOptions, particlesArray),
	        currentParticlesSpeed: Util$1.createTexture(particlesTextureOptions),
	        nextParticlesSpeed: Util$1.createTexture(particlesTextureOptions),
	        postProcessingPosition: Util$1.createTexture(particlesTextureOptions, particlesArray),
	        postProcessingSpeed: Util$1.createTexture(particlesTextureOptions)
	      };
	    }
	  }, {
	    key: "destroyParticlesTextures",
	    value: function destroyParticlesTextures() {
	      var _this = this;

	      keys$1(this.particlesTextures).forEach(function (key) {
	        _this.particlesTextures[key].destroy();
	      });
	    }
	  }, {
	    key: "createComputingPrimitives",
	    value: function createComputingPrimitives(data, particleSystemOptions, viewerParameters) {
	      var _dimension = new Cesium.Cartesian3(data.dimensions.lon, data.dimensions.lat, data.dimensions.lev);

	      var _minimum = new Cesium.Cartesian3(data.lon.min, data.lat.min, data.lev.min);

	      var _maximum = new Cesium.Cartesian3(data.lon.max, data.lat.max, data.lev.max);

	      var _interval = new Cesium.Cartesian3((_maximum.x - _minimum.x) / (_dimension.x - 1), (_maximum.y - _minimum.y) / (_dimension.y - 1), _dimension.z > 1 ? (_maximum.z - _minimum.z) / (_dimension.z - 1) : 1.0);

	      var _uSpeedRange = new Cesium.Cartesian2(data.U.min, data.U.max);

	      var _vSpeedRange = new Cesium.Cartesian2(data.V.min, data.V.max);

	      var that = this;
	      this.primitives = {
	        getWind: new CustomPrimitive({
	          commandType: 'Compute',
	          uniformMap: {
	            U: function U() {
	              return that.windTextures.U;
	            },
	            V: function V() {
	              return that.windTextures.V;
	            },
	            currentParticlesPosition: function currentParticlesPosition() {
	              return that.particlesTextures.currentParticlesPosition;
	            },
	            dimension: function dimension() {
	              return _dimension;
	            },
	            minimum: function minimum() {
	              return _minimum;
	            },
	            maximum: function maximum() {
	              return _maximum;
	            },
	            interval: function interval() {
	              return _interval;
	            }
	          },
	          fragmentShaderSource: new Cesium.ShaderSource({
	            sources: [getWindFrag]
	          }),
	          outputTexture: this.particlesTextures.particlesWind,
	          preExecute: function preExecute() {
	            // keep the outputTexture up to date
	            that.primitives.getWind.commandToExecute.outputTexture = that.particlesTextures.particlesWind;
	          }
	        }),
	        updateSpeed: new CustomPrimitive({
	          commandType: 'Compute',
	          uniformMap: {
	            currentParticlesSpeed: function currentParticlesSpeed() {
	              return that.particlesTextures.currentParticlesSpeed;
	            },
	            particlesWind: function particlesWind() {
	              return that.particlesTextures.particlesWind;
	            },
	            uSpeedRange: function uSpeedRange() {
	              return _uSpeedRange;
	            },
	            vSpeedRange: function vSpeedRange() {
	              return _vSpeedRange;
	            },
	            pixelSize: function pixelSize() {
	              return viewerParameters.pixelSize;
	            },
	            speedFactor: function speedFactor() {
	              return particleSystemOptions.speedFactor;
	            }
	          },
	          fragmentShaderSource: new Cesium.ShaderSource({
	            sources: [updateSpeedFrag]
	          }),
	          outputTexture: this.particlesTextures.nextParticlesSpeed,
	          preExecute: function preExecute() {
	            // swap textures before binding
	            var temp = that.particlesTextures.currentParticlesSpeed;
	            that.particlesTextures.currentParticlesSpeed = that.particlesTextures.postProcessingSpeed;
	            that.particlesTextures.postProcessingSpeed = temp; // keep the outputTexture up to date

	            that.primitives.updateSpeed.commandToExecute.outputTexture = that.particlesTextures.nextParticlesSpeed;
	          }
	        }),
	        updatePosition: new CustomPrimitive({
	          commandType: 'Compute',
	          uniformMap: {
	            currentParticlesPosition: function currentParticlesPosition() {
	              return that.particlesTextures.currentParticlesPosition;
	            },
	            currentParticlesSpeed: function currentParticlesSpeed() {
	              return that.particlesTextures.currentParticlesSpeed;
	            }
	          },
	          fragmentShaderSource: new Cesium.ShaderSource({
	            sources: [updatePositionFrag]
	          }),
	          outputTexture: this.particlesTextures.nextParticlesPosition,
	          preExecute: function preExecute() {
	            // swap textures before binding
	            var temp = that.particlesTextures.currentParticlesPosition;
	            that.particlesTextures.currentParticlesPosition = that.particlesTextures.postProcessingPosition;
	            that.particlesTextures.postProcessingPosition = temp; // keep the outputTexture up to date

	            that.primitives.updatePosition.commandToExecute.outputTexture = that.particlesTextures.nextParticlesPosition;
	          }
	        }),
	        postProcessingPosition: new CustomPrimitive({
	          commandType: 'Compute',
	          uniformMap: {
	            nextParticlesPosition: function nextParticlesPosition() {
	              return that.particlesTextures.nextParticlesPosition;
	            },
	            nextParticlesSpeed: function nextParticlesSpeed() {
	              return that.particlesTextures.nextParticlesSpeed;
	            },
	            lonRange: function lonRange() {
	              return viewerParameters.lonRange;
	            },
	            latRange: function latRange() {
	              return viewerParameters.latRange;
	            },
	            lonDataRange: function lonDataRange() {
	              return viewerParameters.lonDataRange;
	            },
	            latDataRange: function latDataRange() {
	              return viewerParameters.latDataRange;
	            },
	            randomCoef: function randomCoef() {
	              var randomCoef = Math.random();
	              return randomCoef;
	            },
	            dropRate: function dropRate() {
	              return particleSystemOptions.dropRate;
	            },
	            dropRateBump: function dropRateBump() {
	              return particleSystemOptions.dropRateBump;
	            }
	          },
	          fragmentShaderSource: new Cesium.ShaderSource({
	            sources: [postProcessingPositionFrag]
	          }),
	          outputTexture: this.particlesTextures.postProcessingPosition,
	          preExecute: function preExecute() {
	            // keep the outputTexture up to date
	            that.primitives.postProcessingPosition.commandToExecute.outputTexture = that.particlesTextures.postProcessingPosition;
	          }
	        }),
	        postProcessingSpeed: new CustomPrimitive({
	          commandType: 'Compute',
	          uniformMap: {
	            postProcessingPosition: function postProcessingPosition() {
	              return that.particlesTextures.postProcessingPosition;
	            },
	            nextParticlesSpeed: function nextParticlesSpeed() {
	              return that.particlesTextures.nextParticlesSpeed;
	            }
	          },
	          fragmentShaderSource: new Cesium.ShaderSource({
	            sources: [postProcessingSpeedFrag]
	          }),
	          outputTexture: this.particlesTextures.postProcessingSpeed,
	          preExecute: function preExecute() {
	            // keep the outputTexture up to date
	            that.primitives.postProcessingSpeed.commandToExecute.outputTexture = that.particlesTextures.postProcessingSpeed;
	          }
	        })
	      };
	    }
	  }]);

	  return ParticlesComputing;
	}();

	var ParticlesRendering =
	/*#__PURE__*/
	function () {
	  function ParticlesRendering(context, data, particleSystemOptions, viewerParameters, particlesComputing) {
	    _classCallCheck(this, ParticlesRendering);

	    this.createRenderingTextures(context, data);
	    this.createRenderingFramebuffers(context);
	    this.createRenderingPrimitives(context, particleSystemOptions, viewerParameters, particlesComputing);
	  }

	  _createClass(ParticlesRendering, [{
	    key: "createRenderingTextures",
	    value: function createRenderingTextures(context, data) {
	      var colorTextureOptions = {
	        context: context,
	        width: context.drawingBufferWidth,
	        height: context.drawingBufferHeight,
	        pixelFormat: Cesium.PixelFormat.RGBA,
	        pixelDatatype: Cesium.PixelDatatype.UNSIGNED_BYTE
	      };
	      var depthTextureOptions = {
	        context: context,
	        width: context.drawingBufferWidth,
	        height: context.drawingBufferHeight,
	        pixelFormat: Cesium.PixelFormat.DEPTH_COMPONENT,
	        pixelDatatype: Cesium.PixelDatatype.UNSIGNED_INT
	      };
	      var colorTableTextureOptions = {
	        context: context,
	        width: data.colorTable.colorNum,
	        height: 1,
	        pixelFormat: Cesium.PixelFormat.RGB,
	        pixelDatatype: Cesium.PixelDatatype.FLOAT,
	        sampler: new Cesium.Sampler({
	          minificationFilter: Cesium.TextureMinificationFilter.LINEAR,
	          magnificationFilter: Cesium.TextureMagnificationFilter.LINEAR
	        })
	      };
	      this.textures = {
	        segmentsColor: Util$1.createTexture(colorTextureOptions),
	        segmentsDepth: Util$1.createTexture(depthTextureOptions),
	        currentTrailsColor: Util$1.createTexture(colorTextureOptions),
	        currentTrailsDepth: Util$1.createTexture(depthTextureOptions),
	        nextTrailsColor: Util$1.createTexture(colorTextureOptions),
	        nextTrailsDepth: Util$1.createTexture(depthTextureOptions),
	        colorTable: Util$1.createTexture(colorTableTextureOptions, data.colorTable.array)
	      };
	    }
	  }, {
	    key: "createRenderingFramebuffers",
	    value: function createRenderingFramebuffers(context) {
	      this.framebuffers = {
	        segments: Util$1.createFramebuffer(context, this.textures.segmentsColor, this.textures.segmentsDepth),
	        currentTrails: Util$1.createFramebuffer(context, this.textures.currentTrailsColor, this.textures.currentTrailsDepth),
	        nextTrails: Util$1.createFramebuffer(context, this.textures.nextTrailsColor, this.textures.nextTrailsDepth)
	      };
	    }
	  }, {
	    key: "createSegmentsGeometry",
	    value: function createSegmentsGeometry(particleSystemOptions) {
	      var repeatVertex = 4;
	      var st = [];

	      for (var s = 0; s < particleSystemOptions.particlesTextureSize; s++) {
	        for (var t = 0; t < particleSystemOptions.particlesTextureSize; t++) {
	          for (var i = 0; i < repeatVertex; i++) {
	            st.push(s / particleSystemOptions.particlesTextureSize);
	            st.push(t / particleSystemOptions.particlesTextureSize);
	          }
	        }
	      }

	      st = new Float32Array(st);
	      var normal = [];
	      var pointToUse = [-1, 1];
	      var offsetSign = [-1, 1];

	      for (var _i = 0; _i < particleSystemOptions.maxParticles; _i++) {
	        for (var j = 0; j < repeatVertex / 2; j++) {
	          for (var k = 0; k < repeatVertex / 2; k++) {
	            normal.push(pointToUse[j]);
	            normal.push(offsetSign[k]);
	            normal.push(0);
	          }
	        }
	      }

	      normal = new Float32Array(normal);
	      var indexSize = 6 * particleSystemOptions.maxParticles;
	      var vertexIndexes = new Uint32Array(indexSize);

	      for (var _i2 = 0, _j = 0, vertex = 0; _i2 < particleSystemOptions.maxParticles; _i2++) {
	        vertexIndexes[_j++] = vertex + 0;
	        vertexIndexes[_j++] = vertex + 1;
	        vertexIndexes[_j++] = vertex + 2;
	        vertexIndexes[_j++] = vertex + 2;
	        vertexIndexes[_j++] = vertex + 1;
	        vertexIndexes[_j++] = vertex + 3;
	        vertex += 4;
	      }

	      var geometry = new Cesium.Geometry({
	        attributes: new Cesium.GeometryAttributes({
	          st: new Cesium.GeometryAttribute({
	            componentDatatype: Cesium.ComponentDatatype.FLOAT,
	            componentsPerAttribute: 2,
	            values: st
	          }),
	          normal: new Cesium.GeometryAttribute({
	            componentDatatype: Cesium.ComponentDatatype.FLOAT,
	            componentsPerAttribute: 3,
	            values: normal
	          })
	        }),
	        indices: vertexIndexes
	      });
	      return geometry;
	    }
	  }, {
	    key: "createRenderingPrimitives",
	    value: function createRenderingPrimitives(context, particleSystemOptions, viewerParameters, particlesComputing) {
	      var that = this;
	      this.primitives = {
	        segments: new CustomPrimitive({
	          commandType: 'Draw',
	          attributeLocations: {
	            st: 0,
	            normal: 1
	          },
	          geometry: this.createSegmentsGeometry(particleSystemOptions),
	          primitiveType: Cesium.PrimitiveType.TRIANGLES,
	          uniformMap: {
	            currentParticlesPosition: function currentParticlesPosition() {
	              return particlesComputing.particlesTextures.currentParticlesPosition;
	            },
	            postProcessingPosition: function postProcessingPosition() {
	              return particlesComputing.particlesTextures.postProcessingPosition;
	            },
	            postProcessingSpeed: function postProcessingSpeed() {
	              return particlesComputing.particlesTextures.postProcessingSpeed;
	            },
	            colorTable: function colorTable() {
	              return that.textures.colorTable;
	            },
	            aspect: function aspect() {
	              return context.drawingBufferWidth / context.drawingBufferHeight;
	            },
	            pixelSize: function pixelSize() {
	              return viewerParameters.pixelSize;
	            },
	            lineWidth: function lineWidth() {
	              return particleSystemOptions.lineWidth;
	            },
	            particleHeight: function particleHeight() {
	              return particleSystemOptions.particleHeight;
	            }
	          },
	          vertexShaderSource: new Cesium.ShaderSource({
	            sources: [segmentDrawVert]
	          }),
	          fragmentShaderSource: new Cesium.ShaderSource({
	            sources: [segmentDrawFrag]
	          }),
	          rawRenderState: Util$1.createRawRenderState({
	            // undefined value means let Cesium deal with it
	            viewport: undefined,
	            depthTest: {
	              enabled: true
	            },
	            depthMask: true
	          }),
	          framebuffer: this.framebuffers.segments,
	          autoClear: true
	        }),
	        trails: new CustomPrimitive({
	          commandType: 'Draw',
	          attributeLocations: {
	            position: 0,
	            st: 1
	          },
	          geometry: Util$1.getFullscreenQuad(),
	          primitiveType: Cesium.PrimitiveType.TRIANGLES,
	          uniformMap: {
	            segmentsColorTexture: function segmentsColorTexture() {
	              return that.textures.segmentsColor;
	            },
	            segmentsDepthTexture: function segmentsDepthTexture() {
	              return that.textures.segmentsDepth;
	            },
	            currentTrailsColor: function currentTrailsColor() {
	              return that.framebuffers.currentTrails.getColorTexture(0);
	            },
	            trailsDepthTexture: function trailsDepthTexture() {
	              return that.framebuffers.currentTrails.depthTexture;
	            },
	            fadeOpacity: function fadeOpacity() {
	              return particleSystemOptions.fadeOpacity;
	            }
	          },
	          // prevent Cesium from writing depth because the depth here should be written manually
	          vertexShaderSource: new Cesium.ShaderSource({
	            defines: ['DISABLE_GL_POSITION_LOG_DEPTH'],
	            sources: [fullscreenVert]
	          }),
	          fragmentShaderSource: new Cesium.ShaderSource({
	            defines: ['DISABLE_LOG_DEPTH_FRAGMENT_WRITE'],
	            sources: [trailDrawFrag]
	          }),
	          rawRenderState: Util$1.createRawRenderState({
	            viewport: undefined,
	            depthTest: {
	              enabled: true,
	              func: Cesium.DepthFunction.ALWAYS // always pass depth test for full control of depth information

	            },
	            depthMask: true
	          }),
	          framebuffer: this.framebuffers.nextTrails,
	          autoClear: true,
	          preExecute: function preExecute() {
	            // swap framebuffers before binding
	            var temp = that.framebuffers.currentTrails;
	            that.framebuffers.currentTrails = that.framebuffers.nextTrails;
	            that.framebuffers.nextTrails = temp; // keep the framebuffers up to date

	            that.primitives.trails.commandToExecute.framebuffer = that.framebuffers.nextTrails;
	            that.primitives.trails.clearCommand.framebuffer = that.framebuffers.nextTrails;
	          }
	        }),
	        screen: new CustomPrimitive({
	          commandType: 'Draw',
	          attributeLocations: {
	            position: 0,
	            st: 1
	          },
	          geometry: Util$1.getFullscreenQuad(),
	          primitiveType: Cesium.PrimitiveType.TRIANGLES,
	          uniformMap: {
	            trailsColorTexture: function trailsColorTexture() {
	              return that.framebuffers.nextTrails.getColorTexture(0);
	            },
	            trailsDepthTexture: function trailsDepthTexture() {
	              return that.framebuffers.nextTrails.depthTexture;
	            }
	          },
	          // prevent Cesium from writing depth because the depth here should be written manually
	          vertexShaderSource: new Cesium.ShaderSource({
	            defines: ['DISABLE_GL_POSITION_LOG_DEPTH'],
	            sources: [fullscreenVert]
	          }),
	          fragmentShaderSource: new Cesium.ShaderSource({
	            defines: ['DISABLE_LOG_DEPTH_FRAGMENT_WRITE'],
	            sources: [screenDrawFrag]
	          }),
	          rawRenderState: Util$1.createRawRenderState({
	            viewport: undefined,
	            depthTest: {
	              enabled: false
	            },
	            depthMask: true,
	            blending: {
	              enabled: true
	            }
	          }),
	          framebuffer: undefined // undefined value means let Cesium deal with it

	        })
	      };
	    }
	  }]);

	  return ParticlesRendering;
	}();

	var ParticleSystem$2 =
	/*#__PURE__*/
	function () {
	  function ParticleSystem(context, data, particleSystemOptions, viewerParameters) {
	    _classCallCheck(this, ParticleSystem);

	    this.context = context;
	    this.data = data;
	    this.particleSystemOptions = particleSystemOptions;
	    this.viewerParameters = viewerParameters;
	    this.particlesComputing = new ParticlesComputing(this.context, this.data, this.particleSystemOptions, this.viewerParameters);
	    this.particlesRendering = new ParticlesRendering(this.context, this.data, this.particleSystemOptions, this.viewerParameters, this.particlesComputing);
	  }

	  _createClass(ParticleSystem, [{
	    key: "canvasResize",
	    value: function canvasResize(context) {
	      var _this = this;

	      this.particlesComputing.destroyParticlesTextures();

	      keys$1(this.particlesComputing.windTextures).forEach(function (key) {
	        _this.particlesComputing.windTextures[key].destroy();
	      });

	      this.particlesRendering.textures.colorTable.destroy();

	      keys$1(this.particlesRendering.framebuffers).forEach(function (key) {
	        _this.particlesRendering.framebuffers[key].destroy();
	      });

	      this.context = context;
	      this.particlesComputing = new ParticlesComputing(this.context, this.data, this.particleSystemOptions, this.viewerParameters);
	      this.particlesRendering = new ParticlesRendering(this.context, this.data, this.particleSystemOptions, this.viewerParameters, this.particlesComputing);
	    }
	  }, {
	    key: "clearFramebuffers",
	    value: function clearFramebuffers() {
	      var _this2 = this;

	      var clearCommand = new Cesium.ClearCommand({
	        color: new Cesium.Color(0.0, 0.0, 0.0, 0.0),
	        depth: 1.0,
	        framebuffer: undefined,
	        pass: Cesium.Pass.OPAQUE
	      });

	      keys$1(this.particlesRendering.framebuffers).forEach(function (key) {
	        clearCommand.framebuffer = _this2.particlesRendering.framebuffers[key];
	        clearCommand.execute(_this2.context);
	      });
	    }
	  }, {
	    key: "refreshParticles",
	    value: function refreshParticles(maxParticlesChanged) {
	      this.clearFramebuffers();
	      this.particlesComputing.destroyParticlesTextures();
	      this.particlesComputing.createParticlesTextures(this.context, this.particleSystemOptions, this.viewerParameters);

	      if (maxParticlesChanged) {
	        var geometry = this.particlesRendering.createSegmentsGeometry(this.particleSystemOptions);
	        this.particlesRendering.primitives.segments.geometry = geometry;
	        var vertexArray = Cesium.VertexArray.fromGeometry({
	          context: this.context,
	          geometry: geometry,
	          attributeLocations: this.particlesRendering.primitives.segments.attributeLocations,
	          bufferUsage: Cesium.BufferUsage.STATIC_DRAW
	        });
	        this.particlesRendering.primitives.segments.commandToExecute.vertexArray = vertexArray;
	      }
	    }
	  }, {
	    key: "applyParticleSystemOptions",
	    value: function applyParticleSystemOptions(particleSystemOptions) {
	      var _this3 = this;

	      var maxParticlesChanged = false;

	      if (this.particleSystemOptions.maxParticles !== particleSystemOptions.maxParticles) {
	        maxParticlesChanged = true;
	      }

	      keys$1(particleSystemOptions).forEach(function (key) {
	        _this3.particleSystemOptions[key] = particleSystemOptions[key];
	      });

	      this.refreshParticles(maxParticlesChanged);
	    }
	  }, {
	    key: "applyViewerParameters",
	    value: function applyViewerParameters(viewerParameters) {
	      var _this4 = this;

	      keys$1(viewerParameters).forEach(function (key) {
	        _this4.viewerParameters[key] = viewerParameters[key];
	      });

	      this.refreshParticles(false);
	    }
	  }]);

	  return ParticleSystem;
	}();

	var Wind3D =
	/*#__PURE__*/
	function () {
	  function Wind3D(viewer, data, particleSystemOptions) {
	    _classCallCheck(this, Wind3D);

	    this.viewer = viewer;
	    this.scene = this.viewer.scene;
	    this.camera = this.viewer.camera;
	    this.data = data;
	    this.viewerParameters = {
	      lonRange: new Cesium.Cartesian2(),
	      latRange: new Cesium.Cartesian2(),
	      pixelSize: 0.0,
	      lonDataRange: new Cesium.Cartesian2(),
	      latDataRange: new Cesium.Cartesian2()
	    }; // use a smaller earth radius to make sure distance to camera > 0

	    this.globeBoundingSphere = new Cesium.BoundingSphere(Cesium.Cartesian3.ZERO, 0.99 * 6378137.0);
	    this.updateViewerParameters();
	    this.particleSystem = new ParticleSystem$2(this.scene.context, data, particleSystemOptions, this.viewerParameters);
	    this.addPrimitives();
	    this.setupEventListeners();
	    this.imageryLayers = this.viewer.imageryLayers;
	  }

	  _createClass(Wind3D, [{
	    key: "addPrimitives",
	    value: function addPrimitives() {
	      // the order of primitives.add() should respect the dependency of primitives
	      this.scene.primitives.add(this.particleSystem.particlesComputing.primitives.getWind);
	      this.scene.primitives.add(this.particleSystem.particlesComputing.primitives.updateSpeed);
	      this.scene.primitives.add(this.particleSystem.particlesComputing.primitives.updatePosition);
	      this.scene.primitives.add(this.particleSystem.particlesComputing.primitives.postProcessingPosition);
	      this.scene.primitives.add(this.particleSystem.particlesComputing.primitives.postProcessingSpeed);
	      this.scene.primitives.add(this.particleSystem.particlesRendering.primitives.segments);
	      this.scene.primitives.add(this.particleSystem.particlesRendering.primitives.trails);
	      this.scene.primitives.add(this.particleSystem.particlesRendering.primitives.screen);
	    }
	  }, {
	    key: "removePrimitives",
	    value: function removePrimitives() {
	      this.scene.primitives.remove(this.particleSystem.particlesRendering.primitives.screen);
	      this.scene.primitives.remove(this.particleSystem.particlesRendering.primitives.trails);
	      this.scene.primitives.remove(this.particleSystem.particlesRendering.primitives.segments);
	      this.scene.primitives.remove(this.particleSystem.particlesComputing.primitives.postProcessingSpeed);
	      this.scene.primitives.remove(this.particleSystem.particlesComputing.primitives.postProcessingPosition);
	      this.scene.primitives.remove(this.particleSystem.particlesComputing.primitives.updatePosition);
	      this.scene.primitives.remove(this.particleSystem.particlesComputing.primitives.updateSpeed);
	      this.scene.primitives.remove(this.particleSystem.particlesComputing.primitives.getWind);
	    }
	  }, {
	    key: "updateViewerParameters",
	    value: function updateViewerParameters() {
	      var viewRectangle = this.camera.computeViewRectangle(this.scene.globe.ellipsoid);
	      var lonLatRange = Util$1.viewRectangleToLonLatRange(viewRectangle);
	      this.viewerParameters.lonRange.x = lonLatRange.lon.min;
	      this.viewerParameters.lonRange.y = lonLatRange.lon.max;
	      this.viewerParameters.latRange.x = lonLatRange.lat.min;
	      this.viewerParameters.latRange.y = lonLatRange.lat.max;
	      this.viewerParameters.lonDataRange.x = this.data.lon.min;
	      this.viewerParameters.lonDataRange.y = this.data.lon.max;
	      this.viewerParameters.latDataRange.x = this.data.lat.min;
	      this.viewerParameters.latDataRange.y = this.data.lat.max;
	      var pixelSize = this.camera.getPixelSize(this.globeBoundingSphere, this.scene.drawingBufferWidth, this.scene.drawingBufferHeight);

	      if (pixelSize > 0) {
	        this.viewerParameters.pixelSize = pixelSize;
	      }
	    }
	  }, {
	    key: "moveStartListener",
	    value: function moveStartListener() {
	      this.scene.primitives.show = false;
	    }
	  }, {
	    key: "moveEndListener",
	    value: function moveEndListener() {
	      this.updateViewerParameters();
	      this.particleSystem.applyViewerParameters(this.viewerParameters);
	      this.scene.primitives.show = true;
	    }
	  }, {
	    key: "preRenderListener",
	    value: function preRenderListener() {
	      if (this.resized) {
	        this.particleSystem.canvasResize(this.scene.context);
	        this.resized = false;
	        this.addPrimitives();
	        this.scene.primitives.show = true;
	      }
	    }
	  }, {
	    key: "setupEventListeners",
	    value: function setupEventListeners() {
	      var that = this;
	      this.camera.moveStart.addEventListener(this.moveStartListener, this);
	      this.camera.moveEnd.addEventListener(this.moveEndListener, this);
	      this.resized = false;
	      window.addEventListener('resize', function () {
	        that.resized = true;
	        that.scene.primitives.show = false;
	        that.scene.primitives.removeAll();
	      });
	      this.scene.preRender.addEventListener(this.preRenderListener, this);
	    }
	  }, {
	    key: "destroy",
	    value: function destroy() {
	      this.removePrimitives();
	      this.camera.moveStart.removeEventListener(this.moveStartListener, this);
	      this.camera.moveEnd.removeEventListener(this.moveEndListener, this);
	      this.scene.preRender.removeEventListener(this.preRenderListener, this);
	    }
	  }]);

	  return Wind3D;
	}();

	var script$1R = {
	  name: 'vc-windmap',
	  mixins: [cmp],
	  props: {
	    data: Object,
	    colorTable: {
	      type: Object,
	      default: function _default() {
	        return colorTable;
	      }
	    },
	    particleSystemOptions: {
	      type: Object,
	      default: function _default() {
	        return {
	          particlesTextureSize: 128,
	          maxParticles: 128 * 128,
	          particleHeight: 100.0,
	          fadeOpacity: 0.996,
	          dropRate: 0.003,
	          dropRateBump: 0.01,
	          speedFactor: 4.0,
	          lineWidth: 4.0
	        };
	      }
	    }
	  },
	  watch: {
	    data: function data(val) {
	      this.reload();
	    },
	    particleSystemOptions: {
	      handler: function handler(val) {
	        this.windMap.particleSystem.applyParticleSystemOptions(val);
	      },
	      deep: true
	    }
	  },
	  methods: {
	    createCesiumObject: function createCesiumObject() {
	      var viewer, particleSystemOptions, windMap;
	      return regenerator.async(function createCesiumObject$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              viewer = this.viewer, particleSystemOptions = this.particleSystemOptions;

	              if (this.isEmptyObj(this.data)) {
	                _context.next = 5;
	                break;
	              }

	              this.data.colorTable = this.loadColorTable();
	              windMap = new Wind3D(viewer, this.data, particleSystemOptions);
	              return _context.abrupt("return", windMap);

	            case 5:
	              return _context.abrupt("return", true);

	            case 6:
	            case "end":
	              return _context.stop();
	          }
	        }
	      }, null, this);
	    },
	    loadColorTable: function loadColorTable() {
	      var json = this.colorTable;
	      var colorNum = json.ncolors;
	      var colorTable = json.colorTable;
	      var colorsArray = new Float32Array(3 * colorNum);

	      for (var i = 0; i < colorNum; i++) {
	        colorsArray[3 * i] = colorTable[3 * i];
	        colorsArray[3 * i + 1] = colorTable[3 * i + 1];
	        colorsArray[3 * i + 2] = colorTable[3 * i + 2];
	      }

	      var result = {};
	      result.colorNum = colorNum;
	      result.array = colorsArray;
	      return result;
	    },
	    mount: function mount() {
	      return regenerator.async(function mount$(_context2) {
	        while (1) {
	          switch (_context2.prev = _context2.next) {
	            case 0:
	              return _context2.abrupt("return", true);

	            case 1:
	            case "end":
	              return _context2.stop();
	          }
	        }
	      });
	    },
	    unmount: function unmount() {
	      return regenerator.async(function unmount$(_context3) {
	        while (1) {
	          switch (_context3.prev = _context3.next) {
	            case 0:
	              if (!this.isEmptyObj(this.windMap)) {
	                this.windMap.destroy();
	              }

	              return _context3.abrupt("return", true);

	            case 2:
	            case "end":
	              return _context3.stop();
	          }
	        }
	      }, null, this);
	    }
	  },
	  stubVNode: {
	    empty: function empty() {
	      return this.$options.name;
	    }
	  },
	  created: function created() {
	    var _this = this;

	    defineProperties$1(this, {
	      windMap: {
	        enumerable: true,
	        get: function get() {
	          return _this.$services && _this.cesiumObject;
	        }
	      }
	    });
	  }
	};

	/* script */
	var __vue_script__$1R = script$1R;
	/* template */

	/* style */

	var __vue_inject_styles__$1R = undefined;
	/* scoped */

	var __vue_scope_id__$1R = undefined;
	/* functional template */

	var __vue_is_functional_template__$1R = undefined;
	/* component normalizer */

	function __vue_normalize__$1R(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "VcWindMap.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var VcWindMap = __vue_normalize__$1R({}, __vue_inject_styles__$1R, __vue_script__$1R, __vue_scope_id__$1R, __vue_is_functional_template__$1R);

	function plugin$1H(Vue) {

	  if (plugin$1H.installed) {
	    return;
	  }

	  plugin$1H.installed = true;
	  Vue.component(VcWindMap.name, VcWindMap);
	}

	var VcWindMap$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$1H,
		VcWindMap: VcWindMap,
		install: plugin$1H
	});

	var script$1S = {
	  name: 'vc-scan-circle',
	  mixins: [cmp, position, color],
	  props: {
	    radius: {
	      type: Number,
	      default: 1500
	    },
	    interval: {
	      type: Number,
	      default: 3000
	    }
	  },
	  mounted: function mounted() {
	    var _this = this;

	    this.getParent(this.$parent).createPromise.then(function (_ref) {
	      var Cesium = _ref.Cesium,
	          viewer = _ref.viewer;
	      var $props = _this.$props,
	          transformProps = _this.transformProps;
	      var options = transformProps($props);
	      var cartographicCenter = Cesium.Cartographic.fromCartesian(options.position);

	      var _Cartesian3Center = Cesium.Cartographic.toCartesian(cartographicCenter);

	      var _Cartesian4Center = new Cesium.Cartesian4(_Cartesian3Center.x, _Cartesian3Center.y, _Cartesian3Center.z, 1);

	      var _CartographicCenter1 = new Cesium.Cartographic(cartographicCenter.longitude, cartographicCenter.latitude, cartographicCenter.height + 500);

	      var _Cartesian3Center1 = Cesium.Cartographic.toCartesian(_CartographicCenter1);

	      var _Cartesian4Center1 = new Cesium.Cartesian4(_Cartesian3Center1.x, _Cartesian3Center1.y, _Cartesian3Center1.z, 1);

	      var _time = new Date().getTime();

	      var _scratchCartesian4Center = new Cesium.Cartesian4();

	      var _scratchCartesian4Center1 = new Cesium.Cartesian4();

	      var _scratchCartesian3Normal = new Cesium.Cartesian3();

	      _this.uniforms = {
	        u_scanCenterEC: function u_scanCenterEC() {
	          return Cesium.Matrix4.multiplyByVector(viewer.camera._viewMatrix, _Cartesian4Center, _scratchCartesian4Center);
	        },
	        u_scanPlaneNormalEC: function u_scanPlaneNormalEC() {
	          var temp = Cesium.Matrix4.multiplyByVector(viewer.camera._viewMatrix, _Cartesian4Center, _scratchCartesian4Center);
	          var temp1 = Cesium.Matrix4.multiplyByVector(viewer.camera._viewMatrix, _Cartesian4Center1, _scratchCartesian4Center1);
	          _scratchCartesian3Normal.x = temp1.x - temp.x;
	          _scratchCartesian3Normal.y = temp1.y - temp.y;
	          _scratchCartesian3Normal.z = temp1.z - temp.z;
	          Cesium.Cartesian3.normalize(_scratchCartesian3Normal, _scratchCartesian3Normal);
	          return _scratchCartesian3Normal;
	        },
	        u_radius: function u_radius() {
	          return options.radius * ((new Date().getTime() - _time) % options.interval) / options.interval;
	        },
	        u_scanColor: options.color
	      };
	    });
	  },
	  methods: {
	    createCesiumObject: function createCesiumObject() {
	      var _this2 = this;

	      return regenerator.async(function createCesiumObject$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              return _context.abrupt("return", this.$refs.stage.createPromise.then(function (_ref2) {
	                var Cesium = _ref2.Cesium,
	                    viewer = _ref2.viewer,
	                    cesiumObject = _ref2.cesiumObject;

	                if (!_this2.$refs.stage._mounted) {
	                  return _this2.$refs.stage.load().then(function (_ref3) {
	                    var Cesium = _ref3.Cesium,
	                        viewer = _ref3.viewer,
	                        cesiumObject = _ref3.cesiumObject;
	                    return cesiumObject;
	                  });
	                } else {
	                  return cesiumObject;
	                }
	              }));

	            case 1:
	            case "end":
	              return _context.stop();
	          }
	        }
	      }, null, this);
	    },
	    mount: function mount() {
	      return regenerator.async(function mount$(_context2) {
	        while (1) {
	          switch (_context2.prev = _context2.next) {
	            case 0:
	              return _context2.abrupt("return", true);

	            case 1:
	            case "end":
	              return _context2.stop();
	          }
	        }
	      });
	    },
	    unmount: function unmount() {
	      return regenerator.async(function unmount$(_context3) {
	        while (1) {
	          switch (_context3.prev = _context3.next) {
	            case 0:
	              return _context3.abrupt("return", this.$refs.stage && this.$refs.stage.unload());

	            case 1:
	            case "end":
	              return _context3.stop();
	          }
	        }
	      }, null, this);
	    }
	  },
	  created: function created() {
	    var _this3 = this;

	    defineProperties$1(this, {
	      postProcessStage: {
	        enumerable: true,
	        get: function get() {
	          return _this3.cesiumObject;
	        }
	      }
	    });
	  },
	  data: function data() {
	    return {
	      nowaiting: true,
	      fsScanSegment: "\n        uniform sampler2D colorTexture;\n        uniform sampler2D depthTexture;\n        varying vec2 v_textureCoordinates;\n        uniform vec4 u_scanCenterEC;\n        uniform vec3 u_scanPlaneNormalEC;\n        uniform float u_radius;\n        uniform vec4 u_scanColor;\n        vec4 toEye(in vec2 uv, in float depth)\n        {\n          vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0));\n          vec4 posInCamera =czm_inverseProjection * vec4(xy, depth, 1.0);\n          posInCamera =posInCamera / posInCamera.w;\n          return posInCamera;\n        }\n        vec3 pointProjectOnPlane(in vec3 planeNormal, in vec3 planeOrigin, in vec3 point)\n        {\n          vec3 v01 = point -planeOrigin;\n          float d = dot(planeNormal, v01) ;\n          return (point - planeNormal * d);\n        }\n        float getDepth(in vec4 depth)\n        {\n          float z_window = czm_unpackDepth(depth);\n          z_window = czm_reverseLogDepth(z_window);\n          float n_range = czm_depthRange.near;\n          float f_range = czm_depthRange.far;\n          return (2.0 * z_window - n_range - f_range) / (f_range - n_range);\n        }\n        void main()\n        {\n          gl_FragColor = texture2D(colorTexture, v_textureCoordinates);\n          float depth = getDepth( texture2D(depthTexture, v_textureCoordinates));\n          vec4 viewPos = toEye(v_textureCoordinates, depth);\n          vec3 prjOnPlane = pointProjectOnPlane(u_scanPlaneNormalEC.xyz, u_scanCenterEC.xyz, viewPos.xyz);\n          float dis = length(prjOnPlane.xyz - u_scanCenterEC.xyz);\n          if(dis < u_radius)\n          {\n            float f = 1.0 -abs(u_radius - dis) / u_radius;\n            f = pow(f, 4.0);\n            gl_FragColor = mix(gl_FragColor, u_scanColor, f);\n          }\n        }",
	      uniforms: {}
	    };
	  }
	};

	/* script */
	var __vue_script__$1S = script$1S;
	/* template */

	var __vue_render__$o = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('i', {
	    class: _vm.$options.name,
	    staticStyle: {
	      "display": "none !important"
	    }
	  }, [_c('vc-stage-process-post', {
	    ref: "stage",
	    attrs: {
	      "fragmentShader": _vm.fsScanSegment,
	      "uniforms": _vm.uniforms
	    }
	  })], 1);
	};

	var __vue_staticRenderFns__$o = [];
	/* style */

	var __vue_inject_styles__$1S = undefined;
	/* scoped */

	var __vue_scope_id__$1S = undefined;
	/* functional template */

	var __vue_is_functional_template__$1S = false;
	/* component normalizer */

	function __vue_normalize__$1S(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "VcScanCircle.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var VcScanCircle = __vue_normalize__$1S({
	  render: __vue_render__$o,
	  staticRenderFns: __vue_staticRenderFns__$o
	}, __vue_inject_styles__$1S, __vue_script__$1S, __vue_scope_id__$1S, __vue_is_functional_template__$1S);

	function plugin$1I(Vue) {

	  if (plugin$1I.installed) {
	    return;
	  }

	  plugin$1I.installed = true;
	  Vue.use(PostProcessStage$1);
	  Vue.component(VcScanCircle.name, VcScanCircle);
	}

	var VcScanCircle$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$1I,
		VcScanCircle: VcScanCircle,
		install: plugin$1I
	});

	var script$1T = {
	  name: 'vc-scan-radar',
	  mixins: [cmp, position, color],
	  props: {
	    radius: {
	      type: Number,
	      default: 1500
	    },
	    interval: {
	      type: Number,
	      default: 3000
	    }
	  },
	  mounted: function mounted() {
	    var _this = this;

	    this.getParent(this.$parent).createPromise.then(function (_ref) {
	      var Cesium = _ref.Cesium,
	          viewer = _ref.viewer;
	      var $props = _this.$props,
	          transformProps = _this.transformProps;
	      var options = transformProps($props);
	      var cartographicCenter = Cesium.Cartographic.fromCartesian(options.position);

	      var _Cartesian3Center = Cesium.Cartographic.toCartesian(cartographicCenter);

	      var _Cartesian4Center = new Cesium.Cartesian4(_Cartesian3Center.x, _Cartesian3Center.y, _Cartesian3Center.z, 1);

	      var _CartographicCenter1 = new Cesium.Cartographic(cartographicCenter.longitude, cartographicCenter.latitude, cartographicCenter.height + 500);

	      var _Cartesian3Center1 = Cesium.Cartographic.toCartesian(_CartographicCenter1);

	      var _Cartesian4Center1 = new Cesium.Cartesian4(_Cartesian3Center1.x, _Cartesian3Center1.y, _Cartesian3Center1.z, 1);

	      var _CartographicCenter2 = new Cesium.Cartographic(cartographicCenter.longitude + Cesium.Math.toRadians(0.001), cartographicCenter.latitude, cartographicCenter.height);

	      var _Cartesian3Center2 = Cesium.Cartographic.toCartesian(_CartographicCenter2);

	      var _Cartesian4Center2 = new Cesium.Cartesian4(_Cartesian3Center2.x, _Cartesian3Center2.y, _Cartesian3Center2.z, 1);

	      var _RotateQ = new Cesium.Quaternion();

	      var _RotateM = new Cesium.Matrix3();

	      var _time = new Date().getTime();

	      var _scratchCartesian4Center = new Cesium.Cartesian4();

	      var _scratchCartesian4Center1 = new Cesium.Cartesian4();

	      var _scratchCartesian4Center2 = new Cesium.Cartesian4();

	      var _scratchCartesian3Normal = new Cesium.Cartesian3();

	      var _scratchCartesian3Normal1 = new Cesium.Cartesian3();

	      _this.uniforms = {
	        u_scanCenterEC: function u_scanCenterEC() {
	          return Cesium.Matrix4.multiplyByVector(viewer.camera._viewMatrix, _Cartesian4Center, _scratchCartesian4Center);
	        },
	        u_scanPlaneNormalEC: function u_scanPlaneNormalEC() {
	          var temp = Cesium.Matrix4.multiplyByVector(viewer.camera._viewMatrix, _Cartesian4Center, _scratchCartesian4Center);
	          var temp1 = Cesium.Matrix4.multiplyByVector(viewer.camera._viewMatrix, _Cartesian4Center1, _scratchCartesian4Center1);
	          _scratchCartesian3Normal.x = temp1.x - temp.x;
	          _scratchCartesian3Normal.y = temp1.y - temp.y;
	          _scratchCartesian3Normal.z = temp1.z - temp.z;
	          Cesium.Cartesian3.normalize(_scratchCartesian3Normal, _scratchCartesian3Normal);
	          return _scratchCartesian3Normal;
	        },
	        u_radius: options.radius,
	        u_scanLineNormalEC: function u_scanLineNormalEC() {
	          var temp = Cesium.Matrix4.multiplyByVector(viewer.camera._viewMatrix, _Cartesian4Center, _scratchCartesian4Center);
	          var temp1 = Cesium.Matrix4.multiplyByVector(viewer.camera._viewMatrix, _Cartesian4Center1, _scratchCartesian4Center1);
	          var temp2 = Cesium.Matrix4.multiplyByVector(viewer.camera._viewMatrix, _Cartesian4Center2, _scratchCartesian4Center2);
	          _scratchCartesian3Normal.x = temp1.x - temp.x;
	          _scratchCartesian3Normal.y = temp1.y - temp.y;
	          _scratchCartesian3Normal.z = temp1.z - temp.z;
	          Cesium.Cartesian3.normalize(_scratchCartesian3Normal, _scratchCartesian3Normal);
	          _scratchCartesian3Normal1.x = temp2.x - temp.x;
	          _scratchCartesian3Normal1.y = temp2.y - temp.y;
	          _scratchCartesian3Normal1.z = temp2.z - temp.z;
	          var tempTime = (new Date().getTime() - _time) % options.interval / options.interval;
	          Cesium.Quaternion.fromAxisAngle(_scratchCartesian3Normal, tempTime * Cesium.Math.PI * 2, _RotateQ);
	          Cesium.Matrix3.fromQuaternion(_RotateQ, _RotateM);
	          Cesium.Matrix3.multiplyByVector(_RotateM, _scratchCartesian3Normal1, _scratchCartesian3Normal1);
	          Cesium.Cartesian3.normalize(_scratchCartesian3Normal1, _scratchCartesian3Normal1);
	          return _scratchCartesian3Normal1;
	        },
	        u_scanColor: options.color
	      };
	    });
	  },
	  methods: {
	    createCesiumObject: function createCesiumObject() {
	      var _this2 = this;

	      return regenerator.async(function createCesiumObject$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              return _context.abrupt("return", this.$refs.stage.createPromise.then(function (_ref2) {
	                var Cesium = _ref2.Cesium,
	                    viewer = _ref2.viewer,
	                    cesiumObject = _ref2.cesiumObject;

	                if (!_this2.$refs.stage._mounted) {
	                  return _this2.$refs.stage.load().then(function (_ref3) {
	                    var Cesium = _ref3.Cesium,
	                        viewer = _ref3.viewer,
	                        cesiumObject = _ref3.cesiumObject;
	                    return cesiumObject;
	                  });
	                } else {
	                  return cesiumObject;
	                }
	              }));

	            case 1:
	            case "end":
	              return _context.stop();
	          }
	        }
	      }, null, this);
	    },
	    mount: function mount() {
	      return regenerator.async(function mount$(_context2) {
	        while (1) {
	          switch (_context2.prev = _context2.next) {
	            case 0:
	              return _context2.abrupt("return", true);

	            case 1:
	            case "end":
	              return _context2.stop();
	          }
	        }
	      });
	    },
	    unmount: function unmount() {
	      return regenerator.async(function unmount$(_context3) {
	        while (1) {
	          switch (_context3.prev = _context3.next) {
	            case 0:
	              return _context3.abrupt("return", this.$refs.stage && this.$refs.stage.unload());

	            case 1:
	            case "end":
	              return _context3.stop();
	          }
	        }
	      }, null, this);
	    }
	  },
	  created: function created() {
	    var _this3 = this;

	    defineProperties$1(this, {
	      postProcessStage: {
	        enumerable: true,
	        get: function get() {
	          return _this3.cesiumObject;
	        }
	      }
	    });
	  },
	  data: function data() {
	    return {
	      nowaiting: true,
	      fsScanSegment: "\n        uniform sampler2D colorTexture;\n        uniform sampler2D depthTexture;\n        varying vec2 v_textureCoordinates;\n        uniform vec4 u_scanCenterEC;\n        uniform vec3 u_scanPlaneNormalEC;\n        uniform vec3 u_scanLineNormalEC;\n        uniform float u_radius;\n        uniform vec4 u_scanColor;\n        vec4 toEye(in vec2 uv, in float depth)\n        {\n          vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0));\n          vec4 posInCamera =czm_inverseProjection * vec4(xy, depth, 1.0);\n          posInCamera =posInCamera / posInCamera.w;\n          return posInCamera;\n        }\n        bool isPointOnLineRight(in vec3 ptOnLine, in vec3 lineNormal, in vec3 testPt)\n        {\n          vec3 v01 = testPt - ptOnLine;\n          normalize(v01);\n          vec3 temp = cross(v01, lineNormal);\n          float d = dot(temp, u_scanPlaneNormalEC);\n          return d > 0.5;\n        }\n        vec3 pointProjectOnPlane(in vec3 planeNormal, in vec3 planeOrigin, in vec3 point)\n        {\n          vec3 v01 = point -planeOrigin;\n          float d = dot(planeNormal, v01) ;\n          return (point - planeNormal * d);\n        }\n        float distancePointToLine(in vec3 ptOnLine, in vec3 lineNormal, in vec3 testPt)\n        {\n          vec3 tempPt = pointProjectOnPlane(lineNormal, ptOnLine, testPt);\n          return length(tempPt - ptOnLine);\n        }\n        float getDepth(in vec4 depth)\n        {\n          float z_window = czm_unpackDepth(depth);\n          z_window = czm_reverseLogDepth(z_window);\n          float n_range = czm_depthRange.near;\n          float f_range = czm_depthRange.far;\n          return (2.0 * z_window - n_range - f_range) / (f_range - n_range);\n        }\n        void main()\n        {\n          gl_FragColor = texture2D(colorTexture, v_textureCoordinates);\n          float depth = getDepth( texture2D(depthTexture, v_textureCoordinates));\n          vec4 viewPos = toEye(v_textureCoordinates, depth);\n          vec3 prjOnPlane = pointProjectOnPlane(u_scanPlaneNormalEC.xyz, u_scanCenterEC.xyz, viewPos.xyz);\n          float dis = length(prjOnPlane.xyz - u_scanCenterEC.xyz);\n          float twou_radius = u_radius * 2.0;\n          if(dis < u_radius)\n          {\n            float f0 = 1.0 -abs(u_radius - dis) / u_radius;\n            f0 = pow(f0, 64.0);\n            vec3 lineEndPt = vec3(u_scanCenterEC.xyz) + u_scanLineNormalEC * u_radius;\n            float f = 0.0;\n            if(isPointOnLineRight(u_scanCenterEC.xyz, u_scanLineNormalEC.xyz, prjOnPlane.xyz))\n            {\n              float dis1= length(prjOnPlane.xyz - lineEndPt);\n              f = abs(twou_radius -dis1) / twou_radius;\n              f = pow(f, 3.0);\n            }\n            gl_FragColor = mix(gl_FragColor, u_scanColor, f + f0);\n          }\n        }",
	      uniforms: {}
	    };
	  }
	};

	/* script */
	var __vue_script__$1T = script$1T;
	/* template */

	var __vue_render__$p = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('i', {
	    class: _vm.$options.name,
	    staticStyle: {
	      "display": "none !important"
	    }
	  }, [_c('vc-stage-process-post', {
	    ref: "stage",
	    attrs: {
	      "fragmentShader": _vm.fsScanSegment,
	      "uniforms": _vm.uniforms
	    }
	  })], 1);
	};

	var __vue_staticRenderFns__$p = [];
	/* style */

	var __vue_inject_styles__$1T = undefined;
	/* scoped */

	var __vue_scope_id__$1T = undefined;
	/* functional template */

	var __vue_is_functional_template__$1T = false;
	/* component normalizer */

	function __vue_normalize__$1T(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "VcScanRadar.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var VcScanRadar = __vue_normalize__$1T({
	  render: __vue_render__$p,
	  staticRenderFns: __vue_staticRenderFns__$p
	}, __vue_inject_styles__$1T, __vue_script__$1T, __vue_scope_id__$1T, __vue_is_functional_template__$1T);

	function plugin$1J(Vue) {

	  if (plugin$1J.installed) {
	    return;
	  }

	  plugin$1J.installed = true;
	  Vue.use(PostProcessStage$1);
	  Vue.component(VcScanRadar.name, VcScanRadar);
	}

	var VcScanRadar$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$1J,
		VcScanRadar: VcScanRadar,
		install: plugin$1J
	});

	var script$1U = {
	  name: 'vc-ripple-circle-double',
	  mixins: [cmp, position, show, color, height],
	  props: {
	    minRadius: {
	      type: Number,
	      default: 0.1
	    },
	    maxRadius: {
	      type: Number,
	      default: 3000
	    },
	    deviationRadius: {
	      type: Number,
	      default: 40
	    },
	    interval: {
	      type: Number,
	      default: 1000
	    },
	    imageUrl: String
	  },
	  data: function data() {
	    return {
	      material: {},
	      radius1: undefined,
	      radius2: undefined,
	      nowaiting: true
	    };
	  },
	  mounted: function mounted() {
	    var _this = this;

	    this.getParent(this.$parent).createPromise.then(function (_ref) {
	      var Cesium = _ref.Cesium,
	          viewer = _ref.viewer;

	      _this.init();
	    });
	  },
	  methods: {
	    createCesiumObject: function createCesiumObject() {
	      var _this2 = this;

	      return regenerator.async(function createCesiumObject$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              return _context.abrupt("return", promise$1.all([this.$refs.entity1.createPromise, this.$refs.entity2.createPromise]).then(function (entities) {
	                if (!_this2.$refs.entity1._mounted || !_this2.$refs.entity1._mounted) {
	                  _this2.init();

	                  return promise$1.all([_this2.$refs.entity1.load(), _this2.$refs.entity2.load()]).then(function (entities) {
	                    return entities;
	                  });
	                } else {
	                  return entities;
	                }
	              }));

	            case 1:
	            case "end":
	              return _context.stop();
	          }
	        }
	      }, null, this);
	    },
	    init: function init() {
	      var _this3 = this;

	      var minRadius = this.minRadius,
	          maxRadius = this.maxRadius,
	          imageUrl = this.imageUrl,
	          interval = this.interval,
	          changeRadius1 = this.changeRadius1,
	          changeRadius2 = this.changeRadius2,
	          color = this.color;
	      var cesiumColor = makeColor(color);
	      this.r1 = minRadius;
	      this.r2 = minRadius;
	      this.material = {
	        fabric: {
	          type: 'Image',
	          uniforms: {
	            image: imageUrl,
	            transparent: true,
	            color: function color() {
	              return cesiumColor.withAlpha(1 - _this3.r1 / maxRadius); // entity的颜色透明 并不影响材质，并且 entity也会透明哦
	            }
	          }
	        }
	      };
	      this.radius1 = changeRadius1;
	      setTimeout(function () {
	        _this3.radius2 = changeRadius2;
	      }, interval);
	    },
	    mount: function mount() {
	      return regenerator.async(function mount$(_context2) {
	        while (1) {
	          switch (_context2.prev = _context2.next) {
	            case 0:
	              return _context2.abrupt("return", true);

	            case 1:
	            case "end":
	              return _context2.stop();
	          }
	        }
	      });
	    },
	    unmount: function unmount() {
	      return regenerator.async(function unmount$(_context3) {
	        while (1) {
	          switch (_context3.prev = _context3.next) {
	            case 0:
	              this.radius1 = 0;
	              this.radius2 = 0;
	              return _context3.abrupt("return", this.$refs.entity1 && this.$refs.entity2 ? promise$1.all([this.$refs.entity1.unload(), this.$refs.entity2.unload()]) : true);

	            case 3:
	            case "end":
	              return _context3.stop();
	          }
	        }
	      }, null, this);
	    },
	    changeRadius1: function changeRadius1() {
	      var deviationRadius = this.deviationRadius,
	          maxRadius = this.maxRadius,
	          minRadius = this.minRadius;

	      if (!this.flag1) {
	        this.r1 += deviationRadius;

	        if (this.r1 >= maxRadius) {
	          this.r1 = minRadius;
	        }

	        this.flag1 = true;
	      } else {
	        this.flag1 = false;
	      }

	      return this.r1;
	    },
	    changeRadius2: function changeRadius2() {
	      var deviationRadius = this.deviationRadius,
	          maxRadius = this.maxRadius,
	          minRadius = this.minRadius;

	      if (!this.flag2) {
	        this.r2 += deviationRadius;

	        if (this.r2 >= maxRadius) {
	          this.r2 = minRadius;
	        }

	        this.flag2 = true;
	      } else {
	        this.flag2 = false;
	      }

	      return this.r2;
	    }
	  },
	  created: function created() {
	    var _this4 = this;

	    defineProperties$1(this, {
	      entities: {
	        enumerable: true,
	        get: function get() {
	          return _this4.cesiumObject;
	        }
	      }
	    });
	  }
	};

	/* script */
	var __vue_script__$1U = script$1U;
	/* template */

	var __vue_render__$q = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('i', {
	    class: _vm.$options.name,
	    staticStyle: {
	      "display": "none !important"
	    }
	  }, [_c('vc-entity', {
	    ref: "entity1",
	    attrs: {
	      "position": _vm.position,
	      "show": _vm.show
	    }
	  }, [_c('vc-graphics-ellipse', {
	    attrs: {
	      "height": _vm.height,
	      "material": _vm.material,
	      "semiMajorAxis": _vm.radius1,
	      "semiMinorAxis": _vm.radius1
	    }
	  })], 1), _vm._v(" "), _c('vc-entity', {
	    ref: "entity2",
	    attrs: {
	      "position": _vm.position,
	      "show": _vm.show
	    }
	  }, [_c('vc-graphics-ellipse', {
	    attrs: {
	      "height": _vm.height,
	      "material": _vm.material,
	      "semiMajorAxis": _vm.radius2,
	      "semiMinorAxis": _vm.radius2
	    }
	  })], 1)], 1);
	};

	var __vue_staticRenderFns__$q = [];
	/* style */

	var __vue_inject_styles__$1U = undefined;
	/* scoped */

	var __vue_scope_id__$1U = undefined;
	/* functional template */

	var __vue_is_functional_template__$1U = false;
	/* component normalizer */

	function __vue_normalize__$1U(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "VcDoubleCircleRipple.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var VcDoubleCircleRipple = __vue_normalize__$1U({
	  render: __vue_render__$q,
	  staticRenderFns: __vue_staticRenderFns__$q
	}, __vue_inject_styles__$1U, __vue_script__$1U, __vue_scope_id__$1U, __vue_is_functional_template__$1U);

	function plugin$1K(Vue) {

	  if (plugin$1K.installed) {
	    return;
	  }

	  plugin$1K.installed = true;
	  Vue.use(Entity$1);
	  Vue.use(EllipseGraphics$1);
	  Vue.component(VcDoubleCircleRipple.name, VcDoubleCircleRipple);
	}

	var VcDoubleCircleRipple$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$1K,
		VcDoubleCircleRipple: VcDoubleCircleRipple,
		install: plugin$1K
	});

	var script$1V = {
	  name: 'vc-circle-roatating-double',
	  mixins: [cmp, position, show, height],
	  props: {
	    radius1: {
	      type: Number,
	      default: 1500
	    },
	    radius2: {
	      type: Number,
	      default: 3000
	    },
	    material1: [Object, String, Array],
	    material2: [Object, String, Array],
	    deviationRotation1: {
	      type: Number,
	      default: -0.03
	    },
	    deviationRotation2: {
	      type: Number,
	      default: 0.05
	    }
	  },
	  data: function data() {
	    return {
	      rotation1: 0,
	      stRotation1: 0,
	      rotation2: 0,
	      stRotation2: 0,
	      nowaiting: true
	    };
	  },
	  mounted: function mounted() {
	    var _this = this;

	    this.getParent(this.$parent).createPromise.then(function (_ref) {
	      var Cesium = _ref.Cesium,
	          viewer = _ref.viewer;

	      _this.init();
	    });
	  },
	  methods: {
	    createCesiumObject: function createCesiumObject() {
	      var _this2 = this;

	      return regenerator.async(function createCesiumObject$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              return _context.abrupt("return", promise$1.all([this.$refs.entity1.createPromise, this.$refs.entity2.createPromise]).then(function (entities) {
	                if (!_this2.$refs.entity1._mounted || !_this2.$refs.entity1._mounted) {
	                  return promise$1.all([_this2.$refs.entity1.load(), _this2.$refs.entity2.load()]).then(function (entities) {
	                    _this2.init();

	                    return entities;
	                  });
	                } else {
	                  return entities;
	                }
	              }));

	            case 1:
	            case "end":
	              return _context.stop();
	          }
	        }
	      }, null, this);
	    },
	    init: function init() {
	      var deviationRotation1 = this.deviationRotation1,
	          deviationRotation2 = this.deviationRotation2;
	      var startrotation1 = Cesium.Math.toRadians(30);

	      var getRotationValue1 = function getRotationValue1() {
	        startrotation1 += deviationRotation1;
	        return startrotation1;
	      };

	      this.rotation1 = getRotationValue1;
	      this.stRotation1 = getRotationValue1;
	      var startrotation2 = Cesium.Math.toRadians(30);

	      var getRotationValue2 = function getRotationValue2() {
	        startrotation2 += deviationRotation2;
	        return startrotation2;
	      };

	      this.rotation2 = getRotationValue2;
	      this.stRotation2 = getRotationValue2;
	    },
	    mount: function mount() {
	      return regenerator.async(function mount$(_context2) {
	        while (1) {
	          switch (_context2.prev = _context2.next) {
	            case 0:
	              return _context2.abrupt("return", true);

	            case 1:
	            case "end":
	              return _context2.stop();
	          }
	        }
	      });
	    },
	    unmount: function unmount() {
	      return regenerator.async(function unmount$(_context3) {
	        while (1) {
	          switch (_context3.prev = _context3.next) {
	            case 0:
	              this.rotation1 = undefined;
	              this.rotation2 = undefined;
	              this.stRotation1 = undefined;
	              this.stRotation2 = undefined;
	              return _context3.abrupt("return", this.$refs.entity1 && this.$refs.entity2 ? promise$1.all([this.$refs.entity1.unload(), this.$refs.entity2.unload()]) : true);

	            case 5:
	            case "end":
	              return _context3.stop();
	          }
	        }
	      }, null, this);
	    }
	  },
	  created: function created() {
	    var _this3 = this;

	    defineProperties$1(this, {
	      entities: {
	        enumerable: true,
	        get: function get() {
	          return _this3.cesiumObject;
	        }
	      }
	    });
	  }
	};

	/* script */
	var __vue_script__$1V = script$1V;
	/* template */

	var __vue_render__$r = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('i', {
	    class: _vm.$options.name,
	    staticStyle: {
	      "display": "none !important"
	    }
	  }, [_c('vc-entity', {
	    ref: "entity1",
	    attrs: {
	      "position": _vm.position,
	      "show": _vm.show
	    }
	  }, [_c('vc-graphics-ellipse', {
	    attrs: {
	      "height": _vm.height,
	      "material": _vm.material1,
	      "rotation": _vm.rotation1,
	      "semiMajorAxis": _vm.radius1,
	      "semiMinorAxis": _vm.radius1,
	      "stRotation": _vm.stRotation1
	    }
	  })], 1), _vm._v(" "), _c('vc-entity', {
	    ref: "entity2",
	    attrs: {
	      "position": _vm.position,
	      "show": _vm.show
	    }
	  }, [_c('vc-graphics-ellipse', {
	    attrs: {
	      "height": _vm.height,
	      "material": _vm.material2,
	      "rotation": _vm.rotation2,
	      "semiMajorAxis": _vm.radius2,
	      "semiMinorAxis": _vm.radius2,
	      "stRotation": _vm.stRotation2
	    }
	  })], 1)], 1);
	};

	var __vue_staticRenderFns__$r = [];
	/* style */

	var __vue_inject_styles__$1V = undefined;
	/* scoped */

	var __vue_scope_id__$1V = undefined;
	/* functional template */

	var __vue_is_functional_template__$1V = false;
	/* component normalizer */

	function __vue_normalize__$1V(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "VcDoubleRotatingCircle.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var VcDoubleRotatingCircle = __vue_normalize__$1V({
	  render: __vue_render__$r,
	  staticRenderFns: __vue_staticRenderFns__$r
	}, __vue_inject_styles__$1V, __vue_script__$1V, __vue_scope_id__$1V, __vue_is_functional_template__$1V);

	function plugin$1L(Vue) {

	  if (plugin$1L.installed) {
	    return;
	  }

	  plugin$1L.installed = true;
	  Vue.use(Entity$1);
	  Vue.use(EllipseGraphics$1);
	  Vue.component(VcDoubleRotatingCircle.name, VcDoubleRotatingCircle);
	}

	var VcDoubleRotatingCircle$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$1L,
		VcDoubleRotatingCircle: VcDoubleRotatingCircle,
		install: plugin$1L
	});

	var script$1W = {
	  name: 'vc-shine-ellipse',
	  mixins: [cmp, position, color, show],
	  props: {
	    height: {
	      type: Number,
	      default: undefined
	    },
	    radius: {
	      type: Number,
	      default: 2000
	    },
	    deviationAlpha: {
	      type: Number,
	      default: 0.05
	    },
	    imageUrl: String
	  },
	  data: function data() {
	    return {
	      nowaiting: true,
	      material: {}
	    };
	  },
	  mounted: function mounted() {
	    var _this = this;

	    this.getParent(this.$parent).createPromise.then(function (_ref) {
	      var Cesium = _ref.Cesium,
	          viewer = _ref.viewer;
	      var deviationAlpha = _this.deviationAlpha,
	          color = _this.color,
	          imageUrl = _this.imageUrl;
	      var colorObject = makeColor(color);
	      _this.flag = true;
	      _this.x = 1;
	      _this.material = {
	        fabric: {
	          type: 'Image',
	          uniforms: {
	            image: imageUrl,
	            color: function color() {
	              if (_this.flag) {
	                _this.x -= deviationAlpha;
	                _this.x <= 0 && (_this.flag = false);
	              } else {
	                _this.x += deviationAlpha;
	                _this.x >= 1 && (_this.flag = true);
	              }

	              return colorObject.withAlpha(_this.x);
	            }
	          }
	        }
	      };
	    });
	  },
	  created: function created() {
	    var _this2 = this;

	    defineProperties$1(this, {
	      entity: {
	        enumerable: true,
	        get: function get() {
	          return _this2.cesiumObject;
	        }
	      }
	    });
	  },
	  methods: {
	    createCesiumObject: function createCesiumObject() {
	      var _this3 = this;

	      return regenerator.async(function createCesiumObject$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              return _context.abrupt("return", this.$refs.entity.createPromise.then(function (_ref2) {
	                var Cesium = _ref2.Cesium,
	                    viewer = _ref2.viewer,
	                    cesiumObject = _ref2.cesiumObject;

	                if (!_this3.$refs.entity._mounted) {
	                  return _this3.$refs.entity.load().then(function (_ref3) {
	                    var Cesium = _ref3.Cesium,
	                        viewer = _ref3.viewer,
	                        cesiumObject = _ref3.cesiumObject;
	                    return cesiumObject;
	                  });
	                } else {
	                  return cesiumObject;
	                }
	              }));

	            case 1:
	            case "end":
	              return _context.stop();
	          }
	        }
	      }, null, this);
	    },
	    mount: function mount() {
	      return regenerator.async(function mount$(_context2) {
	        while (1) {
	          switch (_context2.prev = _context2.next) {
	            case 0:
	              return _context2.abrupt("return", true);

	            case 1:
	            case "end":
	              return _context2.stop();
	          }
	        }
	      });
	    },
	    unmount: function unmount() {
	      return regenerator.async(function unmount$(_context3) {
	        while (1) {
	          switch (_context3.prev = _context3.next) {
	            case 0:
	              return _context3.abrupt("return", this.$refs.entity && this.$refs.entity.unload());

	            case 1:
	            case "end":
	              return _context3.stop();
	          }
	        }
	      }, null, this);
	    }
	  }
	};

	/* script */
	var __vue_script__$1W = script$1W;
	/* template */

	var __vue_render__$s = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('i', {
	    class: _vm.$options.name,
	    staticStyle: {
	      "display": "none !important"
	    }
	  }, [_c('vc-entity', {
	    ref: "entity",
	    attrs: {
	      "position": _vm.position,
	      "show": _vm.show
	    }
	  }, [_c('vc-graphics-ellipse', {
	    attrs: {
	      "height": _vm.height,
	      "material": _vm.material,
	      "semi-major-axis": _vm.radius,
	      "semi-minor-axis": _vm.radius
	    }
	  })], 1)], 1);
	};

	var __vue_staticRenderFns__$s = [];
	/* style */

	var __vue_inject_styles__$1W = undefined;
	/* scoped */

	var __vue_scope_id__$1W = undefined;
	/* functional template */

	var __vue_is_functional_template__$1W = false;
	/* component normalizer */

	function __vue_normalize__$1W(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "VcShineEllipse.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var VcShineEllipse = __vue_normalize__$1W({
	  render: __vue_render__$s,
	  staticRenderFns: __vue_staticRenderFns__$s
	}, __vue_inject_styles__$1W, __vue_script__$1W, __vue_scope_id__$1W, __vue_is_functional_template__$1W);

	function plugin$1M(Vue) {

	  if (plugin$1M.installed) {
	    return;
	  }

	  plugin$1M.installed = true;
	  Vue.use(Entity$1);
	  Vue.use(EllipseGraphics$1);
	  Vue.component(VcShineEllipse.name, VcShineEllipse);
	}

	var VcShineEllipse$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$1M,
		VcShineEllipse: VcShineEllipse,
		install: plugin$1M
	});

	var script$1X = {
	  name: 'vc-shine-point',
	  mixins: [cmp, position, color, show],
	  props: {
	    pixelSize: {
	      type: Number,
	      default: 10
	    },
	    deviationAlpha: {
	      type: Number,
	      default: 0.05
	    }
	  },
	  data: function data() {
	    return {
	      nowaiting: true,
	      callBackColor: {}
	    };
	  },
	  mounted: function mounted() {
	    var _this = this;

	    this.getParent(this.$parent).createPromise.then(function (_ref) {
	      var Cesium = _ref.Cesium,
	          viewer = _ref.viewer;
	      var deviationAlpha = _this.deviationAlpha,
	          color = _this.color;
	      var colorObject = makeColor(color);
	      _this.flag = true;
	      _this.x = 1;

	      _this.callBackColor = function () {
	        if (_this.flag) {
	          _this.x -= deviationAlpha;
	          _this.x <= 0 && (_this.flag = false);
	        } else {
	          _this.x += deviationAlpha;
	          _this.x >= 1 && (_this.flag = true);
	        }

	        return colorObject.withAlpha(_this.x);
	      };
	    });
	  },
	  methods: {
	    createCesiumObject: function createCesiumObject() {
	      var _this2 = this;

	      return regenerator.async(function createCesiumObject$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              return _context.abrupt("return", this.$refs.entity.createPromise.then(function (_ref2) {
	                var Cesium = _ref2.Cesium,
	                    viewer = _ref2.viewer,
	                    cesiumObject = _ref2.cesiumObject;

	                if (!_this2.$refs.entity._mounted) {
	                  return _this2.$refs.entity.load().then(function (_ref3) {
	                    var Cesium = _ref3.Cesium,
	                        viewer = _ref3.viewer,
	                        cesiumObject = _ref3.cesiumObject;
	                    return cesiumObject;
	                  });
	                } else {
	                  return cesiumObject;
	                }
	              }));

	            case 1:
	            case "end":
	              return _context.stop();
	          }
	        }
	      }, null, this);
	    },
	    mount: function mount() {
	      return regenerator.async(function mount$(_context2) {
	        while (1) {
	          switch (_context2.prev = _context2.next) {
	            case 0:
	              return _context2.abrupt("return", true);

	            case 1:
	            case "end":
	              return _context2.stop();
	          }
	        }
	      });
	    },
	    unmount: function unmount() {
	      return regenerator.async(function unmount$(_context3) {
	        while (1) {
	          switch (_context3.prev = _context3.next) {
	            case 0:
	              return _context3.abrupt("return", this.$refs.entity && this.$refs.entity.unload());

	            case 1:
	            case "end":
	              return _context3.stop();
	          }
	        }
	      }, null, this);
	    }
	  },
	  created: function created() {
	    var _this3 = this;

	    defineProperties$1(this, {
	      entity: {
	        enumerable: true,
	        get: function get() {
	          return _this3.cesiumObject;
	        }
	      }
	    });
	  }
	};

	/* script */
	var __vue_script__$1X = script$1X;
	/* template */

	var __vue_render__$t = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('i', {
	    class: _vm.$options.name,
	    staticStyle: {
	      "display": "none !important"
	    }
	  }, [_c('vc-entity', {
	    ref: "entity",
	    attrs: {
	      "position": _vm.position
	    }
	  }, [_c('vc-graphics-point', {
	    attrs: {
	      "color": _vm.callBackColor,
	      "heightReference": 2,
	      "outlineWidth": 0,
	      "pixelSize": _vm.pixelSize,
	      "show": _vm.show
	    }
	  })], 1)], 1);
	};

	var __vue_staticRenderFns__$t = [];
	/* style */

	var __vue_inject_styles__$1X = undefined;
	/* scoped */

	var __vue_scope_id__$1X = undefined;
	/* functional template */

	var __vue_is_functional_template__$1X = false;
	/* component normalizer */

	function __vue_normalize__$1X(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "VcShinePoint.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var VcShinePoint = __vue_normalize__$1X({
	  render: __vue_render__$t,
	  staticRenderFns: __vue_staticRenderFns__$t
	}, __vue_inject_styles__$1X, __vue_script__$1X, __vue_scope_id__$1X, __vue_is_functional_template__$1X);

	function plugin$1N(Vue) {

	  if (plugin$1N.installed) {
	    return;
	  }

	  plugin$1N.installed = true;
	  Vue.use(Entity$1);
	  Vue.use(PointGraphics$1);
	  Vue.component(VcShinePoint.name, VcShinePoint);
	}

	var VcShinePoint$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$1N,
		VcShinePoint: VcShinePoint,
		install: plugin$1N
	});

	var PolylineTrailMaterialProperty =
	/*#__PURE__*/
	function () {
	  function PolylineTrailMaterialProperty(color, duration, imageUrl, loop) {
	    _classCallCheck(this, PolylineTrailMaterialProperty);

	    if (!getOwnPropertyDescriptor$1(PolylineTrailMaterialProperty.prototype, 'color')) {
	      defineProperties$1(PolylineTrailMaterialProperty.prototype, {
	        color: Cesium.createPropertyDescriptor('color')
	      });
	    }

	    this._definitionChanged = new Cesium.Event();
	    this._color = undefined;
	    this.color = color;
	    this._duration = duration;
	    this._time = new Date().getTime();
	    this._imageUrl = imageUrl;
	    this._loop = loop;
	    this.init();
	  }

	  _createClass(PolylineTrailMaterialProperty, [{
	    key: "init",
	    value: function init() {
	      var PolylineTrailType = 'PolylineTrail';
	      var PolylineTrailImage = this._imageUrl;
	      var PolylineTrailSource = "\n      czm_material czm_getMaterial(czm_materialInput materialInput)\n      {\n        czm_material material = czm_getDefaultMaterial(materialInput);\n        vec2 st = materialInput.st;\n        vec4 colorImage = texture2D(image, vec2(fract(st.s - time), st.t));\n        material.alpha = colorImage.a * color.a;\n        material.diffuse = (colorImage.rgb+color.rgb)/2.0;\n        return material;\n      }"; // material.alpha:透明度; material.diffuse：颜色;

	      Cesium.Material._materialCache.addMaterial(PolylineTrailType, {
	        fabric: {
	          type: PolylineTrailType,
	          uniforms: {
	            color: new Cesium.Color(1, 0, 0, 1),
	            image: PolylineTrailImage,
	            time: 0,
	            repeat: new Cesium.Cartesian2(1, 1),
	            axisY: false
	          },
	          source: PolylineTrailSource
	        },
	        translucent: function translucent() {
	          return true;
	        }
	      });
	    }
	  }, {
	    key: "getType",
	    value: function getType() {
	      return 'PolylineTrail';
	    }
	  }, {
	    key: "getValue",
	    value: function getValue(time, result) {
	      if (!Cesium.defined(result)) {
	        result = {};
	      }

	      if (this.lastTime >= 0.99 && !this._loop) {
	        return result;
	      }

	      result.color = Cesium.Property.getValueOrClonedDefault(this._color, time, Cesium.Color.WHITE, result.color);
	      result.image = this._imageUrl;
	      result.time = (new Date().getTime() - this._time) % this._duration / this._duration;
	      this.lastTime = result.time;
	      return result;
	    }
	  }, {
	    key: "equals",
	    value: function equals(other) {
	      return this === other || other instanceof PolylineTrailMaterialProperty && Cesium.Property.equals(this._color, other._other);
	    }
	  }, {
	    key: "isConstant",
	    get: function get() {
	      return false;
	    }
	  }, {
	    key: "definitionChanged",
	    get: function get() {
	      return this._definitionChanged;
	    }
	  }]);

	  return PolylineTrailMaterialProperty;
	}();

	var script$1Y = {
	  name: 'vc-trail-polyline',
	  mixins: [cmp, positions, width, clampToGround, show],
	  props: {
	    color: {
	      type: [Object, String, Array],
	      default: 'yellow'
	    },
	    interval: {
	      type: Number,
	      default: 3000
	    },
	    imageUrl: String,
	    loop: {
	      type: Boolean,
	      default: true
	    }
	  },
	  data: function data() {
	    return {
	      nowaiting: true,
	      material: {}
	    };
	  },
	  mounted: function mounted() {
	    var _this = this;

	    this.getParent(this.$parent).createPromise.then(function (_ref) {
	      var Cesium = _ref.Cesium,
	          viewer = _ref.viewer;
	      var color = _this.color,
	          imageUrl = _this.imageUrl,
	          interval = _this.interval,
	          loop = _this.loop;
	      var colorCesium = makeColor(color);
	      _this.material = new PolylineTrailMaterialProperty(colorCesium, interval, imageUrl, loop);
	    });
	  },
	  methods: {
	    createCesiumObject: function createCesiumObject() {
	      var _this2 = this;

	      return regenerator.async(function createCesiumObject$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              return _context.abrupt("return", this.$refs.entity.createPromise.then(function (_ref2) {
	                var Cesium = _ref2.Cesium,
	                    viewer = _ref2.viewer,
	                    cesiumObject = _ref2.cesiumObject;

	                if (!_this2.$refs.entity._mounted) {
	                  return _this2.$refs.entity.load().then(function (_ref3) {
	                    var Cesium = _ref3.Cesium,
	                        viewer = _ref3.viewer,
	                        cesiumObject = _ref3.cesiumObject;
	                    return cesiumObject;
	                  });
	                } else {
	                  return cesiumObject;
	                }
	              }));

	            case 1:
	            case "end":
	              return _context.stop();
	          }
	        }
	      }, null, this);
	    },
	    mount: function mount() {
	      return regenerator.async(function mount$(_context2) {
	        while (1) {
	          switch (_context2.prev = _context2.next) {
	            case 0:
	              return _context2.abrupt("return", true);

	            case 1:
	            case "end":
	              return _context2.stop();
	          }
	        }
	      });
	    },
	    unmount: function unmount() {
	      return regenerator.async(function unmount$(_context3) {
	        while (1) {
	          switch (_context3.prev = _context3.next) {
	            case 0:
	              return _context3.abrupt("return", this.$refs.entity && this.$refs.entity.unload());

	            case 1:
	            case "end":
	              return _context3.stop();
	          }
	        }
	      }, null, this);
	    }
	  },
	  created: function created() {
	    var _this3 = this;

	    defineProperties$1(this, {
	      entity: {
	        enumerable: true,
	        get: function get() {
	          return _this3.cesiumObject;
	        }
	      }
	    });
	  }
	};

	/* script */
	var __vue_script__$1Y = script$1Y;
	/* template */

	var __vue_render__$u = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('i', {
	    class: _vm.$options.name,
	    staticStyle: {
	      "display": "none !important"
	    }
	  }, [_c('vc-entity', {
	    ref: "entity",
	    attrs: {
	      "show": _vm.show
	    }
	  }, [_c('vc-graphics-polyline', {
	    attrs: {
	      "material": _vm.material,
	      "positions": _vm.positions,
	      "width": _vm.width,
	      "clampToGround": _vm.clampToGround
	    }
	  })], 1)], 1);
	};

	var __vue_staticRenderFns__$u = [];
	/* style */

	var __vue_inject_styles__$1Y = undefined;
	/* scoped */

	var __vue_scope_id__$1Y = undefined;
	/* functional template */

	var __vue_is_functional_template__$1Y = false;
	/* component normalizer */

	function __vue_normalize__$1Y(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "VcPolylineTrail.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var VcPolylineTrail = __vue_normalize__$1Y({
	  render: __vue_render__$u,
	  staticRenderFns: __vue_staticRenderFns__$u
	}, __vue_inject_styles__$1Y, __vue_script__$1Y, __vue_scope_id__$1Y, __vue_is_functional_template__$1Y);

	function plugin$1O(Vue) {

	  if (plugin$1O.installed) {
	    return;
	  }

	  plugin$1O.installed = true;
	  Vue.use(Entity$1);
	  Vue.use(PolylineGraphics$1);
	  Vue.component(VcPolylineTrail.name, VcPolylineTrail);
	}

	var VcPolylineTrail$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$1O,
		VcPolylineTrail: VcPolylineTrail,
		install: plugin$1O
	});

	var script$1Z = {
	  name: 'vc-trail-wall',
	  mixins: [cmp, positions, minimumHeights, maximumHeights, outline, show],
	  props: {
	    color: {
	      type: [Object, String, Array],
	      default: 'yellow'
	    },
	    interval: {
	      type: Number,
	      default: 3000
	    },
	    imageUrl: String,
	    loop: {
	      type: Boolean,
	      default: true
	    }
	  },
	  data: function data() {
	    return {
	      nowaiting: true,
	      material: {}
	    };
	  },
	  mounted: function mounted() {
	    var _this = this;

	    this.getParent(this.$parent).createPromise.then(function (_ref) {
	      var Cesium = _ref.Cesium,
	          viewer = _ref.viewer;
	      var color = _this.color,
	          imageUrl = _this.imageUrl,
	          interval = _this.interval,
	          loop = _this.loop;
	      var colorCesium = makeColor(color);
	      _this.material = new PolylineTrailMaterialProperty(colorCesium, interval, imageUrl, loop);
	    });
	  },
	  methods: {
	    createCesiumObject: function createCesiumObject() {
	      var _this2 = this;

	      return regenerator.async(function createCesiumObject$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              return _context.abrupt("return", this.$refs.entity.createPromise.then(function (_ref2) {
	                var Cesium = _ref2.Cesium,
	                    viewer = _ref2.viewer,
	                    cesiumObject = _ref2.cesiumObject;

	                if (!_this2.$refs.entity._mounted) {
	                  return _this2.$refs.entity.load().then(function (_ref3) {
	                    var Cesium = _ref3.Cesium,
	                        viewer = _ref3.viewer,
	                        cesiumObject = _ref3.cesiumObject;
	                    return cesiumObject;
	                  });
	                } else {
	                  return cesiumObject;
	                }
	              }));

	            case 1:
	            case "end":
	              return _context.stop();
	          }
	        }
	      }, null, this);
	    },
	    mount: function mount() {
	      return regenerator.async(function mount$(_context2) {
	        while (1) {
	          switch (_context2.prev = _context2.next) {
	            case 0:
	              return _context2.abrupt("return", true);

	            case 1:
	            case "end":
	              return _context2.stop();
	          }
	        }
	      });
	    },
	    unmount: function unmount() {
	      return regenerator.async(function unmount$(_context3) {
	        while (1) {
	          switch (_context3.prev = _context3.next) {
	            case 0:
	              return _context3.abrupt("return", this.$refs.entity && this.$refs.entity.unload());

	            case 1:
	            case "end":
	              return _context3.stop();
	          }
	        }
	      }, null, this);
	    }
	  },
	  created: function created() {
	    var _this3 = this;

	    defineProperties$1(this, {
	      entity: {
	        enumerable: true,
	        get: function get() {
	          return _this3.cesiumObject;
	        }
	      }
	    });
	  }
	};

	/* script */
	var __vue_script__$1Z = script$1Z;
	/* template */

	var __vue_render__$v = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('i', {
	    class: _vm.$options.name,
	    staticStyle: {
	      "display": "none !important"
	    }
	  }, [_c('vc-entity', {
	    ref: "entity"
	  }, [_c('vc-graphics-wall', {
	    attrs: {
	      "material": _vm.material,
	      "maximumHeights": _vm.maximumHeights,
	      "minimumHeights": _vm.minimumHeights,
	      "outline": _vm.outline,
	      "positions": _vm.positions,
	      "show": _vm.show
	    }
	  })], 1)], 1);
	};

	var __vue_staticRenderFns__$v = [];
	/* style */

	var __vue_inject_styles__$1Z = undefined;
	/* scoped */

	var __vue_scope_id__$1Z = undefined;
	/* functional template */

	var __vue_is_functional_template__$1Z = false;
	/* component normalizer */

	function __vue_normalize__$1Z(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
	  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

	  component.__file = "VcWallTrail.vue";

	  if (!component.render) {
	    component.render = template.render;
	    component.staticRenderFns = template.staticRenderFns;
	    component._compiled = true;
	    if (functional) component.functional = true;
	  }

	  component._scopeId = scope;

	  return component;
	}
	/* style inject */

	/* style inject SSR */


	var VcWallTrail = __vue_normalize__$1Z({
	  render: __vue_render__$v,
	  staticRenderFns: __vue_staticRenderFns__$v
	}, __vue_inject_styles__$1Z, __vue_script__$1Z, __vue_scope_id__$1Z, __vue_is_functional_template__$1Z);

	function plugin$1P(Vue) {

	  if (plugin$1P.installed) {
	    return;
	  }

	  plugin$1P.installed = true;
	  Vue.use(Entity$1);
	  Vue.use(WallGraphics$1);
	  Vue.component(VcWallTrail.name, VcWallTrail);
	}

	var VcWallTrail$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$1P,
		VcWallTrail: VcWallTrail,
		install: plugin$1P
	});

	/**
	 * @const {string} VueCesium version
	 */

	var VERSION = '2.2.0'; // const $vc = {
	//   VERSION
	// }

	/**
	 * Register all VueCesium components.
	 * @param {Object} Vue
	 * @param {Object} options
	 */

	function plugin$1Q(Vue) {
	  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	  if (plugin$1Q.installed) {
	    return;
	  }

	  plugin$1Q.installed = true; // 场景

	  Vue.use(Viewer$1, options); // 影像

	  Vue.use(ImageryLayer$1, options);
	  Vue.use(ArcGisMapServerImageryProvider$1, options);
	  Vue.use(BingMapsImageryProvider$1, options);
	  Vue.use(GoogleEarthEnterpriseImageryProvider$1, options);
	  Vue.use(GridImageryProvider$1, options);
	  Vue.use(IonImageryProvider$1, options);
	  Vue.use(MapboxImageryProvider$1, options);
	  Vue.use(MapboxStyleImageryProvider$1, options);
	  Vue.use(OpenStreetMapImageryProvider$1, options);
	  Vue.use(SingleTileImageryProvider$1, options);
	  Vue.use(TileCoordinatesImageryProvider$1, options);
	  Vue.use(TileMapServiceImageryProvider$1, options);
	  Vue.use(UrlTemplateImageryProvider$1, options);
	  Vue.use(WebMapServiceImageryProvider$1, options);
	  Vue.use(WebMapTileServiceImageryProvider$1, options);
	  Vue.use(TiandituImageryProvider$2, options);
	  Vue.use(SuperMapImageryProvider$2, options);
	  Vue.use(TiledCacheImageryProvider$1, options);
	  Vue.use(BaiduMapImageryProvider$2, options); // 地形

	  Vue.use(ArcGISTiledElevationTerrainProvider$1, options);
	  Vue.use(CesiumTerrainProvider$1, options); // 数据源

	  Vue.use(CustomDataSource$1, options);
	  Vue.use(CzmlDataSource$1, options);
	  Vue.use(GeoJsonDataSource$1, options);
	  Vue.use(KmlDataSource$1, options); // 实体

	  Vue.use(Entity$1, options);
	  Vue.use(BillboardGraphics$1, options);
	  Vue.use(BoxGraphics$1, options);
	  Vue.use(CorridorGraphics$1, options);
	  Vue.use(CylinderGraphics$1, options);
	  Vue.use(EllipseGraphics$1, options);
	  Vue.use(EllipsoidGraphics$1, options);
	  Vue.use(LabelGraphics$1, options);
	  Vue.use(ModelGraphics$1, options);
	  Vue.use(Cesium3DTilesetGraphics$1, options);
	  Vue.use(PathGraphics$1, options);
	  Vue.use(PlaneGraphics$1, options);
	  Vue.use(PointGraphics$1, options);
	  Vue.use(PolygonGraphics$1, options);
	  Vue.use(PolylineGraphics$1, options);
	  Vue.use(PolylineVolumeGraphics$1, options);
	  Vue.use(RectangleGraphics$1, options);
	  Vue.use(WallGraphics$1, options); // 图元集合

	  Vue.use(PrimitiveCollection$1, options);
	  Vue.use(BillboardCollection$1, options);
	  Vue.use(LabelCollection$1, options);
	  Vue.use(PointPrimitiveCollection$1, options);
	  Vue.use(PolylineCollection$1, options); // 图元

	  Vue.use(Primitive$1, options);
	  Vue.use(ClassificationPrimitive$1, options);
	  Vue.use(GroundPolylinePrimitive$1, options);
	  Vue.use(GroundPrimitive$1, options);
	  Vue.use(Billboard$1, options);
	  Vue.use(Label$1, options);
	  Vue.use(PointPrimitive$1, options);
	  Vue.use(Polyline$1, options);
	  Vue.use(Model$1, options);
	  Vue.use(Cesium3DTileset$1, options);
	  Vue.use(ParticleSystem$1, options); // 几何体

	  Vue.use(GeometryInstance$1, options);
	  Vue.use(BoxGeometry$1, options);
	  Vue.use(BoxOutlineGeometry$1, options);
	  Vue.use(CircleGeometry$1, options);
	  Vue.use(CircleOutlineGeometry$1, options);
	  Vue.use(CoplanarPolygonGeometry$1, options);
	  Vue.use(CoplanarPolygonOutlineGeometry$1, options);
	  Vue.use(CorridorGeometry$1, options);
	  Vue.use(CorridorOutlineGeometry$1, options);
	  Vue.use(CylinderGeometry$1, options);
	  Vue.use(CylinderOutlineGeometry$1, options);
	  Vue.use(EllipseGeometry$1, options);
	  Vue.use(EllipseOutlineGeometry$1, options);
	  Vue.use(EllipsoidGeometry$1, options);
	  Vue.use(EllipsoidOutlineGeometry$1, options);
	  Vue.use(FrustumGeometry$1, options);
	  Vue.use(FrustumOutlineGeometry$1, options);
	  Vue.use(GroundPolylineGeometry$1, options);
	  Vue.use(PlaneGeometry$1, options);
	  Vue.use(PlaneOutlineGeometry$1, options);
	  Vue.use(PolygonGeometry$1, options);
	  Vue.use(PolygonOutlineGeometry$1, options);
	  Vue.use(PolylineGeometry$1, options);
	  Vue.use(PolylineVolumeGeometry$1, options);
	  Vue.use(PolylineVolumeOutlineGeometry$1, options);
	  Vue.use(RectangleGeometry$1, options);
	  Vue.use(RectangleOutlineGeometry$1, options);
	  Vue.use(SimplePolylineGeometry$1, options);
	  Vue.use(SphereGeometry$1, options);
	  Vue.use(SphereOutlineGeometry$1, options);
	  Vue.use(WallGeometry$1, options);
	  Vue.use(WallOutlineGeometry$1, options); // stage

	  Vue.use(PostProcessStageCollection$1, options);
	  Vue.use(PostProcessStage$1, options); // 工具

	  Vue.use(VcMeasureArea$1, options);
	  Vue.use(VcMeasureDistance$1, options);
	  Vue.use(VcMeasureHeight$1, options);
	  Vue.use(VcDrawHandlerPoint$1, options);
	  Vue.use(VcDrawHandlerPolyline$1, options);
	  Vue.use(VcDrawHandlerPolygon$1, options); // 扩展

	  Vue.use(VcFlood$1, options);
	  Vue.use(VcHeatMap$1, options);
	  Vue.use(VcWindMap$1, options);
	  Vue.use(VcKrigingMap$1, options);
	  Vue.use(VcScanCircle$1, options);
	  Vue.use(VcScanRadar$1, options);
	  Vue.use(VcDoubleCircleRipple$1, options);
	  Vue.use(VcDoubleRotatingCircle$1, options);
	  Vue.use(VcShineEllipse$1, options);
	  Vue.use(VcShinePoint$1, options);
	  Vue.use(VcPolylineTrail$1, options);
	  Vue.use(VcWallTrail$1, options);
	  Vue.use(VcHTMLOverlay$1, options); // 控件

	  Vue.use(VcNavigation$1, options); // Vue.use(VcNavigationSM, options)
	  // Vue.use(VcOverviewMap, options)
	  // lang.install($vc, options.lang)
	  // Vue.prototype.$vc = $vc
	}

	var VueCesium = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': plugin$1Q,
		VERSION: VERSION,
		lang: lang,
		install: plugin$1Q,
		Viewer: Viewer$1,
		ImageryLayer: ImageryLayer$1,
		ArcGisMapServerImageryProvider: ArcGisMapServerImageryProvider$1,
		BingMapsImageryProvider: BingMapsImageryProvider$1,
		GoogleEarthEnterpriseImageryProvider: GoogleEarthEnterpriseImageryProvider$1,
		GridImageryProvider: GridImageryProvider$1,
		IonImageryProvider: IonImageryProvider$1,
		MapboxImageryProvider: MapboxImageryProvider$1,
		MapboxStyleImageryProvider: MapboxStyleImageryProvider$1,
		OpenStreetMapImageryProvider: OpenStreetMapImageryProvider$1,
		SingleTileImageryProvider: SingleTileImageryProvider$1,
		TileCoordinatesImageryProvider: TileCoordinatesImageryProvider$1,
		TileMapServiceImageryProvider: TileMapServiceImageryProvider$1,
		UrlTemplateImageryProvider: UrlTemplateImageryProvider$1,
		WebMapServiceImageryProvider: WebMapServiceImageryProvider$1,
		WebMapTileServiceImageryProvider: WebMapTileServiceImageryProvider$1,
		TiandituImageryProvider: TiandituImageryProvider$2,
		SuperMapImageryProvider: SuperMapImageryProvider$2,
		TiledCacheImageryProvider: TiledCacheImageryProvider$1,
		BaiduMapImageryProvider: BaiduMapImageryProvider$2,
		ArcGISTiledElevationTerrainProvider: ArcGISTiledElevationTerrainProvider$1,
		CesiumTerrainProvider: CesiumTerrainProvider$1,
		CustomDataSource: CustomDataSource$1,
		CzmlDataSource: CzmlDataSource$1,
		GeoJsonDataSource: GeoJsonDataSource$1,
		KmlDataSource: KmlDataSource$1,
		Entity: Entity$1,
		BillboardGraphics: BillboardGraphics$1,
		BoxGraphics: BoxGraphics$1,
		CorridorGraphics: CorridorGraphics$1,
		CylinderGraphics: CylinderGraphics$1,
		EllipseGraphics: EllipseGraphics$1,
		EllipsoidGraphics: EllipsoidGraphics$1,
		LabelGraphics: LabelGraphics$1,
		ModelGraphics: ModelGraphics$1,
		Cesium3DTilesetGraphics: Cesium3DTilesetGraphics$1,
		PathGraphics: PathGraphics$1,
		PlaneGraphics: PlaneGraphics$1,
		PointGraphics: PointGraphics$1,
		PolygonGraphics: PolygonGraphics$1,
		PolylineGraphics: PolylineGraphics$1,
		PolylineVolumeGraphics: PolylineVolumeGraphics$1,
		RectangleGraphics: RectangleGraphics$1,
		WallGraphics: WallGraphics$1,
		PrimitiveCollection: PrimitiveCollection$1,
		BillboardCollection: BillboardCollection$1,
		LabelCollection: LabelCollection$1,
		PointPrimitiveCollection: PointPrimitiveCollection$1,
		PolylineCollection: PolylineCollection$1,
		Primitive: Primitive$1,
		ClassificationPrimitive: ClassificationPrimitive$1,
		GroundPolylinePrimitive: GroundPolylinePrimitive$1,
		GroundPrimitive: GroundPrimitive$1,
		Billboard: Billboard$1,
		Label: Label$1,
		PointPrimitive: PointPrimitive$1,
		Polyline: Polyline$1,
		Model: Model$1,
		Cesium3DTileset: Cesium3DTileset$1,
		ParticleSystem: ParticleSystem$1,
		GeometryInstance: GeometryInstance$1,
		BoxGeometry: BoxGeometry$1,
		BoxOutlineGeometry: BoxOutlineGeometry$1,
		CircleGeometry: CircleGeometry$1,
		CircleOutlineGeometry: CircleOutlineGeometry$1,
		CoplanarPolygonGeometry: CoplanarPolygonGeometry$1,
		CoplanarPolygonOutlineGeometry: CoplanarPolygonOutlineGeometry$1,
		CorridorGeometry: CorridorGeometry$1,
		CorridorOutlineGeometry: CorridorOutlineGeometry$1,
		CylinderGeometry: CylinderGeometry$1,
		CylinderOutlineGeometry: CylinderOutlineGeometry$1,
		EllipseGeometry: EllipseGeometry$1,
		EllipseOutlineGeometry: EllipseOutlineGeometry$1,
		EllipsoidGeometry: EllipsoidGeometry$1,
		EllipsoidOutlineGeometry: EllipsoidOutlineGeometry$1,
		FrustumGeometry: FrustumGeometry$1,
		FrustumOutlineGeometry: FrustumOutlineGeometry$1,
		GroundPolylineGeometry: GroundPolylineGeometry$1,
		PlaneGeometry: PlaneGeometry$1,
		PlaneOutlineGeometry: PlaneOutlineGeometry$1,
		PolygonGeometry: PolygonGeometry$1,
		PolygonOutlineGeometry: PolygonOutlineGeometry$1,
		PolylineGeometry: PolylineGeometry$1,
		PolylineVolumeGeometry: PolylineVolumeGeometry$1,
		PolylineVolumeOutlineGeometry: PolylineVolumeOutlineGeometry$1,
		RectangleGeometry: RectangleGeometry$1,
		RectangleOutlineGeometry: RectangleOutlineGeometry$1,
		SimplePolylineGeometry: SimplePolylineGeometry$1,
		SphereGeometry: SphereGeometry$1,
		SphereOutlineGeometry: SphereOutlineGeometry$1,
		WallGeometry: WallGeometry$1,
		WallOutlineGeometry: WallOutlineGeometry$1,
		PostProcessStageCollection: PostProcessStageCollection$1,
		PostProcessStage: PostProcessStage$1,
		VcMeasureArea: VcMeasureArea$1,
		VcMeasureDistance: VcMeasureDistance$1,
		VcMeasureHeight: VcMeasureHeight$1,
		VcDrawHandlerPoint: VcDrawHandlerPoint$1,
		VcDrawHandlerPolyline: VcDrawHandlerPolyline$1,
		VcDrawHandlerPolygon: VcDrawHandlerPolygon$1,
		VcFlood: VcFlood$1,
		VcHeatMap: VcHeatMap$1,
		VcWindMap: VcWindMap$1,
		VcKrigingMap: VcKrigingMap$1,
		VcScanCircle: VcScanCircle$1,
		VcScanRadar: VcScanRadar$1,
		VcDoubleCircleRipple: VcDoubleCircleRipple$1,
		VcDoubleRotatingCircle: VcDoubleRotatingCircle$1,
		VcShineEllipse: VcShineEllipse$1,
		VcShinePoint: VcShinePoint$1,
		VcPolylineTrail: VcPolylineTrail$1,
		VcWallTrail: VcWallTrail$1,
		VcHTMLOverlay: VcHTMLOverlay$1,
		VcNavigation: VcNavigation$1,
		VcNavigationSM: index,
		VcOverviewMap: index$2,
		PolylineTrailMaterialProperty: PolylineTrailMaterialProperty
	});

	function ownKeys(object, enumerableOnly) { var keys = keys$1(object); if (getOwnPropertySymbols$1) { var symbols = getOwnPropertySymbols$1(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return getOwnPropertyDescriptor$1(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (getOwnPropertyDescriptors$1) { defineProperties$1(target, getOwnPropertyDescriptors$1(source)); } else { ownKeys(source).forEach(function (key) { defineProperty$1(target, key, getOwnPropertyDescriptor$1(source, key)); }); } } return target; }
	var index_umd = _objectSpread({}, VueCesium);

	return index_umd;

})));
