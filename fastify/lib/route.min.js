"use strict";const FindMyWay=require("find-my-way"),Context=require("./context"),handleRequest=require("./handleRequest"),{hookRunner:hookRunner,hookIterator:hookIterator,lifecycleHooks:lifecycleHooks}=require("./hooks"),supportedMethods=["DELETE","GET","HEAD","PATCH","POST","PUT","OPTIONS"],{normalizeSchema:normalizeSchema}=require("./schemas"),{parseHeadOnSendHandlers:parseHeadOnSendHandlers}=require("./headRoute"),{ValidatorSelector:ValidatorSelector,SerializerCompiler:buildDefaultSerializer}=require("./schema-compilers"),warning=require("./warnings"),{compileSchemasForValidation:compileSchemasForValidation,compileSchemasForSerialization:compileSchemasForSerialization}=require("./validation"),{FST_ERR_SCH_VALIDATION_BUILD:FST_ERR_SCH_VALIDATION_BUILD,FST_ERR_SCH_SERIALIZATION_BUILD:FST_ERR_SCH_SERIALIZATION_BUILD}=require("./errors"),{kRoutePrefix:kRoutePrefix,kLogLevel:kLogLevel,kLogSerializers:kLogSerializers,kHooks:kHooks,kHooksDeprecatedPreParsing:kHooksDeprecatedPreParsing,kSchemas:kSchemas,kOptions:kOptions,kValidatorCompiler:kValidatorCompiler,kSerializerCompiler:kSerializerCompiler,kContentTypeParser:kContentTypeParser,kReply:kReply,kReplySerializerDefault:kReplySerializerDefault,kReplyIsError:kReplyIsError,kRequest:kRequest,kRequestPayloadStream:kRequestPayloadStream,kDisableRequestLogging:kDisableRequestLogging,kSchemaErrorFormatter:kSchemaErrorFormatter,kErrorHandler:kErrorHandler}=require("./symbols.js");function buildRouting(e){const r=FindMyWay(e.config);let t,o,i,n,a,s,l,h,u,c,d,p,m,k,f,g=!1;return{setup(e,r){t=r.avvio,o=r.fourOhFour,s=r.logger,l=r.hasLogger,h=r.setupResponseListeners,u=r.throwIfAlreadyStarted,f=e.exposeHeadRoutes,i=e.requestIdHeader,n=e.querystringParser,a=e.requestIdLogLabel,c=e.genReqId,d=e.disableRequestLogging,p=e.ignoreTrailingSlash,m=!Object.prototype.hasOwnProperty.call(e,"return503OnClosing")||e.return503OnClosing,k=ValidatorSelector()},routing:r.lookup.bind(r),route:R,prepareRoute:S,routeHandler:y,closeRoutes:()=>{g=!0},printRoutes:r.prettyPrint.bind(r)};function S(e,r,t,o){if(o||"function"!=typeof t){if(o&&"function"==typeof o){if("[object Object]"!==Object.prototype.toString.call(t))throw new Error(`Options for ${e}:${r} route must be an object`);if(t.handler)throw"function"==typeof t.handler?new Error(`Duplicate handler for ${e}:${r} route is not allowed!`):new Error(`Handler for ${e}:${r} route must be a function`)}}else o=t,t={};return t=Object.assign({},t,{method:e,url:r,handler:o||t&&t.handler}),R.call(this,t)}function R(e){const i={...e};if(u("Cannot add route when fastify instance is already started!"),Array.isArray(i.method)){for(var n=0;n<i.method.length;n++)if(-1===supportedMethods.indexOf(i.method[n]))throw new Error(`${i.method[n]} method is not supported!`)}else if(-1===supportedMethods.indexOf(i.method))throw new Error(`${i.method} method is not supported!`);if(!i.handler)throw new Error(`Missing handler function for ${i.method}:${i.url} route.`);if(void 0!==i.errorHandler&&"function"!=typeof i.errorHandler)throw new Error(`Error Handler for ${i.method}:${i.url} route, if defined, must be a function`);validateBodyLimitOption(i.bodyLimit);const a=this[kRoutePrefix];return this.after((e,r)=>{const t=i.url||i.path;if("/"===t&&a.length>0)switch(i.prefixTrailingSlash){case"slash":s.call(this,{path:t},e,r);break;case"no-slash":s.call(this,{path:""},e,r);break;case"both":default:s.call(this,{path:""},e,r),!0!==p&&s.call(this,{path:t,prefixing:!0},e,r)}else"/"===t[0]&&a.endsWith("/")?s.call(this,{path:t.slice(1)},e,r):s.call(this,{path:t},e,r)}),this;function s({path:n,prefixing:s=!1},l,h){const u=a+n;if(i.url=u,i.path=u,i.routePath=n,i.prefix=a,i.logLevel=i.logLevel||this[kLogLevel],(this[kLogSerializers]||i.logSerializers)&&(i.logSerializers=Object.assign(Object.create(this[kLogSerializers]),i.logSerializers)),null==i.attachValidation&&(i.attachValidation=!1),!1===s)for(const e of this[kHooks].onRoute)try{e.call(this,i)}catch(e){return void h(e)}const c=i.config||{};c.url=u,c.method=i.method;const d=new Context(i.schema,i.handler.bind(this),this[kReply],this[kRequest],this[kContentTypeParser],c,i.errorHandler||this[kErrorHandler],i.bodyLimit,i.logLevel,i.logSerializers,i.attachValidation,this[kReplySerializerDefault],i.schemaErrorFormatter||this[kSchemaErrorFormatter]),p=null!=r.find("HEAD",n);try{r.on(i.method,i.url,{version:i.version},y,d)}catch(e){return void h(e)}const{exposeHeadRoute:m}=i;if((null!=m?m:f)&&"GET"===e.method&&!p){const e=parseHeadOnSendHandlers(i.onSend);S.call(this,"HEAD",n,{...i,onSend:e})}else p&&m&&warning.emit("FSTDEP007");t.once("preReady",()=>{for(const e of lifecycleHooks){const r=this[kHooks][e].concat(i[e]||[]).map(r=>{const t=r.bind(this);return"preParsing"===e&&r.length===("AsyncFunction"===r.constructor.name?2:3)&&(warning.emit("FSTDEP004"),t[kHooksDeprecatedPreParsing]=!0),t});d[e]=r.length?r:null}if(o.setContext(this,d),i.schema){d.schema=normalizeSchema(d.schema);const e=this[kSchemas];!i.validatorCompiler&&(!this[kValidatorCompiler]||this[kValidatorCompiler]&&e.hasNewSchemas())&&this.setValidatorCompiler(k(e.getSchemas(),this[kOptions].ajv));try{compileSchemasForValidation(d,i.validatorCompiler||this[kValidatorCompiler])}catch(e){throw new FST_ERR_SCH_VALIDATION_BUILD(i.method,u,e.message)}i.schema.response&&!i.serializerCompiler&&(!this[kSerializerCompiler]||this[kSerializerCompiler]&&e.hasNewSchemas())&&this.setSerializerCompiler(buildDefaultSerializer(e.getSchemas()));try{compileSchemasForSerialization(d,i.serializerCompiler||this[kSerializerCompiler])}catch(e){throw new FST_ERR_SCH_SERIALIZATION_BUILD(i.method,u,e.message)}}}),h(l)}}function y(e,r,t,o){if(!0===g&&(2!==e.httpVersionMajor&&(r.once("finish",()=>e.destroy()),r.setHeader("Connection","close")),m)){const e={"Content-Type":"application/json","Content-Length":"80"};return r.writeHead(503,e),void r.end('{"error":"Service Unavailable","message":"Service Unavailable","statusCode":503}')}const u=e.headers[i]||c(e),p={[a]:u,level:o.logLevel};o.logSerializers&&(p.serializers=o.logSerializers);const k=s.child(p);k[kDisableRequestLogging]=d;const f=e.url.indexOf("?"),S=n(f>-1?e.url.slice(f+1):""),R=new o.Request(u,t,e,S,k,o),y=new o.Reply(r,R,k);!1===d&&k.info({req:R},"incoming request"),!0!==l&&null===o.onResponse||h(y),null!==o.onRequest?hookRunner(o.onRequest,hookIterator,R,y,runPreParsing):runPreParsing(null,R,y),null!==o.onTimeout&&(R.raw.socket._meta||R.raw.socket.on("timeout",handleTimeout),R.raw.socket._meta={context:o,request:R,reply:y})}}function handleTimeout(){const{context:e,request:r,reply:t}=this._meta;hookRunner(e.onTimeout,hookIterator,r,t,noop)}function validateBodyLimitOption(e){if(void 0!==e&&(!Number.isInteger(e)||e<=0))throw new TypeError(`'bodyLimit' option must be an integer > 0. Got '${e}'`)}function runPreParsing(e,r,t){!0!==t.sent&&(null==e?(r[kRequestPayloadStream]=r.raw,null!==t.context.preParsing?preParsingHookRunner(t.context.preParsing,r,t,handleRequest):handleRequest(null,r,t)):t.send(e))}function preParsingHookRunner(e,r,t,o){let i=0;function n(l,h){if(t.sent)return;if(void 0!==h&&(r[kRequestPayloadStream]=h),l||i===e.length)return!l||l instanceof Error||(t[kReplyIsError]=!0),void o(l,r,t);const u=e[i++];let c;try{c=u[kHooksDeprecatedPreParsing]?u(r,t,n):u(r,t,r[kRequestPayloadStream],n)}catch(e){return void n(e)}c&&"function"==typeof c.then&&c.then(a,s)}function a(e){n(null,e)}function s(e){n(e)}n(null,r[kRequestPayloadStream])}function noop(){}module.exports={buildRouting:buildRouting,validateBodyLimitOption:validateBodyLimitOption};