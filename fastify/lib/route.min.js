"use strict";const FindMyWay=require("find-my-way"),Context=require("./context"),handleRequest=require("./handleRequest"),{hookRunner:hookRunner,hookIterator:hookIterator,lifecycleHooks:lifecycleHooks}=require("./hooks"),supportedMethods=["DELETE","GET","HEAD","PATCH","POST","PUT","OPTIONS"],{normalizeSchema:normalizeSchema}=require("./schemas"),{parseHeadOnSendHandlers:parseHeadOnSendHandlers}=require("./headRoute"),warning=require("./warnings"),{compileSchemasForValidation:compileSchemasForValidation,compileSchemasForSerialization:compileSchemasForSerialization}=require("./validation"),{FST_ERR_SCH_VALIDATION_BUILD:FST_ERR_SCH_VALIDATION_BUILD,FST_ERR_SCH_SERIALIZATION_BUILD:FST_ERR_SCH_SERIALIZATION_BUILD,FST_ERR_DEFAULT_ROUTE_INVALID_TYPE:FST_ERR_DEFAULT_ROUTE_INVALID_TYPE}=require("./errors"),{kRoutePrefix:kRoutePrefix,kLogLevel:kLogLevel,kLogSerializers:kLogSerializers,kHooks:kHooks,kHooksDeprecatedPreParsing:kHooksDeprecatedPreParsing,kSchemaController:kSchemaController,kOptions:kOptions,kContentTypeParser:kContentTypeParser,kReply:kReply,kReplySerializerDefault:kReplySerializerDefault,kReplyIsError:kReplyIsError,kRequest:kRequest,kRequestPayloadStream:kRequestPayloadStream,kDisableRequestLogging:kDisableRequestLogging,kSchemaErrorFormatter:kSchemaErrorFormatter,kErrorHandler:kErrorHandler}=require("./symbols.js");function buildRouting(e){const t=FindMyWay(e.config);let r,o,n,i,a,s,l,u,c,h,d,p,m,f,k=!1;return{setup(e,t){r=t.avvio,o=t.fourOhFour,s=t.logger,l=t.hasLogger,u=t.setupResponseListeners,c=t.throwIfAlreadyStarted,f=e.exposeHeadRoutes,n=e.requestIdHeader,i=e.querystringParser,a=e.requestIdLogLabel,h=e.genReqId,d=e.disableRequestLogging,p=e.ignoreTrailingSlash,m=!Object.prototype.hasOwnProperty.call(e,"return503OnClosing")||e.return503OnClosing},routing:t.lookup.bind(t),route:R,prepareRoute:g,getDefaultRoute:function(){return t.defaultRoute},setDefaultRoute:function(e){if("function"!=typeof e)throw new FST_ERR_DEFAULT_ROUTE_INVALID_TYPE;t.defaultRoute=e},routeHandler:S,closeRoutes:()=>{k=!0},printRoutes:t.prettyPrint.bind(t)};function g(e,t,r,o){if(o||"function"!=typeof r){if(o&&"function"==typeof o){if("[object Object]"!==Object.prototype.toString.call(r))throw new Error(`Options for ${e}:${t} route must be an object`);if(r.handler)throw"function"==typeof r.handler?new Error(`Duplicate handler for ${e}:${t} route is not allowed!`):new Error(`Handler for ${e}:${t} route must be a function`)}}else o=r,r={};return r=Object.assign({},r,{method:e,url:t,path:t,handler:o||r&&r.handler}),R.call(this,r)}function R(e){const n={...e};if(c("Cannot add route when fastify instance is already started!"),Array.isArray(n.method)){for(var i=0;i<n.method.length;i++)if(-1===supportedMethods.indexOf(n.method[i]))throw new Error(`${n.method[i]} method is not supported!`)}else if(-1===supportedMethods.indexOf(n.method))throw new Error(`${n.method} method is not supported!`);if(!n.handler)throw new Error(`Missing handler function for ${n.method}:${n.url} route.`);if(void 0!==n.errorHandler&&"function"!=typeof n.errorHandler)throw new Error(`Error Handler for ${n.method}:${n.url} route, if defined, must be a function`);validateBodyLimitOption(n.bodyLimit);const a=this[kRoutePrefix];return this.after((e,t)=>{const r=n.url||n.path;if("/"===r&&a.length>0&&"HEAD"!==n.method)switch(n.prefixTrailingSlash){case"slash":s.call(this,{path:r},e,t);break;case"no-slash":s.call(this,{path:""},e,t);break;case"both":default:s.call(this,{path:""},e,t),!0!==p&&s.call(this,{path:r,prefixing:!0},e,t)}else"/"===r[0]&&a.endsWith("/")?s.call(this,{path:r.slice(1)},e,t):s.call(this,{path:r},e,t)}),this;function s({path:i,prefixing:s=!1},l,u){const c=a+i;if(n.url=c,n.path=c,n.routePath=i,n.prefix=a,n.logLevel=n.logLevel||this[kLogLevel],(this[kLogSerializers]||n.logSerializers)&&(n.logSerializers=Object.assign(Object.create(this[kLogSerializers]),n.logSerializers)),null==n.attachValidation&&(n.attachValidation=!1),!1===s)for(const e of this[kHooks].onRoute)try{e.call(this,n)}catch(e){return void u(e)}const h={...n.config,url:c,method:n.method},d=new Context(n.schema,n.handler.bind(this),this[kReply],this[kRequest],this[kContentTypeParser],h,n.errorHandler||this[kErrorHandler],n.bodyLimit,n.logLevel,n.logSerializers,n.attachValidation,this[kReplySerializerDefault],n.schemaErrorFormatter||this[kSchemaErrorFormatter]),p=null!=t.find("HEAD",i);try{t.on(n.method,n.url,{version:n.version},S,d)}catch(e){return void u(e)}const{exposeHeadRoute:m}=n;if((null!=m?m:f)&&"GET"===e.method&&!p){const e=parseHeadOnSendHandlers(n.onSend);g.call(this,"HEAD",i,{...n,onSend:e})}else p&&m&&warning.emit("FSTDEP007");r.once("preReady",()=>{for(const e of lifecycleHooks){const t=this[kHooks][e].concat(n[e]||[]).map(t=>{const r=t.bind(this);return"preParsing"===e&&t.length===("AsyncFunction"===t.constructor.name?2:3)&&(warning.emit("FSTDEP004"),r[kHooksDeprecatedPreParsing]=!0),r});d[e]=t.length?t:null}if(o.setContext(this,d),n.schema){d.schema=normalizeSchema(d.schema);const e=this[kSchemaController];n.validatorCompiler||e.setupValidator(this[kOptions]);try{compileSchemasForValidation(d,n.validatorCompiler||e.validatorCompiler)}catch(e){throw new FST_ERR_SCH_VALIDATION_BUILD(n.method,c,e.message)}n.schema.response&&!n.serializerCompiler&&e.setupSerializer(this[kOptions]);try{compileSchemasForSerialization(d,n.serializerCompiler||e.serializerCompiler)}catch(e){throw new FST_ERR_SCH_SERIALIZATION_BUILD(n.method,c,e.message)}}}),u(l)}}function S(e,t,r,o){if(!0===k&&(2!==e.httpVersionMajor&&(t.once("finish",()=>e.destroy()),t.setHeader("Connection","close")),m)){const e={"Content-Type":"application/json","Content-Length":"80"};return t.writeHead(503,e),void t.end('{"error":"Service Unavailable","message":"Service Unavailable","statusCode":503}')}const c=e.headers[n]||h(e),p={[a]:c,level:o.logLevel};o.logSerializers&&(p.serializers=o.logSerializers);const f=s.child(p);f[kDisableRequestLogging]=d;const g=e.url.indexOf("?"),R=i(g>-1?e.url.slice(g+1):""),S=new o.Request(c,r,e,R,f,o),y=new o.Reply(t,S,f);!1===d&&f.info({req:S},"incoming request"),!0!==l&&null===o.onResponse||u(y),null!==o.onRequest?hookRunner(o.onRequest,hookIterator,S,y,runPreParsing):runPreParsing(null,S,y),null!==o.onTimeout&&(S.raw.socket._meta||S.raw.socket.on("timeout",handleTimeout),S.raw.socket._meta={context:o,request:S,reply:y})}}function handleTimeout(){const{context:e,request:t,reply:r}=this._meta;hookRunner(e.onTimeout,hookIterator,t,r,noop)}function validateBodyLimitOption(e){if(void 0!==e&&(!Number.isInteger(e)||e<=0))throw new TypeError(`'bodyLimit' option must be an integer > 0. Got '${e}'`)}function runPreParsing(e,t,r){!0!==r.sent&&(null==e?(t[kRequestPayloadStream]=t.raw,null!==r.context.preParsing?preParsingHookRunner(r.context.preParsing,t,r,handleRequest):handleRequest(null,t,r)):r.send(e))}function preParsingHookRunner(e,t,r,o){let n=0;function i(l,u){if(r.sent)return;if(void 0!==u&&(t[kRequestPayloadStream]=u),l||n===e.length)return!l||l instanceof Error||(r[kReplyIsError]=!0),void o(l,t,r);const c=e[n++];let h;try{h=c[kHooksDeprecatedPreParsing]?c(t,r,i):c(t,r,t[kRequestPayloadStream],i)}catch(e){return void i(e)}h&&"function"==typeof h.then&&h.then(a,s)}function a(e){i(null,e)}function s(e){i(e)}i(null,t[kRequestPayloadStream])}function noop(){}module.exports={buildRouting:buildRouting,validateBodyLimitOption:validateBodyLimitOption};