"use strict";const FindMyWay=require("find-my-way"),Context=require("./context"),handleRequest=require("./handleRequest"),{hookRunner,hookIterator,lifecycleHooks}=require("./hooks"),supportedMethods=["DELETE","GET","HEAD","PATCH","POST","PUT","OPTIONS"],normalizeSchema=require("./schemas")["normalizeSchema"],parseHeadOnSendHandlers=require("./headRoute")["parseHeadOnSendHandlers"],warning=require("./warnings"),kRequestAcceptVersion=require("./symbols")["kRequestAcceptVersion"],{compileSchemasForValidation,compileSchemasForSerialization}=require("./validation"),{FST_ERR_SCH_VALIDATION_BUILD,FST_ERR_SCH_SERIALIZATION_BUILD,FST_ERR_DEFAULT_ROUTE_INVALID_TYPE,FST_ERR_DUPLICATED_ROUTE,FST_ERR_INVALID_URL}=require("./errors"),{kRoutePrefix,kLogLevel,kLogSerializers,kHooks,kSchemaController,kOptions,kReplySerializerDefault,kReplyIsError,kRequestPayloadStream,kDisableRequestLogging,kSchemaErrorFormatter,kErrorHandler,kHasBeenDecorated}=require("./symbols.js"),buildErrorHandler=require("./error-handler")["buildErrorHandler"];function buildRouting(e){const d=e["keepAliveConnections"],c=FindMyWay(e.config);let u,h,m,p,f,R,g,k,i,y,S,n,E,v,L=!1;return{setup(e,r){u=r.avvio,h=r.fourOhFour,R=r.logger,g=r.hasLogger,k=r.setupResponseListeners,i=r.throwIfAlreadyStarted,v=e.exposeHeadRoutes,m=e.requestIdHeader,p=e.querystringParser,f=e.requestIdLogLabel,y=e.genReqId,S=e.disableRequestLogging,n=e.ignoreTrailingSlash,E=!Object.prototype.hasOwnProperty.call(e,"return503OnClosing")||e.return503OnClosing},routing:c.lookup.bind(c),route:a,prepareRoute:H,getDefaultRoute:function(){return c.defaultRoute},setDefaultRoute:function(e){if("function"!=typeof e)throw new FST_ERR_DEFAULT_ROUTE_INVALID_TYPE;c.defaultRoute=e},routeHandler:q,closeRoutes:()=>{L=!0},printRoutes:c.prettyPrint.bind(c)};function H(e,r,t,o){if("string"!=typeof r)throw new FST_ERR_INVALID_URL(typeof r);if(o||"function"!=typeof t){if(o&&"function"==typeof o){if("[object Object]"!==Object.prototype.toString.call(t))throw new Error(`Options for ${e}:${r} route must be an object`);if(t.handler)throw"function"==typeof t.handler?new Error(`Duplicate handler for ${e}:${r} route is not allowed!`):new Error(`Handler for ${e}:${r} route must be a function`)}}else o=t,t={};return t=Object.assign({},t,{method:e,url:r,path:r,handler:o||t&&t.handler}),a.call(this,t)}function a(l){const d={...l};i("Cannot add route when fastify instance is already started!");const e=d.url||d.path||"";if(Array.isArray(d.method))for(var r=0;r<d.method.length;++r)validateMethodAndSchemaBodyOption(d.method[r],e,d.schema);else validateMethodAndSchemaBodyOption(d.method,e,d.schema);if(!d.handler)throw new Error(`Missing handler function for ${d.method}:${e} route.`);if(void 0!==d.errorHandler&&"function"!=typeof d.errorHandler)throw new Error(`Error Handler for ${d.method}:${e} route, if defined, must be a function`);validateBodyLimitOption(d.bodyLimit);const o=this[kRoutePrefix];if("/"===e&&0<o.length&&"HEAD"!==d.method)switch(d.prefixTrailingSlash){case"slash":t.call(this,e);break;case"no-slash":t.call(this,"");break;default:t.call(this,""),!0!==n&&t.call(this,e,!0)}else"/"===e[0]&&o.endsWith("/")?t.call(this,e.slice(1)):t.call(this,e);return this;function t(i,e=!1){const n=o+i;if(d.url=n,d.path=n,d.routePath=i,d.prefix=o,d.logLevel=d.logLevel||this[kLogLevel],(this[kLogSerializers]||d.logSerializers)&&(d.logSerializers=Object.assign(Object.create(this[kLogSerializers]),d.logSerializers)),null==d.attachValidation&&(d.attachValidation=!1),!1===e)for(const t of this[kHooks].onRoute)t.call(this,d);const r=d.constraints||{};e={...d.config,url:n,method:d.method};const a=new Context({schema:d.schema,handler:d.handler.bind(this),config:e,errorHandler:d.errorHandler,bodyLimit:d.bodyLimit,logLevel:d.logLevel,logSerializers:d.logSerializers,attachValidation:d.attachValidation,schemaErrorFormatter:d.schemaErrorFormatter,replySerializer:this[kReplySerializerDefault],server:this});d.version&&(warning.emit("FSTDEP008"),r.version=d.version);const s="HEAD"===d.method&&null!=c.find(d.method,d.url,r);if(!s)try{c.on(d.method,d.url,{constraints:r},q,a)}catch(e){if(e.message.includes(`Method '${d.method}' already declared for route '${d.url}'`))throw new FST_ERR_DUPLICATED_ROUTE(d.method,d.url);throw e}this.after((e,r)=>{a.errorHandler=d.errorHandler?buildErrorHandler(this[kErrorHandler],d.errorHandler):this[kErrorHandler],a._parserOptions.limit=d.bodyLimit||null,a.logLevel=d.logLevel,a.logSerializers=d.logSerializers,a.attachValidation=d.attachValidation,a[kReplySerializerDefault]=this[kReplySerializerDefault],a.schemaErrorFormatter=d.schemaErrorFormatter||this[kSchemaErrorFormatter]||a.schemaErrorFormatter,u.once("preReady",()=>{for(const r of lifecycleHooks){var e=this[kHooks][r].concat(d[r]||[]).map(e=>e.bind(this));a[r]=e.length?e:null}for(;!a.Request[kHasBeenDecorated]&&a.Request.parent;)a.Request=a.Request.parent;for(;!a.Reply[kHasBeenDecorated]&&a.Reply.parent;)a.Reply=a.Reply.parent;if(h.setContext(this,a),d.schema){a.schema=normalizeSchema(a.schema,this.initialConfig);const t=this[kSchemaController];!d.validatorCompiler&&(d.schema.body||d.schema.headers||d.schema.querystring||d.schema.params)&&t.setupValidator(this[kOptions]);try{compileSchemasForValidation(a,d.validatorCompiler||t.validatorCompiler)}catch(e){throw new FST_ERR_SCH_VALIDATION_BUILD(d.method,n,e.message)}d.schema.response&&!d.serializerCompiler&&t.setupSerializer(this[kOptions]);try{compileSchemasForSerialization(a,d.serializerCompiler||t.serializerCompiler)}catch(e){throw new FST_ERR_SCH_SERIALIZATION_BUILD(d.method,n,e.message)}}});var t,o=d["exposeHeadRoute"];(null!=o?o:v)&&"GET"===l.method&&!s?(t=parseHeadOnSendHandlers(d.onSend),H.call(this,"HEAD",i,{...d,onSend:t})):s&&o&&warning.emit("FSTDEP007"),r(e)})}}function q(e,r,t,o){if(!0===L&&(2!==e.httpVersionMajor&&(r.once("finish",()=>e.destroy()),r.setHeader("Connection","close")),E))return r.writeHead(503,{"Content-Type":"application/json","Content-Length":"80"}),void r.end('{"error":"Service Unavailable","message":"Service Unavailable","statusCode":503}');"keep-alive"===String.prototype.toLowerCase.call(e.headers.connection||"")&&!1===d.has(e.socket)&&(d.add(e.socket),e.socket.on("close",removeTrackedSocket.bind({keepAliveConnections:d,socket:e.socket}))),void 0!==e.headers[kRequestAcceptVersion]&&(e.headers["accept-version"]=e.headers[kRequestAcceptVersion],e.headers[kRequestAcceptVersion]=void 0);var i=e.headers[m]||y(e),n={[f]:i};const a={level:o.logLevel};o.logSerializers&&(a.serializers=o.logSerializers);const s=R.child(n,a);s[kDisableRequestLogging]=S;n=e.url.indexOf("?"),n=p(-1<n?e.url.slice(n+1):"");const l=new o.Request(i,t,e,n,s,o);r=new o.Reply(r,l,s);!1===S&&s.info({req:l},"incoming request"),!0!==g&&null===o.onResponse||k(r),null!==o.onRequest?hookRunner(o.onRequest,hookIterator,l,r,runPreParsing):runPreParsing(null,l,r),null!==o.onTimeout&&(l.raw.socket._meta||l.raw.socket.on("timeout",handleTimeout),l.raw.socket._meta={context:o,request:l,reply:r})}}function handleTimeout(){var{context:e,request:r,reply:t}=this._meta;hookRunner(e.onTimeout,hookIterator,r,t,noop)}function validateMethodAndSchemaBodyOption(e,r,t){if(-1===supportedMethods.indexOf(e))throw new Error(`${e} method is not supported!`);if(("GET"===e||"HEAD"===e)&&t&&t.body)throw new Error(`Body validation schema for ${e}:${r} route is not supported!`)}function validateBodyLimitOption(e){if(void 0!==e&&(!Number.isInteger(e)||e<=0))throw new TypeError(`'bodyLimit' option must be an integer > 0. Got '${e}'`)}function runPreParsing(e,r,t){if(!0!==t.sent){if(null!=e)return t[kReplyIsError]=!0,void t.send(e);r[kRequestPayloadStream]=r.raw,null!==t.context.preParsing?preParsingHookRunner(t.context.preParsing,r,t,handleRequest):handleRequest(null,r,t)}}function preParsingHookRunner(o,i,n,a){let s=0;function l(e,r){if(!n.sent)if(void 0!==r&&(i[kRequestPayloadStream]=r),e||s===o.length)a(e,i,n);else{const t=o[s++];let e;try{e=t(i,n,i[kRequestPayloadStream],l)}catch(e){return void l(e)}e&&"function"==typeof e.then&&e.then(d,c)}}function d(e){l(null,e)}function c(e){l(e)}l(null,i[kRequestPayloadStream])}function removeTrackedSocket(){this.keepAliveConnections.delete(this.socket)}function noop(){}module.exports={buildRouting:buildRouting,validateBodyLimitOption:validateBodyLimitOption};