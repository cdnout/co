/*
 * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.
 * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2014, Orange
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/* Last build : 2019-2-13_11:37:25 / git revision : b21165b9 */

(function(root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module unless amdModuleId is set
        define([], function() {
            return (root['MediaPlayer'] = factory());
        });
    } else if (typeof exports === 'object') {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like environments that support module.exports,
        // like Node.
        module.exports = factory();
    } else {
        root['MediaPlayer'] = factory();
    }
}(this, function() {

var hasplayer = {},
    Mss = {},
    Hls = {},
    Dash = {},
    MediaPlayer = {},
    Q,
    goog,
    dijon;

/**
 * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.
 * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2014, Orange
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * @constructs MediaPlayer
 *
 */
/*jshint -W020 */

/**
 * @class
 * @classdesc MediaPlayer is the object used by the webapp to instanciante and control hasplayer.
 */
MediaPlayer = function () {

//#region Private attributes/properties
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////// PRIVATE ////////////////////////////////////////////
    var VERSION_DASHJS = '1.2.0',
        VERSION = '1.15.1',
        GIT_TAG = 'b21165b9',
        BUILD_DATE = '2019-2-13_11:37:25',
        context = new MediaPlayer.di.Context(), // default context
        system = new dijon.System(), // dijon system instance
        initialized = false,
        debugController = null, // use to handle key pressed and download debug file
        videoModel, // model to manipulate the domVideoNode
        videoBitrates = null, //bitrates list of video
        audioBitrates = null,
        videoQualityChanged = [],
        audioQualityChanged = [],
        error = null,
        warning = null,
        defaultAudioLang = 'und',
        defaultSubtitleLang = 'und',
        subtitlesEnabled = false,
        initialQuality = {
            video: -1,
            audio: -1
        },
        streamController = null,
        resetting = false,
        playing = false,
        autoPlay = true,
        source = null, // current source played
        scheduleWhilePaused = false, // should we buffer while in pause
        isSafari = (fingerprint_browser().name === "Safari"),
        plugins = {};
//#endregion

//#region Private methods
    var _isPlayerInitialized = function () {
        if (!initialized) {
            throw new Error('MediaPlayer not initialized !!!');
        }
    };

    var _isVideoModelInitialized = function () {
        if (!videoModel.getElement()) {
            throw new Error('MediaPlayer.play(): Video element not attached to MediaPlayer');
        }
    };

    var _isSourceInitialized = function () {
        if (!source) {
            throw new Error('MediaPlayer.play(): Source not attached to MediaPlayer');
        }
    };

    var _play = function () {
        var plugin,
            pluginsInitDefer = [],
            pluginsLoadDefer = [];

        _isPlayerInitialized();
        _isVideoModelInitialized();
        _isSourceInitialized();

        // Check MSE support
        // (except in case of HLS streams on Safari for which we do not use MSE)
        if (!(isSafari && source.protocol === 'HLS') && !MediaPlayer.hasMediaSourceExtension()) {
            this.errHandler.sendError(MediaPlayer.dependencies.ErrorHandler.prototype.CAPABILITY_ERR_MEDIASOURCE, "MediaSource extension not supported by the browser");
            return;
        }

        // Wait for plugins completely intialized before starting a new session
        for(var name in  plugins) {
            pluginsInitDefer.push(plugins[name].deferInit.promise);
        }
        Q.all(pluginsInitDefer).then((function () {
            // Notify plugins a new stream is loaded
            for (var name in plugins) {
                plugin = plugins[name];
                plugin.deferLoad = Q.defer();
                pluginsLoadDefer.push(plugin.deferLoad.promise);
                plugin.load(source, function () {
                    this.deferLoad.resolve();
                }.bind(plugin));
            }

            Q.all(pluginsLoadDefer).then((function () {
                // Once all plugins are ready, we load the stream
                playing = true;

                this.metricsModel.addSession(null, source.url, videoModel.getElement().loop, null, "MediaPlayer.js_" + this.getVersion());

                this.debug.log("[MediaPlayer] Version: " + this.getVersionFull() + " - " + this.getBuildDate());
                this.debug.log("[MediaPlayer] user-agent: " + navigator.userAgent);
                this.debug.log("[MediaPlayer] Load stream:\n", JSON.stringify(source, null, '  '));

                // streamController Initialization
                if (!streamController) {
                    streamController = system.getObject('streamController');
                    streamController.setVideoModel(videoModel);
                    streamController.setAutoPlay(autoPlay);
                }

                streamController.setDefaultAudioLang(defaultAudioLang);
                streamController.setDefaultSubtitleLang(defaultSubtitleLang);
                streamController.enableSubtitles(subtitlesEnabled);
                streamController.load(source);
                system.mapValue("scheduleWhilePaused", scheduleWhilePaused);
                system.mapOutlet("scheduleWhilePaused", "stream");

            }).bind(this));
        }).bind(this));
    };

    // player state and intitialization
    var _isReady = function () {
        return initialized && videoModel.getElement() && source && !resetting;
    };

    var _doAutoPlay = function () {
        if (_isReady()) {
            _play.call(this);
        }
    };

    // event disptach
    var _dispatchBitrateEvent = function (type, value) {
        var event = document.createEvent("CustomEvent");
        event.initCustomEvent(type, false, false, {
            type: value.streamType,
            bitrate: value.switchedQuality,
            representationId: value.representationId,
            time: videoModel.getCurrentTime(),
            width: value.width,
            height: value.height
        });
        videoModel.getElement().dispatchEvent(event);
    };

    var _metricAdded = function (e) {
        var event;
        switch (e.data.metric) {
            case "ManifestReady":
                _isPlayerInitialized();
                this.debug.log("[MediaPlayer] ManifestReady");
                videoBitrates = this.metricsExt.getBitratesForType('video');
                this.debug.log("[MediaPlayer] video bitrates: " + JSON.stringify(videoBitrates));
                event = document.createEvent("CustomEvent");
                event.initCustomEvent('manifest_loaded', false, false, {});
                videoModel.getElement().dispatchEvent(event);
                break;
            case "RepresentationSwitch":
                _isPlayerInitialized();
                if (e.data.stream == "video") {
                    videoBitrates = this.metricsExt.getBitratesForType(e.data.stream);
                    if (videoBitrates) {
                        _dispatchBitrateEvent('download_bitrate', {
                            streamType: e.data.stream,
                            switchedQuality: videoBitrates[e.data.value.lto],
                            representationId: e.data.value.to,
                            width: this.metricsExt.getVideoWidthForRepresentation(e.data.value.to),
                            height: this.metricsExt.getVideoHeightForRepresentation(e.data.value.to)
                        });
                        this.debug.log("[MediaPlayer][" + e.data.stream + "] send download_bitrate - b=" + videoBitrates[e.data.value.lto]);
                    }
                } else if (e.data.stream == "audio") {
                    audioBitrates = this.metricsExt.getBitratesForType(e.data.stream);
                    if (audioBitrates) {
                        _dispatchBitrateEvent('download_bitrate', {
                            streamType: e.data.stream,
                            switchedQuality: audioBitrates[e.data.value.lto],
                            representationId: e.data.value.to,
                            width: this.metricsExt.getVideoWidthForRepresentation(e.data.value.to),
                            height: this.metricsExt.getVideoHeightForRepresentation(e.data.value.to)
                        });
                        this.debug.log("[MediaPlayer][" + e.data.stream + "] send download_bitrate - b=" + videoBitrates[e.data.value.lto]);
                    }
                }
                break;
            case "BufferedSwitch":
                _isPlayerInitialized();
                if (e.data.stream == "video") {
                    videoQualityChanged.push({
                        streamType: e.data.stream,
                        mediaStartTime: e.data.value.mt,
                        switchedQuality: videoBitrates[e.data.value.lto],
                        representationId: e.data.value.to,
                        width: this.metricsExt.getVideoWidthForRepresentation(e.data.value.to),
                        height: this.metricsExt.getVideoHeightForRepresentation(e.data.value.to)
                    });
                } else if (e.data.stream == "audio") {
                    audioQualityChanged.push({
                        streamType: e.data.stream,
                        mediaStartTime: e.data.value.mt,
                        switchedQuality: audioBitrates[e.data.value.lto],
                        representationId: e.data.value.to,
                        width: this.metricsExt.getVideoWidthForRepresentation(e.data.value.to),
                        height: this.metricsExt.getVideoHeightForRepresentation(e.data.value.to)
                    });
                }
                break;
            case "BufferLevel":
                //this.debug.log("[MediaPlayer] BufferLevel = "+e.data.value.level+" for type = "+e.data.stream);
                event = document.createEvent("CustomEvent");
                event.initCustomEvent('bufferLevel_updated', false, false, {
                    type: e.data.stream,
                    level: e.data.value.level
                });
                videoModel.getElement().dispatchEvent(event);
                break;
            case "State":
                //this.debug.log("[MediaPlayer] State = "+e.data.value.current+" for type = "+e.data.stream);
                event = document.createEvent("CustomEvent");
                event.initCustomEvent('state_changed', false, false, {
                    type: e.data.stream,
                    state: e.data.value.current
                });
                videoModel.getElement().dispatchEvent(event);
                break;
        }
    };

    var _onError = function (e) {
        error = e.data;
        this.reset(2);
    };

    var _onWarning = function (e) {
        warning = e.data;
    };

    var _cleanStreamTab = function (streamTab, idToRemove) {
        var i = 0;

        for (i = idToRemove.length - 1; i >= 0; i -= 1) {
            streamTab.splice(i, 1);
        }
    };

    var _detectPlayBitrateChange = function (streamTab) {
        var currentTime = videoModel.getCurrentTime(),
            currentSwitch = null,
            idToRemove = [],
            i = 0;

        for (i = 0; i < streamTab.length; i += 1) {
            currentSwitch = streamTab[i];
            if (currentTime >= currentSwitch.mediaStartTime) {
                _dispatchBitrateEvent('play_bitrate', currentSwitch);
                this.debug.log("[MediaPlayer][" + currentSwitch.streamType + "] send play_bitrate - b=" + currentSwitch.switchedQuality + ", t=" + currentSwitch.mediaStartTime + "(" + videoModel.getPlaybackRate() + ")");
                // And remove when it's played
                idToRemove.push(i);
            }
        }

        _cleanStreamTab(streamTab, idToRemove);
    };

    // Usefull to dispatch event of quality changed
    var _onTimeupdate = function () {
        // If not in playing state, then do not send 'play_bitrate' events, wait for 'loadeddata' event first
        if (videoModel.getPlaybackRate() === 0) {
            return;
        }
        // Check for video playing quality change
        _detectPlayBitrateChange.call(this, videoQualityChanged);
        // Check for audio playing quality change
        _detectPlayBitrateChange.call(this, audioQualityChanged);
    };

    // event connection
    var _connectEvents = function () {
        this.addEventListener('metricAdded', _metricAdded.bind(this));
        this.addEventListener('error', _onError.bind(this));
        this.addEventListener('warning', _onWarning.bind(this));
        this.addEventListener('timeupdate', _onTimeupdate.bind(this));
    };

    // Keyboard handler to display version
    var _handleKeyPressedEvent = function(e) {
        // If Ctrl+Alt+Shift+d is pressed then display MediaPlayer version and plugins versions
        if (e.altKey === true && e.ctrlKey === true && e.shiftKey === true && e.keyCode === 86) {
            console.log('[MediaPlayer] Version: ' + this.getVersion() + ' - ' + this.getBuildDate());
            for (var plugin in plugins) {
                console.log('[' + plugins[plugin].getName() + '] Version: ' + plugins[plugin].getVersion() + ' - ' + plugins[plugin].getBuildDate());
            }
            
        }
    };

    /// Private playback functions ///
    var _resetAndPlay = function (reason) {
        if (playing && streamController) {
            if (!resetting) {
                resetting = true;

                var teardownComplete = {};
                teardownComplete[MediaPlayer.dependencies.StreamController.eventList.ENAME_TEARDOWN_COMPLETE] = (function () {

                    // Notify plugins that player is reset
                    for (var plugin in plugins) {
                        plugins[plugin].reset();
                    }

                    // Finish rest of shutdown process
                    streamController = null;
                    playing = false;

                    resetting = false;

                    this.debug.log("[MediaPlayer] Player is stopped");

                    if (_isReady.call(this)) {
                        _doAutoPlay.call(this);
                    }
                }).bind(this);
                streamController.subscribe(MediaPlayer.dependencies.StreamController.eventList.ENAME_TEARDOWN_COMPLETE, teardownComplete, undefined, true);
                streamController.reset(reason);
            }
        } else {
            if (_isReady.call(this)) {
                _doAutoPlay.call(this);
            }
        }
    };

    var _toMediaPlayerTrack = function (track) {
        if (!track) {
            return null;
        }
        var _track = {};
        if (track.id) {
            _track.id = track.id;
        }
        if (track.lang) {
            _track.lang = track.lang;
        }
        if (track.subType) {
            _track.subType = track.subType;
        }
        return _track;
    };

    var _getTracksFromType = function (_type) {
        if (!streamController) {
            return null;
        }
        switch (_type) {
            case MediaPlayer.TRACKS_TYPE.AUDIO:
                return streamController.getAudioTracks();
            case MediaPlayer.TRACKS_TYPE.TEXT:
                return streamController.getSubtitleTracks();
        }
        return null;
    };

    var _getSelectedTrackFromType = function (_type) {
        if (!streamController) {
            return null;
        }
        switch (_type) {
            case MediaPlayer.TRACKS_TYPE.AUDIO:
                return streamController.getSelectedAudioTrack();
            case MediaPlayer.TRACKS_TYPE.TEXT:
                return streamController.getSelectedSubtitleTrack();
        }
        return null;
    };

    var _selectTrackFromType = function (_type, _track) {
        if (!streamController) {
            return null;
        }
        switch (_type) {
            case MediaPlayer.TRACKS_TYPE.AUDIO:
                streamController.setAudioTrack(_track);
                break;
            case MediaPlayer.TRACKS_TYPE.TEXT:
                streamController.setSubtitleTrack(_track);
                break;
        }
        return null;
    };

    var _isEqual = function (prop1, prop2) {
        if (!prop1 && !prop2) {
            // let's consider in this case that null and undefined are equal
            return true;
        }
        return prop1 === prop2;
    };

    var _isSameTrack = function (track1, track2) {
        return (_isEqual(track1.id, track2.id) && _isEqual(track1.lang, track2.lang) && _isEqual(track1.subType, track2.subType));
    };

    // parse the arguments of load function to make an object
    var _parseLoadArguments = function () {
        if (arguments && arguments.length > 0) {
            var params = {};
            // restaure url
            if (typeof arguments[0] === 'string') {
                params.url = arguments[0];
            }
            //restaure protData
            if (arguments[1]) {
                params.protData = arguments[1];
            }
            return params;
        }

    };

    var _getDVRInfoMetric = function () {
        var metrics = this.metricsModel.getReadOnlyMetricsFor('video'),
            dvrInfo = metrics ? this.metricsExt.getCurrentDVRInfo(metrics) : null;
        return dvrInfo;
    };

//#endregion

//#region DIJON initialization
    system.mapValue('system', system);
    system.mapOutlet('system');
    system.injectInto(context);
//#endregion

    return {
        ///////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////// PUBLIC /////////////////////////////////////////////
//#region dependencies
        notifier: undefined,
        debug: undefined,
        eventBus: undefined,
        metricsExt: undefined,
        abrController: undefined,
        metricsModel: undefined,
        errHandler: undefined,
        config: undefined,
//#endregion

//#region VERSION
        /**
         * Returns the version of the player.
         * @method getVersion
         * @access public
         * @memberof MediaPlayer#
         * @return {string} the version of the player
         */
        getVersion: function () {
            return VERSION;
        },

        /**
         * Returns the full version of the player (including git tag).
         * @method getVersionFull
         * @access public
         * @memberof MediaPlayer#
         * @return {string} the version of the player including git tag
         */
        getVersionFull: function () {
            if (GIT_TAG.indexOf("@@") === -1) {
                return VERSION + '_' + GIT_TAG;
            } else {
                return VERSION;
            }
        },

        /**
         * Returns the version of dash.js from which this player has been built.
         * @method getVersionDashJS
         * @access public
         * @memberof MediaPlayer#
         * @return {string} the dash.js version
         */
        getVersionDashJS: function () {
            return VERSION_DASHJS;
        },

        /**
         * Returns the date at which this player has been built.
         * @access public
         * @memberof MediaPlayer#
         * @return {string} the date at which this player has been built
         */
        getBuildDate: function () {
            if (BUILD_DATE.indexOf("@@") === -1) {
                return BUILD_DATE;
            } else {
                return 'Not a builded version';
            }
        },
//#endregion

//#region INIT
        /**
         * Initialize the player.
         * @method init
         * @access public
         * @memberof MediaPlayer#
         * @param {Object} video - the HTML5 video element used to decode and render the media data
         */
        init: function (video) {
            if (!video) {
                throw new Error('MediaPlayer.init(): Invalid Argument');
            }
            if (!initialized) {
                system.injectInto(this);
                initialized = true;
                this.debug.log("[MediaPlayer] Version: " + this.getVersionFull() + " - " + this.getBuildDate());
                this.debug.log("[MediaPlayer] user-agent: " + navigator.userAgent);
            }
            videoModel = system.getObject('videoModel');
            videoModel.setElement(video);

            // in case of init is called another time
            /*if (playing && streamController) {
                streamController.reset();
                playing = false;
            }*/

            // connect default events
            _connectEvents.call(this);
            //debugController.init();

            // create DebugController
            debugController = system.getObject('debugController');
            debugController.init(VERSION);

            window.addEventListener('keydown', _handleKeyPressedEvent.bind(this));            
        },
//#endregion

//#region LISTENERS
        /**
         * Registers a listener on the specified event.
         * The possible event types are:
         * <li>'error' (see [error]{@link MediaPlayer#event:error} event specification)
         * <li>'warning' (see [warning]{@link MediaPlayer#event:warning} event specification)
         * <li>'manifestUrlUpdate' (see [manifestUrlUpdate]{@link MediaPlayer#event:manifestUrlUpdate} event specification)
         * <li>'play_bitrate' (see [play_bitrate]{@link MediaPlayer#event:play_bitrate} event specification)
         * <li>'download_bitrate' (see [download_bitrate]{@link MediaPlayer#event:download_bitrate} event specification)
         * <li>'bufferLevel_updated' (see [bufferLevel_updated]{@link MediaPlayer#event:bufferLevel_updated} event specification)
         * <li>'state_changed' (see [state_changed]{@link MediaPlayer#event:state_changed} event specification)
         * <li>'cueEnter' (see [cueEnter]{@link MediaPlayer#event:cueEnter} event specification)
         * <li>'cueExit' (see [cueExit]{@link MediaPlayer#event:cueExit} event specification)
         * @method addEventListener
         * @access public
         * @memberof MediaPlayer#
         * @param {string} type - the event type for listen to, either any HTML video element event or player event.
         * @param {callback} listener - the callback which is called when an event of the specified type occurs
         * @param {boolean} useCapture - see HTML DOM addEventListener() method specification
         */
        addEventListener: function (type, listener, useCapture) {
            _isPlayerInitialized();
            if (MediaPlayer.PUBLIC_EVENTS[type] === 'hasplayer') {
                this.eventBus.addEventListener(type, listener, useCapture);
            } else {
                videoModel.listen(type, listener, useCapture);
            }
        },

        /**
         * Unregisters the listener previously registered with the addEventListener() method.
         * @method removeEventListener
         * @access public
         * @memberof MediaPlayer#
         * @see [addEventListener]{@link MediaPlayer#addEventListener}
         * @param {string} type - the event type on which the listener was registered
         * @param {callback} listener - the callback which was registered to the event type
         */
        removeEventListener: function (type, listener) {
            _isPlayerInitialized();
            if (MediaPlayer.PUBLIC_EVENTS[type] === 'hasplayer') {
                this.eventBus.removeEventListener(type, listener);
            } else {
                videoModel.unlisten(type, listener);
            }
        },
//#endregion

//#region COMPONENTS GETTER
        /**
         * Returns the video model object.
         * @access public
         * @memberof MediaPlayer#
         * @return {object} the video model object
         */
        getVideoModel: function() {
            return videoModel;
        },

        /**
         * Returns the debug object.
         * @access public
         * @memberof MediaPlayer#
         * @return {object} the debug object
         */
        getDebug: function () {
            return this.debug;
        },

        /**
         * Returns the metrics extension object.
         * @access public
         * @memberof MediaPlayer#
         * @return {object} the metrics extension object
         */
        getMetricsExt: function () {
            return this.metricsExt;
        },
//#endregion

//#region CONFIG
        /**
         * Sets player configuration parameters.
         * @access public
         * @memberof MediaPlayer#
         * @param {MediaPlayer#PlayerParams} params - parameter(s) value(s) to set.
         */
        setConfig: function (params) {
            if (this.config && params) {
                this.debug.log("[MediaPlayer] set config: " + JSON.stringify(params, null, '\t'));
                this.config.setParams(params);
            }
        },
        setParams: function (params) {
            this.setConfig(params);
        },

        /**
         * Enables or disables debug information in the browser console.
         * @method setDebug
         * @access public
         * @memberof MediaPlayer#
         * @param {boolean} value - true to enable debug information, false to disable
         */
        setDebug: function (value) {
            _isPlayerInitialized();
            if (typeof value !== 'boolean') {
                throw new Error('MediaPlayer.setDebug(): Invalid Arguments');
            }
            if (value === true) {
                this.debug.setLevel(4);
            } else {
                this.debug.setLevel(0);
            }
        },

        /**
         * Returns the autoplay state.
         * @access public
         * @memberof MediaPlayer#
         * @return {boolean} the autoplay state
         */
        getAutoPlay: function () {
            return autoPlay;
        },

        /**
         * Sets the autoplay state.
         * @access public
         * @memberof MediaPlayer#
         * @param {boolean} value - true to activate autoplay, false to disable autoplay
         */
        setAutoPlay: function (value) {
            autoPlay = value;
        },

        /**
         * Sets the initial quality to be downloaded for the given track type.
         * This method has to be used before each call to load() method to set the initial quality.
         * Otherwise, the initial quality is set according to previous bandwidth condition.
         * @access public
         * @memberof MediaPlayer#
         * @see [setConfig]{@link MediaPlayer#setConfig} to set quality boundaries
         * @param {string} type - the track type ('video' or 'audio')
         * @param {number} value - the new initial quality index (starting from 0) to be downloaded
         */
        setInitialQualityFor: function (type, value) {
            initialQuality[type] = value;
        },

        /**
         * Returns the current quality for a stream type.
         * @access public
         * @memberof MediaPlayer#
         * @param {string} type - stream type, 'video' or 'audio'
         * @return {number} the current quality level as an index of the quality (in bitrate ascending order)
         */
        getQualityFor: function (type) {
            _isPlayerInitialized();
            return this.abrController.getQualityFor(type);
        },

        /**
         * Selects the quality for a stream type.
         * @access public
         * @memberof MediaPlayer#
         * @param {string} type - stream type, 'video' or 'audio'
         * @param {number} value - the selected quality level as an index of the quality (in bitrate ascending order)
         */
        setQualityFor: function (type, value) {
            _isPlayerInitialized();
            if (typeof value !== 'number') {
                throw new Error('MediaPlayer.setQualityFor(): Invalid Arguments');
            }
            this.abrController.setQualityFor(type, value);
        },

        /**
         * Returns the auto switch quality state.
         * @access public
         * @memberof MediaPlayer#
         * @return {boolean} the auto switch quality state
         */
        getAutoSwitchQuality: function() {
            _isPlayerInitialized();
            return this.abrController.getAutoSwitchBitrate();
        },

        /**
         * Sets the auto switch quality state.
         * @access public
         * @memberof MediaPlayer#
         * @param {boolean} value - the new auto switch quality state
         */
        setAutoSwitchQuality: function(value) {
            _isPlayerInitialized();
            if (typeof value !== 'boolean') {
                throw new Error('MediaPlayer.setAutoSwitchQuality(): Invalid Arguments');
            }
            this.abrController.setAutoSwitchBitrate(value);
        },

        /**
         * Returns the buffering behaviour while the player is in pause.
         * @access public
         * @memberof MediaPlayer#
         * @return {boolean} true if the player still buffers stream while in pause
         */
        getScheduleWhilePaused: function () {
            return scheduleWhilePaused;
        },

        /**
         * Sets the buffering behaviour while player is in pause.
         * @access public
         * @memberof MediaPlayer#
         * @param {boolean} value - true if the player has to buffer stream while in pause
         */
        setScheduleWhilePaused: function (value) {
            if (typeof value !== 'boolean') {
                throw new Error('MediaPlayer.setScheduleWhilePaused(): Invalid Arguments');
            }
            scheduleWhilePaused = value;
        },

        /**
         * Sets the default audio language. If the default language is available in the stream,
         * the corresponding audio track is selected. Otherwise, the first declared audio track in the manifest is selected.
         * @method setDefaultAudioLang
         * @access public
         * @memberof MediaPlayer#
         * @param {string} lang - the default audio language based on ISO 3166-2
         */
        setDefaultAudioLang: function (language) {
            if (typeof language !== 'string') {
                throw new Error('MediaPlayer.setDefaultAudioLang(): Invalid Arguments');
            }
            defaultAudioLang = language;
        },

        /**
         * Gets the default audio language.
         * @method getDefaultAudioLang
         * @access public
         * @memberof MediaPlayer#
         * @return {string} lang - the default audio language based on ISO 3166-2
         */
        getDefaultAudioLang: function(){
            return defaultAudioLang;
        },

        /**
         * Sets the default subtitle language. If the default language is available in the stream,
         * the corresponding subtitle track is selected. Otherwise, the first declared subtitle track in the manifest is selected.
         * @method setDefaultSubtitleLang
         * @access public
         * @memberof MediaPlayer#
         * @param {string} lang - the default subtitle language based on ISO 3166-2
         */
        setDefaultSubtitleLang: function (language) {
            if (typeof language !== 'string') {
                throw new Error('MediaPlayer.setDefaultSubtitleLang(): Invalid Arguments');
            }
            defaultSubtitleLang = language;
        },

        /**
         * Gets the default subtitle language.
         * @method getDefaultSubtitleLang
         * @access public
         * @memberof MediaPlayer#
         * @return {string} lang - the default subtitle language based on ISO 3166-2
         */
        getDefaultSubtitleLang: function () {
            return defaultSubtitleLang;
        },
//#endregion

//#region PLAYBACK
        /**
         * Load/open a video stream.
         * @method load
         * @access public
         * @memberof MediaPlayer#
         * @param {object} stream - video stream properties object such url, startTime, prodData ...
            <pre>
            {
                url : "[manifest url]",
                startTime : [start time in seconds (optional, only for static streams)],
                startOver : [true if start-over DVR stream (optional)],
                protocol : "[protocol type]", // 'HLS' to activate native support on Safari/OSx
                protData : {
                    // one entry for each key system ('com.microsoft.playready' or 'com.widevine.alpha')
                    "[key_system_name]": {
                        laURL: "[licenser url (optional)]",
                        withCredentials: "[license_request_withCredentials_value (true or false, optional)]",
                        cdmData: "[CDM data (optional)]", // Supported by PlayReady key system (using MS-prefixed EME API) only
                        serverCertificate: "[license_server_certificate (as Base64 string, optional)]",
                        audioRobustness: "[audio_robustness_level (optional)]", // Considered for Widevine key system only
                        videoRobustness: "[video_robustness_level (optional)]" // Considered for Widevine key system only
                    },
                    ...
               }
               ...
            }
            </pre>
        */
        load: function (stream) {
            var config = {
                    video: {
                        "ABR.keepBandwidthCondition": true
                    },
                    audio: {
                        "ABR.keepBandwidthCondition": true
                    }
                };

            // patch to be retro compatible with old syntax
            if (arguments && arguments.length > 0 && typeof arguments[0] !== 'object') {
                console.warn('You are using "deprecated" call of the method load, please refer to the documentation to change prameters call');
                stream = _parseLoadArguments.apply(null, arguments);
            }

            if(!stream || !stream.url){
                 throw new Error('MediaPlayer.load(): stream has no url.');
            }

            videoQualityChanged = [];
            audioQualityChanged = [];

            _isPlayerInitialized();

            // Reset the player
            this.reset(0);

            // Set initial quality if first stream
            if (initialQuality.video >= 0) {
                this.abrController.setQualityFor('video', initialQuality.video);
                config.video["ABR.keepBandwidthCondition"] = false;
                initialQuality.video = -1;
            }

            if (initialQuality.audio >= 0) {
                this.abrController.setQualityFor('audio', initialQuality.audio);
                config.audio["ABR.keepBandwidthCondition"] = false;
                initialQuality.audio = -1;
            }

            // Set config to set 'keepBandwidthCondition' parameter
            this.setConfig(config);

            // Reset last error and warning
            error = null;
            warning = null;

            source = stream;
            _resetAndPlay.call(this, 0);
        },

        /**
        * Plays/resumes playback of the media.
        * @method play
        * @access public
        * @memberof MediaPlayer#
        */
        play: function () {
            _isPlayerInitialized();
            videoModel.play();
        },

        /**
         * Seeks the media to the new time. For LIVE streams, this function can be used to perform seeks within the DVR window if available.
         * @method seek
         * @access public
         * @memberof MediaPlayer#
         * @param {number} time - the new time value in seconds
         */
        seek: function (time) {
            var range = null,
                liveDelay = 0;

            _isPlayerInitialized();

            if (typeof time !== 'number' || isNaN(time)) {
                throw new Error('MediaPlayer.seek(): Invalid Arguments');
            }

            if (!this.isLive()) {
                if (time < 0 || time > videoModel.getDuration()) {
                    throw new Error('MediaPlayer.seek(): seek value outside available time range');
                } else {
                    videoModel.setCurrentTime(time);
                }
            } else {
                range = this.getDVRWindowRange();
                liveDelay = streamController.getLiveDelay();
                if (range === null) {
                    throw new Error('MediaPlayer.seek(): impossible for live stream');
                } else if (time < range.start || time > range.end) {
                    throw new Error('MediaPlayer.seek(): seek value outside available time range');
                } else {
                    // Ensure we keep enough buffer
                    if (time > (range.end - liveDelay)) {
                        time = range.end - liveDelay;
                    }
                    streamController.seek(time, true);
                }
            }
        },

        /**
         * Pauses the media playback.
         * @method pause
         * @access public
         * @memberof MediaPlayer#
         */
        pause: function () {
            _isPlayerInitialized();
            videoModel.pause();
        },

        /**
         * Stops the media playback and seek back to start of stream and media. Subsequently call to play() method will restart streaming and playing from beginning.
         * @method stop
         * @access public
         * @memberof MediaPlayer#
         */
        stop: function () {
            _isPlayerInitialized();
            videoModel.pause();
            //test if player is in VOD mode
            if (!this.isLive()) {
                videoModel.setCurrentTime(0);
            }

            // Notify plugins that current stream is stopped
            for (var plugin in plugins) {
                plugins[plugin].stop();
            }
        },

        /**
         * Stops and resets the player.
         * @method reset
         * @access public
         * @memberof MediaPlayer#
         * @param {number} reason - the reason for stopping the player.
         * Possible values are:
         * <li>0 : stop during streaming at user request
         * <li>1 : stop when all streams are completed
         * <li>2 : stop after an error
         */
        reset: function (reason) {
            _isPlayerInitialized();

            // Reset ABR controller
            this.setQualityFor('video', 0);
            this.setQualityFor('audio', 0);

            source = null;

            _resetAndPlay.call(this, reason);
        },

        /**
        * Updates the manifest URL. This method is used to provide an update of the manifest URL when the original
        * URL provided in load() method is no more valid (for example if it has expired when signed)
        * (see [manifestUrlUpdate]{@link MediaPlayer#event:manifestUrlUpdate} event specification).
        * @method refeshManifest
        * @access public
        * @memberof MediaPlayer#
        * param {string} url - the updated video stream's manifest URL
        */
        refreshManifest: function (url) {
            _isPlayerInitialized();
            streamController.refreshManifest(url);
        },
//#endregion

//#region STREAM METADATA
        /**
         * Returns the media duration.
         * @method getDuration
         * @access public
         * @memberof MediaPlayer#
         * @return {number} the media duration in seconds, <i>Infinity</i> for live content
         */
        getDuration: function () {
            _isPlayerInitialized();
            return videoModel.getDuration();
        },

        /**
         * Returns true if the current stream is a live stream.
         * @method isLive
         * @access public
         * @memberof MediaPlayer#
         * @return {boolean} true if current stream is a live stream, false otherwise
         */
        isLive: function () {
            _isPlayerInitialized();
            return videoModel.getDuration() !== Number.POSITIVE_INFINITY ? false : true;
        },

        /**
         * Returns the current playback time/position.
         * @method getPosition
         * @access public
         * @memberof MediaPlayer#
         * @return {number} the current playback time/position in seconds
         */
        getPosition: function () {
            _isPlayerInitialized();
            return videoModel.getCurrentTime();
        },

        /**
         * Return the available DVR window range in case of live streams.
         * @method getDVRWindowRange
         * @access public
         * @memberOf MediaPlayer#
         * @return {object} range - the DVR window range
         * @return {number} range.start - the DVR window range start time
         * @return {number} range.end - the DVR window range end time
         * @return {number} range.programStart - the DVR window range absolute program start date/time (if available, may be undefined)
         * @return {number} range.programEnd - the DVR window range absolute program end date/time (if available, may be undefined)
         */
        getDVRWindowRange: function () {
            _isPlayerInitialized();
            if (!this.isLive()) {
                return null;
            }
            var dvrInfo = _getDVRInfoMetric.call(this);
            return dvrInfo ? dvrInfo.range : null;
        },

        /**
         * Returns the DVR window size.
         * @method getDVRWindowSize
         * @access public
         * @memberof MediaPlayer#
         * @return {number} the DVR window size in seconds
         */
        getDVRWindowSize: function () {
            _isPlayerInitialized();
            if (!this.isLive()) {
                return null;
            }
            // TODO: get timeShiftBufferDepth
            return null;
            // var dvrInfo = _getDVRInfoMetric();
            // return dvrInfo ? dvrInfo.mpd.timeShiftBufferDepth : null;;
        },

        /**
         * TBD
         * @method getDVRSeekOffset
         * @access public
         * @memberof MediaPlayer#
         * @param  value
         * @return DVR seek offset
         */
        getDVRSeekOffset: function (value) {
            _isPlayerInitialized();
            if (!this.isLive()) {
                return null;
            }
            var dvrInfo = _getDVRInfoMetric.call(this),
                val = dvrInfo ? dvrInfo.range.start + value : null;

            if (val && val > dvrInfo.range.end) {
                val = dvrInfo.range.end;
            }

            return val;
        },

        /**
         * Returns the list of available bitrates (in bitrate ascending order).
         * @method getVideoBitrates
         * @access public
         * @memberof MediaPlayer#
         * @return {Array<Number>} array of bitrate values
         */
        getVideoBitrates: function () {
            _isPlayerInitialized();
            if (!videoBitrates) {
                return [];
            }
            return videoBitrates.slice();
        },

        /**
         * Returns the metrics for stream type.
         * @access public
         * @memberof MediaPlayer#
         * @param {string} type - stream type, 'video' or 'audio'
         * @return {Array} the metrics array for the selected type
         */
        getMetricsFor: function(type) {
            var metrics = this.metricsModel.getReadOnlyMetricsFor(type);
            return metrics;
        },
//#endregion

//#region TRICK MODE
        /////////// TRICK MODE
        /**
         * Returns the current trick mode speed.
         * @method setTrickModeSpeed
         * @access public
         * @memberof MediaPlayer#
         * @return {number} the current trick mode speed
         */
        getTrickModeSpeed: function () {
            if (streamController) {
                return streamController.getTrickModeSpeed();
            }

            return 0;
        },

        /**
         * Sets the trick mode speed.
         * @method setTrickModeSpeed
         * @access public
         * @memberof MediaPlayer#
         * @param {number} speed - the new trick mode speed (0 corresponds to normal playback, i.e. playbackRate = 1)
         */
        setTrickModeSpeed: function (speed) {
            _isPlayerInitialized();
            if (streamController) {
                streamController.setTrickModeSpeed(speed);
            }
        },
//#endregion

//#region ERROR/WARNING
        /**
         * Returns the Error object for the most recent error.
         * @method getError
         * @access public
         * @memberof MediaPlayer#
         * @return {object} the Error object for the most recent error, or null if there has not been an error
        */
        getError: function () {
            return error;
        },

        /**
         * Returns the Warning object for the most recent warning.
         * @method getWarning
         * @access public
         * @memberof MediaPlayer#
         * @return {object} the Warning object for the most recent warning, or null if there has not been a warning
         */
        getWarning: function () {
            return warning;
        },
//#endregion

//#region TRACKS
        /**
         * Returns the list of available tracks for the stream type (as specified in the stream manifest).
         * The tracks list can be retrieved once the video 'loadeddata' event has been fired.
         * @method getTracks
         * @access public
         * @param {String} type - the stream type according to MediaPlayer.TRACKS_TYPE (see @link MediaPlayer#TRACKS_TYPE)
         * @memberof MediaPlayer#
         * @return {Array<Track>} the available tracks for the stream type
         */
        getTracks: function (type) {

            _isPlayerInitialized();

            if (!type || (type !== MediaPlayer.TRACKS_TYPE.AUDIO && type !== MediaPlayer.TRACKS_TYPE.TEXT)) {
                throw new Error('MediaPlayer Invalid Argument - "type" should be defined and shoud be kind of MediaPlayer.TRACKS_TYPE');
            }

            var _tracks = _getTracksFromType(type);

            if (!_tracks) {
                return [];
            }

            var tracks = [];
            for (var i = 0; i < _tracks.length; i += 1) {
                tracks.push(_toMediaPlayerTrack(_tracks[i]));
            }

            return tracks;
        },

        /**
         * Selects the track to be playbacked for the stream type.
         * @method selectTrack
         * @access public
         * @memberof MediaPlayer#
         * @see [getTracks]{@link MediaPlayer#getTracks}
         * @param {String} type - the stream type according to MediaPlayer.TRACKS_TYPE (see @link MediaPlayer#TRACKS_TYPE)
         * @param {Track} track - the track to select, as returned by the [getTracks]{@link MediaPlayer#getTracks} method
         *
         */
        selectTrack: function (type, track) {

            _isPlayerInitialized();

            if (!type || (type !== MediaPlayer.TRACKS_TYPE.AUDIO && type !== MediaPlayer.TRACKS_TYPE.TEXT)) {
                throw new Error('MediaPlayer Invalid Argument - "type" should be defined and shoud be kind of MediaPlayer.TRACKS_TYPE');
            }

            if (!track || !(track.id || track.lang || track.subType)) {
                throw new Error('MediaPlayer.selectTrack(): track parameter is not in valid');
            }

            var _tracks = _getTracksFromType(type);

            if (!_tracks) {
                this.debug.error("[MediaPlayer] No available track for type " + type);
                return;
            }
            var selectedTrack = _getSelectedTrackFromType(type);

            if (selectedTrack && _isSameTrack(selectedTrack, track)) {
                this.debug.log("[MediaPlayer] " + type + " track [" + track.id + " - " + track.lang + "] is already selected");
                return;
            }

            for (var i = 0; i < _tracks.length; i += 1) {
                if (_isSameTrack(_tracks[i], track)) {
                    _selectTrackFromType(type, _tracks[i]);
                    return;
                }
            }
        },

        /**
         * Returns the selected track for the stream type.
         * @method getSelectedTrack
         * @access public
         * @memberof MediaPlayer#
         * @param {String} type - the stream type according to MediaPlayer.TRACKS_TYPE (see @link MediaPlayer#TRACKS_TYPE)
         * @return {Track} the selected track
         */
        getSelectedTrack: function (type) {
            _isPlayerInitialized();

            if (!type || (type !== MediaPlayer.TRACKS_TYPE.AUDIO && type !== MediaPlayer.TRACKS_TYPE.TEXT)) {
                throw new Error('MediaPlayer Invalid Argument - "type" should be defined and shoud be kind of MediaPlayer.TRACKS_TYPE');
            }

            return _toMediaPlayerTrack(_getSelectedTrackFromType(type));
        },
//#endregion

//#region SUBTITLES DISPLAY
        /**
         * Enable or disables subtitles processing.
         * @method enableSubtitles
         * @access public
         * @memberof MediaPlayer#
         * @param {boolean} value - true to enable subtitles, false to disables subtitles processing (by default subtitles are disabled)
         */
        enableSubtitles: function (value) {
            _isPlayerInitialized();
            if (typeof value !== 'boolean') {
                throw new Error('MediaPlayer.enableSubtitles(): Invalid Arguments');
            }
            subtitlesEnabled = value;
            if (streamController) {
                streamController.enableSubtitles(subtitlesEnabled);
            }
        },

        /**
        * Returns the subtitles processing state.
        * @method isSubtitlesEnabled
        * @access public
        * @memberof MediaPlayer#
        * @return {boolean} true if subtitles are enabled, false otherwise
        */
        isSubtitlesEnabled: function () {
            _isPlayerInitialized();
            return subtitlesEnabled;
        },

        /**
         * Enables or disables subtitles display in a div outside video player.
         * @method enableSubtitleExternDisplay
         * @access public
         * @memberof MediaPlayer#
         * @param {boolean} mode - true if subtitles are displayed in a div outside video player
         */
        enableSubtitleExternDisplay: function (value) {
            if (typeof value !== 'boolean') {
                throw new Error('MediaPlayer.enableSubtitleExternDisplay(): Invalid Arguments');
            }
            this.config.setParams({'TextTrackExtensions.displayModeExtern': value});
        },

        /**
         * Returns the HTML div element previously attached (@see [attachTTMLRenderingDiv]{@link MediaPlayer#attachTTMLRenderingDiv})
         * @method getTTMLRenderingDiv
         * @access public
         * @memberof MediaPlayer#
         * @returns {HTMLDivElement} the HTML div object previously attached
         */
        getTTMLRenderingDiv: function() {
            return videoModel ? videoModel.getTTMLRenderingDiv() : null;
        },

        /**
         * Attaches an HTML div element to be used to render rich TTML subtitles.
         * @method attachTTMLRenderingDiv
         * @access public
         * @memberof MediaPlayer#
         * @param {HTMLDivElement} div - An unstyled div element placed after the video element. It will be styled to match the video size and overlay z-order
         */
        attachTTMLRenderingDiv: function(div) {
            _isPlayerInitialized();
            videoModel.setTTMLRenderingDiv(div);
        },
//#endregion

//#region AUDIO VOLUME
        /**
         * Returns the audio mute state.
         * @method getMute
         * @access public
         * @memberof MediaPlayer#
         * @return {boolean} true if the audio is muted, false otherwise
         */
        getMute: function () {
            _isPlayerInitialized();
            return videoModel.getMute();
        },

        /**
         * Sets the audio mute state.
         * @method setMute
         * @access public
         * @memberof MediaPlayer#
         * @param {boolean} value - true to mute audio, false otherwise
         */
        setMute: function (value) {
            _isPlayerInitialized();
            if (typeof value !== 'boolean') {
                throw new Error('MediaPlayer.setMute(): Invalid Arguments');
            }
            videoModel.setMute(value);
        },

        /**
         * Returns the audio volume level.
         * @method getVolume
         * @access public
         * @memberof MediaPlayer#
         * @return {number} the current audio volume level, from 0.0 (silent) to 1.0 (loudest)
         */
        getVolume: function () {
            _isPlayerInitialized();
            return videoModel.getVolume();
        },

        /**
         * Sets the audio volume level.
         * @method setVolume
         * @access public
         * @memberof MediaPlayer#
         * @param {number} level - the audio volume level, from 0.0 (silent) to 1.0 (loudest)
         */
        setVolume: function (level) {
            _isPlayerInitialized();
            if ((typeof level !== 'number') || level < 0 || level > 1) {
                throw new Error('MediaPlayer.setVolume(): Invalid Arguments');
            }

            videoModel.setVolume(level);
        },
//#endregion

//#region TERMINAL ID
        /**
         * Returns the terminal ID.
         * @method getTerminalId
         * @access public
         * @memberof MediaPlayer#
         * @return {string} the terminal ID (<OS name>-<OS bits>-<browser name>)
         */
        getTerminalId: function () {
            var browser = fingerprint_browser(),
                os = fingerprint_os();

            return os.name + "-" + os.bits + "-" + browser.name;
        },
//#endregion

//#region PLUGINS
        /**
         * Adds a MediaPlayer plugin.
         * @method addPlugin
         * @access public
         * @memberof MediaPlayer#
         * @param {object} plugin - the plugin instance
         */
        addPlugin: function (plugin) {
            _isPlayerInitialized();

            if (plugin === undefined) {
                throw new Error('MediaPlayer.addPlugin(): plugin undefined');
            }

            // Check plugin API
            if (typeof(plugin.getName) !== 'function' ||
                typeof(plugin.getVersion) !== 'function' ||
                typeof(plugin.init) !== 'function' ||
                typeof(plugin.load) !== 'function' ||
                typeof(plugin.stop) !== 'function' ||
                typeof(plugin.reset) !== 'function') {
                throw new Error('MediaPlayer.addPlugin(): plugin API not compliant');
            }

            if (plugins[plugin.getName()]) {
                // Destroy plugin already loaded
                plugins[plugin.getName()].destroy();
            }

            this.debug.log("[MediaPlayer] Add plugin '" + plugin.getName() + "' (v" + plugin.getVersion() + ")");

            // Store plugin
            plugins[plugin.getName()] = plugin;

            // Initialize plugin (if player initialized)
            plugin.deferInit = Q.defer();
            if (initialized) {
                plugin.init(this, function () {
                    this.deferInit.resolve();
                }.bind(plugin));
            }
        },

        /**
         * Removes a MediaPlayer plugin.
         * @method removePlugin
         * @access public
         * @memberof MediaPlayer#
         * @param {object|string} plugin - the plugin instance (or name) to remove
         */
        removePlugin: function (plugin) {
            var name;

            if (plugin === undefined) {
                throw new Error('MediaPlayer.removePlugin(): plugin undefined');
            }

            if (typeof(plugin) === 'string') {
                name = plugin;
            } else {
                if (typeof(plugin.getName) !== 'function') {
                    throw new Error('MediaPlayer.removePlugin(): plugin API not compliant');
                }
                name = plugin.getName();
            }

            if (plugins[name]) {
                this.debug.log("[MediaPlayer] Remove plugin '" + name);
                // Reset plugin
                plugins[name].destroy();
                // delete it
                plugins[name] = null;
                delete plugins[name];
            }
        }
//#endregion
    };
};

MediaPlayer.prototype = {
    constructor: MediaPlayer
};

//#region Packages
/**
 * Packages declaration
 */
MediaPlayer.dependencies = {};
MediaPlayer.dependencies.protection = {};
MediaPlayer.dependencies.protection.servers = {};
MediaPlayer.utils = {};
MediaPlayer.models = {};
MediaPlayer.modules = {};
MediaPlayer.vo = {};
MediaPlayer.vo.metrics = {};
MediaPlayer.vo.protection = {};
MediaPlayer.rules = {};
MediaPlayer.rules.o = {};
MediaPlayer.di = {};
//#endregion

//#region Enums
/**
 * ENUMS
 */
MediaPlayer.PUBLIC_EVENTS = {
    /**
     * The error event is fired when an error occurs.
     * When the error event is fired, the application shall stop the player.
     *
     * @event MediaPlayer#error
     * @param {object} event - the event
     * @param {object} event.type - the event type ('error')
     * @param {object} event.data - the event data
     * @param {string} event.data.code - error code
     * @param {string} event.data.message - error message
     * @param {object} event.data.data - error additionnal data
     */
    'error': 'hasplayer',

    /**
    * The warning event is fired when a warning occurs.
    *
    * @event MediaPlayer#warning
    * @param {object} event - the event
    * @param {object} event.type - the event type ('warning')
    * @param {object} event.data - the event data
    * @param {string} event.data.code - warning code
    * @param {string} event.data.message - warning message
    * @param {object} event.data.data - warning additionnal data
    */
    'warning': 'hasplayer',

    /**
     * The manifestUrlUpdate event is fired when the URL of the manifest may have to be refreshed,
     * since the player failed to download the manifest file (URL expiration for example).
     * The application shall therefore provide an updated manifest URL by using the method [refreshManifest]{@link MediaPlayer#refreshManifest}
     *
     * @event MediaPlayer#manifestUrlUpdate
     * @param {object} event - the event
     * @param {object} event.type - the event type ('manifestUrlUpdate')
     * @param {object} event.data - the event data
     * @param {object} event.data.url - the current manifest url
     */
    'manifestUrlUpdate': 'hasplayer',

    /**
     * The metricAdded event is fired when a new metric has been added,
     * TBD
     */
    'metricAdded' : 'hasplayer',

    /**
     * The metricChanged event is fired when a metric has been updated,
     * TBD
     */
    'metricChanged' : 'hasplayer',

    /**
     * The cueEnter event is fired when a subtitle cue needs to be displayed.
     *
     * @event MediaPlayer#cueEnter
     * @param {object} event - the event
     * @param {object} event.type - the event type ('cueEnter')
     * @param {object} event.data - the event data
     * @param {object} event.data.text - the subtitle text
     * @param {string} event.data.style.backgroundColor - the background color
     * @param {string} event.data.style.color - the font color
     * @param {string} event.data.style.fontFamily - the font family
     * @param {string} event.data.style.fontSize - the font size
     */
    'cueEnter': 'hasplayer',

    /**
     * The cueExit event is fired when a subtitle cue needs to be erased.
     *
     * @event MediaPlayer#cueExit
     * @param {object} event - the event
     * @param {object} event.type - the event type ('cueExit')
     * @param {object} event.data - the event data
     * @param {object} event.data.text - the subtitle text
     * @param {string} event.data.style.backgroundColor - the background color
     * @param {string} event.data.style.color - the font color
     * @param {string} event.data.style.fontFamily - the font family
     * @param {string} event.data.style.fontSize - the font size
     */
    'cueExit': 'hasplayer',

    /**
     * The 'play_bitrate' event is fired when the current played bitrate has changed.
     *
     * @event MediaPlayer#play_bitrate
     * @param {CustomEvent} event - the event
     * @param {object} event.detail - the event data
     * @param {string} event.detail.type - the stream type ('audio' or 'video')
     * @param {number} event.detail.bitrate - the new bitrate
     * @param {string} event.detail.representationId - the corresponding representation id (from manifest)
     * @param {number} event.detail.time - the current video time
     * @param {number} event.detail.width - in case of video stream, the video width of the representation
     * @param {number} event.detail.height - in case of video stream, the video height of the representation
     */
    'play_bitrate': 'video',

    /**
     * The download_bitrate event is fired when the current downloaded bitrate has changed.
     *
     * @event MediaPlayer#download_bitrate
     * @param {CustomEvent} event - the event
     * @param {object} event.detail - the event data
     * @param {string} event.detail.type - the stream type ('audio' or 'video')
     * @param {number} event.detail.bitrate - the new bitrate
     * @param {string} event.detail.representationId - the corresponding representation id (from manifest)
     * @param {number} event.detail.time - the current video time
     * @param {number} event.detail.width - in case of video stream, the video width of the representation
     * @param {number} event.detail.height - in case of video stream, the video height of the representation
     */
    'download_bitrate': 'video',

    /**
     * The bufferLevel_updated event is fired when the buffer level changed.
     *
     * @event MediaPlayer#bufferLevel_updated
     * @param {CustomEvent} event - the event
     * @param {object} event.detail - the event data
     * @param {string} event.detail.type - the stream type ('audio' or 'video')
     * @param {number} event.detail.level - the buffer level (in seconds)
     */
    'bufferLevel_updated': 'video',

    /**
     * The state_changed event is fired when the player state changed.
     *
     * @event MediaPlayer#state_changed
     * @param {CustomEvent} event - the event
     * @param {object} event.detail - the event data
     * @param {string} event.detail.type - the stream type ('audio' or 'video')
     * @param {string} event.detail.state - the current state ('stopped', 'buffering', 'seeking' or 'playing')
     */
    'state_changed': 'video'
};

/**
 * Exposes the available tracks types used to manage tracks (language) switching.
 * @see [getTracks]{@link MediaPlayer#getTracks}
 * @see [getSelectedTrack]{@link MediaPlayer#getSelectedTrack}
 * @see [selectTrack]{@link MediaPlayer#selectTrack}
 * @enum
 */
MediaPlayer.TRACKS_TYPE = {
    AUDIO: "audio",
    TEXT: "text"
};
//#endregion

//#region Player parameters
/**
 * Player parameters object.
 * All parameters values are applied for any stream type. Parameters can be overriden specifically for audio and video track by setting
 * parameters values in the params.audio and params.video objects.
 * @typedef MediaPlayer#PlayerParams
 * @type Object
 * @property {number}   BufferController.minBufferTimeForPlaying - Minimum buffer level before playing, in seconds (default value = 0)
 * @property {number}   BufferController.minBufferTime - Minimum buffer size (in seconds), if set to '-1' the maximum value between the manifest's minBufferTime and 16 sec. is considered (default value = -1)
 * @property {number}   BufferController.bufferToKeep - The buffer size (in seconds) to keep anterior to current playing time (default value = 30)
 * @property {number}   BufferController.liveDelay - The delay (in seconds) between the live edge and playing time, if set to '-1' the live delay is set according to minBufferTime (default value = -1)
 * @property {number}   ABR.minBandwidth - Minimum bandwidth to be playbacked (default value = -1)
 * @property {number}   ABR.maxBandwidth - Maximum bandwidth to be playbacked (default value = -1)
 * @property {number}   ABR.minQuality - Minimum quality index (start from 0) to be playbacked (default value = -1)
 * @property {number}   ABR.maxQuality - Maximum quality index (start from 0) to be playbacked (default value = -1)
 * @property {boolean}  ABR.switchUpIncrementally - Switch up quality incrementally, or not (default value = false)
 * @property {number}   ABR.switchUpRatioSafetyFactor - Switch up bandwith ratio safety factor (default value = 1.5)
 * @property {boolean}  ABR.latencyInBandwidth - Include (or not) latency in bandwidth (default value = true)
 * @property {number}   ABR.switchLowerBufferTime - Buffer level (in seconds) under which switching down to lowest quality occurs (default value = -1)
 * @property {number}   ABR.switchLowerBufferRatio - Buffer level (as percentage of buffer size) under which switching down to lowest quality occurs (default value = 0.25)
 * @property {number}   ABR.switchDownBufferTime - Buffer level (in seconds) under which switching down quality occur, if unsufficient bandwidth (default value = -1)
 * @property {number}   ABR.switchDownBufferRatio - Buffer level (as percentage of buffer size) under which switching down quality occurs, if unsufficient bandwidth (default value = 0.5)
 * @property {number}   ABR.switchUpBufferTime - Buffer level (in seconds) upper which switching up quality occurs, if sufficient bandwidth (default value = -1)
 * @property {number}   ABR.switchUpBufferRatio - Buffer level (as percentage of buffer size) upper which switching up quality occurs, if sufficient bandwidth (default value = 0.75)
 * @property {number}   ABR.droppedFramesMinRatio - The number of dropped frames (as a ratio to total video frames) from which switching up quality is disabled (default value = 0.1)
 * @property {number}   ABR.droppedFramesMaxRatio - The number of dropped frames (as a ratio to total video frames) from which quality is switched down (default value = 0.3)
 * @property {number}   ManifestLoader.RetryAttempts - Number of retry attempts for downloading manifest file when it fails (default value = 2)
 * @property {number}   ManifestLoader.RetryInterval - Interval (in milliseconds) between each retry attempts for downloading manifest file (default value = 500)
 * @property {number}   FragmentLoader.RetryAttempts - Number of retry attempts for downloading segment files when it fails (default value = 2)
 * @property {number}   FragmentLoader.RetryInterval - Interval (in milliseconds) between each retry attempts for downloading segment files (default value = 500)
 * @property {boolean}  Protection.licensePersistence - Provides or not license persistence at application level, in case no persistence is provided by the CDM (default value = false)
 * @property {number}   backoffSeekToEnd - Backoff value (in seconds) when seeking at end/duration (default value = 2)
 * @property {Object}   video - Video parameters (parameters for video track)
 * @property {Object}   audio - audio parameters (parameters for audio track)
 */
//#endregion

//#region Static functions
/**
 * Static functions
 */
/**
* Returns the current browser status on MSE support.
* @method hasMediaSourceExtension
* @static
* @return true if MSE is supported, false otherwise
*/
MediaPlayer.hasMediaSourceExtension = function () {
    return new MediaPlayer.utils.Capabilities().supportsMediaSource();
};

/**
 * Returns the current browser status on EME support.
 * @method hasMediaKeysExtension
 * @static
 * @return true if EME is supported, false otherwise
 */
MediaPlayer.hasMediaKeysExtension = function () {
    return new MediaPlayer.utils.Capabilities().supportsMediaKeys();
};
//#endregion

/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Digital Primates
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.dependencies.AbrController = function() {
    "use strict";

    var autoSwitchBitrate = true,
        autoSwitchDic = {},
        qualityDict = {},
        qualityMaxDict = {},
        confidenceDict = {},
        playerState = "",

        getInternalAutoSwitch = function(type) {
            if (!autoSwitchDic.hasOwnProperty(type)) {
                autoSwitchDic[type] = true;
            }
            return autoSwitchDic[type];
        },

        setInternalAutoSwitch = function(type, value) {
            autoSwitchDic[type] = value;
        },

        getInternalQuality = function(type) {
            var quality;

            if (!qualityDict.hasOwnProperty(type)) {
                qualityDict[type] = 0;
            }

            quality = qualityDict[type];

            return quality;
        },

        setInternalQuality = function(type, value) {
            qualityDict[type] = value;
        },

        getInternalConfidence = function(type) {
            var confidence;

            if (!confidenceDict.hasOwnProperty(type)) {
                confidenceDict[type] = 0;
            }

            confidence = confidenceDict[type];

            return confidence;
        },

        setInternalConfidence = function(type, value) {
            confidenceDict[type] = value;
        },

        getRulesRequestQuality = function(type, data) {
            var self = this,
                autoSwitch = getInternalAutoSwitch(type),
                quality = getInternalQuality(type),
                confidence = getInternalConfidence(type),
                newQuality = MediaPlayer.rules.SwitchRequest.prototype.NO_CHANGE,
                newConfidence = MediaPlayer.rules.SwitchRequest.prototype.NO_CHANGE,
                qualityMax = MediaPlayer.rules.SwitchRequest.prototype.NO_CHANGE,
                i,
                len,
                results = [],
                metrics,
                req,
                values = {},
                rules,
                max;

            if (!autoSwitchBitrate || !autoSwitch) {
                self.debug.log("[AbrController][" + type + "] ABR disabled");
                return {
                    quality: quality,
                    confidence: confidence
                };
            }

            self.debug.log("[AbrController][" + type + "] Check rules....");

            metrics = self.getMetricsFor(data);
            rules = self.abrRulesCollection.getRules(MediaPlayer.rules.BaseRulesCollection.prototype.QUALITY_SWITCH_RULES);
            for (i = 0, len = rules.length; i < len; i += 1) {
                results.push(rules[i].checkIndex(quality, metrics, data, playerState));
            }

            values[MediaPlayer.rules.SwitchRequest.prototype.STRONG] = MediaPlayer.rules.SwitchRequest.prototype.NO_CHANGE;
            values[MediaPlayer.rules.SwitchRequest.prototype.WEAK] = MediaPlayer.rules.SwitchRequest.prototype.NO_CHANGE;
            values[MediaPlayer.rules.SwitchRequest.prototype.DEFAULT] = MediaPlayer.rules.SwitchRequest.prototype.NO_CHANGE;

            for (i = 0, len = results.length; i < len; i += 1) {
                req = results[i];
                if (req.quality !== MediaPlayer.rules.SwitchRequest.prototype.NO_CHANGE) {
                    self.debug.log("[AbrController][" + type + "] Request for quality " + req.quality + ", priority = " + req.priority + " (" + rules[i].name + ")");
                    values[req.priority] = Math.min(values[req.priority], req.quality);
                }

                if (req.max === true) {
                    qualityMax = Math.min(qualityMax, req.quality);
                }
            }

            if (values[MediaPlayer.rules.SwitchRequest.prototype.WEAK] !== MediaPlayer.rules.SwitchRequest.prototype.NO_CHANGE) {
                newConfidence = MediaPlayer.rules.SwitchRequest.prototype.WEAK;
                newQuality = values[MediaPlayer.rules.SwitchRequest.prototype.WEAK];
            }

            if (values[MediaPlayer.rules.SwitchRequest.prototype.DEFAULT] !== MediaPlayer.rules.SwitchRequest.prototype.NO_CHANGE) {
                newConfidence = MediaPlayer.rules.SwitchRequest.prototype.DEFAULT;
                newQuality = values[MediaPlayer.rules.SwitchRequest.prototype.DEFAULT];
            }

            if (values[MediaPlayer.rules.SwitchRequest.prototype.STRONG] !== MediaPlayer.rules.SwitchRequest.prototype.NO_CHANGE) {
                newConfidence = MediaPlayer.rules.SwitchRequest.prototype.STRONG;
                newQuality = values[MediaPlayer.rules.SwitchRequest.prototype.STRONG];
            }

            if (newQuality !== MediaPlayer.rules.SwitchRequest.prototype.NO_CHANGE && newQuality !== undefined) {
                quality = newQuality;
            }

            if (newConfidence !== MediaPlayer.rules.SwitchRequest.prototype.NO_CHANGE && newConfidence !== undefined) {
                confidence = newConfidence;
            }

            if (qualityMax !== MediaPlayer.rules.SwitchRequest.prototype.NO_CHANGE) {
                qualityMaxDict[type] = qualityMax;
            }

            max = self.manifestExt.getRepresentationCount(data);
            // Ensure valid quality index
            if (quality < 0) {
                quality = 0;
            }
            if (quality >= max) {
                quality = max - 1;
            }

            if (confidence !== MediaPlayer.rules.SwitchRequest.prototype.STRONG &&
                confidence !== MediaPlayer.rules.SwitchRequest.prototype.WEAK) {
                confidence = MediaPlayer.rules.SwitchRequest.prototype.DEFAULT;
            }

            self.debug.info("[AbrController][" + type + "] Request quality: " + quality);

            return {
                quality: quality,
                confidence: confidence
            };
        },

        getQualityBoundaries = function(type, data) {
            var bitrates = this.metricsExt.getBitratesForType(type, data),
                qualityMin = this.config.getParamFor(type, "ABR.minQuality", "number", -1),
                qualityMax = this.config.getParamFor(type, "ABR.maxQuality", "number", -1),
                bandwidthMin = this.config.getParamFor(type, "ABR.minBandwidth", "number", -1),
                bandwidthMax = this.config.getParamFor(type, "ABR.maxBandwidth", "number", -1),
                i,
                count = bitrates.length;

            if (bandwidthMin !== -1) {
                for (i = 0; i < bitrates.length; i++) {
                    if (bitrates[i] >= bandwidthMin) {
                        qualityMin = (qualityMin === -1) ? i : Math.max(i, qualityMin);
                        break;
                    }
                }
            }

            if (bandwidthMax !== -1) {
                for (i = bitrates.length - 1; i >= 0; i--) {
                    if (bitrates[i] <= bandwidthMax) {
                        qualityMax = (qualityMax === -1) ? i : Math.min(i, qualityMax);
                        break;
                    }
                }
            }

            qualityMin = (qualityMin >= count) ? (count - 1) : qualityMin;
            qualityMin = (qualityMin < 0) ? 0 : qualityMin;
            qualityMax = (qualityMax >= count || qualityMax < 0) ? (count - 1) : qualityMax;

            return {
                min: qualityMin,
                max: qualityMax
            };

        };

    return {
        debug: undefined,
        abrRulesCollection: undefined,
        manifestExt: undefined,
        metricsModel: undefined,
        metricsExt: undefined,
        config: undefined,

        getAutoSwitchBitrate: function() {
            return autoSwitchBitrate;
        },

        setAutoSwitchBitrate: function(value) {
            this.debug.log("[AbrController] Set auto switch: " + value);
            autoSwitchBitrate = value;
        },

        getMetricsFor: function(data) {
            var isVideo,
                isAudio;

            isVideo = this.manifestExt.getIsVideo(data);
            if (isVideo) {
                return this.metricsModel.getMetricsFor("video");
            } else {
                isAudio = this.manifestExt.getIsAudio(data);
                if (isAudio) {
                    return this.metricsModel.getMetricsFor("audio");
                } else {
                    return this.metricsModel.getMetricsFor("stream");
                }
            }
        },

        getPlaybackQuality: function(type, data) {
            var self = this,
                previousQuality = this.getQualityFor(type),
                qualityMin = -1,
                qualityMax = -1,
                quality,
                confidence,
                switchUpIncrementally = this.config.getParamFor(type, "ABR.switchUpIncrementally", "boolean", false),
                result;

            result = getRulesRequestQuality.call(this, type, data);
            quality = result.quality;
            confidence = result.confidence;

            if (self.getAutoSwitchBitrate()) {
                // Check incremental switch
                if (switchUpIncrementally && (quality > previousQuality)) {
                    self.debug.log("[AbrController][" + type + "] Incremental switch => quality: " + quality);
                    quality = previousQuality + 1;
                }

                // Check representation boundaries
                var qualityBoundaries = getQualityBoundaries.call(self, type, data);
                qualityMin = qualityBoundaries.min;
                qualityMax = qualityBoundaries.max;

                if (quality < qualityMin) {
                    quality = qualityMin;
                    self.debug.log("[AbrController][" + type + "] New quality < min => " + quality);
                }

                if (quality > qualityMax) {
                    quality = qualityMax;
                    self.debug.log("[AbrController][" + type + "] New quality > max => " + quality);
                }

                // Check max quality allowed by the rules (see DroppedFramesRule for example)
                if (quality > qualityMaxDict[type]) {
                    quality = qualityMaxDict[type];
                    self.debug.log("[AbrController][" + type + "] Max allowed quality = " + quality);
                }
            }

            setInternalQuality.call(self, type, quality);
            setInternalConfidence.call(self, type, confidence);

            self.debug.info("[AbrController][" + type + "] Set quality: " + quality);
            return {
                quality: quality,
                confidence: confidence
            };
        },

        getAutoSwitchFor: function(type) {
            return getInternalAutoSwitch(type);
        },

        setAutoSwitchFor: function(type, value) {
            var autoSwitch = getInternalAutoSwitch(type);
            if (value !== autoSwitch) {
                this.debug.log("[AbrController][" + type + "] Set auto switch: " + value);
                setInternalAutoSwitch(type, value);
            }
        },

        getQualityFor: function(type) {
            return getInternalQuality(type);
        },

        setQualityFor: function(type, value) {
            var quality = getInternalQuality(type);
            if (value !== quality) {
                this.debug.log("[AbrController][" + type + "] Set playback quality: " + value);
                setInternalQuality(type, value);
            }
        },

        isMinQuality: function(type, data, value) {
            var qualityBoundaries = getQualityBoundaries.call(this, type, data);
            return value <= qualityBoundaries.min;
        },

        setPlayerState: function(state) {
            playerState = state;
        }
    };
};

MediaPlayer.dependencies.AbrController.prototype = {
    constructor: MediaPlayer.dependencies.AbrController
};

MediaPlayer.dependencies.AbrController.BANDWIDTH_SAFETY = 0.9;
/*
 * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.
 * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2014, Orange
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.dependencies.BufferController = function() {
    "use strict";
    var READY = "READY",
        state = READY,
        ready = false,
        started = false,
        waitingForBuffer = false,
        initialPlayback = true,
        initializationData = [],
        seeking = false,
        seekTarget = -1,
        dataChanged = true,
        trackChanged = false,
        overrideBuffer = false,
        availableRepresentations,
        _currentRepresentation,
        currentBufferedQuality = -1,
        currentDownloadQuality = -1,
        stalled = false,
        isDynamic = false,
        isBufferingCompleted = false,
        deferredRejectedDataAppend = null,
        periodInfo = null,
        fragmentsToLoad = 0,
        fragmentModel = null,
        bufferLevel = 0,
        isQuotaExceeded = false,
        rejectedBytes = null,
        appendingRejectedData = false,
        mediaSource,
        type,
        data = null,
        buffer = null,
        minBufferTime,
        minBufferTimeAtStartup,
        bufferToKeep,
        liveDelay,
        bufferTimeout,
        bufferStateTimeout,
        trickModeEnabled = false,
        trickModePreviousQuality = 0,
        trickModePreviousAutoSwitch = true,
        trickModeForward = false,

        playListMetrics = null,
        playListTraceMetrics = null,
        playListTraceMetricsClosed = true,

        inbandEventFound = false,

        // Buffering state
        INIT = -1,
        BUFFERING = 0,
        PLAYING = 1,
        htmlVideoState = INIT,
        htmlVideoTime = -1,

        deferredFragmentBuffered = null,

        // Segment download failure recovery
        SEGMENT_DOWNLOAD_ERROR_MAX = 3,
        segmentDownloadErrorCount = 0,
        segmentRequestOnError = null,

        // HLS chunk sequence number
        currentSequenceNumber = -1,
        playlistRefreshTimeout = null,

        segmentDuration = NaN,

        // Patch for Safari: do not remove past buffer in live use case since it generates MEDIA_ERROR_DECODE while appending new segment (see hasEnoughSpaceToAppend())
        isSafari = (fingerprint_browser().name === "Safari"),
        isWebKit = (fingerprint_browser().name === "WebKit"),

        // Patch for Firefox: set buffer timestampOffset since on Firefox timestamping is based on CTS (see OnMediaLoaded())
        isFirefox = (fingerprint_browser().name === "Firefox"),

        sendRequest = function() {

            if (!isRunning.call(this)) {
                return;
            }

            if (fragmentModel !== null) {
                this.fragmentController.onBufferControllerStateChange();
            }
        },

        clearPlayListTraceMetrics = function(endTime, stopreason) {
            var duration = 0,
                startTime = null;

            if (playListTraceMetricsClosed === false) {
                startTime = playListTraceMetrics.start;
                duration = endTime.getTime() - startTime.getTime();

                playListTraceMetrics.duration = duration;
                playListTraceMetrics.stopreason = stopreason;

                playListTraceMetricsClosed = true;
            }
        },

        setStalled = function(value) {
            if (type === "text") {
                return;
            }

            this.debug.info("[BufferController][" + type + "] stalled = " + value);
            stalled = value;
            this.videoModel.stallStream(type, stalled);

            // Notify ABR controller we start buffering in order to adapt ABR rules (see InsufficientbufferRule)
            this.abrController.setPlayerState(stalled ? "buffering" : "playing");
        },

        startPlayback = function() {
            if (!ready || !started) {
                return;
            }

            this.debug.info("[BufferController][" + type + "] startPlayback");

            // Start buffering process
            checkIfSufficientBuffer.call(this);
        },

        doStart = function() {
            var currentTime;

            if (started === true) {
                return;
            }

            // We check also if buffering process is not already started
            // This may happen if doStart is called by Stream on 'play' event after a seek
            if (deferredFragmentBuffered !== null) {
                return;
            }

            if (seeking === false) {
                currentTime = new Date();
                clearPlayListTraceMetrics(currentTime, MediaPlayer.vo.metrics.PlayList.Trace.USER_REQUEST_STOP_REASON);
                playListMetrics = this.metricsModel.addPlayList(type, currentTime, 0, MediaPlayer.vo.metrics.PlayList.INITIAL_PLAY_START_REASON);
            }

            if (isBufferingCompleted) {
                if (data.mimeType === "application/ttml+xml") {
                    return;
                }
                isBufferingCompleted = false;
            }

            started = true;

            this.debug.info("[BufferController][" + type + "] START");

            waitingForBuffer = true;

            // Reset htmlVideoState in order to update it after a pause or seek command in UpdateBufferState function
            if (htmlVideoState === INIT) {
                // At first playback start, set state to BUFFERING
                this.metricsModel.addState(type, "buffering", this.videoModel.getCurrentTime());
            }
            htmlVideoState = BUFFERING;
            htmlVideoTime = -1;
            segmentRequestOnError = null;

            // Clear executed requests from fragment controller. In case the browser has cleared the buffer itslef silently,
            // then FragmentController will not state that the cleared segments have been already loaded.
            this.fragmentController.clearExecutedRequests(fragmentModel);

            startPlayback.call(this);
        },

        doSeek = function(time) {
            var self = this;

            // Avoid identical successive seeks
            if ((seeking === true) && (seekTarget === time)) {
                // We are already seeking at the given time
                return;
            }

            this.debug.info("[BufferController][" + type + "] SEEK: " + time);

            // Do stop since <video>'s stop command may not be called before seek one
            if (started === true) {
                doStop.call(this);
            }

            seeking = true;
            seekTarget = time;

            // Wait for current buffering process to be completed before restarting
            Q.when(deferredFragmentBuffered ? deferredFragmentBuffered.promise : true).then(
                function() {
                    // self.debug.log("[BufferController]["+type+"] SEEK: do start");
                    // Set media type to stalled state
                    setStalled.call(self, true);
                        
                    doStart.call(self);
                }
            );
        },

        doSeeked = function() {
            this.debug.info("[BufferController][" + type + "] SEEKED");
            seeking = false;
            seekTarget = -1;
        },

        doStop = function() {
            if (!started) {
                return;
            }
            this.debug.info("[BufferController][" + type + "] STOP");

            // Stop buffering process
            clearTimeout(bufferTimeout);
            clearTimeout(bufferStateTimeout);
            started = false;
            waitingForBuffer = false;

            seeking = false;
            seekTarget = -1;

            // Stop buffering process and cancel loaded request
            clearPlayListTraceMetrics(new Date(), MediaPlayer.vo.metrics.PlayList.Trace.USER_REQUEST_STOP_REASON);

            this.fragmentController.abortRequestsForModel(fragmentModel);
        },


        getRepresentationForQuality = function(quality) {
            return availableRepresentations[quality];
        },

        onBytesLoadingStart = function(request) {
            this.debug.info("[BufferController][" + type + "] Load request ", (request.url !== null) ? request.url : request.quality);
        },

        onBytesLoaded = function(request, response) {
            // Store current segment sequence number for next segment request (HLS use case)
            if (request.sequenceNumber !== undefined) {
                currentSequenceNumber = request.sequenceNumber;
            }

            if (this.fragmentController.isInitializationRequest(request)) {
                onInitializationLoaded.call(this, request, response);
            } else {
                onMediaLoaded.call(this, request, response);
            }
        },

        onInitializationLoaded = function(request, response) {

            if (!isRunning.call(this)) {
                return;
            }

            var initData = response.data,
                quality = request.quality,
                self = this;

            this.debug.log("[BufferController][" + type + "] Initialization loaded ", quality);

            try {
                this.fragmentController.process(initData).then(function(data) {
                    if (data) {
                        // Cache the initialization data to use it next time the quality has changed
                        initializationData[quality] = data;

                        self.debug.info("[BufferController][" + type + "] Buffer initialization segment ", (request.url !== null) ? request.url : request.quality);
                        //console.saveBinArray(data, type + "_init_" + request.quality + ".mp4");
                        appendToBuffer.call(self, data, request.quality).then(
                            function() {
                                // Load next media segment
                                if (isRunning.call(self)) {
                                    loadNextFragment.call(self);
                                }
                            }
                        );
                    } else {
                        // ORANGE : For HLS Stream, init segment are pushed with media (@see HlsFragmentController)
                        loadNextFragment.call(self);
                    }
                },
                function (e) {
                    signalSegmentBuffered.call(self);
                    if (e.name) {
                        self.errHandler.sendError(e.name, e.message, e.data);
                    } else {
                        self.errHandler.sendError(MediaPlayer.dependencies.ErrorHandler.prototype.INTERNAL_ERROR, "Internal error while processing media segment", e.message);
                    }
                });
            } catch (e) {
                signalSegmentBuffered.call(self);
                if (e.name) {
                    self.errHandler.sendError(e.name, e.message, e.data);
                } else {
                    self.errHandler.sendError(MediaPlayer.dependencies.ErrorHandler.prototype.INTERNAL_ERROR, "Internal error while processing media segment", e.message);
                }
            }
        },

        onMediaLoaded = function(request, response) {

            if (!isRunning.call(this)) {
                return;
            }

            var eventStreamAdaption = this.manifestExt.getEventStreamForAdaptationSet(this.getData()),
                eventStreamRepresentation = this.manifestExt.getEventStreamForRepresentation(this.getData(), _currentRepresentation),
                events,
                self = this;

            segmentDuration = request.duration;

            // Reset segment download error status
            segmentDownloadErrorCount = 0;

            this.debug.log("[BufferController][" + type + "] Media loaded ", request.url);

            if (this.chunkAborted === true) {
                this.chunkAborted = false;
            }

            if (this.chunkMissingCount === 1) {
                this.chunkMissingCount = 0;
            }

            try {
                this.fragmentController.process(response.data, request, _currentRepresentation).then(function(data) {
                    if (data) {
                        if (eventStreamAdaption.length > 0 || eventStreamRepresentation.length > 0) {
                            events = handleInbandEvents.call(self, data, request, eventStreamAdaption, eventStreamRepresentation);
                            self.eventController.addInbandEvents(events);
                        }

                        self.debug.info("[BufferController][" + type + "] Buffer segment from url ", request.url);

                        /*if (trickModeEnabled) {
                                var filename = type + "_" + request.index + "_" + request.quality + ".mp4",
                                    blob = new Blob([data], {
                                        type: 'data/mp4'
                                    });

                                if (navigator.msSaveBlob) { // For IE10+ and edge
                                    navigator.msSaveBlob(blob, filename);
                                }
                            }*/

                        //console.saveBinArray(data, request.url.substring(request.url.lastIndexOf('/') + 1));
                        data = deleteInbandEvents.call(self, data);

                        // Check if we need to override the current buffered segments (in case of language switch for example)
                        Q.when(overrideBuffer ? removeBuffer.call(self) : true).then(
                            function() {
                                /*if (overrideBuffer) {
                                    debugBufferRange.call(self);
                                }*/
                                overrideBuffer = false;

                                // If firefox, set buffer timestampOffset since timestamping (MSE buffer range and <video> currentTime) is based on CTS (and not DTS like in other browsers)
                                if (isFirefox) {
                                    buffer.timestampOffset = -getSegmentTimestampOffset(data, request);
                                }

                                appendToBuffer.call(self, data, request.quality, request).then(
                                    function() {
                                        // Check if a new quality is being appended,
                                        // then add a metric to enable MediaPlayer to detect playback quality changes
                                        if (currentBufferedQuality !== request.quality) {
                                            self.debug.log("[BufferController][" + type + "] Buffered quality changed: " + request.quality);
                                            self.metricsModel.addBufferedSwitch(type, request.startTime, _currentRepresentation.id, request.quality);
                                            currentBufferedQuality = request.quality;
                                        }

                                        // Signal end of buffering process
                                        signalSegmentBuffered.call(self);
                                        // Check buffer level
                                        checkIfSufficientBuffer.call(self);
                                    }
                                );
                            }
                        );
                    } else {
                        self.debug.error("[BufferController][" + type + "] Error with segment data, no bytes to push");
                        // Signal end of buffering process
                        signalSegmentBuffered.call(self);
                        // Check buffer level
                        checkIfSufficientBuffer.call(self);
                    }
                },
                function (e) {
                    signalSegmentBuffered.call(self);
                    if (e.name) {
                        self.errHandler.sendError(e.name, e.message, e.data);
                    } else {
                        self.errHandler.sendError(MediaPlayer.dependencies.ErrorHandler.prototype.INTERNAL_ERROR, "Internal error while processing media segment", e.message);
                    }
                });
            } catch (e) {
                signalSegmentBuffered.call(self);
                if (e.name) {
                    self.errHandler.sendError(e.name, e.message, e.data);
                } else {
                    self.errHandler.sendError(MediaPlayer.dependencies.ErrorHandler.prototype.INTERNAL_ERROR, "Internal error while processing media segment", e.message);
                }
            }
        },

        appendToBuffer = function(data, quality, request) {
            var deferred = Q.defer(),
                currentVideoTime = this.videoModel.getCurrentTime(),
                currentTime = new Date(),
                self = this;

            // this.debug.log("Push (" + type + ") bytes: " + data.byteLength);

            if (playListTraceMetricsClosed === true) {
                playListTraceMetricsClosed = false;
                playListTraceMetrics = this.metricsModel.appendPlayListTrace(playListMetrics, _currentRepresentation.id, null, currentTime, currentVideoTime, null, 1.0, null);
            }

            if (!hasData()) {
                return;
            }

            hasEnoughSpaceToAppend.call(this).then(
                function() {
                    if (!hasData()) {
                        return;
                    }
                    self.debug.log("[BufferController][" + type + "] Buffering segment");
                    self.sourceBufferExt.append(buffer, data, request).then(
                        function( /*appended*/ ) {
                            self.debug.log("[BufferController][" + type + "] Segment buffered");

                            isQuotaExceeded = false;

                            // Patch for Safari & WebKit: do not remove past buffer since it generates MEDIA_ERROR_DECODE while appending new segment
                            if (bufferLevel > 1 && !isSafari && !isWebKit) {
                                // Remove outdated buffer parts and requests
                                // (checking bufferLevel ensure buffer is not empty or back to current time)
                                removeBuffer.call(self, -1, getWorkingTime.call(self) - bufferToKeep).then(
                                    function() {
                                        debugBufferRange.call(self);
                                        deferred.resolve();
                                    }
                                );
                            } else if (trickModeEnabled) {
                                // In case of trick play, remove outdated buffer parts according to trick play direction
                                var start = trickModeForward ? -1 : (getWorkingTime.call(self) + segmentDuration);
                                var end = trickModeForward ? (getWorkingTime.call(self) - segmentDuration) : -1;
                                removeBuffer.call(self, start, end).then(
                                    function() {
                                        debugBufferRange.call(self);
                                        deferred.resolve();
                                    }
                                );
                            } else {
                                debugBufferRange.call(self);
                                deferred.resolve();
                            }

                            self.system.notify("bufferUpdated");
                        },
                        function(result) {
                            if (type === 'text') {
                                // if text, do nt raise an error (the stream would stop)
                                // just log th error
                                self.debug.error("[BufferController][" + type + "] Failed to append data in source buffer : " + result.err.message);
                                deferred.resolve();
                            } else {
                                self.errHandler.sendError(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_APPEND_SOURCEBUFFER, "Failed to append data into " + type + " source buffer",
                                                          new MediaPlayer.vo.Error(result.err.code, result.err.name, result.err.message));
                                // if the append has failed because the buffer is full we should store the data
                                // that has not been appended and stop request scheduling. We also need to store
                                // the promise for this append because the next data can be appended only after
                                // this promise is resolved.
                                if (result.err.code === MediaPlayer.dependencies.ErrorHandler.prototype.DOM_ERR_QUOTA_EXCEEDED) {
                                    rejectedBytes = {
                                        data: data,
                                        quality: quality/*,
                                    index: index*/
                                    };
                                    deferredRejectedDataAppend = deferred;
                                    isQuotaExceeded = true;
                                    fragmentsToLoad = 0;
                                    // stop scheduling new requests
                                    doStop.call(self);
                                } else {
                                    // promise has to be resolved
                                    deferred.resolve();
                                }
                            }
                        }
                    );
                }
            );

            return deferred.promise;
        },

        debugBufferRange = function() {
            var ranges = null,
                i,
                len;

            if (this.debug.getLevel() >= this.debug.INFO) {
                if (buffer) {
                    ranges = this.sourceBufferExt.getAllRanges(buffer);
                    if ((ranges === null) || (ranges.length === 0)) {
                        return;
                    }
                    for (i = 0, len = ranges.length; i < len; i += 1) {
                        this.debug.info("[BufferController][" + type + "] Buffered range [" + i + "]: " + ranges.start(i) + " - " + ranges.end(i) + " (" + this.getVideoModel().getCurrentTime() + ")");
                    }
                }
            }
        },

        getSegmentTimestampOffset = function (data, request) {
            var fragment = mp4lib.deserialize(data),
                moov = fragment.getBoxByType("moov"),
                moof = fragment.getBoxByType("moof"),
                traf = moof === null ? null : moof.getBoxByType("traf"),
                trun = traf === null ? null : traf.getBoxByType("trun"),
                ctsOffset,
                timescale;

            if (trun === null || trun.samples_table.length === 0) {
                return 0;
            }

            ctsOffset = trun.samples_table[0].sample_composition_time_offset;
            if (ctsOffset ===  undefined) {
                return 0;
            }

            // Try to get timescale from moov
            if (moov) {
                var mvhd = moov.getBoxByType("mvhd");
                timescale = mvhd.timescale;
            } else {
                timescale = request.timescale;
            }

            return (ctsOffset / timescale);
        },

        handleInbandEvents = function(data, request, adaptionSetInbandEvents, representationInbandEvents) {
            var events = [],
                i = 0,
                identifier,
                size,
                expTwo = Math.pow(256, 2),
                expThree = Math.pow(256, 3),
                segmentStarttime = Math.max(isNaN(request.startTime) ? 0 : request.startTime, 0),
                eventStreams = [],
                inbandEvents;

            inbandEventFound = false;
            /* Extract the possible schemeIdUri : If a DASH client detects an event message box with a scheme that is not defined in MPD, the client is expected to ignore it */
            inbandEvents = adaptionSetInbandEvents.concat(representationInbandEvents);
            for (var loop = 0; loop < inbandEvents.length; loop++) {
                eventStreams[inbandEvents[loop].schemeIdUri] = inbandEvents[loop];
            }
            while (i < data.length) {
                identifier = String.fromCharCode(data[i + 4], data[i + 5], data[i + 6], data[i + 7]); // box identifier
                size = data[i] * expThree + data[i + 1] * expTwo + data[i + 2] * 256 + data[i + 3] * 1; // size of the box
                if (identifier === "moov" || identifier === "moof") {
                    break;
                } else if (identifier === "emsg") {
                    inbandEventFound = true;
                    var eventBox = ["", "", 0, 0, 0, 0, ""],
                        arrIndex = 0,
                        j = i + 12; //fullbox header is 12 bytes, thats why we start at 12

                    while (j < size + i) {
                        /* == string terminates with 0, this indicates end of attribute == */
                        if (arrIndex === 0 || arrIndex === 1 || arrIndex === 6) {
                            if (data[j] !== 0) {
                                eventBox[arrIndex] += String.fromCharCode(data[j]);
                            } else {
                                arrIndex += 1;
                            }
                            j += 1;
                        } else {
                            eventBox[arrIndex] = data[j] * expThree + data[j + 1] * expTwo + data[j + 2] * 256 + data[j + 3] * 1;
                            j += 4;
                            arrIndex += 1;
                        }
                    }
                    var schemeIdUri = eventBox[0],
                        value = eventBox[1],
                        timescale = eventBox[2],
                        presentationTimeDelta = eventBox[3],
                        duration = eventBox[4],
                        id = eventBox[5],
                        messageData = eventBox[6],
                        presentationTime = segmentStarttime * timescale + presentationTimeDelta;

                    if (eventStreams[schemeIdUri]) {
                        var event = new Dash.vo.Event();
                        event.eventStream = eventStreams[schemeIdUri];
                        event.eventStream.value = value;
                        event.eventStream.timescale = timescale;
                        event.duration = duration;
                        event.id = id;
                        event.presentationTime = presentationTime;
                        event.messageData = messageData;
                        event.presentationTimeDelta = presentationTimeDelta;
                        events.push(event);
                    }
                }
                i += size;
            }
            return events;
        },

        deleteInbandEvents = function(data) {
            if (!inbandEventFound) {
                return data;
            }

            var length = data.length,
                i = 0,
                j = 0,
                l = 0,
                identifier,
                size,
                expTwo = Math.pow(256, 2),
                expThree = Math.pow(256, 3),
                modData = new Uint8Array(data.length);

            while (i < length) {

                identifier = String.fromCharCode(data[i + 4], data[i + 5], data[i + 6], data[i + 7]);
                size = data[i] * expThree + data[i + 1] * expTwo + data[i + 2] * 256 + data[i + 3] * 1;


                if (identifier !== "emsg") {
                    for (l = i; l < i + size; l++) {
                        modData[j] = data[l];
                        j += 1;
                    }
                }
                i += size;

            }

            return modData.subarray(0, j);
        },

        isRunning = function() {
            if (started) {
                return true;
            }

            // If buffering process is running, then we interrupt it
            signalSegmentBuffered.call(this);

            return false;
        },

        signalSegmentBuffered = function() {
            if (deferredFragmentBuffered) {
                // this.debug.log("[BufferController][" + type + "] ### End of buffering process");
                deferredFragmentBuffered.resolve();
                deferredFragmentBuffered = null;
            }
        },

        hasEnoughSpaceToAppend = function() {
            var deferred = Q.defer(),
                removedTime = 0,
                fragmentDuration,
                startClearing;

            // do not remove any data until the quota is exceeded
            if (!isQuotaExceeded) {
                return Q.when(true);
            }

            startClearing = function() {
                var currentTime = this.videoModel.getCurrentTime(),
                    removeStart = 0,
                    removeEnd,
                    req;

                // we need to remove data that is more than one segment before the video currentTime
                req = this.fragmentController.getExecutedRequestForTime(fragmentModel, currentTime);
                removeEnd = (req && !isNaN(req.startTime)) ? req.startTime : Math.floor(currentTime);
                fragmentDuration = (req && !isNaN(req.duration)) ? req.duration : 1;

                removeBuffer.call(this, removeStart, removeEnd).then(
                    function(removedTimeValue) {
                        removedTime += removedTimeValue;
                        if (removedTime >= fragmentDuration) {
                            deferred.resolve();
                        } else {
                            setTimeout(startClearing, fragmentDuration * 1000);
                        }
                    }
                );
            };

            startClearing.call(this);

            return deferred.promise;
        },

        removeBuffer = function(start, end) {
            var deferred = Q.defer(),
                removeStart,
                removeEnd,
                self = this;

            if (buffer.buffered.length === 0) {
                deferred.resolve(0);
                return deferred.promise;
            }

            removeStart = ((start !== undefined) && (start !== -1)) ? start : buffer.buffered.start(0);
            removeEnd = ((end !== undefined) && (end !== -1)) ? end : buffer.buffered.end(buffer.buffered.length - 1);

            if (removeEnd <= removeStart) {
                deferred.resolve(0);
                return deferred.promise;
            }

            this.debug.info("[BufferController][" + type + "] Remove from " + removeStart + " to " + removeEnd + " (" + this.getVideoModel().getCurrentTime() + ")");

            // Abort on buffer
            if (type !== "text") {
                // no need to abort for text buffer. remove call do the same thing
                this.sourceBufferExt.abort(mediaSource, buffer);
            }

            // Wait for buffer update completed
            this.sourceBufferExt.remove(buffer, removeStart, removeEnd, periodInfo.duration, mediaSource).then(
                function() {
                    // Remove all requests from the list of the executed requests
                    self.fragmentController.removeExecutedRequestsBeforeTime(fragmentModel, removeEnd + 1); // +1 for rounding issues
                    self.fragmentController.cancelPendingRequestsForModel(fragmentModel);
                    deferred.resolve(removeEnd - removeStart);
                }, function(ex) {
                    self.errHandler.sendWarning(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_REMOVE_SOURCEBUFFER, "Failed to remove data from " + type + " source buffer",
                        new MediaPlayer.vo.Error(ex.code, ex.name, ex.message));
                    deferred.resolve(0);
                }
            );

            return deferred.promise;
        },

        onBytesError = function(e) {

            if (!isRunning.call(this)) {
                return;
            }

            signalSegmentBuffered.call(this);

            // Abandonned request => load segment at lowest quality
            if (e.aborted) {
                // if (e.quality !== 0) {
                // this.debug.info("[BufferController][" + type + "] Segment download abandonned => Retry segment download at lowest quality");
                // this.abrController.setAutoSwitchFor(type, false);
                // this.abrController.setQualityFor(type, 0);
                bufferFragment.call(this);
                // }
                return;
            }

            // Ignore in case of text track, this will not stop playing
            if (type === "text") {

                this.errHandler.sendWarning(MediaPlayer.dependencies.ErrorHandler.prototype.DOWNLOAD_ERR_CONTENT,
                    "Failed to download media segment", {
                        url: e.url,
                        status: e.status
                    });

                return;
            }

            // Segment download failed
            segmentDownloadErrorCount += 1;

            if (segmentDownloadErrorCount === SEGMENT_DOWNLOAD_ERROR_MAX) {
                // If failed consecutively SEGMENT_DOWNLOAD_ERROR_MAX times, then raise an error
                this.errHandler.sendError(MediaPlayer.dependencies.ErrorHandler.prototype.DOWNLOAD_ERR_CONTENT,
                    "Failed to download media segment", {
                        url: e.url,
                        status: e.status
                    });
            } else {
                // Raise a warning
                this.errHandler.sendWarning(MediaPlayer.dependencies.ErrorHandler.prototype.DOWNLOAD_ERR_CONTENT,
                    "Failed to download media segment", {
                        url: e.url,
                        status: e.status
                    });

                // Store segment request that failed to load
                segmentRequestOnError = e;
                if (htmlVideoState === BUFFERING) {
                    // If already in buffering state (i.e. empty buffer) then signal to stream that segment loading failed
                    // Else signal it when entering in buffering state (see updateBufferState())
                    signalSegmentLoadingFailed.call(this);
                }
            }
        },

        signalStreamComplete = function( /*request*/ ) {
            this.debug.log("[BufferController][" + type + "] Stream is complete.");

            isBufferingCompleted = true;
            clearPlayListTraceMetrics(new Date(), MediaPlayer.vo.metrics.PlayList.Trace.END_OF_CONTENT_STOP_REASON);

            signalSegmentBuffered.call(this);

            doStop.call(this);

            this.system.notify("bufferingCompleted");
        },

        loadInitialization = function(quality) {

            if (!isRunning.call(this)) {
                return Q.when(null);
            }

            var self = this;

            // Check if initialization segment for current quality has already been loaded and stored
            if (initializationData[quality]) {
                this.debug.info("[BufferController][" + type + "] Buffer initialization segment, quality = ", quality);
                appendToBuffer.call(this, initializationData[quality], quality).then(
                    function() {
                        self.debug.log("[BufferController][" + type + "] Initialization segment buffered");
                        // Load next media segment
                        if (isRunning.call(self)) {
                            loadNextFragment.call(self);
                        }
                    }
                );
                return Q.when(null);
            } else {
                // Get init segment request for the current
                return this.indexHandler.getInitRequest(availableRepresentations[quality]);
            }
        },

        loadNextFragment = function() {

            if (!isRunning.call(this)) {
                return;
            }

            var time = getWorkingTime.call(this),
                range,
                segmentTime,
                self = this;


            // If we override buffer (in case of language for example), then consider current video time for the next segment time
            if (overrideBuffer) {
                segmentTime = time;
            } else {
                // Get buffer range that includes working time
                range = this.sourceBufferExt.getBufferRange(buffer, time);

                // Get next segment time
                segmentTime = range ? range.end : time;
            }

            // currentSequenceNumber used in HLS
            if ((currentSequenceNumber !== -1) && !seeking && !overrideBuffer) {
                this.debug.log("[BufferController][" + type + "] loadNextFragment for sequence number: " + currentSequenceNumber);
                this.indexHandler.getNextSegmentRequestFromSN(_currentRepresentation, currentSequenceNumber).then(onFragmentRequest.bind(this));
            } else {
                this.debug.log("[BufferController][" + type + "] loadNextFragment for time: " + segmentTime);
                this.indexHandler.getSegmentRequestForTime(_currentRepresentation, segmentTime).then(onFragmentRequest.bind(this), function() {
                    currentDownloadQuality = -1;
                    signalStreamComplete.call(self);
                });
            }
        },

        onFragmentRequest = function(request) {

            if (!isRunning.call(this)) {
                return;
            }

            var manifest = this.manifestModel.getValue();

            // Check if current request signals end of stream
            if ((request !== null) && (request.action === request.ACTION_COMPLETE)) {
                signalStreamComplete.call(this);
                return;
            }

            if (request !== null) {
                //if trick mode enbaled, get the request to get I Frame data.
                if (trickModeEnabled) {
                    request = this.indexHandler.getIFrameRequest(request);
                }

                // If we have already loaded the given fragment ask for the next one. Otherwise prepare it to get loaded
                if (this.fragmentController.isFragmentLoadedOrPending(this, request)) {
                    this.debug.log("[BufferController][" + type + "] new fragment request => already loaded or pending " + request.url);
                    this.indexHandler.getNextSegmentRequest(_currentRepresentation).then(onFragmentRequest.bind(this));
                } else {
                    // Download the segment
                    this.fragmentController.prepareFragmentForLoading(this, request, onBytesLoadingStart, onBytesLoaded, onBytesError, null /*signalStreamComplete*/ );
                    sendRequest.call(this);
                }
            } else {
                // No more fragment in current list
                this.debug.log("[BufferController][" + type + "] loadNextFragment failed");
                signalSegmentBuffered.call(this);

                if (isDynamic) {
                    // If live HLS, then check buffer since playlist should be updated
                    if (manifest.name === "M3U") {
                        updateCheckBufferTimeout.call(this);
                    }
                } else {
                    // For VOD streams, signal end of stream
                    signalStreamComplete.call(this);
                }
            }
        },

        hasData = function() {
            return !!data && !!buffer;
        },

        getTimeToEnd = function() {
            var currentTime = this.videoModel.getCurrentTime();

            return ((periodInfo.start + periodInfo.duration) - currentTime);
        },

        getWorkingTime = function() {
            var time = -1,
                videoTime = this.videoModel.getCurrentTime();

            if (seeking) {
                time = seekTarget;
                //this.debug.log("[BufferController][" + type + "] Working time = " + time + " (seeking = " + seeking + ", video time = " + videoTime + ")");
            } else {
                time = videoTime;
                //this.debug.log("[BufferController][" + type + "] Working time = " + time);
            }

            return time;
        },

        getLiveEdgeTime = function() {
            var deferred = Q.defer(),
                startTime,
                // Get live edge time from manifest as the last segment time
                liveEdgeTime = _currentRepresentation.segmentAvailabilityRange.end,
                self = this;

            this.debug.log("[BufferController][" + type + "] Manifest live edge = " + liveEdgeTime);

            // Step back from a found live edge time to be able to buffer some data
            startTime = Math.max((liveEdgeTime - liveDelay), _currentRepresentation.segmentAvailabilityRange.start);

            // Get the request corresponding to the start time
            this.indexHandler.getSegmentRequestForTime(_currentRepresentation, startTime).then(
                function(request) {
                    // Set live edge to be the start time of the founded segment
                    periodInfo.liveEdge = request.startTime;
                    self.debug.log("[BufferController][" + type + "] Live edge = " + periodInfo.liveEdge);

                    deferred.resolve(periodInfo.liveEdge);
                }
            );

            return deferred.promise;
        },

        updateBufferLevel = function(sendMetric) {
            if (!hasData()) {
                return;
            }

            var workingTime = getWorkingTime.call(this);

            bufferLevel = this.sourceBufferExt.getBufferLength(buffer, workingTime);
            this.debug.log("[BufferController][" + type + "] Working time = " + workingTime + ", Buffer level = " + bufferLevel.toFixed(3));
            if (sendMetric) {
                this.metricsModel.addBufferLevel(type, new Date(), bufferLevel);
            }
            this.updateBufferState();
        },

        checkIfSufficientBuffer = function() {

            if (!isRunning.call(this)) {
                return;
            }

            var timeToEnd,
                delay;

            this.debug.log("[BufferController][" + type + "] Check buffer...");

            updateBufferLevel.call(this, true);

            // Check stalled mode of video model
            if (stalled) {
                if (bufferLevel > minBufferTimeAtStartup) {
                    setStalled.call(this, false);
                }
            }

            timeToEnd = getTimeToEnd.call(this);
            this.debug.log("[BufferController][" + type + "] time to end = " + timeToEnd);

            // In trick mode state, always fills buffer
            if (trickModeEnabled) {
                if (bufferLevel < 1) {
                    bufferFragment.call(this);
                }
            } else {
                if (trackChanged || overrideBuffer ||
                    ((bufferLevel < minBufferTime) &&
                        ((minBufferTime < timeToEnd) || (minBufferTime >= timeToEnd && !isBufferingCompleted)))) {
                    // Buffer needs to be filled
                    bufferFragment.call(this);
                } else {
                    // Determine the timeout delay before checking again the buffer
                    delay = bufferLevel - minBufferTime + 0.5; // + 0.5 to ensure buffer level will be inferior to minBufferTime
                    updateCheckBufferTimeout.call(this, delay);
                }
            }
        },

        updateCheckBufferTimeout = function(delay) {
            var self = this;

            delay = delay ? delay : 1;

            this.debug.log("[BufferController][" + type + "] Check buffer in = " + delay.toFixed(3) + " ms (bufferLevel = " + bufferLevel + ")");

            clearTimeout(bufferTimeout);
            bufferTimeout = setTimeout(function() {
                bufferTimeout = null;
                checkIfSufficientBuffer.call(self);
            }, (delay * 1000));
        },

        bufferFragment = function() {
            var now = new Date(),
                currentVideoTime = this.videoModel.getCurrentTime(),
                manifest = this.manifestModel.getValue(),
                loadInit = false,
                quality,
                playlistUpdated = null,
                self = this;

            if (deferredFragmentBuffered !== null) {
                this.debug.error("[BufferController][" + type + "] deferredFragmentBuffered has not been resolved, create a new one is not correct.");
            }

            deferredFragmentBuffered = Q.defer();

            this.debug.log("[BufferController][" + type + "] Start buffering process...");

            // Check if data has changed
            doUpdateData.call(this);

            // If initialization data has been changed (track changed), then load initialization segment
            loadInit = (initializationData.length === 0) && (manifest.name !== "M3U");

            // Get current quality
            quality = this.abrController.getPlaybackQuality(type, data).quality;

            // Get corresponding representation
            _currentRepresentation = getRepresentationForQuality.call(this, quality);

            // Quality changed?
            if (quality !== currentDownloadQuality) {
                this.debug.log("[BufferController][" + type + "] currentDownloadQuality changed : " + quality);
                currentDownloadQuality = quality;
                // Load initialization segment
                loadInit = true;

                clearPlayListTraceMetrics(new Date(), MediaPlayer.vo.metrics.PlayList.Trace.REPRESENTATION_SWITCH_STOP_REASON);
                this.debug.log("[BufferController][" + type + "] Send RepresentationSwitch with quality = " + quality);
                this.metricsModel.addRepresentationSwitch(type, now, currentVideoTime, _currentRepresentation.id, quality);

                // HLS use case => download playlist for new representation
                playlistUpdated = updatePlayListForRepresentation.call(this);
            }

            Q.when(playlistUpdated ? playlistUpdated : true).then(
                function() {
                    if (loadInit === true) {
                        // Load initialization segment request
                        loadInitialization.call(self, quality).then(
                            function(request) {
                                if (request !== null) {
                                    self.fragmentController.prepareFragmentForLoading(self, request, onBytesLoadingStart, onBytesLoaded, onBytesError, null /*signalStreamComplete*/ );
                                    sendRequest.call(self);
                                }
                            }, function(e) {
                                signalSegmentBuffered.call(self);
                                if (e.name === MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_CODEC_UNSUPPORTED) {
                                    self.errHandler.sendError(e.name, e.message, e.data);
                                } else {
                                    self.errHandler.sendError(MediaPlayer.dependencies.ErrorHandler.prototype.INTERNAL_ERROR, "Internal error while processing initialization segment", e.message);
                                }
                            }
                        );
                    } else {
                        // Load next fragment
                        // Notes: 1 - Next fragment is download in // with initialization segment
                        //        2 - Buffer level is checked once next fragment data has been pushed into buffer (@see checkIfSufficientBuffer())
                        loadNextFragment.call(self);
                    }
                },
                function(err) {
                    signalSegmentBuffered.call(self);
                    if (err) {
                        self.errHandler.sendError(err.name, err.message, err.data);
                    }
                }
            );

        },

        updatePlayListForRepresentation = function() {
            var manifest = this.manifestModel.getValue(),
                deferred,
                representation,
                idx,
                self = this;

            if (manifest.name !== "M3U") {
                return Q.when(true);
            }

            // In static use case, do not update playlist if already downloaded
            if (!isDynamic) {
                if (_currentRepresentation.segmentInfoType === "SegmentList") {
                    return Q.when(true);
                }
            }

            if (playlistRefreshTimeout) {
                clearTimeout(playlistRefreshTimeout);
                playlistRefreshTimeout = null;
            }

            deferred = Q.defer();

            idx = this.manifestExt.getDataIndex(data, manifest, periodInfo.index);
            representation = manifest.Period_asArray[periodInfo.index].AdaptationSet_asArray[idx].Representation_asArray[currentDownloadQuality];

            this.debug.log("[BufferController][" + type + "] Update playlist for representation " + representation.id);

            this.parser.hlsParser.updatePlaylist(representation, data).then(
                function() {
                    availableRepresentations = updateRepresentations.call(self, data, periodInfo);
                    _currentRepresentation = getRepresentationForQuality.call(self, currentDownloadQuality);
                    representation = manifest.Period_asArray[periodInfo.index].AdaptationSet_asArray[idx].Representation_asArray[currentDownloadQuality];

                    // Refresh playlist according to last segment duration
                    var segments = representation.SegmentList.SegmentURL_asArray;
                    if (segments > 0) {
                        segmentDuration = segments[segments.length-1] - 1;
                    }
                    playlistRefreshTimeout = setTimeout(function() {
                        updatePlayListForRepresentation.call(self);
                    }, (segmentDuration * 1000));

                    deferred.resolve();
                },
                function(err) {
                    if (err) {
                        self.errHandler.sendWarning(err.name, err.message, err.data);
                    }
                    deferred.reject(err);
                }
            );

            return deferred.promise;
        },

        updateRepresentations = function(data, periodInfo) {
            var manifest = this.manifestModel.getValue(),
                idx,
                adaptations;

            idx = this.manifestExt.getDataIndex(data, manifest, periodInfo.index);
            adaptations = this.manifestExt.getAdaptationsForPeriod(manifest, periodInfo);

            return this.manifestExt.getRepresentationsForAdaptation(manifest, adaptations[idx]);
        },

        doUpdateData = function() {
            if (dataChanged === false) {
                return false;
            }

            this.debug.log("[BufferController][" + type + "] Data changed");

            // Update representations
            availableRepresentations = updateRepresentations.call(this, data, periodInfo);
            _currentRepresentation = getRepresentationForQuality.call(this, this.abrController.getPlaybackQuality(type, data).quality);

            this.bufferExt.updateData(data, type);

            if (trackChanged) {
                // Reset stored initialization segments
                initializationData = [];

                // Clear the executed requests
                this.fragmentController.clearExecutedRequests(fragmentModel);

                // Signal to override current buffering segments to switch as soon as possible to new track
                overrideBuffer = true;

                // For xml subtitles file, reset cues since there is no media segment
                if (type === 'text') {
                    buffer.UpdateLang(data.id, data.lang);
                    if (data.mimeType === 'application/ttml+xml') {
                        removeBuffer.call(this);
                    }
                }
            }

            dataChanged = false;
            trackChanged = false;
        },

        onFragmentLoadProgress = function(evt) {
            var currentQuality = this.abrController.getQualityFor(type),
                i,
                rules;

            // Check only if not at lowest quality
            if (this.abrController.isMinQuality(type, data, currentQuality)) {
                return;
            }

            rules = this.abrRulesCollection.getRules(MediaPlayer.rules.BaseRulesCollection.prototype.ABANDON_FRAGMENT_RULES);
            var callback = function(switchRequest) {
                if (switchRequest.quality < currentQuality) {
                    this.fragmentController.abortRequestsForModel(fragmentModel);
                    this.debug.info("[BufferController][" + type + "] Abandon current segment download");
                }
            };

            for (i = 0; i < rules.length; i++) {
                rules[i].execute(evt.data.request, callback.bind(this));
            }
        },

        signalSegmentLoadingFailed = function() {
            if (segmentRequestOnError === null) {
                return;
            }
            this.debug.log("[BufferController][" + type + "] Signal segment loading failed");
            this.system.notify("segmentLoadingFailed", segmentRequestOnError);
            segmentRequestOnError = null;
        };

    return {
        videoModel: undefined,
        metricsModel: undefined,
        manifestExt: undefined,
        manifestModel: undefined,
        bufferExt: undefined,
        sourceBufferExt: undefined,
        abrController: undefined,
        parser: undefined,
        fragmentExt: undefined,
        indexHandler: undefined,
        debug: undefined,
        system: undefined,
        errHandler: undefined,
        config: undefined,
        abrRulesCollection: undefined,

        initialize: function(type, newPeriodInfo, newData, buffer, fragmentController, source, eventController) {
            var manifest = this.manifestModel.getValue();

            this.debug.log("[BufferController][" + type + "] Initialize");

            this[MediaPlayer.dependencies.FragmentLoader.eventList.ENAME_LOADING_PROGRESS] = onFragmentLoadProgress;

            isDynamic = this.manifestExt.getIsDynamic(manifest);
            this.setMediaSource(source);
            this.setType(type);
            this.setBuffer(buffer);
            this.setFragmentController(fragmentController);
            this.setEventController(eventController);
            minBufferTime = this.config.getParamFor(type, "BufferController.minBufferTime", "number", -1);
            minBufferTimeAtStartup = this.config.getParamFor(type, "BufferController.minBufferTimeForPlaying", "number", MediaPlayer.dependencies.BufferExtensions.BUFFER_TIME_AT_STARTUP);
            bufferToKeep = this.config.getParamFor(type, "BufferController.bufferToKeep", "number", MediaPlayer.dependencies.BufferExtensions.DEFAULT_BUFFER_TO_KEEP);
            liveDelay = this.config.getParamFor(type, "BufferController.liveDelay", "number", -1);

            this.updateData(newData, newPeriodInfo);

            this.load();

            ready = true;
        },

        load: function() {
            var manifest = this.manifestModel.getValue(),
                self = this;

            doUpdateData.call(this);

            // Retrieve the representation of initial quality to enable some parameters initialization
            // (@see getLiveEdgeTime() for example)
            _currentRepresentation = getRepresentationForQuality.call(this, this.abrController.getPlaybackQuality(type, data).quality);

            currentDownloadQuality = -1;

            // Clear buffer
            removeBuffer.call(this).then(function () {
                if (_currentRepresentation) {
                    self.indexHandler.setIsDynamic(isDynamic);
                    if (minBufferTime === -1) {
                        minBufferTime = self.bufferExt.decideBufferLength(manifest.minBufferTime, periodInfo.duration, waitingForBuffer);
                    }

                    if (liveDelay === -1 || liveDelay < minBufferTime) {
                        liveDelay = minBufferTime;
                    }

                    // Update manifest's minBufferTime value
                    manifest.minBufferTime = minBufferTime;
                    if (type === "video") {
                        if (isDynamic) {
                            self.indexHandler.updateSegmentList(_currentRepresentation).then(
                                function() {
                                    getLiveEdgeTime.call(self).then(
                                        function(time) {
                                            self.system.notify("startTimeFound", time);
                                        }
                                    );
                                }
                            );
                        } else {
                            self.indexHandler.getCurrentTime(_currentRepresentation).then(
                                function(time) {
                                    if (time < _currentRepresentation.segmentAvailabilityRange.start) {
                                        time = _currentRepresentation.segmentAvailabilityRange.start;
                                    }
                                    self.system.notify("startTimeFound", time);
                                }
                            );
                        }
                    }
                }

            });
        },

        getIndexHandler: function() {
            return this.indexHandler;
        },

        getType: function() {
            return type;
        },

        setType: function(value) {
            type = value;

            if (this.indexHandler !== undefined) {
                this.indexHandler.setType(value);
            }
        },

        getPeriodInfo: function() {
            return periodInfo;
        },

        getVideoModel: function() {
            return this.videoModel;
        },

        setVideoModel: function(value) {
            this.videoModel = value;
        },

        getFragmentController: function() {
            return this.fragmentController;
        },

        setFragmentController: function(value) {
            if (value) {
                this.fragmentController = value;
                fragmentModel = this.fragmentController.attachBufferController(this);
                fragmentModel.fragmentLoader.subscribe(MediaPlayer.dependencies.FragmentLoader.eventList.ENAME_LOADING_PROGRESS, this);
                fragmentModel.setType(type);
            }
        },

        setEventController: function(value) {
            this.eventController = value;
        },

        getData: function() {
            return data;
        },

        updateData: function(newData, newPeriodInfo) {

            this.debug.log("[BufferController][" + type + "] Update data");

            // Check if track has changed (in case of language switch for example)
            trackChanged = (data === null) ? false : ((data.id !==  newData.id) || (data.lang !==  newData.lang) || (data.subType !==  newData.subType));

            // Set the new data
            data = newData;
            periodInfo = newPeriodInfo;
            dataChanged = true;

            if (trackChanged) {
                this.debug.log("[BufferController][" + type + "] Track changed");

                // Restart buffering process to switch as soon as possible to new track

                // Reset current timeout
                clearTimeout(bufferTimeout);
                bufferTimeout = null;

                // Reset buffering completed state
                isBufferingCompleted = false;

                // Restart controller if stopped (if buffering was already completed)
                doStart.call(this);

                // Restart buffering process
                if (deferredFragmentBuffered === null) {
                    checkIfSufficientBuffer.call(this);
                }
            }
        },

        getHtmlVideoState: function() {
            return htmlVideoState;
        },

        getAvailableRepresentations: function() {
            return availableRepresentations;
        },

        getCurrentRepresentation: function() {
            return _currentRepresentation;
        },

        getBuffer: function() {
            return buffer;
        },

        setBuffer: function(value) {
            buffer = value;
        },

        getMinBufferTime: function() {
            return minBufferTime;
        },

        setMinBufferTime: function(value) {
            minBufferTime = value;
        },

        getLiveDelay: function() {
            return liveDelay;
        },

        setMediaSource: function(value) {
            mediaSource = value;
        },

        isReady: function() {
            return state === READY;
        },

        isBufferingCompleted: function() {
            return isBufferingCompleted;
        },

        updateManifest: function() {
            this.system.notify("manifestUpdate");
        },

        updateBufferState: function() {
            var currentTime = this.videoModel.getCurrentTime(),
                previousTime = htmlVideoTime === -1 ? currentTime : htmlVideoTime,
                progress = (currentTime - previousTime),
                ranges,
                self = this;

            clearTimeout(bufferStateTimeout);
            bufferStateTimeout = null;

            if (started === false) {
                return;
            }

            if (type === "text") {
                return;
            }

            if (trickModeEnabled) {
                return;
            }

            //this.debug.log("#### [" + type + "] level = " + bufferLevel + ", currentTime = " + currentTime + ", progress = " + progress);

            switch (htmlVideoState) {
                case INIT:
                    htmlVideoState = BUFFERING;
                    this.debug.info("[BufferController][" + type + "] BUFFERING - " + currentTime + " - " + bufferLevel);
                    this.metricsModel.addState(type, "buffering", currentTime);
                    break;

                case BUFFERING:
                    if (!this.getVideoModel().isPaused() &&
                        ((progress > 0) && (bufferLevel >= 1))) {
                        htmlVideoState = PLAYING;
                        this.debug.info("[BufferController][" + type + "] PLAYING - " + currentTime);
                        this.metricsModel.addState(type, "playing", currentTime);
                        // Reset seeking state since on some browsers (IE11/Edge) seeked event may not be raised
                        seeking = false;
                        seekTarget = -1;

                        // Reset segment download error status
                        segmentDownloadErrorCount = 0;
                    } else if (!this.getVideoModel().isStalled()) {
                        ranges = this.sourceBufferExt.getAllRanges(buffer);
                    }
                    break;

                case PLAYING:
                    if (!this.getVideoModel().isPaused() && !this.getVideoModel().isSeeking() &&
                        ((progress <= 0 && bufferLevel <= 1) || (bufferLevel === 0))) {
                        htmlVideoState = BUFFERING;
                        this.debug.info("[BufferController][" + type + "] BUFFERING - " + currentTime + " - " + bufferLevel);
                        this.metricsModel.addState(type, "buffering", currentTime);

                        if (segmentRequestOnError) {
                            // If buffering is due to segment download failure (see onBytesError()), then signal it to Stream (see Stream.onBufferFailed())
                            signalSegmentLoadingFailed.call(this);
                        } else {
                            // Check if there is a hole in the buffer (segment download failed or input stream discontinuity), then skip it
                            // For live streams we consider discontinuities lower than a segment duration
                            ranges = this.sourceBufferExt.getAllRanges(buffer);
                            var i;
                            for (i = 0; i < ranges.length; i++) {
                                if (currentTime < ranges.start(i)) {
                                    if (!isDynamic || ((ranges.start(i) - currentTime) < segmentDuration)) {
                                        break;
                                    }
                                }
                            }
                            if (i < ranges.length) {
                                // Seek to next available range
                                this.debug.info("[BufferController][" + type + "] BUFFERING => skip buffer discontinuity, seek to " + ranges.start(i));
                                this.videoModel.setCurrentTime(ranges.start(i));
                            }
                        }
                    }

                    bufferStateTimeout = setTimeout(function() {
                        bufferStateTimeout = null;
                        updateBufferLevel.call(self, false);
                    }, 1000);

                    break;
            }

            if (currentTime > 0) {
                htmlVideoTime = currentTime;
            }
        },

        updateStalledState: function() {
            stalled = this.videoModel.isStalled();
        },

        reset: function(errored) {
            var cancel = function cancelDeferred(d) {
                    if (d) {
                        d.reject();
                        d = null;
                    }
                },
                deferred = Q.defer(),
                self = this;

            doStop.call(this);
            // Wait for current buffering process to be completed before restarting
            this.sourceBufferExt.abort(mediaSource, buffer);

            if (playlistRefreshTimeout) {
                clearTimeout(playlistRefreshTimeout);
                playlistRefreshTimeout = null;
            }

            Q.when(deferredFragmentBuffered ? deferredFragmentBuffered.promise : true).then(
                function() {
                    cancel(deferredRejectedDataAppend);
                    cancel(deferredFragmentBuffered);

                    if (fragmentModel) {
                        fragmentModel.fragmentLoader.unsubscribe(MediaPlayer.dependencies.FragmentLoader.eventList.ENAME_LOADING_PROGRESS, self.abrController);
                        self.fragmentController.abortRequestsForModel(fragmentModel);
                        self.fragmentController.detachBufferController(fragmentModel);
                        fragmentModel = null;
                    }

                    initializationData = [];
                    initialPlayback = true;
                    isQuotaExceeded = false;
                    rejectedBytes = null;
                    appendingRejectedData = false;

                    if (trickModeEnabled) {
                        // Restore ABR quality and auto switch state
                        self.abrController.setAutoSwitchFor(type, trickModePreviousAutoSwitch);
                        self.abrController.setQualityFor(type, trickModePreviousQuality);
                    }

                    if (!errored) {
                        self.sourceBufferExt.removeSourceBuffer(mediaSource, buffer);
                    }
                    data = null;
                    buffer = null;

                    deferred.resolve();
                }, function() {
                    deferred.reject();
                }
            );

            return deferred.promise;
        },

        getSegmentDuration: function() {
            return segmentDuration;
        },

        setTrickMode: function(enabled, forward) {
            var deferred = Q.defer();

            this.debug.log("[BufferController][" + type + "] setTrickMode - enabled = " + enabled);

            if (trickModeEnabled === enabled) {
                deferred.resolve();
                return deferred.promise;
            }
            trickModeEnabled = enabled;

            if (trickModeEnabled) {
                // Trick mode enabled
                // => store current quality and auto switch state
                // => disable auto switch and set lowest quality
                trickModeForward = forward;
                trickModePreviousQuality = this.abrController.getQualityFor(type);
                trickModePreviousAutoSwitch = this.abrController.getAutoSwitchFor(type);
                this.abrController.setAutoSwitchFor(type, false);
                this.abrController.setQualityFor(type, 0);
                deferred.resolve();
            } else {
                // Trick mode disabled
                // => restore ABR quality and auto switch state
                this.abrController.setAutoSwitchFor(type, trickModePreviousAutoSwitch);
                this.abrController.setQualityFor(type, trickModePreviousQuality);
                removeBuffer.call(this).then(function() {
                    deferred.resolve();
                });
            }

            return deferred.promise;
        },

        start: doStart,
        seek: doSeek,
        stop: doStop,
        seeked: doSeeked,
        updateBufferLevel: updateBufferLevel
    };
};

MediaPlayer.dependencies.BufferController.prototype = {
    constructor: MediaPlayer.dependencies.BufferController
};

/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Digital Primates
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.dependencies.BufferExtensions = function () {
    "use strict";

    var minBufferTarget,
        currentBufferTarget,
        topAudioQualityIndex = 0,
        topVideoQualityIndex = 0,
        audioData = null,
        videoData = null,

        getCurrentHttpRequestLatency = function(metrics) {
            var httpRequest = this.metricsExt.getCurrentHttpRequest(metrics);
            if (httpRequest !== null) {
                return (httpRequest.tresponse.getTime() - httpRequest.trequest.getTime()) / 1000;
            }
            return 0;
        },

        isPlayingAtTopQuality = function() {
            var self = this,
                audioQuality,
                videoQuality,
                isAtTop;

            audioQuality = audioData ? self.abrController.getQualityFor("audio") : topAudioQualityIndex;
            videoQuality = videoData ? self.abrController.getQualityFor("video") : topVideoQualityIndex;

            isAtTop = (audioQuality === topAudioQualityIndex) &&
                (videoQuality === topVideoQualityIndex);

            return isAtTop;
        };

    return {
        system:undefined,
        videoModel: undefined,
        metricsExt: undefined,
        metricsModel: undefined,
        abrController: undefined,
        bufferMax: undefined,

        updateData: function(data, type) {
            if (data) {
                var topIndex = data.Representation_asArray.length - 1;

                if (type === "audio") {
                    topAudioQualityIndex = topIndex;
                    audioData = data;
                } else if (type === "video") {
                    topVideoQualityIndex = topIndex;
                    videoData = data;
                }
            }
        },

        getTopQualityIndex: function(type) {
            var topQualityIndex = null;

            if (type === "audio") {
                topQualityIndex = topAudioQualityIndex;
            } else if (type === "video") {
                topQualityIndex = topVideoQualityIndex;
            }

            return topQualityIndex;
        },

        decideBufferLength: function (minBufferTime, duration/*, waitingForBuffer*/) {

            if (duration === Infinity) {
                minBufferTarget = (minBufferTime > 0) ? minBufferTime : MediaPlayer.dependencies.BufferExtensions.DEFAULT_MIN_BUFFER_TIME;
            } else if (minBufferTime >= duration) {
                minBufferTarget = Math.min(duration, MediaPlayer.dependencies.BufferExtensions.DEFAULT_MIN_BUFFER_TIME);
            } else {
                minBufferTarget = Math.min(duration, minBufferTime);
            }

            return minBufferTarget;
        },

        getLeastBufferLevel: function() {
            var videoMetrics = this.metricsModel.getReadOnlyMetricsFor("video"),
                videoBufferLevel = this.metricsExt.getCurrentBufferLevel(videoMetrics),
                audioMetrics = this.metricsModel.getReadOnlyMetricsFor("audio"),
                audioBufferLevel = this.metricsExt.getCurrentBufferLevel(audioMetrics),
                leastLevel = null;

            if (videoBufferLevel === null || audioBufferLevel === null) {
                leastLevel = (audioBufferLevel !== null) ? audioBufferLevel.level : ((videoBufferLevel !== null) ? videoBufferLevel.level : null);
            } else {
                leastLevel = Math.min(audioBufferLevel.level, videoBufferLevel.level);
            }

            return leastLevel;
        },

        getRequiredBufferLength: function (waitingForBuffer, delay, isDynamic, duration) {
            var self = this,
                vmetrics = self.metricsModel.getReadOnlyMetricsFor("video"),
                ametrics = self.metricsModel.getReadOnlyMetricsFor("audio"),
                isLongFormContent = (duration >= MediaPlayer.dependencies.BufferExtensions.LONG_FORM_CONTENT_DURATION_THRESHOLD),
                deferred = Q.defer(),
                isAtTop = false,
                requiredBufferLength;

            if (self.bufferMax === MediaPlayer.dependencies.BufferExtensions.BUFFER_SIZE_MIN) {
                requiredBufferLength = minBufferTarget;
                deferred.resolve(requiredBufferLength);
            } else if (self.bufferMax === MediaPlayer.dependencies.BufferExtensions.BUFFER_SIZE_INFINITY) {
                requiredBufferLength = duration;
                deferred.resolve(requiredBufferLength);
            } else if (self.bufferMax === MediaPlayer.dependencies.BufferExtensions.BUFFER_SIZE_REQUIRED) {
                currentBufferTarget = minBufferTarget;

                if (!isDynamic) {
                    if (!waitingForBuffer) {
                        isAtTop = isPlayingAtTopQuality.call(self);
                    }
                }

                        if (isAtTop) {
                            currentBufferTarget = isLongFormContent ?
                                MediaPlayer.dependencies.BufferExtensions.BUFFER_TIME_AT_TOP_QUALITY_LONG_FORM :
                                MediaPlayer.dependencies.BufferExtensions.BUFFER_TIME_AT_TOP_QUALITY;
                        }

                        requiredBufferLength = currentBufferTarget + delay + Math.max(getCurrentHttpRequestLatency.call(self, vmetrics),
                            getCurrentHttpRequestLatency.call(self, ametrics));

                        deferred.resolve(requiredBufferLength);
            } else {
                deferred.reject("invalid bufferMax value: " + self.bufferMax);
            }

            return deferred.promise;
        },

        //TODO: need to add this info to MediaPlayer.vo.metrics.BufferLevel or create new metric?
        getBufferTarget: function() {
            return currentBufferTarget === undefined ? minBufferTarget : currentBufferTarget;
        }
    };
};

MediaPlayer.dependencies.BufferExtensions.BUFFER_SIZE_REQUIRED = "required";
MediaPlayer.dependencies.BufferExtensions.BUFFER_SIZE_MIN = "min";
MediaPlayer.dependencies.BufferExtensions.BUFFER_SIZE_INFINITY = "infinity";
MediaPlayer.dependencies.BufferExtensions.BUFFER_TIME_AT_STARTUP = 1;
MediaPlayer.dependencies.BufferExtensions.DEFAULT_MIN_BUFFER_TIME = 16;
MediaPlayer.dependencies.BufferExtensions.DEFAULT_BUFFER_TO_KEEP = 30;
MediaPlayer.dependencies.BufferExtensions.DEFAULT_LIVE_DELAY = 16;
MediaPlayer.dependencies.BufferExtensions.BUFFER_TIME_AT_TOP_QUALITY = 30;
MediaPlayer.dependencies.BufferExtensions.BUFFER_TIME_AT_TOP_QUALITY_LONG_FORM = 300;
MediaPlayer.dependencies.BufferExtensions.LONG_FORM_CONTENT_DURATION_THRESHOLD = 600;
MediaPlayer.dependencies.BufferExtensions.prototype.constructor = MediaPlayer.dependencies.BufferExtensions;

/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 * 
 * Copyright (c) 2013, Digital Primates
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.utils.Capabilities = function () {
    "use strict";
};

MediaPlayer.utils.Capabilities.prototype = {
    constructor: MediaPlayer.utils.Capabilities,
    system: undefined,

    supportsMediaSource: function () {
        "use strict";

        var hasWebKit = ("WebKitMediaSource" in window),
            hasMediaSource = ("MediaSource" in window);

        return (hasWebKit || hasMediaSource);
    },

    supportsMediaKeys: function () {
        "use strict";

        var hasWebKit = ("WebKitMediaKeys" in window),
            hasMs = ("MSMediaKeys" in window),
            hasMediaSource = ("MediaKeys" in window);

        return (hasWebKit || hasMs || hasMediaSource);
    },

    /**
     * Returns whether Encrypted Media Extensions are supported on this
     * user agent
     *
     * @return {boolean} true if EME is supported, false otherwise
     */
    supportsEncryptedMedia: function () {
        return this.system.hasMapping('protectionModel');
    },

    supportsCodec: function (element, codec) {
        "use strict";

        if (!(element instanceof HTMLMediaElement)) {
            throw "element must be of type HTMLMediaElement.";
        }

        var canPlay = element.canPlayType(codec);
        return (canPlay === "probably" || canPlay === "maybe");
    }
};
/*
 * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.
 * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2014, Orange
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.utils.Config = function () {
    "use strict";

    var paramsType = ["video", "audio"],

        // Default configuration, provides list of possible parameters
        params = {
            // BufferController parameters
            "BufferController.minBufferTimeForPlaying": -1,
            "BufferController.minBufferTime": -1,
            "BufferController.bufferToKeep": -1,
            "BufferController.liveDelay": -1,
            // ABR parameters
            "ABR.minBandwidth": -1,
            "ABR.maxBandwidth": -1,
            "ABR.minQuality": -1,
            "ABR.maxQuality": -1,
            "ABR.switchUpIncrementally": -1,
            "ABR.switchUpRatioSafetyFactor": -1,
            "ABR.latencyInBandwidth": -1,
            "ABR.switchDownBufferTime": -1,
            "ABR.switchDownBufferRatio": -1,
            "ABR.switchLowerBufferTime": -1,
            "ABR.switchLowerBufferRatio": -1,
            "ABR.switchUpBufferTime": -1,
            "ABR.switchUpBufferRatio": -1,
            "ABR.keepBandwidthCondition": -1,
            "ABR.droppedFramesMinRatio": -1,
            "ABR.droppedFramesMaxRatio": -1,
            // Manifest loader parameters
            "ManifestLoader.RetryAttempts": -1,
            "ManifestLoader.RetryInterval": -1,
            // Fragment loader parameters
            "FragmentLoader.RetryAttempts": -1,
            "FragmentLoader.RetryInterval": -1,
            // Protection parameters
            "Protection.licensePersistence": -1,
            // Other parameters
            "backoffSeekToEnd" : 2,
            // Video parameters
            "video": {
            },
            // Audio parameters
            "audio": {
            }
        },

        doSetParams = function (newParams) {
            var item,
                typeParams,
                typeItem;

            for (item in newParams) {
                if (newParams.hasOwnProperty(item)) {
                    // Check if comment
                    if (item.indexOf('//') === -1) {
                        // Check if type parameters
                        if (paramsType.indexOf(item) > -1) {
                            typeParams = newParams[item];
                            for (typeItem in typeParams) {
                                if (typeParams.hasOwnProperty(typeItem)) {
                                    params[item][typeItem] = newParams[item][typeItem];
                                }
                            }
                        } else {
                            params[item] = newParams[item];
                        }
                    }
                }
            }
        },

        getParam = function (params, name, type, def) {
            var value = params[name];

            if ((value === undefined) || (value === -1)) {
                return def;
            }

            if ((type !== undefined) && (typeof value !== type)) {
                switch (type) {
                    case 'number':
                        value = Number(value);
                        break;
                    case 'boolean':
                        value = (value === 'true') ||
                                (value === '1') ||
                                (value === 1);
                        break;
                    default:
                        break;
                }
            }

            return value;
        },

        doGetParam = function (name, type, def) {
            return getParam(params, name, type, def);
        },

        doGetParamFor = function (key, name, type, def) {
            var typeParams = params[key];

            if ((typeParams !== undefined) && (typeParams[name] !== undefined)) {
                return getParam(typeParams, name, type, def);
            }

            return getParam(params, name, type, def);
        };

    return {
        debug: undefined,

        setup: function () {
        },

        setParams: function (newParams) {
            doSetParams(newParams);

            // Update debugger level if set in config
            var level = this.getParam("Debug.level", "number", -1);
            if (level !== -1) {
                this.debug.setLevel(level);
            }
        },

        getParam: function (name, type, def) {
            return doGetParam(name, type, def);
        },

        getParamFor: function (key, name, type, def) {
            return doGetParamFor(key, name, type, def);
        }
    };
};

MediaPlayer.utils.Config.prototype = {
    constructor: MediaPlayer.utils.Config
};

/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Digital Primates
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.di.Context = function () {
    "use strict";

    var mapProtectionModel = function() {
        var videoElement = document.createElement("video"),
            debug = this.system.getObject("debug");

        // Detect EME APIs.  Look for newest API versions first
        if (MediaPlayer.models.ProtectionModel_21Jan2015.detect(videoElement)) {
            this.system.mapSingleton('protectionModel', MediaPlayer.models.ProtectionModel_21Jan2015);
        } else if (MediaPlayer.models.ProtectionModel_3Feb2014.detect(videoElement)) {
            this.system.mapClass('protectionModel', MediaPlayer.models.ProtectionModel_3Feb2014);
        } else if (MediaPlayer.models.ProtectionModel_01b.detect(videoElement)) {
            this.system.mapClass('protectionModel', MediaPlayer.models.ProtectionModel_01b);
        } else {
            debug.log("No supported version of EME detected on this user agent!");
            debug.log("Attempts to play encrypted content will fail!");
        }
    };

    return {
        system : undefined,
        setup : function () {
            this.system.autoMapOutlets = true;

            // MediaPlayer.utils.*
            this.system.mapSingleton('capabilities', MediaPlayer.utils.Capabilities);
            this.system.mapSingleton('config', MediaPlayer.utils.Config);
            this.system.mapSingleton('debug', MediaPlayer.utils.Debug);
            this.system.mapSingleton('debugController', MediaPlayer.utils.DebugController);
            this.system.mapClass('domParser', MediaPlayer.utils.DOMParser);
            this.system.mapSingleton('eventBus', MediaPlayer.utils.EventBus);
            this.system.mapSingleton('textTrackExtensions', MediaPlayer.utils.TextTrackExtensions);
            this.system.mapSingleton('tokenAuthentication', MediaPlayer.utils.TokenAuthentication);
            this.system.mapSingleton('vttParser', MediaPlayer.utils.VTTParser);
            this.system.mapSingleton('ttmlParser', MediaPlayer.utils.TTMLParser);
            this.system.mapSingleton('ttmlRenderer', MediaPlayer.utils.TTMLRenderer);

            // MediaPlayer.models.*
            this.system.mapSingleton('manifestModel', MediaPlayer.models.ManifestModel);
            this.system.mapClass('metrics', MediaPlayer.models.MetricsList);
            this.system.mapSingleton('metricsModel', MediaPlayer.models.MetricsModel);
            this.system.mapSingleton('uriQueryFragModel', MediaPlayer.models.URIQueryAndFragmentModel);
            this.system.mapSingleton('videoModel', MediaPlayer.models.VideoModel);

            // MediaPlayer.dependencies.*
            this.system.mapSingleton('abrController', MediaPlayer.dependencies.AbrController);
            this.system.mapClass('bufferController', MediaPlayer.dependencies.BufferController);
            this.system.mapSingleton('bufferExt', MediaPlayer.dependencies.BufferExtensions);
            this.system.mapSingleton('errHandler', MediaPlayer.dependencies.ErrorHandler);
            this.system.mapClass('eventController', MediaPlayer.dependencies.EventController);
            this.system.mapClass('fragmentController', MediaPlayer.dependencies.FragmentController);
            this.system.mapClass('fragmentLoader', MediaPlayer.dependencies.FragmentLoader);
            this.system.mapClass('fragmentModel', MediaPlayer.dependencies.FragmentModel);
            this.system.mapClass('manifestLoader', MediaPlayer.dependencies.ManifestLoader);
            this.system.mapSingleton('manifestUpdater', MediaPlayer.dependencies.ManifestUpdater);
            this.system.mapSingleton('mediaSourceExt', MediaPlayer.dependencies.MediaSourceExtensions);
            this.system.mapSingleton('notifier', MediaPlayer.dependencies.Notifier);
            this.system.mapSingleton('parser', MediaPlayer.dependencies.Parser);
            this.system.mapSingleton('sourceBufferExt', MediaPlayer.dependencies.SourceBufferExtensions);
            this.system.mapClass('stream', MediaPlayer.dependencies.Stream);
            this.system.mapSingleton('streamController', MediaPlayer.dependencies.StreamController);
            this.system.mapClass('textController', MediaPlayer.dependencies.TextController);
            this.system.mapSingleton('textSourceBuffer', MediaPlayer.dependencies.TextSourceBuffer);
            this.system.mapSingleton('textTTMLXMLMP4SourceBuffer', MediaPlayer.dependencies.TextTTMLXMLMP4SourceBuffer);
            this.system.mapSingleton('videoExt', MediaPlayer.dependencies.VideoModelExtensions);

            // MediaPlayer.dependencies.protection.*
            // Protection package if available
            if (MediaPlayer.dependencies.ProtectionController) {
                this.system.mapClass('protectionController', MediaPlayer.dependencies.ProtectionController);
                this.system.mapSingleton('protectionExt', MediaPlayer.dependencies.ProtectionExtensions);
                this.system.mapSingleton('ksClearKey', MediaPlayer.dependencies.protection.KeySystem_ClearKey);
                this.system.mapSingleton('ksPlayReady', MediaPlayer.dependencies.protection.KeySystem_PlayReady);
                this.system.mapSingleton('ksWidevine', MediaPlayer.dependencies.protection.KeySystem_Widevine);
                this.system.mapSingleton('serverClearKey', MediaPlayer.dependencies.protection.servers.ClearKey);
                this.system.mapSingleton('serverDRMToday', MediaPlayer.dependencies.protection.servers.DRMToday);
                this.system.mapSingleton('serverPlayReady', MediaPlayer.dependencies.protection.servers.PlayReady);
                this.system.mapSingleton('serverWidevine', MediaPlayer.dependencies.protection.servers.Widevine);
                mapProtectionModel.call(this); // Determines EME API support and version
            }

            // MediaPlayer.rules.*
            this.system.mapClass('abrRulesCollection', MediaPlayer.rules.BaseRulesCollection);
            this.system.mapClass('abandonRequestRule', MediaPlayer.rules.AbandonRequestsRule);
            this.system.mapClass('downloadRatioRule', MediaPlayer.rules.DownloadRatioRule);
            this.system.mapClass('droppedFramesRule', MediaPlayer.rules.DroppedFramesRule);
            this.system.mapClass('insufficientBufferRule', MediaPlayer.rules.InsufficientBufferRule);
            this.system.mapClass('limitSwitchesRule', MediaPlayer.rules.LimitSwitchesRule);

            // Dash.dependencies.*
            this.system.mapClass('baseURLExt', Dash.dependencies.BaseURLExtensions);
            this.system.mapClass('fragmentExt', Dash.dependencies.FragmentExtensions);
            this.system.mapClass('indexHandler', Dash.dependencies.DashHandler);
            this.system.mapSingleton('manifestExt', Dash.dependencies.DashManifestExtensions);
            //this.system.mapSingleton('metricsExt', Dash.dependencies.DashMetricsExtensions);
            this.system.mapSingleton('metricsExt', MediaPlayer.dependencies.MetricsExtensions);
            this.system.mapSingleton('timelineConverter', Dash.dependencies.TimelineConverter);
            this.system.mapClass('dashParser', Dash.dependencies.DashParser);

            // Mss package if available
            if (Mss.dependencies.MssParser) {
                this.system.mapClass('mssParser', Mss.dependencies.MssParser);
            }

            // Hls package if available
            if (Hls.dependencies.HlsParser) {
                this.system.mapClass('hlsParser', Hls.dependencies.HlsParser);
                this.system.mapSingleton('hlsDemux', Hls.dependencies.HlsDemux);
            }

            // But we do always provide HlsStream to support HLS(+FP) streams in Safari
            this.system.mapClass('hlsStream', Hls.dependencies.HlsStream);

            // Create the context manager to plug some specific parts of the code
            this.system.mapSingleton('contextManager', MediaPlayer.modules.ContextManager);

            // Plug message handler. When the message is notify, the contextManager is called
            this.system.mapHandler('setContext', 'contextManager', 'setContext');
        }
    };
};

/*
 * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.
 * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2014, Orange
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.modules.ContextManager = function (){
    "use strict";

    return {
        system: undefined,
        debug: undefined,

        setContext: function(ctx) {
            this.system.autoMapOutlets = true;

            if (ctx === "MSS") {
                // here we map specific Class
                this.system.mapClass('mp4Processor', MediaPlayer.dependencies.Mp4Processor);
                this.system.mapClass('indexHandler', Mss.dependencies.MssHandler);
                this.system.mapClass('fragmentController', Mss.dependencies.MssFragmentController);
                this.system.mapClass('mssFragmentInfoController', Mss.dependencies.MssFragmentInfoController);
            } else if (ctx === "HLS") {
                this.system.mapClass('mp4Processor', MediaPlayer.dependencies.Mp4Processor);
                this.system.mapClass('fragmentController', Hls.dependencies.HlsFragmentController);
                this.system.mapClass('indexHandler', Hls.dependencies.HlsHandler);
            } else {
                this.system.mapClass('fragmentController', MediaPlayer.dependencies.FragmentController);
                this.system.mapClass('indexHandler', Dash.dependencies.DashHandler);
            }
        }
    };
};

MediaPlayer.modules.ContextManager.prototype =  {
    constructor: MediaPlayer.modules.ContextManager
};

/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Digital Primates
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.utils.Debug = function () {
    "use strict";

    Date.prototype.HHMMSSmmm = function() {

        var h = this.getHours().toString(),
            m = this.getMinutes().toString(),
            s = this.getSeconds().toString(),
            ms = this.getMilliseconds().toString(),
            HH = h[1] ? h : "0" + h[0],
            MM = m[1] ? m : "0" + m[0],
            SS = s[1] ? s : "0" + s[0],
            mmm = ms[2] ? ms : "0" + (ms[1] ? ms : "0" + ms[0]);

        return HH + ":" + MM + ":" + SS + "." + mmm;
    };

    Date.prototype.MMSSmmm = function() {

        var m = this.getMinutes().toString(),
            s = this.getSeconds().toString(),
            ms = this.getMilliseconds().toString(),
            MM = m[1] ? m : "0" + m[0],
            SS = s[1] ? s : "0" + s[0],
            mmm = ms[2] ? ms : "0" + (ms[1] ? ms : "0" + ms[0]);

        return MM + ":" + SS + "." + mmm;
    };

    // MemoryLogger definition

    var MemoryLogger = function(){
        // array to store logs
        this.logArray= [];
        // boolean to set leve in message
        this.showLevel = true;
    };


    MemoryLogger.prototype.error =
    MemoryLogger.prototype.warn = 
    MemoryLogger.prototype.info =
    MemoryLogger.prototype.debug  = function(message){
        this.logArray.push(message);
    };

    MemoryLogger.prototype.getLogs = function(){
        return this.logArray;
    };

    // ORANGE: add level
    var NONE  = 0,
        ERROR = 1,
        WARN  = 2,
        INFO  = 3,
        DEBUG = 4,
        ALL   = 4,
        level = 0,
        showTimestamp = true,
        showElapsedTime = false,
        startTime = new Date(),
        // default logger set to console
        _logger = console,

        _log = function (logLevel, args) {
            if (logLevel <= getLevel()) {

                var message = _prepareLog(logLevel, args);

                switch (logLevel) {
                    case ERROR:
                        _logger.error(message);
                        break;
                    case WARN:
                        _logger.warn(message);
                        break;
                    case INFO:
                        _logger.info(message);
                        break;
                    case DEBUG:
                        _logger.debug(message);
                        break;
                }
                
            }

        },

        _prepareLog = function(logLevel, args){
            var message = "",
                logTime = null;

            if (showTimestamp) {
                logTime = new Date();
                message += "[" + logTime.HHMMSSmmm() + "]";
            }

            if(_logger && _logger.showLevel){
                 message += "["+_getStringLevel(logLevel)+"]";
            }

            if (showElapsedTime) {
                message += "[" + new Date(logTime - startTime).MMSSmmm() + "]";
            }

            Array.apply(null, args).forEach(function(item) {
                message += item + " ";
            });

            return message;
        },

        _getStringLevel = function(level){
            switch(level){
                case ERROR:
                return "ERROR";
                case WARN:
                return "WARN";
                case INFO:
                return "INFO";
                case DEBUG:
                return "DEBUG";
                default:
                return "";
            }
        },

        getLevel = function() {
            return level;
        },

        getLogger = function () {
            return _logger;
        };

    return {
        
        // ORANGE: add level
        NONE:   NONE,
        ERROR:  ERROR,
        WARN:   WARN,
        INFO:   INFO,
        DEBUG:  DEBUG,
        ALL:    ALL,

        getLevel: getLevel,
        getLogger: getLogger,

        setLevel: function(value) {
            level  = value;
        },

        setLogger: function(type){
           switch(type){
                case 'log4javascript' :
                    var appender = new log4javascript.PopUpAppender();
                    var layout = new log4javascript.PatternLayout("%d{HH:mm:ss.SSS} %-5p - %m%n");
                    appender.setLayout(layout);
                    _logger.addAppender(appender);
                    _logger.setLevel(log4javascript.Level.ALL);
                    _logger.initialized = true;
                break;

                case 'memory':
                    _logger = new MemoryLogger();
                break;

                case 'console':
                    _logger = console;
                break;

                default:
                    _logger = null;
           }
        },

        error: function () {
            _log.call(this, ERROR, arguments);
        },

        warn: function () {
            _log.call(this, WARN, arguments);
        },

        info: function () {
            _log.call(this, INFO, arguments);
        },

        // Keep this function for compatibility
        log: function () {
            _log.call(this, DEBUG, arguments);
        }
    };
};

/**
 * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.
 * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2016, Orange
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * @constructs DebugController
 * @description A class which allow to download debug data on specific keybord shortcut
 */
MediaPlayer.utils.DebugController = function() {
    'use strict';

    // debug data configuration
    var debugData = {
        isInDebug: false,
        level: 0,
        loggerType: 'console'
    };

    var version = '';

    var _handleKeyPressedEvent = function(e) {
        // if we press ctrl + alt + maj + z we activate debug mode
        if ((e.altKey === true) && (e.ctrlKey === true) && (e.shiftKey === true) &&
            ((e.keyCode === 68) || (e.keyCode === 90))) {
            if (debugData.isInDebug) {
                console.log('hasplayer.js debug OFF (v' + version + ')');
                debugData.isInDebug = false;
                if (e.keyCode === 90) {
                    _downloadDebug(this.debug.getLogger().getLogs());
                    this.debug.setLevel(debugData.level);
                    this.debug.setLogger(debugData.loggerType);
                } else {
                    this.debug.setLevel(0);
                }
            } else {
                console.log('hasplayer.js debug ON (v' + version + ')');
                debugData.isInDebug = true;
                debugData.level = this.debug.getLevel();
                this.debug.setLevel((e.keyCode === 68) ? 4 : 3);
                this.debug.setLogger((e.keyCode === 68) ? 'console' : 'memory');
            }
        }
    };

    var _downloadDebug = function(array) {
        if (array && array.length > 0) {
            var filename = 'hasplayer_logs.txt',
                data = JSON.stringify(array, null, '\r\n'),
                blob = new Blob([data], {
                    type: 'text/json'
                });

            if (navigator.msSaveBlob) { // For IE10+ and edge
                navigator.msSaveBlob(blob, filename);
            } else {
                var e = document.createEvent('MouseEvents'),
                    a = document.createElement('a');
                a.download = filename;
                a.href = window.URL.createObjectURL(blob);
                a.dataset.downloadurl = ['text/json', a.download, a.href].join(':');
                e.initMouseEvent('click', true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
                a.dispatchEvent(e);
            }
        }
    };

    return {
        debug: undefined,

        setup: function() {
            window.addEventListener('keydown', _handleKeyPressedEvent.bind(this));
        },

        init: function(ver) {
            version = ver;
        }

    };
};

MediaPlayer.utils.DebugController.prototype = {
    constructor: MediaPlayer.utils.DebugController
};
/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Digital Primates
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

MediaPlayer.dependencies.ErrorHandler = function () {
    "use strict";

    return {
        eventBus: undefined,
        debug: undefined,

        sendWarning: function (code, message, data) {
            this.debug.warn("[Warn] Code: " + code + ", Message: " + message + ", Data: " + JSON.stringify(data, null, '\t'));
            this.eventBus.dispatchEvent({
                type: "warning",
                data: {code : code, message: message, data: data}
            });
        },

        sendError: function (code, message, data) {
            this.debug.error("[Error] Code: " + code + ", Message: " + message + ", Data: " + JSON.stringify(data, null, '\t'));
            this.eventBus.dispatchEvent({
                type: "error",
                data: {code : code, message: message, data: data}
            });
        }
    };
};

MediaPlayer.dependencies.ErrorHandler.prototype = {
    constructor: MediaPlayer.dependencies.ErrorHandler
};

// <video> element errors
MediaPlayer.dependencies.ErrorHandler.prototype.INTERNAL_ERROR = "INTERNAL_ERROR";

// <video> element errors
MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_ABORTED = "MEDIA_ERR_ABORTED";
MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_NETWORK = "MEDIA_ERR_NETWORK";
MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_DECODE = "MEDIA_ERR_DECODE";
MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_SRC_NOT_SUPPORTED = "MEDIA_ERR_SRC_NOT_SUPPORTED";
MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_ENCRYPTED = "MEDIA_ERR_ENCRYPTED";

MediaPlayer.dependencies.ErrorHandler.prototype.CAPABILITY_ERR_MEDIASOURCE = "CAPABILITY_ERR_MEDIASOURCE";
MediaPlayer.dependencies.ErrorHandler.prototype.CAPABILITY_ERR_MEDIAKEYS = "CAPABILITY_ERR_MEDIAKEYS";

// MSE errors
MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_CREATE_MEDIASOURCE = "MEDIA_ERR_CREATE_MEDIASOURCE";
MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_CODEC_UNSUPPORTED = "MEDIA_ERR_CODEC_UNSUPPORTED";
MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_CREATE_SOURCEBUFFER = "MEDIA_ERR_CREATE_SOURCEBUFFER";
MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_APPEND_SOURCEBUFFER = "MEDIA_ERR_APPEND_SOURCEBUFFER";
MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_REMOVE_SOURCEBUFFER = "MEDIA_ERR_REMOVE_SOURCEBUFFER";

// MediaPlayer errors
MediaPlayer.dependencies.ErrorHandler.prototype.MANIFEST_ERR_PARSE = "MANIFEST_ERR_PARSE";
MediaPlayer.dependencies.ErrorHandler.prototype.MANIFEST_ERR_NO_STREAM = "MANIFEST_ERR_NO_STREAM";
MediaPlayer.dependencies.ErrorHandler.prototype.MANIFEST_ERR_NO_VIDEO = "MANIFEST_ERR_NO_VIDEO";
MediaPlayer.dependencies.ErrorHandler.prototype.MANIFEST_ERR_NO_AUDIO = "MANIFEST_ERR_NO_AUDIO";
MediaPlayer.dependencies.ErrorHandler.prototype.MANIFEST_ERR_NO_TEXT = "MANIFEST_ERR_NO_TEXT";
MediaPlayer.dependencies.ErrorHandler.prototype.DOWNLOAD_ERR_MANIFEST = "DOWNLOAD_ERR_MANIFEST";
MediaPlayer.dependencies.ErrorHandler.prototype.DOWNLOAD_ERR_SIDX = "DOWNLOAD_ERR_SIDX";
MediaPlayer.dependencies.ErrorHandler.prototype.DOWNLOAD_ERR_INIT = "DOWNLOAD_ERR_INIT";
MediaPlayer.dependencies.ErrorHandler.prototype.DOWNLOAD_ERR_CONTENT = "DOWNLOAD_ERR_CONTENT";

// MSS errors
MediaPlayer.dependencies.ErrorHandler.prototype.MSS_NO_TFRF = "MSS_NO_TFRF";

// HLS errors
MediaPlayer.dependencies.ErrorHandler.prototype.HLS_INVALID_PACKET_ERROR = "HLS_INVALID_PACKET_ERROR";
MediaPlayer.dependencies.ErrorHandler.prototype.HLS_DEMUX_ERROR = "HLS_DEMUX_ERROR";
MediaPlayer.dependencies.ErrorHandler.prototype.HLS_INVALID_KEY_ERROR = "HLS_INVALID_KEY_ERROR";

// MediaKeyError from EME v0.1b (https://dvcs.w3.org/hg/html-media/raw-file/eme-v0.1b/encrypted-media/encrypted-media.html)
MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR = "MEDIA_KEYERR";
MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_UNKNOWN = "MEDIA_KEYERR_UNKNOWN";
MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_CLIENT = "MEDIA_KEYERR_CLIENT";
MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_SERVICE = "MEDIA_KEYERR_SERVICE";
MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_OUTPUT = "MEDIA_KEYERR_OUTPUT";
MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_HARDWARECHANGE = "MEDIA_KEYERR_HARDWARECHANGE";
MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_DOMAIN = "MEDIA_KEYERR_DOMAIN";
MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_EXPIRED = "MEDIA_KEYERR_EXPIRED";

// Key system errors
MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYSYSERR_ACCESS_DENIED = "MEDIA_KEYSYSERR_ACCESS_DENIED";

// Key/license errors
MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYMESSERR_URL_LICENSER_UNKNOWN = "MEDIA_KEYMESSERR_URL_LICENSER_UNKNOWN";
MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYMESSERR_NO_CHALLENGE = "MEDIA_KEYMESSERR_NO_CHALLENGE";
MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYMESSERR_LICENSER_ERROR = "MEDIA_KEYMESSERR_LICENSER_ERROR";
MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYMESSERR_NO_SESSION = "MEDIA_KEYMESSERR_NO_SESSION";

// Other MediaKeyError
MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_SERVER_CERTIFICATE = "MEDIA_KEYERR_SERVER_CERTIFICATE";

// DOM exceptions (see http://www.w3.org/TR/WebIDL-1/#h-idl-domexception-error-names)
MediaPlayer.dependencies.ErrorHandler.prototype.DOM_ERR_INDEX_SIZE = 1;
MediaPlayer.dependencies.ErrorHandler.prototype.DOM_ERR_HIERARCHY_REQUEST = 3;
MediaPlayer.dependencies.ErrorHandler.prototype.DOM_ERR_WRONG_DOCUMENT = 4;
MediaPlayer.dependencies.ErrorHandler.prototype.DOM_ERR_INVALID_CHARACTER = 5;
MediaPlayer.dependencies.ErrorHandler.prototype.DOM_ERR_NO_MODIFICATION_ALLOWED = 7;
MediaPlayer.dependencies.ErrorHandler.prototype.DOM_ERR_NOT_FOUND = 8;
MediaPlayer.dependencies.ErrorHandler.prototype.DOM_ERR_NOT_SUPPORTED = 9;
MediaPlayer.dependencies.ErrorHandler.prototype.DOM_ERR_INVALID_STATE = 11;
MediaPlayer.dependencies.ErrorHandler.prototype.DOM_ERR_SYNTAX = 12;
MediaPlayer.dependencies.ErrorHandler.prototype.DOM_ERR_INVALID_MODIFICATION = 13;
MediaPlayer.dependencies.ErrorHandler.prototype.DOM_ERR_NAMESPACE = 14;
MediaPlayer.dependencies.ErrorHandler.prototype.DOM_ERR_INVALID_ACCESS = 15;
MediaPlayer.dependencies.ErrorHandler.prototype.DOM_ERR_SECURITY = 18;
MediaPlayer.dependencies.ErrorHandler.prototype.DOM_ERR_NETWORK = 19;
MediaPlayer.dependencies.ErrorHandler.prototype.DOM_ERR_ABORT = 20;
MediaPlayer.dependencies.ErrorHandler.prototype.DOM_ERR_URL_MISMATCH = 21;
MediaPlayer.dependencies.ErrorHandler.prototype.DOM_ERR_QUOTA_EXCEEDED = 22;
MediaPlayer.dependencies.ErrorHandler.prototype.DOM_ERR_TIMEOUT = 23;
MediaPlayer.dependencies.ErrorHandler.prototype.DOM_ERR_INVALID_NODE_TYPE = 24;
MediaPlayer.dependencies.ErrorHandler.prototype.DOM_ERR_DATA_CLONE = 25;

MediaPlayer.utils.EventBus = function() {
    "use strict";

    var registrations,

        getListeners = function(type, useCapture) {
            var captype = (useCapture ? '1' : '0') + type;

            if (!(captype in registrations)) {
                registrations[captype] = [];
            }

            return registrations[captype];
        },

        init = function() {
            registrations = {};
        };

    init();

    return {
        addEventListener: function(type, listener, useCapture) {
            var listeners = getListeners(type, useCapture),
                idx = listeners.indexOf(listener);

            if (idx === -1) {
                listeners.push(listener);
            }
        },

        removeEventListener: function(type, listener, useCapture) {
            var listeners = getListeners(type, useCapture),
                idx = listeners.indexOf(listener);

            if (idx !== -1) {
                listeners.splice(idx, 1);
            }
        },

        dispatchEvent: function(evt) {
            var listeners = getListeners(evt.type, false).slice(),
                i = 0;

            for (i = 0; i < listeners.length; i += 1) {
                listeners[i].call(this, evt);
            }
            return !evt.defaultPrevented;
        }
    };
};
/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Fraunhofer Fokus
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.dependencies.EventController = function() {
    "use strict";


    var inlineEvents = [], // Holds all Inline Events not triggered yet
        inbandEvents = [], // Holds all Inband Events not triggered yet
        activeEvents = [], // Holds all Events currently running
        eventInterval = null, // variable holding the setInterval
        refreshDelay = 100, // refreshTime for the setInterval
        presentationTimeThreshold = refreshDelay / 1000,
        MPD_RELOAD_SCHEME = "urn:mpeg:dash:event:2012",
        MPD_RELOAD_VALUE = 1,

        reset = function() {
            if (eventInterval !== null) {
                clearInterval(eventInterval);
                eventInterval = null;
            }
            inlineEvents = null;
            inbandEvents = null;
            activeEvents = null;
        },

        clear = function() {
            if (eventInterval !== null) {
                clearInterval(eventInterval);
                eventInterval = null;
            }
        },

        start = function() {
            var self = this;

            self.debug.log("[EventController] Start Event Controller");
            if (!isNaN(refreshDelay)) {
                eventInterval = setInterval(onEventTimer.bind(this), refreshDelay);
            }
        },

        /**
         * Add events to the eventList. Events that are not in the mpd anymore but not triggered yet will still be deleted
         * @param values
         */
        addInlineEvents = function(values) {
            var self = this;
            inlineEvents = [];

            if (values && values.length > 0) {
                inlineEvents = values;
            }
            self.debug.log("[EventController] Added " + values.length + " inline events");
        },

        /**
         * i.e. processing of any one event message box with the same id is sufficient
         * @param values
         */
        addInbandEvents = function(values) {
            var self = this,
                i = 0,
                event;

            for (i = 0; i < values.length; i++) {
                event = values[i];
                inbandEvents[event.id] = event;
                self.debug.log("[EventController] Add inband event with id " + event.id);
            }
        },

        /**
         * Itereate through the eventList and trigger/remove the events
         */
        onEventTimer = function() {
            triggerEvents.call(this, inbandEvents);
            triggerEvents.call(this, inlineEvents);
            removeEvents.call(this);
        },

        triggerEvents = function(events) {
            var self = this,
                currentVideoTime = this.videoModel.getCurrentTime(),
                presentationTime,
                j = 0,
                curr;

            /* == Trigger events that are ready == */
            if (events) {
                for (j = 0; j < events.length; j++) {
                    curr = events[j];

                    if (curr !== undefined) {
                        presentationTime = curr.presentationTime / curr.eventStream.timescale;
                        if (presentationTime === 0 || (presentationTime <= currentVideoTime && presentationTime + presentationTimeThreshold > currentVideoTime)) {
                            self.debug.log("[EventController] Start Event at " + currentVideoTime);
                            if (curr.duration > 0) {
                                activeEvents.push(curr);
                            }
                            if (curr.eventStream.schemeIdUri === MPD_RELOAD_SCHEME && curr.eventStream.value === MPD_RELOAD_VALUE) {
                                refreshManifest.call(this);
                            }
                            events.splice(j, 1);
                        }
                    }
                }
            }
        },

        /**
         * Remove events from the list that are over
         */
        removeEvents = function() {
            var self = this,
                currentVideoTime,
                i = 0,
                curr;

            if (activeEvents) {
                currentVideoTime = this.videoModel.getCurrentTime();

                for (i = 0; i < activeEvents.length; i++) {
                    curr = activeEvents[i];
                    if (curr !== null && (curr.duration + curr.presentationTime) / curr.eventStream.timescale < currentVideoTime) {
                        self.debug.log("[EventController] Remove Event at time " + currentVideoTime);
                        curr = null;
                        activeEvents.splice(i, 1);
                    }
                }
            }

        },

        refreshManifest = function() {
            var self = this,
                manifest = self.manifestModel.getValue(),
                url = manifest.mpdUrl;

            if (manifest.hasOwnProperty("Location")) {
                url = manifest.Location;
            }
            self.debug.log("[EventController] Refresh manifest @ " + url);
            self.manifestLoader.load(url).then(
                function(manifestResult) {
                    self.manifestModel.setValue(manifestResult);
                }
            );
        };

    return {
        manifestModel: undefined,
        manifestLoader: undefined,
        debug: undefined,
        system: undefined,
        videoModel: undefined,
        addInlineEvents: addInlineEvents,
        addInbandEvents: addInbandEvents,
        reset: reset,
        clear: clear,
        start: start
    };

};

MediaPlayer.dependencies.EventController.prototype = {
    constructor: MediaPlayer.dependencies.EventController
};
/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Digital Primates
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.dependencies.FragmentController = function() {
    "use strict";

    var fragmentModels = [],

        findModel = function(bufferController) {
            var ln = fragmentModels.length,
                i = 0;
            // We expect one-to-one relation between FragmentModel and BufferController,
            // so just compare the given BufferController object with the one that stored in the model to find the model for it
            for (i = 0; i < ln; i += 1) {
                if (fragmentModels[i].getContext() === bufferController) {
                    return fragmentModels[i];
                }
            }

            return null;
        },

        isReadyToLoadNextFragment = function() {
            var isReady = true,
                ln = fragmentModels.length,
                i = 0;
            // Loop through the models and check if all of them are in the ready state
            for (i = 0; i < ln; i += 1) {
                if (!fragmentModels[i].isReady()) {
                    isReady = false;
                    break;
                }
            }

            return isReady;
        },

        executeRequests = function() {
            var i = 0;

            for (i = 0; i < fragmentModels.length; i += 1) {
                fragmentModels[i].executeCurrentRequest();
            }
        };

    return {
        system: undefined,
        debug: undefined,

        process: function(bytes) {
            var result = null;

            if (bytes !== null && bytes !== undefined && bytes.byteLength > 0) {
                result = new Uint8Array(bytes);
            }

            return Q.when(result);
        },

        attachBufferController: function(bufferController) {
            var model;

            if (!bufferController) {
                return null;
            }
            // Wrap the buffer controller into model and store it to track the loading state and execute the requests
            model = findModel(bufferController);

            if (!model) {
                model = this.system.getObject("fragmentModel");
                model.setContext(bufferController);
                fragmentModels.push(model);
            }

            return model;
        },

        detachBufferController: function(bufferController) {
            var idx = fragmentModels.indexOf(bufferController);
            // If we have the model for the given buffer just remove it from array
            if (idx > -1) {
                fragmentModels.splice(idx, 1);
            }
        },

        onBufferControllerStateChange: function() {
            // Check if we are ready to execute pending requests and do it
            if (isReadyToLoadNextFragment()) {
                executeRequests.call(this);
            }
        },

        isFragmentLoadedOrPending: function(bufferController, request) {
            var fragmentModel = findModel(bufferController),
                isLoaded;

            if (!fragmentModel) {
                return false;
            }

            isLoaded = fragmentModel.isFragmentLoadedOrPending(request);

            return isLoaded;
        },

        getPendingRequests: function(bufferController) {
            var fragmentModel = findModel(bufferController);

            if (!fragmentModel) {
                return null;
            }

            return fragmentModel.getPendingRequests();
        },

        getLoadingRequests: function(bufferController) {
            var fragmentModel = findModel(bufferController);

            if (!fragmentModel) {
                return null;
            }

            return fragmentModel.getLoadingRequests();
        },

        isInitializationRequest: function(request) {
            return (request && request.type && request.type.toLowerCase() === "initialization segment");
        },

        getLoadingTime: function(bufferController) {
            var fragmentModel = findModel(bufferController);

            if (!fragmentModel) {
                return null;
            }

            return fragmentModel.getLoadingTime();
        },

        getExecutedRequestForTime: function(model, time) {
            if (model) {
                return model.getExecutedRequestForTime(time);
            }

            return null;
        },

        removeExecutedRequest: function(model, request) {
            if (model) {
                model.removeExecutedRequest(request);
            }
        },

        removeExecutedRequestsBeforeTime: function(model, time) {
            if (model) {
                model.removeExecutedRequestsBeforeTime(time);
            }
        },

        clearExecutedRequests: function(model) {
            if (model) {
                model.clearExecutedRequests();
            }
        },

        cancelPendingRequestsForModel: function(model) {
            if (model) {
                model.cancelPendingRequests();
            }
        },

        abortRequestsForModel: function(model) {
            if (model) {
                model.abortRequests();
            }
        },

        prepareFragmentForLoading: function(bufferController, request, startLoadingCallback, successLoadingCallback, errorLoadingCallback, streamEndCallback) {
            var fragmentModel = findModel(bufferController);

            if (!fragmentModel || !request) {
                return null;
            }
            // Store the request and all the necessary callbacks in the model for deferred execution
            fragmentModel.addRequest(request);
            fragmentModel.setCallbacks(startLoadingCallback, successLoadingCallback, errorLoadingCallback, streamEndCallback);

            return true;
        }
    };
};

MediaPlayer.dependencies.FragmentController.prototype = {
    constructor: MediaPlayer.dependencies.FragmentController
};
/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Digital Primates
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.dependencies.FragmentLoader = function() {
    "use strict";

    var DEFAULT_RETRY_ATTEMPTS = 2,
        DEFAULT_RETRY_INTERVAL = 500,
        retryAttempts = DEFAULT_RETRY_ATTEMPTS,
        retryInterval = DEFAULT_RETRY_INTERVAL,
        retryCount = 0,
        xhrs = [],
        type,

        _checkForExistence = function(request) {
            var req = new XMLHttpRequest(),
                isSuccessful = false;

            req.open("HEAD", request.url, true);

            req.onload = function() {
                if (req.status < 200 || req.status > 399) {
                    return;
                }
                isSuccessful = true;
                request.deferred.resolve(request);
            };

            req.onloadend = req.onerror = function() {
                if (isSuccessful) {
                    return;
                }
                request.deferred.reject(req);
            };

            req.send();
        },

        _loadRequest = function(request) {
            var deferred = Q.defer(),
                req = new XMLHttpRequest(),
                httpRequestMetrics = null,
                firstProgress = true,
                needFailureReport = true,
                lastTraceTime = null,
                self = this;

            xhrs.push(req);
            request.requestStartDate = new Date();

            httpRequestMetrics = self.metricsModel.addHttpRequest(
                request.streamType,
                null,
                request.type,
                request.url,
                null,
                request.range,
                request.requestStartDate,
                null,
                null,
                null,
                null,
                request.duration,
                request.startTime,
                request.quality);

            self.metricsModel.appendHttpTrace(
                httpRequestMetrics,
                request.requestStartDate,
                request.requestStartDate.getTime() - request.requestStartDate.getTime(), [0]);

            lastTraceTime = request.requestStartDate;

            req.open("GET", self.tokenAuthentication.addTokenAsQueryArg(request.url), true);
            req.responseType = "arraybuffer";
            req = self.tokenAuthentication.setTokenInRequestHeader(req);

            if (request.range) {
                req.setRequestHeader("Range", 'bytes='+request.range);
            }

            req.onprogress = function(event) {
                var currentTime = new Date();
                if (firstProgress) {
                    firstProgress = false;
                    if (!event.lengthComputable || (event.lengthComputable && event.total !== event.loaded)) {
                        request.firstByteDate = currentTime;
                        httpRequestMetrics.tresponse = currentTime;
                    }
                }

                if (event.lengthComputable) {
                    request.bytesLoaded = event.loaded;
                    request.bytesTotal = event.total;
                }

                self.metricsModel.appendHttpTrace(
                    httpRequestMetrics,
                    currentTime,
                    currentTime.getTime() - lastTraceTime.getTime(), [request.bytesLoaded ? request.bytesLoaded : 0]);

                lastTraceTime = currentTime;

                self.notify(MediaPlayer.dependencies.FragmentLoader.eventList.ENAME_LOADING_PROGRESS, {
                    request: request,
                    httpRequestMetrics: httpRequestMetrics,
                    lastTraceTime: lastTraceTime
                });

            };

            req.onload = function() {
                if (req.status < 200 || req.status > 399) {
                    return;
                }
                needFailureReport = false;

                var currentTime = new Date(),
                    bytes = req.response,
                    bytesLength = (bytes ? bytes.byteLength : 0),
                    latency,
                    download;

                if (!request.firstByteDate) {
                    request.firstByteDate = request.requestStartDate;
                }
                request.requestEndDate = currentTime;

                latency = (request.firstByteDate.getTime() - request.requestStartDate.getTime());
                download = (request.requestEndDate.getTime() - request.firstByteDate.getTime());

                self.debug.log("[FragmentLoader]["+type+"] Loaded: " + request.url + " (" + req.status + ", " + latency + "ms, " + download + "ms)");

                httpRequestMetrics.tresponse = request.firstByteDate;
                httpRequestMetrics.tfinish = request.requestEndDate;
                httpRequestMetrics.responsecode = req.status;

                httpRequestMetrics.bytesLength = bytesLength;

                self.metricsModel.appendHttpTrace(
                    httpRequestMetrics,
                    currentTime,
                    currentTime.getTime() - lastTraceTime.getTime(), [bytesLength]);

                lastTraceTime = currentTime;

                deferred.resolve({
                    data: bytes,
                    request: request
                });
            };

            req.onabort = function() {
                var currentTime = new Date(),
                    lastTrace,
                    bytes;

                req.aborted = true;

                if (httpRequestMetrics.trace.length === 0) {
                    return;
                }
                lastTrace = httpRequestMetrics.trace[httpRequestMetrics.trace.length - 1];
                bytes = lastTrace.b[0];

                request.requestEndDate = currentTime;
                httpRequestMetrics.tresponse = request.firstByteDate;
                httpRequestMetrics.tfinish = request.requestEndDate;
                httpRequestMetrics.responsecode = req.status;

                httpRequestMetrics.bytesLength = bytes;
            };

            req.onloadend = req.onerror = function() {
                if (xhrs.indexOf(req) === -1) {
                    return;
                }
                
                xhrs.splice(xhrs.indexOf(req), 1);
                
                if (!needFailureReport) {
                    return;
                }
                needFailureReport = false;

                httpRequestMetrics.responsecode = req.status;

                // When request failed do not complete http metrics so that
                // DownloadRatioRule does not take into account these request
                /*var currentTime = new Date(),
                    bytes = req.response,
                    latency,
                    download;

                if (!request.firstByteDate) {
                    request.firstByteDate = request.requestStartDate;
                }
                request.requestEndDate = currentTime;

                latency = (request.firstByteDate.getTime() - request.requestStartDate.getTime());
                download = (request.requestEndDate.getTime() - request.firstByteDate.getTime());

                httpRequestMetrics.tresponse = request.firstByteDate;
                httpRequestMetrics.tfinish = request.requestEndDate;
                httpRequestMetrics.responsecode = req.status;

                self.metricsModel.appendHttpTrace(httpRequestMetrics,
                    currentTime,
                    currentTime.getTime() - lastTraceTime.getTime(), [bytes ? bytes.byteLength : 0]);
                lastTraceTime = currentTime;*/

                deferred.reject(req);
            };

            self.debug.log("[FragmentLoader]["+type+"] Load: " + request.url);

            req.send();
            return deferred.promise;
        },

        _load = function (request, deferred) {
            var self = this;

            _loadRequest.call(self, request).then(function(result) {
                    retryCount = 0;
                    deferred.resolve(result);
                }, function(reqerror) {
                     if (reqerror.aborted) {
                        // Request has been aborted => set status to 0
                        request.status = 0;
                        request.aborted = true;
                        deferred.reject(request);
                    } else if (retryCount >= retryAttempts) {
                        // No (more) retry => set status and reject
                        retryCount = 0;
                        request.status = reqerror.status;
                        deferred.reject(request);
                    } else {
                        // Retry
                        setTimeout(function() {
                            retryCount++;
                            _load.call(self, request, deferred);
                        }, retryInterval);
                    }
                });           

        };

    return {
        metricsModel: undefined,
        debug: undefined,
        tokenAuthentication: undefined,
        config: undefined,
        notify: undefined,
        subscribe: undefined,
        unsubscribe: undefined,

        setup: function() {
            retryAttempts = this.config.getParam("FragmentLoader.RetryAttempts", "number", DEFAULT_RETRY_ATTEMPTS);
            retryInterval = this.config.getParam("FragmentLoader.RetryInterval", "number", DEFAULT_RETRY_INTERVAL);
        },

        setType: function (value) {
            type = value;
        },

        load: function(request) {
            var deferred = Q.defer();

            // MSS use case: if initialization segment and data already ready (automatically generated),
            // then do not download segment
            if (request.type === "Initialization Segment" && request.data) {
                deferred.resolve(request, {data: request.data});
            } else {
                _load.call(this, request, deferred);
            }

            return deferred.promise;
        },

        abort: function() {
            var i = 0;

            for (i = 0; i < xhrs.length; i += 1) {
                this.debug.log("[FragmentLoader]["+type+"] Abort XHR " + (xhrs[i].responseURL ? xhrs[i].responseURL : ""));
                xhrs[i].abort();
            }
        },

        checkForExistence: function(req) {
            if (!req) {
                return Q.when(null);
            }

            req.deferred = Q.defer();
            _checkForExistence.call(this, req);

            return req.deferred.promise;
        }
    };
};

MediaPlayer.dependencies.FragmentLoader.prototype = {
    constructor: MediaPlayer.dependencies.FragmentLoader
};

MediaPlayer.dependencies.FragmentLoader.eventList = {
    ENAME_LOADING_PROGRESS: "loadingProgress"
};
/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Digital Primates
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

MediaPlayer.dependencies.FragmentModel = function () {
    "use strict";

    var context,
        executedRequests = [],
        pendingRequests = [],
        loadingRequests = [],
        startLoadingCallback,
        successLoadingCallback,
        errorLoadingCallback,
        streamEndCallback,
        type,

        LOADING_REQUEST_THRESHOLD = 2,

        loadCurrentFragment = function(request) {
            var onSuccess,
                onError,
                self = this;

            // We are about to start loading the fragment, so execute the corresponding callback
            startLoadingCallback.call(context, request);

            onSuccess = function(request, response) {
                loadingRequests.splice(loadingRequests.indexOf(request), 1);
                executedRequests.push(request);
                successLoadingCallback.call(context, request, response);
                request.deferred = null;
            };

            onError = function(request) {
                loadingRequests.splice(loadingRequests.indexOf(request), 1);
                errorLoadingCallback.call(context, request);
                request.deferred = null;
            };

            self.fragmentLoader.load(request).then(onSuccess.bind(context, request),
                onError.bind(context, request));
        },

        sortRequestsByProperty = function(requestsArray, sortProp) {
            var compare = function (req1, req2){
                if (req1[sortProp] < req2[sortProp]) {
                    return -1;
                }
                if (req1[sortProp] > req2[sortProp]){
                    return 1;
                }
                return 0;
            };

            requestsArray.sort(compare);

        },

        removeExecutedRequest = function(request) {
            var idx = executedRequests.indexOf(request);

            if (idx !== -1) {
                executedRequests.splice(idx, 1);
            }
        };

    return {
        system: undefined,
        debug: undefined,
        fragmentLoader: undefined,

        setContext: function(value) {
            context = value;
        },

        getContext: function() {
            return context;
        },

        setType: function (value) {
            type = value;
            if (this.fragmentLoader) {
                this.fragmentLoader.setType(value);
            }
        },

        addRequest: function(value) {
            if (value) {
                if (this.isFragmentLoadedOrPending(value)) {
                    return;
                }

                pendingRequests.push(value);
                sortRequestsByProperty.call(this, pendingRequests, "index");
            }
        },

        setCallbacks: function(onLoadingStart, onLoadingSuccess, onLoadingError, onStreamEnd) {
            startLoadingCallback = onLoadingStart;
            streamEndCallback = onStreamEnd;
            errorLoadingCallback = onLoadingError;
            successLoadingCallback = onLoadingSuccess;
        },

        isFragmentLoadedOrPending: function(request) {
            var isLoaded = false,
                i = 0,
                req;

            // First, check if the fragment has already been loaded
            for (i = 0; i < executedRequests.length; i++) {
                req = executedRequests[i];
                if (request.startTime === req.startTime || ((req.action === "complete") && request.action === req.action)) {
                    //self.debug.log(request.streamType + " Fragment already loaded for time: " + request.startTime);
                    if (request.url === req.url) {
                        //self.debug.log(request.streamType + " Fragment url already loaded: " + request.url);
                        isLoaded = true;
                        break;
                    } else {
                        // Remove overlapping segment of a different quality
                        executedRequests.splice(i, 1);
                        i--;
                    }
                }
            }

            // if it has not been loaded check if it is going to be loaded
            if (!isLoaded) {
                for (i = 0; i < pendingRequests.length; i++) {
                    req = pendingRequests[i];
                    if ((request.url === req.url) && (request.startTime === req.startTime)) {
                        isLoaded = true;
                    }
                }
            }

            if (!isLoaded) {
                for (i = 0; i < loadingRequests.length; i++) {
                    req = loadingRequests[i];
                    if ((request.url === req.url) && (request.startTime === req.startTime)) {
                        isLoaded = true;
                    }
                }
            }

            return isLoaded;
        },

        isReady: function() {
            return context.isReady();
        },

        getPendingRequests: function() {
            return pendingRequests;
        },

        getLoadingRequests: function() {
            return loadingRequests;
        },

        getLoadingTime: function() {
            var loadingTime = 0,
                req,
                i;

            // get the latest loaded request and calculate its loading time. In case requestEndDate/firstByteDate properties
            // have not been set (e.g. for a request with action='complete') we should get the previous request.
            for (i = executedRequests.length - 1; i >= 0; i -= 1) {
                req = executedRequests[i];

                if ((req.requestEndDate instanceof Date) && (req.firstByteDate instanceof Date)) {
                    loadingTime = req.requestEndDate.getTime() - req.firstByteDate.getTime();
                    break;
                }
            }

            return loadingTime;
        },

        getExecutedRequestForTime: function(time) {
            var lastIdx = executedRequests.length - 1,
                start = NaN,
                end = NaN,
                req = null,
                i;

            // loop through the executed requests and pick the one for which the playback interval matches the given time
            for (i = lastIdx; i >= 0; i -=1) {
                req = executedRequests[i];
                start = req.startTime;
                end = start + req.duration;
                if (!isNaN(start) && !isNaN(end) && (time > start) && (time < end)) {
                    return req;
                }
            }

            return null;
        },

        getExecutedRequestForQualityAndIndex: function(quality, index) {
            var lastIdx = executedRequests.length - 1,
                req = null,
                i;

            for (i = lastIdx; i >= 0; i -=1) {
                req = executedRequests[i];
                if (req.quality === quality && req.index === index) {
                    return req;
                }
            }

            return null;
        },

        removeExecutedRequest: function(request) {
            removeExecutedRequest.call(this, request);
        },

        removeExecutedRequestsBeforeTime: function(time) {
            var lastIdx = executedRequests.length - 1,
                start = NaN,
                req = null,
                i;

            // loop through the executed requests and remove the ones for which startTime is less than the given time
            for (i = lastIdx; i >= 0; i -=1) {
                req = executedRequests[i];
                start = req.startTime;
                if (!isNaN(start) && (start < time)) {
                    removeExecutedRequest.call(this, req);
                }
            }
        },

        clearExecutedRequests: function() {
            executedRequests = [];
        },

        cancelPendingRequests: function() {
            pendingRequests = [];
        },

        abortRequests: function() {
            this.fragmentLoader.abort();
            loadingRequests = [];
        },

        executeCurrentRequest: function() {
            var self = this,
                currentRequest;

            if (pendingRequests.length === 0) {
                return;
            }

            if (loadingRequests.length >= LOADING_REQUEST_THRESHOLD) {
                // too many requests have been loading, do nothing until some of them are loaded or aborted
                return;
            }

            // take the next request to execute and remove it from the list of pending requests
            currentRequest = pendingRequests.shift();

            switch (currentRequest.action) {
                case "complete":
                    // Stream has completed, execute the correspoinding callback
                    executedRequests.push(currentRequest);
                    streamEndCallback.call(context, currentRequest);
                    break;
                case "download":
                    loadingRequests.push(currentRequest);
                    loadCurrentFragment.call(self, currentRequest);
                    break;
                default:
                    this.debug.log("Unknown request action.");
                    if (currentRequest.deferred) {
                        currentRequest.deferred.reject();
                        currentRequest.deferred = null;
                    } else {
                        errorLoadingCallback.call(context, currentRequest);
                    }
            }
        }
    };
};

MediaPlayer.dependencies.FragmentModel.prototype = {
    constructor: MediaPlayer.dependencies.FragmentModel
};
/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Digital Primates
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.dependencies.ManifestLoader = function() {
    "use strict";

    var DEFAULT_RETRY_ATTEMPTS = 2,
        DEFAULT_RETRY_INTERVAL = 500,
        _retryAttempts = DEFAULT_RETRY_ATTEMPTS,
        _retryInterval = DEFAULT_RETRY_INTERVAL,
        _xhrLoader = null,

        _getDecodedResponseText = function(text) {
            var fixedCharCodes = '',
                i = 0,
                charCode;

            // Some content is not always successfully decoded by every browser.
            // Known problem case: UTF-16 BE manifests on Internet Explorer 11.
            // This function decodes any text that the browser failed to decode.
            if (text.length < 1) {
                return text;
            }

            // The troublesome bit here is that IE still strips off the BOM, despite incorrectly decoding the file.
            // So we will simply assume that the first character is < (0x3C) and detect its invalid decoding (0x3C00).
            if (text.charCodeAt(0) !== 0x3C00) {
                return text;
            }

            // We have a problem!
            for (i = 0; i < text.length; i += 1) {
                charCode = text.charCodeAt(i);

                // Swap around the two bytes that make up the character code.
                fixedCharCodes += String.fromCharCode(((charCode & 0xFF) << 8 | (charCode & 0xFF00) >> 8));
            }

            return fixedCharCodes;
        },

        _parseBaseUrl = function(url) {
            var base = null;

            if (url.indexOf("/") !== -1) {
                if (url.indexOf("?") !== -1) {
                    url = url.substring(0, url.indexOf("?"));
                }
                base = url.substring(0, url.lastIndexOf("/") + 1);
            }

            return base;
        },

        _abort = function() {

            if (_xhrLoader !== null) {
                _xhrLoader.abort();
            }

            this.parser.abort();
        },

        _load = function(url) {
            var baseUrl = _parseBaseUrl(url),
                deferred = Q.defer(),
                self = this;

            _xhrLoader = new MediaPlayer.dependencies.XHRLoader();
            _xhrLoader.initialize(null, _retryAttempts, _retryInterval);
            _xhrLoader.load(url).then(
                function (request) {

                    // Get the redirection URL and use it as base URL for subsequent requests
                    if (request.responseURL) {
                        self.debug.log("[ManifestLoader] Redirect URL: " + request.responseURL);
                        baseUrl = _parseBaseUrl(request.responseURL);
                    }

                    self.tokenAuthentication.checkRequestHeaderForToken(request);
                    self.metricsModel.addHttpRequest("stream",
                        null,
                        "MPD",
                        url,
                        null,
                        null,
                        request.startDate,
                        request.endDate,
                        request.status,
                        null,
                        null);

                    self.parser.parse(_getDecodedResponseText(request.responseText), baseUrl).then(
                        function(manifest) {
                            if (manifest) {
                                manifest.mpdUrl = url;
                                manifest.mpdLoadedTime = request.endDate;
                                self.metricsModel.addManifestUpdate("stream", manifest.type, request.startDate, request.endDate, manifest.availabilityStartTime);
                                deferred.resolve(manifest);
                            } else {
                                deferred.reject();
                            }
                        },
                        function(error) {
                            // Check if reject is due to other issue than manifest parsing
                            // (for example HLS variant steam playlist download error)
                            if (error && error.name && error.message) {
                                deferred.reject(error);
                            } else {
                                self.debug.error("[ManifestLoader] Manifest parsing error");
                                deferred.reject({
                                    name: MediaPlayer.dependencies.ErrorHandler.prototype.MANIFEST_ERR_PARSE,
                                    message: "Failed to parse manifest",
                                    data: {
                                        url: url
                                    }
                                });
                            }
                        }
                    );
                },
                function(request) {

                    if (!request || request.aborted) {
                        deferred.reject();
                    } else {

                        self.metricsModel.addHttpRequest("stream",
                            null,
                            "MPD",
                            url,
                            null,
                            null,
                            request.startDate,
                            request.endDate,
                            request.status,
                            null,
                            null);

                        deferred.reject({
                            name: MediaPlayer.dependencies.ErrorHandler.prototype.DOWNLOAD_ERR_MANIFEST,
                            message: "Failed to download manifest",
                            data : {
                                url: url,
                                status: request.status
                            }
                        });
                    }
                }
            );

            return deferred.promise;
        };

    return {
        debug: undefined,
        parser: undefined,
        config: undefined,
        metricsModel: undefined,
        tokenAuthentication: undefined,

        setup: function() {
            _retryAttempts = this.config.getParam("ManifestLoader.RetryAttempts", "number", DEFAULT_RETRY_ATTEMPTS);
            _retryInterval = this.config.getParam("ManifestLoader.RetryInterval", "number", DEFAULT_RETRY_INTERVAL);
        },

        load: _load,

        abort: _abort
    };
};

MediaPlayer.dependencies.ManifestLoader.prototype = {
    constructor: MediaPlayer.dependencies.ManifestLoader
};
/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Digital Primates
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.dependencies.ManifestUpdater = function() {
    "use strict";

    var refreshDelay = NaN,
        refreshTimer = null,
        isStopped = false,
        deferredUpdate,

        clear = function() {
            if (refreshTimer !== null) {
                clearInterval(refreshTimer);
                refreshTimer = null;
            }
        },

        start = function() {
            clear.call(this);

            if (!isNaN(refreshDelay)) {
                this.debug.log("Refresh manifest in " + refreshDelay + " seconds.");
                refreshTimer = setTimeout(onRefreshTimer.bind(this), Math.min(refreshDelay * 1000, Math.pow(2, 31) - 1), this);
            }
        },

        update = function() {
            var self = this,
                manifest = self.manifestModel.getValue(),
                timeSinceLastUpdate, 
                t;

            if (manifest !== undefined && manifest !== null) {
                t = self.manifestExt.getRefreshDelay(manifest);
                timeSinceLastUpdate = (new Date().getTime() - manifest.mpdLoadedTime.getTime()) / 1000;
                refreshDelay = Math.max(t - timeSinceLastUpdate, 0);
                start.call(self);
            }
        },

        onRefreshTimer = function() {
            var self = this,
                manifest,
                url;

            // The manifest should not update until the previous update has completed. A promise postpones the update
            // until is is resolved. For the first time the promise does not exist yet, so pass 'true' instead.
            Q.when(deferredUpdate ? deferredUpdate.promise : true).then(
                function() {
                    deferredUpdate = Q.defer();
                    manifest = self.manifestModel.getValue();
                    url = manifest.mpdUrl;

                    if (manifest.hasOwnProperty("Location")) {
                        url = manifest.Location;
                    }

                    //self.debug.log("Refresh manifest @ " + url);

                    self.manifestLoader.load(url).then(
                        function(manifestResult) {
                            self.manifestModel.setValue(manifestResult);
                            self.debug.log("Manifest has been refreshed.");
                            //self.debug.log(manifestResult);
                            if (isStopped) {
                                return;
                            }

                            update.call(self);
                        }
                    );
                }
            );
        },

        onStreamsComposed = function() {
            // When streams are ready we can consider manifest update completed. Resolve the update promise.
            if (deferredUpdate) {
                deferredUpdate.resolve();
            }
        };

    return {
        debug: undefined,
        system: undefined,
        manifestModel: undefined,
        manifestExt: undefined,
        manifestLoader: undefined,

        setup: function() {
            update.call(this);
            // Listen to streamsComposed event to be aware that the streams have been composed
            this.system.mapHandler("streamsComposed", undefined, onStreamsComposed.bind(this));
        },

        start: function() {
            isStopped = false;
            update.call(this);
        },

        stop: function() {
            isStopped = true;
            clear.call(this);
        }
    };
};

MediaPlayer.dependencies.ManifestUpdater.prototype = {
    constructor: MediaPlayer.dependencies.ManifestUpdater
};
/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 * 
 * Copyright (c) 2013, Digital Primates
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.models.ManifestModel = function () {
    "use strict";

    var manifest = null;

    return {
        system: undefined,
        eventBus: undefined,

        getValue:  function () {
            return manifest;
        },

        setValue: function (value) {
            manifest = value;
            if (manifest) {
                this.system.notify("manifestUpdated");
            }

            if (manifest !== null) {
                this.eventBus.dispatchEvent({
                    type: "manifestLoaded",
                    data: value
                });
            }
        }
    };
};

MediaPlayer.models.ManifestModel.prototype = {
    constructor: MediaPlayer.models.ManifestModel
};





/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Digital Primates
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.dependencies.MediaSourceExtensions = function () {
    "use strict";
};

MediaPlayer.dependencies.MediaSourceExtensions.prototype = {
    constructor: MediaPlayer.dependencies.MediaSourceExtensions,

    createMediaSource: function () {
        "use strict";

        var hasWebKit = ("WebKitMediaSource" in window),
            hasMediaSource = ("MediaSource" in window);

        if (hasMediaSource) {
            return new MediaSource();
        } else if (hasWebKit) {
            return new WebKitMediaSource();
        }

        return null;
    },

    attachMediaSource: function (source, videoModel) {
        "use strict";

        videoModel.setSource(window.URL.createObjectURL(source));
        return true;
    },

    detachMediaSource: function (videoModel) {
        "use strict";
        videoModel.setSource(null);
        return true;
    },

    setDuration: function (source, value) {
        "use strict";
        var i,
            updating = false;

        if (source.readyState !== 'open') return source.duration;

        for (i = 0; i < source.sourceBuffers.length; i++) {
            if(source.sourceBuffers[i].updating){
                updating = true;
                break;
            }
        }

        if (!updating) {
            source.duration = value;
        }

        return source.duration;
    },

    signalEndOfStream: function(source) {
        "use strict";
        var buffers = source.sourceBuffers,
            ln = buffers.length,
            i = 0;

        if (source.readyState !== 'open') {
            return;
        }

        for (i; i < ln; i++) {
            if (buffers[i].updating) {
                return;
            }
            if (buffers[i].buffered.length === 0) {
                return;
            }
        }

        source.endOfStream();
        return true;
    }
};
/*
 * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.
 * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2014, Orange
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.dependencies.MetricsExtensions = function() {
    "use strict";

    var h264ProfileMap = {
        "42": "Baseline",
        "4D": "Main",
        "58": "Extended",
        "64": "High"
    };

    var findRepresentionInPeriodArray = function(periodArray, representationId) {
        var period,
            adaptationSet,
            adaptationSetArray,
            representation,
            representationArray,
            periodArrayIndex,
            adaptationSetArrayIndex,
            representationArrayIndex;

        for (periodArrayIndex = 0; periodArrayIndex < periodArray.length; periodArrayIndex = periodArrayIndex + 1) {
            period = periodArray[periodArrayIndex];
            adaptationSetArray = period.AdaptationSet_asArray;
            for (adaptationSetArrayIndex = 0; adaptationSetArrayIndex < adaptationSetArray.length; adaptationSetArrayIndex = adaptationSetArrayIndex + 1) {
                adaptationSet = adaptationSetArray[adaptationSetArrayIndex];
                representationArray = adaptationSet.Representation_asArray;
                for (representationArrayIndex = 0; representationArrayIndex < representationArray.length; representationArrayIndex = representationArrayIndex + 1) {
                    representation = representationArray[representationArrayIndex];
                    if (representationId === representation.id) {
                        return representation;
                    }
                }
            }
        }

        return null;
    };

    var adaptationIsType = function(adaptation, bufferType) {
        var found = false;
        // TODO : HACK ATTACK
        // Below we call getIsVideo and getIsAudio and then check the adaptation set for a 'type' property.
        // getIsVideo and getIsAudio are adding this 'type' property and SHOULD NOT BE.
        // This method expects getIsVideo and getIsAudio to be sync, but they are async (returns a promise).
        // This is a bad workaround!
        // The metrics extensions should have every method use promises.

        if (bufferType === "video") {
            this.manifestExt.getIsVideo(adaptation);
            if (adaptation.type === "video") {
                found = true;
            }
        } else if (bufferType === "audio") {
            this.manifestExt.getIsAudio(adaptation);
            if (adaptation.type === "audio") {
                found = true;
            }
        } else if (bufferType === "text") {
            this.manifestExt.getIsText(adaptation);
            if (adaptation.type === "text") {
                found = true;
            }
        } else {
            found = false;
        }

        return found;
    };

    var rslt = MediaPlayer.utils.copyMethods(Dash.dependencies.DashMetricsExtensions);

    rslt.config = undefined;

    rslt.getDuration = function() {
        var self = this,
            manifest = self.manifestModel.getValue(),
            duration = manifest ? manifest.Period.duration : null;

        if (duration !== Infinity) {
            return duration;
        }

        return -1;
    };

    rslt.getFormatForType = function(type) {
        var self = this,
            manifest = self.manifestModel.getValue(),
            i = 0,
            adaptation;

        if (!manifest) {
            return null;
        }

        for (i = 0; i < manifest.Period.AdaptationSet.length; i++) {
            adaptation = manifest.Period.AdaptationSet[i];
            if (adaptation.type === type) {
                return adaptation.mimeType;
            }
        }

        return null;
    };

    rslt.getCodecForType = function(type) {
        var self = this,
            manifest = self.manifestModel.getValue(),
            i = 0,
            adaptation;

        if (!manifest) {
            return null;
        }

        for (i = 0; i < manifest.Period.AdaptationSet.length; i++) {
            adaptation = manifest.Period.AdaptationSet[i];
            if (adaptation.type === type || adaptation.contentType === type) {
                //return codecs of the first Representation
                return adaptation.Representation_asArray[0].codecs;
            }
        }

        return null;
    };

    rslt.getVideoWidthForRepresentation = function(representationId) {
        var self = this,
            manifest = self.manifestModel.getValue(),
            representation,
            periodArray;

        if (!manifest) {
            return null;
        }

        periodArray = manifest.Period_asArray;
        representation = findRepresentionInPeriodArray.call(self, periodArray, representationId);
        if (representation === null) {
            return null;
        }
        return representation.width;
    };

    rslt.getVideoHeightForRepresentation = function(representationId) {
        var self = this,
            manifest = self.manifestModel.getValue(),
            representation,
            periodArray;

        if (!manifest) {
            return null;
        }

        periodArray = manifest.Period_asArray;
        representation = findRepresentionInPeriodArray.call(self, periodArray, representationId);
        if (representation === null) {
            return null;
        }
        return representation.height;
    };

    rslt.getCodecsForRepresentation = function(representationId) {
        var self = this,
            manifest = self.manifestModel.getValue(),
            representation,
            periodArray = manifest.Period_asArray;

        if (!manifest) {
            return null;
        }

        representation = findRepresentionInPeriodArray.call(self, periodArray, representationId);
        if (representation === null) {
            return null;
        }
        return representation.codecs;
    };

    rslt.getH264ProfileLevel = function(codecs) {

        if (codecs.indexOf("avc1") < 0) {
            return "";
        }
        var profile = h264ProfileMap[codecs.substr(5, 2)],
            level = parseInt(codecs.substr(9, 2), 16) / 10.0;

        return profile + "@" + level.toString();
    };

    rslt.getBitratesForType = function(type, data) {
        var self = this,
            manifest = self.manifestModel.getValue(),
            periodArray,
            period,
            periodArrayIndex,
            adaptationSetArray,
            adaptationSet = null,
            representation,
            representationArray,
            adaptationSetArrayIndex,
            representationArrayIndex,
            bitrateArray = [];

        if (!manifest) {
            return null;
        }

        if (data) {
            adaptationSet = data;
        } else {
            periodArray = manifest.Period_asArray;

            for (periodArrayIndex = 0; periodArrayIndex < periodArray.length; periodArrayIndex = periodArrayIndex + 1) {
                period = periodArray[periodArrayIndex];
                adaptationSetArray = period.AdaptationSet_asArray;
                for (adaptationSetArrayIndex = 0; adaptationSetArrayIndex < adaptationSetArray.length; adaptationSetArrayIndex = adaptationSetArrayIndex + 1) {
                    adaptationSet = adaptationSetArray[adaptationSetArrayIndex];
                    if (adaptationIsType.call(self, adaptationSetArray[adaptationSetArrayIndex], type)) {
                        adaptationSet = adaptationSetArray[adaptationSetArrayIndex];
                        break;
                    }
                }
            }
        }

        if (adaptationSet !== null) {
            // Order adaptationSet's representations in bitrate ascending value
            adaptationSet = self.manifestExt.processAdaptation(adaptationSet);
            representationArray = adaptationSet.Representation_asArray;
            for (representationArrayIndex = 0; representationArrayIndex < representationArray.length; representationArrayIndex = representationArrayIndex + 1) {
                representation = representationArray[representationArrayIndex];
                bitrateArray.push(representation.bandwidth);
            }
        }

        return bitrateArray;
    };

    rslt.getBitratesWithResolutionForType = function(type) {
        var self = this,
            manifest = self.manifestModel.getValue(),
            periodArray,
            period,
            periodArrayIndex,
            adaptationSet,
            adaptationSetArray,
            representation,
            representationArray,
            adaptationSetArrayIndex,
            representationArrayIndex,
            bitrateArray = [];

        if (!manifest) {
            return null;
        }

        periodArray = manifest.Period_asArray;

        for (periodArrayIndex = 0; periodArrayIndex < periodArray.length; periodArrayIndex = periodArrayIndex + 1) {
            period = periodArray[periodArrayIndex];
            adaptationSetArray = period.AdaptationSet_asArray;
            for (adaptationSetArrayIndex = 0; adaptationSetArrayIndex < adaptationSetArray.length; adaptationSetArrayIndex = adaptationSetArrayIndex + 1) {
                adaptationSet = adaptationSetArray[adaptationSetArrayIndex];
                if (adaptationIsType.call(self, adaptationSet, type)) {
                    //order adaptation in bitrate ascending value
                    adaptationSet = self.manifestExt.processAdaptation(adaptationSet);
                    representationArray = adaptationSet.Representation_asArray;
                    for (representationArrayIndex = 0; representationArrayIndex < representationArray.length; representationArrayIndex = representationArrayIndex + 1) {
                        representation = representationArray[representationArrayIndex];
                        var reso = {
                            bitrate: representation.bandwidth,
                            width: representation.width,
                            height: representation.height
                        };
                        bitrateArray.push(reso);
                    }
                    return bitrateArray;
                }
            }
        }

        return bitrateArray;
    };

    return rslt;
};

MediaPlayer.dependencies.MetricsExtensions.prototype = {
    constructor: MediaPlayer.dependencies.MetricsExtensions
};

/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Digital Primates
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 MediaPlayer.models.MetricsModel = function () {
    "use strict";

    return {
        system : undefined,
        eventBus: undefined,
        config: undefined,
        streamMetrics: {},
        metricsChanged: function () {
            this.eventBus.dispatchEvent({
                type: "metricsChanged",
                data: {}
            });
        },

        metricChanged: function (streamType) {
            this.eventBus.dispatchEvent({
                type: "metricChanged",
                data: {stream: streamType}
            });
            this.metricsChanged();
        },

        metricUpdated: function (streamType, metricType, vo) {
            this.eventBus.dispatchEvent({
                type: "metricUpdated",
                data: {stream: streamType, metric: metricType, value: vo}
            });
            this.metricChanged(streamType);
        },

        metricAdded: function (streamType, metricType, vo) {
            this.eventBus.dispatchEvent({
                type: "metricAdded",
                data: {stream: streamType, metric: metricType, value: vo}
            });
            this.metricChanged(streamType);
        },

        clearAllCurrentMetrics: function () {
            var self = this;

            for (var type in this.streamMetrics) {
                if (this.streamMetrics.hasOwnProperty(type) && (type === "stream")) {
                    delete this.streamMetrics[type];
                } else {
                    var keepBW = this.config.getParamFor(type, "ABR.keepBandwidthCondition", "boolean", true);

                    for (var prop in this.streamMetrics[type]) {
                        // We keep HttpList in order to keep bandwidth conditions when switching the input stream
                        if (this.streamMetrics[type].hasOwnProperty(prop) && ((prop !== "HttpList") || (keepBW === false))) {
                            this.streamMetrics[type][prop] = [];
                        }
                    }
                }
            }

            this.metricsChanged.call(self);
        },

        getReadOnlyMetricsFor: function(type) {
            if (this.streamMetrics.hasOwnProperty(type)) {
                return this.streamMetrics[type];
            }

            return null;
        },

        getMetricsFor: function(type) {
            var metrics;

            if (this.streamMetrics.hasOwnProperty(type)) {
                metrics = this.streamMetrics[type];
            } else {
                metrics = this.system.getObject("metrics");
                this.streamMetrics[type] = metrics;
            }

            return metrics;
        },

        addTcpConnection: function (streamType, tcpid, dest, topen, tclose, tconnect) {
            var vo = new MediaPlayer.vo.metrics.TCPConnection();

            vo.tcpid = tcpid;
            vo.dest = dest;
            vo.topen = topen;
            vo.tclose = tclose;
            vo.tconnect = tconnect;

            this.getMetricsFor(streamType).TcpList.push(vo);
            this.metricAdded(streamType, "TcpConnection", vo);

            return vo;
        },

        // ORANGE: add request quality
        addHttpRequest: function (streamType, tcpid, type, url, actualurl, range, trequest, tresponse, tfinish, responsecode, interval, mediaduration, startTime, quality) {
            var vo = new MediaPlayer.vo.metrics.HTTPRequest(),
                metrics = this.getMetricsFor(streamType).HttpList;

            vo.stream = streamType;
            vo.tcpid = tcpid;
            vo.type = type;
            vo.url = url;
            vo.actualurl = actualurl;
            vo.range = range;
            vo.trequest = trequest;
            vo.tresponse = tresponse;
            vo.tfinish = tfinish;
            vo.responsecode = responsecode;
            vo.interval = interval;
            vo.mediaduration = mediaduration;
            vo.startTime = startTime;
            vo.quality = quality;

            metrics.push(vo);
            this.metricAdded(streamType, "HttpRequest", vo);

            // Keep only last 10 metrics to avoid memory leak
            if (metrics.length > 10) {
                metrics.shift();
            }

            return vo;
        },

        appendHttpTrace: function (httpRequest, s, d, b) {
            var vo = new MediaPlayer.vo.metrics.HTTPRequest.Trace();

            vo.s = s;
            vo.d = d;
            vo.b = b;

            httpRequest.trace.push(vo);
            this.metricUpdated(httpRequest.stream, "HttpRequestTrace", httpRequest);

            return vo;
        },

        addRepresentationSwitch: function (streamType, t, mt, to, lto) {
            var vo = new MediaPlayer.vo.metrics.RepresentationSwitch();

            vo.t = t;
            vo.mt = mt;
            vo.to = to;
            vo.lto = lto;

            this.getMetricsFor(streamType).RepSwitchList.push(vo);
            this.metricAdded(streamType, "RepresentationSwitch", vo);

            return vo;
        },

        addBufferedSwitch: function (streamType, mt, to, lto) {
            var vo = new MediaPlayer.vo.metrics.BufferedSwitch();

            vo.mt = mt;
            vo.to = to;
            vo.lto = lto;

            this.getMetricsFor(streamType).BufferedSwitchList.push(vo);
            this.metricAdded(streamType, "BufferedSwitch", vo);

            return vo;
        },

        addState: function (streamType, currentState, position, reason) {

            var state = this.getMetricsFor(streamType).State;
            if (state.length > 0 && state[state.length - 1].current === currentState) {
                return;
            }

            var vo = new MediaPlayer.vo.metrics.State(),
                metrics = this.getMetricsFor(streamType).State;

            vo.current = currentState;
            vo.position = position;
            vo.reason = reason;

            metrics.push(vo);
            this.metricAdded(streamType, "State", vo);

            // console.log("[STATE] type: " + streamType + ", state:" + currentState + ", position: " + position);

            // Keep only last 10 metrics to avoid memory leak
            if (metrics.length > 10) {
                metrics.shift();
            }

            return vo;
        },

        addSession: function (streamType, url, loop, endTime, playerType) {
            var vo = new MediaPlayer.vo.metrics.Session();

            vo.uri = url;
            if (loop) {
                vo.loopMode = 1;
            } else {
                vo.loopMode = 0;
            }
            vo.endTime = endTime;
            vo.playerType = playerType;

            this.metricAdded(streamType, "Session", vo);

            return vo;
        },

        addCondition: function (streamType, isFullScreen, videoWidth, videoHeight, droppedFrames, fps) {
            var vo = new MediaPlayer.vo.metrics.Condition();

            vo.isFullScreen = isFullScreen;
            vo.windowSize = videoWidth + "x" + videoHeight;
            vo.fps = fps;
            vo.droppedFrames = droppedFrames;

            this.metricAdded(streamType, "Condition", vo);

            return vo;
        },

        addMetaData: function () {
            this.metricAdded(null, "ManifestReady", null);
        },

        addBufferLevel: function (streamType, t, level) {
            var vo = new MediaPlayer.vo.metrics.BufferLevel(),
                metrics = this.getMetricsFor(streamType).BufferLevel;

            vo.t = t;
            vo.level = Number(level.toFixed(3));

            metrics.push(vo);
            this.metricAdded(streamType, "BufferLevel", vo);

            // Keep only last 10 metrics to avoid memory leak
            if (metrics.length > 10) {
                metrics.shift();
            }

            return vo;
        },


        addDVRInfo: function (streamType, t, range) {
            var vo = new MediaPlayer.vo.metrics.DVRInfo(),
                metrics = this.getMetricsFor(streamType).DVRInfo;

            vo.t = t;
            vo.range = range;

            metrics.push(vo);
            this.metricAdded(streamType, "DVRInfo", vo);

            // Keep only last 10 metrics to avoid memory leak
            if (metrics.length > 10) {
                metrics.shift();
            }

            return vo;
        },

        addDroppedFrames: function (streamType, quality) {
            var vo = new MediaPlayer.vo.metrics.DroppedFrames(),
                list = this.getMetricsFor(streamType).DroppedFrames;

            vo.time = quality.creationTime;
            vo.droppedFrames = quality.droppedVideoFrames;
            vo.decodedFrameCount = quality.totalVideoFrames;

            if (list.length > 0 && list[list.length - 1] === vo) {
                return list[list.length - 1];
            }

            list.push(vo);

            this.metricAdded(streamType, "DroppedFrames", vo);
            return vo;
        },


        addPlaybackQuality: function (streamType, t, quality, mediaTime) {
            var vo = new MediaPlayer.vo.metrics.PlaybackQuality(),
                metrics = this.getMetricsFor(streamType).PlaybackQuality;

            vo.t = t;//quality.creationTime;
            vo.mt = mediaTime;
            vo.droppedFrames = quality.droppedVideoFrames;
            vo.totalVideoFrames = quality.totalVideoFrames;

            // Add new metrics only if droppedVideoFrames or totalVideoFrames changed
            if (metrics.length > 0) {
                if ((vo.droppedFrames === metrics[metrics.length-1].droppedFrames) &&
                    (vo.totalVideoFrames === metrics[metrics.length-1].totalVideoFrames)) {
                    return metrics[metrics.length - 1];
                }
            }

            metrics.push(vo);
            this.metricAdded(streamType, "PlaybackQuality", vo);

            // Keep only last 10 metrics to avoid memory leak
            if (metrics.length > 10) {
                metrics.shift();
            }

            return vo;
        },

        addVideoResolution: function (streamType, t, width, height, mediaTime) {
            var vo = new MediaPlayer.vo.metrics.VideoResolution(),
                metrics = this.getMetricsFor(streamType).VideoResolution;

            vo.t = t;
            vo.mt = mediaTime;
            vo.width = width;
            vo.height = height;

            // Add new metrics only if width or height changed
            if (metrics.length > 0) {
                if ((vo.width === metrics[metrics.length-1].width) &&
                    (vo.height === metrics[metrics.length-1].height)) {
                    return metrics[metrics.length - 1];
                }
            }

            metrics.push(vo);
            this.metricAdded(streamType, "VideoResolution", vo);

            return vo;
        },

        addManifestUpdate: function(streamType, type, requestTime, fetchTime, availabilityStartTime, presentationStartTime, clientTimeOffset, currentTime, buffered, latency) {
            var vo = new MediaPlayer.vo.metrics.ManifestUpdate(),
                metrics = this.getMetricsFor("stream");

            vo.streamType = streamType;
            vo.type = type;
            vo.requestTime = requestTime; // when this manifest update was requested
            vo.fetchTime = fetchTime; // when this manifest update was received
            vo.availabilityStartTime = availabilityStartTime;
            vo.presentationStartTime = presentationStartTime; // the seek point (liveEdge for dynamic, Period[0].startTime for static)
            vo.clientTimeOffset = clientTimeOffset; // the calculated difference between the server and client wall clock time
            vo.currentTime = currentTime; // actual element.currentTime
            vo.buffered = buffered; // actual element.ranges
            vo.latency = latency; // (static is fixed value of zero. dynamic should be ((Now-@availabilityStartTime) - currentTime)

            metrics.ManifestUpdate.push(vo);
            this.metricAdded(streamType, "ManifestUpdate", vo);

            return vo;
        },

        updateManifestUpdateInfo: function(manifestUpdate, updatedFields) {
            if (manifestUpdate && updatedFields) {
                for (var field in updatedFields) {
                    if (updatedFields.hasOwnProperty(field)) {
                        manifestUpdate[field] = updatedFields[field];
                    }
                }

                this.metricUpdated(manifestUpdate.streamType, "ManifestUpdate", manifestUpdate);
            }
        },

        addManifestUpdatePeriodInfo: function(manifestUpdate, id, index, start, duration) {
            var vo = new MediaPlayer.vo.metrics.ManifestUpdate.PeriodInfo();

            vo.id = id;
            vo.index = index;
            vo.start = start;
            vo.duration = duration;

            manifestUpdate.periodInfo.push(vo);
            this.metricUpdated(manifestUpdate.streamType, "ManifestUpdatePeriodInfo", manifestUpdate);

            return vo;
        },

        addManifestUpdateRepresentationInfo: function(manifestUpdate, id, index, periodIndex, streamType, presentationTimeOffset, startNumber, segmentInfoType) {
            var vo = new MediaPlayer.vo.metrics.ManifestUpdate.RepresentationInfo();

            vo.id = id;
            vo.index = index;
            vo.periodIndex = periodIndex;
            vo.streamType = streamType;
            vo.startNumber = startNumber;
            vo.segmentInfoType = segmentInfoType;
            vo.presentationTimeOffset = presentationTimeOffset;

            manifestUpdate.representationInfo.push(vo);
            this.metricUpdated(manifestUpdate.streamType, "ManifestUpdateRepresentationInfo", manifestUpdate);

            return vo;
        },

        addPlayList: function (streamType, start, mstart, starttype, speed) {
            var vo = new MediaPlayer.vo.metrics.PlayList(),
                metrics = this.getMetricsFor(streamType).PlayList;

            vo.stream = streamType;
            vo.start = start;
            vo.mstart = mstart;
            vo.starttype = starttype;
            vo.speed = speed;

            metrics.push(vo);
            this.metricAdded(streamType, "PlayList", vo);

            // Keep only last 10 metrics to avoid memory leak
            if (metrics.length > 10) {
                metrics.shift();
            }

            return vo;
        },

        appendPlayListTrace: function (playList, representationid, subreplevel, start, mstart, duration, playbackspeed, stopreason) {
            var vo = new MediaPlayer.vo.metrics.PlayList.Trace();

            vo.representationid = representationid;
            vo.subreplevel = subreplevel;
            vo.start = start;
            vo.mstart = mstart;
            vo.duration = duration;
            vo.playbackspeed = playbackspeed;
            vo.stopreason = stopreason;

            if (playList && Array.isArray(playList.trace)) {
                playList.trace.push(vo);
                this.metricUpdated(playList.stream, "PlayListTrace", playList);

                // Keep only last 10 metrics to avoid memory leak
                if (playList.trace.length > 10) {
                    playList.trace.shift();
                }
            }

            return vo;
        }
    };
};

MediaPlayer.models.MetricsModel.prototype = {
    constructor: MediaPlayer.models.MetricsModel
};

/*
 * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.
 * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2014, Orange
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.dependencies.Mp4Processor = function() {
    "use strict";

    ///////////////////////////////////////////////////////////////////////////////////////////
    // MOOV
    ///////////////////////////////////////////////////////////////////////////////////////////

    var createMovieHeaderBox = function(tracks) {

            // Movie Header Box
            // This box defines overall information which is media-independent, and relevant to the
            // entire presentation considered as a whole.

            // Create MovieHeader box (mvhd)
            var mvhd = new mp4lib.boxes.MovieHeaderBox(),
                track = tracks[tracks.length - 1]; // take last track to determine get track id

            mvhd.version = 1; // version = 1  in order to have 64bits duration value
            mvhd.creation_time = 0; // the creation time of the presentation => ignore (set to 0)
            mvhd.modification_time = 0; // the most recent time the presentation was modified => ignore (set to 0)
            mvhd.timescale = track.timescale; // the time-scale for the entire presentation => take timescale of current adaptationSet
            mvhd.duration = Math.round(track.duration * track.timescale); // the length of the presentation (in the indicated timescale) =>  take duration of period
            mvhd.rate = 0x00010000; // 16.16 number, "1.0" = normal playback
            mvhd.volume = 0x0100; // 8.8 number, "1.0" = full volume
            mvhd.reserved = 0;
            mvhd.reserved_2 = [0x0, 0x0];
            mvhd.matrix = [0x00010000, 0x0, 0x0, 0x0, 0x00010000, 0x0, 0x0, 0x0, 0x40000000]; // provides a transformation matrix for the video; (u,v,w) are restricted here to (0,0,1),
            // hex values (0,0,0x40000000)
            mvhd.pre_defined = [0x0, 0x0, 0x0, 0x0, 0x0, 0x0];
            mvhd.next_track_ID = track.trackId + 1; // indicates a value to use for the track ID of the next track to be added to this presentation
            mvhd.flags = 0; //default value

            return mvhd;
        },

        createTrackBox = function(track) {

            // Track Box: This is a container box for a single track of a presentation
            // Track Header Box: This box specifies the characteristics of a single track
            var trak,
                tkhd,
                mdia;

            // Create Track box (trak)
            trak = new mp4lib.boxes.TrackBox();

            // Create and add TrackHeader box (trak)
            tkhd = new mp4lib.boxes.TrackHeaderBox();

            tkhd.version = 1; // version = 1  in order to have 64bits duration value
            tkhd.flags = 0x1 | 0x2 | 0x4; //Track_enabled: Indicates that the track is enabled. Flag value is 0x000001. A disabled track (the low
            //bit is zero) is treated as if it were not present.
            //Track_in_movie: Indicates that the track is used in the presentation. Flag value is 0x000002.
            //Track_in_preview: Indicates that the track is used when previewing the presentation. Flag value is 0x000004.
            tkhd.creation_time = 0; // the creation time of the presentation => ignore (set to 0)
            tkhd.modification_time = 0; // the most recent time the presentation was modified => ignore (set to 0)
            tkhd.track_id = track.trackId; // uniquely identifies this track over the entire life-time of this presentation
            tkhd.reserved = 0;
            tkhd.duration = Math.round(track.duration * track.timescale); // the duration of this track (in the timescale indicated in the Movie Header Box) =>  take duration of period
            tkhd.reserved_2 = [0x0, 0x0];
            tkhd.layer = 0; // specifies the front-to-back ordering of video tracks; tracks with lower numbers are closer to the viewer => 0 since only one video track
            tkhd.alternate_group = 0; // specifies a group or collection of tracks => ignore
            tkhd.volume = 0x0100; // 8.8 number, "1.0" = full volume
            tkhd.reserved_3 = 0;
            tkhd.matrix = [0x00010000, 0x0, 0x0, 0x0, 0x00010000, 0x0, 0x0, 0x0, 0x40000000]; // provides a transformation matrix for the video; (u,v,w) are restricted here to (0,0,1),
            tkhd.width = track.width << 16; // visual presentation size as fixed-point 16.16 values
            tkhd.height = track.height << 16; // visual presentation size as fixed-point 16.16 values

            trak.boxes.push(tkhd);

            //Create container for the track information in a track (mdia)
            mdia = new mp4lib.boxes.MediaBox();

            //Create and add Media Header Box (mdhd)
            mdia.boxes.push(createMediaHeaderBox(track));

            //Create and add Handler Reference Box (hdlr)
            mdia.boxes.push(createHandlerReferenceBox(track));

            //Create and add Media Information Box (minf)
            mdia.boxes.push(createMediaInformationBox(track));

            trak.boxes.push(mdia);

            return trak;
        },

        getLanguageCode = function(language) {

            // Declares the language code for this track. See ISO 639-2/T for the set of three character
            // codes. Each character is packed as the difference between its ASCII value and 0x60. Since the code
            // is confined to being three lower-case letters, these values are strictly positive.
            var firstLetterCode,
                secondLetterCode,
                thirdLetterCode,
                result = 0;

            // If lang member is define, get it. if not language is 'und'
            // If current adaptation is video type, return 'und'.
            // var language = adaptation.lang ? adaptation.lang : 'und' ;

            // Return value is packed on 15 bits, each character is defined on 5 bits
            // there is a padding value to align on 16 bits
            firstLetterCode = (language.charCodeAt(0) - 96) << 10; //96 decimal base = 0x60
            secondLetterCode = (language.charCodeAt(1) - 96) << 5;
            thirdLetterCode = language.charCodeAt(2) - 96;

            result = firstLetterCode | secondLetterCode | thirdLetterCode;

            return result;
        },

        createMediaHeaderBox = function(track) {

            // mdhd : The media header declares overall information that is media-independent, and relevant to characteristics of
            // the media in a track.
            var mdhd = new mp4lib.boxes.MediaHeaderBox();

            mdhd.flags = 0;
            mdhd.version = 1; // version = 1  in order to have 64bits duration value
            mdhd.creation_time = 0; // the creation time of the presentation => ignore (set to 0)
            mdhd.modification_time = 0; // the most recent time the presentation was modified => ignore (set to 0)
            mdhd.timescale = track.timescale; // the time-scale for the entire presentation => take timescale of current adaptationSet
            mdhd.duration = Math.round(track.duration * track.timescale); //integer that declares the duration of this media (in the scale of the timescale). If the
            //duration cannot be determined then duration is set to all 1s.
            mdhd.pad = 0; // padding for language value
            mdhd.language = getLanguageCode(track.language);

            mdhd.pre_defined = 0; // default value

            return mdhd;
        },

        stringToCharCode = function(str) {
            var code = 0,
                i;

            for (i = 0; i < str.length; i += 1) {
                code |= str.charCodeAt(i) << ((str.length - i - 1) * 8);
            }
            return code;
        },

        createHandlerReferenceBox = function(track) {

            // This box within a Media Box declares the process by which the media-data in the track is presented, and thus,
            // the nature of the media in a track. For example, a video track would be handled by a video handler.
            var hdlr = new mp4lib.boxes.HandlerBox();

            hdlr.version = 0; // default value version = 0
            hdlr.pre_defined = 0; //default value.
            switch (track.type) {
                case 'video':
                    hdlr.handler_type = stringToCharCode(hdlr.HANDLERTYPEVIDEO);
                    hdlr.name = hdlr.HANDLERVIDEONAME;
                    break;
                case 'audio':
                    hdlr.handler_type = stringToCharCode(hdlr.HANDLERTYPEAUDIO);
                    hdlr.name = hdlr.HANDLERAUDIONAME;
                    break;
                default:
                    hdlr.handler_type = stringToCharCode(hdlr.HANDLERTYPETEXT);
                    hdlr.name = hdlr.HANDLERTEXTNAME;
            }
            hdlr.name += '\0';
            hdlr.reserved = [0x0, 0x0, 0x0]; //default value
            hdlr.flags = 0; //default value

            return hdlr;
        },

        createMediaInformationBox = function(track) {

            // This box contains all the objects that declare characteristic information of the media in the track.
            var minf = new mp4lib.boxes.MediaInformationBox();

            //Create and add the adapted media header box (vmhd, smhd or nmhd) for audio, video or text.
            switch (track.type) {
                case 'video':
                    minf.boxes.push(createVideoMediaHeaderBox(track));
                    break;
                case 'audio':
                    minf.boxes.push(createSoundMediaHeaderBox(track));
                    break;
                default:
                    //minf.boxes.push(createNullMediaHeaderBox(track));
            }

            //Create and add Data Information Box (dinf)
            minf.boxes.push(createDataInformationBox(track));

            //Create and add Sample Table Box (stbl)
            minf.boxes.push(createSampleTableBox(track));

            return minf;

        },

        createDataInformationBox = function() {
            var dinf,
                dref,
                url;

            // The data information box contains objects that declare the location of the media information in a track.
            dinf = new mp4lib.boxes.DataInformationBox();

            // The data reference object contains a table of data references (normally URLs) that declare the location(s) of
            // the media data used within the presentation
            dref = new mp4lib.boxes.DataReferenceBox();

            dref.version = 0; // is an integer that specifies the version of this box default = 0
            dref.entry_count = 1; // is an integer that counts the actual entries
            dref.flags = 0; // default value

            // The DataEntryBox within the DataReferenceBox shall be either a DataEntryUrnBox or a DataEntryUrlBox.
            // (not used, but mandatory)
            url = new mp4lib.boxes.DataEntryUrlBox();
            url.location = "";
            url.version = 0;
            url.flags = 1;

            //add data Entry Url Box in data Reference box
            dref.boxes.push(url);

            //add data Reference Box in data information box
            dinf.boxes.push(dref);

            return dinf;
        },

        createDecodingTimeToSampleBox = function() {

            // This box contains a compact version of a table that allows indexing from decoding time to sample number.

            var stts = new mp4lib.boxes.TimeToSampleBox();

            stts.version = 0; // is an integer that specifies the version of this box. default value = 0
            stts.entry_count = 0; // is an integer that gives the number of entries in the following table. not used in fragmented content
            stts.flags = 0; // default value = 0

            stts.entry = [];

            return stts;
        },

        createSampleToChunkBox = function() {

            // Samples within the media data are grouped into chunks.
            var stsc = new mp4lib.boxes.SampleToChunkBox();

            stsc.flags = 0;
            stsc.version = 0; // is an integer that specifies the version of this box. default value = 0.
            stsc.entry_count = 0; // is an integer that gives the number of entries in the following table

            stsc.entry = [];

            return stsc;
        },

        createChunkOffsetBox = function() {

            // The chunk offset table gives the index of each chunk into the containing file
            var stco = new mp4lib.boxes.ChunkOffsetBox();

            stco.version = 0; // is an integer that specifies the version of this box. default value = 0
            stco.entry_count = 0; // is an integer that gives the number of entries in the following table
            stco.flags = 0; // default value

            stco.chunk_offset = [];

            return stco;
        },

        createSampleSizeBox = function() {

            // This box contains the sample count and a table giving the size in bytes of each sample. This allows the media
            // data itself to be unframed. The total number of samples in the media is always indicated in the sample count.
            var stsz = new mp4lib.boxes.SampleSizeBox();

            stsz.version = 0; // default value = 0
            stsz.flags = 0; //default value = 0
            stsz.sample_count = 0; //is an integer that gives the number of samples in the track; if sample-size is 0, then it is
            //also the number of entries in the following table
            stsz.sample_size = 0; //is integer specifying the default sample size.

            return stsz;
        },

        _hexstringtoBuffer = function(a) {
            var res = new Uint8Array(a.length / 2),
                i;

            for (i = 0; i < a.length / 2; i += 1) {
                res[i] = parseInt("" + a[i * 2] + a[i * 2 + 1], 16);
            }
            return res;
        },

        _mergeArrays = function(oldBuffer, newPart) {
            var res = new Uint8Array(oldBuffer.length + newPart.length);
            res.set(oldBuffer, 0);
            res.set(newPart, oldBuffer.length);
            return res;
        },

        createAVCConfigurationBox = function(track) {
            var avcC,
                NALDatabuffer,
                codecPrivateData,
                NALArray,
                SPS_index,
                PPS_index,
                i,
                NALBuffer,
                tempBuffer,
                regexpSPS = new RegExp("^[A-Z0-9]7", "gi"),
                regexpPPS = new RegExp("^[A-Z0-9]8", "gi");

            //Create an AVC Configuration Box
            avcC = new mp4lib.boxes.AVCConfigurationBox();

            avcC.configurationVersion = 1; //unsigned int(8) configurationVersion = 1;
            avcC.lengthSizeMinusOne = 3; //indicates the length in bytes of the NALUnitLength field in an AVC video
            //sample or AVC parameter set sample of the associated stream minus one

            avcC.reserved = 0x3F; //bit(6) reserved = ‘111111’b;

            avcC.SPS_NAL = []; //SPS NAL Array
            avcC.PPS_NAL = []; //PPS NAL Array

            NALDatabuffer = new Uint8Array(0);

            codecPrivateData = track.codecPrivateData;

            NALArray = codecPrivateData.split("00000001");

            NALArray.splice(0, 1);

            SPS_index = 0;
            PPS_index = 0;
            for (i = 0; i < NALArray.length; i += 1) {
                NALBuffer = _hexstringtoBuffer(NALArray[i]);

                if (NALArray[i].match(regexpSPS)) {
                    avcC.SPS_NAL[SPS_index++] = {
                        "NAL_length": NALBuffer.length,
                        "NAL": NALBuffer
                    };
                    avcC.AVCProfileIndication = parseInt(NALArray[i].substr(2, 2), 16); //contains the profile code as defined in ISO/IEC 14496-10.
                    avcC.profile_compatibility = parseInt(NALArray[i].substr(4, 2), 16); //is a byte defined exactly the same as the byte which occurs between the
                    //profile_IDC and level_IDC in a sequence parameter set (SPS), as defined in ISO/IEC 14496-10.
                    avcC.AVCLevelIndication = parseInt(NALArray[i].substr(6, 2), 16); //contains the level code as defined in ISO/IEC 14496-10.
                }
                if (NALArray[i].match(regexpPPS)) {
                    avcC.PPS_NAL[PPS_index++] = {
                        "NAL_length": NALBuffer.length,
                        "NAL": NALBuffer
                    };
                }

                tempBuffer = new Uint8Array(NALBuffer.length + 4);
                tempBuffer[3] = NALBuffer.length;
                tempBuffer.set(NALBuffer, 4);

                NALDatabuffer = _mergeArrays(NALDatabuffer, tempBuffer);
            }
            avcC.numOfSequenceParameterSets = SPS_index; // number of SPSs that are used as the initial set of SPSs for decoding the AVC elementary stream.
            avcC.numOfPictureParameterSets = PPS_index; // number of PPSs that are used as the initial set of PPSs for decoding the AVC elementary stream.

            return avcC;
        },

        createAVCVisualSampleEntry = function(track) {
            var avc1 = null;

            //An AVC visual sample entry shall contain an AVC Configuration Box
            if (track.contentProtection !== undefined) {
                avc1 = new mp4lib.boxes.EncryptedVideoBox();
            } else {
                avc1 = new mp4lib.boxes.AVC1VisualSampleEntryBox();
            }

            avc1.data_reference_index = 1; //To DO... ??
            avc1.compressorname = [0x0A, 0x41, 0x56, 0x43, 0x20, 0x43, 0x6F, 0x64,
                                   0x69, 0x6E, 0x67, 0x00, 0x00, 0x00, 0x00, 0x00,
                                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
            // = "AVC Coding";
            //is a name, for informative purposes. It is formatted in a fixed 32-byte field, with the first
            //byte set to the number of bytes to be displayed, followed by that number of bytes of displayable data,
            //and then padding to complete 32 bytes total (including the size byte). The field may be set to 0.
            avc1.depth = 0x0018; //takes one of the following values 0x0018 – images are in colour with no alpha.
            avc1.reserved = [0x0, 0x0, 0x0, 0x0, 0x0, 0x0]; //default value = 0
            avc1.reserved_2 = 0; //default value = 0
            avc1.reserved_3 = 0; //default value = 0
            avc1.pre_defined = 0; //unsigned int(16) pre_defined = 0;
            avc1.pre_defined_2 = [0x0, 0x0, 0x0]; //unsigned int(32)[3] pre_defined = 0;
            avc1.pre_defined_3 = 65535; //int(16) pre_defined = -1;
            avc1.frame_count = 1; //template unsigned int(16) frame_count = 1;indicates how many frames of compressed video are stored in each sample. The default is
            //1, for one frame per sample; it may be more than 1 for multiple frames per sample
            avc1.horizresolution = 0x00480000; // 72 dpi
            avc1.vertresolution = 0x00480000; // 72 dpi

            avc1.height = track.height; //are the maximum visual width and height of the stream described by this sample
            avc1.width = track.width; //description, in pixels

            //create and add AVC Configuration Box (avcC)
            avc1.boxes.push(createAVCConfigurationBox(track));

            if (track.contentProtection !== undefined) {
                // create and add Protection Scheme Info Box
                avc1.boxes.push(createProtectionSchemeInfoBox(track));
            }

            return avc1;
        },

        createOriginalFormatBox = function(track) {
            var frma = new mp4lib.boxes.OriginalFormatBox();
            frma.data_format = stringToCharCode(track.codecs.substring(0, track.codecs.indexOf('.')));
            return frma;
        },

        createSchemeTypeBox = function() {
            var schm = new mp4lib.boxes.SchemeTypeBox();

            schm.flags = 0;
            schm.version = 0;
            schm.scheme_type = 0x63656E63; //'cenc' => common encryption
            schm.scheme_version = 0x00010000; // version set to 0x00010000 (Major version 1, Minor version 0)

            return schm;
        },

        createSchemeInformationBox = function(track) {
            var schi = new mp4lib.boxes.SchemeInformationBox();

            //create and add Track Encryption Box
            schi.boxes.push(createTrackEncryptionBox(track));

            return schi;
        },

        createTrackEncryptionBox = function(track) {
            var tenc = new mp4lib.boxes.TrackEncryptionBox();

            tenc.flags = 0; //default value
            tenc.version = 0; //default value

            tenc.default_IsEncrypted = 0x1; //default value
            tenc.default_IV_size = 8; //default value, NA => à préciser
            tenc.default_KID = (track.contentProtection && (track.contentProtection.length) > 0 && track.contentProtection[0]["cenc:default_KID"]) ?
                track.contentProtection[0]["cenc:default_KID"] :
                [0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0];

            return tenc;
        },

        createProtectionSchemeInfoBox = function(track) {
            //create Protection Scheme Info Box
            var sinf = new mp4lib.boxes.ProtectionSchemeInformationBox();

            //create and add Original Format Box => indicate codec type of the encrypted content
            sinf.boxes.push(createOriginalFormatBox(track));

            //create and add Scheme Type box
            sinf.boxes.push(createSchemeTypeBox());

            //create and add Scheme Information Box
            sinf.boxes.push(createSchemeInformationBox(track));

            return sinf;
        },

        createVisualSampleEntry = function(track) {
            var codec = track.codecs.substring(0, track.codecs.indexOf('.'));

            switch (codec) {
                case "avc1":
                    return createAVCVisualSampleEntry(track);
                default:
                    throw {
                        name: MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_CODEC_UNSUPPORTED,
                        message: "Video codec is not supported (MP4)",
                        data: {
                            codec: codec
                        }
                    };
            }
        },

        parseHexString = function(str) {
            var bytes = [];
            while (str.length >= 2) {
                bytes.push(parseInt(str.substring(0, 2), 16));
                str = str.substring(2, str.length);
            }

            return bytes;
        },

        createMPEG4AACESDescriptor = function(track) {
            var audioSpecificConfig,
                dsiLength,
                decoderSpecificInfo,
                dcdLength,
                decoderConfigDescriptor,
                esdLength,
                esDescriptor;

            // AudioSpecificConfig
            // defined in ISO/IEC 14496-3, subpart 1
            // => AudioSpecificConfig corresponds to hex bytes contained in "codecPrivateData" field
            audioSpecificConfig = parseHexString(track.codecPrivateData);

            // DecoderSpecificInfo
            // defined in ISO/IEC 14496-1 (Systems), extends a BaseDescriptor
            dsiLength = audioSpecificConfig.length;
            decoderSpecificInfo = new Uint8Array(2 + dsiLength); // 2 = tag + size bytes
            decoderSpecificInfo[0] = 0x05; // bit(8), tag=0x05 (DecSpecificInfoTag)
            decoderSpecificInfo[1] = dsiLength; // bit(8), size
            decoderSpecificInfo.set(audioSpecificConfig, 2); // AudioSpecificConfig bytes

            // DecoderConfigDescriptor
            // defined in ISO/IEC 14496-1 (Systems), extends a BaseDescriptor
            dcdLength = 13 + decoderSpecificInfo.length; // 2 = tag + size bytes
            decoderConfigDescriptor = new Uint8Array(2 + dcdLength);
            decoderConfigDescriptor[0] = 0x04; // bit(8), tag=0x04 (DecoderConfigDescrTag)
            decoderConfigDescriptor[1] = dcdLength; // bit(8), size
            decoderConfigDescriptor[2] = 0x40; // bit(8), objectTypeIndication=0x40 (MPEG-4 AAC)
            decoderConfigDescriptor[3] = 0x05 << 2; // bit(6), streamType=0x05 (Audiostream)
            decoderConfigDescriptor[3] |= 0 << 1; // bit(1), upStream=0
            decoderConfigDescriptor[3] |= 1; // bit(1), reserved=1
            decoderConfigDescriptor[4] = 0xFF; // bit(24), buffersizeDB=undefined
            decoderConfigDescriptor[5] = 0xFF; // ''
            decoderConfigDescriptor[6] = 0xFF; // ''
            decoderConfigDescriptor[7] = (track.bandwidth & 0xFF000000) >> 24; // bit(32), maxBitrate=undefined
            decoderConfigDescriptor[8] = (track.bandwidth & 0x00FF0000) >> 16; // ''
            decoderConfigDescriptor[9] = (track.bandwidth & 0x0000FF00) >> 8; // ''
            decoderConfigDescriptor[10] = (track.bandwidth & 0x000000FF); // ''
            decoderConfigDescriptor[11] = (track.bandwidth & 0xFF000000) >> 24; // bit(32), avgbitrate
            decoderConfigDescriptor[12] |= (track.bandwidth & 0x00FF0000) >> 16; // ''
            decoderConfigDescriptor[13] |= (track.bandwidth & 0x0000FF00) >> 8; // ''
            decoderConfigDescriptor[14] |= (track.bandwidth & 0x000000FF); // ''
            decoderConfigDescriptor.set(decoderSpecificInfo, 15); // DecoderSpecificInfo bytes

            // ES_Descriptor
            // defined in ISO/IEC 14496-1 (Systems), extends a BaseDescriptor
            esdLength = 3 + decoderConfigDescriptor.length;
            esDescriptor = new Uint8Array(2 + esdLength); // 2 = tag + size bytes
            esDescriptor[0] = 0x03; // bit(8), tag=0x03 (ES_DescrTag)
            esDescriptor[1] = esdLength; // bit(8), size
            esDescriptor[2] = (track.trackId & 0xFF00) >> 8; // bit(16), ES_ID=track_id
            esDescriptor[3] = (track.trackId & 0x00FF); // ''
            esDescriptor[4] = 0; // bit(8), flags and streamPriority
            esDescriptor.set(decoderConfigDescriptor, 5); // decoderConfigDescriptor bytes

            return esDescriptor;
        },

        createMP4AudioSampleEntry = function(track) {
            var mp4a = null,
                esdBox,
                ES_Descriptor;

            if (track.contentProtection !== undefined) {
                mp4a = new mp4lib.boxes.EncryptedAudioBox();
            } else {
                mp4a = new mp4lib.boxes.MP4AudioSampleEntryBox();
            }

            // SampleEntry fields
            mp4a.reserved = [0x0, 0x0, 0x0, 0x0, 0x0, 0x0];
            mp4a.data_reference_index = 1; // ??

            // AudioSampleEntry fields
            mp4a.reserved_2 = [0x0, 0x0]; // default value = 0
            mp4a.channelcount = track.channels; // number of channels
            mp4a.samplesize = 16; // default value = 16
            mp4a.pre_defined = 0; // default value = 0
            mp4a.reserved_3 = 0; // default value = 0
            mp4a.samplerate = track.samplingRate << 16; // sampling rate, as fixed-point 16.16 values

            esdBox = new mp4lib.boxes.ESDBox();
            ES_Descriptor = createMPEG4AACESDescriptor(track);
            esdBox.ES_tag = ES_Descriptor[0];
            esdBox.ES_length = ES_Descriptor[1];
            esdBox.ES_data = ES_Descriptor.subarray(2, ES_Descriptor.length);
            esdBox.version = 0;
            esdBox.flags = 0;

            // MP4AudioSampleEntry fields
            mp4a.boxes.push(esdBox);

            if (track.contentProtection !== undefined) {
                // create and add Protection Scheme Info Box
                mp4a.boxes.push(createProtectionSchemeInfoBox(track));
            }

            return mp4a;
        },

        createAudioSampleEntry = function(track) {
            var codec = track.codecs.substring(0, track.codecs.indexOf('.'));

            switch (codec) {
                case "mp4a":
                    return createMP4AudioSampleEntry(track);
                default:
                    throw {
                        name: MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_CODEC_UNSUPPORTED,
                        message: "Audio codec is not supported (MP4)",
                        data: {
                            codec: codec
                        }
                    };
            }

            return null;
        },

        createSampleDescriptionBox = function(track) {

            //The sample description table gives detailed information about the coding type used, and any initialization
            //information needed for that coding.
            var stsd = new mp4lib.boxes.SampleDescriptionBox();
            stsd.version = 0;
            stsd.flags = 0;

            switch (track.type) {
                case "video":
                    stsd.boxes.push(createVisualSampleEntry(track));
                    break;
                case "audio":
                    stsd.boxes.push(createAudioSampleEntry(track));
                    break;
                default:
                    //NAN : To do add text entry
                    break;
            }

            return stsd;
        },

        createSampleTableBox = function(track) {

            //The sample table contains all the time and data indexing of the media samples in a track. Using the tables
            //here, it is possible to locate samples in time, determine their type (e.g. I-frame or not), and determine their
            //size, container, and offset into that container.
            var stbl = new mp4lib.boxes.SampleTableBox();

            //create and add Decoding Time to Sample Box (stts)
            stbl.boxes.push(createDecodingTimeToSampleBox(track));

            //create and add Sample to Chunk Box (stsc)
            stbl.boxes.push(createSampleToChunkBox(track));

            //create and add Chunk Offset Box (stco)
            stbl.boxes.push(createChunkOffsetBox(track));

            //create and add Sample Size Box (stsz)
            stbl.boxes.push(createSampleSizeBox(track));

            //create and add Sample Description Box (stsd)
            stbl.boxes.push(createSampleDescriptionBox(track));

            return stbl;
        },

        createVideoMediaHeaderBox = function() {
            //The video media header contains general presentation information, independent of the coding, for video
            //track. Note that the flags field has the value 1.
            var vmhd = new mp4lib.boxes.VideoMediaHeaderBox();

            vmhd.version = 0; //default value, is an integer that specifies the version of this box
            vmhd.flags = 1; //default value
            vmhd.graphicsmode = 0; //specifies a composition mode for this video track, from the following enumerated set,
            //which may be extended by derived specifications: copy = 0 copy over the existing image
            vmhd.opcolor = [0x0, 0x0, 0x0]; //is a set of 3 colour values (red, green, blue) available for use by graphics modes
            //default value opcolor = {0, 0, 0};

            return vmhd;
        },

        createSoundMediaHeaderBox = function() {

            //The sound media header contains general presentation information, independent of the coding, for audio
            //track. This header is used for all tracks containing audio
            var smhd = new mp4lib.boxes.SoundMediaHeaderBox();

            smhd.version = 0; //default value, is an integer that specifies the version of this box
            smhd.balance = 0; //is a fixed-point 8.8 number that places mono audio tracks in a stereo space; 0 is centre (the
            //normal value); full left is -1.0 and full right is 1.0.
            smhd.reserved = 0;
            smhd.flags = 1;

            return smhd;
        },

        /*createNullMediaHeaderBox = function () {
            //NAN non défini dans mp4lib, à définir
            //var nmhd = new NullMediaHeaderBox();
            //return nmhd;
        },*/

        createFileTypeBox = function() {

            //create a File Type Box
            var ftyp = new mp4lib.boxes.FileTypeBox();

            ftyp.major_brand = 1769172790; // is a brand identifier iso6 => decimal ASCII value for iso6
            ftyp.minor_brand = 1; // is an informative integer for the minor version of the major brand
            ftyp.compatible_brands = []; //is a list, to the end of the box, of brands isom, iso6 and msdh
            ftyp.compatible_brands[0] = 1769172845; // => decimal ASCII value for isom
            ftyp.compatible_brands[1] = 1769172790; // => decimal ASCII value for iso6
            ftyp.compatible_brands[2] = 1836278888; // => decimal ASCII value for msdh

            return ftyp;
        },

        createMovieExtendsBox = function(tracks) {
            var mvex,
                //mehd,
                trex,
                track = tracks[tracks.length - 1],
                i;

            // Create Movie Extends Box (mvex)
            // This box warns readers that there might be Movie Fragment Boxes in this file
            mvex = new mp4lib.boxes.MovieExtendsBox();

            // Create Movie Extends Header Box (mehd)
            // The Movie Extends Header is optional, and provides the overall duration, including fragments, of a fragmented
            // movie. If this box is not present, the overall duration must be computed by examining each fragment.
            // mehd is optional
            /*if (track.duration !== Number.POSITIVE_INFINITY) {
                mehd = new mp4lib.boxes.MovieExtendsHeaderBox();
                mehd.version = 1;
                mehd.flags = 0;
                mehd.fragment_duration = Math.round(track.duration * track.timescale); // declares length of the presentation of the whole movie including fragments

                //add mehd box in mvex box
                mvex.boxes.push(mehd);
            }*/

            for (i = 0; i < tracks.length; i += 1) {
                track = tracks[i];
                // Create Track Extend Box (trex), exactly one for each track in the movie box
                // This sets up default values used by the movie fragments. By setting defaults in this way, space and
                // complexity can be saved in each Track Fragment Box.
                trex = new mp4lib.boxes.TrackExtendsBox();
                trex.version = 0;
                trex.flags = 0;
                trex.track_ID = track.trackId; // identifies the track; this shall be the track ID of a track in the Movie Box
                trex.default_sample_description_index = 1; // Set default value
                trex.default_sample_duration = 0; // ''
                trex.default_sample_flags = 0; // ''
                trex.default_sample_size = 0; // ''

                // add trex box in mvex box
                mvex.boxes.push(trex);
            }

            return mvex;
        },

        createProtectionSystemSpecificHeaderBox = function(keySystems) {
            var psshs = [],
                pssh_bytes,
                pssh,
                i;

            for (i = 0; i < keySystems.length; i += 1) {
                pssh_bytes = new Uint8Array(keySystems[i].initData);
                pssh = new mp4lib.boxes.ProtectionSystemSpecificHeaderBox();
                pssh.read(pssh_bytes, 8, pssh_bytes.length); // 8: skip box length and type fields
                psshs.push(pssh);
            }

            return psshs;
        },

        generateMoov = function (tracks) {
            var boxes = [],
                moov,
                supportedKS,
                i;

            // Create Movie box (moov)
            moov = new mp4lib.boxes.MovieBox();

            // Create and add MovieHeader box (mvhd)
            moov.boxes.push(createMovieHeaderBox(tracks));

            for (i = 0; i < tracks.length; i += 1) {
                // Create and add Track box (trak)
                moov.boxes.push(createTrackBox(tracks[i]));
            }

            // Create and add MovieExtends box (mvex)
            moov.boxes.push(createMovieExtendsBox(tracks));

            // Create and add Protection System Specific Header box (pssh)
            for (i = 0; i < tracks.length; i++) {
                if (tracks[i].contentProtection !== undefined) {
                    supportedKS = this.protectionExt.getSupportedKeySystemsFromContentProtection(tracks[i].contentProtection);
                    moov.boxes.push.apply(moov.boxes, createProtectionSystemSpecificHeaderBox(supportedKS));
                }
            }

            boxes.push(createFileTypeBox());

            boxes.push(moov);

            return boxes;
        },

        ///////////////////////////////////////////////////////////////////////////////////////////
        // MOOF
        ///////////////////////////////////////////////////////////////////////////////////////////

        sequenceNumber = 1,

        createMovieFragmentHeaderBox = function() {

            // Movie Fragment Header Box
            // The movie fragment header contains a sequence number, as a safety check. The sequence number usually
            // starts at 1 and must increase for each movie fragment in the file, in the order in which they occur. This allows
            // readers to verify integrity of the sequence; it is an error to construct a file where the fragments are out of
            // sequence.
            var mfhd = new mp4lib.boxes.MovieFragmentHeaderBox();

            mfhd.version = 0;
            mfhd.flags = 0;
            mfhd.sequence_number = sequenceNumber++;

            return mfhd;
        },

        createTrackFragmentBox = function(track) {

            // Track Fragment Box
            // Within the movie fragment there is a set of track fragments, zero or more per track. The track fragments in
            // turn contain zero or more track runs, each of which document a contiguous run of samples for that track.
            // Within these structures, many fields are optional and can be defaulted.
            var traf = new mp4lib.boxes.TrackFragmentBox();

            traf.version = 0;
            traf.flags = 0;

            // Add Track Fragment Header box (tfhd)
            traf.boxes.push(createTrackFragmentHeaderBox(track));

            // Add Track Fragment Decode Time box (tfdt)
            traf.boxes.push(createTrackFragmentBaseMediaDecodeTimeBox(track));

            // Add Track Fragment Run box (trun)
            traf.boxes.push(createTrackFragmentRunBox(track));

            // Add Sample Dependency Table box (sdtp)
            traf.boxes.push(createSampleDependencyTableBox(track));

            return traf;
        },

        createTrackFragmentHeaderBox = function(track) {

            // Track Fragment Header Box
            // Each movie fragment can add zero or more fragments to each track; and a track fragment can add zero or
            // more contiguous runs of samples. The track fragment header sets up information and defaults used for those
            // runs of samples.
            var tfhd = new mp4lib.boxes.TrackFragmentHeaderBox();

            tfhd.version = 0;
            tfhd.flags = //0x000008 | // default-sample-duration-present
            //0x000010 | // default-sample-size-present
            0x020000; // default-base-is-moof

            tfhd.track_ID = track.trackId;
            //tfhd.default_sample_duration = 0;
            //tfhd.default_sample_size = 0;

            return tfhd;
        },

        createTrackFragmentBaseMediaDecodeTimeBox = function(track) {

            // Track Fragment Base Media Decode Time Box
            // The Track Fragment Base Media Decode Time Box provides the absolute decode time, measured on the
            // media timeline, of the first sample in decode order in the track fragment. This can be useful, for example,
            // when performing random access in a file; it is not necessary to sum the sample durations of all preceding
            // samples in previous fragments to find this value (where the sample durations are the deltas in the Decoding
            // Time to Sample Box and the sample_durations in the preceding track runs).
            // The Track Fragment Base Media Decode Time Box, if present, shall be positioned after the Track Fragment
            // Header Box and before the first Track Fragment Run box.

            var tfdt = new mp4lib.boxes.TrackFragmentBaseMediaDecodeTimeBox();

            tfdt.version = 1; // baseMediaDecodeTime on 64 bits
            tfdt.flags = 0;

            tfdt.baseMediaDecodeTime = (track.samples.length > 0) ? track.samples[0].dts : 0;

            return tfdt;
        },

        createTrackFragmentRunBox = function(track) {

            // Track Fragment Run Box
            // Within the Track Fragment Box, there are zero or more Track Run Boxes. If the duration-is-empty flag is set in
            // the tf_flags, there are no track runs. A track run documents a contiguous set of samples for a track.
            // The number of optional fields is determined from the number of bits set in the lower byte of the flags, and the
            // size of a record from the bits set in the second byte of the flags. This procedure shall be followed, to allow for
            // new fields to be defined.

            var trun = new mp4lib.boxes.TrackFragmentRunBox(),
                i,
                cts_base,
                sample_duration_present_flag,
                sample;

            cts_base = track.samples[0].cts;
            sample_duration_present_flag = (track.samples[0].duration > 0) ? 0x000100 : 0x000000;

            trun.version = 0;
            trun.flags = 0x000001 | // data-offset-present
                         sample_duration_present_flag | // sample-duration-present
                         0x000200 | // sample-size-present
                         0x000400 | // sample-flags-present
                         ((track.type === 'video') ? 0x000800 : 0x000000); // sample-composition-time-offsets-present

            trun.data_offset = 0; // Initialize to 0, will be updated once mdat is set
            trun.samples_table = [];
            trun.sample_count = track.samples.length;

            for (i = 0; i < track.samples.length; i++) {
                sample = {
                    sample_duration: track.samples[i].duration,
                    sample_size: track.samples[i].size,
                    sample_composition_time_offset: track.samples[i].cts - track.samples[i].dts,
                    sample_flags: track.samples[i].flags
                };

                if (sample.sample_composition_time_offset < 0) {
                    trun.version = 1;
                }

                trun.samples_table.push(sample);
            }

            return trun;
        },

        createSampleDependencyTableBox = function(track) {
            var sdtp = new mp4lib.boxes.SampleDependencyTableBox(),
                i;

            sdtp.version = 0;
            sdtp.flags = 0;
            sdtp.sample_dependency_table = [];
            for (i = 0; i < track.samples.length; i++) {
                sdtp.sample_dependency_table.push((track.samples[i].flags & 0x0FF00000) >> 20);
            }

            return sdtp;
        },

        createMediaDataBox = function(track) {

            // Media Data Box

            var mdat = new mp4lib.boxes.MediaDataBox();

            mdat.data = track.data;

            return mdat;
        },

        generateMoof = function (tracks) {

            var boxes = [],
                moof,
                i,
                length,
                trafs,
                mdatLength = 0,
                trackglobal = {},
                mdatTracksTab = [],
                offset = 0;

            // Create Movie Fragment box (moof)
            moof = new mp4lib.boxes.MovieFragmentBox();

            // Create Movie Fragment Header box (moof)
            moof.boxes.push(createMovieFragmentHeaderBox());

            if (tracks) {
                for (i = 0; i < tracks.length; i += 1) {
                    // Create Track Fragment box (traf)
                    moof.boxes.push(createTrackFragmentBox(tracks[i]));
                }
            }

            boxes.push(moof);

            moof.computeLength();
            length = moof.size;

            // Add tracks data
            trafs = moof.getBoxesByType("traf");

            length += 8; // 8 = 'size' + 'type' mdat fields length

            if (tracks && tracks.length) {
                // mdat array size = tracks.length
                mdatTracksTab = [tracks.length];
            }

            if (tracks) {
                for (i = 0; i < tracks.length; i += 1) {
                    // Update trun.data_offset for the track
                    trafs[i].getBoxByType("trun").data_offset = length;
                    // Update length of output fragment file
                    length += tracks[i].data.length;
                    // Add current data in mdatTracksTab array
                    mdatTracksTab[i] = tracks[i].data;
                    // Update length of global mdat
                    mdatLength += mdatTracksTab[i].length;
                }
            }

            trackglobal.data = new Uint8Array(mdatLength);

            // Concatenate all the tracks data in an array
            for (i = 0; i < mdatTracksTab.length; i++) {
                trackglobal.data.set(mdatTracksTab[i], offset);
                offset += mdatTracksTab[i].length;
            }

            // Create mdat
            boxes.push(createMediaDataBox(trackglobal));

            return boxes;
        };

    return {
        protectionExt: undefined,

        generateInitSegment: function (tracks) {
            var file = new mp4lib.boxes.File();
            file.boxes = generateMoov.call(this, tracks);
            return mp4lib.serialize(file);
        },

        generateMediaSegment: function (tracks) {
            var file = new mp4lib.boxes.File();
            file.boxes = generateMoof.call(this, tracks);
            return mp4lib.serialize(file);
        },

        generateInitMediaSegment: function (tracks) {
            var file = new mp4lib.boxes.File();
            file.boxes = generateMoov.call(this, tracks);
            file.boxes = file.boxes.concat(generateMoof.call(this, tracks));
            return mp4lib.serialize(file);
        },
    };
};

MediaPlayer.dependencies.Mp4Processor.prototype = {
    constructor: MediaPlayer.dependencies.Mp4Processor
};
/**
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Dash Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  * Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  * Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.dependencies.Notifier = function () {
    "use strict";

    var OBSERVABLE_ID_PROP = "observableId",
        system,
        id = 0,

        getId = function() {
            if (!this[OBSERVABLE_ID_PROP]) {
                id += 1;
                this[OBSERVABLE_ID_PROP] = "_id_" + id;
            }

            return this[OBSERVABLE_ID_PROP];
        };

    return {
        system : undefined,

        setup: function() {
            system = this.system;
            system.mapValue('notify', this.notify);
            system.mapValue('subscribe', this.subscribe);
            system.mapValue('unsubscribe', this.unsubscribe);
        },

        notify: function (/*eventName[, args]*/) {
            var eventId = arguments[0] + getId.call(this),
                event = new MediaPlayer.vo.Event();

            event.sender =  this;
            event.type = arguments[0];
            event.data = arguments[1];
            event.error = arguments[2];
            event.timestamp = new Date().getTime();

            system.notify.call(system, eventId, event);
        },

        subscribe: function(eventName, observer, handler, oneShot) {
            if (!handler && observer[eventName]) {
                handler = observer[eventName] = observer[eventName].bind(observer);
            }

            if(!observer) throw "observer object cannot be null or undefined";

            if(!handler) throw "event handler cannot be null or undefined";

            eventName += getId.call(this);

            system.mapHandler(eventName, undefined, handler, oneShot);
        },

        unsubscribe: function(eventName, observer, handler) {
            handler = handler || observer[eventName];
            eventName += getId.call(this);

            system.unmapHandler(eventName, undefined, handler);
        }
    };
};

MediaPlayer.dependencies.Notifier.prototype = {
    constructor: MediaPlayer.dependencies.Notifier
};
/*
 * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.
 * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2014, Orange
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.dependencies.Parser = function() {
    "use strict";

    var _parser = null,

        parse = function(data, baseUrl) {

            if (_parser === null) {
                // we parse the response of the request to know the manifest type
                if (data.indexOf("SmoothStreamingMedia") > -1 && typeof(this.mssParser) !== 'undefined') {
                    this.system.notify('setContext', 'MSS');
                    //do some business to transform it into a Dash Manifest
                    _parser = this.mssParser;
                } else if (data.indexOf("#EXTM3U") > -1 && typeof(this.hlsParser) !== 'undefined') {
                    this.system.notify('setContext', 'HLS');
                    _parser = this.hlsParser;
                } else if (data.indexOf("MPD") > -1 && typeof(this.dashParser) !== 'undefined') {
                    this.system.notify('setContext', 'MPD');
                    _parser = this.dashParser;
                } else {
                    return Q.reject("manifest cannot be parsed, protocol is unsupported!");
                }
            }

            return _parser.parse(data, baseUrl);
        },

        abort = function() {
            if ((_parser !== null) && (_parser.abort !== undefined)) {
                _parser.abort();
            }
        },

        reset = function() {
            _parser = null;
        };

    return {
        debug: undefined,
        system: undefined,
        dashParser: undefined,
        mssParser: undefined,
        hlsParser: undefined,
        metricsModel: undefined,

        parse: parse,
        abort: abort,
        reset: reset
    };
};

MediaPlayer.dependencies.Parser.prototype = {
    constructor: MediaPlayer.dependencies.Parser
};
/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Digital Primates
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.dependencies.SourceBufferExtensions = function () {
    "use strict";
    this.system = undefined;
    this.manifestExt = undefined;
};

MediaPlayer.dependencies.SourceBufferExtensions.prototype = {

    constructor: MediaPlayer.dependencies.SourceBufferExtensions,

    createSourceBuffer: function (mediaSource, codec) {
        "use strict";

        var buffer = null;

        if (!mediaSource) {
            return null;
        }

        try {
            buffer = mediaSource.addSourceBuffer(codec);
        } catch(ex) {
            // For text track not supported by MSE, we try to create corresponding specific source buffer
            if (this.manifestExt.getIsTextTrack(codec)) {
                if ((codec === 'text/vtt') || (codec === 'text/ttml')) {
                    buffer = this.system.getObject("textSourceBuffer");
                } else if (codec === 'application/ttml+xml+mp4' || codec === 'application/mp4' || codec === 'application/ttml+xml') {
                    buffer = this.system.getObject("textTTMLXMLMP4SourceBuffer");
                } else {
                    throw ex;
                }
            } else {
                throw ex;
            }
        }
        return buffer;
    },

    removeSourceBuffer: function (mediaSource, buffer) {
        "use strict";
        try {
            mediaSource.removeSourceBuffer(buffer);
        } catch (ex) {
        }
    },

    getBufferRange: function (buffer, time, tolerance) {
        "use strict";
        var ranges = null,
            start = 0,
            end = 0,
            firstStart = null,
            lastEnd = null,
            gap = 0,
            toler = (tolerance || 0.03),
            len,
            i;

        try {
            ranges = buffer.buffered;
        } catch(ex) {
            return null;
        }

        if (ranges) {
            for (i = 0, len = ranges.length; i < len; i += 1) {
                start = ranges.start(i);
                end = ranges.end(i);
                if (firstStart === null) {
                    gap = Math.abs(start - time);
                    if (time >= start && time < end) {
                        // start the range
                        firstStart = start;
                        lastEnd = end;
                        continue;
                    } else if (gap <= toler) {
                        // start the range even though the buffer does not contain time 0
                        firstStart = start;
                        lastEnd = end;
                        continue;
                    }
                } else {
                    gap = start - lastEnd;
                    if (gap <= toler) {
                        // the discontinuity is smaller than the tolerance, combine the ranges
                        lastEnd = end;
                    } else {
                        break;
                    }
                }
            }

            if (firstStart !== null) {
                return {start: firstStart, end: lastEnd};
            }
        }

        return null;
    },

    getAllRanges: function(buffer) {
        var ranges = null;

        try{
            ranges = buffer.buffered;
            return ranges;
        } catch (ex) {
            return null;
        }
    },

    getBufferLength: function (buffer, time, tolerance) {
        "use strict";

        var self = this,
            range,
            length;

        range = self.getBufferRange(buffer, time, tolerance);

        if (range === null) {
            length = 0;
        } else {
            length = range.end - time;
        }

        return length;
    },

    waitForUpdateEnd: function(buffer) {
        "use strict";
        var defer = Q.defer(),
            intervalId,
            CHECK_INTERVAL = 50,
            checkIsUpdateEnded = function() {
                // if updating is still in progress do nothing and wait for the next check again.
                if (buffer.updating) {
                    return;
                }
                // updating is completed, now we can stop checking and resolve the promise
                clearInterval(intervalId);
                defer.resolve(true);
            },
            updateEndHandler = function() {
                if (buffer.updating) {
                    return;
                }

                buffer.removeEventListener("updateend", updateEndHandler, false);
                defer.resolve(true);
            };

            if (!buffer.updating) {
                defer.resolve(true);
                return defer.promise;
            }
        // use updateend event if possible
        if (typeof buffer.addEventListener === "function") {
            try {
                buffer.addEventListener("updateend", updateEndHandler, false);
            } catch (err) {
                // use setInterval to periodically check if updating has been completed
                intervalId = setInterval(checkIsUpdateEnded, CHECK_INTERVAL);
            }
        } else {
            // use setInterval to periodically check if updating has been completed
            intervalId = setInterval(checkIsUpdateEnded, CHECK_INTERVAL);
        }

        return defer.promise;
    },

    append: function (buffer, bytes, request) {
        var deferred = Q.defer(),
            self = this;

        self.waitForUpdateEnd(buffer).then(function() {
            try {
                if ("append" in buffer) {
                    buffer.append(bytes, request);
                } else if ("appendBuffer" in buffer) {
                    buffer.appendBuffer(bytes);
                }

                // updating is in progress, we should wait for it to complete before signaling that this operation is done
                self.waitForUpdateEnd(buffer, request).then(
                    function() {
                        deferred.resolve();
                    }
                );
            } catch (err) {
                deferred.reject({err: err, data: bytes});
            }
        });

        return deferred.promise;
    },

    remove: function (buffer, start, end, duration, mediaSource) {
        var deferred = Q.defer(),
            self = this;

        self.waitForUpdateEnd(buffer).then(function() {
            try {
                // make sure that the given time range is correct. Otherwise we will get InvalidAccessError
                if ((start >= 0) && (start < duration) && (end > start) && (mediaSource.readyState !== "ended")) {
                    buffer.remove(start, end);
                }

                //workaround in order to remove all the cues in the textTrack from the video element.
                //end parameter equals the video.duration. The use case of a dash stream with a full TTML subtitles file has an issue because video duration could be NaN. It occurs
                //after the manifest has been parsed, a call to MediaSource.setDuration is made but after a few ms, a duration change event occurs with a value of NaN. The origin of this issue may be
                //that no media segments have been pushed.
                //So, all the buffer is removed.
                if (isNaN(end) && (mediaSource.readyState !== "ended")) {
                    buffer.remove(start);
                }

                // updating is in progress, we should wait for it to complete before signaling that this operation is done
                self.waitForUpdateEnd(buffer).then(
                    function() {
                        deferred.resolve();
                    }
                );
            } catch (err) {
                deferred.reject(err);
            }
        });

        return deferred.promise;
    },

    abort: function (mediaSource, buffer) {
        "use strict";
            try {
                if (mediaSource.readyState === "open") {
                    buffer.abort();
                }
            } catch(ex){
            }
    }
};

/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Digital Primates
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

// Define Math.sign method in case it is not defined (like in IE11)
if (!Math.sign) {
    Math.sign = function(value) {
        "use strict";
        return (value < 0) ? -1 : ((value === 0) ? 0 : 1);
    };
}

MediaPlayer.dependencies.Stream = function() {
    "use strict";

    var manifest,
        mediaSource,
        contentProtection = null,
        videoController = null,
        videoTrackIndex = -1,
        audioController = null,
        audioTrackIndex = -1,
        textController = null,
        subtitlesEnabled = false,
        dvrStarted = false,
        fragmentInfoVideoController = null,
        fragmentInfoAudioController = null,
        fragmentInfoTextController = null,

        textTrackIndex = -1,
        autoPlay = true,
        initialized = false,
        errored = false,

        // Events listeners
        endedListener,
        loadedListener,
        playListener,
        pauseListener,
        errorListener,
        seekingListener,
        seekedListener,
        waitingListener,
        timeupdateListener,
        durationchangeListener,
        progressListener,
        ratechangeListener,
        canplayListener,
        playingListener,
        loadstartListener,

        // Audio/text languages
        defaultAudioLang = 'und',
        defaultSubtitleLang = 'und',

        periodInfo = null,

        // Initial start time
        initialStartTime = -1,

        // Play start time (= live edge for live streams)
        playStartTime = -1,

        // Programmatical seek
        seekTime,
        checkStartTimeIntervalId,

        // trick mode variables
        tmState = "Stopped",
        tmSpeed = 1,
        tmPreviousSpeed,
        tmStartTime,
        tmVideoStartTime,
        tmMinSeekStep,
        tmSeekStep,
        tmSeekTime,
        tmSeekTimeout,
        tmSeekValue,
        tmEndDetected = false,
        muteState = false,

        eventController = null,
        protectionController,
        initializeMediaSourceFinished = true,

        reloadTimeout = null,
        isReloading = false,

        startClockTime = -1,
        startStreamTime = -1,
        visibilitychangeListener,

        // ProtectionController events listener
        onProtectionError = function(event) {
            this.errHandler.sendError(event.data.code, event.data.message, event.data.data);
        },

        play = function() {
            if (!initialized) {
                return;
            }

            this.debug.info("[Stream] Play.");
            this.videoModel.play();
        },

        pause = function() {
            this.debug.info("[Stream] Pause.");
            this.videoModel.pause();
        },

        seek = function(time, autoplay) {
            if (!initialized) {
                //this.debug.info("[Stream] (seek) not initialized");
                return;
            }

            this.debug.info("[Stream] Seek: " + time);

            // In case of live streams and then DVR seek, then we start the fragmentInfoControllers
            // (check if seek not due to stream loading or reloading)
            if (this.manifestExt.getIsDynamic(manifest) && !isReloading && (this.videoModel.getCurrentTime() !== 0)) {
                startFragmentInfoControllers.call(this);
            }

            // Stream is starting playing => fills the buffers before setting <video> current time
            if (autoplay === true) {
                // 1- seeks the buffer controllers at the desired time
                // 2- once data is present in the buffers, then we can set the current time to the <video> component (see onBufferUpdated())
                seekTime = time;
                this.system.unmapHandler("bufferUpdated");
                this.system.mapHandler("bufferUpdated", undefined, onBufferUpdated.bind(this));
                startBuffering.call(this, seekTime);
            } else {
                // Stream is already playing, simply seek the <video> component
                this.videoModel.setCurrentTime(time);
            }
        },

        // Media Source
        setUpMediaSource = function(mediaSourceArg) {
            var deferred = Q.defer(),
                self = this,

                onMediaSourceOpen = function( /*e*/ ) {
                    //self.debug.log("MediaSource is open!");

                    mediaSourceArg.removeEventListener("sourceopen", onMediaSourceOpen);
                    mediaSourceArg.removeEventListener("webkitsourceopen", onMediaSourceOpen);

                    deferred.resolve(mediaSourceArg);
                };

            //self.debug.log("MediaSource should be closed. The actual readyState is: " + mediaSourceArg.readyState);

            mediaSourceArg.addEventListener("sourceopen", onMediaSourceOpen, false);
            mediaSourceArg.addEventListener("webkitsourceopen", onMediaSourceOpen, false);

            self.mediaSourceExt.attachMediaSource(mediaSourceArg, self.videoModel);

            //self.debug.log("MediaSource attached to video.  Waiting on open...");

            return deferred.promise;
        },

        tearDownMediaSource = function() {
            var self = this,
                funcs = [],
                deferred = Q.defer(),

                executeReset = function() {
                    if (!!videoController) {
                        funcs.push(videoController.reset(errored));
                    }

                    if (!!fragmentInfoVideoController) {
                        funcs.push(fragmentInfoVideoController.reset(errored));
                    }

                    if (!!audioController) {
                        funcs.push(audioController.reset(errored));
                    }

                    if (!!fragmentInfoAudioController) {
                        funcs.push(fragmentInfoAudioController.reset(errored));
                    }

                    if (!!textController) {
                        funcs.push(textController.reset(errored));
                    }

                    if (!!fragmentInfoTextController) {
                        funcs.push(fragmentInfoTextController.reset(errored));
                    }

                    Q.all(funcs).then(
                        function() {
                            if (!!eventController) {
                                eventController.reset();
                                eventController = undefined;
                            }

                            if (!!mediaSource) {
                                self.mediaSourceExt.detachMediaSource(self.videoModel);
                            }

                            initialized = false;

                            contentProtection = null;

                            videoController = null;
                            audioController = null;
                            textController = null;

                            mediaSource = null;
                            manifest = null;

                            deferred.resolve();
                        });
                };


            Q.when(initializeMediaSourceFinished).then(
                function() {
                    executeReset();
                });
            return deferred.promise;
        },

        createBufferController = function(data, codec) {
            var bufferController = null,
                buffer = null;

            // Check if codec is supported (applies only for video and audio)
            if (data.type === 'video' || data.type === 'audio') {
                if (!this.capabilities.supportsCodec(this.videoModel.getElement(), codec)) {
                    this.errHandler.sendError(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_CODEC_UNSUPPORTED, 'Codec is not supported (HTMLMediaElement)', {
                        codec: codec
                    });
                    return null;
                }
            }

            // Create SourceBuffer
            try {
                buffer = this.sourceBufferExt.createSourceBuffer(mediaSource, codec);
            } catch (ex) {
                this.errHandler.sendError(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_CREATE_SOURCEBUFFER, 'Failed to create ' + data.type + ' source buffer',
                    new MediaPlayer.vo.Error(ex.code, ex.name, ex.message));
                return null;
            }

            // Create and initialize BufferController
            bufferController = this.system.getObject("bufferController");
            bufferController.initialize(data.type, periodInfo, data, buffer, this.fragmentController, mediaSource, eventController);

            if (data.type === 'text' && buffer.hasOwnProperty('initialize')) {
                buffer.initialize(codec, bufferController, data);
            }

            return bufferController;
        },

        createFragmentInfoController = function(bufferController, data) {
            if (manifest.name !== 'MSS' || (!this.manifestExt.getIsDynamic(manifest) && !this.manifestExt.getIsStartOver(manifest))) {
                return null;
            }

            var fragmentInfoController = null;

            if (bufferController && data && data.type) {
                fragmentInfoController = this.system.getObject("mssFragmentInfoController");
                fragmentInfoController.initialize(data.type, this.fragmentController, bufferController);
            }

            return fragmentInfoController;
        },

        initializeProtectionController = function () {
            var deferred = null,
                data,
                audioCodec = null,
                videoCodec = null,
                ksSelected,
                self = this;

            data = this.manifestExt.getVideoData(manifest, periodInfo.index);
            if (data) {
                videoCodec = this.manifestExt.getCodec(data);
                contentProtection = this.manifestExt.getContentProtectionData(data);
            }
            data = this.manifestExt.getSpecificAudioData(manifest, periodInfo.index, defaultAudioLang);
            if (data) {
                audioCodec = this.manifestExt.getCodec(data);
            }

            if (!contentProtection) {
                return Q.when(true);
            }

            if (!this.capabilities.supportsEncryptedMedia()) {
                // No protectionController (MediaKeys not supported/enabled) but content is protected => error
                this.errHandler.sendError(MediaPlayer.dependencies.ErrorHandler.prototype.CAPABILITY_ERR_MEDIAKEYS, "EME is not supported/enabled", null);
                return Q.when(false);
            }

            if (!protectionController) {
                return Q.when(true);
            }

            deferred = Q.defer();

            ksSelected = {};
            ksSelected[MediaPlayer.dependencies.ProtectionController.eventList.ENAME_KEY_SYSTEM_SELECTED] = function(/*event*/) {
                self.debug.log("[Stream] ProtectionController initialized");
                protectionController.unsubscribe(MediaPlayer.dependencies.ProtectionController.eventList.ENAME_KEY_SYSTEM_SELECTED, ksSelected);
                deferred.resolve(true);
            };
            protectionController.subscribe(MediaPlayer.dependencies.ProtectionController.eventList.ENAME_KEY_SYSTEM_SELECTED, ksSelected);
            this.debug.log("[Stream] Initialize ProtectionController");
            protectionController.init(contentProtection, audioCodec, videoCodec);

            return deferred.promise;
        },

        initializeMediaSource = function() {
            var data,
                videoCodec,
                audioCodec,
                textMimeType;

            if (!manifest) {
                return;
            }

            initializeMediaSourceFinished = false;
            eventController = this.system.getObject("eventController");

            // Initialize video BufferController
            data = this.manifestExt.getVideoData(manifest, periodInfo.index);

            if (data === null) {
                this.errHandler.sendError(MediaPlayer.dependencies.ErrorHandler.prototype.MANIFEST_ERR_NO_VIDEO, 'No Video data in manifest');
            } else {
                filterCodecs.call(this, data);
                videoTrackIndex = this.manifestExt.getDataIndex(data, manifest, periodInfo.index);
                videoCodec = this.manifestExt.getCodec(data);
                contentProtection = this.manifestExt.getContentProtectionData(data);

                if (videoCodec === null) {
                    this.errHandler.sendError(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_CODEC_UNSUPPORTED, 'Video codec information not available', {codec: ''});
                } else {
                    videoController = createBufferController.call(this, data, videoCodec);
                    fragmentInfoVideoController = createFragmentInfoController.call(this, videoController, data);
                }
            }

            // Abort if no video controller
            if (videoController === null) {
                initializeMediaSourceFinished = true;
                return;
            }

            // Initialize audio BufferController
            data = this.manifestExt.getSpecificAudioData(manifest, periodInfo.index, defaultAudioLang);

            if (data === null) {
                this.errHandler.sendWarning(MediaPlayer.dependencies.ErrorHandler.prototype.MANIFEST_ERR_NO_AUDIO, "No audio data in manifest");
            } else {
                filterCodecs.call(this, data);
                audioTrackIndex = this.manifestExt.getDataIndex(data, manifest, periodInfo.index);
                audioCodec = this.manifestExt.getCodec(data);

                if (audioCodec === null) {
                    this.errHandler.sendWarning(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_CODEC_UNSUPPORTED, 'Audio codec information not available', {codec: ''});
                } else {
                    audioController = createBufferController.call(this, data, audioCodec);

                    // Abort if audio track defined but failed to create audio controller
                    if (audioController === null) {
                        initializeMediaSourceFinished = true;
                        return;
                    }

                    fragmentInfoAudioController = createFragmentInfoController.call(this, audioController, data);
                }
            }

            // Initialize text BufferController
            data = this.manifestExt.getSpecificTextData(manifest, periodInfo.index, defaultSubtitleLang);

            if (data !== null) {
                textTrackIndex = this.manifestExt.getDataIndex(data, manifest, periodInfo.index);
                textMimeType = this.manifestExt.getMimeType(data);

                if (textMimeType === null) {
                    this.errHandler.sendWarning(MediaPlayer.dependencies.ErrorHandler.prototype.MANIFEST_ERR_NO_TEXT, "Text codec information not available");
                } else {
                    textController = createBufferController.call(this, data, textMimeType);
                    fragmentInfoTextController = createFragmentInfoController.call(this, textController, data);
                }
            }

            // Initialize EventController
            if (eventController) {
                eventController.addInlineEvents(this.manifestExt.getEventsForPeriod(manifest, periodInfo));
            }

            initializeMediaSourceFinished = true;
            return;
        },

        initializePlayback = function() {
            this.debug.log("[Stream] Setting duration: " + periodInfo.duration);
            this.mediaSourceExt.setDuration(mediaSource, periodInfo.duration);
            initialized = true;
        },

        startFragmentInfoControllers = function() {
            if (manifest.name !== 'MSS' || (!this.manifestExt.getIsDynamic(manifest) && !this.manifestExt.getIsStartOver(manifest))) {
                return;
            }

            if (fragmentInfoVideoController && dvrStarted === false) {
                dvrStarted = true;
                fragmentInfoVideoController.start(videoController.getSegmentDuration());
            }

            if (fragmentInfoAudioController) {
                fragmentInfoAudioController.start(audioController.getSegmentDuration());
            }

            if (fragmentInfoTextController && subtitlesEnabled) {
                fragmentInfoTextController.start(textController.getSegmentDuration());
            }
        },

        stopFragmentInfoControllers = function() {
            if (fragmentInfoVideoController) {
                dvrStarted = false;
                fragmentInfoVideoController.stop();
            }

            if (fragmentInfoAudioController) {
                fragmentInfoAudioController.stop();
            }

            if (fragmentInfoTextController) {
                fragmentInfoTextController.stop();
            }
        },

        onLoaded = function() {
            this.debug.info("[Stream] <video> loadedmetadata event");
        },

        onCanPlay = function() {
            this.debug.info("[Stream] <video> canplay event");
        },

        onPlaying = function() {
            this.debug.info("[Stream] <video> playing event");

            this.metricsModel.addState("video", "playing", this.getVideoModel().getCurrentTime());

            // Store start time (clock and stream time) for resynchronization purpose
            startClockTime = new Date().getTime() / 1000;
            startStreamTime = this.getVideoModel().getCurrentTime();
        },

        onLoadStart = function() {
            this.debug.info("[Stream] <video> loadstart event");
        },

        onPlay = function() {
            this.debug.info("[Stream] <video> play event");

            //listen pause event to have correct metrics, it should be unlistened by the onBufferingCompleted callback.
            this.videoModel.listen("pause", pauseListener);

            if (tmSpeed !== 1) {
                this.setTrickModeSpeed(1);
            } else {
                // Set the currentTime here to be sure that videoTag is ready to accept the seek (cause IE fail on set currentTime on BufferUpdate)
                if (playStartTime >= 0) {
                    setVideoModelCurrentTime.call(this, playStartTime);
                    playStartTime = -1;
                } else {
                    startBuffering.call(this);
                }
            }

            this.metricsModel.addPlayList("video", new Date().getTime(), this.videoModel.getCurrentTime(), "play");
        },

        // ORANGE : ended event
        onEnded = function() {
            this.debug.info("[Stream] <video> ended event");
            //add stopped state metric with reason = 1 : end of stream
            this.metricsModel.addState("video", "stopped", this.videoModel.getCurrentTime(), 1);

            if (this.manifestExt.getIsStartOver(manifest)) {
                stopFragmentInfoControllers.call(this);
            }
        },

        onPause = function() {
            this.debug.info("[Stream] <video> pause event");
            startClockTime = -1;
            startStreamTime = -1;
            if (tmSpeed === 1) {
                // ORANGE : add metric
                this.metricsModel.addState("video", "paused", this.videoModel.getCurrentTime());
                this.metricsModel.addPlayList("video", new Date().getTime(), this.videoModel.getCurrentTime(), "pause");
            }
            suspend.call(this);
            if (manifest.name === 'MSS' && this.manifestExt.getIsDynamic(manifest)) {
                startFragmentInfoControllers.call(this);
            }
        },

        onError = function(event) {
            var error = event.target.error,
                code,
                message = "[Stream] <video> error: ";

            if (error.code === -1) {
                // not an error!
                return;
            }

            switch (error.code) {
                case 1:
                    code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_ABORTED;
                    message += "fetching process aborted";
                    break;
                case 2:
                    code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_NETWORK;
                    message += "network error";
                    break;
                case 3:
                    code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_DECODE;
                    message += "media decoding error";
                    break;
                case 4:
                    code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_SRC_NOT_SUPPORTED;
                    message += "media format not supported";
                    break;
                case 5:
                    code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_ENCRYPTED;
                    message += "media is encrypted";
                    break;
            }

            errored = true;

            this.errHandler.sendError(code, message);
        },

        onSeeking = function() {
            var time = this.videoModel.getCurrentTime(),
                duration = this.videoModel.getDuration();

            this.debug.info("[Stream] <video> seeking event: " + time);

            // Check if seeking is different from trick mode seeking, then cancel trick mode
            if ((tmSpeed !== 1) && (time.toFixed(3) !== tmSeekValue.toFixed(3))) {
                this.setTrickModeSpeed(1);
                return;
            }

            // Check if seek time is less than range start, never seek before range start.
            time = (time < this.getStartTime()) ? this.getStartTime() : time;

            // Seeking at end of stream (= duration) does not work consistently across browsers and 'ended' event is then not always raised.
            // Then seek 2 sec. backward to enable 'ended' event to be raised.
            var backoffSeekToEnd = this.config.getParam("backoffSeekToEnd", "number", 2);
            if (duration !== Infinity && time >= (duration - backoffSeekToEnd)) {
                setVideoModelCurrentTime.call(this, (duration - backoffSeekToEnd));
                return;
            }

            if (tmSpeed === 1) {
                this.metricsModel.addState("video", "seeking", this.getVideoModel().getCurrentTime());
                this.metricsModel.addPlayList('video', new Date().getTime(), time, MediaPlayer.vo.metrics.PlayList.SEEK_START_REASON);
            }

            startBuffering.call(this, time);
        },

        onSeeked = function() {
            var self = this,
                currentTime,
                currentVideoTime,
                elapsedTime,
                elapsedSeekTime,
                elapsedVideoTime,
                speed,
                ratio = 0.9,
                seekValue,
                videoEndedEvent,
                delay,
                _seek = function(delay, seekValue) {
                    if (self.videoModel.getCurrentTime() === self.getStartTime() || tmEndDetected) {
                        self.debug.log("[Stream] Trick mode (x" + tmSpeed + "): stop");
                        if (tmEndDetected) {
                            videoEndedEvent = document.createEvent("Event");
                            videoEndedEvent.initEvent("ended", true, true);
                            self.videoModel.getElement().dispatchEvent(videoEndedEvent);
                        }
                        return;
                    }
                    if (seekValue < self.getStartTime()) {
                        seekValue = self.getStartTime();
                    } else if (seekValue >= self.videoModel.getDuration()) {
                        seekValue = self.videoModel.getDuration() - tmMinSeekStep;
                        tmEndDetected = true;
                    }
                    if (delay > 0) {
                        self.debug.log("[Stream] Trick mode (x" + tmSpeed + "): wait " + delay.toFixed(3) + " s");
                    }
                    tmSeekTimeout = setTimeout(function() {
                        tmSeekTime = new Date().getTime() / 1000;
                        self.debug.log("[Stream] Trick mode (x" + tmSpeed + "): seek time = " + seekValue.toFixed(3));
                        tmSeekValue = seekValue;
                        self.videoModel.setCurrentTime(seekValue);
                    }, delay > 0 ? (delay * 1000) : 0);
                };

            this.debug.info("[Stream] <video> seeked event");

            // Notify BufferControllers that video has seeked
            seekedBuffers.call(this);

            // Trick mode
            if (tmSpeed !== 1) {

                currentTime = (new Date().getTime()) / 1000;
                currentVideoTime = self.videoModel.getCurrentTime();
                elapsedTime = currentTime - tmStartTime;
                elapsedSeekTime = currentTime - tmSeekTime;
                elapsedVideoTime = Math.abs(currentVideoTime - tmVideoStartTime);
                speed = (elapsedVideoTime / elapsedTime);

                self.debug.log("[Stream] Trick mode (x" + tmSpeed + "): elapsed time = " + elapsedTime.toFixed(3) + ", elapsed video time = " + elapsedVideoTime.toFixed(3) + ", speed = " + speed.toFixed(3));

                if (tmState === "Changed") {
                    clearTimeout(tmSeekTimeout);
                    // Target speed changed => reset start times, and seek
                    tmState = "Running";
                    tmStartTime = (new Date().getTime()) / 1000;
                    tmVideoStartTime = currentVideoTime;
                    self.debug.info("[Stream] Trick mode (x" + tmSpeed + "): videoTime = " + tmVideoStartTime);
                    //if trick mode speed has decreased, we have to decrease tmSeekStep
                    tmSeekStep = Math.abs(tmPreviousSpeed / tmSpeed) > 1 ? tmSeekStep / Math.abs(tmPreviousSpeed / tmSpeed) : tmSeekStep;
                    seekValue = currentVideoTime + (tmSeekStep * Math.sign(tmSpeed));
                    delay = 0;
                } else if (speed < (Math.abs(tmSpeed) * ratio)) {
                    // Measured speed < target speed => increase seek step
                    var speedRatio = Math.abs(tmSpeed / speed);
                    tmSeekStep *= Math.round(speedRatio) + Math.round(speedRatio % tmMinSeekStep);
                    self.debug.info("[Stream] Trick mode (x" + tmSpeed + "): seek step = " + tmSeekStep);
                    seekValue = currentVideoTime + (tmSeekStep * Math.sign(tmSpeed));
                    delay = 0;
                } else {
                    // Measured speed > target speed => wait before next seek
                    seekValue = currentVideoTime + (tmSeekStep * Math.sign(tmSpeed));
                    delay = (Math.abs(seekValue - tmVideoStartTime) / Math.abs(tmSpeed)) - elapsedTime - elapsedSeekTime;
                }

                _seek.call(self, delay, seekValue);

            }

            // The current time has been changed on video model, then reactivate 'seeking' event listener
            // (see setVideoModelCurrentTime())
            this.videoModel.listen("seeking", seekingListener);

            isReloading = false;
            startClockTime = -1;
            startStreamTime = -1;
        },

        onProgress = function() {
            this.debug.info("[Stream] <video> progress event");
            updateBuffer.call(this);
        },

        onTimeupdate = function() {
            this.debug.info("[Stream] <video> timeupdate event: " + this.videoModel.getCurrentTime());
            updateBuffer.call(this);
        },

        onWaiting = function() {
            this.debug.info("[Stream] <video> waiting event");
            if (!this.getVideoModel().isSeeking()) {
                this.metricsModel.addState("video", "buffering", this.getVideoModel().getCurrentTime());
            }
        },

        onDurationchange = function() {
            var duration = this.videoModel.getDuration();
            this.debug.info("[Stream] <video> durationchange event: " + duration);
        },

        onRatechange = function() {
            this.debug.info("[Stream] <video> ratechange event: " + this.videoModel.getPlaybackRate());
            if (videoController) {
                videoController.updateStalledState();
            }
            if (audioController) {
                audioController.updateStalledState();
            }
            if (textController) {
                textController.updateStalledState();
            }
        },

        onReload = function() {

            // Ask for manifest refresh
            // Then, once manifest has been refresh and data updated, we reload session (see updateData())
            pause.call(this);
            isReloading = true;
            this.system.notify("manifestUpdate", true);
        },

        updateBuffer = function() {

            if (videoController) {
                videoController.updateBufferLevel(true);
            }

            if (audioController) {
                audioController.updateBufferLevel(true);
            }

            if (textController) {
                textController.updateBufferLevel(true);
            }
        },

        startBuffering = function(time) {
            this.debug.log("[Stream] startBuffering" + ((time === undefined) ? "" : (" at time " + time)));

            if (videoController) {
                if (time === undefined) {
                    videoController.start();
                } else {
                    videoController.seek(time);
                }
            }

            if (audioController) {
                if (time === undefined) {
                    audioController.start();
                } else {
                    audioController.seek(time);
                }
            }

            if (textController && subtitlesEnabled && tmSpeed === 1) {
                if (time === undefined) {
                    textController.start();
                } else {
                    textController.seek(time);
                }
            }
        },

        stopBuffering = function() {
            this.debug.log("[Stream] stopBuffering");

            if (videoController) {
                videoController.stop();
            }

            if (audioController) {
                audioController.stop();
            }

            if (textController) {
                textController.stop();
            }
        },

        seekedBuffers = function() {
            if (videoController) {
                videoController.seeked();
            }
            if (audioController) {
                audioController.seeked();
            }
            if (textController) {
                textController.seeked();
            }
        },

        suspend = function() {
            if (!this.scheduleWhilePaused || this.manifestExt.getIsDynamic(manifest)) {
                stopBuffering.call(this);
            }

            clearInterval(checkStartTimeIntervalId);
        },

        doLoad = function(manifestResult) {

            var self = this;

            //self.debug.log("Stream start loading.");

            manifest = manifestResult;
            self.debug.log("[Stream] Create MediaSource");

            try {
                mediaSource = self.mediaSourceExt.createMediaSource();
            } catch (error) {
                self.errHandler.sendError(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_CREATE_MEDIASOURCE, "Failed to create MediaSource", {
                    name: error.name,
                    message: error.message
                });
            }

            if (mediaSource === null) {
                return;
            }

            initializeProtectionController.call(self).then(function() {
                self.debug.log("[Stream] Setup MediaSource");
                setUpMediaSource.call(self, mediaSource).then(
                    function(mediaSourceResult) {
                        mediaSource = mediaSourceResult;
                        self.debug.log("[Stream] Initialize MediaSource");
                        initializeMediaSource.call(self);
                        self.debug.log("[Stream] Initialize playback");
                        initializePlayback.call(self);
                        self.debug.log("[Stream] Playback initialized");
                    }
                );
            });
        },

        setVideoModelCurrentTime = function(time) {
            this.debug.log("[Stream] Set video model current time: " + time);
            this.videoModel.unlisten("seeking", seekingListener);
            this.videoModel.setCurrentTime(time);
        },

        onBufferingCompleted = function() {

            // if there is at least one buffer controller that has not completed buffering yet do nothing
            if ((videoController && !videoController.isBufferingCompleted()) || (audioController && !audioController.isBufferingCompleted())) {
                return;
            }

            // buffering has been complted, now we can signal end of stream
            if (mediaSource) {
                //unlisten pause event to have correct metrics, and not catch the pause event sent before the onded event
                this.videoModel.unlisten("pause", pauseListener);
                this.debug.info("[Stream] Signal end of stream");
                this.mediaSourceExt.signalEndOfStream(mediaSource);
            }
        },

        // 'startTimeFound' event raised by video controller when start time has been found
        // startTime = video live edge for live streams
        // startTime = first video segment time for static streams
        // => then seek every BufferController at the found start time
        onStartTimeFound = function(startTime) {
            this.debug.info("[Stream] Start time = " + startTime);
            // Check if initial start time is set, then overload start time
            if (initialStartTime !== -1 &&
                !this.manifestExt.getIsDynamic(manifest) &&
                initialStartTime < periodInfo.duration) {
                this.debug.info("[Stream] Initial start time = " + initialStartTime);
                startTime = initialStartTime;
            }
            seek.call(this, startTime, (periodInfo.index === 0) && autoPlay);
        },

        // ORANGE: 'bufferUpdated' event raised when some data has been appended into media buffers
        // => if not started (live use case) then check for playback start time and do play
        onBufferUpdated = function() {
            var videoRange,
                audioRange,
                startTime;

            this.debug.info("[Stream] Check start time");

            // Check if video buffer is not empty
            videoRange = this.sourceBufferExt.getBufferRange(videoController.getBuffer(), seekTime, videoController.getSegmentDuration());
            if (videoRange === null) {
                return;
            }

            startTime = Math.max(seekTime, videoRange.start);

            if (videoRange.end < startTime) {
                return;
            }

            if (audioController) {
                // Check if audio buffer is not empty
                audioRange = this.sourceBufferExt.getBufferRange(audioController.getBuffer(), seekTime, audioController.getSegmentDuration());
                if (audioRange === null) {
                    return;
                }
                this.debug.info("[Stream] Check start time: A[" + audioRange.start + "-" + audioRange.end + "], V[" + videoRange.start + "-" + videoRange.end + "]");
                // Check if audio and video can be synchronized (if some audio sample is available at returned start time)
                if (audioRange.end < startTime) {
                    return;
                }
                startTime = Math.max(startTime, audioRange.start);
            }

            this.debug.info("[Stream] Check start time: OK => " + startTime);

            // Unmap "bufferUpdated" handler
            this.system.unmapHandler("bufferUpdated");

            // Set current time on video if 'play' event has already been raised.
            // If 'play' event has not yet been raised, the the current time will be set afterwards
            if (!this.videoModel.isPaused()) {
                setVideoModelCurrentTime.call(this, startTime);
            } else {
                playStartTime = startTime;
            }

            if (this.manifestExt.getIsStartOver(manifest)) {
                startFragmentInfoControllers.call(this);
            }
            
            play.call(this);
        },

        // 'sourceDurationChanged' event is raised when source duration changed (start-over streams use case)
        onSourceDurationChanged = function(duration) {
            this.debug.info("[Stream] Source duration changed: " + duration);
            this.mediaSourceExt.setDuration(mediaSource, duration);
            manifest.mediaPresentationDuration = duration;
            periodInfo.duration = duration;
        },

        selectTrack = function(controller, track, currentIndex) {
            var index = -1;

            if (!controller) {
                return currentIndex;
            }

            if (currentIndex === -1) {
                return currentIndex;
            }

            // Get data index corresponding to the new selected track
            index = this.manifestExt.getDataIndex(track, manifest, periodInfo.index);

            // Check if different track selected
            if (index !== currentIndex) {
                if (manifest.name === 'MSS' && (this.manifestExt.getIsDynamic(manifest)  || this.manifestExt.getIsStartOver(manifest))) {
                    // If live MSS, refresh the manifest to get new selected track segments info
                    this.system.notify("manifestUpdate");
                } else {
                    // Else update controller data directly
                    controller.updateData(track, periodInfo);
                }
            }

            return index;
        },

        filterCodecs = function(data) {
            var codec,
                i;
            // Filter codecs that are not supported
            // But keep at least codec from lowest representation
            i = 1;
            while (i < data.Representation_asArray.length) {
                codec = this.manifestExt.getCodecForRepresentation(data.Representation_asArray[i]);
                if (codec) {
                    if (!this.capabilities.supportsCodec(this.videoModel.getElement(), codec)) {
                        this.debug.warn('[Stream] codec not supported: ' + codec);
                        data.Representation_asArray.splice(i, 1);
                        i--;
                    }
                }
                i++;
            }
        },

        updateData = function(updatedPeriodInfo) {
            var videoData,
                data;

            manifest = this.manifestModel.getValue();
            periodInfo = updatedPeriodInfo;
            this.debug.log("[Stream] Manifest updated ... set new data on buffers.");

            if (videoController) {
                videoData = videoController.getData();

                if (!!videoData && videoData.hasOwnProperty("id")) {
                    data = this.manifestExt.getDataForId(videoData.id, manifest, periodInfo.index);
                } else {
                    data = this.manifestExt.getDataForIndex(videoTrackIndex, manifest, periodInfo.index);
                }
                filterCodecs.call(this, data);
                videoController.updateData(data, periodInfo);
            }

            if (audioController) {
                data = this.manifestExt.getDataForIndex(audioTrackIndex, manifest, periodInfo.index);
                filterCodecs.call(this, data);
                audioController.updateData(data, periodInfo);
            }

            if (textController) {
                data = this.manifestExt.getDataForIndex(textTrackIndex, manifest, periodInfo.index);
                textController.updateData(data, periodInfo);
            }

            if (eventController) {
                var events = this.manifestExt.getEventsForPeriod(manifest, periodInfo);
                eventController.addInlineEvents(events);
            }

            if (isReloading && videoController) {
                this.system.unmapHandler("bufferUpdated");
                this.system.mapHandler("bufferUpdated", undefined, onBufferUpdated.bind(this));
                // Call load on video controller in order to get new stream start time (=live edge for live streams)
                videoController.load();
            }

            if (dvrStarted) {
                startFragmentInfoControllers.call(this);
            }
        },

        streamsComposed = function() {
            var time = this.videoModel.getCurrentTime();
            textController.seek(time);
            textController.seeked();
        },

        // Called when a BufferController failed to download or buffer a segment
        onSegmentLoadingFailed = function(segmentRequest) {
            var self = this;

            this.debug.log("[Stream] Segment loading failed: start time = " + segmentRequest.startTime + ", duration = " + segmentRequest.duration);

            if ((this.manifestExt.getIsDynamic(manifest) || this.manifestExt.getIsStartOver(manifest)) && reloadTimeout === null) {
                // For Live streams, then we try to reload the session
                isReloading = true;
                var delay = segmentRequest.duration;
                this.debug.info("[Stream] Reload session in " + delay + " s.");
                reloadTimeout = setTimeout(function() {
                    reloadTimeout = null;
                    //pause.call(self);
                    isReloading = true;
                    self.debug.info("[Stream] Reload session (update manifest)");
                    self.system.notify("manifestUpdate", true);
                    stopFragmentInfoControllers.call(self);
                }, delay * 1000);
            } else {
                // For VOD streams, we seek at recovery time
                seek.call(this, (segmentRequest.startTime + segmentRequest.duration));
            }
        },

        onVisibilitychange = function() {

            if (document.hidden === true || startClockTime === -1) {
                return;
            }

            // If current document get focus back, then check if resynchronization is required
            var clockTime = new Date().getTime() / 1000,
                streamTime = this.getVideoModel().getCurrentTime(),
                elapsedClockTime = clockTime - startClockTime,
                elapsedStreamTime = streamTime - startStreamTime;

            this.debug.log("[Stream] VisibilityChange: elapsedClockTime = " + elapsedClockTime + ", elapsedStreamTime = " + elapsedStreamTime + " (" + (elapsedClockTime - elapsedStreamTime) + ")");

            if ((elapsedClockTime - elapsedStreamTime) > 1) {
                onReload.call(this);
            }

        };

    return {
        system: undefined,
        videoModel: undefined,
        manifestLoader: undefined,
        manifestModel: undefined,
        mediaSourceExt: undefined,
        sourceBufferExt: undefined,
        manifestExt: undefined,
        fragmentController: undefined,
        fragmentExt: undefined,
        protectionExt: undefined,
        capabilities: undefined,
        debug: undefined,
        metricsExt: undefined,
        errHandler: undefined,
        timelineConverter: undefined,
        scheduleWhilePaused: undefined,
        textTrackExtensions: undefined,
        metricsModel: undefined,
        eventBus: undefined,
        notify: undefined,
        config: undefined,

        setup: function() {
            this.system.mapHandler("startTimeFound", undefined, onStartTimeFound.bind(this));
            this.system.mapHandler("segmentLoadingFailed", undefined, onSegmentLoadingFailed.bind(this));
            this.system.mapHandler("bufferingCompleted", undefined, onBufferingCompleted.bind(this));
            this.system.mapHandler("sourceDurationChanged", undefined, onSourceDurationChanged.bind(this));
            
            // Protection event handlers
            if (MediaPlayer.dependencies.ProtectionController) {
                this[MediaPlayer.dependencies.ProtectionController.eventList.ENAME_PROTECTION_ERROR] = onProtectionError.bind(this);
            }

            playListener = onPlay.bind(this);
            pauseListener = onPause.bind(this);
            errorListener = onError.bind(this);
            seekingListener = onSeeking.bind(this);
            seekedListener = onSeeked.bind(this);
            waitingListener = onWaiting.bind(this);
            progressListener = onProgress.bind(this);
            ratechangeListener = onRatechange.bind(this);
            timeupdateListener = onTimeupdate.bind(this);
            durationchangeListener = onDurationchange.bind(this);
            loadedListener = onLoaded.bind(this);
            canplayListener = onCanPlay.bind(this);
            playingListener = onPlaying.bind(this);
            loadstartListener = onLoadStart.bind(this);
            endedListener = onEnded.bind(this);

            visibilitychangeListener = onVisibilitychange.bind(this);
        },

        load: function(manifest, periodInfoValue) {
            periodInfo = periodInfoValue;
            doLoad.call(this, manifest);
        },

        setVideoModel: function(value) {
            this.videoModel = value;
            this.videoModel.listen("play", playListener);
            this.videoModel.listen("pause", pauseListener);
            this.videoModel.listen("error", errorListener);
            this.videoModel.listen("seeking", seekingListener);
            this.videoModel.listen("seeked", seekedListener);
            this.videoModel.listen("waiting", waitingListener);
            this.videoModel.listen("timeupdate", timeupdateListener);
            this.videoModel.listen("durationchange", durationchangeListener);
            this.videoModel.listen("progress", progressListener);
            this.videoModel.listen("ratechange", ratechangeListener);
            this.videoModel.listen("loadedmetadata", loadedListener);
            this.videoModel.listen("ended", endedListener);
            this.videoModel.listen("canplay", canplayListener);
            this.videoModel.listen("playing", playingListener);
            this.videoModel.listen("loadstart", loadstartListener);

            //document.addEventListener("visibilitychange", visibilitychangeListener);
        },

        setInitialStartTime: function(startTime) {
            var time = parseFloat(startTime);
            if (!isNaN(time)) {
                initialStartTime = time;
            }
        },

        getAudioTracks: function() {
            return this.manifestExt.getAudioDatas(manifest, periodInfo.index);
        },

        setAudioTrack: function(audioTrack) {
            if (fragmentInfoAudioController) {
                fragmentInfoAudioController.stop();
            }
            audioTrackIndex = selectTrack.call(this, audioController, audioTrack, audioTrackIndex);
        },

        getSelectedAudioTrack: function() {
            if (audioController) {
                return this.manifestExt.getDataForIndex(audioTrackIndex, manifest, periodInfo.index);
            }
            return undefined;
        },

        getSubtitleTracks: function() {
            return this.manifestExt.getTextDatas(manifest, periodInfo.index);
        },

        setSubtitleTrack: function(subtitleTrack) {
            if (fragmentInfoTextController) {
                fragmentInfoTextController.stop();
            }
            textTrackIndex = selectTrack.call(this, textController, subtitleTrack, textTrackIndex);
        },

        getSelectedSubtitleTrack: function() {
            if (textController && subtitlesEnabled) {
                return this.manifestExt.getDataForIndex(textTrackIndex, manifest, periodInfo.index);
            }
            return undefined;
        },

        initProtection: function(protectionCtrl) {
            protectionController = protectionCtrl;
            if (protectionController) {
                protectionController.subscribe(MediaPlayer.dependencies.ProtectionController.eventList.ENAME_PROTECTION_ERROR, this);
            }
        },

        getVideoModel: function() {
            return this.videoModel;
        },

        getManifestExt: function() {
            var self = this;
            return self.manifestExt;
        },

        setAutoPlay: function(value) {
            autoPlay = value;
        },

        setDefaultAudioLang: function(language) {
            defaultAudioLang = language;
        },

        setDefaultSubtitleLang: function(language) {
            defaultSubtitleLang = language;
        },

        getAutoPlay: function() {
            return autoPlay;
        },

        reset: function() {
            var deferred = Q.defer(),
                self = this;

            this.debug.info("[Stream] Reset");

            stopBuffering.call(this);

            stopFragmentInfoControllers.call(this);

            pause.call(this);

            // Trick mode seeking timeout
            clearTimeout(tmSeekTimeout);

            // Stop reload timeout
            clearTimeout(reloadTimeout);

            //if player is in trick mode, restore mute state.
            if (tmSpeed !== 1) {
                this.videoModel.setMute(muteState);
            }

            //document.removeEventListener("visibilityChange");

            this.videoModel.unlisten("play", playListener);
            this.videoModel.unlisten("pause", pauseListener);
            this.videoModel.unlisten("error", errorListener);
            this.videoModel.unlisten("seeking", seekingListener);
            this.videoModel.unlisten("seeked", seekedListener);
            this.videoModel.unlisten("waiting", waitingListener);
            this.videoModel.unlisten("timeupdate", timeupdateListener);
            this.videoModel.unlisten("durationchange", durationchangeListener);
            this.videoModel.unlisten("progress", progressListener);
            this.videoModel.unlisten("ratechange", ratechangeListener);
            this.videoModel.unlisten("loadedmetadata", loadedListener);
            this.videoModel.unlisten("ended", endedListener);
            this.videoModel.unlisten("canplay", canplayListener);
            this.videoModel.unlisten("playing", playingListener);
            this.videoModel.unlisten("loadstart", loadstartListener);

            this.system.unmapHandler("streamsComposed", undefined, streamsComposed);

            this.system.unmapHandler("bufferUpdated");
            this.system.unmapHandler("startTimeFound");
            this.system.unmapHandler("segmentLoadingFailed");
            this.system.unmapHandler("bufferingCompleted");
            this.system.unmapHandler("sourceDurationChanged");
            
            tearDownMediaSource.call(this).then(
                function() {
                    if (protectionController) {
                        protectionController.unsubscribe(MediaPlayer.dependencies.ProtectionController.eventList.ENAME_PROTECTION_ERROR, self);
                    }

                    protectionController = undefined;
                    self.fragmentController = undefined;

                    deferred.resolve();
                });

            return deferred.promise;
        },

        getDuration: function() {
            return periodInfo.duration;
        },

        getStartTime: function() {
            return periodInfo.start;
        },

        getPeriodIndex: function() {
            return periodInfo.index;
        },

        getId: function() {
            return periodInfo.id;
        },

        getPeriodInfo: function() {
            return periodInfo;
        },

        getMinbufferTime: function() {
            if (!videoController) {
                return MediaPlayer.dependencies.BufferExtensions.DEFAULT_MIN_BUFFER_TIME;
            }
            return videoController.getMinbufferTime();
        },

        getLiveDelay: function() {
            if (!videoController) {
                return MediaPlayer.dependencies.BufferExtensions.DEFAULT_LIVE_DELAY;
            }
            return videoController.getLiveDelay();
        },

        startEventController: function() {
            eventController.start();
        },

        resetEventController: function() {
            eventController.reset();
        },

        enableSubtitles: function(enabled) {
            var track;

            if (enabled !== subtitlesEnabled) {
                subtitlesEnabled = enabled;
                track = this.textTrackExtensions.getCurrentTextTrack(this.videoModel.getElement());
                this.textTrackExtensions.cleanSubtitles();

                if (textController) {
                    if (enabled) {
                        if (manifest.name === 'MSS' && (this.manifestExt.getIsDynamic(manifest)  || this.manifestExt.getIsStartOver(manifest))) {
                            // In case of MSS live streams, refresh manifest before activating subtitles
                            this.system.mapHandler("streamsComposed", undefined, streamsComposed.bind(this), true);
                            this.system.notify("manifestUpdate");
                        } else {
                            streamsComposed.call(this);
                        }
                        // show subtitle here => useful for full TTML file
                        if (track && track.kind !== 'metadata' && track.mode !== 'showing') {
                            track.mode = "showing";
                        }else if (track) {
                            track.mode = "hidden";
                        }
                    } else {
                        if (fragmentInfoTextController) {
                            fragmentInfoTextController.stop();
                        }
                        // hide subtitle here
                        if (track) {
                            track.mode = "disabled";
                        }
                        textController.stop();
                    }
                }
            }
        },

        setTrickModeSpeed: function(speed) {
            var funcs = [],
                self = this,
                enableTrickMode = (speed !== 1) ? true : false,
                currentVideoTime,
                seekValue,
                restoreMute = function() {
                    if (self.videoModel.getCurrentTime() > (currentVideoTime + 1)) {
                        self.videoModel.unlisten("timeupdate", restoreMute);
                        self.debug.info("[Stream] Set mute: " + muteState + ", the mute state before using trick mode.");
                        self.videoModel.setMute(muteState);
                    }
                };

            if (speed === tmSpeed) {
                return;
            }

            if (!videoController) {
                return;
            }

            self.debug.info("[Stream] Trick mode: speed = " + speed);

            if (enableTrickMode && tmState === "Stopped") {
                //unlisten pause event to have correct metrics
                this.videoModel.unlisten("pause", pauseListener);
                self.debug.info("[Stream] Set mute: true");
                muteState = self.videoModel.getMute();
                if (!muteState) {
                    self.videoModel.setMute(true);
                }
                self.videoModel.pause();
            } else if (!enableTrickMode) {
                //stop trick mode, add a trick mode metric
                self.metricsModel.addPlayList('video', new Date().getTime(), tmVideoStartTime, 'trickMode', tmSpeed);
                tmSpeed = 1;
                clearTimeout(tmSeekTimeout);
                stopBuffering.call(self);
            }

            funcs.push(videoController.setTrickMode(enableTrickMode, speed > 1));
            if (audioController) {
                funcs.push(audioController.setTrickMode(enableTrickMode, speed > 1));
            }

            Q.all(funcs).then(function() {
                tmPreviousSpeed = tmSpeed;
                tmSpeed = speed;
                currentVideoTime = self.videoModel.getCurrentTime();

                if (!enableTrickMode) {
                    //listen pause event to have correct metrics
                    self.videoModel.listen("pause", pauseListener);
                    self.debug.info("[Stream] Trick mode: Stopped, current time = " + currentVideoTime);
                    tmState = "Stopped";
                    self.videoModel.listen("timeupdate", restoreMute);
                    currentVideoTime = tmEndDetected ? self.getStartTime() : currentVideoTime;
                    seek.call(self, currentVideoTime, true);
                } else {
                    if (tmState === "Running") {
                        //trick mode speed has changed, add a trick mode metric for the previous speed
                        self.metricsModel.addPlayList('video', new Date().getTime(), tmVideoStartTime, 'trickMode', tmPreviousSpeed);
                        tmState = "Changed";
                    } else if (tmState === "Stopped") {
                        tmEndDetected = false;
                        tmState = "Running";
                        tmSeekStep = tmMinSeekStep = videoController.getSegmentDuration();
                        tmStartTime = tmSeekTime = (new Date().getTime()) / 1000;
                        tmVideoStartTime = currentVideoTime;
                        self.debug.info("[Stream] Trick mode (x" + tmSpeed + "): videoTime = " + tmVideoStartTime);
                        seekValue = currentVideoTime + (tmSeekStep * Math.sign(tmSpeed));
                        seekValue = Math.round((seekValue - (seekValue % tmMinSeekStep)) * 1000) / 1000;
                        self.debug.info("[Stream] Trick mode (x" + tmSpeed + "): seek step = " + tmSeekStep);
                        tmSeekValue = seekValue;
                        seek.call(self, seekValue);
                    }
                }
            });
        },

        getTrickModeSpeed: function() {
            return tmSpeed;
        },

        updateData: updateData,
        play: play,
        seek: seek,
        pause: pause
    };
};

MediaPlayer.dependencies.Stream.prototype = {
    constructor: MediaPlayer.dependencies.Stream
};

/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Digital Primates
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.dependencies.StreamController = function() {
    "use strict";

    /*
     * StreamController aggregates all streams defined as Period sections in the manifest file
     * and implements corresponding logic to switch between them.
     */

    var source,
        running = false,
        streams = [],
        activeStream,
        protectionController,
        ownProtectionController = false,
        //TODO set correct value for threshold
        STREAM_BUFFER_END_THRESHOLD = 6,
        STREAM_END_THRESHOLD = 0.2,
        autoPlay = true,
        isPeriodSwitchingInProgress = false,
        timeupdateListener,
        seekingListener,
        progressListener,
        pauseListener,
        playListener,
        protectionData,
        defaultAudioLang = 'und',
        defaultSubtitleLang = 'und',
        subtitlesEnabled = false,
        reloadStream = false,
        deferredLoading = null,

        isSafari = (fingerprint_browser().name === "Safari"),

        /*
         * Replaces the currently displayed <video> with a new data and corresponding <video> element.
         *
         * @param fromVideoModel Currently used video data
         * @param toVideoModel New video data to be displayed
         *
         * TODO - move method to appropriate place - VideoModelExtensions??
         */
        switchVideoModel = function(fromVideoModel, toVideoModel) {
            var activeVideoElement = fromVideoModel.getElement(),
                newVideoElement = toVideoModel.getElement();

            if (!newVideoElement.parentNode) {
                activeVideoElement.parentNode.insertBefore(newVideoElement, activeVideoElement);
            }

            // We use width property to hide/show video element because when using display="none"/"block" playback
            // sometimes stops after switching.
            activeVideoElement.style.width = "0px";
            newVideoElement.style.width = "100%";

            copyVideoProperties(activeVideoElement, newVideoElement);
            detachVideoEvents.call(this, fromVideoModel);
            attachVideoEvents.call(this, toVideoModel);

            return true;
        },

        attachVideoEvents = function(videoModel) {
            videoModel.listen("seeking", seekingListener);
            videoModel.listen("progress", progressListener);
            videoModel.listen("timeupdate", timeupdateListener);
            videoModel.listen("pause", pauseListener);
            videoModel.listen("play", playListener);
        },

        detachVideoEvents = function(videoModel) {
            videoModel.unlisten("seeking", seekingListener);
            videoModel.unlisten("progress", progressListener);
            videoModel.unlisten("timeupdate", timeupdateListener);
            videoModel.unlisten("pause", pauseListener);
            videoModel.unlisten("play", playListener);
        },

        copyVideoProperties = function(fromVideoElement, toVideoElement) {
            ["controls", "loop", "muted", "playbackRate", "volume"].forEach(function(prop) {
                toVideoElement[prop] = fromVideoElement[prop];
            });
        },

        /*
         * Called when more data is buffered.
         * Used to determine the time current stream is almost buffered and we can start buffering of the next stream.
         * TODO move to ???Extensions class
         */
        onProgress = function() {

            var ranges = activeStream.getVideoModel().getElement().buffered;

            // nothing is buffered
            if (!ranges.length) {
                return;
            }

            var lastRange = ranges.length - 1,
                bufferEndTime = ranges.end(lastRange),
                remainingBufferDuration = activeStream.getStartTime() + activeStream.getDuration() - bufferEndTime;

            if (remainingBufferDuration < STREAM_BUFFER_END_THRESHOLD) {
                activeStream.getVideoModel().unlisten("progress", progressListener);
                onStreamBufferingEnd();
            }
        },

        switchStream = function(from, to, seekTo) {

            if (isPeriodSwitchingInProgress || !from || !to || from === to) {
                return;
            }

            isPeriodSwitchingInProgress = true;

            from.pause();
            activeStream = to;

            switchVideoModel.call(this, from.getVideoModel(), to.getVideoModel());

            if (seekTo) {
                this.seek(from.getVideoModel().getCurrentTime());
            } else {
                this.seek(to.getStartTime());
            }

            this.play();
            from.resetEventController();
            activeStream.startEventController();
            isPeriodSwitchingInProgress = false;
        },


        /*
         * Called when current playback positon is changed.
         * Used to determine the time current stream is finished and we should switch to the next stream.
         * TODO move to ???Extensions class
         */
        onTimeupdate = function() {

            if (!activeStream) {
                return;
            }

            var self = this,
                time = new Date(),
                streamEndTime = activeStream.getStartTime() + activeStream.getDuration(),
                videoElement = activeStream.getVideoModel().getElement(),
                currentTime = videoElement.currentTime,
                playBackQuality = self.videoExt.getPlaybackQuality(videoElement);

            // playBackQuality may be null
            if (playBackQuality)
                self.metricsModel.addPlaybackQuality("video", time, playBackQuality, currentTime);
            self.metricsModel.addVideoResolution("video", time, videoElement.videoWidth, videoElement.videoHeight, currentTime);

            if (!getNextStream()) {
                return;
            }

            // Sometimes after seeking timeUpdateHandler is called before seekingHandler and a new period starts
            // from beginning instead of from a chosen position. So we do nothing if the player is in the seeking state
            if (activeStream.getVideoModel().getElement().seeking) {
                return;
            }

            // check if stream end is reached
            if (streamEndTime - currentTime < STREAM_END_THRESHOLD) {
                switchStream.call(this, activeStream, getNextStream());
            }
        },

        /*
         * Called when Seeking event is occured.
         * TODO move to ???Extensions class
         */
        onSeeking = function() {
            var seekingTime = activeStream.getVideoModel().getCurrentTime(),
                seekingStream = getStreamForTime(seekingTime);

            if (seekingStream && seekingStream !== activeStream) {
                switchStream.call(this, activeStream, seekingStream, seekingTime);
            }
        },

        onPause = function() {
            this.manifestUpdater.stop();
        },

        onPlay = function() {
            this.manifestUpdater.start();
        },

        /*
         * Handles the current stream buffering end moment to start the next stream buffering
         */
        onStreamBufferingEnd = function() {
            var nextStream = getNextStream();
            if (nextStream) {
                nextStream.seek(nextStream.getStartTime());
            }
        },

        getNextStream = function() {
            var nextIndex = activeStream.getPeriodIndex() + 1;
            return (nextIndex < streams.length) ? streams[nextIndex] : null;
        },

        getStreamForTime = function(time) {
            var duration = 0,
                stream = null,
                ln = streams.length,
                i = 0;

            if (ln > 0) {
                duration += streams[0].getStartTime();
            }

            for (i = 0; i < ln; i += 1) {
                stream = streams[i];
                duration += stream.getDuration();

                if (time < duration) {
                    return stream;
                }
            }
        },

        //  TODO move to ???Extensions class
        createVideoModel = function() {
            var model = this.system.getObject("videoModel"),
                video = document.createElement("video");
            model.setElement(video);
            return model;
        },

        removeVideoElement = function(element) {
            if (element.parentNode) {
                element.parentNode.removeChild(element);
            }
        },

        composeStreams = function() {
            var manifest = this.manifestModel.getValue(),
                metrics = this.metricsModel.getMetricsFor("stream"),
                manifestUpdateInfo = this.metricsExt.getCurrentManifestUpdate(metrics),
                periodInfo,
                periods,
                pLen,
                sLen,
                pIdx,
                sIdx,
                period,
                mpd,
                stream;

            if (!manifest) {
                return false;
            }

            // Specific use case of "start-over" or "session DVR" live streams
            // We set this information in the manifest, to be used by MssFragmentController for DVR window updating
            if (source.startOver) {
                manifest.startOver = true;
            } 

            this.debug.info("[StreamController] composeStreams");

            if (this.capabilities.supportsEncryptedMedia()) {
                if (!protectionController) {
                    protectionController = this.system.getObject("protectionController");
                    /*this.eventBus.dispatchEvent({
                        type: MediaPlayer.events.PROTECTION_CREATED,
                        data: {
                            controller: protectionController,
                            manifest: manifest
                        }
                    });*/
                    ownProtectionController = true;
                }
                protectionController.setMediaElement(this.videoModel.getElement());
                if (protectionData) {
                    protectionController.setProtectionData(protectionData);
                }
            }

            mpd = this.manifestExt.getMpd(manifest);
            if (activeStream) {
                periodInfo = activeStream.getPeriodInfo();
                mpd.isClientServerTimeSyncCompleted = periodInfo.mpd.isClientServerTimeSyncCompleted;
                mpd.clientServerTimeShift = periodInfo.mpd.clientServerTimeShift;
            }

            periods = this.manifestExt.getRegularPeriods(manifest, mpd);
            if (periods.length === 0) {
                return false;
            }

            for (pIdx = 0, pLen = periods.length; pIdx < pLen; pIdx += 1) {
                period = periods[pIdx];
                for (sIdx = 0, sLen = streams.length; sIdx < sLen; sIdx += 1) {
                    // If the stream already exists we just need to update the values we got from the updated manifest
                    if (streams[sIdx].getId() === period.id) {
                        stream = streams[sIdx];
                        this.debug.info("[StreamController] update stream data");
                        stream.updateData(period);
                    }
                }
                // If the Stream object does not exist we probably loaded the manifest the first time or it was
                // introduced in the updated manifest, so we need to create a new Stream and perform all the initialization operations
                if (!stream) {
                    this.debug.info("[StreamController] Create stream");
                    stream = this.system.getObject("stream");
                    stream.setVideoModel(pIdx === 0 ? this.videoModel : createVideoModel.call(this));
                    stream.initProtection(protectionController);
                    stream.setAutoPlay(autoPlay);
                    stream.setDefaultAudioLang(defaultAudioLang);
                    stream.setDefaultSubtitleLang(defaultSubtitleLang);
                    stream.enableSubtitles(subtitlesEnabled);
                    stream.setInitialStartTime(source.startTime);
                    stream.load(manifest, period);
                    streams.push(stream);
                }

                this.metricsModel.addManifestUpdatePeriodInfo(manifestUpdateInfo, period.id, period.index, period.start, period.duration);
                stream = null;
            }

            // If the active stream has not been set up yet, let it be the first Stream in the list
            if (!activeStream) {
                activeStream = streams[0];
                attachVideoEvents.call(this, activeStream.getVideoModel());
            }

            this.metricsModel.updateManifestUpdateInfo(manifestUpdateInfo, {
                currentTime: this.videoModel.getCurrentTime(),
                buffered: this.videoModel.getElement().buffered,
                presentationStartTime: periods[0].start,
                clientTimeOffset: mpd.clientServerTimeShift
            });

            if (deferredLoading) {
                deferredLoading.resolve();
                deferredLoading = null;
            }

            return true;
        },

        manifestUpdate = function(reload) {
            if (reload === true) {
                reloadStream = true;
            }
            this.refreshManifest();
        },

        manifestHasUpdated = function() {

            // Check if stopping
            if (!running) {
                if (deferredLoading) {
                    deferredLoading.resolve();
                    deferredLoading = null;
                }
                return;
            }

            this.debug.info("[StreamController] Manifest updated");

            var result = composeStreams.call(this);

            if (result) {
                this.system.notify("streamsComposed");
            } else {
                this.errHandler.sendError(MediaPlayer.dependencies.ErrorHandler.prototype.MANIFEST_ERR_NO_STREAM, "No stream/period is provided in the manifest");
            }

            if (deferredLoading) {
                deferredLoading.resolve();
                deferredLoading = null;
            }
        },

        loadNativeHlsStream = function (source) {
            // If HLS+FP on Safari then we do use specific Stream instance
            if (isSafari && source.protocol === 'HLS') {
                var stream = this.system.getObject("hlsStream");
                stream.setVideoModel(this.videoModel);
                stream.setProtectionData(protectionData);
                stream.setAutoPlay(autoPlay);
                stream.setDefaultAudioLang(defaultAudioLang);
                stream.setDefaultSubtitleLang(defaultSubtitleLang);
                stream.enableSubtitles(subtitlesEnabled);
                stream.setInitialStartTime(source.startTime);
                streams.push(stream);
                activeStream = stream;
                attachVideoEvents.call(this, activeStream.getVideoModel());
                stream.load(source.url);
                return true;
            }

            return false;
        };

    return {
        system: undefined,
        videoModel: undefined,
        parser: undefined,
        manifestLoader: undefined,
        manifestUpdater: undefined,
        manifestModel: undefined,
        manifestExt: undefined,
        fragmentExt: undefined,
        capabilities: undefined,
        debug: undefined,
        metricsModel: undefined,
        metricsExt: undefined,
        videoExt: undefined,
        errHandler: undefined,
        eventBus: undefined,
        notify: undefined,
        subscribe: undefined,
        unsubscribe: undefined,

        setup: function() {
            this.system.mapHandler("manifestUpdate", undefined, manifestUpdate.bind(this));
            this.system.mapHandler("manifestUpdated", undefined, manifestHasUpdated.bind(this));
            timeupdateListener = onTimeupdate.bind(this);
            progressListener = onProgress.bind(this);
            seekingListener = onSeeking.bind(this);
            pauseListener = onPause.bind(this);
            playListener = onPlay.bind(this);
        },

        getManifestExt: function() {
            return activeStream.getManifestExt();
        },

        setAutoPlay: function(value) {
            autoPlay = value;
        },

        getAutoPlay: function() {
            return autoPlay;
        },

        getVideoModel: function() {
            return this.videoModel;
        },

        setVideoModel: function(value) {
            this.videoModel = value;
        },

        getAudioTracks: function() {
            if (activeStream) {
                return activeStream.getAudioTracks();
            }
            return null;
        },

        getSelectedAudioTrack: function() {

            if (activeStream) {
                return activeStream.getSelectedAudioTrack();
            }

            return undefined;
        },

        setAudioTrack: function(audioTrack) {
            if (activeStream) {
                activeStream.setAudioTrack(audioTrack);
            }
        },

        getSubtitleTracks: function() {
            if (activeStream) {
                return activeStream.getSubtitleTracks();
            }
            return null;
        },

        setSubtitleTrack: function(subtitleTrack) {
            if (activeStream) {
                activeStream.setSubtitleTrack(subtitleTrack);
            }
        },

        getSelectedSubtitleTrack: function() {

            if (activeStream) {
                return activeStream.getSelectedSubtitleTrack();
            }

            return undefined;
        },

        getMinbufferTime: function() {
            if (!activeStream) {
                return MediaPlayer.dependencies.BufferExtensions.DEFAULT_MIN_BUFFER_TIME;
            }
            return activeStream.getMinbufferTime();
        },

        getLiveDelay: function() {
            if (!activeStream) {
                return MediaPlayer.dependencies.BufferExtensions.DEFAULT_LIVE_DELAY;
            }
            return activeStream.getLiveDelay();
        },

        load: function(newSource) {
            var self = this;

            running = true;

            source = newSource;

            if (source.protData) {
                protectionData = source.protData;
            }

            if (loadNativeHlsStream.call(this, source)) {
                return;
            }

            reloadStream = false;

            deferredLoading = Q.defer();
            self.debug.info("[StreamController] load url: " + source.url);
            self.manifestLoader.load(source.url).then(
                function(manifest) {
                    self.manifestModel.setValue(manifest);
                    //ORANGE : add Metadata metric
                    self.metricsModel.addMetaData();
                    self.debug.info("[StreamController] Manifest has loaded.");
                    //self.debug.log(self.manifestModel.getValue());
                    self.manifestUpdater.start();
                },
                function(err) {
                    deferredLoading.resolve();
                    deferredLoading = null;
                    // err is undefined in the case the request has been aborted
                    if (err) {
                        self.errHandler.sendError(err.name, err.message, err.data);
                    }
                }
            );
        },

        refreshManifest: function(url) {
            var manifest = this.manifestModel.getValue(),
                manifestUrl = url ? url : (manifest.hasOwnProperty("Location") ? manifest.Location : manifest.mpdUrl);

            this.debug.log("[StreamController] Refresh manifest: " + manifestUrl);

            var self = this;
            this.manifestLoader.abort();
            this.manifestLoader.load(manifestUrl, true).then(
                function(manifestResult) {
                    self.manifestModel.setValue(manifestResult);
                    self.debug.log("[StreamController] Manifest has been refreshed");
                    reloadStream = false;
                },
                function(err) {
                    // err is undefined in the case the request has been aborted
                    if (err === undefined) {
                        return;
                    }

                    // Url is refreshed
                    if (url) {
                        // Raise an error only in case we try to reload the session
                        // to recover some segment downloading error
                        if (reloadStream) {
                            self.errHandler.sendError(err.name, err.message, err.data);
                        }
                    } else {
                        // If internal manifest updating (for ex. track switching),
                        // then raise a warning and ask for refreshing the url (in case it is no more valid or expired)
                        self.errHandler.sendWarning(err.name, err.message, err.data);
                        self.eventBus.dispatchEvent({
                            type: "manifestUrlUpdate",
                            data: {
                                url: manifestUrl
                            }
                        });
                    }
                }
            );
        },

        reset: function(reason) {
            var teardownComplete = {},
                funcs = [],
                stream,
                i,
                self = this;

            this.debug.info("[StreamController] Reset");

            if (!!activeStream) {
                detachVideoEvents.call(this, activeStream.getVideoModel());
            }

            running = false;

            self.manifestLoader.abort();
            self.manifestUpdater.stop();
            self.parser.reset();

            teardownComplete[MediaPlayer.models.ProtectionModel.eventList.ENAME_TEARDOWN_COMPLETE] = function() {
                // Complete ProtectionController teardown process
                ownProtectionController = false;
                protectionController = null;
                protectionData = null;

                self.manifestModel.setValue(null);

                self.metricsModel.addState('video', 'stopped', self.videoModel.getCurrentTime(), reason);
                self.metricsModel.clearAllCurrentMetrics();
                self.notify(MediaPlayer.dependencies.StreamController.eventList.ENAME_TEARDOWN_COMPLETE);
            };

            // Wait for current loading process (manifest download and updating) to be achieved
            Q.when(deferredLoading ? deferredLoading.promise : true).then(function () {

                self.pause();

                isPeriodSwitchingInProgress = false;

                // Reset the streams
                for (i = 0; i < streams.length; i += 1) {
                    stream = streams[i];
                    funcs.push(stream.reset());
                    if (stream !== activeStream) {
                        removeVideoElement(stream.getVideoModel().getElement());
                    }
                }

                // Reset the video model (stalled states)
                self.videoModel.reset();

                Q.all(funcs).then(
                    function() {
                        streams = [];
                        activeStream = null;

                        // Teardown the protection system
                        if (!protectionController) {
                            teardownComplete[MediaPlayer.models.ProtectionModel.eventList.ENAME_TEARDOWN_COMPLETE]();
                        } else if (ownProtectionController) {
                            protectionController.protectionModel.subscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_TEARDOWN_COMPLETE, teardownComplete, undefined, true);
                            protectionController.teardown();
                        } else {
                            protectionController.setMediaElement(null);
                            teardownComplete[MediaPlayer.models.ProtectionModel.eventList.ENAME_TEARDOWN_COMPLETE]();
                        }
                    }
                );
            });
        },

        setDefaultAudioLang: function(language) {
            defaultAudioLang = language;
        },

        setDefaultSubtitleLang: function(language) {
            defaultSubtitleLang = language;
        },

        enableSubtitles: function(enabled) {
            subtitlesEnabled = enabled;
            if (activeStream) {
                activeStream.enableSubtitles(enabled);
            }
        },

        setTrickModeSpeed: function(speed) {
            if (activeStream) {
                activeStream.setTrickModeSpeed(speed);
            }
        },

        getTrickModeSpeed: function() {
            if (activeStream) {
                return activeStream.getTrickModeSpeed();
            }
            return 0;
        },

        play: function() {
            activeStream.play();
        },

        pause: function() {
            if (activeStream) {
                activeStream.pause();
            }
        },

        seek: function(time, autoplay) {
            if (activeStream) {
                activeStream.seek(time, autoplay);
            }
        },
    };
};

MediaPlayer.dependencies.StreamController.prototype = {
    constructor: MediaPlayer.dependencies.StreamController
};

MediaPlayer.dependencies.StreamController.eventList = {
    ENAME_STREAMS_COMPOSED: "streamsComposed",
    ENAME_TEARDOWN_COMPLETE: "streamTeardownComplete"
};

/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2014, Akamai Technologies
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.utils.TokenAuthentication = function () {
    "use strict";
    var tokenAuthentication = {type:MediaPlayer.utils.TokenAuthentication.TYPE_QUERY};
    return {
        debug:undefined,
        getTokenAuthentication:function () {

            return tokenAuthentication;

        },
        setTokenAuthentication:function (object) {

            tokenAuthentication = object;

        },
        checkRequestHeaderForToken:function(request) {

            if (tokenAuthentication.name !== undefined &&
                request.getResponseHeader(tokenAuthentication.name) !== null) {

                tokenAuthentication.token = request.getResponseHeader(tokenAuthentication.name);
                this.debug.log(tokenAuthentication.name+" received: " + tokenAuthentication.token);

           }
        },
        addTokenAsQueryArg:function(url) {

            if(tokenAuthentication.name !== undefined && tokenAuthentication.token !== undefined) {
                if (tokenAuthentication.type === MediaPlayer.utils.TokenAuthentication.TYPE_QUERY) {

                    var modifier = url.indexOf('?') === -1 ? '?' : '&';
                    url += modifier + tokenAuthentication.name +"=" + tokenAuthentication.token;
                    this.debug.log(tokenAuthentication.name+" is being appended on the request url with a value of : " + tokenAuthentication.token);

                }
            }

            return url;
        },
        setTokenInRequestHeader:function(request) {

            if (tokenAuthentication.type === MediaPlayer.utils.TokenAuthentication.TYPE_HEADER) {

                request.setRequestHeader(tokenAuthentication.name, tokenAuthentication.token);
                this.debug.log(tokenAuthentication.name+" is being set in the request header with a value of : " + tokenAuthentication.token);

            }

            return request;
        }
    };
};

MediaPlayer.utils.TokenAuthentication.TYPE_QUERY = "query";
MediaPlayer.utils.TokenAuthentication.TYPE_HEADER = "header";
/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2014, Akamai Technologies
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.models.URIQueryAndFragmentModel = function () {
    "use strict";

    var URIFragmentDataVO = new MediaPlayer.vo.URIFragmentData(),
        URIQueryData = [],

        reset = function () {
            URIFragmentDataVO = new MediaPlayer.vo.URIFragmentData();
            URIQueryData = [];
        },

        parseURI = function (uri) {

            var URIFragmentData = [],
                testQuery = new RegExp(/[?]/),
                testFragment = new RegExp(/[#]/),
                isQuery = testQuery.test(uri),
                isFragment = testFragment.test(uri),
                mappedArr;

            function reduceArray(previousValue, currentValue, index, array) {
                var arr =  array[0].split(/[=]/);
                array.push({key:arr[0], value:arr[1]});
                array.shift();
                return array;
            }

            function mapArray(currentValue, index, array) {
                if (index > 0)
                {
                    if (isQuery && URIQueryData.length === 0) {
                        URIQueryData = array[index].split(/[&]/);
                    } else if (isFragment) {
                        URIFragmentData = array[index].split(/[&]/);
                    }
                }

                return array;
            }

            mappedArr = uri.split(/[?#]/).map(mapArray);

            if (URIQueryData.length > 0) {
                URIQueryData = URIQueryData.reduce(reduceArray, null);
            }

            if (URIFragmentData.length > 0) {
                URIFragmentData = URIFragmentData.reduce(reduceArray, null);
                URIFragmentData.forEach(function (object) {
                    URIFragmentDataVO[object.key] = object.value;
                });
            }

            return uri;
        };

    return {
        parseURI:parseURI,
        reset:reset,
        //ORANGE: fix bug on not updating URIFragmentDataVO 
        getURIFragmentData: function() {
            return URIFragmentDataVO;
        },
        getURIQueryData:URIQueryData
    };
};

MediaPlayer.models.URIQueryAndFragmentModel.prototype = {
    constructor: MediaPlayer.models.URIQueryAndFragmentModel
};

/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Digital Primates
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.models.VideoModel = function () {
    "use strict";

    var element,
        stalledStreams = [],
        TTMLRenderingDiv = null,

        addStalledStream = function (type) {    
            if (type === null || stalledStreams.indexOf(type) !== -1) {
                return;
            }
    
            this.debug.info("<video> # stall stream " + type);
            stalledStreams.push(type);
            // If at least one stream is stalled, then halt playback until nothing is stalled
            if (stalledStreams.length === 1) {
                this.setPlaybackRate(0);
            }
        },

        removeStalledStream = function (type) {
            var index = stalledStreams.indexOf(type);
    
            if (type === null) {
                return;
            }
            this.debug.info("<video> # unstall stream " + type);
            if (index !== -1) {
                stalledStreams.splice(index, 1);
            }
            // If no stream is stalled then resume playback.
            if (this.isStalled() === false && element.playbackRate === 0) {
                this.setPlaybackRate(1);
            }
        };

    return {
        system: undefined,
        debug: undefined,

        setup: function () {
            stalledStreams = [];
        },

        reset: function () {
            stalledStreams = [];
        },

        play: function () {
            this.debug.info("<video> # play()");
            element.play();
        },

        pause: function () {
            this.debug.info("<video> # pause()");
            element.pause();
        },

        isPaused: function () {
            return element.paused;
        },

        isSeeking: function () {
            return element.seeking;
        },

        getDuration: function () {
            return element.duration;
        },

        getPlaybackRate: function () {
            return element.playbackRate;
        },

        setPlaybackRate: function (value) {
            this.debug.info("<video> # playbackRate = " + value);
            element.playbackRate = value;
        },

        getMute: function () {
            return element.muted;
        },

        setMute: function (value) {
            element.muted = value;
        },

        getVolume: function () {
            return element.volume;
        },

        setVolume: function (value) {
            element.volume = value;
        },

        getCurrentTime: function () {
            return element.currentTime;
        },

        setCurrentTime: function (currentTime) {
            this.debug.info("<video> # currentTime = " + currentTime);
            element.currentTime = currentTime;
        },

        listen: function (type, callback) {
            element.addEventListener(type, callback, false);
        },

        unlisten: function (type, callback) {
            element.removeEventListener(type, callback, false);
        },

        listenOnParent: function (type, callback) {
            element.parentElement.addEventListener(type, callback, false);
        },

        unlistenOnParent: function (type, callback) {
            element.parentElement.removeEventListener(type, callback, false);
        },

        getElement: function () {
            return element;
        },

        setElement: function (value) {
            element = value;
        },

        setSource: function (source) {
            if (source) {
                this.debug.info("<video> # set source");
                element.src = source;
            } else {
                this.debug.info("<video> # reset source");
                element.removeAttribute('src');
                element.load();
            }
        },

        isStalled: function () {
            return (stalledStreams.length > 0);
        },

        stallStream: function (type, stalled) {
            if (stalled) {
                addStalledStream.call(this, type);
            } else {
                removeStalledStream.call(this, type);
            }
        },
        
        getTTMLRenderingDiv: function() {
            return TTMLRenderingDiv;
        },

        setTTMLRenderingDiv: function(div) {
            TTMLRenderingDiv = div;
            // The styling will allow the captions to match the video window size and position.
            TTMLRenderingDiv.style.position = 'absolute';
            TTMLRenderingDiv.style.display = 'flex';
            TTMLRenderingDiv.style.overflow = 'hidden';
            TTMLRenderingDiv.style.pointerEvents = 'none';
            TTMLRenderingDiv.style.top = 0;
            TTMLRenderingDiv.style.left = 0;
        }
    };
};

MediaPlayer.models.VideoModel.prototype = {
    constructor: MediaPlayer.models.VideoModel
};

/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 * 
 * Copyright (c) 2013, Digital Primates
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.dependencies.VideoModelExtensions = function () {
    "use strict";

    return {
        getPlaybackQuality: function (videoElement) {
            var hasWebKit = ("webkitDroppedFrameCount" in videoElement),
                hasQuality = ("getVideoPlaybackQuality" in videoElement),
                result = null;

            if (hasQuality) {
                result = videoElement.getVideoPlaybackQuality();
            }
            // ORANGE : add totalVideoFrames
            else if (hasWebKit) {
                result = {droppedVideoFrames: videoElement.webkitDroppedFrameCount, creationTime: new Date(), totalVideoFrames: videoElement.webkitDecodedFrameCount};
            }

            return result;
        }
    };
};

MediaPlayer.dependencies.VideoModelExtensions.prototype = {
    constructor: MediaPlayer.dependencies.VideoModelExtensions
};
/*
 * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.
 * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2014, Orange
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.dependencies.XHRLoader = function() {
    "use strict";

    var _xhr = null,
        _url = null,
        _responseType = null,
        _range = null,
        _onprogress = null,
        _retryAttempts = 0,
        _retryInterval = 0,
        _retryCount = 0,
        _retryTimeout = null,
        _deferred = null,

        _abort = function() {

            if (_xhr !== null && _xhr.readyState > 0 && _xhr.readyState < 4) {
                _xhr.abort();
            } else if (_retryTimeout) {
                clearTimeout(_retryTimeout);
                _retryTimeout = null;
                _deferred.reject();
            }
        },

        _load = function() {
            var needFailureReport = true,

                onprogress = function(event) {
                    if (_onprogress) {
                        _onprogress(_xhr, event);
                    }
                },

                onabort = function() {
                    _xhr.aborted = true;
                },

                onload = function() {
                    if (_xhr.status < 200 || _xhr.status > 299) {
                        return;
                    }

                    if (_xhr.status === 200 && _xhr.readyState === 4) {
                        // The request succeeded
                        // => return the response the responseURL in case of URL redirection
                        needFailureReport = false;

                        // Add endDate attribute to store request end time
                        _xhr.endDate = new Date();

                        _deferred.resolve(_xhr);
                    }
                },

                onloadend = function() {

                    if (!needFailureReport) {
                        return;
                    }
                    needFailureReport = false;

                    // Add endDate attribute to store request end time
                    _xhr.endDate = new Date();

                    // The request failed
                    _retryCount++;
                    if (!_xhr.aborted && _retryAttempts > 0 && _retryCount <= _retryAttempts) {
                        // Retry the request
                        _retryTimeout = setTimeout(function() {
                            _load();
                        }, _retryInterval);
                    } else {
                        _deferred.reject(_xhr);
                    }
                };

            try {
                _xhr = new XMLHttpRequest();
                _xhr.open("GET", _url, true);

                if (_responseType) {
                    _xhr.responseType = _responseType;
                }

                if (_range) {
                    _xhr.setRequestHeader('Range', 'bytes=' + _range);
                }

                _xhr.onprogress = onprogress;
                _xhr.onabort = onabort;
                _xhr.onload = onload;
                _xhr.onloadend = onloadend;
                _xhr.onerror = onloadend;

                // Add startDate attribute to store request start time
                _xhr.startDate = new Date();

                _xhr.send();
            } catch (e) {
                _xhr.onerror();
            }
        };

    return {

        initialize: function(responseType, retryAttempts, retryInterval, onprogress) {
            _responseType = responseType;
            _retryAttempts = retryAttempts;
            _retryInterval = retryInterval;
            _onprogress = onprogress;
        },

        load: function(url, range) {
            _url = url;
            _range = range;
            _retryCount = 0;
            _deferred = Q.defer();
            _load();
            return _deferred.promise;
        },

        abort: _abort
    };
};

MediaPlayer.dependencies.XHRLoader.prototype = {
    constructor: MediaPlayer.dependencies.XHRLoader
};

/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Akamai Technologies
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Akamai Technologies nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.dependencies.TextController = function() {

    var LOADING = "LOADING",
        //LOADED = "LOADED",
        READY = "READY",
        initialized = false,
        periodInfo = null,
        mediaSource,
        data,
        buffer,
        availableRepresentations,
        state = READY,
        setState = function(value) {
            this.debug.log("TextController setState to:" + value);
            state = value;
        },
        startPlayback = function() {

            if (!initialized || state !== READY) {
                return;
            }

            var self = this;
            // TODO Multiple tracks can be handled here by passing in quality level.
            self.indexHandler.getInitRequest(availableRepresentations[0]).then(
                function(request) {
                    //self.debug.log("Loading text track initialization: " + request.url);
                    //self.debug.log(request);
                    self.fragmentLoader.load(request).then(onBytesLoaded.bind(self, request), onBytesError.bind(self, request));
                    setState.call(self, LOADING);
                }
            );
        },
        doStart = function() {
            startPlayback.call(this);
        },

        updateRepresentations = function(data, periodInfo) {
            var adaptations,
                manifest = this.manifestModel.getValue(),
                idx;

            idx = this.manifestExt.getDataIndex(data, manifest, periodInfo.index);

            adaptations = this.manifestExt.getAdaptationsForPeriod(manifest, periodInfo);
            return this.manifestExt.getRepresentationsForAdaptation(manifest, adaptations[idx]);
        },

        onBytesLoaded = function(request, response) {
            var self = this;
            //self.debug.log(" Text track Bytes finished loading: " + request.url);
            // ORANGE: add request parameter to retrieve startTime and timescale in fragmentController
            self.fragmentController.process(response.data, request).then(
                function(data) {
                    if (data !== null) {
                        //self.debug.log("Push text track bytes: " + data.byteLength);
                        self.sourceBufferExt.append(buffer, data, self.videoModel);
                    }
                }
            );
        },

        onBytesError = function( /*request*/ ) {};

    return {
        videoModel: undefined,
        fragmentLoader: undefined,
        fragmentController: undefined,
        indexHandler: undefined,
        sourceBufferExt: undefined,
        manifestModel: undefined,
        manifestExt: undefined,
        debug: undefined,
        initialize: function(periodInfo, data, buffer, videoModel, source) {
            var self = this;

            self.setVideoModel(videoModel);
            self.setBuffer(buffer);
            self.setMediaSource(source);

            self.updateData(data, periodInfo);

            initialized = true;
            
            startPlayback.call(self);
        },

        setPeriodInfo: function(value) {
            periodInfo = value;
        },

        getPeriodIndex: function() {
            return periodInfo.index;
        },

        getVideoModel: function() {
            return this.videoModel;
        },

        setVideoModel: function(value) {
            this.videoModel = value;
        },

        getData: function() {
            return data;
        },

        setData: function(value) {
            data = value;
        },

        getBuffer: function() {
            return buffer;
        },

        setBuffer: function(value) {
            buffer = value;
        },

        setMediaSource: function(value) {
            mediaSource = value;
        },

        updateData: function(dataValue, periodInfoValue) {
            data = dataValue;
            periodInfo = periodInfoValue;

            availableRepresentations = updateRepresentations.call(this, data, periodInfo);
            setState.call(this, READY);
            startPlayback.call(this);
        },

        reset: function(errored) {
            if (!errored) {
                this.sourceBufferExt.abort(mediaSource, buffer);
                this.sourceBufferExt.removeSourceBuffer(mediaSource, buffer);
            }
        },

        start: doStart
    };
};

MediaPlayer.dependencies.TextController.prototype = {
    constructor: MediaPlayer.dependencies.TextController
};
/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Akamai Technologies
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Akamai Technologies nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.dependencies.TextSourceBuffer = function () {

    var video,
        data,
        mimeType,

        decodeUtf8 = function(arrayBuffer) {
            var result = "",
                i = 0,
                c = 0,
                c2 = 0,
                c3 = 0,
                data = new Uint8Array(arrayBuffer);

            // If we have a BOM skip it
            if (data.length >= 3 && data[0] === 0xef && data[1] === 0xbb && data[2] === 0xbf) {
                i = 3;
            }

            while (i < data.length) {
                c = data[i];

                if (c < 128) {
                    result += String.fromCharCode(c);
                    i++;
                } else if (c > 191 && c < 224) {
                    if (i + 1 >= data.length) {
                        throw "UTF-8 Decode failed. Two byte character was truncated.";
                    }
                    c2 = data[i + 1];
                    result += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
                    i += 2;
                } else {
                    if (i + 2 >= data.length) {
                        throw "UTF-8 Decode failed. Multi byte character was truncated.";
                    }
                    c2 = data[i + 1];
                    c3 = data[i + 2];
                    result += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
                    i += 3;
                }
            }
            return result;
        },

        buffered = {
            length: 0,
            ranges: [],

            start: function(index) {
                return this.ranges[index].start;
            },

            end: function(index) {
                return this.ranges[index].end;
            },

            addRange: function(start, end) {
                var i = 0,
                    rangesUpdated = false,
                    tolerance = 0.01;

                //detect discontinuity in ranges.
                for (i = 0; i < this.ranges.length; i++) {
                    if (this.ranges[i].end <= (start + tolerance) && this.ranges[i].end >= (start - tolerance)) {
                        rangesUpdated = true;
                        this.ranges[i].end = end;
                    }

                    if (this.ranges[i].start <= (end + tolerance) && this.ranges[i].start >= (end - tolerance)) {
                        rangesUpdated = true;
                        this.ranges[i].start = start;
                    }
                }

                if (!rangesUpdated) {
                    this.ranges.push({
                        start: start,
                        end: end
                    });
                    this.length = this.length + 1;

                    // TimeRanges must be normalized
                    this.ranges.sort(function(a, b) {
                        return a.start - b.start;
                    });
                }
            },

            removeRange: function(start, end) {
                var i = 0;
                for (i = this.ranges.length - 1; i >= 0; i -= 1) {
                    if (((end === undefined || end === -1) || (this.ranges[i].end <= end)) &&
                        ((start === undefined || start === -1) || (this.ranges[i].start >= start))) {
                        this.ranges.splice(i, 1);
                    }
                }

                this.length = this.ranges.length;
            },

            reset: function() {
                this.length = 0;
                this.ranges = [];
            }
        };

    return {
        system:undefined,
        eventBus:undefined,
        errHandler: undefined,
        textTrackExtensions: undefined,
        buffered: buffered,

        initialize: function (type, bufferController) {
            mimeType = type;
            video = bufferController.getVideoModel().getElement();
            data = bufferController.getData();
            buffered.reset();
        },

        remove: function(start, end) {
            if (start < 0 || start >= end) {
                throw "INVALID_ACCESS_ERR";
            }

            this.textTrackExtensions.deleteCues(video, false, start, end);
            this.buffered.removeRange(start, end);
        },

        append: function (bytes, request) {
            var self = this,
                ccContent = decodeUtf8(bytes),
                cues = self.getParser().parse(ccContent, request);

            if (video.textTracks.length === 0) {
                // We need to create the TextTrack
                self.textTrackExtensions.addTextTrack(video, [], data.Representation_asArray[0].id, data.lang, true);
            }

            if (video.textTracks.length === 0) {
                // Failed to create TextTrack, should never happen
                return;
            }

            self.textTrackExtensions.addCues(video.textTracks[0], cues);

            if (request) {
                self.buffered.addRange(request.startTime, request.startTime + request.duration);
            }
        },

        abort: function() {
            this.textTrackExtensions.deleteCues(video);
            this.buffered.reset();
        },

        getParser: function() {
            var parser;

            if (mimeType === "text/vtt") {
                parser = this.system.getObject("vttParser");
            } /*else if (mimeType === "application/ttml+xml") {
                parser = this.system.getObject("ttmlParser");
            }*/

            return parser;
        },

        addEventListener: function (type, listener, useCapture) {
            this.eventBus.addEventListener(type, listener, useCapture);
        },

        removeEventListener: function (type, listener, useCapture) {
            this.eventBus.removeEventListener(type, listener, useCapture);
        }
    };
};

MediaPlayer.dependencies.TextSourceBuffer.prototype = {
    constructor: MediaPlayer.dependencies.TextSourceBuffer
};

/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Akamai Technologies
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Akamai Technologies nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.utils.TextTrackExtensions = function() {
    "use strict";
    var Cue,
        currentLanguage = "",
        ttmlRenderer = null;

    return {
        system: undefined,
        eventBus: undefined,
        videoModel: undefined,
        debug: undefined,
        config: undefined,

        setup: function() {
            Cue = window.VTTCue || window.TextTrackCue;
        },

        cueEnter: function(subtitle_style, subtitle_text, subtitle_type) {
            this.eventBus.dispatchEvent({
                type: "cueEnter",
                data: {
                    text: subtitle_text,
                    style: subtitle_style,
                    type: subtitle_type
                }
            });
        },

        cueExit: function(subtitle_style, subtitle_text, subtitle_type) {
            this.eventBus.dispatchEvent({
                type: "cueExit",
                data: {
                    text: subtitle_text,
                    style: subtitle_style,
                    type: subtitle_type
                }
            });
        },

        getCurrentTextTrack: function(video){
            for(var i=0; i< video.textTracks.length; i++){
                if(video.textTracks[i].label === 'hascaption'){
                    return video.textTracks[i];
                }
            }
            return null;
        },

        addTextTrack: function(video, captionData, label, scrlang, isDefaultTrack) {
            var track = null,
                currentItem = null,
                subtitleDisplayMode = 'subtitles',
                renderingDiv = this.videoModel.getTTMLRenderingDiv(),
                i;

            //no function removeTextTrack is defined
            //add one, only if it's necessary
            //deleteCues will be very efficient in this case
            track = this.getCurrentTextTrack(video);
            if (!track) {
                if (renderingDiv) {
                    ttmlRenderer = this.system.getObject("ttmlRenderer");
                    ttmlRenderer.initialize(renderingDiv);
                }
                subtitleDisplayMode = renderingDiv !== null ? 'metadata' : 'subtitles';
                if (subtitleDisplayMode === 'subtitles') {
                    subtitleDisplayMode = this.config.getParam("TextTrackExtensions.displayModeExtern", "boolean") === true ? 'metadata' : 'subtitles';
                }
                //TODO: Ability to define the KIND in the MPD - ie subtitle vs caption....
                track = video.addTextTrack(subtitleDisplayMode, 'hascaption', scrlang);
                currentLanguage = scrlang;
                // track.default is an object property identifier that is a reserved word
                // The following jshint directive is used to suppressed the warning "Expected an identifier and instead saw 'default' (a reserved word)"
                /*jshint -W024 */
                track.default = isDefaultTrack;
                if (subtitleDisplayMode !== 'metadata') {
                    track.mode = "showing";
                }else{
                    track.mode = "hidden";
                }

            } else {
                this.cleanSubtitles();
                track.default = isDefaultTrack;
                if (track.mode !== 'showing' && track.kind !== 'metadata') {
                    track.mode = "showing";
                }
                currentLanguage = scrlang;
            }

            for (i = 0; i < captionData.length; i += 1) {
                currentItem = captionData[i];
                track.addCue(new Cue(currentItem.start, currentItem.end, currentItem.data));
            }

            return track;
        },        

        onCueEnter: function(e) {
            var renderingDiv = this.videoModel.getTTMLRenderingDiv();

            if (e.currentTarget.type === 'image' && renderingDiv === null) {
                this.debug.warn("[TextTrackExtensions] Rendering image subtitles without div is impossible");
            }

            if (renderingDiv) {
                ttmlRenderer.onCueEnter(e);
            }
            this.cueEnter(e.currentTarget.style, e.currentTarget.text, e.currentTarget.type);
        },

        onCueExit: function(e) {
            var renderingDiv = this.videoModel.getTTMLRenderingDiv();

            if (renderingDiv) {
                ttmlRenderer.onCueExit(e);
            }
            this.cueExit(e.currentTarget.style, e.currentTarget.text);
        },

        // Orange: addCues added so it is possible to add cues during playback,
        //         not only during track initialization

        addCues: function(track, captionData) {
            var i = 0,
                currentItem = null,
                newCue = null;

            for (i = 0; i < captionData.length; i += 1) {
                currentItem = captionData[i];
                if (currentItem.start < currentItem.end) {
                    newCue = new Cue(currentItem.start, currentItem.end, currentItem.data);

                    newCue.id = currentLanguage;
                    newCue.type = currentItem.type;
                    newCue.onenter = this.onCueEnter.bind(this);
                    newCue.onexit = this.onCueExit.bind(this);
                    newCue.snapToLines = false;
                    newCue.line = currentItem.line;

                    if (currentItem.style) {
                        newCue.style = currentItem.style;
                    }

                    track.addCue(newCue);
                }
            }
        },

        deleteCues: function(video, disabled, start, end) {
            var track = null,
                cues = null,
                lastIdx = null,
                currentTrackMode,
                i = 0;

            //when multiple tracks are supported - iterate through and delete all cues from all tracks.
            if (video) {
                track = video.textTracks[0];
                if (track) {
                    currentTrackMode = track.mode;
                    //if track mode is disabled, the cues are not accessible
                    //we have to change the mode value to be sure the delete process is correctly executed.
                    if (currentTrackMode === 'disabled') {
                        track.mode = 'hidden';
                    }
                    cues = track.cues;
                    if (cues) {
                        lastIdx = cues.length - 1;

                        for (i = lastIdx; i >= 0; i -= 1) {
                            if (((end === undefined || end === -1) || (cues[i].endTime <= end)) &&
                                ((start === undefined || start === -1) || (cues[i].startTime >= start))) {
                                track.removeCue(cues[i]);
                            }
                        }
                    }
                    track.mode = currentTrackMode;
                }
            }
        },

        cleanSubtitles: function() {
            var renderingDiv = this.videoModel.getTTMLRenderingDiv();
            if (renderingDiv && ttmlRenderer) {
                ttmlRenderer.cleanSubtitles();
            }
        },
    };
};
/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2014, Orange
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Akamai Technologies nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

// Orange: This Source Buffer processes TTML+XML subtitles encapsulated in the mp4
//         This format is used by smoothstreaming headends

MediaPlayer.dependencies.TextTTMLXMLMP4SourceBuffer = function() {

    var video,
        mimeType,
        currentLang,
        currentId,

        // We need to simulate TimeRanges, as defined 
        // by Media Streaming Extensions.
        // start() and end() functions must be provided,
        // as player checks the buffer level using these

        buffered = {
            length: 0,
            ranges: [],

            start: function(index) {
                return this.ranges[index].start;
            },

            end: function(index) {
                return this.ranges[index].end;
            },

            addRange: function(start, end) {
                var i = 0,
                    rangesUpdated = false,
                    tolerance = 0.01;

                //detect discontinuity in ranges.
                for (i = 0; i < this.ranges.length; i++) {
                    if (this.ranges[i].end <= (start + tolerance) && this.ranges[i].end >= (start - tolerance)) {
                        rangesUpdated = true;
                        this.ranges[i].end = end;
                    }

                    if (this.ranges[i].start <= (end + tolerance) && this.ranges[i].start >= (end - tolerance)) {
                        rangesUpdated = true;
                        this.ranges[i].start = start;
                    }
                }

                if (!rangesUpdated) {
                    this.ranges.push({
                        start: start,
                        end: end
                    });
                    this.length = this.length + 1;

                    // TimeRanges must be normalized
                    this.ranges.sort(function(a, b) {
                        return a.start - b.start;
                    });
                }
            },

            removeRange: function(start, end) {
                var i = 0;
                for (i = this.ranges.length - 1; i >= 0; i -= 1) {
                    if (((end === undefined || end === -1) || (this.ranges[i].end <= end)) &&
                        ((start === undefined || start === -1) || (this.ranges[i].start >= start))) {
                        this.ranges.splice(i, 1);
                    }
                }

                this.length = this.ranges.length;
            },

            reset: function() {
                this.length = 0;
                this.ranges = [];
            }
        };

    return {
        updating: false,
        system: undefined,
        eventBus: undefined,
        buffered: buffered,
        textTrackExtensions: undefined,
        ttmlParser: undefined,
        debug: undefined,
        manifestModel: undefined,
        errHandler: undefined,

        initialize: function(type, bufferController, subtitleData) {
            mimeType = type;
            video = bufferController.getVideoModel().getElement();
            buffered.reset();
            currentLang = subtitleData.lang;
            currentId = subtitleData.id;
        },
        remove: function(start, end) {
            /*If start is negative or greater than duration, then throw an INVALID_ACCESS_ERR exception and abort these steps.
            If end is less than or equal to start, then throw an INVALID_ACCESS_ERR exception and abort these steps.
            If this object has been removed from the sourceBuffers attribute of the parent media source then throw an INVALID_STATE_ERR exception and abort these steps.
            If the updating attribute equals true, then throw an INVALID_STATE_ERR exception and abort these steps.
            If the readyState attribute of the parent media source is in the "ended" state then run the following steps:

            Set the readyState attribute of the parent media source to "open"
            Queue a task to fire a simple event named sourceopen at the parent media source .
            Set the updating attribute to true.
            Queue a task to fire a simple event named updatestart at this SourceBuffer object.
            Return control to the caller and run the rest of the steps asynchronously.
            Run the coded frame removal algorithm with start and end as the start and end of the removal range.
            Set the updating attribute to false.
            Queue a task to fire a simple event named update at this SourceBuffer object.
            Queue a task to fire a simple event named updateend at this SourceBuffer object.*/
            if (start < 0 || start >= end) {
                throw "INVALID_ACCESS_ERR";
            }

            this.getTextTrackExtensions().deleteCues(video, false, start, end);
            this.buffered.removeRange(start, end);
        },

        append: function(bytes) {
            var self = this,
                file = mp4lib.deserialize(bytes),
                moov = file.getBoxByType('moov'),
                mvhd,
                moof,
                mdat,
                traf,
                tfhd,
                tfdt,
                trun,
                subs,
                fragmentStart,
                fragmentDuration = 0,
                ttmlData,
                encoding = 'utf-8';

            //no mp4, all the subtitles are in one xml file
            if (mimeType === 'application/ttml+xml') {
                this.track = this.textTrackExtensions.addTextTrack(video, [], currentId, currentLang, true);

                //detect utf-16 encoding
                if (MediaPlayer.utils.isUTF16(bytes)) {
                    encoding = 'utf-16';
                }

                this.convertUTFToString(bytes, encoding)
                    .then(function(result) {
                        self.ttmlParser.parse(result).then(function(cues) {
                            if (cues) {

                                self.textTrackExtensions.addCues(self.track, cues);
                                self.buffered.addRange(0, video.duration);
                                self.eventBus.dispatchEvent({
                                    type: "updateend"
                                });
                            }
                        }, function(error) {
                            self.errHandler.sendWarning(MediaPlayer.dependencies.ErrorHandler.prototype.INTERNAL_ERROR, "Internal error while parsing TTML data", error);
                        });
                    });
                return;
            }

            if (moov) {
                // This must be an init segment, if it has a moov box.
                // We need it to read the timescale, as it will be 
                // used to compute fragments time ranges.

                mvhd = moov.getBoxByType('mvhd');
                self.timescale = mvhd.timescale;

                // Also, it is a good moment to set up a text track on videoElement
                // TODO: set up name and language 
                this.track = this.textTrackExtensions.addTextTrack(video, [], currentId, currentLang, true);
                this.eventBus.dispatchEvent({
                    type: "updateend"
                });
                return;
            }

            moof = file.getBoxByType('moof');
            if (moof) {

                // This is a subtitles track fragment
                // let's decode the data and add captions to video element
                mdat = file.getBoxByType('mdat');

                // We need to update TimeRanges.                            
                // assume that there is a single text sample in fragment
                traf = moof.getBoxByType('traf');
                tfhd = traf.getBoxByType('tfhd');
                tfdt = traf.getBoxByType('tfdt');
                trun = traf.getBoxByType('trun');
                subs = traf.getBoxByType('subs');

                fragmentStart = tfdt.baseMediaDecodeTime / self.timescale;
                fragmentDuration = 0;
                if (trun.flags & 0x000100) {
                    fragmentDuration = trun.samples_table[0].sample_duration / self.timescale;
                } else {
                    fragmentDuration = tfhd.default_sample_duration / self.timescale;
                }

                self.buffered.addRange(fragmentStart, fragmentStart + fragmentDuration);
                
                if (subs) {
                    for (var i = 0; i < subs.entry_count; i++) {
                        for (var j = 0; j < subs.entry[i].subsample_count; j++) {
                            //the first subsample is the one in which TTML text is set
                            ttmlData = mdat.data.subarray(0, subs.entry[i].subSampleEntries[0].subsample_size);
                            break;
                        }
                    }
                } else {
                    ttmlData = mdat.data;
                }

                //detect utf-16 encoding
                if (MediaPlayer.utils.isUTF16(ttmlData)) {
                    encoding = 'utf-16';
                }
                // parse data and add to cues
                self.convertUTFToString(ttmlData, encoding)
                    .then(function(result) {
                        self.ttmlParser.parse(result).then(function(cues) {
                            var i,
                            manifest = self.manifestModel.getValue();

                            if (cues) {
                                if (manifest.name === 'MSS') {
                                    for (i = 0; i < cues.length; i += 1) {
                                        cues[i].start = cues[i].start + fragmentStart;
                                        cues[i].end = cues[i].end + fragmentStart;
                                    }
                                }

                                self.textTrackExtensions.addCues(self.track, cues);

                                self.eventBus.dispatchEvent({
                                    type: "updateend"
                                });
                            }
                        }, function(error) {
                            self.errHandler.sendWarning(MediaPlayer.dependencies.ErrorHandler.prototype.INTERNAL_ERROR, "Internal error while parsing TTML data", error);
                        });
                    });
            }
            return;
        },

        convertUTFToString: function(buf, encoding) {
            var deferred = Q.defer(),
                blob = new Blob([buf], {
                    type: "text/xml"
                }),
                f = new FileReader();

            f.onload = function(e) {
                deferred.resolve(e.target.result);
            };
            f.readAsText(blob, encoding);

            return deferred.promise;
        },

        UpdateLang: function(id, lang){
            currentId = id;
            currentLang = lang;
        },

        abort: function() {
            this.getTextTrackExtensions().deleteCues(video, true);
        },

        getTextTrackExtensions: function() {
            return this.textTrackExtensions;
        },

        addEventListener: function(type, listener, useCapture) {
            this.eventBus.addEventListener(type, listener, useCapture);
            if (!this.updating)
                this.eventBus.dispatchEvent({
                    type: "updateend"
                });
        },

        removeEventListener: function(type, listener, useCapture) {
            this.eventBus.removeEventListener(type, listener, useCapture);
        }
    };
};

MediaPlayer.dependencies.TextTTMLXMLMP4SourceBuffer.prototype = {
    constructor: MediaPlayer.dependencies.TextTTMLXMLMP4SourceBuffer
};
/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Akamai Technologies
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Akamai Technologies nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.utils.TTMLParser = function() {
    "use strict";

    /*
     * This TTML parser follows "TTML Simple Delivery Profile for Closed Captions (US)" spec - http://www.w3.org/TR/ttml10-sdp-us/
     *
     * ORANGE: Some strict limitations of US profile removed to allow for non-US TTML2 implmentations used in Europe:
     *         - no requirement for US profile
     *         - offset-style format allowed for <timeExpression>
     * */

    var SECONDS_IN_HOUR = 60 * 60,
        SECONDS_IN_MIN = 60,
        TTAF_URI = "http://www.w3.org/2006/10/ttaf1",
        TTAF_PARAMETER_URI = "http://www.w3.org/2006/10/ttaf1#parameter",
        TTAF_STYLE_URI = "http://www.w3.org/2006/10/ttaf1#styling",
        TTML_URI = "http://www.w3.org/ns/ttml",
        TTML_PARAMETER_URI = "http://www.w3.org/ns/ttml#parameter",
        TTML_STYLE_URI = "http://www.w3.org/ns/ttml#styling",
        SMPTE_TT_URI = "http://www.smpte-ra.org/schemas/2052-1/2010/smpte-tt",
        globalPrefTTNameSpace = [TTML_URI, TTAF_URI],
        globalPrefStyleNameSpace =  [TTML_STYLE_URI, TTAF_STYLE_URI],
        globalPrefParameterNameSpace = [TTML_PARAMETER_URI, TTAF_PARAMETER_URI],
        globalPrefSMPTENameSpace = [SMPTE_TT_URI],

        // R0028 - A document must not contain a <timeExpression> value that does not conform to the subset of clock-time that
        // matches either of the following patterns: hh:mm:ss.mss or hh:mm:ss:ff, where hh denotes hours (00-23),
        // mm denotes minutes (00-59), ss denotes seconds (00-59), mss denotes milliseconds (000-999), and ff denotes frames (00-frameRate - 1).
        // R0030 - For time expressions that use the hh:mm:ss.mss format, the following constraints apply:
        // - Exactly 2 digits must be used in each of the hours, minutes, and second components (include leading zeros).
        // - Exactly 3 decimal places must be used for the milliseconds component (include leading zeros).
        // R0031 -For time expressions that use the hh:mm:ss:ff format, the following constraints apply:
        // - Exactly 2 digits must be used in each of the hours, minutes, second, and frame components (include leading zeros).

        // Orange: the restrictions above are for US profile only.
        //         in general, TTML allows other syntax representations, see https://dvcs.w3.org/hg/ttml/raw-file/tip/ttml2/spec/ttml2.html#timing-value-timeExpression
        //         we have added support for offset-time, a pretty popular one.

        timingRegexClockTime = /^(0[0-9]|1[0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])((\.[0-9][0-9][0-9])|(:[0-9][0-9]))$/,
        timingRegexOffsetTime = /^\d+(\.\d+|)(h|m|s|ms|f)$/,
        xmlDoc = null,
        nodeTt = null,
        nodeHead = null,
        nodeLayout = null,
        nodeStyling = null,
        nodeBody = null,
        frameRate = null,
        tabStyles = [],
        tabRegions = [],
        tabImages = [],

        parseTimings = function(timingStr) {

            var timeParts,
                parsedTime,
                metric;

            if (timingRegexClockTime.test(timingStr)) {

                timeParts = timingStr.split(":");

                parsedTime = (parseFloat(timeParts[0]) * SECONDS_IN_HOUR +
                    parseFloat(timeParts[1]) * SECONDS_IN_MIN +
                    parseFloat(timeParts[2]));

                // R0031 -For time expressions that use the hh:mm:ss:ff format, the following constraints apply:
                //  - A ttp:frameRate attribute must be present on the tt element.
                //  - A ttp:frameRateMultiplier attribute may be present on the tt element.

                // ORANGE: removed the restrictions above.
                //         now if no frameRate is defined in tt, the :ff information is ignored.

                if (timeParts[3]) {
                    if (frameRate && !isNaN(frameRate)) {
                        parsedTime += parseFloat(timeParts[3]) / frameRate;
                    }
                }
                return parsedTime;
            }

            if (timingRegexOffsetTime.test(timingStr)) {

                if (timingStr.substr(timingStr.length - 2) == 'ms') {
                    parsedTime = parseFloat(timingStr.substr(0, timingStr.length - 3));
                    metric = timingStr.substr(timingStr.length - 2);
                } else {
                    parsedTime = parseFloat(timingStr.substr(0, timingStr.length - 2));
                    metric = timingStr.substr(timingStr.length - 1);
                }

                switch (metric) {
                    case 'h':
                        parsedTime = parsedTime * 60 * 60;
                        break;
                    case 'm':
                        parsedTime = parsedTime * 60;
                        break;
                    case 's':
                        break;
                    case 'ms':
                        parsedTime = parsedTime * 0.01;
                        break;
                    case 'f':
                        if (frameRate && !isNaN(frameRate)) {
                            parsedTime = parsedTime / frameRate;
                        } else {
                            return NaN;
                        }
                        break;
                }

                return parsedTime;
            }

            return NaN;
        },

        passStructuralConstraints = function() {
            var passed = false;

            nodeTt = xmlDoc ? this.domParser.getChildNode(xmlDoc, "tt") : null;
            nodeHead = nodeTt ? this.domParser.getChildNode(nodeTt, "head") : null;
            nodeLayout = nodeHead ? this.domParser.getChildNode(nodeHead, "layout") : null;
            nodeStyling = nodeHead ? this.domParser.getChildNode(nodeHead, "styling") : null;
            nodeBody = nodeTt ? this.domParser.getChildNode(nodeTt, "body") : null;

            // R001 - A document must contain a tt element.
            // R002 - A document must contain both a head and body element.
            // R003 - A document must contain both a styling and a layout element.
            if (nodeTt && nodeHead && /*nodeLayout && nodeStyling &&*/ nodeBody) {
                passed = true;
            }

            // R0008 - A document must contain a ttp:profile element where the use attribute of that element is specified as http://www.w3.org/ns/ttml/profile/sdp-us.
            // ORANGE: The R0008 requirement is removed in the parser implementation to make it work with non-US profiles
            return passed;
        },

        findStyleElement = function(nodeTab, styleElementName, defaultTTMLValue) {
            var styleName,
                regionName,
                resu = null,
                i = 0;

            for (i = 0; i < nodeTab.length; i += 1) {
                //search styleElementName in node Element
                resu = findParameterElement.call(this, [nodeTab[i]], globalPrefStyleNameSpace, styleElementName);

                if (resu) {
                    return resu;
                }

                //search style reference in node Element
                styleName = findParameterElement.call(this, [nodeTab[i]], globalPrefTTNameSpace, 'style');
                if (styleName) {
                    //search if styleElementName is defined in the specific style reference
                    resu = searchInTab.call(this, tabStyles, styleName, styleElementName);
                    if (resu) {
                        return resu;
                    }

                    //search if others styles are referenced in the selected one
                    styleName = searchInTab.call(this, tabStyles, styleName, 'style');

                    while (styleName) {
                        //search in this other style
                        resu = searchInTab.call(this, tabStyles, styleName, styleElementName);
                        if (resu) {
                            return resu;
                        }
                        styleName = searchInTab.call(this, tabStyles, styleName, 'style');
                    }
                }

                //search region reference in node Element
                regionName = findParameterElement.call(this, [nodeTab[i]], globalPrefTTNameSpace, 'region');
                if (regionName) {
                    //region reference has been found in the node element, search styleElementName definition in this specified region
                    resu = searchInTab.call(this, tabRegions, regionName, styleElementName);

                    if (resu) {
                        return resu;
                    }

                    styleName = searchInTab.call(this, tabRegions, regionName, 'style');
                    //search style reference in this specified region Element

                    if (styleName) {
                        //specified style has been detected
                        //browse attributes of this style to detect styleElementName attribute
                        resu = searchInTab.call(this, tabStyles, styleName, styleElementName);
                        if (resu) {
                            return resu;
                        }

                        //search if others styles are referenced in the selected one
                        styleName = searchInTab.call(this, tabStyles, styleName, 'style');

                        while (styleName) {
                            //search in this other style
                            resu = searchInTab.call(this, tabStyles, styleName, styleElementName);
                            if (resu) {
                                return resu;
                            }
                            styleName = searchInTab.call(this, tabStyles, styleName, 'style');
                        }
                    }
                }
            }

            return defaultTTMLValue !== undefined ? defaultTTMLValue : null;
        },

        searchInTab = function(tab, elementNameReference, styleElementName) {
            var i = 0,
                returnValue = null,
                j = 0;

            for (i = 0; i < tab[elementNameReference].length; i += 1) {
                //search with style nameSpaces
                for (j = 0; j < globalPrefStyleNameSpace.length; j += 1) {
                    returnValue = tab[elementNameReference].getNamedItem(styleElementName);
                    if (!returnValue) {
                        returnValue = tab[elementNameReference].getNamedItemNS(globalPrefStyleNameSpace[j], styleElementName);
                    }
                    if (returnValue) {
                        return returnValue.nodeValue;
                    }
                }
                //search with main nameSpaces
                for (j = 0; j < globalPrefTTNameSpace.length; j += 1) {
                    returnValue = tab[elementNameReference].getNamedItem(styleElementName);
                    if (!returnValue) {
                        returnValue = tab[elementNameReference].getNamedItemNS(globalPrefTTNameSpace[j], styleElementName);
                    }
                    if (returnValue) {
                        return returnValue.nodeValue;
                    }
                }
            }

            return null;
        },

        findParameterElement = function(nodeTab, nameSpaceTab, parameterElementName) {
            var parameterValue = null,
                i = 0,
                k = 0;
            //search for each node in the noteTab, if the parameterElementName is defined
            for (i = 0; i < nodeTab.length; i += 1) {
                for (k = 0; k < nameSpaceTab.length; k += 1) {
                    parameterValue = this.domParser.getAttributeValue(nodeTab[i], parameterElementName, nameSpaceTab[k]);
                    if (parameterValue) {
                        return parameterValue;
                    }
                }
            }

            return parameterValue;
        },

        computeCellResolution = function(cellResolution) {
            if (!cellResolution) {
                //default cell resolution defined in TTML documentation
                cellResolution = '32 15';
            }

            var computedCellResolution = cellResolution,
                i = 0;

            computedCellResolution = computedCellResolution.split(' ');

            for (i = 0; i < computedCellResolution.length; i += 1) {
                computedCellResolution[i] = parseFloat(computedCellResolution[i]);
            }

            return computedCellResolution;
        },

        getStyle = function(nodeElementsTab, rootExtent){
            var cssStyle = {
                    backgroundColor: null,
                    color: null,
                    fontSize: null,
                    fontFamily: null,
                    fontStyle: null,
                    textOutline: {
                        color: null,
                        with: null
                    },
                    textAlign: null,
                    displayAlign: null,
                    origin: null,
                    extent: null,
                    cellResolution: null,
                    rootExtent: rootExtent,
                    showBackground: null
                };

            cssStyle.backgroundColor = findStyleElement.call(this, nodeElementsTab, 'backgroundColor', 'transparent');
            cssStyle.color = findStyleElement.call(this, nodeElementsTab, 'color');
            cssStyle.fontSize = findStyleElement.call(this, nodeElementsTab, 'fontSize');
            cssStyle.fontFamily = findStyleElement.call(this, nodeElementsTab, 'fontFamily');
            cssStyle.fontStyle = findStyleElement.call(this, nodeElementsTab, 'fontStyle', 'normal');
            cssStyle.textOutline = findStyleElement.call(this, nodeElementsTab, 'textOutline');
            cssStyle.extent = findStyleElement.call(this, nodeElementsTab, 'extent');
            cssStyle.origin = findStyleElement.call(this, nodeElementsTab, 'origin');
            cssStyle.textAlign = findStyleElement.call(this, nodeElementsTab, 'textAlign', 'start');
            cssStyle.displayAlign = findStyleElement.call(this, nodeElementsTab, 'displayAlign', 'before');
            cssStyle.showBackground = findStyleElement.call(this, nodeElementsTab, 'showBackground');
            cssStyle.cellResolution = findParameterElement.call(this, nodeElementsTab, globalPrefParameterNameSpace, 'cellResolution');
            cssStyle.cellResolution = computeCellResolution(cssStyle.cellResolution);

            return cssStyle;
        },

        internalParse = function(data) {
            var captionArray = [],
                errorMsg,
                regions,
                region,
                previousStartTime = null,
                previousEndTime = null,
                startTime,
                endTime,
                cssStyle = null,
                caption,
                divBody,
                i,
                textDatas,
                j,
                k,
                rootExtent,
                textNodes,
                textValue = "",
                imageRef,
                ttmlRenderingType = "",
                lastCaption;

            try {

                if (this.videoModel.getTTMLRenderingDiv() !== null) {
                    ttmlRenderingType = 'html';
                }

                xmlDoc = this.domParser.createXmlTree(data);

                if (!passStructuralConstraints.call(this)) {
                    errorMsg = "TTML document has incorrect structure";
                    return Q.reject(errorMsg);
                }

                for (i = 0; i < globalPrefParameterNameSpace.length; i += 1) {
                    frameRate = this.domParser.getAttributeValue(nodeTt, 'frameRate', globalPrefParameterNameSpace[i]) ? parseInt(frameRate, 10) : null;
                }

                divBody = this.domParser.getChildNodes(nodeBody, 'div');

                if (!divBody || divBody.length === 0) {
                    errorMsg = "TTML body document does not contain any div";
                    return Q.reject(errorMsg);
                }

                //get all styles informations
                tabStyles = this.domParser.getAllSpecificNodes(nodeTt, 'style');
                //get all regions informations
                tabRegions = this.domParser.getAllSpecificNodes(nodeTt, 'region');
                //get all images url
                tabImages = this.domParser.getAllSpecificNodes(nodeTt, 'image');
                //search if there is a root container size
                rootExtent = findStyleElement.call(this, [nodeTt], 'extent');

                //browse all the different div elements
                for (k = 0; k < divBody.length; k += 1) {
                    //is it images subtitles?
                    imageRef = findParameterElement.call(this, [divBody[k]], globalPrefSMPTENameSpace, 'backgroundImage');
                    if (imageRef && tabImages[imageRef.substring(1)] !== undefined) {

                        startTime = parseTimings(findParameterElement.call(this, [divBody[k]], globalPrefTTNameSpace, 'begin'));
                        endTime = parseTimings(findParameterElement.call(this, [divBody[k]], globalPrefTTNameSpace, 'end'));
                        
                        cssStyle = getStyle.call(this, [divBody[k], nodeTt], rootExtent);
                       
                        caption = {
                            start: startTime,
                            end: endTime,
                            data: 'data:image/' + tabImages[imageRef.substring(1)].imagetype.nodeValue + ';base64, ' + this.domParser.getChildNode(tabImages[imageRef.substring(1)], '#text').nodeValue,
                            type: 'image',
                            line: 80,
                            style: cssStyle
                        };
                        captionArray.push(caption);
                    }
                    regions = this.domParser.getChildNodes(divBody[k], 'p');

                    if (!regions || regions.length === 0) {
                        errorMsg = "TTML document does not contain any cues";
                    } else {
                        for (i = 0; i < regions.length; i += 1) {
                            caption = null;
                            cssStyle = null;
                            region = regions[i];

                            startTime = parseTimings(findParameterElement.call(this, [region], globalPrefTTNameSpace, 'begin'));
                            endTime = parseTimings(findParameterElement.call(this, [region], globalPrefTTNameSpace, 'end'));

                            if (isNaN(startTime) || isNaN(endTime) || (endTime < startTime)) {
                                errorMsg = "TTML document has incorrect timing value";
                            } else {
                                 //is it images subtitles?
                                imageRef = findParameterElement.call(this, [region], globalPrefSMPTENameSpace, 'backgroundImage');
                                if (imageRef && tabImages[imageRef.substring(1)] !== undefined) {
                                    cssStyle = getStyle.call(this, [region, divBody[k], nodeTt], rootExtent);
                                    caption = {
                                        start: startTime,
                                        end: endTime,
                                        data: 'data:image/' + tabImages[imageRef.substring(1)].imagetype.nodeValue + ';base64, ' + this.domParser.getChildNode(tabImages[imageRef.substring(1)], '#text').nodeValue,
                                        type: 'image',
                                        line: 80,
                                        style: cssStyle
                                    };
                                }

                                textDatas = this.domParser.getChildNodes(region, 'span');
                                //subtitles are set in span
                                if (textDatas.length > 0) {
                                    for (j = 0; j < textDatas.length; j++) {
                                        if (j > 0) {
                                            textValue += '\n';
                                        }
                                        /******************** Find style informations ***************************************
                                         *   1- in subtitle paragraph ToDo
                                         *   2- in style element referenced in the subtitle paragraph
                                         *   3- in region ToDo
                                         *   4- in style referenced in the region referenced in the subtitle paragraph
                                         *   5- in the main div ToDo
                                         *   6- in the style of the main div
                                         **************************************************************************************/
                                        //search style informations once. 
                                        if (j === 0) {
                                            cssStyle = getStyle.call(this, [textDatas[j], region, nodeBody, nodeTt, divBody[k]], rootExtent);
                                        }

                                        textNodes = this.domParser.getTextNodesIn(textDatas[j]);

                                        for (var r = 0; r < textNodes.length; r += 1) {
                                            if (r > 0) {
                                                textValue += '\n';
                                            }
                                            textValue += textNodes[r].textContent;
                                        }
                                    }
                                    //line and position element have no effect on IE
                                    //For Chrome line = 80 is a percentage workaround to reorder subtitles
                                    caption = {
                                        start: startTime,
                                        end: endTime,
                                        data: textValue,
                                        type: 'text',
                                        line: 80,
                                        style: cssStyle
                                    };
                                    textValue = "";
                                    captionArray.push(caption);
                                } else {
                                    cssStyle = getStyle.call(this, [region, nodeBody, nodeTt], rootExtent);

                                    //line and position element have no effect on IE
                                    //For Chrome line = 80 is a percentage workaround to reorder subtitles
                                    //try to detect multi lines subtitle
                                    if (i > 0) {
                                        previousStartTime = parseTimings(findParameterElement.call(this, [regions[i - 1]], globalPrefTTNameSpace, 'begin'));
                                        previousEndTime = parseTimings(findParameterElement.call(this, [regions[i - 1]], globalPrefTTNameSpace, 'end'));
                                    }
                                    //workaround to be able to show subtitles on two lines even if startTime and endTime are not equals to the previous values.
                                    if ((startTime === previousStartTime && endTime === previousEndTime) || (startTime >= previousStartTime && endTime <= previousEndTime)) {
                                        if (region.textContent !== "") {
                                            //if rendering is done in an internal div, do not add subtitle text with the same time.
                                            if (ttmlRenderingType === 'html') {
                                                caption = {
                                                    start: startTime,
                                                    end: endTime,
                                                    data: region.textContent,
                                                    type: 'text',
                                                    line: 80,
                                                    style: cssStyle
                                                };
                                            } else {
                                                if (startTime >= previousStartTime && endTime <= previousEndTime) {
                                                    lastCaption = captionArray[captionArray.length - 1];
                                                    lastCaption.end = startTime;
                                                } else {
                                                    lastCaption = captionArray.pop();
                                                }
                                                caption = {
                                                    start: startTime,
                                                    end: endTime,
                                                    data: lastCaption.data + '\n' + region.textContent,
                                                    type: 'text',
                                                    line: 80,
                                                    style: cssStyle
                                                };
                                            }
                                        }
                                    } else {

                                        textNodes = this.domParser.getTextNodesIn(region);

                                        for (j = 0; j < textNodes.length; j += 1) {
                                            if (j > 0) {
                                                textValue += '\n';
                                            }
                                            textValue += textNodes[j].textContent;
                                        }
                                        if (textValue !== "") {
                                            caption = {
                                                start: startTime,
                                                end: endTime,
                                                data: textValue,
                                                type: 'text',
                                                line: 80,
                                                style: cssStyle
                                            };
                                            textValue = "";
                                        }
                                    }
                                    if (caption !== null) {
                                        captionArray.push(caption);
                                    }
                                }
                            }
                        }
                    }
                }
                if (captionArray.length > 0) {
                    return Q.when(captionArray);
                } else {
                    return Q.reject(errorMsg);
                }

            } catch (err) {
                errorMsg = err.message;
                return Q.reject(errorMsg);
            }
        };

    return {
        domParser: undefined,
        videoModel: undefined,
        parse: internalParse

    };
};
/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Akamai Technologies
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Akamai Technologies nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.utils.TTMLRenderer = function() {
    "use strict";
    var ttmlDiv,
        subtitleDivTab = [],

        onFullScreenChange = function() {
            var i = 0;

            for (i = 0; i < subtitleDivTab.length; i++) {
                applySubtitlesCSSStyle(subtitleDivTab[i], subtitleDivTab[i].ttmlStyle, ttmlDiv);
            }
        },

        onSeeking = function() {
            //used for FF, when the user wants to seek, cueExit is not always sent.
            this.cleanSubtitles();
        },

        createSubtitleDiv = function() {
            var subtitleDiv = document.createElement("div");

            subtitleDiv.style.position = 'absolute';
            subtitleDiv.style.display = 'flex';
            subtitleDiv.style.flexDirection = 'row';
            subtitleDiv.style.overflow = 'initial';
            subtitleDiv.style.pointerEvents = 'none';

            ttmlDiv.appendChild(subtitleDiv);

            return subtitleDiv;
        },

        removeSubtitleDiv = function(div) {
            if (ttmlDiv.hasChildNodes()) {
                ttmlDiv.removeChild(div);
            }
        },

        computeFontSize = function(fontSize, cellUnit) {
            var computedFontSize,
                i;
            if (fontSize && fontSize[fontSize.length - 1] === '%') {
                computedFontSize = parseFloat(fontSize.substr(0, fontSize.length - 1)) / 100 * cellUnit[1] + 'px';
            } else if (fontSize && fontSize[fontSize.length - 1] === 'x') {
                //case in pixels
                computedFontSize = fontSize;
            } else if (fontSize && fontSize[fontSize.length - 1] === 'c') {
                var cellsSize = fontSize.replace(/\s/g, '').split('c');

                for (i = 0; i < cellsSize.length; i += 1) {
                    cellsSize[i] = parseFloat(cellsSize[i]);
                }

                if (isNaN(cellsSize[1])) {
                    computedFontSize = cellsSize[0] * cellUnit[1] + 'px';
                } else {
                    computedFontSize = cellsSize[1] * cellUnit[1] + 'px';
                }
            } else { //default value defined in TTML
                computedFontSize = cellUnit[1] + 'px';
            }

            return computedFontSize;
        },

        computeTextOutline = function(textOutline, cellUnit, defaultColor) {
            var computedTextOutline = {
                    color: defaultColor,
                    width: null
                },
                formatTextOutlineWidth,
                textOutlineWidthIndex = 0;

            if (textOutline) {
                textOutline = textOutline.split(' ');

                //detect if outline color has been defined, if not, outline color should be set to color value
                if (textOutline[0] && isNaN(textOutline[0][0])) {
                    computedTextOutline.color = textOutline[0];
                    textOutlineWidthIndex = 1;
                } else {
                    computedTextOutline.color = defaultColor;
                }

                if (computedTextOutline.color && computedTextOutline.color[0] === '#') {
                    computedTextOutline.color = hex2rgba_convert(computedTextOutline.color);
                }

                //detect text outline width, the first length value
                if (textOutline[textOutlineWidthIndex]) {
                    //get the last character for text Outline width definition
                    formatTextOutlineWidth = textOutline[textOutlineWidthIndex][textOutline[textOutlineWidthIndex].length - 1];
                    switch (formatTextOutlineWidth) {
                        //definition in cell.
                        case 'c':
                            textOutline[textOutlineWidthIndex] = textOutline[textOutlineWidthIndex].split('c');
                            if (textOutline[textOutlineWidthIndex][0]) {
                                computedTextOutline.width = textOutline[textOutlineWidthIndex][0] * cellUnit[1] + 'px';
                            }
                            break;
                        case 'x':
                            //definition in pixel
                            computedTextOutline.width = textOutline[textOutlineWidthIndex];
                            break;
                    }
                }
            }
            return computedTextOutline;
        },

        hex2rgba_convert = function(hex) {
            hex = hex.replace('#', '');
            var r = parseInt(hex.substring(0, 2), 16),
                g = parseInt(hex.substring(2, 4), 16),
                b = parseInt(hex.substring(4, 6), 16),
                a = hex.length > 6 ? parseInt(hex.substring(6, 8), 16) : 255,
                result = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';

            return result;
        },

        rgbaTTMLToCss = function(rgbaTTML) {
            var rgba,
                resu = rgbaTTML,
                alpha;

            rgba = rgbaTTML.replace(/^(rgb|rgba)\(/,'').replace(/\)$/,'').replace(/\s/g,'').split(',');
            if (rgba[rgba.length - 1] > 1) {
                alpha = parseInt(rgba[rgba.length - 1], 10) / 255;
                resu = 'rgba('+rgba[0]+','+rgba[1]+','+rgba[2]+','+alpha+')';
            }
            return resu;
        },

        applySubtitlesCSSStyle = function(div, cssStyle, renderingDiv) {
            var origin,
                extent,
                textOutline,
                rootExtent,
                cellUnit = [renderingDiv.clientWidth / cssStyle.cellResolution[0], renderingDiv.clientHeight / cssStyle.cellResolution[1]];

            if (div) {
                if (cssStyle.backgroundColor && cssStyle.backgroundColor[0] === '#') {
                    cssStyle.backgroundColor = hex2rgba_convert(cssStyle.backgroundColor);
                }else if (cssStyle.backgroundColor && cssStyle.backgroundColor[3] === 'a') {//detect backgroundColor with an alpha
                    cssStyle.backgroundColor = rgbaTTMLToCss(cssStyle.backgroundColor);
                }

                if (cssStyle.color && cssStyle.color[0] === '#') {
                    cssStyle.color = hex2rgba_convert(cssStyle.color);
                }else if (cssStyle.color && cssStyle.color[3] === 'a') {//detect backgroundColor with an alpha
                    cssStyle.color = rgbaTTMLToCss(cssStyle.color);
                }

                if (cssStyle.origin && cssStyle.origin[cssStyle.origin.length - 1] === '%') {
                    origin = cssStyle.origin.split('%');
                    div.style.left = parseInt(origin[0], 10) + '%';
                    div.style.top = parseInt(origin[1], 10) + '%';
                    if (cssStyle.extent && cssStyle.extent[cssStyle.extent.length - 1] === '%') {
                        extent = cssStyle.extent.split('%');
                        div.style.width = parseInt(extent[0], 10) + '%';
                        div.style.height = parseInt(extent[1], 10) + '%';
                    }
                } else if (cssStyle.origin && cssStyle.origin[cssStyle.origin.length - 1] === 'x') {
                    origin = cssStyle.origin.split('px');
                    if (cssStyle.rootExtent && cssStyle.rootExtent[cssStyle.rootExtent.length - 1] === 'x') {
                        rootExtent = cssStyle.rootExtent.split('px');
                        var temp = (origin[0] / rootExtent[0]) * renderingDiv.clientWidth;
                        div.style.left = temp / renderingDiv.clientWidth * 100 + '%';
                        temp = (origin[1] / rootExtent[1]) * renderingDiv.clientHeight;
                        div.style.top = temp / renderingDiv.clientHeight * 100 + '%';
                        if (cssStyle.extent && cssStyle.extent[cssStyle.extent.length - 1] === 'x') {
                            extent = cssStyle.extent.split('px');
                            temp = (extent[0] / rootExtent[0]) * renderingDiv.clientWidth;
                            div.style.width = temp / renderingDiv.clientWidth * 100 + '%';
                            temp = (extent[1] / rootExtent[1]) * renderingDiv.clientHeight;
                            div.style.height = temp / renderingDiv.clientHeight * 100 + '%';
                        }
                    } else {
                        div.style.left = origin[0] + "px";
                        div.style.top = origin[1] + "px";
                    }
                }else if (cssStyle.origin && cssStyle.origin[cssStyle.origin.length - 1] === 'c') {
                    origin = cssStyle.origin.split('c');
                    div.style.left = (origin[0] * cellUnit[0]) + "px";
                    div.style.top = (origin[1] * cellUnit[1]) + "px";
                    if (cssStyle.extent && cssStyle.extent[cssStyle.extent.length - 1] === 'c') {
                        extent = cssStyle.extent.split('c');
                        div.style.width = (extent[0] * cellUnit[0]) + "px";
                        div.style.height = (extent[1] * cellUnit[1]) + "px";
                    }
                }

                textOutline = computeTextOutline(cssStyle.textOutline, cellUnit, cssStyle.color);
                div.style.webkitTextStrokeWidth = textOutline.width;
                div.style.webkitTextStroke = textOutline.color;
                switch (cssStyle.textAlign) {
                    //Values in TTML : left | center | right | start | end
                    //Values in css : left|right|center|justify|initial|inherit
                    case 'start':
                        div.style.justifyContent = 'flex-start';
                        break;
                    case 'end':
                        div.style.justifyContent = 'flex-end';
                        break;
                    case 'center':
                        div.style.justifyContent = 'center';
                        break;
                    case 'right':
                        div.style.justifyContent = 'flex-end';
                        break; 
                    case 'left':
                        div.style.justifyContent = 'flex-start';
                        break; 
                    default:
                        div.style.justifyContent = 'flex-start';
                }

                switch (cssStyle.displayAlign) {
                    //Values in TTML : before | center | after
                    //Values in css : flex-start| center | flex-end
                    case 'before':
                        div.style.alignItems = 'flex-start';
                        break;
                    case 'center':
                        div.style.alignItems = cssStyle.displayAlign;
                        break;
                    case 'after':
                        div.style.alignItems = 'flex-end';
                        break;                        
                    default:
                        div.style.alignItems = 'flex-start';
                }

                div.style.fontStyle = cssStyle.fontStyle;
                if (cssStyle.showBackground && cssStyle.showBackground === 'whenActive') {
                    div.style.backgroundColor = 'transparent';
                }else {
                    div.style.backgroundColor = cssStyle.backgroundColor;
                }
                div.style.color = cssStyle.color;
                div.style.fontSize = computeFontSize(cssStyle.fontSize, cellUnit);
                div.style.fontFamily = cssStyle.fontFamily;
            }
        };

    return {
        videoModel: undefined,

        initialize: function(renderingDiv) {
            ttmlDiv = renderingDiv;
            document.addEventListener('webkitfullscreenchange', onFullScreenChange.bind(this));
            document.addEventListener('mozfullscreenchange', onFullScreenChange.bind(this));
            document.addEventListener('fullscreenchange', onFullScreenChange.bind(this));
            this.videoModel.listen("seeking", onSeeking.bind(this));
        },

        cleanSubtitles: function() {
            var i = 0;

            for (i = 0; i < subtitleDivTab.length; i++) {
                removeSubtitleDiv(subtitleDivTab[i]);
            }
            subtitleDivTab = [];
        },

        onCueEnter: function(e) {
            var newDiv = createSubtitleDiv();

            if (e.currentTarget.style) {
                applySubtitlesCSSStyle(newDiv, e.currentTarget.style, ttmlDiv);
                newDiv.ttmlStyle = e.currentTarget.style;
            }

            if (e.currentTarget.type !== 'image') {
                var p = document.createElement('p');
                newDiv.appendChild(p);
                p.innerText = e.currentTarget.text;
                p.style.marginTop = 'auto';
                if (newDiv.ttmlStyle && newDiv.ttmlStyle.showBackground && newDiv.ttmlStyle.showBackground === 'whenActive') {
                    p.style.backgroundColor = e.currentTarget.style.backgroundColor;
                }
            } else {
                var img = new Image();
                img.style.height = 'auto';
                img.style.width = 'auto';
                img.src = e.currentTarget.text;
                newDiv.appendChild(img);
            }
            newDiv.data = e.currentTarget.text;
            subtitleDivTab.push(newDiv);
        },

        onCueExit: function(e) {
            var i = 0;

            for (i = 0; i < subtitleDivTab.length; i++) {
                if ((e.currentTarget.text === subtitleDivTab[i].data) && (subtitleDivTab[i].ttmlStyle === e.currentTarget.style)) {
                    break;
                }
            }
            removeSubtitleDiv(subtitleDivTab[i]);
            subtitleDivTab.splice(i, 1);
        }
    };
};
/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Akamai Technologies
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Akamai Technologies nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.utils.VTTParser = function () {
    "use strict";

    var REGEXP_TIMESTAMPMAP = /X-TIMESTAMP-MAP=(.+)/,
        REGEXP_ATTRIBUTES = /\s*(.+?)\s*:((?:\".*?\")|.*?)(?:,|$)/g,
        REGEXP_CUE = /(\S*)[\s]*-->[\s]*(\S*)(.*)/g,
        REGEXP_LINEBREAK = /(?:\r\n|\r|\n)/gm,

        parseTimestamp = function(stime) {
            var timeArray = stime.split(":"),
                len = timeArray.length,
                time = 0;

            for (var i = 0; i < len; i++) {
                time += parseFloat(timeArray[i], 10) * Math.pow(60, (len-i-1));
            }

            return time;
        },

        parseTimestampMap = function (data) {
            var match,
                attrs,
                name,
                value,
                local = null,
                mpegts = null;

            match = REGEXP_TIMESTAMPMAP.exec(data);

            if (!match) {
                return -1;
            }
            attrs = match[1];

            while ((match = REGEXP_ATTRIBUTES.exec(attrs)) !== null) {
                name = match[1];
                value = match[2];
                switch(name) {
                    case 'MPEGTS':
                        mpegts = parseInt(value, 10);
                        break;
                    case 'LOCAL':
                        local = parseTimestamp(value);
                }
            }

            if (local === null || mpegts === null) {
                return -1;
            }

            // var timestampMap = this.manifestModel.getValue().timestampMap;
            // if (!timestampMap) {
            //     return -1;
            // }

            // var time = timestampMap.local + ((mpegts - timestampMap.mpegts) / 90000.0);

            return {
                local: local,
                mpegts: mpegts
            };
        },

        getTimestampOffset = function (timestampMap, request) {

            if (timestampMap === -1) {
                return 0;
            }

            var streamTimestampMap = this.manifestModel.getValue().timestampMap;
            if (!streamTimestampMap) {
                // If MPEGTS timestamp mapping not yet set, then consider segment start time
                return timestampMap.local - request.startTime;
            }

            var mpegtsOffset = ((timestampMap.mpegts - streamTimestampMap.mpegts) / 90000.0);

            return (timestampMap.local - streamTimestampMap.local - mpegtsOffset);
        };

    return {
        manifestModel: undefined,

        parse: function (data, request) {
            var cues = [],
                cue = null,
                line,
                cueInfo,
                i;

            var offset = getTimestampOffset.call(this, parseTimestampMap(data), request);
            
            var lines = data.split(REGEXP_LINEBREAK);            

            for (i = 0; i < lines.length; i++) {
                line = lines[i].trim();
                if (line.length === 0) {
                    continue;
                }
                if (lines[i].match(REGEXP_CUE)) {
                    if (cue !== null) {
                        cues.push(cue);
                    }
                    // Start of new cue
                    cueInfo = lines[i].split(REGEXP_CUE);
                    cue = {
                        type: 'text',
                        line: 80,
                        start: parseTimestamp(cueInfo[1]) - offset,
                        end: parseTimestamp(cueInfo[2]) - offset,
                        // Do not set style, would need to be converted from VTT to TTML in case TTML renderer is used
                        //style: cueInfo[3].trim(),
                        data: ''
                    };
                } else if (cue !== null) {
                    cue.data += ((cue.data.length === 0) ? '' : '\n') + lines[i];
                }
            }
            if (cue !== null) {
                cues.push(cue);
            }

            return cues;
        }
    };
};

/**
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Dash Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  * Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  * Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.rules.AbandonRequestsRule = function() {
    "use strict";

    var GRACE_TIME_THRESHOLD = 0.5,
        ABANDON_MULTIPLIER = 2;

    return {
        debug: undefined,
        metricsExt:undefined,

        name: "AbandonRequestRule",

        execute: function(request, callback) {
            var now = new Date().getTime(),
                type = request.streamType,
                elapsedTime,
                measuredBandwidth,
                estimatedTimeOfDownload,
                switchRequest = new MediaPlayer.rules.SwitchRequest(MediaPlayer.rules.SwitchRequest.prototype.NO_CHANGE, MediaPlayer.rules.SwitchRequest.prototype.WEAK);

                if (request.firstByteDate === null || request.aborted) {
                    this.debug.log("[AbandonRequestsRule][" + type + "] Request has already been aborted.");
                    callback(switchRequest);
                    return;
                }

                elapsedTime = (now - request.firstByteDate.getTime()) / 1000;

                if (request.bytesLoaded < request.bytesTotal && elapsedTime >= (request.duration * GRACE_TIME_THRESHOLD)) {

                    measuredBandwidth = request.bytesLoaded / elapsedTime;
                    estimatedTimeOfDownload = request.bytesTotal / measuredBandwidth;

                    if ((estimatedTimeOfDownload) > (request.duration * ABANDON_MULTIPLIER)) {
                        switchRequest = new MediaPlayer.rules.SwitchRequest(0, MediaPlayer.rules.SwitchRequest.prototype.STRONG);
                        this.debug.info("[AbandonRequestsRule][" + type + "] BW = " + (measuredBandwidth * 8 / 1000).toFixed(3) + " kb/s => switch to lowest quality");
                    }
                }

            callback(switchRequest);
        },
    };
};

MediaPlayer.rules.AbandonRequestsRule.prototype = {
    constructor: MediaPlayer.rules.AbandonRequestsRule
};
/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Digital Primates
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.rules.BaseRulesCollection = function () {
    "use strict";

    var rules = [],
        adandonFragmentRules = [];

    return {
        downloadRatioRule: undefined,
        insufficientBufferRule: undefined,
        droppedFramesRule: undefined,
        abandonRequestRule:undefined,
 
        getRules: function (type) {
            switch (type) {
                case MediaPlayer.rules.BaseRulesCollection.prototype.QUALITY_SWITCH_RULES:
                    return rules;
                case MediaPlayer.rules.BaseRulesCollection.prototype.ABANDON_FRAGMENT_RULES:
                    return adandonFragmentRules;
                default:
                    return null;
            }
        },

        setup: function () {
            rules.push(this.downloadRatioRule);
            rules.push(this.insufficientBufferRule);
            rules.push(this.droppedFramesRule);
            adandonFragmentRules.push(this.abandonRequestRule);
        }
    };
};

MediaPlayer.rules.BaseRulesCollection.prototype = {
    constructor: MediaPlayer.rules.BaseRulesCollection,
    QUALITY_SWITCH_RULES: "qualitySwitchRules",
    ABANDON_FRAGMENT_RULES: "abandonFragmentRules"
};

/*
 * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.
 * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2014, Orange
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.rules.DownloadRatioRule = function() {
    "use strict";

    return {
        debug: undefined,
        manifestExt: undefined,
        metricsExt: undefined,
        manifestModel: undefined,
        config: undefined,

        name: "DownloadRatioRule",

        checkIndex: function(current, metrics, data) {
            var requests = this.metricsExt.getHttpRequests(metrics),
                lastRequest = null,
                downloadTime,
                totalTime,
                calculatedBandwidth,
                currentBandwidth,
                latencyInBandwidth,
                switchUpRatioSafetyFactor,
                currentRepresentation,
                count,
                bandwidths = [],
                i,
                q = MediaPlayer.rules.SwitchRequest.prototype.NO_CHANGE,
                totalBytesLength = 0,
                p = MediaPlayer.rules.SwitchRequest.prototype.DEFAULT;

            if (data && data.hasOwnProperty('type')) {
                latencyInBandwidth = this.config.getParamFor(data.type, "ABR.latencyInBandwidth", "boolean", true);
                switchUpRatioSafetyFactor = this.config.getParamFor(data.type, "ABR.switchUpRatioSafetyFactor", "number", 1.5);
                //this.debug.log("Checking download ratio rule...");
                this.debug.log("[DownloadRatioRule][" + data.type + "] Checking download ratio rule... (current = " + current + ")");

                if (!metrics) {
                    this.debug.log("[DownloadRatioRule][" + data.type + "] No metrics, bailing.");
                    return new MediaPlayer.rules.SwitchRequest();
                }

                // Get last valid request
                i = requests.length - 1;
                while (i >= 0 && lastRequest === null) {
                    if (requests[i].tfinish && requests[i].trequest && requests[i].tresponse && requests[i].bytesLength > 0) {
                        lastRequest = requests[i];
                    }
                    i--;
                }

                if (lastRequest === null) {
                    this.debug.log("[DownloadRatioRule][" + data.type + "] No valid requests made for this stream yet, bailing.");
                    return new MediaPlayer.rules.SwitchRequest();
                }

                totalTime = (lastRequest.tfinish.getTime() - lastRequest.trequest.getTime()) / 1000;
                downloadTime = (lastRequest.tfinish.getTime() - lastRequest.tresponse.getTime()) / 1000;

                if (totalTime <= 0) {
                    this.debug.log("[DownloadRatioRule][" + data.type + "] Don't know how long the download of the last fragment took, bailing.");
                    return new MediaPlayer.rules.SwitchRequest();
                }

                if (lastRequest.mediaduration === null ||
                    lastRequest.mediaduration === undefined ||
                    lastRequest.mediaduration <= 0 ||
                    isNaN(lastRequest.mediaduration)) {
                    this.debug.log("[DownloadRatioRule][" + data.type + "] Don't know the duration of the last media fragment, bailing.");
                    return new MediaPlayer.rules.SwitchRequest();
                }

                totalBytesLength = lastRequest.bytesLength;

                this.debug.log("[DownloadRatioRule][" + data.type + "] DL: " + Number(downloadTime.toFixed(3)) + "s, Total: " + Number(totalTime.toFixed(3)) + "s, Length: " + totalBytesLength);

                // Take average bandwidth over 3 requests
                count = 1;
                while (i >= 0 && count < 3) {
                    if (requests[i].tfinish && requests[i].trequest && requests[i].tresponse && requests[i].bytesLength > 0) {
                        var _totalTime = (requests[i].tfinish.getTime() - requests[i].trequest.getTime()) / 1000;
                        var _downloadTime = (requests[i].tfinish.getTime() - requests[i].tresponse.getTime()) / 1000;
                        this.debug.log("[DownloadRatioRule][" + data.type + "] DL: " + Number(_downloadTime.toFixed(3)) + "s, Total: " + Number(_totalTime.toFixed(3)) + "s, Length: " + requests[i].bytesLength);
                        totalTime += _totalTime;
                        downloadTime += _downloadTime;
                        totalBytesLength += requests[i].bytesLength;
                        count += 1;
                    }
                    i--;
                }

                // Set length in bits
                totalBytesLength *= 8;

                calculatedBandwidth = latencyInBandwidth ? (totalBytesLength / totalTime) : (totalBytesLength / downloadTime);

                this.debug.log("[DownloadRatioRule][" + data.type + "] BW = " + Math.round(calculatedBandwidth / 1000) + " kb/s");

                if (isNaN(calculatedBandwidth)) {
                    return new MediaPlayer.rules.SwitchRequest();
                }

                count = this.manifestExt.getRepresentationCount(data);
                currentRepresentation = this.manifestExt.getRepresentationFor(current, data);
                currentBandwidth = this.manifestExt.getBandwidth(currentRepresentation);
                for (i = 0; i < count; i += 1) {
                    bandwidths.push(this.manifestExt.getRepresentationBandwidth(data, i));
                }
                if (calculatedBandwidth <= currentBandwidth) {
                    for (i = current - 1; i > 0; i -= 1) {
                        if (bandwidths[i] <= calculatedBandwidth) {
                            break;
                        }
                    }
                    q = i;
                    p = MediaPlayer.rules.SwitchRequest.prototype.WEAK;

                    this.debug.info("[DownloadRatioRule][" + data.type + "] SwitchRequest: q=" + q + "/" + (count - 1) + " (" + bandwidths[q] + "), p=" + p);
                    return new MediaPlayer.rules.SwitchRequest(q, p);
                } else {
                    for (i = count - 1; i > current; i -= 1) {
                        if (calculatedBandwidth > (bandwidths[i] * switchUpRatioSafetyFactor)) {
                            //this.debug.log("[DownloadRatioRule][" + data.type + "] bw = " + calculatedBandwidth + " results[i] * switchUpRatioSafetyFactor =" + (bandwidths[i] * switchUpRatioSafetyFactor) + " with i=" + i);
                            break;
                        }
                    }

                    q = i;
                    p = MediaPlayer.rules.SwitchRequest.prototype.STRONG;

                    this.debug.info("[DownloadRatioRule][" + data.type + "] SwitchRequest: q=" + q + "/" + (count - 1) + " (" + bandwidths[q] + "), p=" + p);
                    return new MediaPlayer.rules.SwitchRequest(q, p);
                }
            } else {
                return new MediaPlayer.rules.SwitchRequest();
            }
        }
    };
};

MediaPlayer.rules.DownloadRatioRule.prototype = {
    constructor: MediaPlayer.rules.DownloadRatioRule
};
/*
 * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.
 * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2014, Orange
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.rules.DroppedFramesRule = function() {
    "use strict";

    var MIN_ELAPSED_TIME = 1,
        lastPlaybackQuality = null,
        currentDroppedFrames = -1,
        currentTotalVideoFrames = -1,

        getDroppedFrames = function(playbackQuality) {
            var elapsedTime;

            if (lastPlaybackQuality === null) {
                lastPlaybackQuality = playbackQuality;
                return;
            }

            // Check sufficient elapsed media time to determine frame rate
            elapsedTime = playbackQuality.mt - lastPlaybackQuality.mt;
            if (elapsedTime < MIN_ELAPSED_TIME) {
                return;
            }

            currentDroppedFrames = playbackQuality.droppedFrames - lastPlaybackQuality.droppedFrames;
            currentTotalVideoFrames = playbackQuality.totalVideoFrames - lastPlaybackQuality.totalVideoFrames;

            lastPlaybackQuality = playbackQuality;
        };

    return {
        debug: undefined,
        metricsExt: undefined,
        manifestModel: undefined,
        config: undefined,

        name: "DroppedFramesRule",

        checkIndex: function(current, metrics, data, playerState) {
            var droppedFramesMaxRatio = this.config.getParamFor(data.type, "ABR.droppedFramesMaxRatio", "number", 0.30),
                droppedFramesMinRatio = this.config.getParamFor(data.type, "ABR.droppedFramesMinRatio", "number", 0.10),
                playbackQuality = this.metricsExt.getCurrentPlaybackQuality(metrics),
                q = MediaPlayer.rules.SwitchRequest.prototype.NO_CHANGE,
                p = MediaPlayer.rules.SwitchRequest.prototype.DEFAULT,
                ratio;

            if (data === null) {
                return new MediaPlayer.rules.SwitchRequest();
            }

            if (data.type !== "video") {
                return new MediaPlayer.rules.SwitchRequest();
            }

            if (playbackQuality === null) {
                // No PlaybackQuality metric => start of a new stream => reset lastPlaybackQuality
                lastPlaybackQuality = null;
                currentDroppedFrames = currentTotalVideoFrames = -1;
                return new MediaPlayer.rules.SwitchRequest();
            }

            // Check if we start buffering the stream. In this case we ignore the rule and reset lastPlaybackQuality
            if (playerState === 'buffering') {
                lastPlaybackQuality = null;
                currentDroppedFrames = currentTotalVideoFrames = -1;
                return new MediaPlayer.rules.SwitchRequest();
            }

            //this.debug.info("[DroppedFramesRule]["+data.type+"] PlaybackQuality = " + JSON.stringify(playbackQuality));

            // Determine number of dropped frames and fps
            getDroppedFrames(playbackQuality);

            if (currentDroppedFrames === -1) {
                return new MediaPlayer.rules.SwitchRequest();
            }

            ratio = currentDroppedFrames / currentTotalVideoFrames;

            this.debug.info("[DroppedFramesRule]["+data.type+"] DroppedFrames:" + currentDroppedFrames + ", totalVideoFrames:" + currentTotalVideoFrames + " => ratio = " + ratio);

            if (ratio > droppedFramesMaxRatio && current > 0) {
                // If too much dropped frames, then switch to lower representation
                q = current - 1;
                p = MediaPlayer.rules.SwitchRequest.prototype.STRONG;
            } else if (ratio > droppedFramesMinRatio) {
                // Still some dropped frames, then stay at current quality
                q = current;
                p = MediaPlayer.rules.SwitchRequest.prototype.STRONG;
            }

            this.debug.info("[DroppedFramesRule][" + data.type + "] SwitchRequest: q=" + q + ", p=" + p);

            return new MediaPlayer.rules.SwitchRequest(q, p);
        }
    };
};

MediaPlayer.rules.DroppedFramesRule.prototype = {
    constructor: MediaPlayer.rules.DroppedFramesRule
};
/*
 * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.
 * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2014, Orange
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.rules.InsufficientBufferRule = function() {
    "use strict";

    return {
        debug: undefined,
        manifestExt: undefined,
        metricsExt: undefined,
        manifestModel: undefined,
        config: undefined,
        isStartBuffering: {},

        name: "InsufficientBufferRule",

        checkIndex: function(current, metrics, data, playerState) {
            var bufferLevel = this.metricsExt.getCurrentBufferLevel(metrics),
                minBufferTime,
                switchLowerBufferRatio,
                switchLowerBufferTime,
                switchDownBufferRatio,
                switchDownBufferTime,
                switchUpBufferRatio,
                switchUpBufferTime,
                mpd,
                q = current,
                p = MediaPlayer.rules.SwitchRequest.prototype.DEFAULT;


            if (data === null) {
                return new MediaPlayer.rules.SwitchRequest();
            }

            // Check if we start buffering the stream. In this case we ignore the rule
            if (playerState === 'buffering') {
                this.isStartBuffering[data.type] = true;
            }

            if (bufferLevel === null) {
                return new MediaPlayer.rules.SwitchRequest();
            }

            this.debug.info("[InsufficientBufferRule][" + data.type + "] Checking buffer level ... (current = " + current +
                ", buffer level = " + (Math.round(bufferLevel.level * 100) / 100) +
                ", buffering = " + this.isStartBuffering[data.type] + ")");


            mpd = this.manifestExt.getMpd(this.manifestModel.getValue());
            if (mpd) {
                minBufferTime = this.config.getParamFor(data.type, "BufferController.minBufferTime", "number", mpd.manifest.minBufferTime);
                switchLowerBufferRatio = this.config.getParamFor(data.type, "ABR.switchLowerBufferRatio", "number", 0.25);
                switchLowerBufferTime = this.config.getParamFor(data.type, "ABR.switchLowerBufferTime", "number", switchLowerBufferRatio * minBufferTime);
                switchDownBufferRatio = this.config.getParamFor(data.type, "ABR.switchDownBufferRatio", "number", 0.5);
                switchDownBufferTime = this.config.getParamFor(data.type, "ABR.switchDownBufferTime", "number", switchDownBufferRatio * minBufferTime);
                switchUpBufferRatio = this.config.getParamFor(data.type, "ABR.switchUpBufferRatio", "number", 0.75);
                switchUpBufferTime = this.config.getParamFor(data.type, "ABR.switchUpBufferTime", "number", switchUpBufferRatio * minBufferTime);

                if ((bufferLevel.level < switchDownBufferTime) && (this.isStartBuffering[data.type])) {
                    return new MediaPlayer.rules.SwitchRequest();
                } else {
                    if (bufferLevel.level >= switchDownBufferTime) {
                        this.isStartBuffering[data.type] = false;
                    }

                    var max = this.manifestExt.getRepresentationCount(data);

                    max -= 1; // 0 based

                    if (bufferLevel.level <= switchLowerBufferTime) {
                        q = 0;
                        p = MediaPlayer.rules.SwitchRequest.prototype.STRONG;
                    } else if (bufferLevel.level <= switchDownBufferTime) {
                        q = (current > 0) ? (current - 1) : 0;
                        p = MediaPlayer.rules.SwitchRequest.prototype.DEFAULT;
                    }

                    this.debug.info("[InsufficientBufferRule][" + data.type + "] SwitchRequest: q=" + q + ", p=" + p);
                    return new MediaPlayer.rules.SwitchRequest(q, p);

                }
            } else {
                this.debug.log("[InsufficientBufferRule][" + data.type + "] Manifest not present yet");
                return new MediaPlayer.rules.SwitchRequest();
            }
        }
    };
};

MediaPlayer.rules.InsufficientBufferRule.prototype = {
    constructor: MediaPlayer.rules.OInsufficientBufferRule
};
/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 * 
 * Copyright (c) 2013, Digital Primates
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.rules.LimitSwitchesRule = function () {
    "use strict";

    /*
     * This rule is intended to limit the number of switches that can happen.
     * We might get into a situation where there quality is bouncing around a ton.
     * This can create an unpleasant experience, so let the stream settle down.
     */

    var MAX_SWITCHES = 10,
        VALIDATION_TIME = 20000,
        WAIT_COUNT = 5,
        waiting = 0;

    return {
        debug: undefined,

        name: "LimitSwitchesRule",

        checkIndex: function (current, metrics /*, data*/) {
            if (waiting > 0) {
                waiting -= 1;
                return new MediaPlayer.rules.SwitchRequest(current, MediaPlayer.rules.SwitchRequest.prototype.STRONG);
            }

            var self = this,
                panic = false,
                rs,
                now = new Date().getTime(),
                delay,
                i,
                numSwitches = metrics.RepSwitchList.length;

            //self.debug.log("Checking limit switches rule...");

            for (i = numSwitches - 1; i >= 0; i -= 1) {
                rs = metrics.RepSwitchList[i];
                delay = now - rs.t.getTime();

                if (delay >= VALIDATION_TIME) {
                    self.debug.log("Reached time limit, bailing.");
                    break;
                }

                if (i >= MAX_SWITCHES) {
                    self.debug.log("Found too many switches within validation time, force the stream to not change.");
                    panic = true;
                    break;
                }
            }

            if (panic) {
                self.debug.log("Wait some time before allowing another switch.");
                waiting = WAIT_COUNT;
                return new MediaPlayer.rules.SwitchRequest(current, MediaPlayer.rules.SwitchRequest.prototype.STRONG);
            } else {
                return new MediaPlayer.rules.SwitchRequest(MediaPlayer.rules.SwitchRequest.prototype.NO_CHANGE, MediaPlayer.rules.SwitchRequest.prototype.STRONG);
            }
        }
    };
};

MediaPlayer.rules.LimitSwitchesRule.prototype = {
    constructor: MediaPlayer.rules.LimitSwitchesRule
};
/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 * 
 * Copyright (c) 2013, Digital Primates
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.rules.SwitchRequest = function (q, p) {
    "use strict";
    this.quality = q;
    this.priority = p;

    if (this.quality === undefined) {
        this.quality = 999;
    }

    if (this.priority === undefined) {
        this.priority = 0.5;
    }
};

MediaPlayer.rules.SwitchRequest.prototype = {
    constructor: MediaPlayer.rules.SwitchRequest,
    NO_CHANGE: 999,
    DEFAULT: 0.5,
    STRONG: 1,
    WEAK: 0
};
/**
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Dash Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  * Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  * Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */


/**
 * Defines the public interface for all ProtectionModel implementations.
 *
 * ProtectionModel implementations provide access to particular versions
 * of the Encrypted Media Extensions (EME) APIs that have been implemented
 * in a user agent.  Developers wishing to add support for a new EME version
 * found in a target user-agent should add a new instance of this interface
 * to the
 *
 * Applications should not need direct access to this object.  All interactions with
 * the protection system should be performed with
 * {@link MediaPlayer.dependencies.ProtectionController}
 *
 * @interface MediaPlayer.models.ProtectionModel
 */

MediaPlayer.models.ProtectionModel = function() { };

/**
 * Returns an array of all initialization data currently used by
 * active sessions.
 *
 * @function
 * @name MediaPlayer.models.ProtectionModel#getAllInitData
 * @returns {ArrayBuffer[]} an array of initialization data buffers
 */

/**
 * Determine if the user-agent supports one of the given key systems and
 * content type configurations. Sends ENAME_KEY_SYSTEM_ACCESS_COMPLETE event
 * with a KeySystemAccess object as event data
 *
 * @function
 * @name MediaPlayer.models.ProtectionModel#requestKeySystemAccess
 * @param {Object[]} ksConfigurations array of desired key system
 * configurations in priority order (highest priority first)
 * @param {MediaPlayer.dependencies.protection.KeySystem} ksConfigurations.ks
 * the key system
 * @param {MediaPlayer.vo.protection.KeySystemConfiguration[]} ksConfigurations.configs
 * array of acceptable key system configurations
 * for this key system in priority order (highest priority first)
 */

/**
 * Selects the key system to use for all future operations on this
 * ProtectionModel.  Sends ENAME_KEY_SYSTEM_SELECTED with no data
 *
 * @function
 * @name MediaPlayer.models.ProtectionModel#selectKeySystem
 * @param keySystemAccess {MediaPlayer.vo.protection.KeySystemAccess} the key
 * system access token representing a supported key system
 */

/**
 * Associate this protection model with a HTMLMediaElement
 *
 * @function
 * @name MediaPlayer.models.ProtectionModel#setMediaElement
 * @param mediaElement {HTMLMediaElement} the media element to
 * which we should associate this protection model and all current
 * key sessions
 */

/**
 * Creates a new key session using the given initData and type. Sends
 * ENAME_KEY_SESSION_CREATED event with MediaPlayer.vo.protection.SessionToken
 * as data.
 *
 * @function
 * @name MediaPlayer.models.ProtectionModel#createKeySession
 * @param {ArrayBuffer} initData PSSH box for the currently selected
 * key system.
 * @param {string} sessionType the desired session type.  One of "temporary",
 * "persistent-license", "persistent-release-message".  CDM implementations
 * are not required to support anything except "temporary"
 */

/**
 * Update the given key session with a key (or any other message
 * intended for the CDM)
 *
 * @function
 * @name MediaPlayer.models.ProtectionModel#updateKeySession
 * @param {MediaPlayer.vo.protection.SessionToken} sessionToken the session
 * token
 * @param {ArrayBuffer} message the message that should be delivered to the CDM
 * for this session
 */

/**
 * Loads the persisted key session data associated with the given sessionID
 * into a new session.  Sends ENAME_KEY_SESSION_CREATED event with
 * {@MediaPlayer.vo.protection.SessionToken} as data.
 *
 * @function
 * @name MediaPlayer.models.ProtectionModel#loadKeySession
 * @param {string} sessionID the session ID corresponding to the persisted
 * session data to be loaded
 */

/**
 * Removes any persisted key session data associated with the given session.
 * Also closes the session.  Sends ENAME_KEY_SESSION_REMOVED and
 * ENAME_KEY_SESSION_CLOSED with sessionID as data
 *
 * @function
 * @name MediaPlayer.models.ProtectionModel#removeKeySession
 * @param {MediaPlayer.vo.protection.SessionToken} sessionToken the session
 * token
 */

/**
 * Close the given session and release all associated keys.  Following
 * this call, the sessionToken becomes invalid.  Sends ENAME_KEY_SESSION_CLOSED
 * with sessionID as data
 *
 * @function
 * @name MediaPlayer.models.ProtectionModel#closeKeySession
 * @param sessionToken the session token
 */

/**
 * Sets the certificate to be used by the CDM for encrypting messages
 *
 * @function
 * @name MediaPlayer.models.ProtectionModel#setServerCertificate
 * @param {ArrayBuffer} serverCertificate
 */

/**
 * Currently selected key system.  Will be null or undefined if no key
 * system has yet been selected
 *
 * @instance
 * @name keySystem
 * @memberof MediaPlayer.models.ProtectionModel
 * @readonly
 * @type MediaPlayer.dependencies.protection.KeySystem
 */


/**
 * Event IDs for events sent by ProtectionModel implementations. Use these
 * event names when subscribing or unsubscribing from ProtectionModel events.
 *
 * @enum {String}
 */
MediaPlayer.models.ProtectionModel.eventList = {
    /**
     * Event ID for needkey/encrypted events
     *
     * @constant
     */
    ENAME_NEED_KEY: "needkey",
    /**
     * Event ID for events delivered when a key system access procedure
     * has completed
     *
     * @constant
     */
    ENAME_KEY_SYSTEM_ACCESS_COMPLETE: "keySystemAccessComplete",
    /**
     * Event ID for events delivered when a key system selection procedure
     * completes
     *
     * @constant
     */
    ENAME_KEY_SYSTEM_SELECTED: "keySystemSelected",
    /**
     * Event ID for events delivered when a HTMLMediaElement has been
     * associated with the protection set
     *
     * @constant
     */
    ENAME_VIDEO_ELEMENT_SELECTED: "videoElementSelected",
    /**
     * Event ID for events delivered when a new server certificate has
     * been delivered to the CDM
     *
     * @constant
     */
    ENAME_SERVER_CERTIFICATE_UPDATED: "serverCertificateUpdated",
    /**
     * Event ID for events delivered when the protection set receives
     * a key message from the CDM
     *
     * @constant
     */
    ENAME_KEY_MESSAGE: "keyMessage",
    /**
     * Event ID for events delivered when a new key has been added
     *
     * @constant
     * @deprecated The latest versions of the EME specification no longer
     * use this event.  {@MediaPlayer.models.protectionModel.eventList.ENAME_KEY_STATUSES_CHANGED}
     * is preferred.
     */
    ENAME_KEY_ADDED: "keyAdded",
    /**
     * Event ID for events delivered when an error is encountered by the CDM
     * while processing a license server response message
     *
     * @constant
     */
    ENAME_KEY_ERROR: "keyError",
    /**
     * Event ID for events delivered when a new key sessions creation
     * process has completed
     *
     * @constant
     */
    ENAME_KEY_SESSION_CREATED: "keySessionCreated",
    /**
     * Event ID for events delivered when a key session removal
     * process has completed
     *
     * @constant
     */
    ENAME_KEY_SESSION_REMOVED: "keySessionRemoved",
    /**
     * Event ID for events delivered when a key session close
     * process has completed
     *
     * @constant
     */
    ENAME_KEY_SESSION_CLOSED: "keySessionClosed",
    /**
     * Event ID for events delivered when the status of one or more
     * decryption keys has changed
     *
     * @constant
     */
    ENAME_KEY_STATUSES_CHANGED: "keyStatusesChanged",
    /**
     * Event ID for events delivered when the process of shutting down
     * a protection set has completed
     *
     * @constant
     */
    ENAME_TEARDOWN_COMPLETE: "protectionTeardownComplete",
};

/**
 * needkey/encrypted event
 */

/**
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Dash Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  * Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  * Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.vo.Error = function (code, message, data) {
    "use strict";
    this.code = code || null;
    this.message = message || null;
    this.data = data || null;
};

MediaPlayer.vo.Error.prototype = {
    constructor: MediaPlayer.vo.Error
};
/**
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Dash Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  * Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  * Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.vo.Event = function () {
    "use strict";
    this.type = null; // event type/name. mandatory
    this.sender = null; // object that fires an event. mandatory
    this.data = null; // object that contains additional information about the event. optional
    this.error = null; // error object. optional
    this.timestamp = NaN; // timestamp. mandatory
};

MediaPlayer.vo.Event.prototype = {
    constructor: MediaPlayer.vo.Event
};
/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Digital Primates
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.models.MetricsList = function () {
    "use strict";

    return {
        TcpList: [],
        HttpList: [],
        RepSwitchList: [],
        BufferedSwitchList:[],
        BufferLevel: [],
        PlayList: [],
        State: [],
        DroppedFrames: [],
        PlaybackQuality: [],
        VideoResolution: [],
        DVRInfo: [],
        ManifestUpdate: []
    };
};

MediaPlayer.models.MetricsList.prototype = {
    constructor: MediaPlayer.models.MetricsList
};

/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 * 
 * Copyright (c) 2014, Orange
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.vo.Mp4Track = function () {
    "use strict";

    this.type = 'und';
    this.trackId = 0;
    this.timescale = 0;
    this.duration = 0;
    this.codecs = "";
    this.codecPrivateData = "";
    this.bandwidth = "";

    // Video related fields
    this.width = 0;
    this.height = 0;

    // Audio related fields
    this.language = 'und';
    this.channels = 0;
    this.samplingRate = 0;

    // Content protection
    this.contentProtection = undefined;

    // Samples description and data
    this.samples = [];
    this.data = null;
};

MediaPlayer.vo.Mp4Track.prototype = {
    constructor: MediaPlayer.vo.Mp4Track
};


MediaPlayer.vo.Mp4Track.Sample = function () {
    "use strict";

    this.dts = 0;
    this.cts = 0;
    this.duration = 0;
    this.flags = 0;
    this.data = null;
    this.size = 0;
};

MediaPlayer.vo.Mp4Track.Sample.prototype = {
    constructor: MediaPlayer.vo.Mp4Track.Sample
};


/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 * 
 * Copyright (c) 2013, Digital Primates
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.vo.SegmentRequest = function () {
    "use strict";
    this.action = "download";
    this.startTime = NaN;
    this.streamType = null;
    this.type = null;
    this.duration = NaN;
    this.timescale = NaN;
    this.range = null;
    this.url = null;
    this.requestStartDate = null;
    this.firstByteDate = null;
    this.requestEndDate = null;
    this.deferred = null;
    this.quality = NaN;
    this.index = NaN;
    this.availabilityStartTime = null;
    this.availabilityEndTime = null;
    this.wallStartTime = null;
};

MediaPlayer.vo.SegmentRequest.prototype = {
    constructor: MediaPlayer.vo.SegmentRequest,
    ACTION_DOWNLOAD: "download",
    ACTION_COMPLETE: "complete"
};
/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2014, Akamai Technologies
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.vo.URIFragmentData = function () {
    "use strict";
    this.t = null;
    this.xywh = null;
    this.track = null;
    this.id = null;
    this.s = null;
};

MediaPlayer.vo.URIFragmentData.prototype = {
    constructor: MediaPlayer.vo.URIFragmentData
};


/*
    From Spec http://www.w3.org/TR/media-frags/

    temporal (t)     - This dimension denotes a specific time range in the original media, such as "starting at second 10, continuing until second 20";
    spatial  (xywh)  - this dimension denotes a specific range of pixels in the original media, such as "a rectangle with size (100,100) with its top-left at coordinate (10,10)";
                       Media fragments support also addressing the media along two additional dimensions (in the advanced version defined in Media Fragments 1.0 URI (advanced)):
    track    (track) - this dimension denotes one or more tracks in the original media, such as "the english audio and the video track";
    id       (id)    - this dimension denotes a named temporal fragment within the original media, such as "chapter 2", and can be seen as a convenient way of specifying a temporal fragment.


    ## Note
    Akamai is purposing to add #s=X to the ISO standard.
        - (X) Value would be a start time to seek to at startup instead of starting at 0 or live edge
        - Allows for seeking back before the start time unlike a temporal clipping.
*/
/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 * 
 * Copyright (c) 2013, Digital Primates
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.vo.metrics.BufferedSwitch = function () {
    "use strict";

    this.mt = null;     // Media-Time | The media presentation time of the earliest access unit (out of all media content components) played out from the Representation.
    this.to = null;     // value of Representation@id identifying the switch-to Representation.
    this.lto = null;    // If not present, this metrics concerns the Representation as a whole. If present, lto indicates the value of SubRepresentation@level within Representation identifying the switch-to level of the Representation.
};

MediaPlayer.vo.metrics.BufferedSwitch.prototype = {
    constructor: MediaPlayer.vo.metrics.BufferedSwitch
};
/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 * 
 * Copyright (c) 2013, Digital Primates
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.vo.metrics.BufferLevel = function () {
    "use strict";

    this.t = null;      // Real-Time | Time of the measurement of the buffer level.
    this.level = null;  // Level of the buffer in milliseconds. Indicates the playout duration for which media data of all active media components is available starting from the current playout time.
};

MediaPlayer.vo.metrics.BufferLevel.prototype = {
    constructor: MediaPlayer.vo.metrics.BufferLevel
};
/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Orange
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.vo.metrics.Condition = function () {
    "use strict";

    this.isFullScreen = null;
    this.windowSize = null;
    this.droppedFrames = null;
    this.fps = null;
    this.bandwidth = null;
};

MediaPlayer.vo.metrics.Condition.prototype = {
    constructor: MediaPlayer.vo.metrics.Condition
};

/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 * 
 * Copyright (c) 2013, Digital Primates
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.vo.metrics.DroppedFrames = function () {
    "use strict";

    this.time = null;      // Real-Time | Time of the measurement of the dropped frames.
    this.droppedFrames = null;  // Number of dropped frames.
};

MediaPlayer.vo.metrics.DroppedFrames.prototype = {
    constructor: MediaPlayer.vo.metrics.DroppedFrames
};
/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2014, Akamai Technologies
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.vo.metrics.DVRInfo = function () {
    "use strict";

    this.time = null;   // Time of the measurement of the DVR info
    this.range = null;  // DVR range
};

MediaPlayer.vo.metrics.DVRInfo.prototype = {
    constructor: MediaPlayer.vo.metrics.DVRInfo
};
/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 * 
 * Copyright (c) 2013, Digital Primates
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.vo.metrics.HTTPRequest = function () {
    "use strict";

    this.stream = null;         // type of stream ("audio" | "video" etc..)
    this.tcpid = null;          // Identifier of the TCP connection on which the HTTP request was sent.
    this.type = null;           // This is an optional parameter and should not be included in HTTP request/response transactions for progressive download.
                                    // The type of the request:
                                    // - MPD
                                    // - XLink expansion
                                    // - Initialization Segment
                                    // - Index Segment
                                    // - Media Segment
                                    // - Bitstream Switching Segment
                                    // - other
    this.url = null;            // The original URL (before any redirects or failures)
    this.actualurl = null;      // The actual URL requested, if different from above
    this.range = null;          // The contents of the byte-range-spec part of the HTTP Range header.
    this.trequest = null;       // Real-Time | The real time at which the request was sent.
    this.tresponse = null;      // Real-Time | The real time at which the first byte of the response was received.
    this.tfinish = null;        // Real-Time | The real time at which the request finshed.
    this.responsecode = null;   // The HTTP response code.
    this.interval = null;       // The duration of the throughput trace intervals (ms), for successful requests only.
    this.mediaduration = null;  // The duration of the media requests, if available, in milliseconds.
    this.trace = [];            // Throughput traces, for successful requests only.
    this.startTime = null;      // the media start time of the segment
    this.quality = null;        // the quality index of the segment
    this.bytesLength = null;    // the segment bytes length
};

MediaPlayer.vo.metrics.HTTPRequest.prototype = {
    constructor: MediaPlayer.vo.metrics.HTTPRequest
};

MediaPlayer.vo.metrics.HTTPRequest.Trace = function () {
    "use strict";

    /*
     * s - Real-Time | Measurement period start.
     * d - Measurement period duration (ms).
     * b - List of integers counting the bytes received in each trace interval within the measurement period.
     */
    this.s = null;
    this.d = null;
    this.b = [];
};

MediaPlayer.vo.metrics.HTTPRequest.Trace.prototype = {
    constructor : MediaPlayer.vo.metrics.HTTPRequest.Trace
};

MediaPlayer.vo.metrics.ManifestUpdate = function () {
    "use strict";

    this.streamType = null;
    this.type = null;                       // static|dynamic
    this.requestTime = null;                // when this manifest update was requested
    this.fetchTime = null;                  // when this manifest update was received
    this.availabilityStartTime = null;
    this.presentationStartTime = 0;      // the seek point (liveEdge for dynamic, Period[0].startTime for static)
    this.clientTimeOffset = 0;           // the calculated difference between the server and client wall clock time
    this.currentTime = null;                // actual element.currentTime
    this.buffered = null;                   // actual element.ranges
    this.latency = 0;                       // (static is fixed value of zero. dynamic should be ((Now-@availabilityStartTime) - elementCurrentTime)
    this.periodInfo = [];
    this.representationInfo = [];
};

MediaPlayer.vo.metrics.ManifestUpdate.PeriodInfo = function () {
    "use strict";

    this.id = null;         // Period@id
    this.index = null;
    this.start = null;      // Period@start
    this.duration = null;   // Period@duration
};

MediaPlayer.vo.metrics.ManifestUpdate.RepresentationInfo = function () {
    "use strict";

    this.id = null;                         // Representation@id
    this.index = null;
    this.streamType = null;
    this.periodIndex = null;
    this.presentationTimeOffset = null;     // @presentationTimeOffset
    this.startNumber = null;                // @startNumber
    this.segmentInfoType = null;            // list|template|timeline
};

MediaPlayer.vo.metrics.ManifestUpdate.prototype = {
    constructor: MediaPlayer.vo.metrics.ManifestUpdate
};

MediaPlayer.vo.metrics.ManifestUpdate.PeriodInfo.prototype = {
    constructor: MediaPlayer.vo.metrics.ManifestUpdate.PeriodInfo
};

MediaPlayer.vo.metrics.ManifestUpdate.RepresentationInfo.prototype = {
    constructor: MediaPlayer.vo.metrics.ManifestUpdate.RepresentationInfo
};
/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 * 
 * Copyright (c) 2013, Digital Primates
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.vo.metrics.PlaybackQuality = function () {
    "use strict";

    this.t = null;                  // Real-Time | Time of the measurement of the playback quality
    this.mt = null;                 // Media-Time | Media presentation time of the measurement of the playback quality
    this.droppedFrames = null;      // Number of dropped frames
    this.totalVideoFrames = null;   // Number of decoded video frames
};

MediaPlayer.vo.metrics.PlaybackQuality.prototype = {
    constructor: MediaPlayer.vo.metrics.PlaybackQuality
};
/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 * 
 * Copyright (c) 2013, Digital Primates
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.vo.metrics.PlayList = function () {
    "use strict";

    this.stream = null;     // type of stream ("audio" | "video" etc..)
    this.start = null;      // Real-Time | Timestamp of the user action that starts the playback period...
    this.mstart = null;     // Media-Time | Presentation time at which playout was requested by the user...
    this.starttype = null;  // Type of user action which triggered playout
                            //      - New playout request (e.g. initial playout or seeking)
                            //      - Resume from pause
                            //        - Other user request (e.g. user-requested quality change)
                            //        - Start of a metrics collection period (hence earlier entries in the play list not collected)
    this.trace = [];        // List of periods of continuous rendering of decoded samples.
};

MediaPlayer.vo.metrics.PlayList.Trace = function () {
    "use strict";

    /*
     * representationid - The value of the Representation@id of the Representation from which the samples were taken.
     * subreplevel      - If not present, this metrics concerns the Representation as a whole. If present, subreplevel indicates the greatest value of any Subrepresentation@level being rendered.
     * start            - Real-Time | The time at which the first sample was rendered.
     * mstart           - Media-Time | The presentation time of the first sample rendered.
     * duration         - The duration of the continuously presented samples (which is the same in real time and media time). ―Continuously presented‖ means that the media clock continued to advance at the playout speed throughout the interval.
     * playbackspeed    - The playback speed relative to normal playback speed (i.e.normal forward playback speed is 1.0).
     * stopreason       - The reason why continuous presentation of this Representation was stopped.
     *                    Either:
     *                    representation switch
     *                    rebuffering
     *                    user request
     *                    end of Period
     *                    end of content
     *                    end of a metrics collection period
     */
    this.representationid = null;
    this.subreplevel = null;
    this.start = null;
    this.mstart = null;
    this.duration = null;
    this.playbackspeed = null;
    this.stopreason = null;
};

MediaPlayer.vo.metrics.PlayList.prototype = {
    constructor: MediaPlayer.vo.metrics.PlayList
};

/* Public Static Constants */
MediaPlayer.vo.metrics.PlayList.INITIAL_PLAY_START_REASON = "initial_start";
MediaPlayer.vo.metrics.PlayList.SEEK_START_REASON = "seek";

MediaPlayer.vo.metrics.PlayList.Trace.prototype = {
    constructor: MediaPlayer.vo.metrics.PlayList.Trace()
};

/* Public Static Constants */
MediaPlayer.vo.metrics.PlayList.Trace.USER_REQUEST_STOP_REASON = "user_request";
MediaPlayer.vo.metrics.PlayList.Trace.REPRESENTATION_SWITCH_STOP_REASON = "representation_switch";
MediaPlayer.vo.metrics.PlayList.Trace.END_OF_CONTENT_STOP_REASON = "end_of_content";
MediaPlayer.vo.metrics.PlayList.Trace.REBUFFERING_REASON = "rebuffering";
/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 * 
 * Copyright (c) 2013, Digital Primates
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.vo.metrics.RepresentationSwitch = function () {
    "use strict";

    this.t = null;      // Real-Time | Time of the switch event.
    this.mt = null;     // Media-Time | The media presentation time of the earliest access unit (out of all media content components) played out from the Representation.
    this.to = null;     // value of Representation@id identifying the switch-to Representation.
    this.lto = null;    // If not present, this metrics concerns the Representation as a whole. If present, lto indicates the value of SubRepresentation@level within Representation identifying the switch-to level of the Representation.
};

MediaPlayer.vo.metrics.RepresentationSwitch.prototype = {
    constructor: MediaPlayer.vo.metrics.RepresentationSwitch
};
/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Orange
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.vo.metrics.Session = function () {
    "use strict";

    this.uri = null;
    this.loopMode = null;
    this.endTime = null;
    this.playerType = null;
};

MediaPlayer.vo.metrics.Session.prototype = {
    constructor: MediaPlayer.vo.metrics.Session
};

/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Orange
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.vo.metrics.State = function () {
    "use strict";

    this.t = null;      // Real-Time | Time of the event.
    this.current = null;    // current state
    this.position = null;    // position in the stream
    this.reason = null;
};

MediaPlayer.vo.metrics.State.prototype = {
    constructor: MediaPlayer.vo.metrics.State
};

/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 * 
 * Copyright (c) 2013, Digital Primates
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.vo.metrics.TCPConnection = function () {
    "use strict";

    this.tcpid = null;      // Identifier of the TCP connection on which the HTTP request was sent.
    this.dest = null;       // IP Address of the interface over which the client is receiving the TCP data.
    this.topen = null;      // Real-Time | The time at which the connection was opened (sending time of the initial SYN or connect socket operation).
    this.tclose = null;     // Real-Time | The time at which the connection was closed (sending or reception time of FIN or RST or close socket operation).
    this.tconnect = null;   // Connect time in ms (time from sending the initial SYN to receiving the ACK or completion of the connect socket operation).
};

MediaPlayer.vo.metrics.TCPConnection.prototype = {
    constructor: MediaPlayer.vo.metrics.TCPConnection
};
/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Orange
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.vo.metrics.VideoResolution = function () {
    "use strict";

    this.t = null;      // Real-Time | Time of the event.
    this.mt = null;     // Media-Time | Media presentation time of the measurement of the video resolution
    this.width = null;  // video width
    this.height = null; // video height
};

MediaPlayer.vo.metrics.VideoResolution.prototype = {
    constructor: MediaPlayer.vo.metrics.VideoResolution
};

/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 * 
 * Copyright (c) 2013, Digital Primates
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*jshint -W020 */
Dash = (function () {
    "use strict";

    return {
        modules: {},
        dependencies: {},
        vo: {},
        di: {}
    };
}());
/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 * 
 * Copyright (c) 2013, Digital Primates
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
Dash.dependencies.BaseURLExtensions = function () {
    "use strict";

        // From YouTube player.  Reformatted for JSLint.
    var parseSIDX = function (ab, ab_first_byte_offset) {
            var d = new DataView(ab),
                sidx = {},
                pos = 0,
                offset,
                time,
                sidxEnd,
                i,
                ref_type,
                ref_size,
                ref_dur,
                type,
                size,
                charCode;

            while (type !== "sidx" && pos < d.byteLength) {
                size = d.getUint32(pos); // subtract 8 for including the size and type
                pos += 4;

                type = "";
                for (i = 0; i < 4; i += 1) {
                    charCode = d.getInt8(pos);
                    type += String.fromCharCode(charCode);
                    pos += 1;
                }

                if (type !== "moof" && type !== "traf" && type !== "sidx") {
                    pos += size - 8;
                } else if (type === "sidx") {
                    // reset the position to the beginning of the box...
                    // if we do not reset the position, the evaluation
                    // of sidxEnd to ab.byteLength will fail.
                    pos -= 8;
                }
            }

            sidxEnd = d.getUint32(pos, false) + pos;
            if (sidxEnd > ab.byteLength) {
                throw "sidx terminates after array buffer";
            }

            sidx.version = d.getUint8(pos + 8);
            pos += 12;

            // skipped reference_ID(32)
            sidx.timescale = d.getUint32(pos + 4, false);
            pos += 8;

            if (sidx.version === 0) {
                sidx.earliest_presentation_time = d.getUint32(pos, false);
                sidx.first_offset = d.getUint32(pos + 4, false);
                pos += 8;
            } else {
                // TODO(strobe): Overflow checks
                sidx.earliest_presentation_time = utils.Math.to64BitNumber(d.getUint32(pos + 4, false), d.getUint32(pos, false));
                //first_offset = utils.Math.to64BitNumber(d.getUint32(pos + 8, false), d.getUint32(pos + 12, false));
                sidx.first_offset = (d.getUint32(pos + 8, false) << 32) + d.getUint32(pos + 12, false);
                pos += 16;
            }

            sidx.first_offset += sidxEnd + (ab_first_byte_offset || 0);

            // skipped reserved(16)
            sidx.reference_count = d.getUint16(pos + 2, false);
            pos += 4;

            sidx.references = [];
            offset = sidx.first_offset;
            time = sidx.earliest_presentation_time;

            for (i = 0; i < sidx.reference_count; i += 1) {
                ref_size = d.getUint32(pos, false);
                ref_type = (ref_size >>> 31);
                ref_size = ref_size & 0x7fffffff;
                ref_dur = d.getUint32(pos + 4, false);
                pos += 12;
                if (ref_size > 0) {
                    sidx.references.push({
                        'size': ref_size,
                        'type': ref_type,
                        'offset': offset,
                        'duration': ref_dur,
                        'time': time,
                        'timescale': sidx.timescale
                    });
                }
                offset += ref_size;
                time += ref_dur;
            }

            if (pos !== sidxEnd) {
                throw "Error: final pos " + pos + " differs from SIDX end " + sidxEnd;
            }

            return sidx;
        },

        parseSegments = function (data, media, offset) {
            var parsed,
                ref,
                segments,
                segment,
                i,
                len,
                start,
                end;

            parsed = parseSIDX.call(this, data, offset);
            ref = parsed.references;
            segments = [];

            for (i = 0, len = ref.length; i < len; i += 1) {
                segment = new Dash.vo.Segment();
                segment.duration = ref[i].duration;
                segment.media = media;
                segment.startTime = ref[i].time;
                segment.timescale = ref[i].timescale;

                start = ref[i].offset;
                end = ref[i].offset + ref[i].size - 1;
                segment.mediaRange = start + "-" + end;

                segments.push(segment);
            }

            this.debug.log("Parsed SIDX box: " + segments.length + " segments.");
            return segments;
        },

        findInit = function (data, info) {
            var deferred = Q.defer(),
                ftyp,
                moov,
                start,
                end,
                d = new DataView(data),
                pos = 0,
                type = "",
                size = 0,
                bytesAvailable,
                i,
                c,
                request,
                loaded = false,
                irange,
                self = this;

            self.debug.log("Searching for initialization.");

            while (type !== "moov" && pos < d.byteLength) {
                size = d.getUint32(pos); // subtract 8 for including the size and type
                pos += 4;

                type = "";
                for (i = 0; i < 4; i += 1) {
                    c = d.getInt8(pos);
                    type += String.fromCharCode(c);
                    pos += 1;
                }

                if (type === "ftyp") {
                    ftyp = pos - 8;
                }
                if (type === "moov") {
                    moov = pos - 8;
                }
                if (type !== "moov") {
                    pos += size - 8;
                }
            }

            bytesAvailable = d.byteLength - pos;

            if (type !== "moov") {
                // Case 1
                // We didn't download enough bytes to find the moov.
                // TODO : Load more bytes.
                //        Be sure to detect EOF.
                //        Throw error is no moov is found in the entire file.
                //        Protection from loading the entire file?
                self.debug.log("Loading more bytes to find initialization.");
                info.range.start = 0;
                info.range.end = info.bytesLoaded + info.bytesToLoad;

                request = new XMLHttpRequest();

                request.onloadend = function () {
                    if (!loaded) {
                        deferred.reject("Error loading initialization.");
                    }
                };

                request.onload = function () {
                    loaded = true;
                    info.bytesLoaded = info.range.end;
                    findInit.call(self, request.response).then(
                        function (segments) {
                            deferred.resolve(segments);
                        }
                    );
                };

                request.onerror = function () {
                    deferred.reject("Error loading initialization.");
                };

                request.open("GET", self.tokenAuthentication.addTokenAsQueryArg(info.url));
                request.responseType = "arraybuffer";
                request.setRequestHeader("Range", "bytes=" + info.range.start + "-" + info.range.end);
                request = self.tokenAuthentication.setTokenInRequestHeader(request);
                request.send(null);
            } else {
                // Case 2
                // We have the entire range, so continue.
                start = ftyp === undefined ? moov : ftyp;
                end = moov + size - 1;
                irange = start + "-" + end;

                self.debug.log("Found the initialization.  Range: " + irange);
                deferred.resolve(irange);
            }

            return deferred.promise;
        },

        loadInit = function (media) {
            var deferred = Q.defer(),
                request = new XMLHttpRequest(),
                needFailureReport = true,
                self = this,
                info = {
                    url: media,
                    range: {},
                    searching: false,
                    bytesLoaded: 0,
                    bytesToLoad: 1500,
                    request: request
                };

            self.debug.log("Start searching for initialization.");
            info.range.start = 0;
            info.range.end = info.bytesToLoad;

            request.onload = function () {
                if (request.status < 200 || request.status > 299)
                {
                  return;
                }
                needFailureReport = false;

                info.bytesLoaded = info.range.end;
                findInit.call(self, request.response, info).then(
                    function (range) {
                        deferred.resolve(range);
                    },function(){
                        deferred.reject();
                    }
                );
            };

            request.onloadend = request.onerror = function () {
                if (!needFailureReport)
                {
                  return;
                }
                needFailureReport = false;

                var data = {};
                data.url = info.url;
                data.request = request;

                self.errHandler.sendError(MediaPlayer.dependencies.ErrorHandler.prototype.DOWNLOAD_ERR_INIT, null, data);
                deferred.reject(request);
            };

            request.open("GET", self.tokenAuthentication.addTokenAsQueryArg(info.url));
            request.responseType = "arraybuffer";
            request.setRequestHeader("Range", "bytes=" + info.range.start + "-" + info.range.end);
            request = self.tokenAuthentication.setTokenInRequestHeader(request);
            request.send(null);
            self.debug.log("Perform init search: " + info.url);

            return deferred.promise;
        },

        findSIDX = function (data, info) {
            var deferred = Q.defer(),
                d = new DataView(data),
                request = new XMLHttpRequest(),
                pos = 0,
                type = "",
                size = 0,
                bytesAvailable,
                sidxBytes,
                sidxSlice,
                sidxOut,
                i,
                c,
                needFailureReport = true,
                parsed,
                ref,
                loadMultiSidx = false,
                self = this;

            self.debug.log("Searching for SIDX box.");
            self.debug.log(info.bytesLoaded + " bytes loaded.");

            while (type !== "sidx" && pos < d.byteLength) {
                size = d.getUint32(pos); // subtract 8 for including the size and type
                pos += 4;

                type = "";
                for (i = 0; i < 4; i += 1) {
                    c = d.getInt8(pos);
                    type += String.fromCharCode(c);
                    pos += 1;
                }

                if (type !== "sidx") {
                    pos += size - 8;
                }
            }

            bytesAvailable = d.byteLength - pos;

            if (type !== "sidx") {
                // Case 1
                // We didn't download enough bytes to find the sidx.
                // TODO : Load more bytes.
                //        Be sure to detect EOF.
                //        Throw error is no sidx is found in the entire file.
                //        Protection from loading the entire file?
                deferred.reject();
            } else if (bytesAvailable < (size - 8)) {
                // Case 2
                // We don't have the entire box.
                // Increase the number of bytes to read and load again.
                self.debug.log("Found SIDX but we don't have all of it.");

                info.range.start = 0;
                info.range.end = info.bytesLoaded + (size - bytesAvailable);

                request.onload = function () {
                    if (request.status < 200 || request.status > 299)
                    {
                      return;
                    }
                    needFailureReport = false;

                    info.bytesLoaded = info.range.end;
                    findSIDX.call(self, request.response, info).then(
                        function (segments) {
                            deferred.resolve(segments);
                        }
                    );
                };

                request.onloadend = request.onerror = function () {
                    if (!needFailureReport)
                    {
                      return;
                    }
                    needFailureReport = false;
                    
                    var data = {};
                    data.url = info.url;
                    data.request = request;

                    self.errHandler.sendError(MediaPlayer.dependencies.ErrorHandler.prototype.DOWNLOAD_ERR_SIDX, null, data);
                    deferred.reject(request);
                };

                request.open("GET", self.tokenAuthentication.addTokenAsQueryArg(info.url));
                request.responseType = "arraybuffer";
                request.setRequestHeader("Range", "bytes=" + info.range.start + "-" + info.range.end);
                request = self.tokenAuthentication.setTokenInRequestHeader(request);
                request.send(null);
            } else {
                // Case 3
                // We have the entire box, so parse it and continue.
                info.range.start = pos - 8;
                info.range.end = info.range.start + size;

                self.debug.log("Found the SIDX box.  Start: " + info.range.start + " | End: " + info.range.end);
//                sidxBytes = data.slice(info.range.start, info.range.end);
                sidxBytes = new ArrayBuffer(info.range.end - info.range.start);
                sidxOut = new Uint8Array(sidxBytes);
                sidxSlice = new Uint8Array(data, info.range.start, info.range.end - info.range.start);
                sidxOut.set(sidxSlice);

                parsed = this.parseSIDX.call(this, sidxBytes, info.range.start);

                // We need to check to see if we are loading multiple sidx.
                // For now just check the first reference and assume they are all the same.
                // TODO : Can the referenceTypes be mixed?
                // TODO : Load them all now, or do it as needed?

                ref = parsed.references;
                if (ref !== null && ref !== undefined && ref.length > 0) {
                    loadMultiSidx = (ref[0].type === 1);
                }

                if (loadMultiSidx) {
                    self.debug.log("Initiate multiple SIDX load.");

                    var j, len, ss, se, r, funcs = [], segs;

                    for (j = 0, len = ref.length; j < len; j += 1) {
                        ss = ref[j].offset;
                        se = ref[j].offset + ref[j].size - 1;
                        r = ss + "-" + se;

                        funcs.push(this.loadSegments.call(self, info.url, r));
                    }

                    Q.all(funcs).then(
                        function (results) {
                            segs = [];
                            for (j = 0, len = results.length; j < len; j += 1) {
                                segs = segs.concat(results[j]);
                            }
                            deferred.resolve(segs);
                        },
                        function (httprequest) {
                            deferred.reject(httprequest);
                        }
                    );

                } else {
                    self.debug.log("Parsing segments from SIDX.");
                    deferred.resolve(parseSegments.call(self, sidxBytes, info.url, info.range.start));
                }
            }

            return deferred.promise;
        },

        loadSegments = function (media, theRange) {
            var deferred = Q.defer(),
                request = new XMLHttpRequest(),
                parts,
                needFailureReport = true,
                self = this,
                info = {
                    url: media,
                    range: {},
                    searching: false,
                    bytesLoaded: 0,
                    bytesToLoad: 1500,
                    request: request
                };

            // We might not know exactly where the sidx box is.
            // Load the first n bytes (say 1500) and look for it.
            if (theRange === null) {
                self.debug.log("No known range for SIDX request.");
                info.searching = true;
                info.range.start = 0;
                info.range.end = info.bytesToLoad;
            } else {
                parts = theRange.split("-");
                info.range.start = parseFloat(parts[0]);
                info.range.end = parseFloat(parts[1]);
            }

            request.onload = function () {
                if (request.status < 200 || request.status > 299)
                {
                  return;
                }
                needFailureReport = false;


                // If we didn't know where the SIDX box was, we have to look for it.
                // Iterate over the data checking out the boxes to find it.
                if (info.searching) {
                    info.bytesLoaded = info.range.end;
                    findSIDX.call(self, request.response, info).then(
                        function (segments) {
                            deferred.resolve(segments);
                        }, function(){
                            deferred.reject();
                        }
                    );
                } else {
                    deferred.resolve(parseSegments.call(self, request.response, info.url, info.range.start));
                }
            };

            request.onloadend = request.onerror = function () {
                if (!needFailureReport)
                {
                  return;
                }
                needFailureReport = false;

                var data = {};
                data.url = info.url;
                data.request = request;
                
                self.errHandler.sendError(MediaPlayer.dependencies.ErrorHandler.prototype.DOWNLOAD_ERR_SIDX, null, data);
                deferred.reject(request);
            };

            request.open("GET", self.tokenAuthentication.addTokenAsQueryArg(info.url));
            request.responseType = "arraybuffer";
            request.setRequestHeader("Range", "bytes=" + info.range.start + "-" + info.range.end);
            request = self.tokenAuthentication.setTokenInRequestHeader(request);
            request.send(null);
            self.debug.log("Perform SIDX load: " + info.url);

            return deferred.promise;
        };

    return {
        debug: undefined,
        errHandler: undefined,
        tokenAuthentication:undefined,
        loadSegments: loadSegments,
        loadInitialization: loadInit,
        parseSegments: parseSegments,
        parseSIDX: parseSIDX,
        findSIDX: findSIDX
    };
};

Dash.dependencies.BaseURLExtensions.prototype = {
    constructor: Dash.dependencies.BaseURLExtensions
};
/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Digital Primates
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
Dash.di.DashContext = function () {
    "use strict";

    return {
        system : undefined,
        setup : function () {
            Dash.di.DashContext.prototype.setup.call(this);

            this.system.mapClass('parser', Dash.dependencies.DashParser);
            this.system.mapClass('indexHandler', Dash.dependencies.DashHandler);
            this.system.mapClass('baseURLExt', Dash.dependencies.BaseURLExtensions);
            this.system.mapClass('fragmentExt', Dash.dependencies.FragmentExtensions);
            this.system.mapSingleton('manifestExt', Dash.dependencies.DashManifestExtensions);
            this.system.mapSingleton('metricsExt', Dash.dependencies.DashMetricsExtensions);
            this.system.mapSingleton('timelineConverter', Dash.dependencies.TimelineConverter);
        }
    };
};

Dash.di.DashContext.prototype = new MediaPlayer.di.Context();
Dash.di.DashContext.prototype.constructor = Dash.di.DashContext;

/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Digital Primates
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
Dash.dependencies.DashHandler = function() {
    "use strict";

    var index = -1,
        requestedTime = null,
        isDynamic,
        type,

        zeroPadToLength = function(numStr, minStrLength) {
            while (numStr.length < minStrLength) {
                numStr = "0" + numStr;
            }

            return numStr;
        },

        replaceTokenForTemplate = function(url, token, value) {
            var startPos = 0,
                endPos = 0,
                tokenLen = token.length,
                formatTag = "%0",
                formatTagLen = formatTag.length,
                formatTagPos,
                specifier,
                width,
                paddedValue;

            // keep looping round until all instances of <token> have been
            // replaced. once that has happened, startPos below will be -1
            // and the completed url will be returned.
            while (true) {

                // check if there is a valid $<token>...$ identifier
                // if not, return the url as is.
                startPos = url.indexOf("$" + token);
                if (startPos < 0) {
                    return url;
                }

                // the next '$' must be the end of the identifer
                // if there isn't one, return the url as is.
                endPos = url.indexOf("$", startPos + tokenLen);
                if (endPos < 0) {
                    return url;
                }

                // now see if there is an additional format tag suffixed to
                // the identifier within the enclosing '$' characters
                formatTagPos = url.indexOf(formatTag, startPos + tokenLen);
                if (formatTagPos > startPos && formatTagPos < endPos) {

                    specifier = url.charAt(endPos - 1);
                    width = parseInt(url.substring(formatTagPos + formatTagLen, endPos - 1), 10);

                    // support the minimum specifiers required by IEEE 1003.1
                    // (d, i , o, u, x, and X) for completeness
                    switch (specifier) {
                        // treat all int types as uint,
                        // hence deliberate fallthrough
                        case 'd':
                        case 'i':
                        case 'u':
                            paddedValue = zeroPadToLength(value.toString(), width);
                            break;
                        case 'x':
                            paddedValue = zeroPadToLength(value.toString(16), width);
                            break;
                        case 'X':
                            paddedValue = zeroPadToLength(value.toString(16), width).toUpperCase();
                            break;
                        case 'o':
                            paddedValue = zeroPadToLength(value.toString(8), width);
                            break;
                        default:
                            this.debug.log("Unsupported/invalid IEEE 1003.1 format identifier string in URL");
                            return url;
                    }
                } else {
                    paddedValue = value;
                }

                url = url.substring(0, startPos) + paddedValue + url.substring(endPos + 1);
            }
        },

        unescapeDollarsInTemplate = function(url) {
            return url.split("$$").join("$");
        },

        replaceIDForTemplate = function(url, value) {
            if (value === null || url.indexOf("$RepresentationID$") === -1) {
                return url;
            }
            var v = value.toString();
            return url.split("$RepresentationID$").join(v);
        },

        getNumberForSegment = function(segment, segmentIndex) {
            return segment.representation.startNumber + segmentIndex;
        },

        getRequestUrl = function(destination, representation) {
            var baseURL = representation.adaptation.period.mpd.manifest.Period_asArray[representation.adaptation.period.index].
            AdaptationSet_asArray[representation.adaptation.index].Representation_asArray[representation.index].BaseURL,
            url;

            if (destination === baseURL) {
                url = destination;
            } else if ((destination.indexOf("http://") !== -1) || (destination.indexOf("https://") !== -1)) {
                url = destination;
            } else {
                url = baseURL + destination;
            }

            return url;
        },

        generateInitRequest = function(representation, streamType) {
            var self = this,
                period,
                request = new MediaPlayer.vo.SegmentRequest(),
                presentationStartTime;

            period = representation.adaptation.period;

            request.streamType = streamType;
            request.type = "Initialization Segment";
            request.url = getRequestUrl(representation.initialization, representation);
            request.range = representation.range;
            presentationStartTime = period.start;
            request.availabilityStartTime = self.timelineConverter.calcAvailabilityStartTimeFromPresentationTime(presentationStartTime, representation.adaptation.period.mpd, isDynamic);
            request.availabilityEndTime = self.timelineConverter.calcAvailabilityEndTimeFromPresentationTime(presentationStartTime + period.duration, period.mpd, isDynamic);
            request.quality = representation.index;

            return request;
        },

        getInit = function(representation) {
            var deferred = Q.defer(),
                request = null,
                url = null,
                self = this;

            if (!representation) {
                return Q.reject("no represenation");
            }

            //self.debug.log("Getting the initialization request.");

            if (representation.initialization) {
                //self.debug.log("Got an initialization.");
                request = generateInitRequest.call(self, representation, type);
                deferred.resolve(request);
            } else {
                // Go out and find the initialization.
                url = representation.adaptation.period.mpd.manifest.Period_asArray[representation.adaptation.period.index].
                AdaptationSet_asArray[representation.adaptation.index].Representation_asArray[representation.index].BaseURL;
                self.baseURLExt.loadInitialization(url).then(
                    function(theRange) {
                        //self.debug.log("Got an initialization.");
                        representation.range = theRange;
                        representation.initialization = url;
                        request = generateInitRequest.call(self, representation, type);
                        deferred.resolve(request);
                    },
                    function(httprequest) {
                        deferred.reject(httprequest);
                    }
                );
            }

            return deferred.promise;
        },

        isMediaFinished = function(representation) { // TODO
            var sDuration,
                period = representation.adaptation.period,
                isFinished = false,
                seg,
                fTime;

            //this.debug.log("Checking for stream end...");
            if (isDynamic) {
                //this.debug.log("Live never ends! (TODO)");
                // TODO : Check the contents of the last box to signal end.
                isFinished = false;
            } else {
                if (index < 0) {
                    isFinished = false;
                } else if (index < representation.availableSegmentsNumber + representation.segmentStartIndex) {
                    seg = getSegmentByIndex(index, representation);

                    if (seg) {
                        fTime = seg.presentationStartTime - period.start;
                        sDuration = representation.adaptation.period.duration;
                        //this.debug.log(representation.segmentInfoType + ": " + fTime + " / " + sDuration);
                        isFinished = (fTime >= sDuration);
                    }
                } else {
                    isFinished = true;
                }
            }

            return isFinished;
        },

        getIndexBasedSegment = function(representation, index) {
            var self = this,
                seg,
                duration,
                presentationStartTime,
                presentationEndTime;

            duration = representation.segmentDuration;
            presentationStartTime = representation.adaptation.period.start + (index * duration);
            presentationEndTime = presentationStartTime + duration;

            seg = new Dash.vo.Segment();

            seg.representation = representation;
            seg.duration = duration;
            seg.presentationStartTime = presentationStartTime;

            seg.mediaStartTime = self.timelineConverter.calcMediaTimeFromPresentationTime(seg.presentationStartTime, representation);

            seg.availabilityStartTime = self.timelineConverter.calcAvailabilityStartTimeFromPresentationTime(seg.presentationStartTime, representation.adaptation.period.mpd, isDynamic);
            seg.availabilityEndTime = self.timelineConverter.calcAvailabilityEndTimeFromPresentationTime(presentationEndTime, representation.adaptation.period.mpd, isDynamic);

            // at this wall clock time, the video element currentTime should be seg.presentationStartTime
            seg.wallStartTime = self.timelineConverter.calcWallTimeForSegment(seg, isDynamic);

            seg.replacementNumber = getNumberForSegment(seg, index);
            seg.availabilityIdx = index;

            //this.debug.log("[DashHandler]["+type+"] createSegment: time = " + seg.mediaStartTime + ", availabilityIdx = " + seg.availabilityIdx);

            return seg;
        },

        getSegmentsFromTimeline = function(representation) {
            var self = this,
                template = representation.adaptation.period.mpd.manifest.Period_asArray[representation.adaptation.period.index].
            AdaptationSet_asArray[representation.adaptation.index].Representation_asArray[representation.index].SegmentTemplate,
            timeline = template.SegmentTimeline,
            isAvailableSegmentNumberCalculated = representation.availableSegmentsNumber > 0,
            maxSegmentsAhead = 10,
            segments = [],
            fragments,
            frag,
            i,
            len,
            j,
            repeat,
            repeatEndTime,
            nextFrag,
            time = 0,
            availabilityIdx = -1,
            calculatedRange,
            hasEnoughSegments = false,
            requiredMediaTime,
            startIdx,
            endIdx,
            fTimescale,
            createSegment = function(s) {
                return getTimeBasedSegment.call(
                    self,
                    representation,
                    time,
                    s.d,
                    fTimescale,
                    template.media,
                    s.mediaRange,
                    availabilityIdx,
                    s.tManifest);
            };

            fTimescale = representation.timescale;

            fragments = timeline.S_asArray;

            calculatedRange = decideSegmentListRangeForTimeline.call(self, representation);

            // if calculatedRange exists we should generate segments that belong to this range.
            // Otherwise generate maxSegmentsAhead segments ahead of the requested time
            if (calculatedRange) {
                startIdx = calculatedRange.start;
                endIdx = calculatedRange.end;
            } else {
                requiredMediaTime = self.timelineConverter.calcMediaTimeFromPresentationTime(requestedTime || 0, representation);
            }

            for (i = 0, len = fragments.length; i < len; i += 1) {
                frag = fragments[i];
                repeat = 0;
                if (frag.hasOwnProperty("r")) {
                    repeat = frag.r;
                }

                //For a repeated S element, t belongs only to the first segment
                if (frag.hasOwnProperty("t")) {
                    time = frag.t;
                }

                //This is a special case: "A negative value of the @r attribute of the S element indicates that the duration indicated in @d attribute repeats until the start of the next S element, the end of the Period or until the
                // next MPD update."
                if (repeat < 0) {
                    nextFrag = fragments[i + 1];
                    repeatEndTime = (nextFrag && nextFrag.hasOwnProperty("t")) ? (nextFrag.t / fTimescale) : representation.adaptation.period.duration;
                    repeat = Math.ceil((repeatEndTime - time / fTimescale) / (frag.d / fTimescale)) - 1;
                }

                // if we have enough segments in the list, but we have not calculated the total number of the segments yet we
                // should continue the loop and calc the number. Once it is calculated, we can break the loop.
                if (hasEnoughSegments) {
                    if (isAvailableSegmentNumberCalculated) break;
                    availabilityIdx += repeat + 1;
                    continue;
                }

                for (j = 0; j <= repeat; j += 1) {
                    availabilityIdx += 1;

                    if (calculatedRange) {
                        if (availabilityIdx > endIdx) {
                            hasEnoughSegments = true;
                            if (isAvailableSegmentNumberCalculated) break;
                            continue;
                        }

                        if (availabilityIdx >= startIdx) {
                            segments.push(createSegment.call(self, frag));
                        }
                    } else {
                        if (segments.length > maxSegmentsAhead) {
                            hasEnoughSegments = true;
                            if (isAvailableSegmentNumberCalculated) break;
                            continue;
                        }

                        if (time / fTimescale >= (requiredMediaTime - (frag.d / fTimescale))) {
                            segments.push(createSegment.call(self, frag));
                        }
                    }

                    time += frag.d;
                }
            }

            if (true/*!isAvailableSegmentNumberCalculated*/) {
                var availabilityStartTime,
                    availabilityEndTime,
                    f = fragments[0];

                availabilityStartTime = (f.t === undefined) ? 0 : self.timelineConverter.calcPresentationTimeFromMediaTime(f.t / fTimescale, representation);
                availabilityEndTime = self.timelineConverter.calcPresentationTimeFromMediaTime((time - frag.d) / fTimescale, representation);
                representation.segmentAvailabilityRange = {
                    start: availabilityStartTime,
                    end: availabilityEndTime
                };
                representation.availableSegmentsNumber = availabilityIdx + 1;
                representation.segmentStartIndex = 0;
            }

            return Q.when(segments);
        },

        getSegmentsFromTemplate = function(representation) {
            var segments = [],
                self = this,
                deferred = Q.defer(),
                template = representation.adaptation.period.mpd.manifest.Period_asArray[representation.adaptation.period.index].
            AdaptationSet_asArray[representation.adaptation.index].Representation_asArray[representation.index].SegmentTemplate,
            duration = representation.segmentDuration,
            segmentRange = null,
            periodStartIdx = Math.floor(representation.adaptation.period.start / duration),
            i,
            startIdx,
            endIdx,
            seg = null,
            start,
            url = null;

            start = representation.startNumber;

            waitForAvailabilityWindow.call(self, representation).then(
                function(availabilityWindow) {
                    representation.segmentAvailabilityRange = availabilityWindow;
                    segmentRange = decideSegmentListRangeForTemplate.call(self, representation);

                    startIdx = segmentRange.start;
                    endIdx = segmentRange.end;

                    for (i = startIdx; i <= endIdx; i += 1) {

                        seg = getIndexBasedSegment.call(
                            self,
                            representation,
                            i - (isDynamic ? periodStartIdx : 0));

                        seg.replacementTime = (start + i - 1) * representation.segmentDuration;
                        url = template.media;
                        url = replaceTokenForTemplate(url, "Number", seg.replacementNumber);
                        url = replaceTokenForTemplate(url, "Time", seg.replacementTime);
                        seg.media = url;

                        segments.push(seg);
                        seg = null;
                    }

                    representation.availableSegmentsNumber = periodStartIdx + Math.ceil((availabilityWindow.end - availabilityWindow.start) / duration);
                    representation.segmentStartIndex = startIdx;

                    deferred.resolve(segments);
                }
            );

            return deferred.promise;
        },

        decideSegmentListRangeForTemplate = function(representation) {
            var self = this,
                periodStart = representation.adaptation.period.start,
                duration = representation.segmentDuration,
                minBufferTime = representation.adaptation.period.mpd.manifest.minBufferTime,
                availabilityWindow = representation.segmentAvailabilityRange,
                originAvailabilityTime = NaN,
                originSegment = null,
                currentSegmentList = representation.segments,
                availabilityLowerLimit = 2 * duration,
                availabilityUpperLimit = Math.max(2 * minBufferTime, 10 * duration),
                start,
                end,
                range;

            if (!availabilityWindow) {
                availabilityWindow = self.timelineConverter.calcSegmentAvailabilityRange(representation, isDynamic);
            }

            if (isDynamic && !representation.adaptation.period.mpd.isClientServerTimeSyncCompleted) {
                start = Math.floor(availabilityWindow.start / duration);
                end = Math.floor(availabilityWindow.end / duration);
                range = {
                    start: start,
                    end: end
                };
                return range;
            }

            // if segments exist we should try to find the latest buffered time, which is the presentation time of the
            // segment for the current index
            if (currentSegmentList) {
                originSegment = getSegmentByIndex(index, representation);
                originAvailabilityTime = originSegment ? (originSegment.presentationStartTime - periodStart) : (index > 0 ? (index * duration) : (requestedTime - periodStart) || (currentSegmentList[0].presentationStartTime - periodStart));
            } else {
                // If no segments exist, but index > 0, it means that we switch to the other representation, so
                // we should proceed from this time.
                // Otherwise we should start from the beginning for static mpds or from the end (live edge) for dynamic mpds
                originAvailabilityTime = (index > 0) ? (index * duration) : (isDynamic ? availabilityWindow.end : availabilityWindow.start);
            }

            // segment list should not be out of the availability window range
            start = Math.floor(Math.max(originAvailabilityTime - availabilityLowerLimit, availabilityWindow.start) / duration);
            end = Math.floor(Math.min(start + availabilityUpperLimit / duration, availabilityWindow.end / duration));

            range = {
                start: start,
                end: end
            };

            return range;
        },

        decideSegmentListRangeForTimeline = function(representation) {
            var originAvailabilityIdx = NaN,
                currentSegmentList = representation.segments,
                availabilityLowerLimit = 2,
                availabilityUpperLimit = 10,
                firstIdx = 0,
                lastIdx = Number.POSITIVE_INFINITY,
                start,
                end,
                range;

            if (isDynamic && !representation.adaptation.period.mpd.isClientServerTimeSyncCompleted) {
                range = {
                    start: firstIdx,
                    end: lastIdx
                };
                return range;
            }

            if (!isDynamic && requestedTime !== null) {
                return null;
            }

            // if segments exist use the current index as an origin index for a new range
            if (currentSegmentList) {
                // if the index is negative we can't calculate the range right now
                if (index < 0) {
                    return null;
                }
                originAvailabilityIdx = index;
            } else {
                // If no segments exist, but index > 0, it means that we switch to the other representation, so
                // we should proceed from this index.
                // Otherwise we should start from the beginning for static mpds or from the end (live edge) for dynamic mpds
                originAvailabilityIdx = (index > 0) ? index : (isDynamic ? lastIdx : firstIdx);
            }

            // segment list should not be out of the availability window range
            start = Math.max(originAvailabilityIdx - availabilityLowerLimit, firstIdx);
            end = Math.min(originAvailabilityIdx + availabilityUpperLimit, lastIdx);

            range = {
                start: start,
                end: end
            };

            return range;
        },

        waitForAvailabilityWindow = function(representation) {
            var self = this,
                deferred = Q.defer(),
                range,
                waitingTime,
                getRange = function() {
                    range = self.timelineConverter.calcSegmentAvailabilityRange(representation, isDynamic);

                    if (range.end > 0) {
                        deferred.resolve(range);
                    } else {
                        // range.end represents a time gap between the current wall-clock time and the availability time of the first segment.
                        // A negative value means that no segments are available yet, we should wait until segments become available
                        waitingTime = Math.abs(range.end) * 1000;
                        setTimeout(getRange, waitingTime);
                    }
                };

            getRange();

            return deferred.promise;
        },

        getTimeBasedSegment = function(representation, time, duration, fTimescale, url, range, index, tManifest) {
            var self = this,
                scaledTime = time / fTimescale,
                scaledDuration = Math.min(duration / fTimescale, representation.adaptation.period.mpd.maxSegmentDuration),
                presentationStartTime,
                presentationEndTime,
                seg;

            presentationStartTime = self.timelineConverter.calcPresentationTimeFromMediaTime(scaledTime, representation);
            // ORANGE: presentationStartTime is the media time of the segment as provided in the SegmentTimeline
            presentationStartTime = scaledTime; //self.timelineConverter.calcPresentationTimeFromMediaTime(scaledTime, representation);
            presentationEndTime = presentationStartTime + scaledDuration;

            seg = new Dash.vo.Segment();

            seg.representation = representation;
            seg.duration = scaledDuration;
            seg.mediaStartTime = scaledTime;

            seg.presentationStartTime = presentationStartTime;

            // For SegmentTimeline every segment is available at mpdLoadedTime
            seg.availabilityStartTime = representation.adaptation.period.mpd.manifest.mpdLoadedTime;
            seg.availabilityEndTime = self.timelineConverter.calcAvailabilityEndTimeFromPresentationTime(presentationEndTime, representation.adaptation.period.mpd, isDynamic);

            // at this wall clock time, the video element currentTime should be seg.presentationStartTime
            seg.wallStartTime = self.timelineConverter.calcWallTimeForSegment(seg, isDynamic);

            seg.replacementTime = tManifest ? tManifest : time;

            seg.replacementNumber = getNumberForSegment(seg, index);

            url = replaceTokenForTemplate(url, "Number", seg.replacementNumber);
            url = replaceTokenForTemplate(url, "Time", seg.replacementTime);
            seg.media = url;
            seg.mediaRange = range;
            seg.availabilityIdx = index;

            //this.debug.log("[DashHandler]["+type+"] createSegment: time = " + seg.mediaStartTime + ", availabilityIdx = " + seg.availabilityIdx + ", url = " + seg.media);

            return seg;
        },

        getSegmentsFromList = function(representation) {
            var self = this,
                segments = [],
                deferred = Q.defer(),
                list = representation.adaptation.period.mpd.manifest.Period_asArray[representation.adaptation.period.index].
            AdaptationSet_asArray[representation.adaptation.index].Representation_asArray[representation.index].SegmentList,
            len = list.SegmentURL_asArray.length,
            i,
            seg,
            s,
            range,
            startIdx = 0,
            endIdx = list.SegmentURL_asArray.length,
            start;

            start = representation.startNumber;

            waitForAvailabilityWindow.call(self, representation).then(
                function(availabilityWindow) {
                    if (!isDynamic) {
                        range = decideSegmentListRangeForTemplate.call(self, representation);
                        startIdx = range.start;
                        endIdx = range.end;
                    }

                    for (i = startIdx; i < endIdx; i += 1) {
                        s = list.SegmentURL_asArray[i];

                        seg = getIndexBasedSegment.call(
                            self,
                            representation,
                            i);

                        seg.replacementTime = (start + i - 1) * representation.segmentDuration;
                        seg.media = s.media;
                        seg.mediaRange = s.mediaRange;
                        seg.index = s.index;
                        seg.indexRange = s.indexRange;

                        // ORANGE: overwrite duration if set at segment level (HLS use case)
                        if (s.duration) {
                            seg.duration = s.duration;
                            seg.presentationStartTime = seg.mediaStartTime = s.time;
                        }

                        // ORANGE: add sequence number (HLS use case)
                        if (s.sequenceNumber !== undefined) {
                            seg.sequenceNumber = s.sequenceNumber;
                        }
                        // ORANGE: add decryption info (HLS use case)
                        if (s.decryptionInfo !== undefined) {
                            seg.decryptionInfo = s.decryptionInfo;
                        }
                        //self.debug.log("[DashHandler]["+type+"] createSegment: time = " + seg.mediaStartTime + ", availabilityIdx = " + seg.availabilityIdx + ", url = " + seg.media);

                        segments.push(seg);
                        seg = null;
                    }
                    representation.segmentAvailabilityRange = availabilityWindow;
                    representation.availableSegmentsNumber = len;
                    representation.segmentStartIndex = startIdx;
                    deferred.resolve(segments);
                });

            return deferred.promise;
        },

        getSegmentsFromSource = function(representation) {
            var self = this,
                baseURL = representation.adaptation.period.mpd.manifest.Period_asArray[representation.adaptation.period.index].
            AdaptationSet_asArray[representation.adaptation.index].Representation_asArray[representation.index].BaseURL,
            deferred = Q.defer(),
            segments = [],
            count = 0,
            range = null,
            s,
            i,
            len,
            seg;

            if (representation.indexRange) {
                range = representation.indexRange;
            }

            this.baseURLExt.loadSegments(baseURL, range).then(
                function(fragments) {
                    for (i = 0, len = fragments.length; i < len; i += 1) {
                        s = fragments[i];

                        seg = getTimeBasedSegment.call(
                            self,
                            representation,
                            s.startTime,
                            s.duration,
                            s.timescale,
                            s.media,
                            s.mediaRange,
                            count);

                        segments.push(seg);
                        seg = null;
                        count += 1;
                    }

                    representation.segmentAvailabilityRange = {
                        start: segments[0].presentationStartTime,
                        end: segments[len - 1].presentationStartTime
                    };
                    representation.availableSegmentsNumber = len;
                    representation.segmentStartIndex = 0;
                    deferred.resolve(segments);
                }, function(){
                    deferred.reject();
                }
            );

            return deferred.promise;
        },

        getSegments = function(representation) {
            var segmentPromise,
                deferred = Q.defer(),
                self = this,
                lastIdx;

            //self.debug.log("[DashHandler]["+type+"] getSegments for representation " + representation.id);
            // Already figure out the segments.
            if (!isSegmentListUpdateRequired.call(self, representation)) {
                return Q.when(representation.segments);
            } else {
                if (representation.segmentInfoType === "SegmentTimeline") {
                    segmentPromise = getSegmentsFromTimeline.call(self, representation);
                } else if (representation.segmentInfoType === "SegmentTemplate") {
                    segmentPromise = getSegmentsFromTemplate.call(self, representation);
                } else if (representation.segmentInfoType === "SegmentList") {
                    segmentPromise = getSegmentsFromList.call(self, representation);
                } else {
                    segmentPromise = getSegmentsFromSource.call(self, representation);
                }

                Q.when(segmentPromise).then(
                    function(segments) {
                        representation.segments = segments;
                        lastIdx = segments.length - 1;
                        if (isDynamic && isNaN(representation.adaptation.period.liveEdge)) {
                            var metrics = self.metricsModel.getMetricsFor("stream"),
                                liveEdge = segments[lastIdx].presentationStartTime;
                            // the last segment is supposed to be a live edge
                            representation.adaptation.period.liveEdge = liveEdge;
                            self.metricsModel.updateManifestUpdateInfo(self.metricsExt.getCurrentManifestUpdate(metrics), {
                                presentationStartTime: liveEdge
                            });
                        }

                        deferred.resolve(segments);
                    }, function(){
                        deferred.reject();
                    }
                );
            }

            return deferred.promise;
        },

        updateSegmentList = function(representation) {
            var self = this,
                deferred = Q.defer();

            representation.segments = null;

            self.debug.log("[DashHandler][" + type + "] updateSegmentList for representation ", representation.id);

            getSegments.call(self, representation).then(
                function(segments) {
                    representation.segments = segments;
                    deferred.resolve(segments);
                }
            );

            return deferred.promise;
        },

        getIndexForSegments = function(time, representation) {
            var segments = representation === null ? null : representation.segments,
                segmentLastIdx = segments === null ? 0 : segments.length - 1,
                idx = -1,
                frag,
                ft,
                fd,
                i,
                self = this;

            self.debug.log("[DashHandler][" + type + "] getIndexForSegments for time ", time);

            if (segments && segments.length > 0) {
                for (i = segmentLastIdx; i >= 0; i--) {
                    frag = segments[i];
                    ft = frag.presentationStartTime;
                    fd = frag.duration;
                    //self.debug.log("[DashHandler]["+type+"] ft = " + ft + ", fd = " + fd + ", idx = " + frag.availabilityIdx);
                    if ((time + Dash.dependencies.DashHandler.EPSILON) >= ft &&
                        (time - Dash.dependencies.DashHandler.EPSILON) <= (ft + fd)) {
                        idx = frag.availabilityIdx;
                        self.debug.log("[DashHandler][" + type + "] getIndexForSegments, idx =  ", idx);
                        break;
                    } else if (idx === -1 && (time - Dash.dependencies.DashHandler.EPSILON) > (ft + fd)) {
                        // time is past the end
                        self.debug.log("[DashHandler][" + type + "] getIndexForSegments, (past the end) idx =  ", idx);
                        idx = isNaN(representation.segmentDuration) ? (frag.availabilityIdx + 1) : Math.floor((time - representation.adaptation.period.start) / representation.segmentDuration);
                        //ORANGE : we have past the end, don't iterate for nothing
                        break;
                    }
                }
            }

            if (idx === -1) {
                if (!isNaN(representation.segmentDuration)) {
                    self.debug.log("[DashHandler][" + type + "] getIndexForSegments, (segment duration) idx =  ", idx);
                    idx = Math.floor((time - representation.adaptation.period.start) / representation.segmentDuration);
                } else if (segments && segments.length > 0 && time < segments[0].presentationStartTime) {
                    self.debug.log("[DashHandler][" + type + "] getIndexForSegments, (before start) idx =  ", idx);
                    idx = 0;
                } else {
                    self.debug.log("[DashHandler][" + type + "] Couldn't figure out segment for time: " + time);
                }
            }

            /*
            if (segments && segments.length > 0) {
                idx = 0;
                ft = segments[0].startTime / segments[0].timescale;
                frag = null;

                while (ft <= time && (idx + 1) < segments.length) {
                    frag = segments[idx];
                    ft += frag.duration / frag.timescale;
                    idx += 1;
                }
                idx -= 1;
            }
            */

            return Q.when(idx);
        },

        getSegmentByIndex = function(index, representation) {
            if (!representation || !representation.segments) {
                return null;
            }

            var ln = representation.segments.length,
                seg,
                i;

            for (i = 0; i < ln; i += 1) {
                seg = representation.segments[i];

                if (seg.availabilityIdx === index) {
                    return seg;
                }
            }

            return null;
        },

        // ORANGE: HLS use case, get next segment from sequence number
        getNextSegmentBySequenceNumber = function(sn, representation) {
            if (!representation || !representation.segments) {
                return null;
            }

            var ln = representation.segments.length,
                seg,
                i;

            for (i = 0; i < ln; i += 1) {
                seg = representation.segments[i];

                if ((seg.sequenceNumber !== undefined) && (seg.sequenceNumber === sn)) {
                    if (i < (ln - 1)) {
                        return representation.segments[i + 1];
                    }
                    return null;
                }
            }

            return null;
        },

        isSegmentListUpdateRequired = function(representation) {
            var updateRequired = false,
                segments = representation.segments,
                upperIdx,
                lowerIdx,
                upperTime,
                lowerTime;

            if (!segments || segments.length === 0) {
                updateRequired = true;
            } else {
                if (requestedTime !== null) {
                    lowerTime = segments[0].presentationStartTime;
                    upperTime = segments[segments.length - 1].presentationStartTime;
                    updateRequired = (requestedTime < lowerTime) || (requestedTime > upperTime);
                } else {
                    lowerIdx = segments[0].availabilityIdx;
                    upperIdx = segments[segments.length - 1].availabilityIdx;
                    updateRequired = (index < lowerIdx) || (index > upperIdx);
                }
            }

            return updateRequired;
        },

        getRequestForSegment = function(segment) {
            if (segment === null || segment === undefined) {
                return null;
            }

            var request = new MediaPlayer.vo.SegmentRequest(),
                representation = segment.representation,
                bandwidth = representation.adaptation.period.mpd.manifest.Period_asArray[representation.adaptation.period.index].
            AdaptationSet_asArray[representation.adaptation.index].Representation_asArray[representation.index].bandwidth,
            url;

            url = getRequestUrl(segment.media, representation);
            url = replaceTokenForTemplate(url, "Number", segment.replacementNumber);
            url = replaceTokenForTemplate(url, "Time", segment.replacementTime);
            url = replaceTokenForTemplate(url, "Bandwidth", bandwidth);
            url = replaceIDForTemplate(url, representation.id);
            url = unescapeDollarsInTemplate(url);

            request.streamType = type;
            request.type = "Media Segment";
            request.url = url;
            request.range = segment.mediaRange;
            request.startTime = segment.presentationStartTime;
            request.duration = segment.duration;
            request.timescale = representation.timescale;
            request.availabilityStartTime = segment.availabilityStartTime;
            request.availabilityEndTime = segment.availabilityEndTime;
            request.wallStartTime = segment.wallStartTime;
            request.quality = representation.index;
            request.index = segment.availabilityIdx;
            // ORANGE: add sequence number (HLS use case)
            if (segment.sequenceNumber !== undefined) {
                request.sequenceNumber = segment.sequenceNumber;
            }
            // ORANGE: add decryption info (HLS use case)
            if (segment.decryptionInfo !== undefined) {
                request.decryptionInfo = segment.decryptionInfo;
            }

            return request;
        },

        getForTime = function(representation, time) {
            var deferred,
                request,
                segment,
                self = this;

            if (!representation) {
                return Q.reject("no representation");
            }

            requestedTime = time;
            index = -1;

            self.debug.log("[DashHandler][" + type + "] Getting the request for time: " + time);

            deferred = Q.defer();

            getSegments.call(self, representation).then(
                function( /*segments*/ ) {
                    var segmentsPromise;

                    //self.debug.log("Got segments.");
                    //self.debug.log(segments);
                    //self.debug.log("Got a list of segments, so dig deeper.");
                    segmentsPromise = getIndexForSegments.call(self, time, representation);
                    return segmentsPromise;
                }, function(){deferred.reject();}
            ).then(
                function(newIndex) {
                    self.debug.log("[DashHandler][" + type + "] Index for time " + time + " is " + newIndex);
                    index = newIndex;

                    return Q.when(isMediaFinished.call(self, representation));
                }
            ).then(
                function(finished) {
                    var requestForSegment = null;

                    //self.debug.log("Stream finished? " + finished);
                    if (finished) {
                        request = new MediaPlayer.vo.SegmentRequest();
                        request.action = request.ACTION_COMPLETE;
                        request.index = index;
                        self.debug.log("[DashHandler][" + type + "] Signal complete.");
                        self.debug.log(request);
                        deferred.resolve(request);
                    } else {
                        segment = getSegmentByIndex(index, representation);
                        requestForSegment = getRequestForSegment.call(self, segment);
                    }

                    return Q.when(requestForSegment);
                }
            ).then(
                function(request) {
                    //self.debug.log("Got a request.");
                    //self.debug.log(request);
                    deferred.resolve(request);
                }
            );

            return deferred.promise;
        },

        getNext = function(representation) {
            var deferred,
                request,
                segment,
                finished,
                self = this;

            if (!representation) {
                return Q.reject("no represenation");
            }

            //self.debug.log("Getting the next request.");

            if (index === -1) {
                throw "You must call getSegmentRequestForTime first.";
            }

            requestedTime = null;
            index += 1;

            deferred = Q.defer();

            self.debug.log("[DashHandler][" + type + "] Getting the next request => index = " + index);

            finished = isMediaFinished.call(self, representation);
            //self.debug.log("Stream finished? " + finished);
            if (finished) {
                request = new MediaPlayer.vo.SegmentRequest();
                request.action = request.ACTION_COMPLETE;
                request.index = index;
                self.debug.log("[DashHandler][" + type + "] Signal complete.");
                //self.debug.log(request);
                deferred.resolve(request);
            } else {
                getSegments.call(self, representation).then(
                    function( /*segments*/ ) {
                        var segmentsPromise;

                        //self.debug.log("Got segments.");
                        //self.debug.log(segments);
                        segment = getSegmentByIndex(index, representation);
                        segmentsPromise = getRequestForSegment.call(self, segment);
                        return Q.when(segmentsPromise);
                    }
                ).then(
                    function(request) {
                        //self.debug.log("Got a request.");
                        //self.debug.log(request);
                        deferred.resolve(request);
                    }
                );
            }

            return deferred.promise;
        },

        // ORANGE: HLS use case, get next request from sequence number
        getNextFromSN = function(representation, sn) {
            var deferred,
                request,
                segment,
                finished,
                self = this;

            if (!representation) {
                return Q.reject("no represenation");
            }

            //self.debug.log("Getting the next request.");

            if (index === -1) {
                throw "You must call getSegmentRequestForTime first.";
            }

            requestedTime = null;
            index += 1;

            deferred = Q.defer();

            self.debug.log("[DashHandler][" + type + "] Getting the next request => sn = " + sn);

            getSegments.call(self, representation).then(
                function( /*segments*/ ) {
                    finished = isMediaFinished.call(self, representation);
                    //self.debug.log("Stream finished? " + finished);
                    if (finished) {
                        request = new MediaPlayer.vo.SegmentRequest();
                        request.action = request.ACTION_COMPLETE;
                        request.index = index;
                        self.debug.log("[DashHandler][" + type + "] Signal complete.");
                        //self.debug.log(request);
                        deferred.resolve(request);
                    } else {
                        segment = getNextSegmentBySequenceNumber(sn, representation);
                        if (segment === null) {
                            deferred.resolve(null);
                        } else {
                            index = segment.availabilityIdx;
                            var requestForSegment = getRequestForSegment.call(self, segment);
                            //self.debug.log("Got a request.");
                            //self.debug.log(request);
                            deferred.resolve(requestForSegment);
                        }
                    }
                }
            );

            return deferred.promise;
        },

        getSegmentCountForDuration = function(representation, requiredDuration, bufferedDuration) {
            var self = this,
                remainingDuration = Math.max(requiredDuration - bufferedDuration, 0),
                deferred = Q.defer(),
                segmentDuration,
                segmentCount = 0;

            if (!representation) {
                return Q.reject("no represenation");
            }

            self.debug.log("[DashHandler][" + type + "] getSegmentCountForDuration");

            getSegments.call(self, representation).then(
                function(segments) {
                    segmentDuration = segments[0].duration;
                    segmentCount = Math.ceil(remainingDuration / segmentDuration);
                    deferred.resolve(segmentCount);
                },
                function() {
                    deferred.resolve(0);
                }
            );

            return deferred.promise;
        },

        getCurrentTime = function(representation) {
            var self = this,
                time,
                bufferedIndex,
                deferred = Q.defer();

            if (!representation) {
                return Q.reject("no represenation");
            }

            bufferedIndex = index;

            getSegments.call(self, representation).then(
                function(segments) {
                    if (bufferedIndex < 0) {
                        time = self.timelineConverter.calcPresentationStartTime(representation.adaptation.period);
                    } else {
                        bufferedIndex = bufferedIndex < segments[0].availabilityIdx ? segments[0].availabilityIdx : Math.min(segments[segments.length - 1].availabilityIdx, bufferedIndex);
                        time = getSegmentByIndex(bufferedIndex, representation).presentationStartTime;
                        self.debug.log("[DashHandler][" + type + "] getSegmentByIndex, index = " + bufferedIndex + " => time = " + time);
                    }

                    self.debug.log("[DashHandler][" + type + "] getCurrentTime => ", time);
                    deferred.resolve(time);
                },
                function() {
                    deferred.reject();
                }
            );

            return deferred.promise;
        },

        getIFrameRequest = function( /*request*/ ) {
            //TBD
        },

        getFragmentInfoRequest = function( /*request*/ ) {
            //TBD
        };

    return {
        debug: undefined,
        baseURLExt: undefined,
        metricsModel: undefined,
        metricsExt: undefined,
        manifestModel: undefined,
        manifestExt: undefined,
        timelineConverter: undefined,
        capabilities: undefined,
        videoModel: undefined,

        getType: function() {
            return type;
        },

        setType: function(value) {
            type = value;
        },

        getIsDynamic: function() {
            return isDynamic;
        },
        setIsDynamic: function(value) {
            isDynamic = value;
        },

        getInitRequest: getInit,
        getSegmentRequestForTime: getForTime,
        getNextSegmentRequest: getNext,
        // ORANGE: HLS use case, get next request from sequence number
        getNextSegmentRequestFromSN: getNextFromSN,
        getCurrentTime: getCurrentTime,
        getSegmentCountForDuration: getSegmentCountForDuration,
        updateSegmentList: updateSegmentList,
        getIFrameRequest: getIFrameRequest,
        getFragmentInfoRequest: getFragmentInfoRequest
    };
};

Dash.dependencies.DashHandler.EPSILON = 0.003;

Dash.dependencies.DashHandler.prototype = {
    constructor: Dash.dependencies.DashHandler
};
/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Digital Primates
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


Dash.dependencies.DashManifestExtensions = function() {
    "use strict";
    this.timelineConverter = undefined;
};

Dash.dependencies.DashManifestExtensions.prototype = {
    constructor: Dash.dependencies.DashManifestExtensions,

    isInteger: Number.isInteger || function (value) {
        return typeof value === 'number' &&
            isFinite(value) &&
            Math.floor(value) === value;
    },

    getIsType: function(adaptation, type, mimeTypes) {
        "use strict";
        var i, j,
            found = false,
            col,
            representation;

        if (!adaptation) {
            return false;
        }

        if (adaptation.type === undefined) {
            adaptation.type = null;
        }

        col = adaptation.ContentComponent_asArray;

        if (col) {
            // Check contentType attribute at adaptation level
            for (i = 0; i < adaptation.ContentComponent_asArray.length && !found; i++) {
                if (adaptation.ContentComponent_asArray[i].contentType === type) {
                    adaptation.type = type;
                    found = true;
                }
            }
        }

        // Check mimeType attribute at adaptation level
        if (!found) {
            if (adaptation.mimeType) {
                for (i = 0; i < mimeTypes.length && !found; i++) {
                    if (adaptation.mimeType.indexOf(mimeTypes[i]) !== -1) {
                        adaptation.type = type;
                        found = true;
                    }
                }
            }
        }

        // Check mimeType attribute at representation level
        if (!found) {
            for (i = 0; i < adaptation.Representation_asArray.length && !found; i++) {
                representation = adaptation.Representation_asArray[i];
                for (j = 0; j < mimeTypes.length && !found; j++) {
                    if (representation.mimeType.indexOf(mimeTypes[j]) !== -1) {
                        adaptation.type = type;
                        found = true;
                    }
                }
            }
        }

        return found;
    },

    getIsVideo: function(adaptation) {
        return this.getIsType(adaptation, "video", ["video"]);
    },

    getIsAudio: function(adaptation) {
        return this.getIsType(adaptation, "audio", ["audio"]);
    },

    getIsText: function(adaptation) {
        return this.getIsType(adaptation, "text", ["vtt", "ttml", "application/mp4"]);
    },

    // ORANGE: added application/ttml+xml+mp4 for Smoothstreaming subtitles (ttml+xml encapsulated in mp4 binary form)
    getIsTextTrack: function(type) {
        return (type === "text/vtt" || type === "application/ttml+xml" || type === "application/ttml+xml+mp4" || type === "application/mp4");
    },

    getIsMain: function( /*adaptation*/ ) {
        "use strict";
        // TODO : Check "Role" node.
        // TODO : Use this somewhere.
        return false;
    },

    processAdaptation: function(adaptation) {
        "use strict";
        if (adaptation.Representation_asArray !== undefined && adaptation.Representation_asArray !== null) {
            adaptation.Representation_asArray.sort(function(a, b) {
                return a.bandwidth - b.bandwidth;
            });
        }

        return adaptation;
    },

    getDataForId: function(id, manifest, periodIndex) {
        "use strict";
        var adaptations = manifest.Period_asArray[periodIndex].AdaptationSet_asArray,
            i,
            len;

        for (i = 0, len = adaptations.length; i < len; i += 1) {
            if (adaptations[i].hasOwnProperty("id") && adaptations[i].id === id) {
                return adaptations[i];
            }
        }

        return null;
    },

    getDataForIndex: function(index, manifest, periodIndex) {
        "use strict";
        var adaptations;

        if (manifest && periodIndex >= 0) {
            adaptations = manifest.Period_asArray[periodIndex].AdaptationSet_asArray;

            if (adaptations && adaptations.length > 0 && !isNaN(index)) {
                return adaptations[index];
            }
        }

        return [];
    },

    getIndex: function(adaptation, manifest) {
        var periods = manifest.Period_asArray,
            adaptations,
            i,
            j;

        for (i = 0; i < periods.length; i += 1) {
            adaptations = periods[i].AdaptationSet_asArray;
            for (j = 0; j < adaptations.length; j += 1) {
                if (adaptations[j] === adaptation) {
                    return j;
                }
            }
        }

        return -1;
    },

    getDataIndex: function(data, manifest, periodIndex) {
        "use strict";

        var adaptations,
            i,
            len;

        if (manifest && periodIndex >= 0) {
            adaptations = manifest.Period_asArray[periodIndex].AdaptationSet_asArray;

            // ORANGE : compare data with id or string representation to avoid reference error due to manifest refresh
            if (data.id) {
                for (i = 0, len = adaptations.length; i < len; i += 1) {
                    if (adaptations[i].id && adaptations[i].id === data.id) {
                        return i;
                    }
                }
            } else {
                var strData = JSON.stringify(data);
                var strAdapt;
                for (i = 0, len = adaptations.length; i < len; i += 1) {
                    strAdapt = JSON.stringify(adaptations[i]);
                    if (strAdapt === strData) {
                        return i;
                    }
                }
            }
        }

        return -1;
    },

    getVideoData: function(manifest, periodIndex) {
        "use strict";
        //return null;
        //------------------------------------
        var adaptations,
            i;

        if (!manifest || periodIndex < 0) {
            return null;
        }

        adaptations = manifest.Period_asArray[periodIndex].AdaptationSet_asArray;

        if (adaptations.length === 0) {
            return null;
        }

        for (i = 0; i < adaptations.length; i += 1) {
            if (this.getIsVideo(adaptations[i])) {
                return adaptations[i];
            }
        }

        return null;
    },

    getTextDatas: function(manifest, periodIndex) {
        "use strict";
        //return null;
        //------------------------------------
        var adaptations,
            datas = [],
            i;

        if (!manifest || periodIndex < 0) {
            return datas;
        }

        adaptations = manifest.Period_asArray[periodIndex].AdaptationSet_asArray;

        if (adaptations.length === 0) {
            return datas;
        }

        for (i = 0; i < adaptations.length; i += 1) {
            if (this.getIsText(adaptations[i])) {
                datas.push(adaptations[i]);
            }
        }

        return datas;
    },

    getAudioDatas: function(manifest, periodIndex) {
        "use strict";
        //------------------------------------
        var adaptations,
            datas = [],
            i;

        // return datas;

        if (!manifest || periodIndex < 0) {
            return datas;
        }

        adaptations = manifest.Period_asArray[periodIndex].AdaptationSet_asArray;

        if (adaptations.length === 0) {
            return datas;
        }

        for (i = 0; i < adaptations.length; i += 1) {
            if (this.getIsAudio(adaptations[i])) {
                datas.push(adaptations[i]);
            }
        }

        return datas;
    },

    getSpecificAudioData: function(manifest, periodIndex, language) {
        "use strict";
        var i,
            datas;


        if (!manifest || periodIndex < 0) {
            return null;
        }

        datas = this.getAudioDatas(manifest, periodIndex);
        if (datas.length === 0) {
            return null;
        }

        for (i = 0; i < datas.length; i += 1) {
            if (datas[i].lang === language) {
                return this.processAdaptation(datas[i]);
            }
        }

        //if the specific language has not been found, return the first one.
        return this.processAdaptation(datas[0]);
    },

    getSpecificTextData: function(manifest, periodIndex, language) {
        "use strict";
        var i,
            datas;

        if (!manifest || periodIndex < 0) {
            return null;
        }

        datas = this.getTextDatas(manifest, periodIndex);
        if (datas.length === 0) {
            return null;
        }

        for (i = 0; i < datas.length; i += 1) {
            if (datas[i].lang === language) {
                return this.processAdaptation(datas[i]);
            }
        }

        return this.processAdaptation(datas[0]);
    },

    getCodec: function(adaptation) {
        "use strict";
        var i = 0,
            representation,
            codec = null;

        while ((codec === null) && (i < adaptation.Representation_asArray.length)) {
            representation = adaptation.Representation_asArray[i];
            codec = this.getCodecForRepresentation(representation);
            i++;
        }

        return codec;
    },

    getCodecForRepresentation: function(representation) {
        "use strict";
        if (representation.codecs === null || representation.codecs === "") {
            return null;
        }
        return (representation.mimeType + ';codecs="' + representation.codecs + '"');
    },

    getMimeType: function(data) {
        "use strict";
        return data.Representation_asArray[0].mimeType;
    },

    getKID: function(data) {
        "use strict";

        if (!data || !data.hasOwnProperty("cenc:default_KID")) {
            return null;
        }
        return data["cenc:default_KID"];
    },

    getContentProtectionData: function(data) {
        "use strict";
        if (!data || !data.hasOwnProperty("ContentProtection_asArray") || data.ContentProtection_asArray.length === 0) {
            return null;
        }
        return data.ContentProtection_asArray;
    },

    getIsDynamic: function(manifest) {
        "use strict";
        var isDynamic = false,
            LIVE_TYPE = "dynamic";

        if (manifest && manifest.hasOwnProperty("type")) {
            isDynamic = (manifest.type === LIVE_TYPE);
        }

        return isDynamic;
    },

    getIsDVR: function(manifest) {
        "use strict";
        var isDynamic = this.getIsDynamic(manifest),
            containsDVR,
            isDVR;

        containsDVR = !isNaN(manifest.timeShiftBufferDepth);
        isDVR = (isDynamic && containsDVR);

        return isDVR;
    },

    getIsOnDemand: function(manifest) {
        "use strict";
        var isOnDemand = false;

        if (manifest.profiles && manifest.profiles.length > 0) {
            isOnDemand = (manifest.profiles.indexOf("urn:mpeg:dash:profile:isoff-on-demand:2011") !== -1);
        }

        return isOnDemand;
    },

    getIsStartOver: function(manifest) {
        "use strict";
        var isStartOver = false;

        if (manifest && manifest.hasOwnProperty("startOver")) {
            isStartOver = (manifest.startOver === true);
        }

        return isStartOver;
    },

    getDuration: function(manifest) {
        var mpdDuration;

        //@mediaPresentationDuration specifies the duration of the entire Media Presentation.
        //If the attribute is not present, the duration of the Media Presentation is unknown.
        if (manifest && manifest.hasOwnProperty("mediaPresentationDuration")) {
            mpdDuration = manifest.mediaPresentationDuration;
        } else {
            mpdDuration = Number.POSITIVE_INFINITY;
        }

        return mpdDuration;
    },

    getBandwidth: function(representation) {
        "use strict";
        return representation && representation.bandwidth ? representation.bandwidth : NaN;
    },

    getRefreshDelay: function(manifest) {
        "use strict";
        var delay = NaN,
            minDelay = 2;

        if (manifest.hasOwnProperty("minimumUpdatePeriod")) {
            delay = Math.max(parseFloat(manifest.minimumUpdatePeriod), minDelay);
        }

        return delay;
    },

    getRepresentationCount: function(adaptation) {
        "use strict";
        if (adaptation) {
            return adaptation.Representation_asArray.length;
        }

        return null;
    },

    getRepresentationFor: function(index, data) {
        "use strict";
        return data && data.Representation_asArray && data.Representation_asArray.length > 0 &&
            this.isInteger(index) && index < data.Representation_asArray.length ? data.Representation_asArray[index] : null;
    },

    getRepresentationsForAdaptation: function(manifest, adaptation) {
        var a,
            representations = [],
            representation,
            initialization,
            segmentInfo,
            r;

        if (manifest && adaptation) {
            a = this.processAdaptation(manifest.Period_asArray[adaptation.period.index].AdaptationSet_asArray[adaptation.index]);

            for (var i = 0; i < a.Representation_asArray.length; i += 1) {
                r = a.Representation_asArray[i];
                representation = new Dash.vo.Representation();
                representation.index = i;
                representation.adaptation = adaptation;

                if (r.hasOwnProperty("id")) {
                    representation.id = r.id;
                }

                if (r.hasOwnProperty("SegmentBase")) {
                    segmentInfo = r.SegmentBase;
                    representation.segmentInfoType = "SegmentBase";
                } else if (r.hasOwnProperty("SegmentList")) {
                    segmentInfo = r.SegmentList;
                    representation.segmentInfoType = "SegmentList";
                    representation.useCalculatedLiveEdgeTime = true;
                } else if (r.hasOwnProperty("SegmentTemplate")) {
                    segmentInfo = r.SegmentTemplate;

                    if (segmentInfo.hasOwnProperty("SegmentTimeline")) {
                        representation.segmentInfoType = "SegmentTimeline";
                    } else {
                        representation.segmentInfoType = "SegmentTemplate";
                    }

                    if (segmentInfo.hasOwnProperty("initialization")) {
                        representation.initialization = segmentInfo.initialization.split("$Bandwidth$")
                            .join(r.bandwidth).split("$RepresentationID$").join(r.id);
                    }
                } else {
                    segmentInfo = r.BaseURL;
                    representation.segmentInfoType = "BaseURL";
                }

                if (segmentInfo.hasOwnProperty("Initialization")) {
                    initialization = segmentInfo.Initialization;
                    if (initialization.hasOwnProperty("sourceURL")) {
                        representation.initialization = initialization.sourceURL;
                    } else if (initialization.hasOwnProperty("range")) {
                        representation.initialization = r.BaseURL;
                        representation.range = initialization.range;
                    }
                } else if (r.hasOwnProperty("mimeType") && this.getIsTextTrack(r.mimeType) && !representation.initialization) {
                    representation.initialization = r.BaseURL;
                    representation.range = 0;
                }

                if (segmentInfo.hasOwnProperty("timescale")) {
                    representation.timescale = segmentInfo.timescale;
                }
                if (segmentInfo.hasOwnProperty("duration")) {
                    // TODO according to the spec @maxSegmentDuration specifies the maximum duration of any Segment in any Representation in the Media Presentation
                    // It is also said that for a SegmentTimeline any @d value shall not exceed the value of MPD@maxSegmentDuration, but nothing is said about
                    // SegmentTemplate @duration attribute. We need to find out if @maxSegmentDuration should be used instead of calculated duration if the the duration
                    // exceeds @maxSegmentDuration
                    //representation.segmentDuration = Math.min(segmentInfo.duration / representation.timescale, adaptation.period.mpd.maxSegmentDuration);
                    representation.segmentDuration = segmentInfo.duration / representation.timescale;
                }
                if (segmentInfo.hasOwnProperty("startNumber")) {
                    representation.startNumber = segmentInfo.startNumber;
                }
                if (segmentInfo.hasOwnProperty("indexRange")) {
                    representation.indexRange = segmentInfo.indexRange;
                }
                if (segmentInfo.hasOwnProperty("presentationTimeOffset")) {
                    representation.presentationTimeOffset = segmentInfo.presentationTimeOffset / representation.timescale;
                }

                representation.MSETimeOffset = this.timelineConverter.calcMSETimeOffset(representation);
                representations.push(representation);
            }
        }

        return representations;
    },

    getAdaptationsForPeriod: function(manifest, period) {
        var p = manifest === null ? null : manifest.Period_asArray[period.index],
            adaptations = [],
            adaptationSet;

        if (p) {
            for (var i = 0; i < p.AdaptationSet_asArray.length; i += 1) {
                adaptationSet = new Dash.vo.AdaptationSet();
                adaptationSet.index = i;
                adaptationSet.period = period;
                adaptations.push(adaptationSet);
            }
        }

        return adaptations;
    },

    getRegularPeriods: function(manifest, mpd) {
        var periods = [],
            isDynamic = this.getIsDynamic(manifest),
            i,
            len,
            p1 = null,
            p = null,
            vo1 = null,
            vo = null;

        for (i = 0, len = manifest.Period_asArray.length; i < len; i += 1) {
            p = manifest.Period_asArray[i];

            // If the attribute @start is present in the Period, then the
            // Period is a regular Period and the PeriodStart is equal
            // to the value of this attribute.
            if (p.hasOwnProperty("start")) {
                vo = new Dash.vo.Period();
                vo.start = p.start;
            }
            // If the @start attribute is absent, but the previous Period
            // element contains a @duration attribute then then this new
            // Period is also a regular Period. The start time of the new
            // Period PeriodStart is the sum of the start time of the previous
            // Period PeriodStart and the value of the attribute @duration
            // of the previous Period.
            else if (p1 !== null && p.hasOwnProperty("duration")) {
                vo = new Dash.vo.Period();
                vo.start = vo1.start + vo1.duration;
                vo.duration = p.duration;
            }
            // If (i) @start attribute is absent, and (ii) the Period element
            // is the first in the MPD, and (iii) the MPD@type is 'static',
            // then the PeriodStart time shall be set to zero.
            else if (i === 0 && !isDynamic) {
                vo = new Dash.vo.Period();
                vo.start = 0;
            }

            // The Period extends until the PeriodStart of the next Period.
            // The difference between the PeriodStart time of a Period and
            // the PeriodStart time of the following Period.
            if (vo1 !== null && isNaN(vo1.duration)) {
                vo1.duration = vo.start - vo1.start;
            }

            if (vo !== null && p.hasOwnProperty("id")) {
                vo.id = p.id;
            }

            if (vo !== null && p.hasOwnProperty("duration")) {
                vo.duration = p.duration;
            }

            if (vo !== null) {
                vo.index = i;
                vo.mpd = mpd;
                periods.push(vo);
            }

            p1 = p;
            p = null;
            vo1 = vo;
            vo = null;
        }

        if (periods.length === 0) {
            return periods;
        }

        mpd.checkTime = this.getCheckTime(manifest, periods[0]);

        // The last Period extends until the end of the Media Presentation.
        // The difference between the PeriodStart time of the last Period
        // and the mpd duration
        if (vo1 !== null && isNaN(vo1.duration)) {
            vo1.duration = this.getEndTimeForLastPeriod(mpd) - vo1.start;
        }

        return periods;
    },

    getMpd: function(manifest) {
        var mpd = new Dash.vo.Mpd();

        if (manifest) {
            mpd.manifest = manifest;

            if (manifest.hasOwnProperty("availabilityStartTime")) {
                mpd.availabilityStartTime = new Date(manifest.availabilityStartTime.getTime());
            } else {
                mpd.availabilityStartTime = new Date(manifest.mpdLoadedTime.getTime());
            }

            if (manifest.hasOwnProperty("availabilityEndTime")) {
                mpd.availabilityEndTime = new Date(manifest.availabilityEndTime.getTime());
            }

            if (manifest.hasOwnProperty("suggestedPresentationDelay")) {
                mpd.suggestedPresentationDelay = manifest.suggestedPresentationDelay;
            }

            if (manifest.hasOwnProperty("timeShiftBufferDepth")) {
                mpd.timeShiftBufferDepth = manifest.timeShiftBufferDepth;
            }

            if (manifest.hasOwnProperty("maxSegmentDuration")) {
                mpd.maxSegmentDuration = manifest.maxSegmentDuration;
            }

            return mpd;
        }

        return null;
    },

    getFetchTime: function(manifest, period) {
        // FetchTime is defined as the time at which the server processes the request for the MPD from the client.
        // TODO The client typically should not use the time at which it actually successfully received the MPD, but should
        // take into account delay due to MPD delivery and processing. The fetch is considered successful fetching
        // either if the client obtains an updated MPD or the client verifies that the MPD has not been updated since the previous fetching.
        var fetchTime = this.timelineConverter.calcPresentationTimeFromWallTime(manifest.mpdLoadedTime, period);

        return fetchTime;
    },

    getCheckTime: function(manifest, period) {
        var checkTime = NaN;

        // If the MPD@minimumUpdatePeriod attribute in the client is provided, then the check time is defined as the
        // sum of the fetch time of this operating MPD and the value of this attribute,
        // i.e. CheckTime = FetchTime + MPD@minimumUpdatePeriod.
        if (manifest.hasOwnProperty("minimumUpdatePeriod")) {
            checkTime = this.getFetchTime(manifest, period) + manifest.minimumUpdatePeriod;
        }

        return checkTime;
    },

    getEndTimeForLastPeriod: function(mpd) {
        var periodEnd;

        // if the MPD@mediaPresentationDuration attribute is present, then PeriodEndTime is defined as the end time of the Media Presentation.
        // if the MPD@mediaPresentationDuration attribute is not present, then PeriodEndTime is defined as FetchTime + MPD@minimumUpdatePeriod

        if (mpd.manifest.mediaPresentationDuration) {
            periodEnd = mpd.manifest.mediaPresentationDuration;
        } else if (!isNaN(mpd.checkTime)) {
            // in this case the Period End Time should match CheckTime
            periodEnd = mpd.checkTime;
        } else {
            return new Error("Must have @mediaPresentationDuration or @minimumUpdatePeriod on MPD or an explicit @duration on the last period.");
        }

        return periodEnd;
    },

    getEventsForPeriod: function(manifest, period) {
        var periodArray = manifest === null ? null : manifest.Period_asArray,
            eventStreams = periodArray === null ? null : periodArray[period.index].EventStream_asArray,
            events = [];

        if (eventStreams) {
            for (var i = 0; i < eventStreams.length; i += 1) {
                var eventStream = new Dash.vo.EventStream();
                eventStream.period = period;
                eventStream.timescale = 1;

                if (eventStreams[i].hasOwnProperty("schemeIdUri")) {
                    eventStream.schemeIdUri = eventStreams[i].schemeIdUri;
                } else {
                    throw "Invalid EventStream. SchemeIdUri has to be set";
                }
                if (eventStreams[i].hasOwnProperty("timescale")) {
                    eventStream.timescale = eventStreams[i].timescale;
                }
                if (eventStreams[i].hasOwnProperty("value")) {
                    eventStream.value = eventStreams[i].value;
                }
                for (var j = 0; j < eventStreams[i].Event_asArray.length; j += 1) {
                    var event = new Dash.vo.Event();
                    event.presentationTime = 0;
                    event.eventStream = eventStream;

                    if (eventStreams[i].Event_asArray[j].hasOwnProperty("presentationTime")) {
                        event.presentationTime = eventStreams[i].Event_asArray[j].presentationTime;
                    }
                    if (eventStreams[i].Event_asArray[j].hasOwnProperty("duration")) {
                        event.duration = eventStreams[i].Event_asArray[j].duration;
                    }
                    if (eventStreams[i].Event_asArray[j].hasOwnProperty("id")) {
                        event.id = eventStreams[i].Event_asArray[j].id;
                    }
                    events.push(event);
                }
            }
        }

        return events;
    },

    getEventStreamForAdaptationSet: function(data) {

        var eventStreams = [],
            inbandStreams;

        if (data) {
            inbandStreams = data.InbandEventStream_asArray;

            if (inbandStreams) {
                for (var i = 0; i < inbandStreams.length; i += 1) {
                    var eventStream = new Dash.vo.EventStream();
                    eventStream.timescale = 1;

                    if (inbandStreams[i].hasOwnProperty("schemeIdUri")) {
                        eventStream.schemeIdUri = inbandStreams[i].schemeIdUri;
                    } else {
                        throw "Invalid EventStream. SchemeIdUri has to be set";
                    }
                    if (inbandStreams[i].hasOwnProperty("timescale")) {
                        eventStream.timescale = inbandStreams[i].timescale;
                    }
                    if (inbandStreams[i].hasOwnProperty("value")) {
                        eventStream.value = inbandStreams[i].value;
                    }
                    eventStreams.push(eventStream);
                }
            }
        }

        return eventStreams;
    },

    getEventStreamForRepresentation: function(data, representation) {

        var eventStreams = [],
            inbandStreams;

        if (data && representation) {

            inbandStreams = data.Representation_asArray[representation.index].InbandEventStream_asArray;

            if (inbandStreams) {
                for (var i = 0; i < inbandStreams.length; i++) {
                    var eventStream = new Dash.vo.EventStream();
                    eventStream.timescale = 1;
                    eventStream.representation = representation;

                    if (inbandStreams[i].hasOwnProperty("schemeIdUri")) {
                        eventStream.schemeIdUri = inbandStreams[i].schemeIdUri;
                    } else {
                        throw "Invalid EventStream. SchemeIdUri has to be set";
                    }
                    if (inbandStreams[i].hasOwnProperty("timescale")) {
                        eventStream.timescale = inbandStreams[i].timescale;
                    }
                    if (inbandStreams[i].hasOwnProperty("value")) {
                        eventStream.value = inbandStreams[i].value;
                    }
                    eventStreams.push(eventStream);
                }
            }
        }

        return eventStreams;

    },

    getRepresentationBandwidth: function(adaptation, index) {
        return this.getBandwidth(this.getRepresentationFor(index, adaptation));
    }

};
/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Digital Primates
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
Dash.dependencies.DashMetricsExtensions = function() {
    "use strict";
    var findRepresentationIndexInPeriodArray = function(periodArray, representationId) {
            var period,
                adaptationSet,
                adaptationSetArray,
                representation,
                representationArray,
                periodArrayIndex,
                adaptationSetArrayIndex,
                representationArrayIndex;

            for (periodArrayIndex = 0; periodArrayIndex < periodArray.length; periodArrayIndex = periodArrayIndex + 1) {
                period = periodArray[periodArrayIndex];
                adaptationSetArray = period.AdaptationSet_asArray;
                for (adaptationSetArrayIndex = 0; adaptationSetArrayIndex < adaptationSetArray.length; adaptationSetArrayIndex = adaptationSetArrayIndex + 1) {
                    adaptationSet = adaptationSetArray[adaptationSetArrayIndex];
                    representationArray = adaptationSet.Representation_asArray;
                    for (representationArrayIndex = 0; representationArrayIndex < representationArray.length; representationArrayIndex = representationArrayIndex + 1) {
                        representation = representationArray[representationArrayIndex];
                        if (representationId === representation.id) {
                            return representationArrayIndex;
                        }
                    }
                }
            }

            return -1;
        },

        findRepresentionInPeriodArray = function(periodArray, representationId) {
            var period,
                adaptationSet,
                adaptationSetArray,
                representation,
                representationArray,
                periodArrayIndex,
                adaptationSetArrayIndex,
                representationArrayIndex;

            for (periodArrayIndex = 0; periodArrayIndex < periodArray.length; periodArrayIndex = periodArrayIndex + 1) {
                period = periodArray[periodArrayIndex];
                adaptationSetArray = period.AdaptationSet_asArray;
                for (adaptationSetArrayIndex = 0; adaptationSetArrayIndex < adaptationSetArray.length; adaptationSetArrayIndex = adaptationSetArrayIndex + 1) {
                    adaptationSet = adaptationSetArray[adaptationSetArrayIndex];
                    representationArray = adaptationSet.Representation_asArray;
                    for (representationArrayIndex = 0; representationArrayIndex < representationArray.length; representationArrayIndex = representationArrayIndex + 1) {
                        representation = representationArray[representationArrayIndex];
                        if (representationId === representation.id) {
                            return representation;
                        }
                    }
                }
            }

            return null;
        },

        adaptationIsType = function(adaptation, bufferType) {
            var found = false;

            // TODO : HACK ATTACK
            // Below we call getIsVideo and getIsAudio and then check the adaptation set for a 'type' property.
            // getIsVideo and getIsAudio are adding this 'type' property and SHOULD NOT BE.
            // This method expects getIsVideo and getIsAudio to be sync, but they are async (returns a promise).
            // This is a bad workaround!
            // The metrics extensions should have every method use promises.

            if (bufferType === "video") {
                //found = this.manifestExt.getIsVideo(adaptation);
                this.manifestExt.getIsVideo(adaptation);
                if (adaptation.type === "video") {
                    found = true;
                }
            } else if (bufferType === "audio") {
                //found = this.manifestExt.getIsAudio(adaptation); // TODO : Have to be sure it's the *active* audio track.
                this.manifestExt.getIsAudio(adaptation);
                if (adaptation.type === "audio") {
                    found = true;
                }
            } else {
                found = false;
            }

            return found;
        },

        findMaxBufferIndex = function(periodArray, bufferType) {
            var period,
                adaptationSet,
                adaptationSetArray,
                representationArray,
                periodArrayIndex,
                adaptationSetArrayIndex;

            for (periodArrayIndex = 0; periodArrayIndex < periodArray.length; periodArrayIndex = periodArrayIndex + 1) {
                period = periodArray[periodArrayIndex];
                adaptationSetArray = period.AdaptationSet_asArray;
                for (adaptationSetArrayIndex = 0; adaptationSetArrayIndex < adaptationSetArray.length; adaptationSetArrayIndex = adaptationSetArrayIndex + 1) {
                    adaptationSet = adaptationSetArray[adaptationSetArrayIndex];
                    representationArray = adaptationSet.Representation_asArray;
                    if (adaptationIsType.call(this, adaptationSet, bufferType)) {
                        return representationArray.length;
                    }
                }
            }

            return -1;
        },

        getBandwidthForRepresentation = function(representationId) {
            var self = this,
                manifest = self.manifestModel.getValue(),
                representation,
                periodArray = manifest === null ? null : manifest.Period_asArray;

            if (periodArray) {
                representation = findRepresentionInPeriodArray.call(self, periodArray, representationId);

                if (representation === null) {
                    return null;
                }

                return representation.bandwidth;
            }

            return null;
        },

        getIndexForRepresentation = function(representationId) {
            var self = this,
                manifest = self.manifestModel.getValue(),
                representationIndex,
                periodArray = manifest === null ? null : manifest.Period_asArray;

            if (periodArray) {
                representationIndex = findRepresentationIndexInPeriodArray.call(self, periodArray, representationId);
                return representationIndex;
            }

            return null;
        },

        getMaxIndexForBufferType = function(bufferType) {
            var self = this,
                manifest = self.manifestModel.getValue(),
                maxIndex,
                periodArray = manifest === null ? null : manifest.Period_asArray;

            if (periodArray) {
                maxIndex = findMaxBufferIndex.call(this, periodArray, bufferType);
                return maxIndex;
            }

            return null;
        },

        getCurrentRepresentationSwitch = function(metrics) {
            if (metrics === null) {
                return null;
            }

            var repSwitch = metrics.RepSwitchList,
                repSwitchLength,
                repSwitchLastIndex,
                currentRepSwitch;

            if (repSwitch === null || repSwitch.length <= 0) {
                return null;
            }

            repSwitchLength = repSwitch.length;
            repSwitchLastIndex = repSwitchLength - 1;

            currentRepSwitch = repSwitch[repSwitchLastIndex];
            return currentRepSwitch;
        },

        getCurrentBufferLevel = function(metrics) {
            if (metrics === null) {
                return null;
            }

            var bufferLevel = metrics.BufferLevel,
                bufferLevelLength,
                bufferLevelLastIndex,
                currentBufferLevel;

            if (bufferLevel === null || bufferLevel.length <= 0) {
                return null;
            }

            bufferLevelLength = bufferLevel.length;
            bufferLevelLastIndex = bufferLevelLength - 1;

            currentBufferLevel = bufferLevel[bufferLevelLastIndex];
            return currentBufferLevel;
        },

        getCurrentHttpRequest = function(metrics) {
            if (metrics === null) {
                return null;
            }

            var httpList = metrics.HttpList,
                httpListLength,
                httpListLastIndex,
                currentHttpList = null;

            if (httpList === null || httpList.length <= 0) {
                return null;
            }

            httpListLength = httpList.length;
            httpListLastIndex = httpListLength - 1;

            // ORANGE: if only 1 item, then was ignored
            //while (httpListLastIndex > 0) {
            while (httpListLastIndex >= 0) {
                if (httpList[httpListLastIndex].responsecode !== null) {
                    currentHttpList = httpList[httpListLastIndex];
                    break;
                }
                httpListLastIndex -= 1;
            }
            return currentHttpList;
        },

        getHttpRequests = function(metrics) {
            if (metrics === null) {
                return [];
            }

            return !!metrics.HttpList ? metrics.HttpList : [];
        },

        getCurrentDroppedFrames = function(metrics) {
            if (metrics === null) {
                return null;
            }

            var droppedFrames = metrics.DroppedFrames,
                droppedFramesLength,
                droppedFramesLastIndex,
                currentDroppedFrames;

            if (droppedFrames === null || droppedFrames.length <= 0) {
                return null;
            }

            droppedFramesLength = droppedFrames.length;
            droppedFramesLastIndex = droppedFramesLength - 1;
            currentDroppedFrames = droppedFrames[droppedFramesLastIndex];

            return currentDroppedFrames;
        },

        getCurrentPlaybackQuality = function(metrics) {

            if (metrics === null) {
                return null;
            }

            var playbackQuality = metrics.PlaybackQuality;

            if (playbackQuality === null || playbackQuality.length <= 0) {
                return null;
            }

            return playbackQuality[playbackQuality.length-1];
        },

        getCurrentDVRInfo = function(metrics) {

            if (metrics === null) {
                return null;
            }

            var dvrInfo = metrics.DVRInfo,
                dvrInfoLastIndex,
                curentDVRInfo = null;

            if (dvrInfo === null || dvrInfo.length <= 0) {
                return null;
            }

            dvrInfoLastIndex = dvrInfo.length - 1;
            curentDVRInfo = dvrInfo[dvrInfoLastIndex];

            return curentDVRInfo;
        },

        getCurrentManifestUpdate = function(metrics) {
            if (metrics === null) {
                return null;
            }

            var manifestUpdate = metrics.ManifestUpdate,
                ln,
                lastIdx,
                currentManifestUpdate;

            if (manifestUpdate === null || manifestUpdate.length <= 0) {
                return null;
            }

            ln = manifestUpdate.length;
            lastIdx = ln - 1;

            currentManifestUpdate = manifestUpdate[lastIdx];

            return currentManifestUpdate;
        };

    return {
        manifestModel: undefined,
        manifestExt: undefined,
        getBandwidthForRepresentation: getBandwidthForRepresentation,
        getIndexForRepresentation: getIndexForRepresentation,
        getMaxIndexForBufferType: getMaxIndexForBufferType,
        getCurrentRepresentationSwitch: getCurrentRepresentationSwitch,
        getCurrentBufferLevel: getCurrentBufferLevel,
        getCurrentHttpRequest: getCurrentHttpRequest,
        getHttpRequests: getHttpRequests,
        getCurrentDroppedFrames: getCurrentDroppedFrames,
        getCurrentPlaybackQuality: getCurrentPlaybackQuality,
        getCurrentDVRInfo: getCurrentDVRInfo,
        getCurrentManifestUpdate: getCurrentManifestUpdate
    };
};

Dash.dependencies.DashMetricsExtensions.prototype = {
    constructor: Dash.dependencies.DashMetricsExtensions
};
/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 * 
 * Copyright (c) 2013, Digital Primates
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
Dash.dependencies.DashParser = function () {
    "use strict";

    var SECONDS_IN_YEAR = 365 * 24 * 60 * 60,
        SECONDS_IN_MONTH = 30 * 24 * 60 * 60, // not precise!
        SECONDS_IN_DAY = 24 * 60 * 60,
        SECONDS_IN_HOUR = 60 * 60,
        SECONDS_IN_MIN = 60,
        MINUTES_IN_HOUR = 60,
        MILLISECONDS_IN_SECONDS = 1000,
        durationRegex = /^P(([\d.]*)Y)?(([\d.]*)M)?(([\d.]*)D)?T?(([\d.]*)H)?(([\d.]*)M)?(([\d.]*)S)?/,
        datetimeRegex = /^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2})(?::([0-9]*)(\.[0-9]*)?)?(?:([+-])([0-9]{2})([0-9]{2}))?/,
        numericRegex = /^[-+]?[0-9]+[.]?[0-9]*([eE][-+]?[0-9]+)?$/,
        matchers = [
            {
                type: "duration",
                test: function (str) {
                    return durationRegex.test(str);
                },
                converter: function (str) {
                    //str = "P10Y10M10DT10H10M10.1S";
                    var match = durationRegex.exec(str);
                    return (parseFloat(match[2] || 0) * SECONDS_IN_YEAR +
                            parseFloat(match[4] || 0) * SECONDS_IN_MONTH +
                            parseFloat(match[6] || 0) * SECONDS_IN_DAY +
                            parseFloat(match[8] || 0) * SECONDS_IN_HOUR +
                            parseFloat(match[10] || 0) * SECONDS_IN_MIN +
                            parseFloat(match[12] || 0));
                }
            },
            {
                type: "datetime",
                test: function (str) {
                    return datetimeRegex.test(str);
                },
                converter: function (str) {
                    var match = datetimeRegex.exec(str),
                        utcDate;
                    // If the string does not contain a timezone offset different browsers can interpret it either
                    // as UTC or as a local time so we have to parse the string manually to normalize the given date value for
                    // all browsers
                    utcDate = Date.UTC(
                        parseInt(match[1], 10),
                        parseInt(match[2], 10)-1, // months start from zero
                        parseInt(match[3], 10),
                        parseInt(match[4], 10),
                        parseInt(match[5], 10),
                        (match[6] && parseInt(match[6], 10) || 0),
                        (match[7] && parseFloat(match[7]) * MILLISECONDS_IN_SECONDS) || 0);
                    // If the date has timezone offset take it into account as well
                    if (match[9] && match[10]) {
                        var timezoneOffset = parseInt(match[9], 10) * MINUTES_IN_HOUR + parseInt(match[10], 10);
                        utcDate += (match[8] === '+' ? -1 : +1) * timezoneOffset * SECONDS_IN_MIN * MILLISECONDS_IN_SECONDS;
                    }

                    return new Date(utcDate);
                }
            },
            {
                type: "numeric",
                test: function (str) {
                    return numericRegex.test(str);
                },
                converter: function (str) {
                    return parseFloat(str);
                }
            }
        ],

        getCommonValuesMap = function () {
            var adaptationSet,
                representation,
                subRepresentation,
                common;

            common = [
                {
                    name: 'profiles',
                    merge: false
                },
                {
                    name: 'width',
                    merge: false
                },
                {
                    name: 'height',
                    merge: false
                },
                {
                    name: 'sar',
                    merge: false
                },
                {
                    name: 'frameRate',
                    merge: false
                },
                {
                    name: 'audioSamplingRate',
                    merge: false
                },
                {
                    name: 'mimeType',
                    merge: false
                },
                {
                    name: 'segmentProfiles',
                    merge: false
                },
                {
                    name: 'codecs',
                    merge: false
                },
                {
                    name: 'maximumSAPPeriod',
                    merge: false
                },
                {
                    name: 'startsWithSap',
                    merge: false
                },
                {
                    name: 'maxPlayoutRate',
                    merge: false
                },
                {
                    name: 'codingDependency',
                    merge: false
                },
                {
                    name: 'scanType',
                    merge: false
                },
                {
                    name: 'FramePacking',
                    merge: true
                },
                {
                    name: 'AudioChannelConfiguration',
                    merge: true
                },
                {
                    name: 'ContentProtection',
                    merge: true
                }
            ];

            adaptationSet = {};
            adaptationSet.name = "AdaptationSet";
            adaptationSet.isRoot = false;
            adaptationSet.isArray = true;
            adaptationSet.parent = null;
            adaptationSet.children = [];
            adaptationSet.properties = common;

            representation = {};
            representation.name = "Representation";
            representation.isRoot = false;
            representation.isArray = true;
            representation.parent = adaptationSet;
            representation.children = [];
            representation.properties = common;
            adaptationSet.children.push(representation);

            subRepresentation = {};
            subRepresentation.name = "SubRepresentation";
            subRepresentation.isRoot = false;
            subRepresentation.isArray = true;
            subRepresentation.parent = representation;
            subRepresentation.children = [];
            subRepresentation.properties = common;
            representation.children.push(subRepresentation);

            return adaptationSet;
        },

        getSegmentValuesMap = function () {
            var period,
                adaptationSet,
                representation,
                common;

            common = [
                {
                    name: 'SegmentBase',
                    merge: true
                },
                {
                    name: 'SegmentTemplate',
                    merge: true
                },
                {
                    name: 'SegmentList',
                    merge: true
                }
            ];

            period = {};
            period.name = "Period";
            period.isRoot = false;
            period.isArray = true;
            period.parent = null;
            period.children = [];
            period.properties = common;

            adaptationSet = {};
            adaptationSet.name = "AdaptationSet";
            adaptationSet.isRoot = false;
            adaptationSet.isArray = true;
            adaptationSet.parent = period;
            adaptationSet.children = [];
            adaptationSet.properties = common;
            period.children.push(adaptationSet);

            representation = {};
            representation.name = "Representation";
            representation.isRoot = false;
            representation.isArray = true;
            representation.parent = adaptationSet;
            representation.children = [];
            representation.properties = common;
            adaptationSet.children.push(representation);

            return period;
        },

        getBaseUrlValuesMap = function () {
            var mpd,
                period,
                adaptationSet,
                representation,
                common;

            common = [
                {
                    name: 'BaseURL',
                    merge: true,
                    mergeFunction: function (parentValue, childValue) {
                        var mergedValue;

                        // child is absolute, don't merge
                        if (childValue.indexOf("http://") === 0) {
                            mergedValue = childValue;
                        } else {
                            mergedValue = parentValue + childValue;
                        }

                        return mergedValue;
                    }
                }
            ];

            mpd = {};
            mpd.name = "mpd";
            mpd.isRoot = true;
            mpd.isArray = true;
            mpd.parent = null;
            mpd.children = [];
            mpd.properties = common;

            period = {};
            period.name = "Period";
            period.isRoot = false;
            period.isArray = true;
            period.parent = null;
            period.children = [];
            period.properties = common;
            mpd.children.push(period);

            adaptationSet = {};
            adaptationSet.name = "AdaptationSet";
            adaptationSet.isRoot = false;
            adaptationSet.isArray = true;
            adaptationSet.parent = period;
            adaptationSet.children = [];
            adaptationSet.properties = common;
            period.children.push(adaptationSet);

            representation = {};
            representation.name = "Representation";
            representation.isRoot = false;
            representation.isArray = true;
            representation.parent = adaptationSet;
            representation.children = [];
            representation.properties = common;
            adaptationSet.children.push(representation);

            return mpd;
        },

        getDashMap = function () {
            var result = [];

            result.push(getCommonValuesMap());
            result.push(getSegmentValuesMap());
            result.push(getBaseUrlValuesMap());

            return result;
        },

        internalParse = function (data, baseUrl) {
            //this.debug.log("Doing parse.");

            var manifest,
                converter = new X2JS(matchers, '', true),
                iron = new ObjectIron(getDashMap()),
                start = new Date(),
                json = null,
                ironed = null;

            try {
                //this.debug.log("Converting from XML.");
                manifest = converter.xml_str2json(data);
                json = new Date();

                if (!manifest.hasOwnProperty("BaseURL")) {
                    //this.debug.log("Setting baseURL: " + baseUrl);
                    manifest.BaseURL = baseUrl;
                } else {
                    // Setting manifest's BaseURL to the first BaseURL
                    manifest.BaseURL = manifest.BaseURL_asArray[0];

                    if (manifest.BaseURL.toString().indexOf("http") !== 0) {
                        manifest.BaseURL = baseUrl + manifest.BaseURL;
                    }
                }

                //this.debug.log("Flatten manifest properties.");
                iron.run(manifest);
                ironed = new Date();

                this.debug.log("Parsing complete: ( xml2json: " + (json.getTime() - start.getTime()) + "ms, objectiron: " + (ironed.getTime() - json.getTime()) + "ms, total: " + ((ironed.getTime() - start.getTime()) / 1000) + "s)");
 
            } catch (e) {
                return Q.reject(null);
            }

            return Q.when(manifest);
        };

    return {
        debug: undefined,
        parse: internalParse
    };
};

Dash.dependencies.DashParser.prototype = {
    constructor: Dash.dependencies.DashParser
};

/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 * 
 * Copyright (c) 2013, Digital Primates
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
Dash.dependencies.FragmentExtensions = function () {
    "use strict";

    var parseTFDT = function (ab) {
            var d = new DataView(ab),
                pos = 0,
                base_media_decode_time,
                version,
                size,
                type,
                i,
                c;

            while (type !== "tfdt" && pos < d.byteLength) {
                size = d.getUint32(pos); // subtract 8 for including the size and type
                pos += 4;

                type = "";
                for (i = 0; i < 4; i += 1) {
                    c = d.getInt8(pos);
                    type += String.fromCharCode(c);
                    pos += 1;
                }

                if (type !== "moof" && type !== "traf" && type !== "tfdt") {
                    pos += size - 8;
                }
            }

            if (pos === d.byteLength) {
                throw "Error finding live offset.";
            }

            version = d.getUint8(pos);

            this.debug.log("position: " + pos);

            if (version === 0) {
                pos += 4;
                base_media_decode_time = d.getUint32(pos, false);
            } else {
                pos += size - 16;
                base_media_decode_time = utils.Math.to64BitNumber(d.getUint32(pos + 4, false), d.getUint32(pos, false));
            }

            return {
                'version' : version,
                'base_media_decode_time' : base_media_decode_time
            };
        },

        parseSIDX = function (ab) {
            var d = new DataView(ab),
                pos = 0,
                version,
                timescale,
                earliest_presentation_time,
                i,
                type,
                size,
                charCode;

            while (type !== "sidx" && pos < d.byteLength) {
                size = d.getUint32(pos); // subtract 8 for including the size and type
                pos += 4;

                type = "";
                for (i = 0; i < 4; i += 1) {
                    charCode = d.getInt8(pos);
                    type += String.fromCharCode(charCode);
                    pos += 1;
                }

                if (type !== "moof" && type !== "traf" && type !== "sidx") {
                    pos += size - 8;
                } else if (type === "sidx") {
                    // reset the position to the beginning of the box...
                    // if we do not reset the position, the evaluation
                    // of sidxEnd to ab.byteLength will fail.
                    pos -= 8;
                }
            }

            version = d.getUint8(pos + 8);
            pos += 12;

            // skipped reference_ID(32)
            timescale = d.getUint32(pos + 4, false);
            pos += 8;

            if (version === 0) {
                earliest_presentation_time = d.getUint32(pos, false);
            } else {
                earliest_presentation_time = utils.Math.to64BitNumber(d.getUint32(pos + 4, false), d.getUint32(pos, false));
            }

            return Q.when({
                'earliestPresentationTime' : earliest_presentation_time,
                'timescale' : timescale
            });
        },

        loadFragment = function (media) {
            var deferred = Q.defer(),
                request = new XMLHttpRequest(),
                url,
                loaded = false,
                errorStr,
                parsed;

            url = media;

            request.onloadend = function () {
                if (!loaded) {
                    errorStr = "Error loading fragment: " + url;
                    deferred.reject(errorStr);
                }
            };

            request.onload = function () {
                loaded = true;
                parsed = parseTFDT(request.response);
                deferred.resolve(parsed);
            };

            request.onerror = function () {
                errorStr = "Error loading fragment: " + url;
                deferred.reject(errorStr);
            };

            request.open("GET", url);
            request.responseType = "arraybuffer";
            request.send(null);

            return deferred.promise;
        };

    return {
        debug : undefined,
        loadFragment : loadFragment,
        parseTFDT : parseTFDT,
        parseSIDX : parseSIDX
    };
};

Dash.dependencies.FragmentExtensions.prototype = {
    constructor: Dash.dependencies.FragmentExtensions
};

/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Digital Primates
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
Dash.dependencies.TimelineConverter = function() {
    "use strict";

    var clientServerTimeShift = 0,

        calcAvailabilityTimeFromPresentationTime = function(presentationTime, mpd, isDynamic, calculateEnd) {
            var availabilityTime = NaN;

            if (calculateEnd) {
                //@timeShiftBufferDepth specifies the duration of the time shifting buffer that is guaranteed
                // to be available for a Media Presentation with type 'dynamic'.
                // When not present, the value is infinite.
                if (isDynamic && (mpd.timeShiftBufferDepth !== Number.POSITIVE_INFINITY)) {
                    availabilityTime = new Date(mpd.availabilityStartTime.getTime() + ((presentationTime + mpd.timeShiftBufferDepth) * 1000));
                } else {
                    availabilityTime = mpd.availabilityEndTime;
                }
            } else {
                if (isDynamic) {
                    availabilityTime = new Date(mpd.availabilityStartTime.getTime() + (presentationTime * 1000));
                } else {
                    // in static mpd, all segments are available at the same time
                    availabilityTime = mpd.availabilityStartTime;
                }
            }

            return availabilityTime;
        },

        calcAvailabilityStartTimeFromPresentationTime = function(presentationTime, mpd, isDynamic) {
            return calcAvailabilityTimeFromPresentationTime.call(this, presentationTime, mpd, isDynamic);
        },

        calcAvailabilityEndTimeFromPresentationTime = function(presentationTime, mpd, isDynamic) {
            return calcAvailabilityTimeFromPresentationTime.call(this, presentationTime, mpd, isDynamic, true);
        },

        calcPresentationStartTime = function(period) {
            var presentationStartTime,
                isDynamic = period.mpd.manifest.type === "dynamic",
                //ORANGE: fix bug on not updating URIFragmentDataVO
                startTimeOffset = parseInt(this.uriQueryFragModel.getURIFragmentData().s, 10);

            if (isDynamic) {

                if (!isNaN(startTimeOffset) && startTimeOffset > 1262304000) {

                    presentationStartTime = startTimeOffset - (period.mpd.availabilityStartTime.getTime() / 1000);

                    if (presentationStartTime > period.liveEdge ||
                        presentationStartTime < (period.liveEdge - period.mpd.timeShiftBufferDepth)) {

                        presentationStartTime = null;
                    }
                }
                presentationStartTime = presentationStartTime || period.liveEdge;

            } else {
                if (!isNaN(startTimeOffset) && startTimeOffset < period.duration && startTimeOffset >= 0) {
                    presentationStartTime = startTimeOffset;
                } else {
                    presentationStartTime = period.start;
                }
            }

            return presentationStartTime;
        },

        calcPresentationTimeFromWallTime = function(wallTime, period) {
            return ((wallTime.getTime() - period.mpd.availabilityStartTime.getTime()) / 1000);
        },

        calcPresentationTimeFromMediaTime = function(mediaTime, representation) {
            var presentationOffset = representation.presentationTimeOffset;

            return mediaTime - presentationOffset;
        },

        calcMediaTimeFromPresentationTime = function(presentationTime, representation) {
            var presentationOffset = representation.presentationTimeOffset;

            return (presentationOffset + presentationTime);
        },

        calcWallTimeForSegment = function(segment, isDynamic) {
            var suggestedPresentationDelay,
                displayStartTime,
                wallTime;

            if (isDynamic) {
                suggestedPresentationDelay = segment.representation.adaptation.period.mpd.suggestedPresentationDelay;
                displayStartTime = segment.presentationStartTime + suggestedPresentationDelay;
                wallTime = new Date(segment.availabilityStartTime.getTime() + (displayStartTime * 1000));
            }

            return wallTime;
        },

        calcActualPresentationTime = function(representation, currentTime, isDynamic) {
            var self = this,
                //periodStart = representation.adaptation.period.start,
                availabilityWindow = self.calcSegmentAvailabilityRange(representation, isDynamic),
                actualTime;

            // ORANGE: confusion to resolve between availabilityWindow.start and periodStart.
            // (in MSS case, periodStart is set to availabilityWindow.start)
            //if ((currentTime >= (availabilityWindow.start + periodStart)) && (currentTime <= (availabilityWindow.end + periodStart))) {
            if ((currentTime >= (availabilityWindow.start)) && (currentTime <= (availabilityWindow.end))) {
                return currentTime;
            }

            actualTime = Math.max(availabilityWindow.end - representation.adaptation.period.mpd.manifest.minBufferTime * 2, availabilityWindow.start);

            return actualTime;
        },

        calcSegmentAvailabilityRange = function(representation, isDynamic) {
            var duration = representation.segmentDuration,
                start = 0,
                end = representation.adaptation.period.duration,
                range = {
                    start: start,
                    end: end
                },
                checkTime,
                now;

            if (!isDynamic) {
                return range;
            }

            if ((!representation.adaptation.period.mpd.isClientServerTimeSyncCompleted || isNaN(duration)) && representation.segmentAvailabilityRange) {
                return representation.segmentAvailabilityRange;
            }

            checkTime = representation.adaptation.period.mpd.checkTime;
            now = calcPresentationTimeFromWallTime(new Date((new Date().getTime()) + clientServerTimeShift), representation.adaptation.period);
            //the Media Segment list is further restricted by the CheckTime together with the MPD attribute
            // MPD@timeShiftBufferDepth such that only Media Segments for which the sum of the start time of the
            // Media Segment and the Period start time falls in the interval [NOW- MPD@timeShiftBufferDepth - @duration, min(CheckTime, NOW)] are included.
            start = Math.max((now - representation.adaptation.period.mpd.timeShiftBufferDepth), 0);
            checkTime += (clientServerTimeShift / 1000);
            end = isNaN(checkTime) ? now : Math.min(checkTime, now);
            range = {
                start: start,
                end: end
            };

            return range;
        },

        /*liveEdgeFound = function(expectedLiveEdge, actualLiveEdge, period) {
            if (period.mpd.isClientServerTimeSyncCompleted) return;

            // the difference between expected and actual live edge time is supposed to be a difference between client
            // and server time as well
            period.mpd.clientServerTimeShift = actualLiveEdge - expectedLiveEdge;
            period.mpd.isClientServerTimeSyncCompleted = true;
            clientServerTimeShift = period.mpd.clientServerTimeShift * 1000;
        },*/

        calcMSETimeOffset = function(representation) {
            var presentationOffset = representation.presentationTimeOffset;

            return (-presentationOffset);
        };

    return {
        system: undefined,
        debug: undefined,
        uriQueryFragModel: undefined,

        setup: function() {
            //this.system.mapHandler("liveEdgeFound", undefined, liveEdgeFound.bind(this));
        },

        calcAvailabilityStartTimeFromPresentationTime: calcAvailabilityStartTimeFromPresentationTime,
        calcAvailabilityEndTimeFromPresentationTime: calcAvailabilityEndTimeFromPresentationTime,
        calcPresentationTimeFromWallTime: calcPresentationTimeFromWallTime,
        calcPresentationTimeFromMediaTime: calcPresentationTimeFromMediaTime,
        calcPresentationStartTime: calcPresentationStartTime,
        calcActualPresentationTime: calcActualPresentationTime,
        calcMediaTimeFromPresentationTime: calcMediaTimeFromPresentationTime,
        calcSegmentAvailabilityRange: calcSegmentAvailabilityRange,
        calcWallTimeForSegment: calcWallTimeForSegment,
        calcMSETimeOffset: calcMSETimeOffset
    };
};

Dash.dependencies.TimelineConverter.prototype = {
    constructor: Dash.dependencies.TimelineConverter
};
/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 * 
 * Copyright (c) 2013, Digital Primates
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
Dash.vo.AdaptationSet = function () {
    "use strict";
    this.period = null;
    this.index = -1;
};

Dash.vo.AdaptationSet.prototype = {
    constructor: Dash.vo.AdaptationSet
};
/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Fraunhofer Fokus
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
Dash.vo.Event = function () {
    "use strict";
    this.duration = NaN;
    this.presentationTime = NaN;
    this.id = NaN;
    this.messageData = "";
    this.eventStream = null;
    this.presentationTimeDelta = NaN; // Specific EMSG Box paramater

};

Dash.vo.Event.prototype = {
    constructor: Dash.vo.Event
};

/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Fraunhofer Fokus
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
Dash.vo.EventStream = function () {
    "use strict";
    this.adaptionSet = null;
    this.representation = null;
    this.period = null;
    this.timescale = 1;
    this.value = "";
    this.schemeIdUri = "";
};

Dash.vo.EventStream.prototype = {
    constructor: Dash.vo.EventStream
};

/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 * 
 * Copyright (c) 2013, Digital Primates
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
Dash.vo.Mpd = function () {
    "use strict";
    this.manifest = null;
    this.suggestedPresentationDelay = 0;
    this.availabilityStartTime = null;
    this.availabilityEndTime = Number.POSITIVE_INFINITY;
    this.timeShiftBufferDepth = Number.POSITIVE_INFINITY;
    this.maxSegmentDuration = Number.POSITIVE_INFINITY;
    this.checkTime = NaN;
    this.clientServerTimeShift = 0;
    this.isClientServerTimeSyncCompleted = false;
};

Dash.vo.Mpd.prototype = {
    constructor: Dash.vo.Mpd
};
/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 * 
 * Copyright (c) 2013, Digital Primates
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
Dash.vo.Period = function () {
    "use strict";
    this.id = null;
    this.index = -1;
    this.duration = NaN;
    this.start = NaN;
    this.mpd = null;
    this.liveEdge = NaN;
};

Dash.vo.Period.prototype = {
    constructor: Dash.vo.Period
};
/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 * 
 * Copyright (c) 2013, Digital Primates
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
Dash.vo.Representation = function () {
    "use strict";
    this.id = null;
    this.index = -1;
    this.adaptation = null;
    this.segmentInfoType = null;
    this.initialization = null;
    this.segmentDuration = NaN;
    this.timescale = 1;
    this.startNumber = 1;
    this.indexRange = null;
    this.range = null;
    this.presentationTimeOffset = 0;
    // Set the source buffer timeOffset to this
    this.MSETimeOffset = NaN;
    this.segmentAvailabilityRange = null;
    this.availableSegmentsNumber = 0;
};

Dash.vo.Representation.prototype = {
    constructor: Dash.vo.Representation
};
/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 * 
 * Copyright (c) 2013, Digital Primates
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
Dash.vo.Segment = function () {
    "use strict";
    this.indexRange = null;
    this.index = null;
    this.mediaRange = null;
    this.media = null;
    this.duration = NaN;
    // this is the time that should be inserted into the media url
    this.replacementTime = null;
    // this is the number that should be inserted into the media url
    this.replacementNumber = NaN;
    // This is supposed to match the time encoded in the media Segment
    this.mediaStartTime = NaN;
    // When the source buffer timeOffset is set to MSETimeOffset this is the 
    // time that will match the seekTarget and video.currentTime
    this.presentationStartTime = NaN;
    // Do not schedule this segment until 
    this.availabilityStartTime = NaN;
    // Ignore and  discard this segment after
    this.availabilityEndTime = NaN;
    // The index of the segment inside the availability window
    this.availabilityIdx = NaN;
    // For dynamic mpd's, this is the wall clock time that the video   
    // element currentTime should be presentationStartTime
    this.wallStartTime = NaN;
    this.representation = null;
};

Dash.vo.Segment.prototype = {
    constructor: Dash.vo.Segment
};
/*
 * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.
 * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.
 * 
 * Copyright (c) 2014, Orange
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.
 * 
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*jshint -W020 */
Hls = (function () {
    "use strict";

    return {
        dependencies: {}
    };
}());
/*
 * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Digital Primates
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

Hls.dependencies.HlsStream = function() {
    "use strict";

    var REQUEST_PARAMS = {
        stream: {
            responseType: 'arraybuffer',
            contentType: 'application/octet-stream'
        },
        text: {
            responseType: 'text',
            contentType: 'application/x-www-form-urlencoded'
        },
    };

    var manifestUrl = null,
        subtitlesEnabled = false,
        autoPlay = true,
        initialized = false,
        errored = false,

        protectionData,
        licenseRequest = null,

        // Events listeners
        endedListener,
        loadedmetadataListener,
        loadeddataListener,
        playListener,
        pauseListener,
        errorListener,
        seekingListener,
        seekedListener,
        timeupdateListener,
        waitingListener,
        durationchangeListener,
        progressListener,
        ratechangeListener,
        canplayListener,
        playingListener,
        loadstartListener,

        needKeyListener,
        keyMessageListener,
        keyAddedListener,
        keyErrorListener,

        // Audio/text languages
        defaultAudioLang = 'und',
        defaultSubtitleLang = 'und',

        // Initial start time
        initialStartTime = -1,

        play = function() {
            if (!initialized) {
                return;
            }

            this.debug.info("[Stream] Play.");
            this.videoModel.play();
        },

        pause = function() {
            this.debug.info("[Stream] Pause.");
            this.videoModel.pause();
        },

        seek = function(time/*, autoplay*/) {
            if (!initialized) {
                //this.debug.info("[Stream] (seek) not initialized");
                return;
            }

            this.debug.info("[Stream] Seek: " + time);

            this.videoModel.setCurrentTime(time);
        },

        onLoadedMetadata = function() {
            this.debug.info("[Stream] <video> loadedmetadata event");
            this.metricsModel.addMetaData();
            this.metricsModel.addState("video", "buffering", this.getVideoModel().getCurrentTime());
        },

        onLoadedData = function() {
            this.debug.info("[Stream] <video> loadeddata event");
            this.setAudioLang(defaultAudioLang);
            this.enableSubtitles(subtitlesEnabled);
        },

        onCanPlay = function() {
            this.debug.info("[Stream] <video> canplay event");
            if (autoPlay) {
                this.videoModel.play();
            }
        },

        onPlaying = function() {
            this.debug.info("[Stream] <video> playing event");
            this.metricsModel.addState("video", "playing", this.getVideoModel().getCurrentTime());
        },

        onLoadStart = function() {
            this.debug.info("[Stream] <video> loadstart event");
        },

        onPlay = function() {
            this.debug.info("[Stream] <video> play event");

            this.metricsModel.addPlayList("video", new Date().getTime(), this.videoModel.getCurrentTime(), "play");
        },

        onEnded = function() {
            this.debug.info("[Stream] <video> ended event");
            //add stopped state metric with reason = 1 : end of stream
            this.metricsModel.addState("video", "stopped", this.videoModel.getCurrentTime(), 1);
        },

        onPause = function() {
            this.debug.info("[Stream] <video> pause event");
            this.metricsModel.addState("video", "paused", this.videoModel.getCurrentTime());
            this.metricsModel.addPlayList("video", new Date().getTime(), this.videoModel.getCurrentTime(), "pause");
        },

        onError = function(event) {
            var error = event.target.error,
                code,
                message = "[Stream] <video> error: ",
                data = null;

            if (error.code === -1) {
                // not an error!
                return;
            }

            switch (error.code) {
                case 1:
                    code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_ABORTED;
                    message += "[HLS] The fetching process for the media resource was aborted by the user";
                    break;
                case 2:
                    code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_NETWORK;
                    message += "[HLS] A network error has caused the user agent to stop fetching the media resource";
                    break;
                case 3:
                    code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_DECODE;
                    message += "[HLS] An error has occurred in the decoding of the media resource";
                    break;
                case 4:
                    // code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_SRC_NOT_SUPPORTED;
                    // message += "[HLS] The media could not be loaded, either because the server or network failed or because the format is not supported";
                    code = MediaPlayer.dependencies.ErrorHandler.prototype.DOWNLOAD_ERR_MANIFEST;
                    message = "[HLS] Failed to download manifest";
                    data = {
                        url: manifestUrl,
                        status: 0 // Set 0 as we have no way to get response status code
                    };
                    break;
                case 5:
                    code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_ENCRYPTED;
                    message += "[HLS] The encrypted media stream could not be played";
                    break;
            }

            errored = true;

            this.errHandler.sendError(code, message, data);
        },

        onSeeking = function() {
            this.debug.info("[Stream] <video> seeking event: " + this.videoModel.getCurrentTime());
            this.metricsModel.addState("video", "seeking", this.videoModel.getCurrentTime());
            this.metricsModel.addPlayList('video', new Date().getTime(), this.getVideoModel().getCurrentTime(), MediaPlayer.vo.metrics.PlayList.SEEK_START_REASON);
        },

        onSeeked = function() {
            // this.debug.info("[Stream] <video> seeked event");
        },

        onProgress = function() {
            // this.debug.info("[Stream] <video> progress event");
        },

        onTimeupdate = function() {
            this.debug.info("[Stream] <video> timeupdate event: " + this.videoModel.getCurrentTime());
        },

        onWaiting = function() {
            this.debug.info("[Stream] <video> waiting event");
            if (!this.getVideoModel().isSeeking()) {
                this.metricsModel.addState("video", "buffering", this.getVideoModel().getCurrentTime());
            }
        },

        onDurationchange = function() {
            this.debug.info("[Stream] <video> durationchange event: " + this.videoModel.getDuration());
        },

        onRatechange = function() {
            this.debug.info("[Stream] <video> ratechange event: " + this.videoModel.getPlaybackRate());
        },

        getKsProtectionData = function(ks) {
            if (!protectionData) {
                return null;
            }
            return protectionData[ks];
        },

        stringToArray = function (string) {
            var buffer = new ArrayBuffer(string.length * 2); // 2 bytes for each char
            var array = new Uint16Array(buffer);
            for (var i = 0; i < string.length; i++) {
                array[i] = string.charCodeAt(i);
            }
            return array;
        },

        extractContentId = function (initData) {
            var contentId = String.fromCharCode.apply(null, new Uint16Array(initData.buffer));

            var parts = contentId.split("//");
            if (parts.length != 2) {
              throw "Invalid content key format";
            }

            return parts[1];
        },

        getCertificate = function () {
            var protData = getKsProtectionData('com.apple.fps.1_0');
            if (!protData || !protData.serverCertificate) {
                return new Uint8Array(0);
            }
            return BASE64.decodeArray(protData.serverCertificate);
        },

        concatInitDataIdAndCertificate = function (initData, id, cert) {
            if (typeof id == "string")
                id = stringToArray(id);

            // layout is [initData][4 byte: idLength][idLength byte: id][4 byte:certLength][certLength byte: cert]
            var offset = 0;
            var buffer = new ArrayBuffer(initData.byteLength + 4 + id.byteLength + 4 + cert.byteLength);
            var dataView = new DataView(buffer);

            var initDataArray = new Uint8Array(buffer, offset, initData.byteLength);
            initDataArray.set(initData);
            offset += initDataArray.byteLength;

            dataView.setUint32(offset, id.byteLength, true);
            offset += 4;

            var idArray = new Uint16Array(buffer, offset, id.length);
            idArray.set(id);
            offset += idArray.byteLength;

            dataView.setUint32(offset, cert.byteLength, true);
            offset += 4;

            var certArray = new Uint8Array(buffer, offset, cert.byteLength);
            certArray.set(cert);

            return new Uint8Array(buffer, 0, buffer.byteLength);
        },

        processLicenseMessage = function (session, type, message) {

            if (type === 'text') {
                message = String.fromCharCode.apply(null, message);
                message = 'spc=' + BASE64.encodeASCII(message) + '&assetId=' + encodeURIComponent(session.contentId);
            }

            return message;
        },

        sendLicenseRequest = function (session, type, url, body) {
            var self = this,
                needFailureReport = true,

            licenseRequest = new XMLHttpRequest();
            licenseRequest.responseType = REQUEST_PARAMS[type].responseType;
            licenseRequest.session = session;

            licenseRequest.onload = function() {

                if (this.status < 200 || this.status > 299) {
                    return;
                }

                if (this.status === 200 && this.readyState === 4) {
                    self.debug.log("[DRM] Received license response");
                    needFailureReport = false;
                    processLicenseResponse(this, type);
                    // this.session.update(new Uint8Array(licenseRequest.response));
                }
            };

            licenseRequest.onerror = licenseRequest.onloadend = function() {
                if (!needFailureReport) {
                    licenseRequest = null;
                    return;
                }
                needFailureReport = false;

                // Raise error only if request has not been aborted by reset
                if (!this.aborted) {
                    self.errHandler.sendError(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYMESSERR_LICENSER_ERROR, "License request failed", {url: url, status: this.status, error: this.response});
                }
                licenseRequest = null;
            };

            licenseRequest.open('POST', url, true);
            licenseRequest.setRequestHeader('Content-Type', REQUEST_PARAMS[type].contentType);
            licenseRequest.send(body);
        },

        processLicenseResponse = function (request, type) {
            var key;

            if (type === 'text') {
                // Response can be of the form: '\n<ckc>base64encoded</ckc>\n', so trim the excess:
                key = request.responseText.trim();
                if (key.substr(0, 5) === '<ckc>' && key.substr(-6) === '</ckc>')
                    key = key.slice(5,-6);
                key = BASE64.decodeArray(key);
            } else {
                key = new Uint8Array(request.response);
            }

            request.session.update(key);
        },

        getKeyError = function(event) {
            var error = event.target.error,
                code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR,
                msg = "MediakeyError";

            if (error) {
                switch (error.code) {
                    case 1:
                        code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_UNKNOWN;
                        msg = "An unspecified error occurred. This value is used for errors that don't match any of the other codes.";
                        break;
                    case 2:
                        code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_CLIENT;
                        msg = "The Key System could not be installed or updated.";
                        break;
                    case 3:
                        code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_SERVICE;
                        msg = "The message passed into update indicated an error from the license service.";
                        break;
                    case 4:
                        code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_OUTPUT;
                        msg = "There is no available output device with the required characteristics for the content protection system.";
                        break;
                    case 5:
                        code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_HARDWARECHANGE;
                        msg += "A hardware configuration change caused a content protection error.";
                        break;
                    case 6:
                        code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_DOMAIN;
                        msg = "An error occurred in a multi-device domain licensing configuration. The most common error is a failure to join the domain.";
                        break;
                    default:
                        code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_UNKNOWN;
                        msg = "An unspecified error occurred. This value is used for errors that don't match any of the other codes.";
                        break;
                }
            } else {
                code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_UNKNOWN;
                msg = "An unspecified error occurred. This value is used for errors that don't match any of the other codes.";
            }
            if (error.systemCode) {
                msg += "  (System Code = " + event.systemCode + ")";
            }
            return new MediaPlayer.vo.protection.KeyError(code, msg);
        },

        onNeedKey = function(e) {
            this.debug.info("[Stream] <video> needkey event", e);

            var video = this.videoModel.getElement(),
                contentId = extractContentId(e.initData),
                certificate = getCertificate();

            var initData = concatInitDataIdAndCertificate(e.initData, contentId, certificate);

            var mediaKeys = new WebKitMediaKeys('com.apple.fps.1_0');
            video.webkitSetMediaKeys(mediaKeys);
            var session = video.webkitKeys.createSession('video/mp4', initData);

            if (!session)
                throw "Could not create key session";

            if (session.error) {
                this.errHandler.sendError(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYMESSERR_NO_SESSION,
                    "Failed to create key session", {code: session.error.code, systemCode: session.error.systemCode});
            }

            session.contentId = contentId;

            session.addEventListener("webkitkeymessage", keyMessageListener, false);
            session.addEventListener("webkitkeyadded", keyAddedListener, false);
            session.addEventListener("webkitkeyerror", keyErrorListener, false);
        },

        onKeyMessage = function(e) {

            this.debug.info("[Stream] keymessage event", e);

            var session = e.target,
                message = e.message,
                url = null,
                type,
                protData = getKsProtectionData('com.apple.fps.1_0');

            if (protData) {
                if (protData.serverURL && typeof protData.serverURL === "string" && protData.serverURL !== "") {
                    url = protData.serverURL;
                } else if (protData.laURL && protData.laURL !== "") { // TODO: Deprecated!
                    url = protData.laURL;
                }
            }

            if (url === null) {
                this.errHandler.sendError(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYMESSERR_URL_LICENSER_UNKNOWN, "No license server URL specified");
                return;
            }

            type = (protData && protData.requestType && protData.requestType === 'text') ? 'text' : 'stream';

            message = processLicenseMessage(session, type, message);
            sendLicenseRequest.call(this, session, type, url, message);
        },

        onKeyAdded = function(e) {
            this.debug.info("[Stream] keyadded event", e);
        },

        onKeyError = function(e) {
            this.debug.info("[Stream] keyerror event", e);
            var error = getKeyError(e);
            this.errHandler.sendError(error.code, error.msg);
        };

    return {
        system: undefined,
        videoModel: undefined,
        capabilities: undefined,
        debug: undefined,
        metricsExt: undefined,
        errHandler: undefined,
        metricsModel: undefined,
        eventBus: undefined,
        notify: undefined,

        setup: function() {

            playListener = onPlay.bind(this);
            pauseListener = onPause.bind(this);
            errorListener = onError.bind(this);
            seekingListener = onSeeking.bind(this);
            seekedListener = onSeeked.bind(this);
            progressListener = onProgress.bind(this);
            ratechangeListener = onRatechange.bind(this);
            timeupdateListener = onTimeupdate.bind(this);
            waitingListener = onWaiting.bind(this);
            durationchangeListener = onDurationchange.bind(this);
            loadedmetadataListener = onLoadedMetadata.bind(this);
            loadeddataListener = onLoadedData.bind(this);
            canplayListener = onCanPlay.bind(this);
            playingListener = onPlaying.bind(this);
            loadstartListener = onLoadStart.bind(this);

            needKeyListener = onNeedKey.bind(this);
            keyMessageListener = onKeyMessage.bind(this);
            keyAddedListener = onKeyAdded.bind(this);
            keyErrorListener = onKeyError.bind(this);

            endedListener = onEnded.bind(this);
        },

        load: function(url) {
            manifestUrl = url;
            if (initialStartTime >= 0) {
                url += '#t=' + initialStartTime;
            }
            this.videoModel.setSource(url);
        },

        setVideoModel: function(value) {
            this.videoModel = value;
            this.videoModel.listen("play", playListener);
            this.videoModel.listen("pause", pauseListener);
            this.videoModel.listen("error", errorListener);
            this.videoModel.listen("seeking", seekingListener);
            this.videoModel.listen("seeked", seekedListener);
            this.videoModel.listen("timeupdate", timeupdateListener);
            this.videoModel.listen("waiting", waitingListener);
            this.videoModel.listen("durationchange", durationchangeListener);
            this.videoModel.listen("progress", progressListener);
            this.videoModel.listen("ratechange", ratechangeListener);
            this.videoModel.listen("loadedmetadata", loadedmetadataListener);
            this.videoModel.listen("loadeddata", loadeddataListener);
            this.videoModel.listen("ended", endedListener);
            this.videoModel.listen("canplay", canplayListener);
            this.videoModel.listen("playing", playingListener);
            this.videoModel.listen("loadstart", loadstartListener);

            this.videoModel.listen("webkitneedkey", needKeyListener);
        },

        reset: function() {
            this.debug.info("[Stream] Reset");

            pause.call(this);

            // Abort license request
            if (licenseRequest) {
                licenseRequest.aborted = true;
                licenseRequest.abort();
            }

            this.videoModel.unlisten("play", playListener);
            this.videoModel.unlisten("pause", pauseListener);
            this.videoModel.unlisten("error", errorListener);
            this.videoModel.unlisten("seeking", seekingListener);
            this.videoModel.unlisten("seeked", seekedListener);
            this.videoModel.unlisten("timeupdate", timeupdateListener);
            this.videoModel.unlisten("waiting", waitingListener);
            this.videoModel.unlisten("durationchange", durationchangeListener);
            this.videoModel.unlisten("progress", progressListener);
            this.videoModel.unlisten("ratechange", ratechangeListener);
            this.videoModel.unlisten("loadedmetadata", loadedmetadataListener);
            this.videoModel.unlisten("loadeddata", loadeddataListener);
            this.videoModel.unlisten("ended", endedListener);
            this.videoModel.unlisten("canplay", canplayListener);
            this.videoModel.unlisten("playing", playingListener);
            this.videoModel.unlisten("loadstart", loadstartListener);

            this.videoModel.unlisten("webkitneedkey", needKeyListener);

            this.debug.info("[Stream] Reset source");
            this.videoModel.setSource(null);
            this.videoModel = null;

            return Q.when(true);
        },


        setProtectionData: function(protData) {
            protectionData = protData;
        },

        setInitialStartTime: function(startTime) {
            var time = parseFloat(startTime);
            if (!isNaN(time)) {
                initialStartTime = time;
            }
        },

        getAudioTracks: function() {
            var audioTracks = [],
                tracks = this.getVideoModel().getElement().audioTracks;
            if (tracks.length === 0) {
                return [];
            }

            for (var i = 0; i < tracks.length; i++) {
                audioTracks.push({
                    type: 'audio',
                    id: tracks[i].id,
                    lang: tracks[i].language
                });
            }
            // this.debug.log('[Stream] audio track: ' + JSON.stringify(audioTracks));
            return audioTracks;
        },

        setAudioLang: function(lang) {
            this.debug.log('[Stream] Set audio lang: ' + lang);
            var tracks = this.getVideoModel().getElement().audioTracks;
            if (tracks.length === 0) {
                return;
            }
            for (var i = 0; i < tracks.length; i++) {
                if (lang === tracks[i].language) {
                    tracks[i].enabled = true;
                }
            }
        },

        setAudioTrack: function(audioTrack) {
            this.debug.log('[Stream] Set audio track: ' + audioTrack.lang);
            var tracks = this.getVideoModel().getElement().audioTracks;
            if (tracks.length === 0) {
                return;
            }
            for (var i = 0; i < tracks.length; i++) {
                if (audioTrack.id === tracks[i].id &&
                    audioTrack.lang === tracks[i].language) {
                    tracks[i].enabled = true;
                }
            }
        },

        getSelectedAudioTrack: function() {
            var tracks = this.getVideoModel().getElement().audioTracks;
            for (var i = 0; i < tracks.length; i++) {
                if (tracks[i].enabled) {
                    return {
                        type: 'audio',
                        id: tracks[i].id,
                        lang: tracks[i].language
                    };
                }
            }
            return null;
        },

        getSubtitleTracks: function() {
            var textTracks = [],
                tracks = this.getVideoModel().getElement().textTracks;
            if (tracks.length === 0) {
                return [];
            }

            for (var i = 0; i < tracks.length; i++) {
                textTracks.push({
                    type: 'text',
                    id: tracks[i].label,
                    lang: tracks[i].language
                });
            }
            // this.debug.log('[Stream] text track: ' + JSON.stringify(textTracks));
            return textTracks;
        },

        enableSubtitles: function(enabled) {
            subtitlesEnabled = enabled;
            var tracks = this.getVideoModel().getElement().textTracks;
            if (tracks.length === 0) {
                return;
            }

            if (enabled) {
                this.debug.log('[Stream] Set subtitle lang: ' + defaultSubtitleLang);
            }

            var found = false;
            for (var i = 0; i < tracks.length; i++) {
                if (enabled && defaultSubtitleLang === tracks[i].language) {
                    tracks[i].mode = 'showing';
                    found = true;
                } else {
                    tracks[i].mode = 'hidden';
                }
            }

            if (enabled && !found) {
                tracks[0].mode = "showing";
            }
        },

        setSubtitleTrack: function(subtitleTrack) {
            this.debug.log('[Stream] Set subtitle track: ' + subtitleTrack.lang);
            var tracks = this.getVideoModel().getElement().textTracks;
            if (tracks.length === 0) {
                return;
            }
            for (var i = 0; i < tracks.length; i++) {
                if (subtitleTrack.id === tracks[i].label &&
                    subtitleTrack.lang === tracks[i].language) {
                    tracks[i].mode = 'showing';
                }
            }
        },

        getSelectedSubtitleTrack: function() {
            var tracks = this.getVideoModel().getElement().textTracks;
            for (var i = 0; i < tracks.length; i++) {
                if (tracks[i].mode === 'showing') {
                    return {
                        type: 'text',
                        id: tracks[i].label,
                        lang: tracks[i].language
                    };
                }
            }
            return null;
        },

        initProtection: function(/*protectionCtrl*/) {},

        getVideoModel: function() {
            return this.videoModel;
        },

        setAutoPlay: function(value) {
            autoPlay = value;
        },

        setDefaultAudioLang: function(language) {
            defaultAudioLang = language;
        },

        setDefaultSubtitleLang: function(language) {
            defaultSubtitleLang = language;
        },

        getAutoPlay: function() {
            return autoPlay;
        },

        getDuration: function() {
            return this.videoModel.getDuration();
        },

        // Used by StreamController for periods transitions => NA
        getStartTime: function() {return 0;},

        getPeriodIndex: function() {return 0;},

        getId: function() {return '';},

        // Used by StreamController to compose streams => NA
        getPeriodInfo: function() {return null;},

        // Not used/called
        getMinbufferTime: function() {return 0;},

        // Not called since no DVR window range (see MediaPlayer::seek)
        getLiveDelay: function() {return -1;},

        // Not supported
        startEventController: function() {},
        resetEventController: function() {},

        // Not supported
        setTrickModeSpeed: function(/*speed*/) {},
        getTrickModeSpeed: function() {return -1;},

        // Used by StreamController to compose streams => NA
        updateData: function() {},

        play: play,
        seek: seek,
        pause: pause
    };
};

Hls.dependencies.HlsStream.prototype = {
    constructor: Hls.dependencies.HlsStream
};
/*
 * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.
 * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.
 * 
 * Copyright (c) 2014, Orange
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.
 * 
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 /*jshint -W020 */
Mss = (function () {
    "use strict";

    return {
        dependencies: {}
    };
}());
/*
 * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.
 * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2014, Orange
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.utils.copyMethods = function(clazz) {
    var rslt = new clazz();
    rslt.parent = {};
    for (var key in rslt) {
        rslt.parent[key] = rslt[key];
    }

    rslt.setup = function() {
        for (var att in this.parent) {
            if (this.parent[att] === undefined) {
                this.parent[att] = this[att];
            }
        }
    };

    return rslt;
};

 /*
  * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.
  * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.
  *
  * Copyright (c) 2014, Orange
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
  * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
  * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
  * •  Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.
  *
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 MediaPlayer.utils.DOMParser = function() {
     "use strict";

     var _parser = null,
         _xmlDoc = null;

     return {
         getAllSpecificNodes: function(mainNode, nodeName) {
             var i = 0,
                 id,
                 querySelectorResult,
                 returnTab = [];

             if (mainNode) {
                 querySelectorResult = mainNode.querySelectorAll(nodeName);
                 if (querySelectorResult) {
                     for (i = 0; i < querySelectorResult.length; i++) {
                         id = this.getAttributeValue(querySelectorResult[i], 'xml:id');
                         if (id) {
                             returnTab[id] = querySelectorResult[i].attributes;
                             if (querySelectorResult[i].childNodes.length > 0) {
                                 returnTab[id].childNodes = querySelectorResult[i].childNodes;
                             }
                         }
                     }
                 }
             }

             return returnTab;
         },

         getAttributeName: function(node, attrValue) {
             var returnValue = [],
                 domAttribute = null,
                 i = 0,
                 attribList = null;

             if (node && node.attributes) {
                 attribList = node.attributes;
                 if (attribList) {
                     for (i = 0; i < attribList.length; i++) {
                         domAttribute = attribList[i];
                         if (domAttribute.value === attrValue) {
                             returnValue.push(domAttribute.name);
                         }
                     }
                 }
             }

             return returnValue;
         },

         getTextNodesIn: function(nodeParent) {
             var textNodes = [],
                 i = 0,
                 nodes = null,
                 node = null,
                 nodeType = null;

             if (nodeParent) {
                 nodes = nodeParent.childNodes;
                 for (i = 0; i < nodes.length; i++) {
                     node = nodes[i];
                     nodeType = node.nodeType;
                     /*ELEMENT_NODE == 1 ( element node )
                     ATTRIBUTE_NODE == 2 ( node attribute )
                     TEXT_NODE == 3 ( text node )
                     CDATA_SECTION_NODE == 4 ( CDATA section node )
                     ENTITY_REFERENCE_NODE == 5 ( node reference to an entity )
                     ENTITY_NODE == 6 ( Feature node )
                     PROCESSING_INSTRUCTION_NODE == 7 ( processing instruction node )
                     COMMENT_NODE == 8 ( comment node )
                     DOCUMENT_NODE == 9 ( document node )
                     DOCUMENT_TYPE_NODE == 10 ( Document Type node )
                     DOCUMENT_FRAGMENT_NODE == 11 ( node document fragment )
                     NOTATION_NODE == 12 ( node notation )*/
                     if (nodeType == 3) {
                         textNodes.push(node);
                     } else if (nodeType == 1 || nodeType == 9 || nodeType == 11) {
                         textNodes = textNodes.concat(this.getTextNodesIn(node));
                     }
                 }
             }
             return textNodes;
         },

         getAttributeValue: function(node, attrName, namespace) {
             var returnValue = null;

             if (node && typeof node.getAttribute == 'function') {
                 returnValue = node.getAttribute(attrName);
                 if (returnValue === null && namespace) {
                     returnValue = node.getAttributeNS(namespace, attrName);
                 }
             }

             return returnValue;
         },

         getChildNode: function(nodeParent, childName) {
             var i = 0,
                 element;

             if (nodeParent && nodeParent.childNodes) {
                 for (i = 0; i < nodeParent.childNodes.length; i++) {
                     element = nodeParent.childNodes[i];
                     if (element.nodeName === childName) {
                         return element;
                     }
                     element = undefined;
                 }
             }

             return element;
         },

         getChildNodes: function(nodeParent, childName) {
             var i = 0,
                 element = [];

             if (nodeParent && nodeParent.childNodes) {
                 for (i = 0; i < nodeParent.childNodes.length; i++) {
                     if (nodeParent.childNodes[i].nodeName === childName) {
                         element.push(nodeParent.childNodes[i]);
                     }
                 }
             }

             return element;
         },

         createXmlTree: function(xmlDocStr) {
             if (window.DOMParser) {
                 try {
                     if (!_parser) {
                         _parser = new window.DOMParser();
                     }

                     _xmlDoc = _parser.parseFromString(xmlDocStr, "text/xml");
                     if (_xmlDoc.getElementsByTagName('parsererror').length > 0) {
                         throw new Error('Error parsing XML');
                     }
                 } catch (e) {
                     _xmlDoc = null;
                 }
             }
             return _xmlDoc;
         }
     };
 };
/*
 * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.
 * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2014, Orange
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
* UTF-16 (LE or BE)
*
* RFC2781: UTF-16, an encoding of ISO 10646
*
* @link http://www.ietf.org/rfc/rfc2781.txt
* @private
* @ignore
*/
MediaPlayer.utils.isUTF16 = function (data) {
   var i = 0;
   var len = data && data.length;
   var pos = null;
   var b1, b2, next, prev;

   if (len < 2) {
       if (data[0] > 0xFF) {
           return false;
       }
   } else {
       b1 = data[0];
       b2 = data[1];
       if (b1 === 0xFF && // BOM (little-endian)
           b2 === 0xFE) {
           return true;
       }
       if (b1 === 0xFE && // BOM (big-endian)
           b2 === 0xFF) {
           return true;
       }

       for (; i < len; i++) {
           if (data[i] === 0x00) {
               pos = i;
               break;
           } else if (data[i] > 0xFF) {
               return false;
           }
       }

       if (pos === null) {
           return false; // Non ASCII
       }

       next = data[pos + 1]; // BE
       if (next !== void 0 && next > 0x00 && next < 0x80) {
           return true;
       }

       prev = data[pos - 1]; // LE
       if (prev !== void 0 && prev > 0x00 && prev < 0x80) {
           return true;
       }
   }

   return false;
};

/*
 * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.
 * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2014, Orange
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
MediaPlayer.utils.ObjectIron = function (map) {

    var lookup;

    // create a list of top level items to search for
    lookup = [];
    for (var i = 0, len = map.length; i < len; i += 1) {
        if (map[i].isRoot) {
            lookup.push("root");
        } else {
            lookup.push(map[i].name);
        }
    }

    var mergeValues = function (parentItem, childItem) {
            var name;
            if (parentItem === null || childItem === null) {
                return;
            }

            for (name in parentItem) {
                if (parentItem.hasOwnProperty(name)) {
                    if (!childItem.hasOwnProperty(name)) {
                        childItem[name] = parentItem[name];
                    }
                }
            }
        },

        mapProperties = function (properties, parent, child) {
            var i,
                len,
                property,
                parentValue,
                childValue;

            if (properties === null || properties.length === 0) {
                return;
            }

            for (i = 0, len = properties.length; i < len; i += 1) {
                property = properties[i];

                if (parent.hasOwnProperty(property.name)) {
                    if (child.hasOwnProperty(property.name)) {
                        // check to see if we should merge
                        if (property.merge) {
                           parentValue = parent[property.name];
                           childValue = child[property.name];

                            // complex objects; merge properties
                            if (typeof parentValue === 'object' && typeof childValue === 'object') {
                                mergeValues(parentValue, childValue);
                            }
                            // simple objects; merge them together
                            else {
                                if (property.mergeFunction !== null) {
                                    child[property.name] = property.mergeFunction(parentValue, childValue);
                                } else {
                                    child[property.name] = parentValue + childValue;
                                }
                            }
                        }
                    } else {
                        // just add the property
                        child[property.name] = parent[property.name];
                    }
                }
            }
        },

        mapItem = function (obj, node) {
            var item = obj,
                i,
                len,
                v,
                len2,
                array,
                childItem,
                childNode;

            if (obj.transformFunc) {
                node = obj.transformFunc(node);
            }

            if (item.children === null || item.children.length === 0) {
                return node;
            }

            for (i = 0, len = item.children.length; i < len; i += 1) {
                childItem = item.children[i];
                var itemMapped = null;
                if (node.hasOwnProperty(childItem.name)) {
                    if (childItem.isArray) {
                        array = node[childItem.name + "_asArray"];
                        for (v = 0, len2 = array.length; v < len2; v += 1) {
                            childNode = array[v];
                            mapProperties(item.properties, node, childNode);
                            //copy result in source object
                            itemMapped = mapItem(childItem, childNode);
                            node[childItem.name + "_asArray"][v] = itemMapped;
                            node[childItem.name][v] =  itemMapped;
                        }
                    } else {
                        childNode = node[childItem.name];
                        mapProperties(item.properties, node, childNode);
                        //copy result in source object
                        itemMapped = mapItem(childItem, childNode);
                        node[childItem.name] = itemMapped;
                        node[childItem.name + "_asArray"] =  [itemMapped];
                    }
                }
            }
            return node;
        },

        performMapping = function (source) {
            var i,
                len,
                pi,
                pp,
                item,
                node,
                array;

            if (source === null) {
                return source;
            }

            if (typeof source !== 'object') {
                return source;
            }

            // first look to see if anything cares about the root node
            for (i = 0, len = lookup.length; i < len; i += 1) {
                if (lookup[i] === "root") {
                    item = map[i];
                    node = source;
                    source = mapItem(item, node);
                    // node == source;
                }
            }

            // iterate over the objects and look for any of the items we care about
            for (pp in source) {
                if (source.hasOwnProperty(pp)) {
                    pi = lookup.indexOf(pp);
                    if (pi !== -1) {
                        item = map[pi];

                        if (item.isArray) {
                            array = source[pp + "_asArray"];
                            for (i = 0, len = array.length; i < len; i += 1) {
                                node = array[i];
                                source[pp][i] = mapItem(item, node);
                                source[pp + "_asArray"][i] = mapItem(item, node);
                            }
                        } else {
                            node = source[pp];
                            source[pp] = mapItem(item, node);
                            source[pp + "_asArray"] = [mapItem(item, node)];
                        }
                    }
                    // now check this to see if he has any of the properties we care about
                    source[pp] = performMapping(source[pp]);
                }
            }

            return source;
        };

    return {
        run: performMapping
    };
};

/**
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Dash Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  * Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  * Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */

MediaPlayer.dependencies.protection.CommonEncryption = {

    /**
     * Find and return the ContentProtection element in the given array
     * that indicates support for MPEG Common Encryption
     *
     * @param cpArray array of content protection elements
     * @returns the Common Encryption content protection element or
     * null if one was not found
     */
    findCencContentProtection: function(cpArray) {
        var retVal = null,
            i = 0,
            cp;
        for (i = 0; i < cpArray.length; ++i) {
            cp = cpArray[i];
            if (cp.schemeIdUri.toLowerCase() === "urn:mpeg:dash:mp4protection:2011" &&
                cp.value.toLowerCase() === "cenc")
                retVal = cp;
        }
        return retVal;
    },

    /**
     * Returns just the data portion of a single PSSH
     *
     * @param pssh {ArrayBuffer} the PSSH
     * @return {ArrayBuffer} data portion of the PSSH
     */
    getPSSHData: function(pssh) {
        var offset = 8, // Box size and type fields
            view = new DataView(pssh),
            // Read version
            version = view.getUint8(offset);

        offset += 20; // Version (1), flags (3), system ID (16)

        if (version > 0) {
            offset += 4 + (16 * view.getUint32(offset)); // Key ID count (4) and All key IDs (16*count)
        }

        offset += 4; // Data size
        return pssh.slice(offset);
    },

    /**
     * Returns the PSSH associated with the given key system from the concatenated
     * list of PSSH boxes in the given initData
     *
     * @param {MediaPlayer.dependencies.protection.KeySystem} keySystem the desired
     * key system
     * @param {ArrayBuffer} initData 'cenc' initialization data.  Concatenated list of PSSH.
     * @returns {ArrayBuffer} The PSSH box data corresponding to the given key system
     * or null if a valid association could not be found.
     */
    getPSSHForKeySystem: function(keySystem, initData) {
        var psshList = MediaPlayer.dependencies.protection.CommonEncryption.parsePSSHList(initData);
        if (psshList.hasOwnProperty(keySystem.uuid.toLowerCase())) {
            return psshList[keySystem.uuid.toLowerCase()];
        }
        return null;
    },

    /**
     * Parse a standard common encryption PSSH which contains a sinmple
     * base64-encoding of the init data
     *
     * @param cpData the ContentProtection element
     * @returns {ArrayBuffer} the init data or null if not found
     */
    parseInitDataFromContentProtection: function(cpData) {
        if (cpData && ("pssh" in cpData)) {
            return BASE64.decodeArray(cpData.pssh.__text).buffer;
        }
        return null;
    },

    readBytes: function(buf, pos, nbBytes) {
        var value = 0,
            i = 0;

        for (i = 0; i < nbBytes; i++) {
            value = value << 8;
            value = value + buf[pos];
            pos++;
        }
        return value;
    },

    /**
     * Parses list of PSSH boxes into keysystem-specific PSSH data
     *
     * @param data {ArrayBuffer} the concatenated list of PSSH boxes as provided by
     * CDM as initialization data when CommonEncryption content is detected
     * @returns {object} an object that has a property named according to each of
     * the detected key system UUIDs (e.g. 00000000-0000-0000-0000-0000000000)
     * and a ArrayBuffer (the entire PSSH box) as the property value
     */
    parsePSSHList: function(data) {

        if (data === null)
            return [];

        var dv = new DataView(data);
        var done = false;
        var pssh = {};

        // TODO: Need to check every data read for end of buffer
        var byteCursor = 0;
        while (!done) {

            var size,
                nextBox,
                version,
                systemID,
                psshDataSize;
            var boxStart = byteCursor;

            if (byteCursor >= dv.buffer.byteLength)
                break;

            /* Box size */
            size = dv.getUint32(byteCursor);
            nextBox = byteCursor + size;
            byteCursor += 4;

            /* Verify PSSH */
            if (dv.getUint32(byteCursor) !== 0x70737368) {
                byteCursor = nextBox;
                continue;
            }
            byteCursor += 4;

            /* Version must be 0 or 1 */
            version = dv.getUint8(byteCursor);
            if (version !== 0 && version !== 1) {
                byteCursor = nextBox;
                continue;
            }
            byteCursor++;

            byteCursor += 3; /* skip flags */

            // 16-byte UUID/SystemID
            systemID = '';
            var i, val;
            for (i = 0; i < 4; i++) {
                val = dv.getUint8(byteCursor + i).toString(16);
                systemID += (val.length === 1) ? '0' + val : val;
            }
            byteCursor += 4;
            systemID += '-';
            for (i = 0; i < 2; i++) {
                val = dv.getUint8(byteCursor + i).toString(16);
                systemID += (val.length === 1) ? '0' + val : val;
            }
            byteCursor += 2;
            systemID += '-';
            for (i = 0; i < 2; i++) {
                val = dv.getUint8(byteCursor + i).toString(16);
                systemID += (val.length === 1) ? '0' + val : val;
            }
            byteCursor += 2;
            systemID += '-';
            for (i = 0; i < 2; i++) {
                val = dv.getUint8(byteCursor + i).toString(16);
                systemID += (val.length === 1) ? '0' + val : val;
            }
            byteCursor += 2;
            systemID += '-';
            for (i = 0; i < 6; i++) {
                val = dv.getUint8(byteCursor + i).toString(16);
                systemID += (val.length === 1) ? '0' + val : val;
            }
            byteCursor += 6;

            systemID = systemID.toLowerCase();

            /* PSSH Data Size */
            psshDataSize = dv.getUint32(byteCursor);
            byteCursor += 4;

            /* PSSH Data */
            pssh[systemID] = dv.buffer.slice(boxStart, nextBox);
            byteCursor = nextBox;
        }

        return pssh;
    },


    /**
     * Returns list of {MediaPlayer.vo.protection.KeySystemConfiguration}
     * (see: https://w3c.github.io/encrypted-media/#idl-def-MediaKeySystemConfiguration)
     *
     * @param {object} videoCodec contains relevant info about video codec
     * @param {object} audioCodec contains relevant info about audio codec
     * @param {String} sessionType the session type like "temporary" or "persistent-license"
     * @returns {Array} list of {MediaPlayer.vo.protection.KeySystemConfiguration}
     */
    getKeySystemConfigurations: function(videoCodec, audioCodec, sessionType) {
        var audioCapabilities = [],
            videoCapabilities = [];
        if (videoCodec) {
            videoCapabilities.push(new MediaPlayer.vo.protection.MediaCapability(videoCodec));
        }
        if (audioCodec) {
            audioCapabilities.push(new MediaPlayer.vo.protection.MediaCapability(audioCodec));
        }
        return [new MediaPlayer.vo.protection.KeySystemConfiguration(
            audioCapabilities, videoCapabilities, "optional", (sessionType === "temporary") ? "optional" : "required", [sessionType])];
    }
};
/**
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Dash Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  * Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  * Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * Provides access to media protection information and functionality.  Each
 * ProtectionController manages a single {@link MediaPlayer.models.ProtectionModel}
 * which encapsulates a set of protection information (EME APIs, selected key system,
 * key sessions).  The APIs of ProtectionController mostly align with the latest EME
 * APIs.  Key system selection is mostly automated when combined with app-overrideable
 * functionality provided in {@link MediaPlayer.dependencies.ProtectionExtensions}.
 *
 * @class MediaPlayer.dependencies.ProtectionController
 * @todo ProtectionController does almost all of its tasks automatically after init() is
 * called.  Applications might want more control over this process and want to go through
 * each step manually (key system selection, session creation, session maintenance).
 */

// Define ArrayBuffer.isView method in case it is not defined
if (!ArrayBuffer.isView) {
    ArrayBuffer.isView = function(data) {
        return data && data.buffer instanceof ArrayBuffer;
    };
}

if (!ArrayBuffer.prototype.slice) {
    ArrayBuffer.prototype.slice = function(begin, end) {
        var len = this.byteLength,
            length,
            target,
            targetArray;
        begin = (begin | 0) || 0;
        end = end === (void 0) ? len : (end | 0);

        // Handle negative values.
        if (begin < 0) {
            begin = Math.max(begin + len, 0);
        }
        if (end < 0) {
            end = Math.max(end + len, 0);
        }

        if (len === 0 || begin >= len || begin >= end) {
            return new ArrayBuffer(0);
        }

        length = Math.min(len - begin, end - begin);
        target = new ArrayBuffer(length);
        targetArray = new Uint8Array(target);
        targetArray.set(new Uint8Array(this, begin, length));
        return target;
    };
}

MediaPlayer.dependencies.ProtectionController = function() {
    "use strict";

    var keySystems = null,
        pendingNeedKeyData = [],
        //audioInfo,
        //videoInfo,
        audioCodec,
        videoCodec,
        protDataSet,
        xhrLicense = null,
        initialized = false,

        getProtData = function(keySystem) {
            var protData = null,
                keySystemString = keySystem.systemString;
            if (protDataSet) {
                protData = (keySystemString in protDataSet) ? protDataSet[keySystemString] : null;
            }
            return protData;
        },

        selectKeySystem = function(supportedKS, fromManifest) {

            var self = this,
                sessionType,
                // Build our request object for requestKeySystemAccess
                requestedKeySystems = [],
                keySystemsInfo = [],
                ksIdx,
                ksAccess,
                i = 0,
                ksSelected,
                keySystemAccess;

            if (this.keySystem) {
                // We have a key system
                for (ksIdx = 0; ksIdx < supportedKS.length; ksIdx++) {
                    if (this.keySystem === supportedKS[ksIdx].ks) {
                        sessionType = supportedKS[ksIdx].ks.sessionType;
                        requestedKeySystems.push({
                            ks: supportedKS[ksIdx].ks,
                            configs: supportedKS[ksIdx].ks.getKeySystemConfigurations(videoCodec, audioCodec, sessionType)
                        });
                        // Key system info in case of error
                        keySystemsInfo.push({
                            schemeIdURI: supportedKS[ksIdx].ks.schemeIdURI,
                            systemString: supportedKS[ksIdx].ks.systemString
                        });

                        // Ensure that we would be granted key system access using the key
                        // system and codec information
                        ksAccess = {};
                        ksAccess[MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_ACCESS_COMPLETE] = function(event) {
                            self.protectionModel.unsubscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_ACCESS_COMPLETE, ksAccess);
                            if (event.error) {
                                //if (!fromManifest) {
                                self.debug.log("[DRM] KeySystem Access Denied! -- " + event.error);
                                self.eventBus.dispatchEvent({
                                    type: MediaPlayer.dependencies.ProtectionController.events.KEY_SYSTEM_SELECTED,
                                    error: "[DRM] KeySystem Access Denied! -- " + event.error
                                });
                                //}
                            } else {
                                self.debug.log("[DRM] KeySystem Access Granted");
                                self.eventBus.dispatchEvent({
                                    type: MediaPlayer.dependencies.ProtectionController.events.KEY_SYSTEM_SELECTED,
                                    data: event.data
                                });
                                self.createKeySession(supportedKS[ksIdx].initData, supportedKS[ksIdx].cdmData);
                            }
                        };
                        this.protectionModel.subscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_ACCESS_COMPLETE, ksAccess, undefined, true);
                        this.protectionModel.requestKeySystemAccess(requestedKeySystems);
                        break;
                    }
                }
            } else if (this.keySystem === undefined) {
                // First time through, so we need to select a key system
                this.keySystem = null;
                pendingNeedKeyData.push(supportedKS);

                // Add all key systems to our request list since we have yet to select a key system
                for (i = 0; i < supportedKS.length; i++) {
                    sessionType = supportedKS[i].ks.sessionType;
                    requestedKeySystems.push({
                        ks: supportedKS[i].ks,
                        configs: supportedKS[i].ks.getKeySystemConfigurations(videoCodec, audioCodec, sessionType)
                    });
                    // Key system info in case of error
                    keySystemsInfo.push({
                        schemeIdURI: supportedKS[i].ks.schemeIdURI,
                        systemString: supportedKS[i].ks.systemString
                    });
                }

                ksSelected = {};

                ksSelected[MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_ACCESS_COMPLETE] = function(event) {
                    if (!self.protectionModel) {
                        return;
                    }
                    self.protectionModel.unsubscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_ACCESS_COMPLETE, ksSelected);
                    if (event.error) {
                        self.debug.log("[DRM] KeySystem Access Denied! -- " + event.error);
                        self.keySystem = undefined;
                        self.protectionModel.unsubscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_SELECTED, ksSelected);
                        if (!fromManifest) {
                            self.eventBus.dispatchEvent({
                                type: MediaPlayer.dependencies.ProtectionController.events.KEY_SYSTEM_SELECTED,
                                error: "[DRM] KeySystem Access Denied! -- " + event.error
                            });
                        }
                        self.notify(MediaPlayer.dependencies.ProtectionController.eventList.ENAME_PROTECTION_ERROR,
                            new MediaPlayer.vo.Error(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYSYSERR_ACCESS_DENIED, "No KeySystem/CDM available", {keySystems: keySystemsInfo}));
                    } else {
                        keySystemAccess = event.data;
                        self.debug.log("[DRM] KeySystem Access (" + keySystemAccess.keySystem.systemString + ") Granted!  Selecting key system...");
                        self.protectionModel.selectKeySystem(keySystemAccess);
                    }
                };
                ksSelected[MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_SELECTED] = function(event) {
                    if (!self.protectionModel) {
                        return;
                    }
                    self.protectionModel.unsubscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_SELECTED, ksSelected);
                    if (!event.error) {
                        self.debug.log("[DRM] KeySystem selected => create key session");
                        self.keySystem = self.protectionModel.keySystem;
                        self.notify(MediaPlayer.dependencies.ProtectionController.eventList.ENAME_KEY_SYSTEM_SELECTED, keySystemAccess);
                        self.eventBus.dispatchEvent({
                            type: MediaPlayer.dependencies.ProtectionController.events.KEY_SYSTEM_SELECTED,
                            data: keySystemAccess
                        });
                        for (i = 0; i < pendingNeedKeyData.length; i++) {
                            for (ksIdx = 0; ksIdx < pendingNeedKeyData[i].length; ksIdx++) {
                                if (self.keySystem === pendingNeedKeyData[i][ksIdx].ks) {
                                    self.createKeySession(pendingNeedKeyData[i][ksIdx].initData, pendingNeedKeyData[i][ksIdx].cdmData);
                                    break;
                                }
                            }
                        }
                    } else {
                        self.keySystem = undefined;
                        if (!fromManifest) {
                            self.eventBus.dispatchEvent({
                                type: MediaPlayer.dependencies.ProtectionController.events.KEY_SYSTEM_SELECTED,
                                error: "[DRM] Error selecting key system! -- " + event.error
                            });
                        }
                        self.notify(MediaPlayer.dependencies.ProtectionController.eventList.ENAME_PROTECTION_ERROR,
                            new MediaPlayer.vo.Error(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYSYSERR_ACCESS_DENIED, "No KeySystem/CDM available", {keySystems: keySystemsInfo}));

                    }
                };
                this.protectionModel.subscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_SELECTED, ksSelected, undefined, true);
                this.protectionModel.subscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_ACCESS_COMPLETE, ksSelected, undefined, true);

                this.protectionModel.requestKeySystemAccess(requestedKeySystems);
            } else {
                // We are in the process of selecting a key system, so just save the data
                pendingNeedKeyData.push(supportedKS);
            }
        },

        /*sendLicenseRequestCompleteEvent = function(data) {
            this.eventBus.dispatchEvent({
                type: MediaPlayer.dependencies.ProtectionController.events.LICENSE_REQUEST_COMPLETE,
                data: data
            });
        },*/

        onKeyMessage = function(e) {
            var self = this,
                licenseMessage = null,
                keyMessage,
                messageType;

            keyMessage = e.data;
            messageType = (keyMessage.messageType) ? keyMessage.messageType : "license-request";
            this.debug.log("[DRM] Key message: type = " + messageType);

            // Dispatch event to applications indicating we received a key message
            this.eventBus.dispatchEvent({
                type: MediaPlayer.dependencies.ProtectionController.events.KEY_MESSAGE,
                data: keyMessage
            });

            var message = keyMessage.message,
                sessionToken = keyMessage.sessionToken,
                protData = getProtData(this.keySystem),
                keySystemString = this.keySystem.systemString,
                licenseServerData = this.protectionExt.getLicenseServer(this.keySystem, protData, messageType),
                needFailureReport = true/*,
                eventData = {
                    sessionToken: sessionToken,
                    messageType: messageType
                }*/;

            // Ensure message from CDM is not empty
            if (!message || message.byteLength === 0) {
                this.notify(MediaPlayer.dependencies.ProtectionController.eventList.ENAME_PROTECTION_ERROR,
                    new MediaPlayer.vo.Error(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYMESSERR_NO_CHALLENGE, "Empty key message from CDM"));
                return;
            }

            // Message not destined for license server
            if (!licenseServerData) {
                this.debug.log("[DRM] License server request not required for this message (type = " + e.data.messageType + ").  Session ID = " + sessionToken.getSessionID());
                return;
            }

            // Perform any special handling for ClearKey
            if (this.protectionExt.isClearKey(this.keySystem)) {
                var clearkeys = this.protectionExt.processClearKeyLicenseRequest(protData, message);
                if (clearkeys) {
                    this.debug.log("[DRM] ClearKey license request handled by application!");
                    this.protectionModel.updateKeySession(sessionToken, clearkeys);
                    return;
                }
            }

            // All remaining key system scenarios require a request to a remote license server
            xhrLicense = new XMLHttpRequest();

            // Determine license server URL
            var url = null;
            if (protData) {
                if (protData.serverURL) {
                    var serverURL = protData.serverURL;
                    if (typeof serverURL === "string" && serverURL !== "") {
                        url = serverURL;
                    } else if (typeof serverURL === "object" && serverURL.hasOwnProperty(messageType)) {
                        url = serverURL[messageType];
                    }
                } else if (protData.laURL && protData.laURL !== "") { // TODO: Deprecated!
                    url = protData.laURL;
                }
            }

            if (url === null) {
                url = this.keySystem.getLicenseServerURLFromInitData(MediaPlayer.dependencies.protection.CommonEncryption.getPSSHData(sessionToken.initData));
                if (!url) {
                    url = e.data.defaultURL;
                }
            }
            // Possibly update or override the URL based on the message
            url = licenseServerData.getServerURLFromMessage(url, message, messageType);

            this.debug.log("[DRM] Licenser server url: " + url);

            // Ensure valid license server URL
            if (!url) {
                this.notify(MediaPlayer.dependencies.ProtectionController.eventList.ENAME_PROTECTION_ERROR,
                    new MediaPlayer.vo.Error(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYMESSERR_URL_LICENSER_UNKNOWN, "No license server URL specified"));
                return;
            }

            xhrLicense.open(licenseServerData.getHTTPMethod(messageType), url, true);
            xhrLicense.responseType = licenseServerData.getResponseType(keySystemString, messageType);
            xhrLicense.onload = function() {

                if (this.status < 200 || this.status > 299) {
                    return;
                }

                if (this.status === 200 && this.readyState === 4) {
                    self.debug.log("[DRM] Received license response");
                    needFailureReport = false;
                    licenseMessage = licenseServerData.getLicenseMessage(this.response, keySystemString, messageType);
                    if (licenseMessage !== null) {
                        needFailureReport = false;
                        self.protectionModel.updateKeySession(sessionToken, licenseMessage);
                    } else {
                        needFailureReport = true;
                    }
                }
            };

            xhrLicense.onerror = xhrLicense.onloadend = function() {
                if (!needFailureReport) {
                    xhrLicense = null;
                    return;
                }
                needFailureReport = false;

                // send error only if request has  not been aborted by reset
                if (!this.aborted) {
                    self.notify(MediaPlayer.dependencies.ProtectionController.eventList.ENAME_PROTECTION_ERROR,
                        new MediaPlayer.vo.Error(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYMESSERR_LICENSER_ERROR, "License request failed", {
                            url: url,
                            status: this.status,
                            error: (this.response && this.response !== null) ? licenseServerData.getErrorResponse(this.response) : ""
                        }));
                }
                xhrLicense = null;
            };

            // Set optional XMLHttpRequest headers from protection data and message
            var updateHeaders = function(headers) {
                var key;
                if (headers) {
                    for (key in headers) {
                        if ('authorization' === key.toLowerCase()) {
                            xhrLicense.withCredentials = true;
                        }
                        xhrLicense.setRequestHeader(key, headers[key]);
                    }
                }
            };
            if (protData) {
                updateHeaders(protData.httpRequestHeaders);
            }
            updateHeaders(this.keySystem.getRequestHeadersFromMessage(message));

            // Set withCredentials property from protData
            if (protData && protData.withCredentials) {
                xhrLicense.withCredentials = true;
            }

            this.debug.log("[DRM] Send license request");
            var licenseRequest = this.keySystem.getLicenseRequestFromMessage(message);
            if (licenseRequest === null) {
                this.notify(MediaPlayer.dependencies.ProtectionController.eventList.ENAME_PROTECTION_ERROR,
                    new MediaPlayer.vo.Error(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYMESSERR_NO_CHALLENGE, "No license challenge from CDM key message"));
            }
            xhrLicense.send(licenseRequest);
        },

        onNeedKey = function(event) {

            var self = this,
                abInitData,
                supportedKS;

            self.debug.log("[DRM] onNeedKey, initDataType = " + event.data.initDataType);

            // Ignore non-cenc initData
            if (event.data.initDataType !== "cenc") {
                self.debug.log("[DRM] Only 'cenc' initData is supported!  Ignoring initData of type: " + event.data.initDataType);
                return;
            }

            // Some browsers return initData as Uint8Array (IE), some as ArrayBuffer (Chrome).
            // Convert to ArrayBuffer
            abInitData = event.data.initData;
            if (ArrayBuffer.isView(abInitData)) {
                abInitData = abInitData.buffer;
            }

            // If key system has already been selected and initData already seen, then do nothing
            if (this.keySystem) {
                var initDataForKS = MediaPlayer.dependencies.protection.CommonEncryption.getPSSHForKeySystem(this.keySystem, abInitData);
                var currentInitData = this.protectionModel.getAllInitData();
                for (var i = 0; i < currentInitData.length; i++) {
                    if (this.protectionExt.initDataEquals(initDataForKS, currentInitData[i])) {
                        this.debug.log("[DRM] Ignoring initData because we have already seen it!");
                        return;
                    }
                }
            }

            supportedKS = this.protectionExt.getSupportedKeySystems(abInitData);
            if (supportedKS.length === 0) {
                self.debug.log("[DRM] Received needkey event with initData, but we don't support any of the key systems!");
                return;
            }

            selectKeySystem.call(this, supportedKS, false);
        },

        onServerCertificateUpdated = function(event) {
            if (!event.error) {
                this.debug.log("[DRM] License server certificate successfully updated");
            } else {
                this.debug.error("[DRM] Failed to set license server certificate");
                this.notify(MediaPlayer.dependencies.ProtectionController.eventList.ENAME_PROTECTION_ERROR,
                    new MediaPlayer.vo.Error(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_SERVER_CERTIFICATE, "Failed to set server certificate", event.error));
            }
        },

        onKeySessionCreated = function(event) {
            if (!event.error) {
                this.debug.log("[DRM] Session created.  SessionID = " + event.data.getSessionID());
            } else {
                this.debug.error("[DRM] Failed to create key session");
                this.notify(MediaPlayer.dependencies.ProtectionController.eventList.ENAME_PROTECTION_ERROR,
                    new MediaPlayer.vo.Error(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYMESSERR_NO_SESSION, "Failed to create key session", event.error));
            }
        },

        onKeyAdded = function( /*event*/ ) {
            this.debug.log("[DRM] Key added");
        },

        onKeyError = function(event) {
            this.notify(MediaPlayer.dependencies.ProtectionController.eventList.ENAME_PROTECTION_ERROR,
                new MediaPlayer.vo.Error(event.data.code, event.data.message, event.data.data));
        },

        onKeySessionClosed = function(event) {
            if (!event.error) {
                this.debug.log("[DRM] Session closed. SessionID = " + event.data);
            } else {
                this.debug.warn("[DRM] Failed to close session");
            }
        },

        onKeySessionRemoved = function(event) {
            if (!event.error) {
                this.debug.log("[DRM] Session removed. SessionID = " + event.data);
            } else {
                this.debug.warn("[DRM] Failed to remove session");
            }
        },

        onKeyStatusesChanged = function(event) {
            if (!event.error) {
                this.debug.log("[DRM] Key statuses changed. statuses = " + event.data);
            } else {
                this.notify(MediaPlayer.dependencies.ProtectionController.eventList.ENAME_PROTECTION_ERROR,
                    new MediaPlayer.vo.Error(event.error.code, event.error.message, event.error.data));
            }
        };

    return {
        system: undefined,
        debug: undefined,
        notify: undefined,
        subscribe: undefined,
        unsubscribe: undefined,
        protectionExt: undefined,
        keySystem: undefined,

        setup: function() {
            this[MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_MESSAGE] = onKeyMessage.bind(this);
            this[MediaPlayer.models.ProtectionModel.eventList.ENAME_NEED_KEY] = onNeedKey.bind(this);
            this[MediaPlayer.models.ProtectionModel.eventList.ENAME_SERVER_CERTIFICATE_UPDATED] = onServerCertificateUpdated.bind(this);
            this[MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_ADDED] = onKeyAdded.bind(this);
            this[MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_ERROR] = onKeyError.bind(this);
            this[MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SESSION_CREATED] = onKeySessionCreated.bind(this);
            this[MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SESSION_CLOSED] = onKeySessionClosed.bind(this);
            this[MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SESSION_REMOVED] = onKeySessionRemoved.bind(this);
            this[MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_STATUSES_CHANGED] = onKeyStatusesChanged.bind(this);

            keySystems = this.protectionExt.getKeySystems();
            this.protectionModel = this.system.getObject("protectionModel");
            this.protectionModel.init();

            this.eventBus = this.system.getObject("eventBus");

            // Subscribe to events
            this.protectionModel.subscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_SERVER_CERTIFICATE_UPDATED, this);
            this.protectionModel.subscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_ADDED, this);
            this.protectionModel.subscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_ERROR, this);
            this.protectionModel.subscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SESSION_CREATED, this);
            this.protectionModel.subscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SESSION_CLOSED, this);
            this.protectionModel.subscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SESSION_REMOVED, this);
            this.protectionModel.subscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_MESSAGE, this);
            this.protectionModel.subscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_STATUSES_CHANGED, this);
        },

        /**
         * Initialize this protection system with a given manifest and optional audio
         * and video stream information.
         *
         * @param {Object} manifest the json version of the manifest XML document for the
         * desired content.  Applications can download their manifest using
         * {@link MediaPlayer#retrieveManifest}
         * @param {MediaPlayer.vo.StreamInfo} [aInfo] audio stream information
         * @param {MediaPlayer.vo.StreamInfo} [vInfo] video stream information
         * @memberof MediaPlayer.dependencies.ProtectionController
         * @instance
         * @todo This API will change when we have better support for allowing applications
         * to select different adaptation sets for playback.  Right now it is clunky for
         * applications to create {@link MediaPlayer.vo.StreamInfo} with the right information,
         */
        init: function(contentProtection, aCodec, vCodec) {
            var supportedKS;
            // TODO: We really need to do much more here... We need to be smarter about knowing
            // which adaptation sets for which we have initialized, including the default key ID
            // value from the ContentProtection elements so we know whether or not we still need to
            // select key systems and acquire keys.
            if (!initialized) {

                this.debug.log("[DRM] Initialize ProtectionController (" + vCodec + ", " + aCodec + ")");

                audioCodec = aCodec;
                videoCodec = vCodec;

                // ContentProtection elements are specified at the AdaptationSet level, so the CP for audio
                // and video will be the same.  Just use one valid MediaInfo object
                supportedKS = this.protectionExt.getSupportedKeySystemsFromContentProtection(contentProtection);
                if (supportedKS && supportedKS.length > 0) {
                    selectKeySystem.call(this, supportedKS, true);
                }

                initialized = true;
            }
        },

        /**
         * ProtectionController Event Listener
         *
         * @callback MediaPlayer.dependencies.ProtectionController~eventListener
         * @param {Object} event The event.  See the documentation for ProtectionController
         * APIs to see what events are fired by each API call
         */

        /**
         * Add a listener for ProtectionController events
         *
         * @param type the event ID
         * @param {MediaPlayer.dependencies.ProtectionController~eventListener} listener
         * the event listener to add
         * @see MediaPlayer.dependencies.ProtectionController.events
         * @memberof MediaPlayer.dependencies.ProtectionController
         * @instance
         */
        addEventListener: function(type, listener) {
            this.eventBus.addEventListener(type, listener);
        },

        /**
         * Remove a listener for ProtectionController events
         *
         * @param type the event ID associated with the listener to rmove
         * @param {MediaPlayer.dependencies.ProtectionController~eventListener} listener
         * the event listener to remove
         * @memberof MediaPlayer.dependencies.ProtectionController
         * @instance
         */
        removeEventListener: function(type, listener) {
            this.eventBus.removeEventListener(type, listener);
        },

        /**
         * Destroys all protection data associated with this protection set.  This includes
         * deleting all key sessions.  In the case of persistent key sessions, the sessions
         * will simply be unloaded and not deleted.  Additionally, if this protection set is
         * associated with a HTMLMediaElement, it will be detached from that element.
         *
         * @memberof MediaPlayer.dependencies.ProtectionController
         * @instance
         */
        teardown: function() {
            var self = this;

            // abort request if xhrLicense is different from null
            if (xhrLicense) {
                xhrLicense.aborted = true;
                xhrLicense.abort();
            }
            this.protectionModel.unsubscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_MESSAGE, this);
            this.protectionModel.unsubscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_SERVER_CERTIFICATE_UPDATED, this);
            this.protectionModel.unsubscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_ADDED, this);
            this.protectionModel.unsubscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_ERROR, this);
            this.protectionModel.unsubscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SESSION_CREATED, this);
            this.protectionModel.unsubscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SESSION_CLOSED, this);
            this.protectionModel.unsubscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SESSION_REMOVED, this);
            this.protectionModel.unsubscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_MESSAGE, this);
            this.protectionModel.unsubscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_STATUSES_CHANGED, this);

            this.keySystem = undefined;

            this.setMediaElement(null).then(function() {
                self.protectionModel.teardown();
                self.protectionModel = undefined;
            });
        },

        /**
         * Create a new key session associated with the given initialization data from
         * the MPD or from the PSSH box in the media
         *
         * @param {ArrayBuffer} initData the initialization data
         * @param {Uint8Array} cdmData the custom data to provide to licenser
         * @memberof MediaPlayer.dependencies.ProtectionController
         * @instance
         * @fires MediaPlayer.dependencies.ProtectionController#KeySessionCreated
         * @todo In older versions of the EME spec, there was a one-to-one relationship between
         * initialization data and key sessions.  That is no longer true in the latest APIs.  This
         * API will need to modified (and a new "generateRequest(keySession, initData)" API created)
         * to come up to speed with the latest EME standard
         */
        createKeySession: function(initData, cdmData) {

            var initDataForKS = MediaPlayer.dependencies.protection.CommonEncryption.getPSSHForKeySystem(this.keySystem, initData),
                i = 0,
                currentInitData;
            if (initDataForKS) {

                this.debug.log('[DRM] create key session for initData:', String.fromCharCode.apply(null, new Uint8Array(initDataForKS)));

                // Check for duplicate initData
                currentInitData = this.protectionModel.getAllInitData();
                for (i = 0; i < currentInitData.length; i++) {
                    if (this.protectionExt.initDataEquals(initDataForKS, currentInitData[i])) {
                        this.debug.log("[DRM] Ignoring initData because we have already seen it!");
                        return;
                    }
                }
                try {
                    this.protectionModel.createKeySession(initDataForKS, this.keySystem.sessionType, cdmData);
                } catch (ex) {
                    this.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SESSION_CREATED, null, {
                        reason: "Create key session raised en exception",
                        error: new MediaPlayer.vo.Error(ex.code, ex.name, ex.message)
                    });
                }
            } else {
                this.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SESSION_CREATED, null, {
                    reason: "needkey/encrypted event contains no initData corresponding to that key system " + this.keySystem.systemString,
                    error: null
                });
            }
        },

        /**
         * Loads a key session with the given session ID from persistent storage.  This
         * essentially creates a new key session
         *
         * @param {string} sessionID
         * @memberof MediaPlayer.dependencies.ProtectionController
         * @instance
         * @fires MediaPlayer.dependencies.ProtectionController#KeySessionCreated
         */
        loadKeySession: function(sessionID) {
            this.protectionModel.loadKeySession(sessionID);
        },

        /**
         * Removes the given key session from persistent storage and closes the session
         * as if {@link MediaPlayer.dependencies.ProtectionController#closeKeySession}
         * was called
         *
         * @param {MediaPlayer.vo.protection.SessionToken} sessionToken the session
         * token
         * @memberof MediaPlayer.dependencies.ProtectionController
         * @instance
         * @fires MediaPlayer.dependencies.ProtectionController#KeySessionRemoved
         * @fires MediaPlayer.dependencies.ProtectionController#KeySessionClosed
         */
        removeKeySession: function(sessionToken) {
            this.protectionModel.removeKeySession(sessionToken);
        },

        /**
         * Closes the key session and releases all associated decryption keys.  These
         * keys will no longer be available for decrypting media
         *
         * @param {MediaPlayer.vo.protection.SessionToken} sessionToken the session
         * token
         * @memberof MediaPlayer.dependencies.ProtectionController
         * @instance
         * @fires MediaPlayer.dependencies.ProtectionController#KeySessionClosed
         */
        closeKeySession: function(sessionToken) {
            this.protectionModel.closeKeySession(sessionToken);
        },

        /**
         * Sets a server certificate for use by the CDM when signing key messages
         * intended for a particular license server.  This will fire
         * an error event if a key system has not yet been selected.
         *
         * @param {ArrayBuffer} serverCertificate a CDM-specific license server
         * certificate
         * @memberof MediaPlayer.dependencies.ProtectionController
         * @instance
         * @fires MediaPlayer.dependencies.ProtectionController#ServerCertificateUpdated
         */
        setServerCertificate: function(serverCertificate) {
            this.protectionModel.setServerCertificate(serverCertificate);
        },

        /**
         * Associate this protection system with the given HTMLMediaElement.  This
         * causes the system to register for needkey/encrypted events from the given
         * element and provides a destination for setting of MediaKeys
         *
         * @param {HTMLMediaElement} element the media element to which the protection
         * system should be associated
         * @memberof MediaPlayer.dependencies.ProtectionController
         * @instance
         */
        setMediaElement: function(element) {
            if (element) {
                this.protectionModel.subscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_NEED_KEY, this);
            } else if (element === null) {
                this.protectionModel.unsubscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_NEED_KEY, this);
            }
            return this.protectionModel.setMediaElement(element);
        },

        /**
         * Sets the session type to use when creating key sessions.  Either "temporary" or
         * "persistent-license".  Default is "temporary".
         *
         * @param {String} sessionType the session type
         * @memberof MediaPlayer.dependencies.ProtectionController
         * @instance
         */
        setSessionType: function(sessionType) {
            if (this.keysystem) {
                this.keySystem.sessionType = sessionType;
            }
        },

        /**
         * Attach KeySystem-specific data to use for license acquisition with EME
         *
         * @param {Object} data an object containing property names corresponding to
         * key system name strings (e.g. "org.w3.clearkey") and associated values
         * being instances of {@link MediaPlayer.vo.protection.ProtectionData}
         * @memberof MediaPlayer.dependencies.ProtectionController
         * @instance
         */
        setProtectionData: function(data) {
            protDataSet = data;
            this.protectionExt.init(data);
        }
    };
};

/**
 * Key system selection event
 *
 * @event MediaPlayer.dependencies.ProtectionController#KeySystemSelected
 * @type {Object}
 * @property {MediaPlayer.vo.protection.KeySystemAccess} data key system
 * access object that describes the selected key system and associated
 * audio/video codecs and CDM capabilities.  May be null if an error occurred
 * @property {string} error if not null, an error occurred and this object
 * will contain an informative error string describing the failure
 */

/**
 * Key session creation event
 *
 * @event MediaPlayer.dependencies.ProtectionController#KeySessionCreated
 * @type {Object}
 * @property {MediaPlayer.vo.protection.SessionToken} data the session token
 * that can be used to access certain properties of the session.  Also
 * required for other ProtectionController APIs that act on key sessions.
 * @property {string} error if not null, an error occurred and this object
 * will contain an informative error string describing the failure
 */

/**
 * Key session removed event
 *
 * @event MediaPlayer.dependencies.ProtectionController#KeySessionRemoved
 * @type {Object}
 * @property {string} data the session ID of the session that was removed
 * from persistent storage
 * @property {string} error if not null, an error occurred and this object
 * will contain an informative error string describing the failure
 */

/**
 * Key session closed event
 *
 * @event MediaPlayer.dependencies.ProtectionController#KeySessionClosed
 * @type {Object}
 * @property {string} data the session ID of the session that was closed
 * @property {string} error if not null, an error occurred and this object
 * will contain an informative error string describing the failure
 */

/**
 * Server certificate updated event
 *
 * @event MediaPlayer.dependencies.ProtectionController#ServerCertificateUpdated
 * @type {Object}
 * @property {Object} data unused for this event.  The server certificate update
 * was is successful if the "error" property of this event is null or undefined
 * @property {string} error if not null, an error occurred and this object
 * will contain an informative error string describing the failure
 */

/**
 * License request completed event
 *
 * @event MediaPlayer.dependencies.ProtectionController#LicenseRequestComplete
 * @type {Object}
 * @property {Object} data The event data.  This data will be provided regardless
 * of the success/failure status of the event
 * @property {MediaPlayer.vo.protection.SessionToken} data.sessionToken session token
 * associated with this license response.  Will never be null, even in error cases.
 * @property {String} data.messageType the message type associated with this request.
 * Supported message types can be found
 * {@link https://w3c.github.io/encrypted-media/#idl-def-MediaKeyMessageType|here}.
 * @property {string} error if not null, an error occurred and this object
 * will contain an informative error string describing the failure
 */

/**
 * Events names for events sent by ProtectionController.  Use these event
 * names when subscribing or unsubscribing from ProtectionController events
 *
 * @enum {String}
 * @see MediaPlayer.dependencies.ProtectionController#addEventListener
 */
MediaPlayer.dependencies.ProtectionController.events = {
    /**
     * Event ID for events delivered when a key system selection procedure
     * has completed
     *
     * @constant
     */
    KEY_SYSTEM_SELECTED: "keySystemSelected",
    /**
     * Event ID for events delivered when the protection set receives
     * a key message from the CDM
     *
     * @constant
     */
    SERVER_CERTIFICATE_UPDATED: "serverCertificateUpdated",
    /**
     * Event ID for events delivered when a new key has been added
     *
     * @constant
     * @deprecated The latest versions of the EME specification no longer
     * use this event. {@MediaPlayer.dependencies.ProtectionController.events.KEY_STATUSES_CHANGED}
     * is preferred.
     */
    KEY_ADDED: "keyAdded",
    /**
     * Event ID for events delivered when a new key sessions creation
     * process has completed
     *
     * @constant
     */
    KEY_SESSION_CREATED: "keySessionCreated",
    /**
     * Event ID for events delivered when a key session removal
     * process has completed
     *
     * @constant
     */
    KEY_SESSION_REMOVED: "keySessionRemoved",
    /**
     * Event ID for events delivered when a key session close
     * process has completed
     *
     * @constant
     */
    KEY_SESSION_CLOSED: "keySessionClosed",
    /**
     * Event ID for events delivered when the status of one or more
     * decryption keys has changed
     *
     * @constant
     */
    KEY_STATUSES_CHANGED: "keyStatusesChanged",
    /**
     * Event ID for events delivered when the protection system receives
     * a key message from the CDM
     *
     * @constant
     */
    KEY_MESSAGE: "keyMessage",
    /**
     * Event ID for events delivered when a license request procedure
     * has completed
     *
     * @constant
     */
    LICENSE_REQUEST_COMPLETE: "licenseRequestComplete"
};

MediaPlayer.dependencies.ProtectionController.eventList = {
    ENAME_PROTECTION_ERROR: "protectionError",
    ENAME_KEY_SYSTEM_SELECTED: "keySystemSelected"
};

MediaPlayer.dependencies.ProtectionController.prototype = {
    constructor: MediaPlayer.dependencies.ProtectionController
};

/**
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Dash Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  * Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  * Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * Media protection functionality that can be modified/overridden by applications
 *
 * @class MediaPlayer.dependencies.ProtectionExtensions
 */
MediaPlayer.dependencies.ProtectionExtensions = function () {
    "use strict";

    this.system = undefined;
    this.debug = undefined;
    this.keySystems = [];

    this.clearkeyKeySystem = undefined;
};

MediaPlayer.dependencies.ProtectionExtensions.prototype = {
    constructor: MediaPlayer.dependencies.ProtectionExtensions,

    /**
     * Setup the key systems available in the player
     */
    setup: function() {
        var keySystem;

        // PlayReady
        keySystem = this.system.getObject("ksPlayReady");
        this.keySystems.push(keySystem);

        // Widevine
        keySystem = this.system.getObject("ksWidevine");
        this.keySystems.push(keySystem);

        // ClearKey
        keySystem = this.system.getObject("ksClearKey");
        this.keySystems.push(keySystem);
        this.clearkeyKeySystem = keySystem;
    },

    /**
     * Initialize the available key systems
     *
     * @param protectionDataSet object that contains 0 or more ProtectionData
     * objects.  Each one is identified by an attribute name equal to
     * to the unique key system string for the DRM to which it is intended
     */
    init: function(protectionDataSet) {
        var getProtectionData = function(keySystemString) {
            var protData = null;
            if (protectionDataSet) {
                protData = (keySystemString in protectionDataSet) ? protectionDataSet[keySystemString] : null;
            }
            return protData;
        };

        for (var i = 0; i < this.keySystems.length; i++) {
            var keySystem = this.keySystems[i];
            keySystem.init(getProtectionData(keySystem.systemString));
        }
    },

    /**
     * Returns a prioritized list of key systems supported
     * by this player (not necessarily those supported by the
     * user agent)
     *
     * @returns {MediaPlayer.dependencies.protection.KeySystem[]} a prioritized
     * list of key systems
     */
    getKeySystems: function() {
        return this.keySystems;
    },

    /**
     * Returns the key system associated with the given key system string
     * name (i.e. 'org.w3.clearkey')
     *
     * @param {string} systemString the system string
     * @returns {MediaPlayer.dependencies.protection.KeySystem} the key system
     * or null if no supported key system is associated with the given key
     * system string
     */
    getKeySystemBySystemString: function(systemString) {
        for (var i = 0; i < this.keySystems.length; i++) {
            if (this.keySystems[i].systemString === systemString) {
                return this.keySystems[i];
            }
        }
        return null;
    },

    /**
     * Determines whether the given key system is ClearKey.  This is
     * necessary because the EME spec defines ClearKey and its method
     * for providing keys to the key session; and this method has changed
     * between the various API versions.  Our EME-specific ProtectionModels
     * must know if the system is ClearKey so that it can format the keys
     * according to the particular spec version.
     *
     * @param keySystem the key
     * @returns {boolean} true if this is the ClearKey key system, false
     * otherwise
     */
    isClearKey: function(keySystem) {
        return (keySystem === this.clearkeyKeySystem);
    },

    /**
     * Check equality of initData array buffers.
     *
     * @param initData1 {ArrayBuffer} first initData
     * @param initData2 {ArrayBuffer} second initData
     * @returns {boolean} true if the initData arrays are equal in size and
     * contents, false otherwise
     */
    initDataEquals: function(initData1, initData2) {
        if (initData1.byteLength === initData2.byteLength) {
            var data1 = new Uint8Array(initData1),
                data2 = new Uint8Array(initData2);
            for (var j = 0; j < data1.length; j++) {
                if (data1[j] !== data2[j]) {
                    return false;
                }
            }
            return true;
        }
        return false;
    },

    /**
     * Returns a set of supported key systems and CENC intialization data
     * from the given array of ContentProtection elements.  Only
     * key systems that are supported by this player will be returned.
     * Key systems are returned in priority order (highest first).
     *
     * @param {Object[]} cps array of content protection elements parsed
     * from the manifest
     * @returns {Object[]} array of objects indicating which supported key
     * systems were found.  Empty array is returned if no
     * supported key systems were found
     * @returns {MediaPlayer.dependencies.protection.KeySystem} Object.ks the key
     * system identified by the ContentProtection element
     * @returns {ArrayBuffer} Object.initData the initialization data parsed
     * from the ContentProtection element
     */
    getSupportedKeySystemsFromContentProtection: function(cps) {
        var cp, ks, ksIdx, cpIdx, supportedKS = [];

        if (cps) {
            for(ksIdx = 0; ksIdx < this.keySystems.length; ++ksIdx) {
                ks = this.keySystems[ksIdx];
                for(cpIdx = 0; cpIdx < cps.length; ++cpIdx) {
                    cp = cps[cpIdx];
                    if (cp.schemeIdUri.toLowerCase() === ks.schemeIdURI) {

                        //this.debug.log("[DRM] Supported key systems: " + ks.systemString + " (" + ks.schemeIdURI + ")");

                        // Look for DRM-specific ContentProtection
                        var initData = ks.getInitData(cp);
                        if (!!initData) {
                            supportedKS.push({
                                ks: this.keySystems[ksIdx],
                                initData: initData,
                                cdmData: ks.getCDMData()
                            });
                        }
                    }
                }
            }
        }
        return supportedKS;
    },

    /**
     * Returns key systems supported by this player for the given PSSH
     * initializationData. Only key systems supported by this player
     * will be returned.  Key systems are returned in priority order
     * (highest priority first)
     *
     * @param {ArrayBuffer} initData Concatenated PSSH data for all DRMs
     * supported by the content
     * @returns {Object[]} array of objects indicating which supported key
     * systems were found.  Empty array is returned if no
     * supported key systems were found
     * @returns {MediaPlayer.dependencies.protection.KeySystem} Object.ks the key
     * system
     * @returns {ArrayBuffer} Object.initData the initialization data
     * associated with the key system
     */
    getSupportedKeySystems: function(initData) {
        var ksIdx, supportedKS = [],
                pssh = MediaPlayer.dependencies.protection.CommonEncryption.parsePSSHList(initData);

        this.debug.log("[DRM] Get supported key systems from init data");

        for (ksIdx = 0; ksIdx < this.keySystems.length; ++ksIdx) {
            if (this.keySystems[ksIdx].uuid in pssh) {
                //this.debug.log("[DRM] Add supported key system: " + this.keySystems[ksIdx].systemString);
                supportedKS.push({
                    ks: this.keySystems[ksIdx],
                    initData: pssh[this.keySystems[ksIdx].uuid],
                    cdmData: this.keySystems[ksIdx].getCDMData()
                });
            }
        }
        return supportedKS;
    },

    /**
     * Returns the license server implementation data that should be used for this request.
     *
     * @param {MediaPlayer.dependencies.protection.KeySystem} keySystem the key system
     * associated with this license request
     * @param {MediaPlayer.vo.protection.ProtectionData} protData protection data to use for the
     * request
     * @param {String} [messageType="license-request"] the message type associated with this
     * request.  Supported message types can be found
     * {@link https://w3c.github.io/encrypted-media/#idl-def-MediaKeyMessageType|here}.
     * @return {MediaPlayer.dependencies.protection.servers.LicenseServer} the license server
     * implementation that should be used for this request or null if the player should not
     * pass messages of the given type to a license server
     *
     */
    getLicenseServer: function(keySystem, protData, messageType) {

        // Our default server implementations do not do anything with "license-release" or
        // "individualization-request" messages, so we just send a success event
        if (messageType === "license-release" || messageType == "individualization-request") {
            return null;
        }

        var licenseServerData = null;
        if (protData && protData.hasOwnProperty("drmtoday")) {
            licenseServerData = this.system.getObject("serverDRMToday");
        } else if (keySystem.systemString === "com.widevine.alpha") {
            licenseServerData = this.system.getObject("serverWidevine");
        } else if (keySystem.systemString === "com.microsoft.playready") {
            licenseServerData = this.system.getObject("serverPlayReady");
        } else if (keySystem.systemString === "org.w3.clearkey") {
            licenseServerData = this.system.getObject("serverClearKey");
        }

        return licenseServerData;
    },

    /**
     * Allows application-specific retrieval of ClearKey keys.
     *
     * @param {MediaPlayer.vo.protection.ProtectionData} protData protection data to use for the
     * request
     * @param {ArrayBuffer} message the key message from the CDM
     * @return {MediaPlayer.vo.protection.ClearKeyKeySet} the clear keys associated with
     * the request or null if no keys can be returned by this function
     */
    processClearKeyLicenseRequest: function(protData, message) {
        try {
            return MediaPlayer.dependencies.protection.KeySystem_ClearKey.getClearKeysFromProtectionData(protData, message);
        } catch (error) {
            this.log("Failed to retrieve clearkeys from ProtectionData");
            return null;
        }
    },

    /**
     * Select a key system by using the priority-ordered key systems supported
     * by the player and the key systems supported by the content
     *
     * @param {Object[]} supportedKS supported key systems
     * @param {MediaPlayer.dependencies.ProtectionController} protectionController
     * @param {MediaPlayer.vo.MediaInfo} videoInfo video media information
     * @param {MediaPlayer.vo.MediaInfo} audioInfo audio media information
     */
    //autoSelectKeySystem: function(supportedKS, protectionController, videoInfo, audioInfo) {
    autoSelectKeySystem: function(supportedKS, protectionController, videoCodec, audioCodec) {

        this.debug.log("[DRM] Auto select key system: ");
        this.debug.log("[DRM] ---- video codec = " + videoCodec);
        this.debug.log("[DRM] ---- audio codec = " + audioCodec);

        // Does the initData contain a key system supported by the player?
        if (supportedKS.length === 0) {
            throw new Error("DRM system for this content not supported by the player!");
        }

        var audioCapabilities = [], videoCapabilities = [];
        if (videoCodec) {
            videoCapabilities.push(new MediaPlayer.vo.protection.MediaCapability(videoCodec));
        }
        if (audioCodec) {
            audioCapabilities.push(new MediaPlayer.vo.protection.MediaCapability(audioCodec));
        }
        var ksConfig = new MediaPlayer.vo.protection.KeySystemConfiguration(audioCapabilities, videoCapabilities);
        var requestedKeySystems = [];
        for (var i = 0; i < supportedKS.length; i++) {
            requestedKeySystems.push({ ks: supportedKS[i].ks, configs: [ksConfig] });
        }

        // Since ProtectionExtensions is a singleton, we need to create an IIFE to wrap the
        // event callback and save the values of protectionModel and protectionController.
        var self = this;
        (function(protCtrl) {

            // Callback object for KEY_SYSTEM_ACCESS_COMPLETE event
            var cbObj = {};

            // Subscribe for event and then perform request
            cbObj[MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_ACCESS_COMPLETE] = function(event) {
                protCtrl.protectionModel.unsubscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_ACCESS_COMPLETE, this);
                if (!event.error) {
                    var keySystemAccess = event.data;
                    self.debug.log("[DRM] KeySystem Access Granted (" + keySystemAccess.keySystem.systemString + ")!");
                    protCtrl.selectKeySystem(keySystemAccess);
                } else {
                    self.debug.log(event.error);
                    protCtrl.notify(MediaPlayer.dependencies.ProtectionController.eventList.ENAME_PROTECTION_ERROR,
                        new MediaPlayer.vo.Error(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYSYSERR_ACCESS_DENIED, "[DRM] KeySystem Access Denied! -- " + event.error, null));
                }
            };

            protCtrl.protectionModel.subscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_ACCESS_COMPLETE, cbObj);
            protCtrl.requestKeySystemAccess(requestedKeySystems);

        })(protectionController);
    }
};


/**
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Dash Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  * Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  * Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * Initial implementation of EME
 *
 * Implemented by Google Chrome prior to v36
 *
 * @implements MediaPlayer.models.ProtectionModel
 * @class
 */
MediaPlayer.models.ProtectionModel_01b = function () {

    var videoElement = null,

        // API names object selected for this user agent
        api = null,

        // With this version of the EME APIs, sessionIDs are not assigned to
        // sessions until the first key message is received.  We are assuming
        // that in the case of multiple sessions, key messages will be received
        // in the order that generateKeyRequest() is called.

        // Holding spot for newly-created sessions until we determine whether or
        // not the CDM supports sessionIDs
        pendingSessions = [],

        // List of sessions that have been initialized.  Only the first position will
        // be used in the case that the CDM does not support sessionIDs
        sessions = [],

        // Not all CDMs support the notion of sessionIDs.  Without sessionIDs
        // there is no way for us to differentiate between sessions, therefore
        // we must only allow a single session.  Once we receive the first key
        // message we can set this flag to determine if more sessions are allowed
        moreSessionsAllowed,

        // This is our main event handler for all desired HTMLMediaElement events
        // related to EME.  These events are translated into our API-independent
        // versions of the same events
        createEventHandler = function() {
            var self = this;
            return {
                handleEvent: function(event) {
                    var sessionToken = null;
                    switch (event.type) {

                        case api.needkey:
                            var initData = ArrayBuffer.isView(event.initData) ? event.initData.buffer : event.initData;
                            self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_NEED_KEY,
                                new MediaPlayer.vo.protection.NeedKey(initData, "cenc"));
                            break;

                        case api.keyerror:
                            sessionToken = findSessionByID(sessions, event.sessionId);
                            if (!sessionToken) {
                                sessionToken = findSessionByID(pendingSessions, event.sessionId);
                            }

                            if (sessionToken) {
                                var code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR,
                                    msg = "MediakeyError";
                                switch (event.errorCode.code) {
                                    case 1:
                                        code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_UNKNOWN;
                                        msg += "An unspecified error occurred. This value is used for errors that don't match any of the other codes.";
                                        break;
                                    case 2:
                                        code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_CLIENT;
                                        msg += "The Key System could not be installed or updated.";
                                        break;
                                    case 3:
                                        code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_SERVICE;
                                        msg += "The message passed into update indicated an error from the license service.";
                                        break;
                                    case 4:
                                        code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_OUTPUT;
                                        msg += "There is no available output device with the required characteristics for the content protection system.";
                                        break;
                                    case 5:
                                        code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_HARDWARECHANGE;
                                        msg += "A hardware configuration change caused a content protection error.";
                                        break;
                                    case 6:
                                        code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_DOMAIN;
                                        msg += "An error occurred in a multi-device domain licensing configuration. The most common error is a failure to join the domain.";
                                        break;
                                }
                                if (event.systemCode) {
                                    msg += "  (System Code = " + event.systemCode + ")";
                                }
                                self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_ERROR, new MediaPlayer.vo.protection.KeyError(code, msg));
                            } else {
                                self.log("No session token found for key error");
                            }
                            break;

                        case api.keyadded:
                            sessionToken = findSessionByID(sessions, event.sessionId);
                            if (!sessionToken) {
                                sessionToken = findSessionByID(pendingSessions, event.sessionId);
                            }

                            if (sessionToken) {
                                self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_ADDED, sessionToken);
                            } else {
                                self.log("No session token found for key added");
                            }
                            break;

                        case api.keymessage:

                            // If this CDM does not support session IDs, we will be limited
                            // to a single session
                            moreSessionsAllowed = (event.sessionId !== null) && (event.sessionId !== undefined);

                            // SessionIDs supported
                            if (moreSessionsAllowed) {

                                // Attempt to find an uninitialized token with this sessionID
                                sessionToken = findSessionByID(sessions, event.sessionId);
                                if (!sessionToken && pendingSessions.length > 0) {

                                    // This is the first message for our latest session, so set the
                                    // sessionID and add it to our list
                                    sessionToken = pendingSessions.shift();
                                    sessions.push(sessionToken);
                                    sessionToken.sessionID = event.sessionId;
                                }
                            } else if (pendingSessions.length > 0) { // SessionIDs not supported

                                sessionToken = pendingSessions.shift();
                                sessions.push(sessionToken);

                                if (pendingSessions.length !== 0) {
                                    self.errHandler.mediaKeyMessageError("Multiple key sessions were creates with a user-agent that does not support sessionIDs!! Unpredictable behavior ahead!");
                                }
                            }

                            if (sessionToken) {
                                var message = ArrayBuffer.isView(event.message) ? event.message.buffer : event.message;

                                // For ClearKey, the spec mandates that you pass this message to the
                                // addKey method, so we always save it to the token since there is no
                                // way to tell which key system is in use
                                sessionToken.keyMessage = message;

                                self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_MESSAGE,
                                    new MediaPlayer.vo.protection.KeyMessage(sessionToken, message, event.defaultURL));
                            } else {
                                self.log("No session token found for key message");
                            }
                            break;
                    }
                }
            };
        },
        eventHandler = null,

        /**
         * Helper function to retrieve the stored session token based on a given
         * sessionID value
         *
         * @param sessionArray {Array} the array of sessions to search
         * @param sessionID the sessionID to search for
         * @returns {*} the session token with the given sessionID
         */
        findSessionByID = function(sessionArray, sessionID) {

            if (!sessionID || !sessionArray) {
                return null;
            } else {
                var len = sessionArray.length;
                for (var i = 0; i < len; i++) {
                    if (sessionArray[i].sessionID === sessionID) {
                        return sessionArray[i];
                    }
                }
                return null;
            }
        },

        removeEventListeners = function() {
            videoElement.removeEventListener(api.keyerror, eventHandler);
            videoElement.removeEventListener(api.needkey, eventHandler);
            videoElement.removeEventListener(api.keymessage, eventHandler);
            videoElement.removeEventListener(api.keyadded, eventHandler);
        };

    return {
        system: undefined,
        log: undefined,
        errHandler: undefined,
        notify: undefined,
        subscribe: undefined,
        unsubscribe: undefined,
        protectionExt: undefined,
        keySystem: null,

        setup: function() {
            eventHandler = createEventHandler.call(this);
        },

        /**
         * Initialize this protection model
         */
        init: function() {
            var tmpVideoElement = document.createElement("video");
            api = MediaPlayer.models.ProtectionModel_01b.detect(tmpVideoElement);
        },

        teardown: function() {
            if (videoElement) {
                removeEventListeners();
            }
            for (var i = 0; i < sessions.length; i++) {
                this.closeKeySession(sessions[i]);
            }
            this.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_TEARDOWN_COMPLETE);
        },

        getAllInitData: function() {
            var i, retVal = [];
            for (i = 0; i < pendingSessions.length; i++) {
                retVal.push(pendingSessions[i].initData);
            }
            for (i = 0; i < sessions.length; i++) {
                retVal.push(sessions[i].initData);
            }
            return retVal;
        },

        requestKeySystemAccess: function(ksConfigurations) {
            var ve = videoElement;
            if (!ve) { // Must have a video element to do this capability tests
                ve = document.createElement("video");
            }

            // Try key systems in order, first one with supported key system configuration
            // is used
            var found = false;
            for (var ksIdx = 0; ksIdx < ksConfigurations.length; ksIdx++) {
                var systemString = ksConfigurations[ksIdx].ks.systemString;
                var configs = ksConfigurations[ksIdx].configs;
                var supportedAudio = null;
                var supportedVideo = null;

                // Try key system configs in order, first one with supported audio/video
                // is used
                for (var configIdx = 0; configIdx < configs.length; configIdx++) {
                    //var audios = configs[configIdx].audioCapabilities;
                    var videos = configs[configIdx].videoCapabilities;

                    // Look for supported audio container/codecs
                    /*
                    if (audios && audios.length !== 0) {
                        supportedAudio = []; // Indicates that we have a requested audio config
                        for (var audioIdx = 0; audioIdx < audios.length; audioIdx++) {
                            if (ve.canPlayType(audios[audioIdx].contentType, systemString) !== "") {
                                supportedAudio.push(audios[audioIdx]);
                            }
                        }
                    }
                    */

                    // Look for supported video container/codecs
                    if (videos && videos.length !== 0) {
                        supportedVideo = []; // Indicates that we have a requested video config
                        for (var videoIdx = 0; videoIdx < videos.length; videoIdx++) {
                            if (ve.canPlayType(videos[videoIdx].contentType, systemString) !== "") {
                                supportedVideo.push(videos[videoIdx]);
                            }
                        }
                    }

                    // No supported audio or video in this configuration OR we have
                    // requested audio or video configuration that is not supported
                    if ((!supportedAudio && !supportedVideo) ||
                            (supportedAudio && supportedAudio.length === 0) ||
                            (supportedVideo && supportedVideo.length === 0)) {
                        continue;
                    }

                    // This configuration is supported
                    found = true;
                    var ksConfig = new MediaPlayer.vo.protection.KeySystemConfiguration(supportedAudio, supportedVideo);
                    var ks = this.protectionExt.getKeySystemBySystemString(systemString);
                    var ksAccess = new MediaPlayer.vo.protection.KeySystemAccess(ks, ksConfig);
                    this.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_ACCESS_COMPLETE,
                            ksAccess);
                    break;
                }
            }
            if (!found) {
                this.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_ACCESS_COMPLETE,
                        null, "Key system access denied! -- No valid audio/video content configurations detected!");
            }
        },

        selectKeySystem: function(keySystemAccess) {
            this.keySystem = keySystemAccess.keySystem;
            this.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_SELECTED);
        },

        setMediaElement: function(mediaElement) {
            if (videoElement === mediaElement) {
                return;
            }

            // Replacing the previous element
            if (videoElement) {
                removeEventListeners();
            }

            videoElement = mediaElement;

            // Only if we are not detaching from the existing element
            if (videoElement) {
                videoElement.addEventListener(api.keyerror, eventHandler);
                videoElement.addEventListener(api.needkey, eventHandler);
                videoElement.addEventListener(api.keymessage, eventHandler);
                videoElement.addEventListener(api.keyadded, eventHandler);
                this.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_VIDEO_ELEMENT_SELECTED);
            }

            return Q.when();
        },

        createKeySession: function(initData /*, keySystemType */) {

            if (!this.keySystem) {
                throw new Error("Can not create sessions until you have selected a key system");
            }

            // Determine if creating a new session is allowed
            if (moreSessionsAllowed || sessions.length === 0) {

                var newSession = { // Implements MediaPlayer.vo.protection.SessionToken
                    sessionID: null,
                    initData: initData,

                    getSessionID: function() {
                        return this.sessionID;
                    },

                    getExpirationTime: function() {
                        return NaN;
                    },

                    getSessionType: function() {
                        return "temporary";
                    }
                };
                pendingSessions.push(newSession);

                // Send our request to the CDM
                videoElement[api.generateKeyRequest](this.keySystem.systemString, new Uint8Array(initData));

                return newSession;

            } else {
                throw new Error("Multiple sessions not allowed!");
            }

        },

        updateKeySession: function(sessionToken, message) {
            var sessionID = sessionToken.sessionID;
            if (!this.protectionExt.isClearKey(this.keySystem)) {
                // Send our request to the CDM
                videoElement[api.addKey](this.keySystem.systemString,
                        new Uint8Array(message), new Uint8Array(sessionToken.initData), sessionID);
            } else {
                // For clearkey, message is a MediaPlayer.vo.protection.ClearKeyKeySet
                for (var i = 0; i < message.keyPairs.length; i++) {
                    videoElement[api.addKey](this.keySystem.systemString,
                            message.keyPairs[i].key, message.keyPairs[i].keyID, sessionID);
                }
            }
        },

        closeKeySession: function(sessionToken) {
            // Send our request to the CDM
            videoElement[api.cancelKeyRequest](this.keySystem.systemString, sessionToken.sessionID);
        },

        setServerCertificate: function(/*serverCertificate*/) { /* Not supported */ },

        loadKeySession: function(/*sessionID*/) { /* Not supported */ },

        removeKeySession: function(/*sessionToken*/) { /* Not supported */ },

        checkIfEncrypted: function() { /* Not supported */ }
    };
};

MediaPlayer.models.ProtectionModel_01b.prototype = {
    constructor: MediaPlayer.models.ProtectionModel_01b
};

// Defines the supported 0.1b API variations
MediaPlayer.models.ProtectionModel_01b.APIs = [
    // Un-prefixed as per spec
    {
        // Video Element
        generateKeyRequest: "generateKeyRequest",
        addKey: "addKey",
        cancelKeyRequest: "cancelKeyRequest",

        // Events
        needkey: "needkey",
        keyerror: "keyerror",
        keyadded: "keyadded",
        keymessage: "keymessage"
    },
    // Webkit-prefixed (early Chrome versions and Chrome with EME disabled in chrome://flags)
    {
        // Video Element
        generateKeyRequest: "webkitGenerateKeyRequest",
        addKey: "webkitAddKey",
        cancelKeyRequest: "webkitCancelKeyRequest",

        // Events
        needkey: "webkitneedkey",
        keyerror: "webkitkeyerror",
        keyadded: "webkitkeyadded",
        keymessage: "webkitkeymessage"
    }
];

/**
 * Detects presence of EME v0.1b APIs
 *
 * @param videoElement {HTMLMediaElement} the media element that will be
 * used for detecting APIs
 * @returns an API object that is used when initializing the ProtectionModel
 * instance, or null if this EME version is not supported
 */
MediaPlayer.models.ProtectionModel_01b.detect = function(videoElement) {
    var apis = MediaPlayer.models.ProtectionModel_01b.APIs;
    for (var i = 0; i < apis.length; i++) {
        var api = apis[i];
        if (typeof videoElement[api.generateKeyRequest] !== 'function') {
            continue;
        }
        if (typeof videoElement[api.addKey] !== 'function') {
            continue;
        }
        if (typeof videoElement[api.cancelKeyRequest] !== 'function') {
            continue;
        }
        return api;
    }

    return null;
};

/**
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Dash Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  * Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  * Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * Implementation of the EME APIs as of the 3 Feb 2014 state of the specification.
 *
 * Implemented by Internet Explorer 11 (Windows 8.1)
 *
 * @implements MediaPlayer.models.ProtectionModel
 * @class
 */
MediaPlayer.models.ProtectionModel_3Feb2014 = function () {

    var videoElement = null,
        mediaKeys = null,
        keySystemAccess = null,
        boundDoSetKeys = null,

        // API names object selected for this user agent
        api = null,

        // Session list
        sessions = [],

        // This is our main event handler for all desired HTMLMediaElement events
        // related to EME.  These events are translated into our API-independent
        // versions of the same events
        createEventHandler = function() {
            var self = this;
            return {
                handleEvent: function(event) {
                    switch (event.type) {

                        case api.needkey:
                            if (event.initData) {
                                var initData = ArrayBuffer.isView(event.initData) ? event.initData.buffer : event.initData;
                                self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_NEED_KEY,
                                        new MediaPlayer.vo.protection.NeedKey(initData, "cenc"));
                            }
                            break;
                    }
                }
            };
        },
        eventHandler = null,

        // IE11 does not let you set MediaKeys until it has entered a certain
        // readyState, so we need this logic to ensure we don't set the keys
        // too early
        setMediaKeys = function() {
            var doSetKeys = function() {
                videoElement.removeEventListener("loadedmetadata", boundDoSetKeys);
                videoElement[api.setMediaKeys](mediaKeys);
                this.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_VIDEO_ELEMENT_SELECTED);
            };
            if (videoElement.readyState >= 1) {
                doSetKeys.call(this);
            } else {
                boundDoSetKeys = doSetKeys.bind(this);
                videoElement.addEventListener("loadedmetadata", boundDoSetKeys);
            }

        },

        getKeyError = function(event) {
            var code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR,
                msg = "MediakeyError";

            if (event.errorCode) {
                switch (event.errorCode.code) {
                    case 1:
                        code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_UNKNOWN;
                        msg = "An unspecified error occurred. This value is used for errors that don't match any of the other codes.";
                        break;
                    case 2:
                        code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_CLIENT;
                        msg = "The Key System could not be installed or updated.";
                        break;
                    case 3:
                        code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_SERVICE;
                        msg = "The message passed into update indicated an error from the license service.";
                        break;
                    case 4:
                        code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_OUTPUT;
                        msg = "There is no available output device with the required characteristics for the content protection system.";
                        break;
                    case 5:
                        code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_HARDWARECHANGE;
                        msg += "A hardware configuration change caused a content protection error.";
                        break;
                    case 6:
                        code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_DOMAIN;
                        msg = "An error occurred in a multi-device domain licensing configuration. The most common error is a failure to join the domain.";
                        break;
                    default:
                        code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_UNKNOWN;
                        msg = "An unspecified error occurred. This value is used for errors that don't match any of the other codes.";
                        break;
                }
            } else {
                code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_UNKNOWN;
                msg = "An unspecified error occurred. This value is used for errors that don't match any of the other codes.";                
            }
            if (event.systemCode) {
                msg += "  (System Code = " + event.systemCode + ")";
            }
            return new MediaPlayer.vo.protection.KeyError(code, msg);
        },

        // Function to create our session token objects which manage the EME
        // MediaKeySession and session-specific event handler
        createSessionToken = function(keySession, initData) {
            var self = this;
            return { // Implements MediaPlayer.vo.protection.SessionToken
                session: keySession,
                initData: initData,

                // This is our main event handler for all desired MediaKeySession events
                // These events are translated into our API-independent versions of the
                // same events
                handleEvent: function(event) {
                    switch (event.type) {

                        case api.error:
                            self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_ERROR, getKeyError(event));
                            break;

                        case api.message:
                            var message = ArrayBuffer.isView(event.message) ? event.message.buffer : event.message;
                            self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_MESSAGE,
                                    new MediaPlayer.vo.protection.KeyMessage(this, message, event.destinationURL));
                            break;

                        case api.ready:
                            self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_ADDED, this);
                            break;

                        case api.close:
                            self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SESSION_CLOSED, this.getSessionID());
                            break;
                    }
                },

                getSessionID: function() {
                    return this.session.sessionId;
                },

                getExpirationTime: function() {
                    return NaN;
                },

                getSessionType: function() {
                    return "temporary";
                }
            };
        };

    return {
        system: undefined,
        notify: undefined,
        subscribe: undefined,
        unsubscribe: undefined,
        protectionExt: undefined,
        debug: undefined,
        keySystem: null,

        setup: function() {
            eventHandler = createEventHandler.call(this);
        },

        /**
         * Initialize this protection model
         */
        init: function() {
            var tmpVideoElement = document.createElement("video");
            api = MediaPlayer.models.ProtectionModel_3Feb2014.detect(tmpVideoElement);
        },

        teardown: function() {
            try {
                for (var i = 0; i < sessions.length; i++) {
                    this.closeKeySession(sessions[i]);
                }
                if (videoElement) {
                    videoElement.removeEventListener(api.needkey, eventHandler);
                }
                this.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_TEARDOWN_COMPLETE);
            } catch (error) {
                this.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_TEARDOWN_COMPLETE,
                        null, "Error tearing down key sessions and MediaKeys! -- " + error.message);
            }
        },

        getAllInitData: function() {
            var retVal = [];
            for (var i = 0; i < sessions.length; i++) {
                retVal.push(sessions[i].initData);
            }
            return retVal;
        },

        requestKeySystemAccess: function(ksConfigurations) {

            // Try key systems in order, first one with supported key system configuration
            // is used
            var found = false;
            for (var ksIdx = 0; ksIdx < ksConfigurations.length; ksIdx++) {
                var systemString = ksConfigurations[ksIdx].ks.systemString;
                var configs = ksConfigurations[ksIdx].configs;
                var supportedAudio = null;
                var supportedVideo = null;

                this.debug.log("[DRM][3Feb2014] Request access for key system " + systemString);

                // Try key system configs in order, first one with supported audio/video
                // is used
                for (var configIdx = 0; configIdx < configs.length; configIdx++) {
                    var audios = configs[configIdx].audioCapabilities;
                    var videos = configs[configIdx].videoCapabilities;

                    // Look for supported audio container/codecs
                    if (audios && audios.length !== 0) {
                        supportedAudio = []; // Indicates that we have a requested audio config
                        for (var audioIdx = 0; audioIdx < audios.length; audioIdx++) {
                            if (window[api.MediaKeys].isTypeSupported(systemString, audios[audioIdx].contentType)) {
                                //this.debug.log("[DRM][3Feb2014] audio codec supported: " + audios[audioIdx].contentType);
                                supportedAudio.push(audios[audioIdx]);
                            }
                        }
                    }

                    // Look for supported video container/codecs
                    if (videos && videos.length !== 0) {
                        supportedVideo = []; // Indicates that we have a requested video config
                        for (var videoIdx = 0; videoIdx < videos.length; videoIdx++) {
                            if (window[api.MediaKeys].isTypeSupported(systemString, videos[videoIdx].contentType)) {
                                //this.debug.log("[DRM][3Feb2014] video codec supported: " + videos[audioIdx].contentType);
                                supportedVideo.push(videos[videoIdx]);
                            }
                        }
                    }

                    // No supported audio or video in this configuration OR we have
                    // requested audio or video configuration that is not supported
                    if ((!supportedAudio && !supportedVideo) ||
                            (supportedAudio && supportedAudio.length === 0) ||
                            (supportedVideo && supportedVideo.length === 0)) {
                        continue;
                    }

                    // This configuration is supported
                    found = true;
                    var ksConfig = new MediaPlayer.vo.protection.KeySystemConfiguration(supportedAudio, supportedVideo);
                    var ks = this.protectionExt.getKeySystemBySystemString(systemString);
                    var ksAccess = new MediaPlayer.vo.protection.KeySystemAccess(ks, ksConfig);
                    this.debug.log("[DRM][3Feb2014] configuration supported = audio:" + JSON.stringify(supportedAudio) + ", video:" + JSON.stringify(supportedVideo));
                    this.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_ACCESS_COMPLETE,
                            ksAccess);
                    break;
                }
            }
            if (!found) {
                this.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_ACCESS_COMPLETE,
                        null, "[DRM][3Feb2014] Key system access denied! -- No valid audio/video content configurations detected!");
            }
        },

        selectKeySystem: function(ksAccess) {
            this.debug.log("[DRM][3Feb2014] Select key system " + ksAccess.keySystem.systemString);
            try {
                mediaKeys = ksAccess.mediaKeys = new window[api.MediaKeys](ksAccess.keySystem.systemString);
                this.keySystem = ksAccess.keySystem;
                keySystemAccess = ksAccess;
                if (videoElement) {
                    setMediaKeys.call(this);
                }
                this.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_SELECTED);

            } catch (error) {
                this.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_SELECTED,
                        null, "Error selecting keys system (" + this.keySystem.systemString + ")! Could not create MediaKeys -- TODO");
            }
        },

        setMediaElement: function(mediaElement) {
            if (videoElement === mediaElement)
                return;

            // Replacing the previous element
            if (videoElement) {
                videoElement.removeEventListener(api.needkey, eventHandler);
                videoElement.removeEventListener("loadedmetadata", boundDoSetKeys);
            }

            videoElement = mediaElement;

            // Only if we are not detaching from the existing element
            if (videoElement) {
                //videoElement.addEventListener(api.needkey, eventHandler);
                if (mediaKeys) {
                    setMediaKeys.call(this);
                }
            }

            return Q.when();
        },

        createKeySession: function(initData, sessionType, cdmData) {

            if (!this.keySystem || !mediaKeys || !keySystemAccess) {
                throw new Error("Can not create sessions until you have selected a key system");
            }

            this.debug.log("[DRM][3Feb2014] Create key session");

            // Use the first video capability for the contentType.
            // TODO:  Not sure if there is a way to concatenate all capability data into a RFC6386-compatible format
            var contentType = keySystemAccess.ksConfiguration.videoCapabilities[0].contentType;
            var session = mediaKeys.createSession(contentType, new Uint8Array(initData), cdmData ? new Uint8Array(cdmData) : null);
            var sessionToken = createSessionToken.call(this, session, initData);

            // Add all event listeners
            session.addEventListener(api.error, sessionToken);
            session.addEventListener(api.message, sessionToken);
            session.addEventListener(api.ready, sessionToken);
            session.addEventListener(api.close, sessionToken);

            // Add to our session list
            sessions.push(sessionToken);

            this.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SESSION_CREATED, sessionToken);
        },

        updateKeySession: function(sessionToken, message) {

            var session = sessionToken.session;

            this.debug.log("[DRM][3Feb2014] Update key session");

            if (!this.protectionExt.isClearKey(this.keySystem)) {
                // Send our request to the key session
                session.update(new Uint8Array(message));
            } else {
                // For clearkey, message is a MediaPlayer.vo.protection.ClearKeyKeySet
                session.update(new Uint8Array(message.toJWK()));
            }
        },

        /**
         * Close the given session and release all associated keys.  Following
         * this call, the sessionToken becomes invalid
         *
         * @param sessionToken the session token
         */
        closeKeySession: function(sessionToken) {

            this.debug.log("[DRM][3Feb2014] Close key session, token = " + sessionToken.session.sessionId);

            var session = sessionToken.session;

            // Remove event listeners
            session.removeEventListener(api.error, sessionToken);
            session.removeEventListener(api.message, sessionToken);
            session.removeEventListener(api.ready, sessionToken);
            session.removeEventListener(api.close, sessionToken);

            // Remove from our session list
            for (var i = 0; i < sessions.length; i++) {
                if (sessions[i] === sessionToken) {
                    sessions.splice(i,1);
                    break;
                }
            }

            // Send our request to the key session
            session[api.release]();
        },

        setServerCertificate: function(/*serverCertificate*/) { /* Not supported */ },

        loadKeySession: function(/*sessionID*/) { /* Not supported */ },

        removeKeySession: function(/*sessionToken*/) { /* Not supported */ },

        checkIfEncrypted: function() { /* Not supported */ }

    };
};

// Defines the supported 3Feb2014 API variations
MediaPlayer.models.ProtectionModel_3Feb2014.APIs = [
    // MS-prefixed (IE11, Windows 8.1)
    {
        // Video Element
        setMediaKeys: "msSetMediaKeys",

        // MediaKeys
        MediaKeys: "MSMediaKeys",

        // MediaKeySession
        release: "close",

        // Events
        needkey: "msneedkey",
        error: "mskeyerror",
        message: "mskeymessage",
        ready: "mskeyadded",
        close: "mskeyclose"
    },
    
    // Un-prefixed as per spec
    // Chrome 38-39 (and some earlier versions) with chrome://flags -- Enable Encrypted Media Extensions
    {
        // Video Element
        setMediaKeys: "setMediaKeys",

        // MediaKeys
        MediaKeys: "MediaKeys",

        // MediaKeySession
        release: "close",

        // Events
        needkey: "needkey",
        error: "keyerror",
        message: "keymessage",
        ready: "keyadded",
        close: "keyclose"
    }
];

/**
 * Detects presence of EME v3Feb2014 APIs
 *
 * @param videoElement {HTMLMediaElement} the media element that will be
 * used for detecting APIs
 * @returns {Object} an API object that is used when initializing the
 * ProtectionModel instance or null if this EME version is not supported
 */
MediaPlayer.models.ProtectionModel_3Feb2014.detect = function(videoElement) {
    var apis = MediaPlayer.models.ProtectionModel_3Feb2014.APIs;
    for (var i = 0; i < apis.length; i++) {
        var api = apis[i];
        if (typeof videoElement[api.setMediaKeys] !== 'function') {
            continue;
        }
        if (typeof window[api.MediaKeys] !== 'function')  {
            continue;
        }
        return api;
    }

    return null;
};

MediaPlayer.models.ProtectionModel_3Feb2014.prototype = {
    constructor: MediaPlayer.models.ProtectionModel_3Feb2014
};


/**
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Dash Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  * Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  * Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * Most recent EME implementation
 *
 * Implemented by Google Chrome v36+ (Windows, OSX, Linux)
 *
 * @implements MediaPlayer.models.ProtectionModel
 * @class
 */
MediaPlayer.models.ProtectionModel_21Jan2015 = function () {

    var videoElement = null,
        mediaKeys = null,
        eventHandler = null,

        // Session list
        sessions = [],

        arrayToHexString = function (array) {

            var str = "[",
                i;

            for (i = 0; i < array.length; i++) {
                str += "0x" + array[i].toString(16);
                if (i < (array.length - 1)) {
                    str += ",";
                }
            }

            str += "]";

            return str;
        },

        requestKeySystemAccessInternal = function(ksConfigurations, idx) {
            var self = this;

            if (navigator.requestMediaKeySystemAccess === undefined ||
                typeof navigator.requestMediaKeySystemAccess !== 'function') {
                this.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_ACCESS_COMPLETE, null, "Insecure origins are not allowed");
                return;
            }

            (function(i) {
                var keySystem = ksConfigurations[i].ks;
                var configs = ksConfigurations[i].configs;
                self.debug.log("[DRM][PM_21Jan2015] requestMediaKeySystemAccess: " + keySystem.systemString);
                navigator.requestMediaKeySystemAccess(keySystem.systemString, configs).then(function(mediaKeySystemAccess) {

                    // Chrome 40 does not currently implement MediaKeySystemAccess.getConfiguration()
                    var configuration = (typeof mediaKeySystemAccess.getConfiguration === 'function') ?
                            mediaKeySystemAccess.getConfiguration() : null;
                    var keySystemAccess = new MediaPlayer.vo.protection.KeySystemAccess(keySystem, configuration);
                    keySystemAccess.mksa = mediaKeySystemAccess;
                    self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_ACCESS_COMPLETE, keySystemAccess);
                }).catch(function() {
                    if (++i < ksConfigurations.length) {
                        requestKeySystemAccessInternal.call(self, ksConfigurations, i);
                    } else {
                        self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_ACCESS_COMPLETE, null, "Key system access denied!");
                    }
                });
            })(idx);
        },

        closeKeySessionInternal = function(sessionToken) {
            var session = sessionToken.session;
            // Remove event listeners
            session.removeEventListener("keystatuseschange", sessionToken);
            session.removeEventListener("message", sessionToken);

            // Send our request to the key session
            return session.close();
        },

        // This is our main event handler for all desired HTMLMediaElement events
        // related to EME.  These events are translated into our API-independent
        // versions of the same events
        createEventHandler = function() {
            var self = this;
            return {
                session : null,

                handleEvent: function(event) {
                    switch (event.type) {
                        case "encrypted":
                            self.debug.log("[DRM][PM_21Jan2015] 'encrypted' event");
                            if (event.initData) {
                                var initData = ArrayBuffer.isView(event.initData) ? event.initData.buffer : event.initData;
                                self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_NEED_KEY,
                                        new MediaPlayer.vo.protection.NeedKey(initData, "cenc"));
                            }
                            break;
                        case "waitingforkey":
                            self.debug.log("[DRM][PM_21Jan2015] 'waitingforkey' event");
                            if (this.session !== null && this.session.usable) {
                                // Widevine CDM doesn't raised error if keys don't match
                                // The unique way to check if the received license is valid is to track this event and raise an error
                                // this.session = null;
                                this.session.usable = false;
                                self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_ERROR,
                                    new MediaPlayer.vo.protection.KeyError(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_ENCRYPTED, "Media is encrypted and no valid key is available"));
                            }
                        break;
                    }
                }
            };
        },

        removeSession = function(token) {
            // Remove from our session list
            for (var i = 0; i < sessions.length; i++) {
                if (sessions[i] === token) {
                    sessions.splice(i, 1);
                    break;
                }
            }
        },

        // Function to create our session token objects which manage the EME
        // MediaKeySession and session-specific event handler
        createSessionToken = function(session, initData, sessionType) {
            var self = this,
                setSessionUsable = function (session, usable) {
                    for (var i = 0; i < sessions.length; i++) {
                        if (sessions[i].session === session) {
                            sessions[i].usable = usable;
                            break;
                        }
                    }
                };

            var token = { // Implements MediaPlayer.vo.protection.SessionToken
                session: session,
                initData: initData,
                usable: false,

                // This is our main event handler for all desired MediaKeySession events
                // These events are translated into our API-independent versions of the
                // same events
                handleEvent: function(event) {

                    switch (event.type) {

                        case "keystatuseschange":
                            self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_STATUSES_CHANGED, this);

                            event.target.keyStatuses.forEach(function() {
                                // has Edge and Chrome implement different version of keystatues, param are not on same order
                                var status, keyId;
                                if (arguments && arguments.length > 0) {
                                    if (arguments[0]) {
                                        if (typeof arguments[0] === 'string') {
                                            status = arguments[0];
                                        } else {
                                            keyId = arguments[0];
                                        }
                                    }

                                    if (arguments[1]) {
                                        if (typeof arguments[1] === 'string') {
                                            status = arguments[1];
                                        } else {
                                            keyId = arguments[1];
                                        }
                                    }
                                }
                                self.debug.log("[DRM][PM_21Jan2015] status = " + status + " for KID " + arrayToHexString(new Uint8Array(keyId)));
                                switch (status) {
                                    case "expired":
                                        setSessionUsable(event.target, false);
                                        self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_STATUSES_CHANGED, null,
                                            new MediaPlayer.vo.Error(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_EXPIRED, "License has expired", null));
                                        break;
                                    case "output-restricted":
                                        setSessionUsable(event.target, false);
                                        self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_STATUSES_CHANGED, null,
                                            new MediaPlayer.vo.Error(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_OUTPUT,
                                                                     "There is no available output device with the required characteristics for the content protection system",
                                                                     null));
                                        break;
                                    case "usable":
                                        setSessionUsable(event.target, true);
                                        // Check 'waitinfforkey' event in case the received license does not apply to current content
                                        videoElement.addEventListener("waitingforkey", eventHandler);
                                        break;

                                    //case "status-pending":
                                    default:
                                        self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_STATUSES_CHANGED,
                                            {status:status, keyId: keyId});
                                }
                            });

                            break;

                        case "message":
                            self.debug.log("[DRM][PM_21Jan2015] 'message' event: ", event);
                            var message = ArrayBuffer.isView(event.message) ? event.message.buffer : event.message;
                            self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_MESSAGE,
                                    new MediaPlayer.vo.protection.KeyMessage(this, message, undefined, event.messageType));
                            break;
                    }
                },

                getSessionID: function() {
                    return this.session.sessionId;
                },

                getExpirationTime: function() {
                    return this.session.expiration;
                },

                getKeyStatuses: function() {
                    return this.session.keyStatuses;
                },

                getSessionType: function() {
                    return sessionType;
                }
            };

            // Add all event listeners
            session.addEventListener("keystatuseschange", token);
            session.addEventListener("message", token);

            // Register callback for session closed Promise
            session.closed.then(function () {
                removeSession(token);
                self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SESSION_CLOSED,
                        token.getSessionID());
            });

            // Add to our session list
            sessions.push(token);

            return token;
        };

    return {
        system: undefined,
        notify: undefined,
        subscribe: undefined,
        unsubscribe: undefined,
        protectionExt: undefined,
        keySystem: null,
        config: null,
        debug: null,

        setup: function() {
            eventHandler = createEventHandler.call(this);
        },

        /**
         * Initialize this protection model
         */
        init: function() {
            eventHandler.session = null;
        },

        teardown: function() {
            var session,
                nbSessions = sessions.length,
                i,
                closeTimeout,
                self = this;

            this.debug.log("[DRM][PM_21Jan2015] Teardown");

            if (!this.config.getParam("Protection.licensePersistence", "boolean", false)) {
                // If license persistence is not enabled, then close sessions and release/delete MediaKeys instance
                // Called when we are done closing a session.
                var done = function(session) {
                    self.debug.log("[DRM][PM_21Jan2015] Session closed");
                    removeSession(session);
                    if (i >= (nbSessions - 1)) {
                        mediaKeys = null;
                        clearTimeout(closeTimeout);
                        self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_TEARDOWN_COMPLETE);
                    }
                };
                var close = function () {
                    for (i = 0; i < nbSessions; i++) {
                        done(sessions[i]);
                    }
                };

                if (nbSessions === 0) {
                    mediaKeys = null;
                    this.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_TEARDOWN_COMPLETE);
                    return;
                }

                for (i = 0; i < nbSessions; i++) {
                    session = sessions[i];
                    (function (s) {
                        self.debug.log("[DRM][PM_21Jan2015] Close session " + session.getSessionID());
                        // Override closed promise resolver
                        session.session.closed.then(function () {
                            done(s);
                        });
                        // Close the session and handle errors, otherwise promise resolver above will be called
                        closeKeySessionInternal(session).catch(function () {
                            done(s);
                        });
                    })(session);
                }
                // Patch for MediaKeySession.close() that may never resolve returned promise
                // (for example after license request failure)
                closeTimeout = setTimeout(close, 1000);
            } else {
                // If license persistence is enabled, then keep usable sessions data and MediaKeys instance
                for (i = 0; i < sessions.length; i++) {
                    session = sessions[i];
                    if (!session.usable) {
                       sessions.splice(i, 1);
                       i--;
                    }
                }
                this.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_TEARDOWN_COMPLETE);
            }
        },

        getAllInitData: function() {
            var retVal = [];
            for (var i = 0; i < sessions.length; i++) {
                retVal.push(sessions[i].initData);
            }
            return retVal;
        },

        requestKeySystemAccess: function(ksConfigurations) {
            requestKeySystemAccessInternal.call(this, ksConfigurations, 0);
        },

        selectKeySystem: function(keySystemAccess) {

            var self = this;

            self.debug.log("[DRM][PM_21Jan2015] Select key system, create new MediaKeys");

            // In case of license persistence we do not reset MediaKeys instance
            if (mediaKeys !== null) {
                self.debug.log("[DRM][PM_21Jan2015] MediaKeys already created");
                self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_SELECTED);
                return;
            }

            keySystemAccess.mksa.createMediaKeys().then(function(mkeys) {
                self.keySystem = keySystemAccess.keySystem;
                mediaKeys = mkeys;
                if (videoElement) {
                    videoElement.setMediaKeys(mediaKeys).then(
                        function () {
                            var serverCertificate = self.keySystem.getServerCertificate();
                            if (serverCertificate) {
                                // The server certificate must be set before creating any MediaKeySession
                                self.setServerCertificate(serverCertificate).then(function() {
                                    self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_SELECTED);
                                    videoElement.addEventListener("encrypted", eventHandler);
                                });
                            } else {
                                self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_SELECTED);
                                videoElement.addEventListener("encrypted", eventHandler);
                            }
                        }
                    );
                }
            }).catch(function() {
                self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_SELECTED,
                        null, "Error selecting keys system (" + keySystemAccess.keySystem.systemString + ")! Could not create MediaKeys -- TODO");

            });
        },

        setMediaElement: function(mediaElement) {
            var self = this,
                deferred = Q.defer();

            if (videoElement === mediaElement) {
                deferred.resolve();
                return deferred.promise;
            }

            if (videoElement) {
                videoElement.removeEventListener("encrypted", eventHandler);
                videoElement.removeEventListener("waitingforkey", eventHandler);
                if (videoElement.setMediaKeys) {
                    videoElement.setMediaKeys(null).then(
                        function () {
                            self.debug.log("[DRM][PM_21Jan2015] Successfully detached MediaKeys from video element");
                            deferred.resolve();
                        },
                        function (e) {
                            self.debug.error("[DRM][PM_21Jan2015] Failed to detach MediaKeys from video element: " + e);
                            deferred.resolve();
                        }
                    );
                } else {
                    deferred.resolve();
                }
            }

            videoElement = mediaElement;

            if (videoElement) {
                if (mediaKeys && videoElement.setMediaKeys) {
                    videoElement.addEventListener("encrypted", eventHandler);
                    videoElement.setMediaKeys(mediaKeys);
                }
            }

            return deferred.promise;
        },

        setServerCertificate: function(serverCertificate) {
            if (!this.keySystem || !mediaKeys) {
                throw new Error("Can not set server certificate until you have selected a key system");
            }

            this.debug.log("[DRM][PM_21Jan2015] Set server certificate");

            var self = this,
                deferred = Q.defer();

            mediaKeys.setServerCertificate(serverCertificate).then(function() {
                self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_SERVER_CERTIFICATE_UPDATED);
                deferred.resolve();
            }).catch(function(error) {
                self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_SERVER_CERTIFICATE_UPDATED,
                        null, "Error updating server certificate -- " + error.name);
                deferred.reject();
            });

            return deferred.promise;
        },

        createKeySession: function(initData, sessionType) {

            if (!this.keySystem || !mediaKeys) {
                throw new Error("Can not create sessions until you have selected a key system");
            }

            this.debug.log("[DRM][PM_21Jan2015] Create key session, type = " + sessionType);
            this.debug.log("[DRM][PM_21Jan2015] initData = " + String.fromCharCode.apply(null, new Uint8Array(initData)));

            var session = mediaKeys.createSession(sessionType);
            var sessionToken = createSessionToken.call(this, session, initData, sessionType);

            // Generate initial key request
            var self = this;
            session.generateRequest("cenc", initData).then(function() {
                self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SESSION_CREATED, sessionToken);
            }).catch(function(ex) {
                removeSession(sessionToken);
                self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SESSION_CREATED, null, {
                    reason: "Failed to generate key request",
                    error: new MediaPlayer.vo.Error(ex.code, ex.name, ex.message)
                });
            });
        },

        updateKeySession: function(sessionToken, message) {

            var session = sessionToken.session;

            // Send our request to the key session
            var self = this;

            self.debug.log("[DRM][PM_21Jan2015] Update key session. SessionID = " + session.sessionId);

            if (this.protectionExt.isClearKey(this.keySystem)) {
                message = message.toJWK();
            }
            session.update(message)
            .then(function() {
                eventHandler.session = sessionToken;
            })
            .catch(function (ex) {
                self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_ERROR,
                    new MediaPlayer.vo.protection.KeyError(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR, "Error while providing license to the CDM", ex));
            });
        },

        loadKeySession: function(sessionID) {
            if (!this.keySystem || !mediaKeys) {
                throw new Error("Can not load sessions until you have selected a key system");
            }

            this.debug.log("[DRM][PM_21Jan2015] Load key session. SessionID = " + sessionID);

            var session = mediaKeys.createSession();

            // Load persisted session data into our newly created session object
            var self = this;
            session.load(sessionID).then(function (success) {
                if (success) {
                    var sessionToken = createSessionToken.call(this, session);
                    self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SESSION_CREATED, sessionToken);
                } else {
                    self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SESSION_CREATED, null, {
                        reason: "Failed to load session " + sessionID,
                        error: null
                    });
                }
            }).catch(function (ex) {
                self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SESSION_CREATED, {
                    reason: "Failed to load session " + sessionID,
                    error: new MediaPlayer.vo.Error(ex.code, ex.name, ex.message)
                });
            });
        },

        removeKeySession: function(sessionToken) {

            var session = sessionToken.session;

            this.debug.log("[DRM][PM_21Jan2015] Remove key session. SessionID = " + sessionToken.getSessionID());

            var self = this;
            session.remove().then(function () {
                self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SESSION_REMOVED,
                    sessionToken.getSessionID());
            }, function (error) {
                self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SESSION_REMOVED,
                    null, "Error removing session (" + sessionToken.getSessionID() + "). " + error.name);
            });
        },

        closeKeySession: function(sessionToken) {

            this.debug.log("[DRM][PM_21Jan2015] Close key session. SessionID = " + sessionToken.getSessionID());

            // Send our request to the key session
            var self = this;
            closeKeySessionInternal(sessionToken).catch(function(error) {
                removeSession(sessionToken);
                self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SESSION_CLOSED,
                        null, "Error closing session (" + sessionToken.getSessionID() + ") " + error.name);
            });
        },

        checkIfEncrypted: function() { /* Not supported */ }
    };
};

/**
 * Detects presence of EME v21Jan2015 APIs
 *
 * @param videoElement {HTMLMediaElement} the media element that will be
 * used for detecting API support
 * @returns {Boolean} true if support was detected, false otherwise
 */
MediaPlayer.models.ProtectionModel_21Jan2015.detect = function(videoElement) {
    if (videoElement.onencrypted === undefined ||
        videoElement.mediaKeys === undefined) {
        return false;
    }

    if (window.MSMediaKeys) {
        return false;
    }

    // Do not check requestMediaKeySystemAccess function since it can be disable on insecure origins
    // if (navigator.requestMediaKeySystemAccess === undefined ||
    //     typeof navigator.requestMediaKeySystemAccess !== 'function') {
    //     return false;
    // }

    return true;
};

MediaPlayer.models.ProtectionModel_21Jan2015.prototype = {
    constructor: MediaPlayer.models.ProtectionModel_21Jan2015
};


/**
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Dash Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  * Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  * Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * Defines the public interface for all Key Systems (DRMs) supported
 * by the player.
 *
 * @interface
 */

MediaPlayer.dependencies.protection.KeySystem = function() {};

/**
 * Key system name string (e.g. 'org.w3.clearkey')
 *
 * @instance
 * @name systemString
 * @memberof MediaPlayer.dependencies.protection.KeySystem
 * @readonly
 * @type String
 */

/**
 * Key system UUID in the form '01234567-89ab-cdef-0123-456789abcdef'
 *
 * @instance
 * @name uuid
 * @memberof MediaPlayer.dependencies.protection.KeySystem
 * @readonly
 * @type String
 */

/**
 * The scheme ID URI for this key system in the form
 * 'urn:uuid:01234567-89ab-cdef-0123-456789abcdef' as used
 * in DASH ContentProtection elements
 *
 * @instance
 * @name schemeIdURI
 * @memberof MediaPlayer.dependencies.protection.KeySystem
 * @readonly
 * @type String
 */


/**
 * The sessionType used for the CDM
 *
 * @instance
 * @name sessionType
 * @memberof MediaPlayer.dependencies.protection.KeySystem
 * @readonly
 * @type String
 */

/**
 * Parse DRM-specific init data from the ContentProtection
 * element.
 *
 * @function
 * @name MediaPlayer.dependencies.protection.KeySystem#getInitData
 * @param {Object} contentProtection the json-style contentProtection
 * object representing the ContentProtection element parsed from the
 * MPD XML document.
 * @returns {ArrayBuffer} EME initialization data
 */

/**
 * For some key systems, the CDM message contains HTTP headers that
 * can be parsed by the application and attached to the license request.
 * Returns a header object with key/value pairs as object properties/values
 *
 * @function
 * @name MediaPlayer.dependencies.protection.KeySystem#getRequestHeadersFromMessage
 * @param {ArrayBuffer} message the CDM message
 * @returns {?Object} headers object with header names as the object property
 * names and header values as the corresponding object property values.  Return
 * null if no such headers were found or if the mechanism is not supported by
 * this key system
 */

/**
 * For some key systems, the CDM message contains more than just the
 * license request data.  This method will pull the license request from
 * the CDM message, if necessary.
 *
 * @function
 * @name MediaPlayer.dependencies.protection.KeySystem#getKeySystemConfigurations
 * @param {object} videoInfo contains relevant info about video (mimeType, codec)
 * @param {object} audioInfo contains relevant info about audio (mimeType, codec)
 * @param {String} sessionType the session type like "temporary" or "persistent-license"
 * @returns {Array} list of {MediaPlayer.vo.protection.KeySystemConfiguration}
 *

 * @function
 * @name MediaPlayer.dependencies.protection.KeySystem#getLicenseRequestFromMessage
 * @param message {ArrayBuffer} the CDM message
 * @returns {Uint8Array} the license request message as will be passed to
 * XMLHttpRequest.send()
 */

/**
 * Returns a license server URL as parsed from key system initialization data (PSSH).
 *
 * @function
 * @name MediaPlayer.dependencies.protection.KeySystem#getLicenseServerURLFromInitData
 * @param initData {ArrayBuffer} the initialization data.  This is just the "Data" field
 * from the PSSH box definition
 * @returns {?string} The license server URL or null if URL is not available in initData
 */

/**
 * Returns specific CDM (custom) data.
 *
 * @function
 * @name MediaPlayer.dependencies.protection.KeySystem#getCDMData
 * @returns {ArrayBuffer} the CDM (custom) data
 */

 /**
 * Returns the server certificate.
 *
 * @function
 * @name MediaPlayer.dependencies.protection.KeySystem#getServerCertificate
 * @returns {ArrayBuffer} the server certificate
 */
/**
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Dash Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  * Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  * Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * Adobe Access DRM
 *
 * @class
 * @implements MediaPlayer.dependencies.protection.KeySystem
 */
MediaPlayer.dependencies.protection.KeySystem_Access = function() {
    "use strict";
};

MediaPlayer.dependencies.protection.KeySystem_Access.prototype = {
    constructor: MediaPlayer.dependencies.protection.KeySystem_Access
};


/**
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Dash Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  * Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  * Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */

MediaPlayer.dependencies.protection.KeySystem_ClearKey = function() {
    "use strict";

    var keySystemStr = "org.w3.clearkey",
        keySystemUUID = "1077efec-c0b2-4d02-ace3-3c1e52e2fb4b",
        protData;

    return {

        system: undefined,
        schemeIdURI: "urn:uuid:" + keySystemUUID,
        systemString: keySystemStr,
        uuid: keySystemUUID,
        sessionType:"temporary",

        init: function(protectionData){
            protData = protectionData;
        },

        getInitData: MediaPlayer.dependencies.protection.CommonEncryption.parseInitDataFromContentProtection,

        getKeySystemConfigurations: MediaPlayer.dependencies.protection.CommonEncryption.getKeySystemConfigurations,

        getRequestHeadersFromMessage: function(/*message*/) { return null; },

        getLicenseRequestFromMessage: function(message) { return new Uint8Array(message); },

        getLicenseServerURLFromInitData: function(/*initData*/) { return null; },

        getCDMData: function () {return null;},

        getServerCertificate: function () { return null; },
    };
};

MediaPlayer.dependencies.protection.KeySystem_ClearKey.prototype = {
    constructor: MediaPlayer.dependencies.protection.KeySystem_ClearKey
};

/**
 * Returns desired clearkeys (as specified in the CDM message) from protection data
 *
 * @param {MediaPlayer.vo.protection.ProtectionData} protData the protection data
 * @param {ArrayBuffer} message the ClearKey CDM message
 * @returns {MediaPlayer.vo.protection.ClearKeyKeySet} the key set or null if none found
 * @throws {Error} if a keyID specified in the CDM message was not found in the
 * protection data
 * @memberof MediaPlayer.dependencies.protection.KeySystem_ClearKey
 */
MediaPlayer.dependencies.protection.KeySystem_ClearKey.getClearKeysFromProtectionData = function(protData, message) {
    var clearkeySet = null;
    if (protData) {
        // ClearKey is the only system that does not require a license server URL, so we
        // handle it here when keys are specified in protection data
        var jsonMsg = JSON.parse(String.fromCharCode.apply(null, new Uint8Array(message)));
        var keyPairs = [];
        for (var i = 0; i < jsonMsg.kids.length; i++) {
            var clearkeyID = jsonMsg.kids[i],
                    clearkey = (protData.clearkeys.hasOwnProperty(clearkeyID)) ? protData.clearkeys[clearkeyID] : null;
            if (!clearkey) {
                throw new Error("[DRM] ClearKey keyID (" + clearkeyID + ") is not known!");
            }
            // KeyIDs from CDM are not base64 padded.  Keys may or may not be padded
            keyPairs.push(new MediaPlayer.vo.protection.KeyPair(clearkeyID, clearkey));
        }
        clearkeySet = new MediaPlayer.vo.protection.ClearKeyKeySet(keyPairs);
    }
    return clearkeySet;
};



/**
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Dash Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  * Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  * Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * Microsoft PlayReady DRM
 *
 * @class
 * @implements MediaPlayer.dependencies.protection.KeySystem
 */
MediaPlayer.dependencies.protection.KeySystem_PlayReady = function() {
    "use strict";

    var keySystemStr = "com.microsoft.playready",
        keySystemUUID = "9a04f079-9840-4286-ab92-e65be0885f95",
        PRCDMData = '<PlayReadyCDMData type="LicenseAcquisition"><LicenseAcquisition version="1.0" Proactive="false"><CustomData encoding="base64encoded">%CUSTOMDATA%</CustomData></LicenseAcquisition></PlayReadyCDMData>',
        protData,

        getRequestHeaders = function(message) {
            var msg,
                xmlDoc,
                headers = {},
                data = (message instanceof ArrayBuffer) ? message : message.buffer,
                dataview = MediaPlayer.utils.isUTF16(new Uint8Array(data)) ? new Uint16Array(data) : new Uint8Array(data),
                headerNameList,
                headerValueList,
                i = 0;

            msg = String.fromCharCode.apply(null, dataview);
            xmlDoc = this.domParser.createXmlTree(msg);

            headerNameList = xmlDoc.getElementsByTagName("name");
            headerValueList = xmlDoc.getElementsByTagName("value");
            for (i = 0; i < headerNameList.length; i += 1) {
                headers[headerNameList[i].childNodes[0].nodeValue] = headerValueList[i].childNodes[0].nodeValue;
            }
            // Some versions of the PlayReady CDM return 'Content' instead of 'Content-Type'.
            // this is NOT w3c conform and license servers may reject the request!
            // -> rename it to proper w3c definition!
            if (headers.hasOwnProperty('Content')) {
                headers['Content-Type'] = headers.Content;
                delete headers.Content;
            }

            // Some versions of the PlayReady CDM do not return headers at all, which means the Content-Type
            // does not get set and most license servers will just refuse the license request.
            // -> set it manually if is missing.
            if (!headers.hasOwnProperty('Content-Type')) {
                headers['Content-Type'] = 'text/xml; charset=utf-8';
            }

            return headers;
        },

        getLicenseRequest = function(message) {
            var msg,
                xmlDoc,
                licenseRequest = null,
                data = (message instanceof ArrayBuffer) ? message : message.buffer,
                dataview = MediaPlayer.utils.isUTF16(new Uint8Array(data)) ? new Uint16Array(data) : new Uint8Array(data),
                Challenge;

            msg = String.fromCharCode.apply(null, dataview);

            xmlDoc = this.domParser.createXmlTree(msg);

            if (xmlDoc.getElementsByTagName("Challenge")[0]) {
                Challenge = xmlDoc.getElementsByTagName("Challenge")[0].childNodes[0].nodeValue;
                if (Challenge) {
                    licenseRequest = BASE64.decode(Challenge);
                }
            }
            if (!licenseRequest) {
                // Some versions of the PlayReady CDM do not return the Microsoft-specified XML structure
                // but just return the raw license request. If we can't extract the license request, let's
                // assume it is the latter and just return the whole message.
                licenseRequest = msg;
            }
            return licenseRequest;
        },

        getLicenseServerURL = function(initData) {
            if (initData) {
                var data = new DataView(initData),
                        numRecords = data.getUint16(4, true),
                        offset = 6,
                        i = 0,
                        recordType,
                        recordLength,
                        recordData,
                        record,
                        xmlDoc,
                        laurl,
                        luiurl;

                for (i = 0; i < numRecords; i++) {
                    // Parse the PlayReady Record header
                    recordType = data.getUint16(offset, true);
                    offset += 2;
                    recordLength = data.getUint16(offset, true);
                    offset += 2;
                    if (recordType !== 0x0001) {
                        offset += recordLength;
                        continue;
                    }

                    recordData = initData.slice(offset, offset+recordLength);
                    record = String.fromCharCode.apply(null, new Uint16Array(recordData));
                    xmlDoc = this.domParser.createXmlTree(record);

                    // First try <LA_URL>
                    if (xmlDoc.getElementsByTagName("LA_URL")[0]) {
                        laurl = xmlDoc.getElementsByTagName("LA_URL")[0].childNodes[0].nodeValue;
                        if (laurl) {
                            return laurl;
                        }
                    }

                    // Optionally, try <LUI_URL>
                    if (xmlDoc.getElementsByTagName("LUI_URL")[0]) {
                        luiurl = xmlDoc.getElementsByTagName("LUI_URL")[0].childNodes[0].nodeValue;
                        if (luiurl) {
                            return luiurl;
                        }
                    }
                }
            }

            return null;

        },

        parseInitDataFromContentProtection = function(cpData) {
            // * desc@ getInitData
            // *   generate PSSH data from PROHeader defined in MPD file
            // *   PSSH format:
            // *   size (4)
            // *   box type(PSSH) (8)
            // *   Protection SystemID (16)
            // *   protection system data size (4) - length of decoded PROHeader
            // *   decoded PROHeader data from MPD file
            var byteCursor = 0,
                PROSize,
                PSSHSize,
                PSSHBoxType = new Uint8Array([0x70, 0x73, 0x73, 0x68, 0x00, 0x00, 0x00, 0x00 ]), //'PSSH' 8 bytes
                playreadySystemID = new Uint8Array([0x9a, 0x04, 0xf0, 0x79, 0x98, 0x40, 0x42, 0x86, 0xab, 0x92, 0xe6, 0x5b, 0xe0, 0x88, 0x5f, 0x95]),
                uint8arraydecodedPROHeader = null,
                PSSHBoxBuffer,
                PSSHBox,
                PSSHData;

            // Handle common encryption PSSH
            if ("pssh" in cpData) {
                return MediaPlayer.dependencies.protection.CommonEncryption.parseInitDataFromContentProtection(cpData);
            }
            // Handle native MS PlayReady ContentProtection elements
            if ("pro" in cpData) {
                uint8arraydecodedPROHeader = BASE64.decodeArray(cpData.pro.__text);
            }
            else if ("prheader" in cpData) {
                uint8arraydecodedPROHeader = BASE64.decodeArray(cpData.prheader.__text);
            }
            else {
                return null;
            }

            PROSize = uint8arraydecodedPROHeader.length;
            PSSHSize = 0x4 + PSSHBoxType.length + playreadySystemID.length + 0x4 + PROSize;

            PSSHBoxBuffer = new ArrayBuffer(PSSHSize);

            PSSHBox = new Uint8Array(PSSHBoxBuffer);
            PSSHData = new DataView(PSSHBoxBuffer);

            PSSHData.setUint32(byteCursor, PSSHSize);
            byteCursor += 0x4;

            PSSHBox.set(PSSHBoxType, byteCursor);
            byteCursor += PSSHBoxType.length;

            PSSHBox.set(playreadySystemID, byteCursor);
            byteCursor += playreadySystemID.length;

            PSSHData.setUint32(byteCursor, PROSize);
            byteCursor += 0x4;

            PSSHBox.set(uint8arraydecodedPROHeader, byteCursor);
            byteCursor += PROSize;

            return PSSHBox.buffer;
        },

        doGetCDMData = function () {
            var customData,
                cdmData,
                cdmDataBytes,
                i;

            if (protData && protData.cdmData) {

                // Convert custom data into multibyte string
                customData = [];
                for (i = 0; i < protData.cdmData.length; ++i) {
                    customData.push(protData.cdmData.charCodeAt(i));
                    customData.push(0);
                }
                customData = String.fromCharCode.apply(null, customData);

                // Encode in Base 64 the custom data string
                customData = BASE64.encode(customData);

                // Initialize CDM data with Base 64 encoded custom data
                // (see https://msdn.microsoft.com/en-us/library/dn457361.aspx)
                cdmData = PRCDMData.replace('%CUSTOMDATA%', customData);

                // Convert CDM data into multibyte characters
                cdmDataBytes = [];
                for (i = 0; i < cdmData.length; ++i) {
                    cdmDataBytes.push(cdmData.charCodeAt(i));
                    cdmDataBytes.push(0);
                }

                return new Uint8Array(cdmDataBytes).buffer;
            }

            return null;
        };

    return {

        schemeIdURI: "urn:uuid:" + keySystemUUID,
        systemString: keySystemStr,
        uuid: keySystemUUID,
        notify: undefined,
        subscribe: undefined,
        unsubscribe: undefined,
        domParser: undefined,
        /*sessionType:"persistent-license",*/
        sessionType:"temporary",

        init: function(protectionData){
            if(protectionData){
                protData = protectionData;
                if(protData.sessionType){
                    this.sessionType = protData.sessionType;
                }
            }
        },

        getInitData: parseInitDataFromContentProtection,

        getKeySystemConfigurations: MediaPlayer.dependencies.protection.CommonEncryption.getKeySystemConfigurations,

        getRequestHeadersFromMessage: getRequestHeaders,

        getLicenseRequestFromMessage: getLicenseRequest,

        getLicenseServerURLFromInitData: getLicenseServerURL,

        getCDMData: doGetCDMData,

        getServerCertificate: function () { return null; },

    };
};

MediaPlayer.dependencies.protection.KeySystem_PlayReady.prototype = {
    constructor: MediaPlayer.dependencies.protection.KeySystem_PlayReady
};

/**
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Dash Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  * Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  * Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * Google Widevine DRM
 *
 * @class
 * @implements MediaPlayer.dependencies.protection.KeySystem
 */
MediaPlayer.dependencies.protection.KeySystem_Widevine = function() {
    "use strict";

    var keySystemStr = "com.widevine.alpha",
        keySystemUUID = "edef8ba9-79d6-4ace-a3c8-27dcd51d21ed",
        protData,

        doGetInitData = function(cpData) {
            return MediaPlayer.dependencies.protection.CommonEncryption.parseInitDataFromContentProtection(cpData);
        },

        doGetKeySystemConfigurations = function(videoCodec, audioCodec, sessionType) {
            var ksConfigurations = MediaPlayer.dependencies.protection.CommonEncryption.getKeySystemConfigurations(videoCodec, audioCodec, sessionType);
            if (protData) {
                if (protData.audioRobustness && ksConfigurations[0].audioCapabilities.length > 0) {
                    ksConfigurations[0].audioCapabilities[0].robustness = protData.audioRobustness;
                }
                if (protData.videoRobustness && ksConfigurations[0].videoCapabilities.length > 0) {
                    ksConfigurations[0].videoCapabilities[0].robustness = protData.videoRobustness;
                }
            }
            return ksConfigurations;
        },

        doGetServerCertificate = function() {
            if (protData && protData.serverCertificate && protData.serverCertificate.length > 0) {
                return BASE64.decodeArray(protData.serverCertificate).buffer;
            }
            return null;
        };

    return {

        schemeIdURI: "urn:uuid:" + keySystemUUID,
        systemString: keySystemStr,
        uuid: keySystemUUID,
        sessionType: "temporary",

        init: function(protectionData) {
            protData = protectionData;
            if (protData && protData.sessionType) {
                this.sessionType = protData.sessionType;
            }
        },

        getInitData: doGetInitData,

        getKeySystemConfigurations: doGetKeySystemConfigurations,

        getRequestHeadersFromMessage: function(/*message*/) { return null; },

        getLicenseRequestFromMessage: function(message) { return new Uint8Array(message); },

        getLicenseServerURLFromInitData: function(/*initData*/) { return null; },

        getCDMData: function() { return null; },

        getServerCertificate: doGetServerCertificate

    };
};

MediaPlayer.dependencies.protection.KeySystem_Widevine.prototype = {
    constructor: MediaPlayer.dependencies.protection.KeySystem_Widevine
};
/**
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Dash Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  * Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  * Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * CableLabs ClearKey license server implementation
 *
 * For testing purposes and evaluating potential uses for ClearKey, we have developed
 * a dirt-simple API for requesting ClearKey licenses from a remote server.
 *
 * @implements MediaPlayer.dependencies.protection.servers.LicenseServer
 * @class
 */
MediaPlayer.dependencies.protection.servers.ClearKey = function() {
    "use strict";

    return {

        getServerURLFromMessage: function(url, message /*, messageType*/ ) {
            // Build ClearKey server query string
            var jsonMsg = JSON.parse(String.fromCharCode.apply(null, new Uint8Array(message))),
                i = 0;
            url += "/?";
            for (i = 0; i < jsonMsg.kids.length; i++) {
                url += jsonMsg.kids[i] + "&";
            }
            url = url.substring(0, url.length - 1);
            return url;
        },

        getHTTPMethod: function( /*messageType*/ ) {
            return 'GET';
        },

        getResponseType: function( /*keySystemStr*/ ) {
            return 'json';
        },

        getLicenseMessage: function(serverResponse /*, keySystemStr, messageType*/ ) {
            var i, keyPairs = [],
                keypair,
                keyid,
                key;
            if (!serverResponse.hasOwnProperty("keys")) {
                return null;
            }

            for (i = 0; i < serverResponse.keys.length; i++) {
                keypair = serverResponse.keys[i];
                keyid = keypair.kid.replace(/=/g, "");
                key = keypair.k.replace(/=/g, "");
                keyPairs.push(new MediaPlayer.vo.protection.KeyPair(keyid, key));
            }
            return new MediaPlayer.vo.protection.ClearKeyKeySet(keyPairs);
        },

        getErrorResponse: function(serverResponse/*, keySystemStr, messageType*/) {
            return {
                code: 0,
                name: "UnknownError",
                message: String.fromCharCode.apply(null, new Uint8Array(serverResponse))
            };
        }
    };
};

MediaPlayer.dependencies.protection.servers.ClearKey.prototype = {
    constructor: MediaPlayer.dependencies.protection.servers.ClearKey
};

/**
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Dash Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  * Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  * Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * CastLabs DRMToday License Server implementation
 *
 * @implements MediaPlayer.dependencies.protection.servers.LicenseServer
 * @class
 */
MediaPlayer.dependencies.protection.servers.DRMToday = function() {
    "use strict";

    var keySystems = {
        "com.widevine.alpha": {
            responseType: "json",
            getLicenseMessage: function(response) {
                return BASE64.decodeArray(response.license);
            },
            getErrorResponse: function(response) {
                return response;
            }
        },
        "com.microsoft.playready": {
            responseType: "arraybuffer",
            getLicenseMessage: function(response) {
                return response;
            },
            getErrorResponse: function(response) {
                return String.fromCharCode.apply(null, new Uint8Array(response));
            }
        }
    };

    return {

        getServerURLFromMessage: function(url /*, message, messageType*/) { return url; },

        getHTTPMethod: function(/*messageType*/) { return 'POST'; },

        getResponseType: function(keySystemStr/*, messageType*/) {
            return keySystems[keySystemStr].responseType;
        },

        getLicenseMessage: function(serverResponse, keySystemStr/*, messageType*/) {
            return keySystems[keySystemStr].getLicenseMessage(serverResponse);
        },

        getErrorResponse: function(serverResponse, keySystemStr/*, messageType*/) {
            return {
                code: 0,
                name: "UnknownError",
                message: keySystems[keySystemStr].getErrorResponse(serverResponse)
            };
        }
    };
};

MediaPlayer.dependencies.protection.servers.DRMToday.prototype = {
    constructor: MediaPlayer.dependencies.protection.servers.DRMToday
};

/**
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Dash Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  * Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  * Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * Defines the public interface for license server implementations supported
 * by the player.
 *
 * Different license servers have different requirements regarding the methods
 * used to request DRM licenses.  Things like request headers, license response
 * formats (for both error and success cases) need to be customized for a
 * specific server implementation
 *
 * License servers handle requests for more than just initial license retrieval.
 * Each API takes a parameter which describes the message type as supported by
 * the Encrypted Media Extensions.
 *
 * @interface
 */

MediaPlayer.dependencies.protection.servers.LicenseServer = function() {};

/**
 * Returns a new or updated license server URL based on the requirements of the
 * license server and possibly from information passed in the CDM license message
 *
 * @function
 * @name MediaPlayer.dependencies.protection.servers.LicenseServer#getServerURLFromMessage
 * @param {?string} url the initially established URL (from ProtectionData or initData)
 * @param {ArrayBuffer} message the CDM message which may be needed to generate the license
 * requests URL
 * @param {String} messageType the message type associated with this request.  Supported
 * message types can be found {@link https://w3c.github.io/encrypted-media/#idl-def-MediaKeyMessageType|here}.
 * @returns {string} the URL to use in license requests
 */

/**
 * Returns the HTTP method to be used (i.e. "GET", "POST", etc.) in
 * XMLHttpRequest.open().
 *
 * @function
 * @name MediaPlayer.dependencies.protection.servers.LicenseServer#getHTTPMethod
 * @param {String} messageType the message type associated with this request.  Supported
 * message types can be found {@link https://w3c.github.io/encrypted-media/#idl-def-MediaKeyMessageType|here}.
 * @returns {string} the HTTP method
 */

/**
 * Returns the response type to set for XMLHttpRequest.responseType
 *
 * @function
 * @name MediaPlayer.dependencies.protection.servers.LicenseServer#getResponseType
 * @param {string} keySystemStr the key system string representing the key system
 * associated with a license request.  Multi-DRM license servers may have different
 * response types depending on the key system.
 * @param {String} messageType the message type associated with this request.  Supported
 * message types can be found {@link https://w3c.github.io/encrypted-media/#idl-def-MediaKeyMessageType|here}.
 * @returns {string} the response type
 */

/**
 * Parses the license server response for any message intended for
 * the CDM.
 *
 * @function
 * @name MediaPlayer.dependencies.protection.servers.LicenseServer#getLicenseMessage
 * @param {Object} serverResponse the response as returned in XMLHttpRequest.response
 * @param {string} keySystemStr the key system string representing the key system
 * associated with a license request.
 * @param {String} messageType the message type associated with this request.  Supported
 * message types can be found {@link https://w3c.github.io/encrypted-media/#idl-def-MediaKeyMessageType|here}.
 * @returns {ArrayBuffer} message that will be sent to the CDM or null if no CDM message
 * was present in the response.
 */

/**
 * Parses the license server response during error conditions and returns a
 * string to display for debugging purposes
 *
 * @function
 * @name MediaPlayer.dependencies.protection.servers.LicenseServer#getErrorResponse
 * @param {Object} serverResponse the server response
 * @param {String} messageType the message type associated with this request.  Supported
 * message types can be found {@link https://w3c.github.io/encrypted-media/#idl-def-MediaKeyMessageType|here}.
 * @returns {string} an error message that indicates the reason for the failure
 */

/**
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Dash Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  * Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  * Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * Microsoft PlayReady Test License Server
 *
 * For testing content that uses the PlayReady test server at
 *
 * @implements MediaPlayer.dependencies.protection.servers.LicenseServer
 * @class
 */
MediaPlayer.dependencies.protection.servers.PlayReady = function() {
    "use strict";

    var decodeUtf8 = function(arrayBuffer) {
            var result = "",
                i = 0,
                c = 0,
                c2 = 0,
                c3 = 0,
                data = new Uint8Array(arrayBuffer);

            // If we have a BOM skip it
            if (data.length >= 3 && data[0] === 0xef && data[1] === 0xbb && data[2] === 0xbf) {
                i = 3;
            }

            while (i < data.length) {
                c = data[i];

                if (c < 128) {
                    result += String.fromCharCode(c);
                    i++;
                } else if (c > 191 && c < 224) {
                    if (i + 1 >= data.length) {
                        throw "UTF-8 Decode failed. Two byte character was truncated.";
                    }
                    c2 = data[i + 1];
                    result += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
                    i += 2;
                } else {
                    if (i + 2 >= data.length) {
                        throw "UTF-8 Decode failed. Multi byte character was truncated.";
                    }
                    c2 = data[i + 1];
                    c3 = data[i + 2];
                    result += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
                    i += 3;
                }
            }
            return result;
        },

        parseServerResponse = function(serverResponse) {
            var stringResponse = decodeUtf8(serverResponse),
                xmlDoc = this.domParser.createXmlTree(stringResponse),
                enveloppe = xmlDoc ? this.domParser.getChildNode(xmlDoc, "soap:Envelope") : null,
                body = enveloppe ? this.domParser.getChildNode(enveloppe, "soap:Body") : null,
                fault = body ? this.domParser.getChildNode(body, "soap:Fault") : null;

            if (fault) {
                return null;
            }

            return serverResponse;
        },

        parseErrorResponse = function(serverResponse) {
            var stringResponse = decodeUtf8(serverResponse),
                xmlDoc = this.domParser.createXmlTree(stringResponse),
                enveloppe = xmlDoc ? this.domParser.getChildNode(xmlDoc, "soap:Envelope") : null,
                body = enveloppe ? this.domParser.getChildNode(enveloppe, "soap:Body") : null,
                fault = body ? this.domParser.getChildNode(body, "soap:Fault") : null,
                detail = fault ? this.domParser.getChildNode(fault, "detail") : null,
                exception = detail ? this.domParser.getChildNode(detail, "Exception") : null,
                node = null,
                faultstring = "",
                statusCode = "",
                message = "",
                idStart = -1,
                idEnd = -1;

            if (fault === null) {
                return {
                    code: 0,
                    name: "UnknownError",
                    message: String.fromCharCode.apply(null, new Uint8Array(serverResponse))
                };
            }

            node = this.domParser.getChildNode(fault, "faultstring").firstChild;
            faultstring = node ? node.nodeValue : null;

            if (exception !== null) {
                node = this.domParser.getChildNode(exception, "StatusCode");
                statusCode = node ? node.firstChild.nodeValue : null;

                node = this.domParser.getChildNode(exception, "Message");
                message = node ? node.firstChild.nodeValue : null;
                idStart = message ? message.lastIndexOf('[') + 1 : -1;
                idEnd = message ? message.indexOf(']') : -1;
            }

            return {
                code: statusCode,
                name: faultstring,
                message: message ? message.substring(idStart, idEnd) : ""
            };
        };

    return {
        domParser: undefined,

        getServerURLFromMessage: function(url /*, message, messageType*/) { return url; },

        getHTTPMethod: function(/*messageType*/) { return 'POST'; },

        getResponseType: function(/*keySystemStr, messageType*/) { return 'arraybuffer'; },

        getLicenseMessage: function(serverResponse/*, keySystemStr, messageType*/) {
            return parseServerResponse.call(this, serverResponse);
        },

        getErrorResponse: function(serverResponse/*, keySystemStr, messageType*/) {
            return parseErrorResponse.call(this, serverResponse);
        }
    };
};

MediaPlayer.dependencies.protection.servers.PlayReady.prototype = {
    constructor: MediaPlayer.dependencies.protection.servers.PlayReady
};

/**
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Dash Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  * Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  * Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */

MediaPlayer.dependencies.protection.servers.Widevine = function() {
    "use strict";

    return {

        getServerURLFromMessage: function(url /*, message, messageType*/) { return url; },

        getHTTPMethod: function(/*messageType*/) { return 'POST'; },

        getResponseType: function(/*keySystemStr, messageType*/) { return 'arraybuffer'; },

        getLicenseMessage: function(serverResponse/*, keySystemStr, messageType*/) {
            return serverResponse;
        },

        getErrorResponse: function(serverResponse/*, keySystemStr, messageType*/) {
            return {
                code: 0,
                name: "UnknownError",
                message: String.fromCharCode.apply(null, new Uint8Array(serverResponse))
            };
        }
    };
};

MediaPlayer.dependencies.protection.servers.Widevine.prototype = {
    constructor: MediaPlayer.dependencies.protection.servers.Widevine
};

/**
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Dash Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  * Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  * Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * A collection of ClearKey encryption keys with an (optional) associated
 * type
 *
 * @param keyPairs {MediaPlayer.vo.protection.KeyPair[]} array of key pairs
 * @param type the type of keys in this set.  One of either 'persistent'
 * or 'temporary'.  Can also be null or undefined.
 * @constructor
 */
MediaPlayer.vo.protection.ClearKeyKeySet = function(keyPairs, type) {
    if (type && type !== "persistent" && type !== "temporary")
        throw new Error("Invalid ClearKey key set type!  Must be one of 'persistent' or 'temporary'");
    this.keyPairs = keyPairs;
    this.type = type;

    /**
     * Convert this key set to its JSON Web Key (JWK) representation
     *
     * @return {ArrayBuffer} JWK object UTF-8 encoded as ArrayBuffer
     */
    this.toJWK = function() {
        var i, numKeys = this.keyPairs.length,
            jwk = {};
        jwk.keys = [];
        for (i = 0; i < numKeys; i++) {
            var key = {
                kty: "oct",
                alg: "A128KW",
                kid: this.keyPairs[i].keyID,
                k: this.keyPairs[i].key
            };
            jwk.keys.push(key);
        }
        if (this.type) {
            jwk.type = this.type;
        }
        var jwkString = JSON.stringify(jwk);
        var len = jwkString.length;

        // Convert JSON string to ArrayBuffer
        var buf = new ArrayBuffer(len);
        var bView = new Uint8Array(buf);
        for (i = 0; i < len; i++)
            bView[i] = jwkString.charCodeAt(i);
        return buf;
    };
};

MediaPlayer.vo.protection.ClearKeyKeySet.prototype = {
    constructor: MediaPlayer.vo.protection.ClearKeyKeySet
};

/**
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Dash Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  * Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  * Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * EME-independent KeyError
 *
 * @param sessionToken the key session to which this error is associated
 * @param errorString an informational error message
 * @class
 * @deprecated Newest versions of EME APIs will not use this error object
 */
MediaPlayer.vo.protection.KeyError = function(code, message, data) {
    "use strict";
    this.code = code;
    this.message = message;
    this.data = data;
};

MediaPlayer.vo.protection.KeyError.prototype = {
    constructor: MediaPlayer.vo.protection.KeyError
};


/**
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Dash Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  * Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  * Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * EME-independent KeyMessage
 *
 * @param {MediaPlayer.vo.protection.SessionToken} sessionToken the session
 * to which the key message is associated
 * @param {ArrayBuffer} message the key message
 * @param [defaultURL] license acquisition URL provided by the CDM
 * @param [messageType] the message type.  One of "license-request",
 * "license-renewal", "license-release", "individualization-request"
 * @constructor
 */
MediaPlayer.vo.protection.KeyMessage = function(sessionToken, message, defaultURL, messageType) {
    "use strict";
    this.sessionToken = sessionToken;
    this.message = message;
    this.defaultURL = defaultURL;
    this.messageType = messageType;
};

MediaPlayer.vo.protection.KeyMessage.prototype = {
    constructor: MediaPlayer.vo.protection.KeyMessage
};


/**
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Dash Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  * Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  * Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * Represents a 128-bit keyID and 128-bit encryption key
 *
 * @param keyID {String} 128-bit key ID, base64 encoded, with no padding
 * @param key {String} 128-bit encryption key, base64 encoded, with no padding
 * @constructor
 */
MediaPlayer.vo.protection.KeyPair = function(keyID, key) {
    "use strict";
    this.keyID = keyID;
    this.key = key;
};

MediaPlayer.vo.protection.KeyPair.prototype = {
    constructor: MediaPlayer.vo.protection.KeyPair
};


/**
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Dash Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  * Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  * Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * Creates a new key system access token.  Represents a valid key system for
 * given piece of content and key system requirements.  Used to initialize license
 * acquisition operations.
 *
 * @param {MediaPlayer.dependencies.protection.KeySystem} keySystem the key system
 * @param {MediaPlayer.vo.protection.KeySystemConfiguration} ksConfiguration the
 * subset of configurations passed to the key system access request that are supported
 * by this user agent
 * @constructor
 */
MediaPlayer.vo.protection.KeySystemAccess = function(keySystem, ksConfiguration) {
    this.keySystem = keySystem;
    this.ksConfiguration = ksConfiguration;
};

MediaPlayer.vo.protection.KeySystemAccess.prototype = {
    constructor: MediaPlayer.vo.protection.KeySystemAccess
};


/**
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Dash Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  * Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  * Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */

/**
 *
 * @param {MediaPlayer.vo.protection.MediaCapability[]} audioCapabilities
 * @param {MediaPlayer.vo.protection.MediaCapability[]} videoCapabilities
 * @param {string} [distinctiveIdentifier]
 * @param {string} [persistentState]
 * @constructor
 */
MediaPlayer.vo.protection.KeySystemConfiguration = function(audioCapabilities, videoCapabilities, distinctiveIdentifier, persistentState, sessionTypes) {
    this.initDataTypes = [ "cenc" ];
    this.audioCapabilities = audioCapabilities;
    this.videoCapabilities = videoCapabilities;
    this.distinctiveIdentifier = distinctiveIdentifier;
    this.persistentState = persistentState;
    this.sessionTypes = sessionTypes;
};

MediaPlayer.vo.protection.KeySystemConfiguration.prototype = {
    constructor: MediaPlayer.vo.protection.KeySystemConfiguration
};
/**
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Dash Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  * Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  * Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * Event indicating the receipt of a response from a license server
 *
 * @param message {Uint8Array} license response message
 * @param requestData a request-specific data object
 * @constructor
 */
MediaPlayer.vo.protection.LicenseRequestComplete = function(message, requestData) {
    "use strict";
    this.message = message;
    this.requestData = requestData;
};

MediaPlayer.vo.protection.LicenseRequestComplete.prototype = {
    constructor: MediaPlayer.vo.protection.LicenseRequestComplete
};


/**
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Dash Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  * Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  * Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */
/**
 * A media capability
 *
 * @param {string} contentType MIME type and codecs (RFC6386)
 * @param {string} [robustness]
 * @constructor
 */
MediaPlayer.vo.protection.MediaCapability = function(contentType, robustness) {
    this.contentType = contentType;
    this.robustness = robustness;
};

MediaPlayer.vo.protection.MediaCapability.prototype = {
    constructor: MediaPlayer.vo.protection.MediaCapability
};

/**
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Dash Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  * Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  * Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */
/**
 * EME-independent NeedKey
 *
 * @param initData the initialization data
 * @param [initDataType] initialization data type
 * @constructor
 */
MediaPlayer.vo.protection.NeedKey = function(initData, initDataType) {
    this.initData = initData;
    this.initDataType = initDataType;
};

MediaPlayer.vo.protection.NeedKey.prototype = {
    constructor: MediaPlayer.vo.protection.NeedKey
};


/**
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Dash Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  * Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  * Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * Data used to customize KeySystems and override default or CDM-provided
 * values
 *
 * @param {string} laURL a license acquisition URL to use with this key system
 * @param {Object} httpRequestHeaders headers to add to the http request
 * @param {Object} bearerToken
 * @param {Object} clearkeys defines a set of clear keys that are available to
 * the key system.  Object properties are base64-encoded keyIDs (with no padding).
 * Corresponding property values are keys, base64-encoded (no padding).
 * @constructor
 */
MediaPlayer.vo.protection.ProtectionData = function(laURL, httpRequestHeaders, bearerToken, clearkeys) {
    this.laURL = laURL;
    this.httpRequestHeaders = httpRequestHeaders;
    this.bearerToken = bearerToken;
    this.clearkeys = clearkeys;
};

MediaPlayer.vo.protection.ProtectionData.prototype = {
    constructor: MediaPlayer.vo.protection.ProtectionData
};
/**
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2013, Dash Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  * Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  * Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */
/**
 * All session tokens returns by ProtectionModel implementations
 * are guaranteed to contain initialization data and optionally
 * session IDs
 *
 * @constructor
 */
MediaPlayer.models.SessionToken = function () {
    "use strict";
};

MediaPlayer.models.SessionToken.prototype = {

    /**
     * The initialization data used to create this session
     *
     * {Uint8Array} initialization data
     */
    initData: null,

    /**
     * The unique session ID designated to this session
     *
     * @return {string} the session ID or the empty string if the implementation
     * does not support session IDs or the sessionID has not yet been established
     */
    getSessionID: function() { return ""; },

    /**
     * The time, in milliseconds since 01 January, 1970 UTC, after which
     * the key(s) in the session will no longer be usable to decrypt
     * media data, or NaN if no such time exists
     *
     * @returns {Number} the expiration time
     */
    getExpirationTime: function() { return NaN; },

    /**
     * Returns a read-only map of key IDs known to the session to the
     * current status of the associated key.
     *
     * @returns {maplike<BufferSource,MediaKeyStatus>}
     */
    getKeyStatuses: function() { return null; }
};




/**
 * This file contains an adaptation of the AES decryption algorithm
 * from the Standford Javascript Cryptography Library. That work is
 * covered by the following copyright and permissions notice:
 *
 * Copyright 2009-2010 Emily Stark, Mike Hamburg, Dan Boneh.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
 * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation
 * are those of the authors and should not be interpreted as representing
 * official policies, either expressed or implied, of the authors.
 */

Hls.dependencies.AES = function() {

    /**
    * Schedule out an AES key for both encryption and decryption. This
    * is a low-level class. Use a cipher mode to do bulk encryption.
    *
    * @constructor
    * @param key {Array} The key as an array of 4, 6 or 8 words.
    */
    this.init = function (key) {

        /**
         * The expanded S-box and inverse S-box tables. These will be computed
         * on the client so that we don't have to send them down the wire.
         *
         * There are two tables, _tables[0] is for encryption and
         * _tables[1] is for decryption.
         *
         * The first 4 sub-tables are the expanded S-box with MixColumns. The
         * last (_tables[01][4]) is the S-box itself.
         *
         * @private
         */
        this._tables = [[[],[],[],[],[]],[[],[],[],[],[]]];

        this._precompute.call(this);

        var i, j, tmp,
        encKey, decKey,
        sbox = this._tables[0][4], decTable = this._tables[1],
        keyLen = key.length, rcon = 1;

        if (keyLen !== 4 && keyLen !== 6 && keyLen !== 8) {
            throw new Error('Invalid aes key size=' + keyLen);
        }

        encKey = key.slice(0);
        decKey = [];
        this._key = [encKey, decKey];

        // schedule encryption keys
        for (i = keyLen; i < 4 * keyLen + 28; i++) {
            tmp = encKey[i-1];

            // apply sbox
            if (i%keyLen === 0 || (keyLen === 8 && i%keyLen === 4)) {
                tmp = sbox[tmp>>>24]<<24 ^ sbox[tmp>>16&255]<<16 ^ sbox[tmp>>8&255]<<8 ^ sbox[tmp&255];

                // shift rows and add rcon
                if (i%keyLen === 0) {
                    tmp = tmp<<8 ^ tmp>>>24 ^ rcon<<24;
                    rcon = rcon<<1 ^ (rcon>>7)*283;
                }
            }

            encKey[i] = encKey[i-keyLen] ^ tmp;
        }

        // schedule decryption keys
        for (j = 0; i; j++, i--) {
            tmp = encKey[j&3 ? i : i - 4];
            if (i<=4 || j<4) {
                decKey[j] = tmp;
            } else {
                decKey[j] = decTable[0][sbox[tmp>>>24]] ^
                decTable[1][sbox[tmp>>16  & 255]] ^
                decTable[2][sbox[tmp>>8   & 255]] ^
                decTable[3][sbox[tmp      & 255]];
            }
        }
    };

    /**
    * Expand the S-box tables.
    *
    * @private
    */
    this._precompute = function () {
        var encTable = this._tables[0], decTable = this._tables[1],
            sbox = encTable[4], sboxInv = decTable[4],
            i, x, xInv, d=[], th=[], x2, x4, x8, s, tEnc, tDec;

        // Compute double and third tables
        for (i = 0; i < 256; i++) {
            th[( d[i] = i<<1 ^ (i>>7)*283 )^i]=i;
        }

        for (x = xInv = 0; !sbox[x]; x ^= x2 || 1, xInv = th[xInv] || 1) {
            // Compute sbox
            s = xInv ^ xInv<<1 ^ xInv<<2 ^ xInv<<3 ^ xInv<<4;
            s = s>>8 ^ s&255 ^ 99;
            sbox[x] = s;
            sboxInv[s] = x;

            // Compute MixColumns
            x8 = d[x4 = d[x2 = d[x]]];
            tDec = x8*0x1010101 ^ x4*0x10001 ^ x2*0x101 ^ x*0x1010100;
            tEnc = d[s]*0x101 ^ s*0x1010100;

            for (i = 0; i < 4; i++) {
                encTable[i][x] = tEnc = tEnc<<24 ^ tEnc>>>8;
                decTable[i][s] = tDec = tDec<<24 ^ tDec>>>8;
            }
        }

        // Compactify. Considerable speedup on Firefox.
        for (i = 0; i < 5; i++) {
            encTable[i] = encTable[i].slice(0);
            decTable[i] = decTable[i].slice(0);
        }
    };

    /**
    * Decrypt 16 bytes, specified as four 32-bit words.
    * @param encrypted0 {number} the first word to decrypt
    * @param encrypted1 {number} the second word to decrypt
    * @param encrypted2 {number} the third word to decrypt
    * @param encrypted3 {number} the fourth word to decrypt
    * @param out {Int32Array} the array to write the decrypted words
    * into
    * @param offset {number} the offset into the output array to start
    * writing results
    * @return {Array} The plaintext.
    */
    this.decrypt = function (encrypted0, encrypted1, encrypted2, encrypted3, out, offset) {
        var key = this._key[1],
            // state variables a,b,c,d are loaded with pre-whitened data
            a = encrypted0 ^ key[0],
            b = encrypted3 ^ key[1],
            c = encrypted2 ^ key[2],
            d = encrypted1 ^ key[3],
            a2, b2, c2,

            nInnerRounds = key.length / 4 - 2, // key.length === 2 ?
            i,
            kIndex = 4,
            table = this._tables[1],

            // load up the tables
            table0    = table[0],
            table1    = table[1],
            table2    = table[2],
            table3    = table[3],
            sbox  = table[4];

        // Inner rounds. Cribbed from OpenSSL.
        for (i = 0; i < nInnerRounds; i++) {
            a2 = table0[a>>>24] ^ table1[b>>16 & 255] ^ table2[c>>8 & 255] ^ table3[d & 255] ^ key[kIndex];
            b2 = table0[b>>>24] ^ table1[c>>16 & 255] ^ table2[d>>8 & 255] ^ table3[a & 255] ^ key[kIndex + 1];
            c2 = table0[c>>>24] ^ table1[d>>16 & 255] ^ table2[a>>8 & 255] ^ table3[b & 255] ^ key[kIndex + 2];
            d  = table0[d>>>24] ^ table1[a>>16 & 255] ^ table2[b>>8 & 255] ^ table3[c & 255] ^ key[kIndex + 3];
            kIndex += 4;
            a=a2; b=b2; c=c2;
        }

        // Last round.
        for (i = 0; i < 4; i++) {
            out[(3 & -i) + offset] =
            sbox[a>>>24      ]<<24 ^
            sbox[b>>16  & 255]<<16 ^
            sbox[c>>8   & 255]<<8  ^
            sbox[d      & 255]     ^
            key[kIndex++];
            a2=a; a=b; b=c; c=d; d=a2;
        }
    };
};

Hls.dependencies.AES.prototype = {
    constructor: Hls.dependencies.AES
};

Hls.dependencies.AES128Decrypter = function(key, iv) {
    "use strict";

    this.key = key;
    this.iv = iv;

    /**
    * Convert network-order (big-endian) bytes into their little-endian
    * representation.
    */
    this.ntoh = function(word) {
        return (word << 24) |
               ((word & 0xff00) << 8) |
               ((word & 0xff0000) >> 8) |
               (word >>> 24);
    };

    /**
    * Decrypt bytes using AES-128 with CBC and PKCS#7 padding.
    * @param encrypted {Uint8Array} the encrypted bytes
    * @param key {Uint32Array} the bytes of the decryption key
    * @param initVector {Uint32Array} the initialization vector (IV) to
    * use for the first round of CBC.
    * @return {Uint8Array} the decrypted bytes
    *
    * @see http://en.wikipedia.org/wiki/Advanced_Encryption_Standard
    * @see http://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_Block_Chaining_.28CBC.29
    * @see https://tools.ietf.org/html/rfc2315
    */
    this.doDecrypt = function(encrypted, key, initVector) {
        var
            // word-level access to the encrypted bytes
            encrypted32 = new Int32Array(encrypted.buffer, encrypted.byteOffset, encrypted.byteLength >> 2),

            decipher = new Hls.dependencies.AES(),

            // byte and word-level access for the decrypted output
            decrypted = new Uint8Array(encrypted.byteLength),
            decrypted32 = new Int32Array(decrypted.buffer),

            // temporary variables for working with the IV, encrypted, and
            // decrypted data
            init0, init1, init2, init3,
            encrypted0, encrypted1, encrypted2, encrypted3,

            // iteration variable
            wordIx;

        decipher.init(Array.prototype.slice.call(key));

        // pull out the words of the IV to ensure we don't modify the
        // passed-in reference and easier access
        init0 = ~~initVector[0];
        init1 = ~~initVector[1];
        init2 = ~~initVector[2];
        init3 = ~~initVector[3];

        // decrypt four word sequences, applying cipher-block chaining (CBC)
        // to each decrypted block
        for (wordIx = 0; wordIx < encrypted32.length; wordIx += 4) {
            // convert big-endian (network order) words into little-endian
            // (javascript order)
            encrypted0 = ~~this.ntoh(encrypted32[wordIx]);
            encrypted1 = ~~this.ntoh(encrypted32[wordIx + 1]);
            encrypted2 = ~~this.ntoh(encrypted32[wordIx + 2]);
            encrypted3 = ~~this.ntoh(encrypted32[wordIx + 3]);

            // decrypt the block
            decipher.decrypt(encrypted0,
                encrypted1,
                encrypted2,
                encrypted3,
                decrypted32,
                wordIx);

            // XOR with the IV, and restore network byte-order to obtain the
            // plaintext
            decrypted32[wordIx]     = this.ntoh(decrypted32[wordIx] ^ init0);
            decrypted32[wordIx + 1] = this.ntoh(decrypted32[wordIx + 1] ^ init1);
            decrypted32[wordIx + 2] = this.ntoh(decrypted32[wordIx + 2] ^ init2);
            decrypted32[wordIx + 3] = this.ntoh(decrypted32[wordIx + 3] ^ init3);

            // setup the IV for the next round
            init0 = encrypted0;
            init1 = encrypted1;
            init2 = encrypted2;
            init3 = encrypted3;
        }

        return decrypted;
    };

    this.localDecrypt = function(encrypted, key, initVector, decrypted) {
        var bytes = this.doDecrypt(encrypted,
            key,
            initVector);
            decrypted.set(bytes, encrypted.byteOffset);
    };

    this.decrypt = function(encrypted) {
        var step = 4 * 8000,
            //encrypted32 = new Int32Array(encrypted.buffer),
            encrypted32 = new Int32Array(encrypted),
            decrypted = new Uint8Array(encrypted.byteLength),
            i = 0;

        // split up the encryption job and do the individual chunks asynchronously
        var key = this.key;
        var initVector = this.iv;
        this.localDecrypt(encrypted32.subarray(i, i + step), key, initVector, decrypted);

        for (i = step; i < encrypted32.length; i += step) {
            initVector = new Uint32Array([
                this.ntoh(encrypted32[i - 4]),
                this.ntoh(encrypted32[i - 3]),
                this.ntoh(encrypted32[i - 2]),
                this.ntoh(encrypted32[i - 1])
            ]);
            this.localDecrypt(encrypted32.subarray(i, i + step), key, initVector, decrypted);
        }

        return decrypted;
    };
};

Hls.dependencies.AES128Decrypter.prototype = {
    constructor: Hls.dependencies.AES128Decrypter
};
/*
 * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.
 * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2014, Orange
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
Hls.dependencies.HlsDemux = function() {
    "use strict";

    var _appendArray = function(array1, array2) {
        var tmp = new Uint8Array(array1.byteLength + array2.byteLength);
        tmp.set(array1, 0);
        tmp.set(array2, array1.byteLength);
        return tmp;
    };

    // List of considered H.264 NALU types
    var H264_NALU_TYPES = [1, 5, 6];

    var trackIdCounter = 1,
        pidToTrack = [],
        tracks = [],
        baseDts = -1,
        dtsOffset = -1,

        getTsPacket = function(data, offset, pid, pusi) {
            var i = offset,
                tsPacket;

            while (i < data.length) {
                tsPacket = new mpegts.ts.TsPacket();
                tsPacket.parse(data.subarray(i, i + mpegts.ts.TsPacket.prototype.TS_PACKET_SIZE));

                //this.debug.log("[HlsDemux] TS packet: pid=" + tsPacket.getPid() + ", pusi = " + tsPacket.getPusi());

                if ((tsPacket.getPid() === pid) && ((pusi === undefined) || (tsPacket.getPusi() === pusi))) {
                    return {
                        offset: i,
                        packet: tsPacket
                    };
                }

                i += mpegts.ts.TsPacket.prototype.TS_PACKET_SIZE;
            }

            return null;
        },

        checkTsPacket = function(data) {
            var tsPacket = new mpegts.ts.TsPacket();
            return tsPacket.checkSyncWord(data.subarray(0, mpegts.ts.TsPacket.prototype.TS_PACKET_SIZE));
        },

        getPAT = function(data) {
            var tsPacket = getTsPacket.call(this, data, 0, mpegts.ts.TsPacket.prototype.PAT_PID);

            if (tsPacket === null) {
                return null;
            }

            var pat = new mpegts.si.PAT();
            pat.parse(tsPacket.packet.getPayload());

            return pat;
        },

        getPMT = function(data, pid) {
            var tsPacket = getTsPacket.call(this, data, 0, pid);

            if (tsPacket === null) {
                return null;
            }

            var pmt = new mpegts.si.PMT();
            pmt.parse(tsPacket.packet.getPayload());

            return pmt;
        },

        demuxTsPacket = function(data) {
            var tsPacket,
                pid,
                track,
                sample = null,
                sampleData = null,
                pesPacket;

            tsPacket = new mpegts.ts.TsPacket();
            tsPacket.parse(data);

            // If packet has only adaptation field, then ignore
            if (tsPacket.hasAdaptationFieldOnly()) {
                return;
            }

            // Get PID and corresponding track
            pid = tsPacket.getPid();
            track = pidToTrack[pid];
            if (!track) {
                return;
            }

            // PUSI => start storing new AU
            if (tsPacket.getPusi()) {

                // Parse PES header
                pesPacket = new mpegts.pes.PesPacket();
                pesPacket.parse(tsPacket.getPayload());

                // Store new access unit
                sample = new MediaPlayer.vo.Mp4Track.Sample();
                sample.cts = pesPacket.getPts().getValue();
                sample.dts = (pesPacket.getDts() !== null) ? pesPacket.getDts().getValue() : sample.cts;
                sample.size = 0;
                sample.duration = 0;
                sample.subSamples = [];

                if (baseDts === -1) {
                    baseDts = sample.dts;
                }

                // Store original MPEG2TS timestamp to help determining offset between absolute samples timestamps and MPEG2TS timestamps (see WebVTT parser)
                sample.mpegTimestamp = sample.cts;

                sample.dts -= baseDts;
                sample.cts -= baseDts;

                sample.dts += dtsOffset;
                sample.cts += dtsOffset;

                //this.debug.log("[HlsDemux][" + track.type + "] dts = " + sample.dts + ", cts = " + sample.cts);

                // Store payload of PES packet as a subsample
                sampleData = pesPacket.getPayload();

                // Set sample flags
                if (track.type === "audio") {
                    sample.flags = 0x01000000; // sample_depends_on = 1, other flags = 0
                }
                if (track.type === "video" && (track.streamType.search('H.264') !== -1)) {
                    // In case of H.264 stream, check if the sample is an IDR sample
                    // If IDR: sample_depends_on = 2, sample_is_non_sync_sample = false
                    // If non-IDR: sample_depends_on = 1, sample_is_non_sync_sample = true
                    sample.flags = mpegts.h264.isIDR(sampleData) ? 0x02000000 : 0x01010000;
                }

                sample.subSamples.push(sampleData);

                if (sample.dts >= 0) {
                     track.samples.push(sample);
                } else {
                    // Check A/V desynchronisation
                    var offset = Math.abs(sample.dts) / 90000;
                    if (offset > 10) {
                        throw {
                            name: MediaPlayer.dependencies.ErrorHandler.prototype.HLS_DEMUX_ERROR,
                            message: "A/V desynchronization (" + Math.round(offset) + " s.)"
                        };
                    }
                }
            } else if (track.samples.length > 0) {
                // Get currently buffered access unit
                sample = track.samples[track.samples.length - 1];

                // Store payload of TS packet as a subsample
                sample.subSamples.push(tsPacket.getPayload());
            }
        },

        postProcess = function(track) {
            var sample,
                length = 0,
                offset = 0,
                subSamplesLength,
                i, s;

            if (track.samples.length === 0) {
                return;
            }

            // Determine total length of track samples data
            // Set samples duration and size
            for (i = 0; i < track.samples.length; i++) {
                subSamplesLength = 0;
                sample = track.samples[i];

                for (s = 0; s < sample.subSamples.length; s++) {
                    subSamplesLength += sample.subSamples[s].length;
                }

                if (i > 0) {
                    track.samples[i - 1].duration = track.samples[i].dts - track.samples[i - 1].dts;
                }

                sample.size = subSamplesLength;
                length += subSamplesLength;
            }
            track.samples[track.samples.length - 1].duration = track.samples[track.samples.length - 2].duration;

            // Allocate track data
            track.data = new Uint8Array(length);

            track.dataCTS = [];

            for (i = 0; i < track.samples.length; i++) {
                sample = track.samples[i];

                // In case of ADTS, for each input sample (i.e. PES packet), we store the CTS (=PTS)
                // in order to set the correct timestamp to each AAC frames after ADTS demultiplexing (see demuxADTS()),
                // and then get around missing frames in input stream
                if (track.streamType.search('ADTS') !== -1) {
                    track.dataCTS[offset] = sample.cts;
                }

                // Copy all sub-sample parts into track data
                for (s = 0; s < sample.subSamples.length; s++) {
                    track.data.set(sample.subSamples[s], offset);
                    offset += sample.subSamples[s].length;
                }
            }

            // In case of H.264 stream, convert bytestream to MP4 format (NALU size field instead of start codes)
            if (track.streamType.search('H.264') !== -1) {
                convertH264Frames.call(this, track);
            }

            // In case of AAC-ADTS stream, demultiplex ADTS frames into AAC frames
            // (Demultiplexing is performed on the whole segment data in case ADTS packets are not aligned
            // on PES packets)
            if (track.streamType.search('ADTS') !== -1) {
                demuxADTS.call(this, track);
            }

            // Patch first frame timestamp and duration in case of missing frames at the end of the previous segment
            if (track.previousCts && track.previousDuration) {
                sample = track.samples[0];
                var gap = sample.cts - (track.previousCts + track.previousDuration);
                if (gap > 0 && gap < track.timescale) {
                    sample.cts -= gap;
                    sample.dts -= gap;
                    sample.duration += gap;
                    this.debug.log("[HlsDemux][" + track.type + "] Patch sample duration, cts = " + (sample.cts / 90000).toFixed(3) + ", duration = " + (sample.duration / 90000).toFixed(3));
                }
            }

        },

        convertH264Frames = function(track) {
            var sample,
                nalu,
                totalLength,
                data,
                offset,
                i, n;

            // Parse all NALUs and determine total data length according to filtered NALUs
            totalLength = 0;
            offset = 0;
            for (i = 0; i < track.samples.length; i++) {
                sample = track.samples[i];
                sample.nalus = mpegts.h264.parseNALUs(track.data.subarray(offset, offset + sample.size));
                for (n = 0; n < sample.nalus.length; n++) {
                    nalu = sample.nalus[n];
                    // this.debug.log("[HlsDemux][" + track.type + "] H264 NALU, type = " + nalu.type + ", size = " + nalu.size + " - write: " + (H264_NALU_TYPES.indexOf(nalu.type) !== -1));
                    if (H264_NALU_TYPES.indexOf(nalu.type) !== -1) {
                        // Set NALU offset relative to whole data array
                        nalu.offset += offset;
                        totalLength += 4 + sample.nalus[n].size; // 4 = NALUSize field length
                    } else {
                        // Remove NALU
                        sample.nalus.splice(n, 1);
                        n--;
                    }
                }
                offset += sample.size;
            }

            // Allocate new data
            data = new Uint8Array(totalLength);

            // Copy all NALUs from each sample (AU) into output data
            offset = 0;
            for (i = 0; i < track.samples.length; i++) {
                sample = track.samples[i];
                sample.size = 0;
                for (n = 0; n < sample.nalus.length; n++) {
                    nalu = sample.nalus[n];
                    data[offset++] = (nalu.size & 0xFF000000) >> 24;
                    data[offset++] = (nalu.size & 0x00FF0000) >> 16;
                    data[offset++] = (nalu.size & 0x0000FF00) >> 8;
                    data[offset++] = (nalu.size & 0x000000FF);
                    data.set(track.data.subarray(nalu.offset, nalu.offset + nalu.size), offset);
                    offset += nalu.size;
                    sample.size += 4 + nalu.size;
                }
            }

            // Replace track data with converted H.264 frames
            track.data = data;
        },

        demuxADTS = function(track) {
            var aacFrames,
                aacSamples = [],
                length,
                offset,
                data,
                sample,
                cts,
                duration,
                i;

            // Parse AAC-ADTS access units and get AAC frames description
            aacFrames = mpegts.aac.parseADTS(track.data, track.dataCTS);

            // And determine total length of AAC frames
            length = 0;
            for (i = 0; i < aacFrames.length; i++) {
                length += aacFrames[i].length;
            }

            // Allocate new data section that will contains all AAC frames
            data = new Uint8Array(length);

            // Store first sample info
            cts = track.samples[0].cts;

            // Determine sample duration
            duration = track.timescale * 1024.0 / track.samplingRate;

            // Copy AAC frames data and create AAC samples
            offset = 0;
            for (i = 0; i < aacFrames.length; i++) {
                // Create sample
                sample = new MediaPlayer.vo.Mp4Track.Sample();

                // Set CTS according to ADTS frame CTS (=PES CTS) or according to sample duration
                sample.cts = sample.dts = (aacFrames[i].cts ? aacFrames[i].cts : cts);
                sample.size = aacFrames[i].length;
                sample.duration = duration;
                sample.flags = 0x01000000; // sample_depends_on = 1, other flags = 0

                // Store original MPEG2TS timestamp to help determining offset between absolute samples timestamps and MPEG2TS timestamps (see WebVTT parser)
                if (aacSamples.length === 0) {
                    sample.mpegTimestamp = track.samples[0].mpegTimestamp;
                }

                aacSamples.push(sample);

                // Update cts for next frame
                cts = sample.cts + duration;

                // Update previous sample duration in case of missing frames
                if (i > 0) {
                    aacSamples[i - 1].duration = aacSamples[i].cts - aacSamples[i - 1].cts;
                    if (aacSamples[i - 1].duration > duration) {
                        this.debug.log("[HlsDemux][" + track.type + "] Patch sample duration, cts = " + (aacSamples[i - 1].cts / 90000).toFixed(3) + ", duration = " + (aacSamples[i - 1].duration / 90000).toFixed(3));
                    }
                }

                // Copy AAC frame data
                data.set(track.data.subarray(aacFrames[i].offset, aacFrames[i].offset + aacFrames[i].length), offset);
                offset += aacFrames[i].length;
            }

            // Replace track data
            track.data = data;

            // Replace track's AAC-ADTS samples by demultiplexed AAC samples
            track.samples = aacSamples;
        },

        arrayToHexString = function(array) {
            var str = "",
                i = 0,
                h = 0;

            for (i = 0; i < array.length; i++) {
                h = array[i].toString(16);
                if (h.length < 2) {
                    h = "0" + h;
                }
                str += h;
            }
            return str;
        },

        doReset = function() {
            this.debug.log("[HlsDemux] Reset");
            // pat = null;
            // pmt = null;
            trackIdCounter = 1;
            pidToTrack = [];
            tracks = [];
            baseDts = -1;
            dtsOffset = -1;
        },


        getTrackCodecInfo = function(data, track) {
            var tsPacket,
                pesPacket,
                esBytes,
                sequenceHeader,
                nalHeader,
                codecPrivateData,
                objectType,
                samplingFrequencyIndex;

            // Get first TS packet containing start of a PES/sample
            tsPacket = getTsPacket.call(this, data, 0, track.pid, true);

            // We have no packet of track's PID , need some more packets to get track info
            if (tsPacket === null) {
                // We throw an error since the <video> element will raise a MEDIA_ERR_SRC_NOT_SUPPORTED error
                // when pushing the initialization segment
                throw {
                    name: MediaPlayer.dependencies.ErrorHandler.prototype.HLS_DEMUX_ERROR,
                    message: "No packets for track " + track.type
                };
            }

            // Get PES packet
            pesPacket = new mpegts.pes.PesPacket();
            pesPacket.parse(tsPacket.packet.getPayload());
            esBytes = pesPacket.getPayload();

            // H264
            if (track.streamType.search('H.264') !== -1) {
                sequenceHeader = mpegts.h264.getSequenceHeader(esBytes);

                while (sequenceHeader === null) {
                    tsPacket = getTsPacket.call(this, data, (tsPacket.offset + mpegts.ts.TsPacket.prototype.TS_PACKET_SIZE), track.pid, false);
                    esBytes = _appendArray(esBytes, tsPacket.packet.getPayload());
                    sequenceHeader = mpegts.h264.getSequenceHeader(esBytes);
                }

                track.codecPrivateData = arrayToHexString(sequenceHeader.bytes);
                track.codecs = "avc1.";

                // Extract from the CodecPrivateData field the hexadecimal representation of the following
                // three bytes in the sequence parameter set NAL unit.
                // => Find the SPS nal header
                nalHeader = /00000001[0-9]7/.exec(track.codecPrivateData);
                if (nalHeader && nalHeader[0]) {
                    // => Take the 6 characters after the SPS nalHeader (if it exists)
                    track.codecs += track.codecPrivateData.substr(track.codecPrivateData.indexOf(nalHeader[0]) + 10, 6);
                }

                // Extract width and height from SPS
                track.width = sequenceHeader.width;
                track.height = sequenceHeader.height;
                this.debug.log("[HlsDemux] width  = " + track.width);
                this.debug.log("[HlsDemux] height = " + track.height);
            }

            // AAC
            if (track.streamType.search('AAC') !== -1) {
                codecPrivateData = mpegts.aac.getAudioSpecificConfig(esBytes);
                objectType = (codecPrivateData[0] & 0xF8) >> 3;
                track.codecPrivateData = arrayToHexString(codecPrivateData);
                track.codecs = "mp4a.40." + objectType;

                samplingFrequencyIndex = (codecPrivateData[0] & 0x07) << 1 | (codecPrivateData[1] & 0x80) >> 7;
                track.samplingRate = mpegts.aac.SAMPLING_FREQUENCY[samplingFrequencyIndex];
                track.channels = (codecPrivateData[1] & 0x78) >> 3;
                track.bandwidth = 0;
                /* code for HE AAC v2 to be tested
                var arr16 = new Uint16Array(2);
                arr16[0] = (codecPrivateData[0] << 8) + codecPrivateData[1];
                arr16[1] = (codecPrivateData[2] << 8) + codecPrivateData[3];
                //convert decimal to hex value
                var codecPrivateDataHex = arr16[0].toString(16)+arr16[1].toString(16);
                track.codecPrivateData = codecPrivateDataHex.toUpperCase();*/
            }

            this.debug.log("[HlsDemux] codecs = " + track.codecs);
            this.debug.log("[HlsDemux] codecPrivateData = " + track.codecPrivateData);
        },

        doGetTracks = function(data) {
            var i = 0,
                pat,
                pmt,
                es,
                pid,
                track,
                streamTypeDesc;

            // First, check that packet is really a TS packet
            if( !checkTsPacket.call(this,data) ) {
                throw {
                    name: MediaPlayer.dependencies.ErrorHandler.prototype.HLS_INVALID_PACKET_ERROR,
                    message: "Failed to demux, packet is invalid, missing SYNC byte"
                };
            }

            // Get PSI (PAT, PMT)
            pat = getPAT.call(this, data);
            if (pat === null) {
                throw {
                    name: MediaPlayer.dependencies.ErrorHandler.prototype.HLS_DEMUX_ERROR,
                    message: "Failed to demux, missing signalization (PAT)"
                };
            }

            pmt = getPMT.call(this, data, pat.getPmtPid());
            if (pmt === null) {
                throw {
                    name: MediaPlayer.dependencies.ErrorHandler.prototype.HLS_DEMUX_ERROR,
                    message: "Failed to demux, missing signalization (PMT)"
                };
            }

            // Create a track for each elementary stream
            for (i = 0; i < pmt.m_listOfComponents.length; i++) {
                es = pmt.m_listOfComponents[i];
                pid = es.m_elementary_PID;

                track = pidToTrack[pid];

                if (!track) {
                    // Create new track
                    track = new MediaPlayer.vo.Mp4Track();
                    track.timescale = mpegts.Pts.prototype.SYSTEM_CLOCK_FREQUENCY;
                    track.pid = pid;

                    // Get elemantary stream type
                    streamTypeDesc = pmt.gStreamTypes[es.m_stream_type];
                    if (streamTypeDesc === null) {
                        this.debug.log("[HlsDemux] Stream Type " + es.m_stream_type + " unknown!");
                        continue;
                    }

                    // Determine track type
                    track.streamType = streamTypeDesc.name;
                    switch (streamTypeDesc.value) {
                        case 0xE0:
                            track.type = "video";
                            break;
                        case 0xC0:
                            track.type = "audio";
                            break;
                        case 0xFC:
                            track.type = "data";
                            break;
                        default:
                            track.type = "und";
                    }
                }

                // Get/update track codec details
                getTrackCodecInfo.call(this, data, track);
                if (track.codecs === "") {
                    throw {
                        name: MediaPlayer.dependencies.ErrorHandler.prototype.HLS_DEMUX_ERROR,
                        message: "Failed to get codec information for track " + track.type
                    };
                }

                if (!pidToTrack[pid]) {
                    // Set trackId
                    track.trackId = trackIdCounter;
                    trackIdCounter++;
                    this.debug.log("[HlsDemux] Add track: type = " + track.type + ", PID = " + track.pid + ", trackId = " + track.trackId);
                    tracks.push(track);
                    pidToTrack[pid] = track;
                }
            }

            return tracks;
        },

        doDemux = function(data, request) {
            var track,
                i = 0,
                firstDts = -1,
                offset;

            if (dtsOffset === -1) {
                dtsOffset = request.startTime * 90000;
                this.debug.log("[HlsDemux] Media start time = " + dtsOffset + " (" + request.startTime + ")");
            }

            this.debug.log("[HlsDemux] Demux chunk, size = " + data.length + ", nb packets = " + Math.round(data.length / mpegts.ts.TsPacket.prototype.TS_PACKET_SIZE));

            // Get PAT, PMT and tracks information if not yet received
            doGetTracks.call(this, data);

            // Clear current tracks' data
            for (i = 0; i < tracks.length; i++) {
                track = tracks[i];

                // Store last sample timestamp and duration (in case of lost/missing samples)
                if (track.samples.length > 0) {
                    track.previousCts = track.samples[track.samples.length - 1].cts;
                    track.previousDuration = track.samples[track.samples.length - 1].duration;
                }

                tracks[i].samples = [];
                tracks[i].data = null;
            }

            // Parse and demux TS packets
            i = 0;
            while (i < data.length) {
                if ((i + mpegts.ts.TsPacket.prototype.TS_PACKET_SIZE) > data.length) {
                    this.debug.log("[HlsDemux] Demux chunk, residual bytes = " + (data.length - i));
                    break;
                }
                demuxTsPacket.call(this, data.subarray(i, i + mpegts.ts.TsPacket.prototype.TS_PACKET_SIZE));
                i += mpegts.ts.TsPacket.prototype.TS_PACKET_SIZE;
            }

            // Re-assemble samples from sub-samples
            //this.debug.log("[HlsDemux] Demux: baseDts = " + baseDts + ", dtsOffset = " + dtsOffset);
            for (i = 0; i < tracks.length; i++) {
                track = tracks[i];

                if (track.samples.length === 0) {
                    continue;
                }

                postProcess.call(this, track);

                this.debug.log("[HlsDemux][" + track.type + "] Demux: 1st PTS = " + track.samples[0].dts + " (" + (track.samples[0].dts / 90000) + ")");

                // Check tracks desynchronization (if > 10 sec)
                firstDts = Math.max(firstDts, track.samples[0].dts);
                offset = Math.abs(track.samples[0].dts - firstDts) / 90000;
                if (offset > 10) {
                    throw {
                        name: MediaPlayer.dependencies.ErrorHandler.prototype.HLS_DEMUX_ERROR,
                        message: "A/V desynchronization (" + Math.round(offset) + " s.)"
                    };
                }
            }

            var _tracks = [];
            for (i = 0; i < tracks.length; i++) {
                if (tracks[i].samples.length > 0) {
                    _tracks.push(tracks[i]);
                }
            }

            return _tracks;
        };

    return {
        debug: undefined,

        reset: doReset,
        getTracks: doGetTracks,
        demux: doDemux
    };
};

Hls.dependencies.HlsDemux.prototype = {
    constructor: Hls.dependencies.HlsDemux
};

/*
 * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.
 * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2014, Orange
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
Hls.dependencies.HlsFragmentController = function () {
    "use strict";

    var decryptionInfos = {},

        generateMediaSegment = function (data, request) {
            var i = 0,
                // Demultiplex HLS chunk to get samples
                tracks = rslt.hlsDemux.demux(new Uint8Array(data), request);

            // Update fragment start time (=tfdt)
            for (i = 0; i < tracks.length; i += 1) {

                if (!rslt.manifestModel.getValue().timestampMap && tracks[i].samples[0].mpegTimestamp) {
                    rslt.manifestModel.getValue().timestampMap = {
                        local: tracks[i].samples[0].cts / 90000.0,
                        mpegts: tracks[i].samples[0].mpegTimestamp
                    };
                }
            }

            // Generate init (moov) and media segment (moof)
            return rslt.mp4Processor.generateInitMediaSegment(tracks);
        },

        createInitializationVector = function (segmentNumber) {
            var uint8View = new Uint8Array(16),
                i = 0;

            for (i = 12; i < 16; i++) {
                uint8View[i] = (segmentNumber >> 8 * (15 - i)) & 0xff;
            }

            return uint8View;
        },

        decrypt = function (data, decryptionInfo) {

            var t = new Date();

            var view = new DataView(decryptionInfo.key.buffer);
            var key = new Uint32Array([
                view.getUint32(0),
                view.getUint32(4),
                view.getUint32(8),
                view.getUint32(12)
            ]);

            view = new DataView(createInitializationVector(decryptionInfo.iv).buffer);
            var iv = new Uint32Array([
                view.getUint32(0),
                view.getUint32(4),
                view.getUint32(8),
                view.getUint32(12)
            ]);

            var decrypter = new Hls.dependencies.AES128Decrypter(key, iv);
            rslt.debug.log("[HlsFragmentController] decrypted chunk (" + (((new Date()).getTime() - t.getTime()) / 1000).toFixed(3) + "s.)");

            return decrypter.decrypt(data);
        },

        loadDecryptionKey = function (decryptionInfo) {
            var deferred = Q.defer();

            this.debug.log("[HlsFragmentController]", "Load decryption key: " + decryptionInfo.uri);
            var xhr = new MediaPlayer.dependencies.XHRLoader();
            // Do not retry for encrypted key, we assume the key file has to be present if playlist if present
            xhr.initialize('arraybuffer', 0, 0);
            xhr.load(decryptionInfo.uri).then(
                function (request) {
                    decryptionInfo.key = new Uint8Array(request.response);
                    deferred.resolve();
                },
                function (request) {
                    if (!request || request.aborted) {
                        deferred.reject();
                    } else {
                        deferred.reject({
                            name: MediaPlayer.dependencies.ErrorHandler.prototype.DOWNLOAD_ERR_MANIFEST,
                            message: "Failed to download HLS decryption key",
                            data: {
                                url: decryptionInfo.uri,
                                status: request.status
                            }
                        });
                    }
                }
            );

            return deferred.promise;
        },

        decryptSegment = function (bytes, request) {
            var deferred = Q.defer(),
                decryptionInfo,
                self = this;

            if (!request.decryptionInfo || request.decryptionInfo.method === "NONE") {
                deferred.resolve(bytes);
                return deferred.promise;
            }

            // check if decryption key has not been already downloaded
            // if (!manifest.decryptionInfos) {
            //     manifest.decryptionInfos = {};
            // }
            decryptionInfo = decryptionInfos[request.decryptionInfo.uri];
            if (decryptionInfo) {
                deferred.resolve(decrypt.call(this, bytes, decryptionInfo));
            } else {
                decryptionInfo = request.decryptionInfo;
                loadDecryptionKey.call(this, decryptionInfo).then(
                    function () {

                        // check key
                        if (decryptionInfo.key && decryptionInfo.key.byteLength !== 16) {
                            return deferred.reject({
                                name: MediaPlayer.dependencies.ErrorHandler.prototype.HLS_INVALID_KEY_ERROR,
                                message: "Invalid HLS key - Key length (" + decryptionInfo.key.byteLength + ") does not respect specification"
                            });
                        }
                        decryptionInfos[decryptionInfo.uri] = decryptionInfo;
                        deferred.resolve(decrypt.call(self, bytes, decryptionInfo));
                    },
                    function (e) {
                        deferred.reject(e);
                    }
                );
            }

            return deferred.promise;
        };

    var rslt = MediaPlayer.utils.copyMethods(MediaPlayer.dependencies.FragmentController);

    rslt.manifestModel = undefined;
    rslt.hlsDemux = undefined;
    rslt.mp4Processor = undefined;

    rslt.process = function (bytes, request /*, representation*/ ) {
        var deferred = Q.defer(),
            result = null;

        if ((bytes === null) || (bytes === undefined) || (bytes.byteLength === 0)) {
            deferred.resolve(null);
            return deferred.promise;
        }

        if (!request || (request.type !== "Media Segment")) {
            deferred.resolve(null);
            return deferred.promise;
        }

        // If text track (WebVTT), then do not process segment
        if (request.streamType === 'text') {
            deferred.resolve(bytes);
            return deferred.promise;
        }

        // Decrypt the segment if encrypted
        decryptSegment.call(rslt, bytes, request).then(function (data) {
            //console.saveBinArray(data, request.url.substring(request.url.lastIndexOf('/') + 1));
            try {
                // First check stream has not been reset while decrypting the chunk
                if (!rslt.manifestModel.getValue()) {
                    deferred.resolve(null);
                } else {
                    // Generate media segment (moof) from demultiplexed MPEG2-TS chunk
                    result = generateMediaSegment(data, request);
                    rslt.sequenceNumber++;
                    deferred.resolve(result);
                }
            } catch (e) {
                deferred.reject(e);
            }
        }, function (e) {
            deferred.reject(e);
        });

        //return result;
        return deferred.promise;
    };

    return rslt;
};

Hls.dependencies.HlsFragmentController.prototype = {
    constructor: Hls.dependencies.HlsFragmentController
};

/*
 * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.
 * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2014, Orange
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
Hls.dependencies.HlsHandler = function() {
    "use strict";
    var getInit = function(representation) {
        var period = null,
            self = this,
            presentationStartTime = null,
            deferred = Q.defer(),
            manifest,
            isDynamic,
            request;

        //Mss.dependencies.MssHandler.prototype.getInitRequest.call(this,quality,data).then(onGetInitRequestSuccess);
        // get the period and startTime
        period = representation.adaptation.period;
        presentationStartTime = period.start;

        manifest = rslt.manifestModel.getValue();
        isDynamic = rslt.manifestExt.getIsDynamic(manifest);

        request = new MediaPlayer.vo.SegmentRequest();

        request.streamType = rslt.getType();
        request.type = "Initialization Segment";
        request.url = null;
        request.data = 1; //used to activate Loaded event in BufferControler
        request.range = representation.range;
        request.availabilityStartTime = self.timelineConverter.calcAvailabilityStartTimeFromPresentationTime(presentationStartTime, representation.adaptation.period.mpd, isDynamic);
        request.availabilityEndTime = self.timelineConverter.calcAvailabilityEndTimeFromPresentationTime(presentationStartTime + period.duration, period.mpd, isDynamic);

        request.quality = representation.index;
        deferred.resolve(request);
        return deferred.promise;
    };

    var rslt = MediaPlayer.utils.copyMethods(Dash.dependencies.DashHandler);

    rslt.getInitRequest = getInit;

    return rslt;
};

Hls.dependencies.HlsHandler.prototype = {
    constructor: Hls.dependencies.HlsHandler
};
/*
 * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.
 * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2014, Orange
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
Hls.dependencies.HlsParser = function() {
    var REGEXP_EXTXSTREAMINF = /#EXT-X-STREAM-INF:([^\n\r]*)[\r\n]+([^\r\n]+)/g,
        REGEXP_EXTXMEDIA = /#EXT-X-MEDIA:(.*)/g,
        REGEXP_EXTXMEDIASEQUENCE = '(?:#(EXT-X-MEDIA-SEQUENCE):*(\\d+))',
        REGEXP_EXTXTARGETDURATION = '(?:#(EXT-X-TARGETDURATION):*(\\d+))',
        REGEXP_EXTXPROGRAMDATETIME = '(?:#(EXT-X-PROGRAM-DATE-TIME):*(.+))',
        REGEXP_EXTXKEY = '(?:#(EXT-X-KEY):(.+))',
        REGEXP_EXTXINF = '(?:#(EXTINF):*(\\d+(?:\\.\\d+)?)(?:,(.*))?[\r\n]*(.*))',
        REGEXP_EXTXENDLIST = '(?:#(EXT-X-ENDLIST))',
        REGEXP_ATTRIBUTES = /\s*(.+?)\s*=((?:\".*?\")|.*?)(?:,|$)/g,
        REGEXP_PLAYLIST = new RegExp('(?:' +
                                     REGEXP_EXTXMEDIASEQUENCE + '|' +
                                     REGEXP_EXTXTARGETDURATION + '|' +
                                     REGEXP_EXTXPROGRAMDATETIME + '|' +
                                     REGEXP_EXTXKEY + '|' +
                                     REGEXP_EXTXINF + '|' +
                                     REGEXP_EXTXENDLIST +
                                     ')', 'g'),
        DEFAULT_RETRY_ATTEMPTS = 2,
        DEFAULT_RETRY_INTERVAL = 500,
        retryAttempts = DEFAULT_RETRY_ATTEMPTS,
        retryInterval = DEFAULT_RETRY_INTERVAL,
        xhrLoader,

        getTagAttributes = function (attributes) {
            var attrs = {},
                match, name, value;

            while ((match = REGEXP_ATTRIBUTES.exec(attributes)) !== null) {
                name = match[1];
                value = match[2].replace(/"/g, ''); // Remove '"' characters
                attrs[name] = value;
            }
            return attrs;
        },

        getAbsoluteURI = function(uri, baseUrl) {
            if ((uri.indexOf("http://") === 0) ||
                (uri.indexOf("https://") === 0)) {
                return uri;
            }

            return baseUrl + uri;
        },

        getVariantStreams = function(manifest) {
            var streams = [], stream,
                match, attrs,
                codecs, audioCodec, videoCodec,
                resolution, width, height,
                i;

            while ((match = REGEXP_EXTXSTREAMINF.exec(manifest)) !== null) {
                attrs = getTagAttributes(match[1]);

                codecs = attrs['CODECS'] || '';

                codecs = codecs.split(',');
                audioCodec = videoCodec = '';
                for (i = 0; i < codecs.length; i++) {
                    if (codecs[i].indexOf('avc1') !== -1) {
                        videoCodec = codecs[i];
                    } else {
                        audioCodec = codecs[i];
                    }
                }

                resolution = attrs['RESOLUTION'] || '0x0';
                resolution = resolution.split('x');
                width = parseInt(resolution[0], 10);
                height = parseInt(resolution[1], 10);

                stream = {
                    programId: attrs['PROGRAM-ID'] || '',
                    bandwidth: parseInt(attrs['BANDWIDTH'] || '0', 10),
                    audioCodec: audioCodec,
                    videoCodec: videoCodec,
                    width: width,
                    height: height,
                    audioId: attrs['AUDIO'] || '',
                    subtitlesId: attrs['SUBTITLES'] || '',
                    uri: match[2]
                };
                streams.push(stream);
            }
            return streams;
        },

        getMedias = function(manifest) {
            var medias = [],
                match, attrs, type, media;

            while ((match = REGEXP_EXTXMEDIA.exec(manifest)) !== null) {
                attrs = getTagAttributes(match[1]);
                // Ignore if type attribute is not set
                type = (attrs['TYPE'] || '').toLowerCase();
                if (type.length === 0) {
                    break;
                }
                media = {
                    type: type,
                    groupId: attrs['GROUP-ID'] || '',
                    name: type + (attrs['NAME'] ? ('_' + attrs['NAME']) : ''),
                    language: attrs['LANGUAGE'] || '',
                    autoSelect: attrs['AUTO-SELECT'] === 'YES' ? true : false,
                    default: attrs['SUTITLES'] === 'YES' ? true : false,
                    uri: attrs['URI'] || ''
                };
                medias.push(media);
            }
            return medias;
        },

        removeSegments = function(segments, sequenceNumber) {
            for (var i = 0; i < segments.length; i++) {
                if (segments[i].sequenceNumber < sequenceNumber) {
                    segments.shift();
                    i--;
                } else {
                    break;
                }
            }
        },

        parsePlaylist = function(manifest, representation, adaptation) {
            var segmentList,
                segments,
                segment,
                initialization,
                decryptionInfo = null,
                duration = 0,
                sequenceNumber = 0,
                programDateTime = null,
                i;

            // Check playlist header
            if (!manifest || (manifest && manifest.length < 0)) {
                return false;
            }

            // this.debug.log(manifest);

            if (manifest.indexOf('#EXTM3U') !== 0) {
                return false;
            }

            segmentList = representation['SegmentList'];
            if (!segmentList) {
                // Initialize SegmentList
                segmentList = {
                    name: 'SegmentList',
                    isRoot: false,
                    isArray: false,
                    // children: [],
                    duration: 0,
                    startNumber: 0,
                    timescale: 1,
                    BaseURL: representation.BaseURL,
                    SegmentURL_asArray: []
                };
                representation['SegmentList'] = segmentList;
            }

            segments = segmentList.SegmentURL_asArray;

            // Set representation duration, by default set to  (="dynamic")
            representation.duration = Infinity;

            var match, tag, attrs;

            while ((match = REGEXP_PLAYLIST.exec(manifest)) !== null) {
                match = match.filter(function(n) { return (n !== undefined); });
                tag = match[1];

                switch (tag) {
                    case 'EXT-X-MEDIA-SEQUENCE':
                        sequenceNumber = parseInt(match[2]);
                        segmentList.startNumber = sequenceNumber;
                        break;
                    case 'EXT-X-TARGETDURATION':
                        segmentList.duration = parseInt(match[2]);
                        break;
                    case 'EXT-X-KEY':
                        attrs = getTagAttributes(match[2]);
                        decryptionInfo = {
                            method: attrs['METHOD'] || 'NONE',
                            uri: getAbsoluteURI(attrs['URI'], segmentList.BaseURL),
                            iv: attrs['IV']
                        };
                        break;
                    case 'EXTINF':
                        segment = {
                            name: "SegmentURL",
                            isRoot: false,
                            isArray: true,
                            media: getAbsoluteURI(match[4], segmentList.BaseURL),
                            sequenceNumber: sequenceNumber,
                            time: (segments.length === 0) ? 0 : segments[segments.length - 1].time + segments[segments.length - 1].duration,
                            duration: parseFloat(match[2]),
                            decryptionInfo: decryptionInfo
                        };

                        if (segment.decryptionInfo && !segment.decryptionInfo.iv) {
                            segment.decryptionInfo.iv = segment.sequenceNumber;
                        }

                        if (segments.length === 0 || segment.sequenceNumber > segments[segments.length-1].sequenceNumber) {
                            segments.push(segment);
                        }
                        sequenceNumber++;
                        duration += segment.duration;

                        if (programDateTime) {
                            segment.programDateTime = programDateTime;
                            programDateTime += (segment.duration * 1000);
                        }

                        break;
                    case 'EXT-X-ENDLIST':
                        representation.duration = duration;
                        break;
                    case 'EXT-X-PROGRAM-DATE-TIME':
                        programDateTime = Date.parse(match[2]);
                        break;
                    default:
                        break;
                }
            }

            // Remove segments from previous playlist
            removeSegments(segments, segmentList.startNumber);

            // Correct segments timeline according to previous segment list (in case of variant stream switching)
            if (adaptation.segments && adaptation.segments.length > 0) {
                // Align segment list according to sequence number
                removeSegments(segments, adaptation.segments[0].sequenceNumber);
                if (segments.length > 0) {
                    removeSegments(adaptation.segments, segments[0].sequenceNumber);
                    if (adaptation.segments.length > 0) {
                        if (segments[0].time !== adaptation.segments[0].time) {
                            segments[0].time = adaptation.segments[0].time;
                            for (i = 1; i < segments.length; i++) {
                                segments[i].time = segments[i - 1].time + segments[i - 1].duration;
                            }
                        }
                    }
                }
            }

            // segment list from manifest may be empty (or shifted/desynchronized from previous playlists)
            if (segments.length === 0) {
                return true;
            }

            adaptation.segments = segments;

            var range = {
                start: segments[0].time,
                end: segments[segments.length - 1].time + segments[segments.length - 1].duration
            };

            if (programDateTime) {
                range.programStart = segments[0].programDateTime;
                range.programEnd = segments[segments.length - 1].programDateTime + segments[segments.length - 1].duration;
            }

            if (adaptation.contentType === 'video') {
                this.metricsModel.addDVRInfo('video', new Date(), range);
            }

            // Set initialization segment info
            initialization = {
                name: "Initialization",
                sourceURL: representation.SegmentList.SegmentURL_asArray[0].media
            };
            representation.SegmentList.Initialization = initialization;

            // PATCH Live = VOD
            //representation.duration = duration;

            return true;
        },

        postProcess = function(manifest, quality) {
            var deferred = Q.defer(),
                period = manifest.Period_asArray[0],
                // Consider video AdaptationSet (always the 1st one)
                adaptationSet = period.AdaptationSet_asArray[0],
                // Consider representation of current and downloaded quality
                representation = adaptationSet.Representation_asArray[quality],
                request = new MediaPlayer.vo.SegmentRequest(),
                manifestDuration,
                mpdLoadedTime,
                maxSequenceNumber,
                i, j, k;

            period.start = 0; //segmentTimes[adaptationSet.Representation_asArray[0].SegmentList.startNumber];

            // Copy duration from first representation's duration
            adaptationSet.duration = representation.duration;
            period.duration = representation.duration;

            if (representation.duration !== Infinity) {
                manifest.mediaPresentationDuration = representation.duration;
            }

            // Set manifest type, "static" vs "dynamic"
            manifest.type = (representation.duration === Infinity) ? "dynamic" : "static";

            manifestDuration = representation.SegmentList.duration * representation.SegmentList.SegmentURL_asArray.length;

            // Dynamic use case
            if (manifest.type === "dynamic") {
                // Set availabilityStartTime property
                mpdLoadedTime = new Date();
                manifest.availabilityStartTime = new Date(mpdLoadedTime.getTime() - (manifestDuration * 1000));

                // Set timeshift buffer depth
                manifest.timeShiftBufferDepth = manifestDuration;
            }

            // Set minBufferTime
            manifest.minBufferTime = representation.SegmentList.duration * 3; //MediaPlayer.dependencies.BufferExtensions.DEFAULT_MIN_BUFFER_TIME

            // Align segment lists of all adaptations
            maxSequenceNumber = Math.max.apply(null, period.AdaptationSet_asArray.map(function(adaptation) {
                var repIndex = quality > adaptation.Representation_asArray.length ? 0 : quality;
                return adaptation.Representation_asArray[repIndex].SegmentList.startNumber;
            }));
            for (i = 0; i < period.AdaptationSet_asArray.length; i++) {
                var adaptation = period.AdaptationSet_asArray[i];
                for (j = 0; j < adaptation.Representation_asArray.length; j++) {
                    if (adaptation.Representation_asArray[j].SegmentList) {
                        var segments = adaptation.Representation_asArray[j].SegmentList.SegmentURL_asArray;
                        if (segments.length > 0 && segments[0].sequenceNumber < maxSequenceNumber) {
                            removeSegments(segments, maxSequenceNumber);
                            if (segments.length > 0) {
                                segments[0].time = 0;
                                for (k = 1; k < segments.length; k++) {
                                    segments[k].time = segments[k - 1].time + segments[k - 1].duration;
                                }
                            }
                        }
                    }
                }
            }

            // Download initialization data (PSI, IDR...) of 1st representation to obtain codec information
            representation = adaptationSet.Representation_asArray[quality];
            request.type = "Initialization Segment";
            request.url = representation.SegmentList.Initialization.sourceURL;

            var onLoaded = function(representation, response) {

                // Parse initialization data to obtain codec information
                var tracks = this.hlsDemux.getTracks(new Uint8Array(response.data)),
                    i = 0;

                representation.codecs = "";
                for (i = 0; i < tracks.length; i++) {
                    representation.codecs += tracks[i].codecs;
                    if (i < (tracks.length - 1)) {
                        representation.codecs += ",";
                    }
                }

                deferred.resolve();
            };

            var onError = function() {
                deferred.resolve();
            };

            if (representation.codecs === "") {
                this.debug.log("[HlsParser]", "Load initialization segment: " + request.url);
                this.fragmentLoader.load(request).then(onLoaded.bind(this, representation), onError.bind(this));
            } else {
                deferred.resolve();
            }

            return deferred.promise;
        },

        parseBaseUrl = function(url) {
            var base = null;

            if (url.indexOf("/") !== -1) {
                if (url.indexOf("?") !== -1) {
                    url = url.substring(0, url.indexOf("?"));
                }
                base = url.substring(0, url.lastIndexOf("/") + 1);
            }

            return base;
        },

        updatePlaylist = function(representation, adaptation) {
            var self = this,
                deferred = Q.defer();

            this.debug.log("[HlsParser]", "Load playlist manifest: " + representation.url);
            xhrLoader = new MediaPlayer.dependencies.XHRLoader();
            xhrLoader.initialize('text', retryAttempts, retryInterval);
            xhrLoader.load(representation.url).then(
                function (request) {
                    if (parsePlaylist.call(self, request.response, representation, adaptation)) {
                        deferred.resolve();
                    } else {
                        deferred.reject({
                            name: MediaPlayer.dependencies.ErrorHandler.prototype.MANIFEST_ERR_PARSE,
                            message: "Failed to parse variant stream playlist",
                            data: {
                                url: representation.url
                            }
                        });
                    }
                },
                function(request) {
                    if (!request || request.aborted) {
                        deferred.reject();
                    } else {
                        deferred.reject({
                            name: MediaPlayer.dependencies.ErrorHandler.prototype.DOWNLOAD_ERR_MANIFEST,
                            message: "Failed to download variant stream playlist",
                            data: {
                                url: representation.url,
                                status: request.status
                            }
                        });
                    }
                }
            );

            return deferred.promise;
        },

        processManifest = function(manifest, baseUrl) {
            var self = this,
                deferred = Q.defer(),
                mpd,
                period,
                adaptationsSets = [],
                adaptationSet,
                representations,
                representation,
                representationId = 0,
                streams = [],
                stream,
                medias = [],
                media,
                quality,
                playlistDefers = [],
                i = 0;

            if (manifest.indexOf('#EXTM3U') !== 0) {
                this.debug.error("[HlsParser] no stream in HLS manifest");
                deferred.reject();
                return deferred.promise;
            }

            // MPD
            mpd = {};
            mpd.name = "M3U";
            mpd.isRoot = true;
            mpd.isArray = true;
            mpd.parent = null;
            // mpd.children = [];
            mpd.BaseURL = baseUrl;

            mpd.profiles = "urn:mpeg:dash:profile:isoff-live:2011";
            mpd.type = "static"; // Updated in postProcess()

            // PERIOD
            period = {};
            period.name = "Period";
            period.isRoot = false;
            period.isArray = false;
            period.parent = mpd;
            period.duration = 0; // To be set at variant playlist parsing
            period.BaseURL = mpd.BaseURL;

            mpd.Period = period;
            mpd.Period_asArray = [period];

            // ADAPTATION SET
            adaptationsSets = [];
            period.AdaptationSet = adaptationsSets;
            period.AdaptationSet_asArray = adaptationsSets;

            // Get variant streams
            streams = getVariantStreams(manifest);

            if (streams.length === 0) {
                this.debug.error("[HlsParser] No stream in HLS manifest");
                deferred.reject();
                return deferred.promise;
            }

            // Sort streams by bandwidth
            streams.sort(function(a, b) {
                return a.bandwidth - b.bandwidth;
            });

            // Create AdaptationSet and a representation for each variant stream
            adaptationSet = {
                name: "AdaptationSet",
                isRoot: false,
                isArray: true,
                id: "video",
                lang: "",
                contentType: "video",
                mimeType: "video/mp4",
                maxWidth: 0,
                maxHeight: 0,
                BaseURL: period.BaseURL
            };

            representations = [];
            for (i = 0; i < streams.length; i++) {
                stream = streams[i];
                // Do not consider representation with bandwidth <= 64K which corresponds to audio only variant stream
                if (stream.bandwidth <= 64000) {
                    break;
                }
                representation = {
                    name: "Representation",
                    isRoot: false,
                    isArray: true,
                    id: representationId.toString(),
                    mimeType: "video/mp4",
                    // Consider audio codec only if no alternate track for audio
                    codecs: (stream.videoCodec.length > 0) ? (stream.audioId.length > 0 ? stream.videoCodec : (stream.videoCodec + ',' + stream.audioCodec)) : "",
                    bandwidth: stream.bandwidth,
                    width: stream.width,
                    height: stream.height,
                    url: getAbsoluteURI(stream.uri, adaptationSet.BaseURL)
                };
                representation.BaseURL = parseBaseUrl(representation.url);
                representations.push(representation);
                representationId++;
            }

            adaptationSet.Representation = (representations.length > 1) ? representations : representations[0];
            adaptationSet.Representation_asArray = representations;
            adaptationsSets.push(adaptationSet);

            // Download and process representation (variant stream) playlist
            quality = this.abrController.getPlaybackQuality("video", adaptationsSets[0]).quality;
            representation = adaptationsSets[0].Representation_asArray[quality];
            playlistDefers.push(updatePlaylist.call(this, representation, adaptationSet));

            // Alternative renditions of the same content (alternative audio tracks or subtitles) #EXT-X-MEDIA
            medias = getMedias(manifest);
            for (i = 0; i < medias.length; i++) {
                media = medias[i];
                adaptationSet = {
                    name: 'AdaptationSet',
                    isRoot: false,
                    isArray: true,
                    id: media.name,
                    lang: media.language,
                    contentType: media.type,
                    mimeType: media.type === 'audio' ? 'audio/mp4' : 'text/vtt',
                    maxWidth: 0,
                    maxHeight: 0,
                    BaseURL: period.BaseURL
                };

                representation = {
                    name: 'Representation',
                    isRoot: false,
                    isArray: true,
                    id: '',
                    mimeType: media.type === 'audio' ? 'audio/mp4' : 'text/vtt',
                    codecs: media.type === 'audio' ? streams[0].audioCodec : 'WebVTT',
                    bandwidth: 0,
                    width: 0,
                    height: 0,
                    url: getAbsoluteURI(media.uri, adaptationSet.BaseURL)
                };
                representation.BaseURL = parseBaseUrl(representation.url);

                adaptationSet.Representation = representation;
                adaptationSet.Representation_asArray = [representation];
                adaptationsSets.push(adaptationSet);
                playlistDefers.push(updatePlaylist.call(this, representation, adaptationSet));
            }

            // Get representation (variant stream) playlist
            Q.all(playlistDefers).then(
                function() {
                    postProcess.call(self, mpd, quality).then(function() {
                        deferred.resolve(mpd);
                    });
                },
                function(error) {
                    // error undefined in case of playlist download aborted
                    if (error) {
                        // Variant stream playlist download error
                        deferred.reject(error);
                    } else {
                        // Variant stream playlist download aborted
                        deferred.resolve(null);
                    }
                }
            );

            return deferred.promise;
        },

        internalParse = function(data, baseUrl) {
            this.hlsDemux.reset();
            this.debug.log("[HlsParser]", "Doing parse.");
            this.debug.log("[HlsParser]", data);
            return processManifest.call(this, data, baseUrl);
        },

        abort = function() {
            if (xhrLoader !== null) {
                xhrLoader.abort();
            }
        };

    return {
        debug: undefined,
        config: undefined,
        manifestModel: undefined,
        fragmentLoader: undefined,
        abrController: undefined,
        hlsDemux: undefined,
        metricsModel: undefined,

        setup: function() {
            retryAttempts = this.config.getParam("ManifestLoader.RetryAttempts", "number", DEFAULT_RETRY_ATTEMPTS);
            retryInterval = this.config.getParam("ManifestLoader.RetryInterval", "number", DEFAULT_RETRY_INTERVAL);
        },

        parse: internalParse,

        updatePlaylist: updatePlaylist,

        abort: abort
    };
};

Hls.dependencies.HlsParser.prototype = {
    constructor: Hls.dependencies.HlsParser
};
/*
 * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.
 * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2014, Orange
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

// Define Number.MAX_SAFE_INTEGER value in case it is not defined (such as in IE11)
if (!Number.MAX_SAFE_INTEGER) {
    Number.MAX_SAFE_INTEGER = 9007199254740991;
}

Mss.dependencies.MssParser = function() {
    "use strict";

    var DEFAULT_TIME_SCALE = 10000000.0,
        SUPPORTED_CODECS = ["AAC", "AACL", "AVC1", "H264", "TTML", "DFXP"],
        samplingFrequencyIndex = {
            96000: 0x0,
            88200: 0x1,
            64000: 0x2,
            48000: 0x3,
            44100: 0x4,
            32000: 0x5,
            24000: 0x6,
            22050: 0x7,
            16000: 0x8,
            12000: 0x9,
            11025: 0xA,
            8000: 0xB,
            7350: 0xC
        },
        mimeTypeMap = {
            "video": "video/mp4",
            "audio": "audio/mp4",
            "text": "application/ttml+xml+mp4"
        },
        xmlDoc = null,
        baseURL = null,

        mapPeriod = function(timescale) {
            var period = {},
                adaptations = [],
                adaptation,
                smoothNode = this.domParser.getChildNode(xmlDoc, "SmoothStreamingMedia"),
                i;

            period.BaseURL = baseURL;

            // For each StreamIndex node, create an AdaptationSet element
            for (i = 0; i < smoothNode.childNodes.length; i++) {
                if (smoothNode.childNodes[i].nodeName === "StreamIndex") {
                    adaptation = mapAdaptationSet.call(this, smoothNode.childNodes[i], timescale);
                    if (adaptation !== null) {
                        adaptations.push(adaptation);
                    }
                }
            }

            if (adaptations.length > 0) {
                period.AdaptationSet = (adaptations.length > 1) ? adaptations : adaptations[0];
            }
            period.AdaptationSet_asArray = adaptations;

            return period;
        },

        mapAdaptationSet = function(streamIndex, timescale) {

            var adaptationSet = {},
                representations = [],
                representation,
                segmentTemplate = {},
                qualityLevels = null,
                subType = null,
                i;

            adaptationSet.id = this.domParser.getAttributeValue(streamIndex, "Name");
            adaptationSet.lang = this.domParser.getAttributeValue(streamIndex, "Language");
            adaptationSet.contentType = this.domParser.getAttributeValue(streamIndex, "Type");
            adaptationSet.mimeType = mimeTypeMap[adaptationSet.contentType];
            adaptationSet.maxWidth = this.domParser.getAttributeValue(streamIndex, "MaxWidth");
            adaptationSet.maxHeight = this.domParser.getAttributeValue(streamIndex, "MaxHeight");
            adaptationSet.BaseURL = baseURL;

            subType = this.domParser.getAttributeValue(streamIndex, "Subtype");
            if (subType) {
                adaptationSet.subType = subType;
            }

            // Create a SegmentTemplate with a SegmentTimeline
            segmentTemplate = mapSegmentTemplate.call(this, streamIndex, timescale);

            qualityLevels = this.domParser.getChildNodes(streamIndex, "QualityLevel");
            // For each QualityLevel node, create a Representation element
            for (i = 0; i < qualityLevels.length; i++) {
                // Propagate BaseURL and mimeType
                qualityLevels[i].BaseURL = adaptationSet.BaseURL;
                qualityLevels[i].mimeType = adaptationSet.mimeType;

                // Set quality level id
                qualityLevels[i].Id = adaptationSet.id + "_" + this.domParser.getAttributeValue(qualityLevels[i], "Index");

                // Map Representation to QualityLevel
                representation = mapRepresentation.call(this, qualityLevels[i], streamIndex);

                if (representation !== null) {
                    // Copy SegmentTemplate into Representation
                    representation.SegmentTemplate = segmentTemplate;

                    representations.push(representation);
                }
            }

            if (representations.length === 0) {
                return null;
            }

            adaptationSet.Representation = (representations.length > 1) ? representations : representations[0];
            adaptationSet.Representation_asArray = representations;

            // Set SegmentTemplate
            adaptationSet.SegmentTemplate = segmentTemplate;

            return adaptationSet;
        },

        mapRepresentation = function(qualityLevel, streamIndex) {

            var representation = {},
                fourCCValue = null,
                type = this.domParser.getAttributeValue(streamIndex, "Type");

            representation.id = qualityLevel.Id;
            representation.bandwidth = parseInt(this.domParser.getAttributeValue(qualityLevel, "Bitrate"), 10);
            representation.mimeType = qualityLevel.mimeType;
            representation.width = parseInt(this.domParser.getAttributeValue(qualityLevel, "MaxWidth"), 10);
            representation.height = parseInt(this.domParser.getAttributeValue(qualityLevel, "MaxHeight"), 10);

            fourCCValue = this.domParser.getAttributeValue(qualityLevel, "FourCC");

            // If FourCC not defined at QualityLevel level, then get it from StreamIndex level
            if (fourCCValue === null || fourCCValue === "") {
                fourCCValue = this.domParser.getAttributeValue(streamIndex, "FourCC");
            }

            // If still not defined (optionnal for audio stream, see https://msdn.microsoft.com/en-us/library/ff728116%28v=vs.95%29.aspx),
            // then we consider the stream is an audio AAC stream
            if (fourCCValue === null || fourCCValue === "") {
                if (type === 'audio') {
                    fourCCValue = "AAC";
                } else {
                    this.errHandler.sendWarning(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_CODEC_UNSUPPORTED, type + " codec/FourCC not provided", {codec: ''});
                    return null;
                }
            }

            // Check if codec is supported
            if (SUPPORTED_CODECS.indexOf(fourCCValue.toUpperCase()) === -1) {
                // Do not send warning
                //this.errHandler.sendWarning(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_CODEC_UNSUPPORTED, "Codec/FourCC not supported", {codec: fourCCValue});
                this.debug.warn("[MssParser] Codec not supported: " + fourCCValue);
                return null;
            }

            // Get codecs value according to FourCC field
            if (fourCCValue === "H264" || fourCCValue === "AVC1") {
                representation.codecs = getH264Codec.call(this, qualityLevel);
            } else if (fourCCValue.indexOf("AAC") >= 0) {
                representation.codecs = getAACCodec.call(this, qualityLevel, fourCCValue);
                representation.audioSamplingRate = parseInt(this.domParser.getAttributeValue(qualityLevel, "SamplingRate"), 10);
                representation.audioChannels = parseInt(this.domParser.getAttributeValue(qualityLevel, "Channels"), 10);
            }

            representation.codecPrivateData = "" + this.domParser.getAttributeValue(qualityLevel, "CodecPrivateData");
            representation.BaseURL = qualityLevel.BaseURL;

            return representation;
        },

        getH264Codec = function(qualityLevel) {
            var codecPrivateData = this.domParser.getAttributeValue(qualityLevel, "CodecPrivateData").toString(),
                nalHeader,
                avcoti;


            // Extract from the CodecPrivateData field the hexadecimal representation of the following
            // three bytes in the sequence parameter set NAL unit.
            // => Find the SPS nal header
            nalHeader = /00000001[0-9]7/.exec(codecPrivateData);
            // => Find the 6 characters after the SPS nalHeader (if it exists)
            avcoti = nalHeader && nalHeader[0] ? (codecPrivateData.substr(codecPrivateData.indexOf(nalHeader[0]) + 10, 6)) : undefined;

            return "avc1." + avcoti;
        },

        getAACCodec = function(qualityLevel, fourCCValue) {
            var objectType = 0,
                codecPrivateData = this.domParser.getAttributeValue(qualityLevel, "CodecPrivateData").toString(),
                codecPrivateDataHex,
                samplingRate = parseInt(this.domParser.getAttributeValue(qualityLevel, "SamplingRate"), 10),
                arr16,
                indexFreq,
                extensionSamplingFrequencyIndex;

            //chrome problem, in implicit AAC HE definition, so when AACH is detected in FourCC
            //set objectType to 5 => strange, it should be 2
            if (fourCCValue === "AACH") {
                objectType = 0x05;
            }
            //if codecPrivateData is empty, build it :
            if (codecPrivateData === undefined || codecPrivateData === "") {
                objectType = 0x02; //AAC Main Low Complexity => object Type = 2
                indexFreq = samplingFrequencyIndex[samplingRate];
                if (fourCCValue === "AACH") {
                    // 4 bytes :     XXXXX         XXXX          XXXX             XXXX                  XXXXX      XXX   XXXXXXX
                    //           ' ObjectType' 'Freq Index' 'Channels value'   'Extens Sampl Freq'  'ObjectType'  'GAS' 'alignment = 0'
                    objectType = 0x05; // High Efficiency AAC Profile = object Type = 5 SBR
                    codecPrivateData = new Uint8Array(4);
                    extensionSamplingFrequencyIndex = samplingFrequencyIndex[samplingRate * 2]; // in HE AAC Extension Sampling frequence
                    // equals to SamplingRate*2
                    //Freq Index is present for 3 bits in the first byte, last bit is in the second
                    codecPrivateData[0] = (objectType << 3) | (indexFreq >> 1);
                    codecPrivateData[1] = (indexFreq << 7) | (qualityLevel.Channels << 3) | (extensionSamplingFrequencyIndex >> 1);
                    codecPrivateData[2] = (extensionSamplingFrequencyIndex << 7) | (0x02 << 2); // origin object type equals to 2 => AAC Main Low Complexity
                    codecPrivateData[3] = 0x0; //alignment bits

                    arr16 = new Uint16Array(2);
                    arr16[0] = (codecPrivateData[0] << 8) + codecPrivateData[1];
                    arr16[1] = (codecPrivateData[2] << 8) + codecPrivateData[3];
                    //convert decimal to hex value
                    codecPrivateDataHex = arr16[0].toString(16);
                    codecPrivateDataHex = arr16[0].toString(16) + arr16[1].toString(16);

                } else {
                    // 2 bytes :     XXXXX         XXXX          XXXX              XXX
                    //           ' ObjectType' 'Freq Index' 'Channels value'   'GAS = 000'
                    codecPrivateData = new Uint8Array(2);
                    //Freq Index is present for 3 bits in the first byte, last bit is in the second
                    codecPrivateData[0] = (objectType << 3) | (indexFreq >> 1);
                    codecPrivateData[1] = (indexFreq << 7) | (parseInt(this.domParser.getAttributeValue(qualityLevel, "Channels"), 10) << 3);
                    // put the 2 bytes in an 16 bits array
                    arr16 = new Uint16Array(1);
                    arr16[0] = (codecPrivateData[0] << 8) + codecPrivateData[1];
                    //convert decimal to hex value
                    codecPrivateDataHex = arr16[0].toString(16);
                }

                codecPrivateData = "" + codecPrivateDataHex;
                codecPrivateData = codecPrivateData.toUpperCase();
                qualityLevel.setAttribute("CodecPrivateData", codecPrivateData);
            } else if (objectType === 0) {
                objectType = (parseInt(codecPrivateData.substr(0, 2), 16) & 0xF8) >> 3;
            }

            return "mp4a.40." + objectType;
        },

        mapSegmentTemplate = function(streamIndex, timescale) {

            var segmentTemplate = {},
                mediaUrl,
                streamIndexTimeScale;

            mediaUrl = this.domParser.getAttributeValue(streamIndex, "Url").replace('{bitrate}', '$Bandwidth$');
            mediaUrl = mediaUrl.replace('{start time}', '$Time$');

            streamIndexTimeScale = this.domParser.getAttributeValue(streamIndex, "TimeScale");
            streamIndexTimeScale = streamIndexTimeScale ? parseFloat(streamIndexTimeScale) : timescale;

            segmentTemplate.media = mediaUrl;
            segmentTemplate.timescale = streamIndexTimeScale;

            segmentTemplate.SegmentTimeline = mapSegmentTimeline.call(this, streamIndex, segmentTemplate.timescale);

            return segmentTemplate;
        },

        mapSegmentTimeline = function(streamIndex, timescale) {

            var segmentTimeline = {},
                chunks = this.domParser.getChildNodes(streamIndex, "c"),
                segments = [],
                segment,
                prevSegment,
                i, j, r,
                tManifest,
                duration = 0;

            for (i = 0; i < chunks.length; i++) {
                segment = {};

                // Get time 't' attribute value (as string in order to handle large values, i.e. > 2^53)
                tManifest = this.domParser.getAttributeValue(chunks[i], "t");

                // Check if time is not greater than 2^53
                // => segment.tManifest = original timestamp value as a string (for constructing the fragment request url, see DashHandler)
                // => segment.t = number value of timestamp (maybe rounded value, but only for 0.1 microsecond)
                if (tManifest && goog.math.Long.fromString(tManifest).greaterThan(goog.math.Long.fromNumber(Number.MAX_SAFE_INTEGER))) {
                    segment.tManifest = tManifest;
                }

                segment.t = parseFloat(tManifest);

                // Get duration 'd' attribute value
                segment.d = parseFloat(this.domParser.getAttributeValue(chunks[i], "d"));

                // If 't' not defined for first segment then t=0
                if ((i === 0) && !segment.t) {
                    segment.t = 0;
                }

                if (i > 0) {
                    prevSegment = segments[segments.length - 1];
                    // Update previous segment duration if not defined
                    if (!prevSegment.d) {
                       if (prevSegment.tManifest) {
                           prevSegment.d = goog.math.Long.fromString(tManifest).subtract(goog.math.Long.fromString(prevSegment.tManifest)).toNumber();
                       } else {
                           prevSegment.d = segment.t - prevSegment.t;
                       }
                       duration += prevSegment.d;
                    }
                    // Set segment absolute timestamp if not set in manifest
                    if (!segment.t) {
                        if (prevSegment.tManifest) {
                           segment.tManifest = goog.math.Long.fromString(prevSegment.tManifest).add(goog.math.Long.fromNumber(prevSegment.d)).toString();
                           segment.t = parseFloat(segment.tManifest);
                       } else {
                           segment.t = prevSegment.t + prevSegment.d;
                       }
                    }
                }

                if (segment.d) {
                    duration += segment.d;
                }

                // Create new segment
                segments.push(segment);

                // Support for 'r' attribute (i.e. "repeat" as in MPEG-DASH)
                r = parseFloat(this.domParser.getAttributeValue(chunks[i], "r"));
                if (r) {

                    for (j = 0; j < (r - 1); j++) {
                        prevSegment = segments[segments.length - 1];
                        segment = {};
                        segment.t = prevSegment.t + prevSegment.d;
                        segment.d = prevSegment.d;
                        if (prevSegment.tManifest) {
                            segment.tManifest  = goog.math.Long.fromString(prevSegment.tManifest).add(goog.math.Long.fromNumber(prevSegment.d)).toString();
                        }
                        duration += segment.d;
                        segments.push(segment);
                    }
                }
            }

            segmentTimeline.S = segments;
            segmentTimeline.S_asArray = segments;
            segmentTimeline.duration = duration / timescale;

            return segmentTimeline;
        },

        getKIDFromProtectionHeader = function(protectionHeader) {
            var prHeader,
                wrmHeader,
                xmlReader,
                KID;

            // Get PlayReady header as byte array (base64 decoded)
            prHeader = BASE64.decodeArray(protectionHeader.firstChild.data);

            // Get Right Management header (WRMHEADER) from PlayReady header
            wrmHeader = getWRMHeaderFromPRHeader(prHeader);

            // Convert from multi-byte to unicode
            wrmHeader = new Uint16Array(wrmHeader.buffer);

            // Convert to string
            wrmHeader = String.fromCharCode.apply(null, wrmHeader);

            // Parse <WRMHeader> to get KID field value
            xmlReader = (new DOMParser()).parseFromString(wrmHeader, "application/xml");
            KID = xmlReader.querySelector("KID").textContent;

            // Get KID (base64 decoded) as byte array
            KID = BASE64.decodeArray(KID);

            // Convert UUID from little-endian to big-endian
            convertUuidEndianness(KID);

            return KID;
        },

        getWRMHeaderFromPRHeader = function(prHeader) {
            var length,
                recordCount,
                recordType,
                recordLength,
                recordValue,
                i = 0;

            // Parse PlayReady header

            // Length - 32 bits (LE format)
            length = (prHeader[i + 3] << 24) + (prHeader[i + 2] << 16) + (prHeader[i + 1] << 8) + prHeader[i];
            i += 4;

            // Record count - 16 bits (LE format)
            recordCount = (prHeader[i + 1] << 8) + prHeader[i];
            i += 2;

            // Parse records
            while (i < prHeader.length) {
                // Record type - 16 bits (LE format)
                recordType = (prHeader[i + 1] << 8) + prHeader[i];
                i += 2;

                // Check if Rights Management header (record type = 0x01)
                if (recordType === 0x01) {

                    // Record length - 16 bits (LE format)
                    recordLength = (prHeader[i + 1] << 8) + prHeader[i];
                    i += 2;

                    // Record value => contains <WRMHEADER>
                    recordValue = new Uint8Array(recordLength);
                    recordValue.set(prHeader.subarray(i, i + recordLength));
                    return recordValue;
                }
            }

            return null;
        },

        convertUuidEndianness = function(uuid) {
            swapBytes(uuid, 0, 3);
            swapBytes(uuid, 1, 2);
            swapBytes(uuid, 4, 5);
            swapBytes(uuid, 6, 7);
        },

        swapBytes = function(bytes, pos1, pos2) {
            var temp = bytes[pos1];
            bytes[pos1] = bytes[pos2];
            bytes[pos2] = temp;
        },


        createPRContentProtection = function(protectionHeader) {

            var contentProtection = {},
                keySystem = this.system.getObject("ksPlayReady"),
                pro;

            pro = {
                __text: protectionHeader.firstChild.data,
                __prefix: "mspr"
            };

            contentProtection.schemeIdUri = keySystem.schemeIdURI;
            contentProtection.value = keySystem.systemString;
            contentProtection.pro = pro;
            contentProtection.pro_asArray = pro;

            return contentProtection;
        },

        createWidevineContentProtection = function(KID) {

            var contentProtection = {},
                keySystem = this.system.getObject("ksWidevine");

            contentProtection.schemeIdUri = keySystem.schemeIdURI;
            contentProtection.value = keySystem.systemString;

            // Create Widevine CENC header (Protocol Buffer) with KID value
            var wvCencHeader = new Uint8Array(2 + KID.length);
            wvCencHeader[0] = 0x12;
            wvCencHeader[1] = 0x10;
            wvCencHeader.set(KID, 2);
    
            // Create a pssh box
            var length = 12 /* box length, type, version and flags */ + 16 /* SystemID */ + 4 /* data length */ + wvCencHeader.length,
                pssh = new Uint8Array(length),
                i = 0;
    
            // Set box length value
            pssh[i++] = (length & 0xFF000000) >> 24;
            pssh[i++] = (length & 0x00FF0000) >> 16;
            pssh[i++] = (length & 0x0000FF00) >> 8;
            pssh[i++] = (length & 0x000000FF);
    
            // Set type ('pssh'), version (0) and flags (0)
            pssh.set([0x70, 0x73, 0x73, 0x68, 0x00, 0x00, 0x00, 0x00], i);
            i += 8;
    
            // Set SystemID ('edef8ba9-79d6-4ace-a3c8-27dcd51d21ed')
            pssh.set([0xed, 0xef, 0x8b, 0xa9,  0x79, 0xd6, 0x4a, 0xce, 0xa3, 0xc8, 0x27, 0xdc, 0xd5, 0x1d, 0x21, 0xed], i);
            i += 16;
    
            // Set data length value
            pssh[i++] = (wvCencHeader.length & 0xFF000000) >> 24;
            pssh[i++] = (wvCencHeader.length & 0x00FF0000) >> 16;
            pssh[i++] = (wvCencHeader.length & 0x0000FF00) >> 8;
            pssh[i++] = (wvCencHeader.length & 0x000000FF);
    
            // Copy Widevine CENC header
            pssh.set(wvCencHeader, i);
    
            // Convert to BASE64 string
            pssh = String.fromCharCode.apply(null, pssh);
            pssh = BASE64.encodeASCII(pssh);         
            
            // Add pssh value to ContentProtection
            contentProtection.pssh = {
                __text: pssh
            };

            return contentProtection;
        },

        addDVRInfo = function(adaptationSet) {
            var segmentTemplate = adaptationSet.SegmentTemplate,
                segments = segmentTemplate.SegmentTimeline.S_asArray;

            if (segments.length === 0) {
                return;
            }

            var range = {
                start: segments[0].t / segmentTemplate.timescale,
                end: (segments[segments.length - 1].t + segments[segments.length - 1].d) / segmentTemplate.timescale
            };

            this.metricsModel.addDVRInfo(adaptationSet.contentType, new Date(), range);
        },

        processManifest = function(manifestLoadedTime) {
            var mpd = {},
                period,
                adaptations,
                contentProtection,
                contentProtections = [],
                smoothNode = this.domParser.getChildNode(xmlDoc, "SmoothStreamingMedia"),
                protection = this.domParser.getChildNode(smoothNode, 'Protection'),
                protectionHeader = null,
                KID,
                timestampOffset,
                startTime,
                segments,
                i, j;

            // Set mpd node properties
            mpd.name = 'MSS';
            mpd.profiles = "urn:mpeg:dash:profile:isoff-live:2011";
            var timescale = this.domParser.getAttributeValue(smoothNode, 'TimeScale');
            mpd.timescale = timescale ? parseFloat(timescale) : DEFAULT_TIME_SCALE;
            var isLive = this.domParser.getAttributeValue(smoothNode, 'IsLive');
            mpd.type = (isLive !== null && isLive.toLowerCase() === 'true') ? 'dynamic' : 'static';
            var canSeek = this.domParser.getAttributeValue(smoothNode, 'CanSeek');
            var dvrWindowLength = parseFloat(this.domParser.getAttributeValue(smoothNode, 'DVRWindowLength'));
            if (dvrWindowLength === 0 && canSeek !== null && canSeek.toLowerCase() === 'true') {
                dvrWindowLength = Infinity;
            }
            mpd.timeShiftBufferDepth = dvrWindowLength / mpd.timescale;
            var duration = parseFloat(this.domParser.getAttributeValue(smoothNode, 'Duration'));

            // If live manifest with Duration, we consider it as a start-over manifest
            if (mpd.type === "dynamic" && duration > 0) {
                mpd.type = "static";
                mpd.startOver = true;
                // We set timeShiftBufferDepth to initial duration, to be used by MssFragmentController to update segment timeline
                mpd.timeShiftBufferDepth = duration / mpd.timescale;
                // Duration will be set according to current segment timeline duration (see below)
            }

            // Complete manifest/mpd initialization
            mpd.mediaPresentationDuration = (duration === 0) ? Infinity : (duration / mpd.timescale);
            mpd.BaseURL = baseURL;
            mpd.minBufferTime = MediaPlayer.dependencies.BufferExtensions.DEFAULT_MIN_BUFFER_TIME;

            // In case of live streams, set availabilityStartTime property according to DVRWindowLength
            if (mpd.type === "dynamic" && mpd.timeShiftBufferDepth < Infinity ) {
                mpd.availabilityStartTime = new Date(manifestLoadedTime.getTime() - (mpd.timeShiftBufferDepth * 1000));
            }

            // Map period node to manifest root node
            mpd.Period = mapPeriod.call(this, mpd.timescale);
            mpd.Period_asArray = [mpd.Period];

            period = mpd.Period;

            // Complete period initialization
            period.start = 0;

            // Test live to static
            // if (mpd.type !== 'static') {
            //     mpd.type = 'static';
            //     mpd.mediaPresentationDuration = mpd.timeShiftBufferDepth;
            // }

            // ContentProtection node
            if (protection !== undefined) {
                if (MediaPlayer.dependencies.ProtectionController) {
                    protectionHeader = this.domParser.getChildNode(protection, 'ProtectionHeader');

                    // Some packagers put newlines into the ProtectionHeader base64 string, which is not good
                    // because this cannot be correctly parsed. Let's just filter out any newlines found in there.
                    protectionHeader.firstChild.data = protectionHeader.firstChild.data.replace(/\n|\r/g, "");

                    // Get KID (in CENC format) from protection header
                    KID = getKIDFromProtectionHeader(protectionHeader);

                    // Create ContentProtection for PR
                    contentProtection = createPRContentProtection.call(this, protectionHeader);
                    contentProtection["cenc:default_KID"] = KID;
                    contentProtections.push(contentProtection);

                    // Create ContentProtection for Widevine (as a CENC protection)
                    contentProtection = createWidevineContentProtection.call(this, KID);
                    contentProtection["cenc:default_KID"] = KID;
                    contentProtections.push(contentProtection);

                    mpd.ContentProtection = (contentProtections.length > 1) ? contentProtections : contentProtections[0];
                    mpd.ContentProtection_asArray = contentProtections;
                } else {
                    mpd.error = {
                        name: MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_ENCRYPTED,
                        message: "protected content detected but protection module is not included."
                    };
                    return mpd;
                }
            }

            adaptations = period.AdaptationSet_asArray;

            for (i = 0; i < adaptations.length; i += 1) {
                // Propagate content protection information into each adaptation
                if (mpd.ContentProtection !== undefined) {
                    adaptations[i].ContentProtection = mpd.ContentProtection;
                    adaptations[i].ContentProtection_asArray = mpd.ContentProtection_asArray;
                }

                if (mpd.type === "dynamic") {
                    // set availabilityStartTime for infinite DVR Window from segment timeline duration
                    if (mpd.timeShiftBufferDepth === Infinity) {
                        mpd.availabilityStartTime = new Date(manifestLoadedTime.getTime() - (adaptations[1].SegmentTemplate.SegmentTimeline.duration * 1000));
                    }
                    // Match timeShiftBufferDepth to video segment timeline duration
                    if (mpd.timeShiftBufferDepth > 0 &&
                        mpd.timeShiftBufferDepth !== Infinity &&
                        adaptations[i].contentType === 'video' &&
                        mpd.timeShiftBufferDepth > adaptations[i].SegmentTemplate.SegmentTimeline.duration) {
                        mpd.timeShiftBufferDepth = adaptations[i].SegmentTemplate.SegmentTimeline.duration;
                    }

                    // Add DVRInfo for live streams
                    addDVRInfo.call(this, adaptations[i]);
                }
            }

            if (mpd.timeShiftBufferDepth < mpd.minBufferTime) {
                mpd.minBufferTime = mpd.timeShiftBufferDepth;
            }

            // Delete Content Protection under root mpd node
            delete mpd.ContentProtection;
            delete mpd.ContentProtection_asArray;

            // In case of VOD streams, check if start time is greater than 0
            // Then determine timestamp offset according to higher audio/video start time
            // (use case = live stream delinearization)
            if (mpd.type === "static") {
                // In case of start-over stream and manifest reloading (due to track switch)
                // we consider previous timestampOffset to keep timelines synchronized
                var prevManifest = this.manifestModel.getValue();
                if (prevManifest && prevManifest.timestampOffset) {
                    timestampOffset = prevManifest.timestampOffset;
                } else {
                    for (i = 0; i < adaptations.length; i++) {
                        if (adaptations[i].contentType === 'audio' || adaptations[i].contentType === 'video') {
                            segments = adaptations[i].SegmentTemplate.SegmentTimeline.S_asArray;
                            startTime = segments[0].t / adaptations[i].SegmentTemplate.timescale;
                            if (timestampOffset === undefined) {
                                timestampOffset = startTime;
                            }
                            timestampOffset = Math.min(timestampOffset, startTime);
                            // Correct content duration according to minimum adaptation's segment timeline duration
                            // in order to force <video> element sending 'ended' event
                            mpd.mediaPresentationDuration = Math.min(mpd.mediaPresentationDuration, adaptations[i].SegmentTemplate.SegmentTimeline.duration);
                        }
                    }
                }

                // Patch segment templates timestamps and determine period start time (since audio/video should not be aligned to 0)
                if (timestampOffset > 0) {
                    mpd.timestampOffset = timestampOffset;
                    for (i = 0; i < adaptations.length; i++) {
                        segments = adaptations[i].SegmentTemplate.SegmentTimeline.S_asArray;
                        for (j = 0; j < segments.length; j++) {
                            if (!segments[j].tManifest) {
                                segments[j].tManifest = segments[j].t;
                            }
                            segments[j].t -= (timestampOffset * adaptations[i].SegmentTemplate.timescale);
                        }
                        if (adaptations[i].contentType === 'audio' || adaptations[i].contentType === 'video') {
                            period.start = Math.max(segments[0].t, period.start);
                        }
                    }
                    period.start /= mpd.timescale;
                }
            }

            // Floor the duration to get around precision differences between segments timestamps and MSE buffer timestamps
            // and the avoid 'ended' event not being raised
            mpd.mediaPresentationDuration = Math.floor(mpd.mediaPresentationDuration * 1000) / 1000;
            period.duration = mpd.mediaPresentationDuration;

            return mpd;
        },

        internalParse = function(data, baseUrl) {
            this.debug.info("[MssParser]", "Doing parse.");

            var start = new Date(),
                xml = null,
                manifest = null,
                mss2dash = null;

            //this.debug.log("[MssParser]", "Converting from XML.");
            xmlDoc = this.domParser.createXmlTree(data);
            xml = new Date();

            if (xmlDoc === null) {
                return Q.reject(null);
            }

            baseURL = baseUrl;

            // Convert MSS manifest into DASH manifest
            manifest = processManifest.call(this, start);

            if (manifest.error) {
                return Q.reject(manifest.error);
            }
            mss2dash = new Date();
            //this.debug.log("mpd: " + JSON.stringify(manifest, null, '\t'));

            this.debug.info("[MssParser]", "Parsing complete (xmlParser: " + (xml.getTime() - start.getTime()) + "ms, mss2dash: " + (mss2dash.getTime() - xml.getTime()) + "ms, total: " + ((new Date().getTime() - start.getTime()) / 1000) + "s)");
            //console.info("manifest",JSON.stringify(manifest) );
            return Q.when(manifest);
        };

    return {
        debug: undefined,
        system: undefined,
        errHandler: undefined,
        domParser: undefined,
        metricsModel: undefined,
        manifestModel: undefined,

        parse: internalParse
    };
};

Mss.dependencies.MssParser.prototype = {
    constructor: Mss.dependencies.MssParser
};

/*
 * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.
 * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2014, Orange
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
Mss.dependencies.MssHandler = function() {
    "use strict";

    var getAudioChannels = function(adaptation, representation) {
            var channels = 1;

            if (adaptation.audioChannels) {
                channels = adaptation.audioChannels;
            } else if (representation.audioChannels) {
                channels = representation.audioChannels;
            }

            return channels;
        },

        getAudioSamplingRate = function(adaptation, representation) {
            var samplingRate = 1;

            if (adaptation.audioSamplingRate) {
                samplingRate = adaptation.audioSamplingRate;
            } else {
                samplingRate = representation.audioSamplingRate;
            }

            return samplingRate;
        },

        // Generates initialization segment data from representation information
        // by using mp4lib library
        getInitData = function(representation) {
            var manifest = rslt.manifestModel.getValue(),
                adaptation,
                realAdaptation,
                realRepresentation,
                track,
                codec;

            if (representation.initData) {
                return representation.initData;
            }

            // Get required media information from manifest  to generate initialisation segment
            adaptation = representation.adaptation;
            realAdaptation = manifest.Period_asArray[adaptation.period.index].AdaptationSet_asArray[adaptation.index];
            realRepresentation = realAdaptation.Representation_asArray[representation.index];

            track = new MediaPlayer.vo.Mp4Track();
            track.type = rslt.getType() || 'und';
            track.trackId = adaptation.index + 1; // +1 since track_id shall start from '1'
            track.timescale = representation.timescale;
            track.duration = representation.adaptation.period.duration;
            track.codecs = realRepresentation.codecs;
            track.codecPrivateData = realRepresentation.codecPrivateData;
            track.bandwidth = realRepresentation.bandwidth;

            if (track.type !== 'text') {
                codec = realRepresentation.mimeType + ';codecs="' + realRepresentation.codecs + '"';
                if (!this.capabilities.supportsCodec(this.videoModel.getElement(), codec)) {
                    throw {
                        name: MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_CODEC_UNSUPPORTED,
                        message: 'Codec is not supported (HTMLMediaElement)',
                        data: {
                            codec: codec,
                            bandwidth: realRepresentation.bandwidth,
                            codecPrivateData: realRepresentation.codecPrivateData
                        }
                    };
                }
            }

            // DRM Protected Adaptation is detected
            if (realAdaptation.ContentProtection_asArray && (realAdaptation.ContentProtection_asArray.length > 0)) {
                track.contentProtection = realAdaptation.ContentProtection_asArray;
            }

            // Video related informations
            track.width = realRepresentation.width || realAdaptation.maxWidth;
            track.height = realRepresentation.height || realAdaptation.maxHeight;

            // Audio related informations
            track.language = realAdaptation.lang ? realAdaptation.lang : 'und';

            track.channels = getAudioChannels(realAdaptation, realRepresentation);
            track.samplingRate = getAudioSamplingRate(realAdaptation, realRepresentation);

            representation.initData = rslt.mp4Processor.generateInitSegment([track]);

            return representation.initData;

        };

    var rslt = MediaPlayer.utils.copyMethods(Dash.dependencies.DashHandler);
    rslt.mp4Processor = undefined;

    rslt.getInitRequest = function(representation) {
        var period = null,
            self = this,
            presentationStartTime = null,
            request = null,
            deferred = Q.defer();

        if (!representation) {
            throw new Error("MssHandler.getInitRequest(): representation is undefined");
        }

        period = representation.adaptation.period;
        presentationStartTime = period.start;

        request = new MediaPlayer.vo.SegmentRequest();

        request.streamType = rslt.getType();
        request.type = "Initialization Segment";
        request.url = null;

        try {
            request.data = getInitData.call(this, representation);
        } catch (e) {
            deferred.reject(e);
            return deferred.promise;
        }

        request.range = representation.range;
        request.availabilityStartTime = self.timelineConverter.calcAvailabilityStartTimeFromPresentationTime(presentationStartTime, representation.adaptation.period.mpd, rslt.getIsDynamic());
        request.availabilityEndTime = self.timelineConverter.calcAvailabilityEndTimeFromPresentationTime(presentationStartTime + period.duration, period.mpd, rslt.getIsDynamic());

        //request.action = "complete"; //needed to avoid to execute request
        request.quality = representation.index;
        deferred.resolve(request);

        return deferred.promise;
    };

    rslt.getIFrameRequest = function(request){
        if (request && request.url && (request.streamType === "video" || request.streamType === "audio")) {
            request.url = request.url.replace('Fragments','KeyFrames');
        }

        return request;
    };

    rslt.getFragmentInfoRequest = function(request){
        if (request && request.url) {
            request.url = request.url.replace('Fragments','FragmentInfo');
            request.type = "FragmentInfo Segment";
        }

        return request;
    };

    return rslt;
};

Mss.dependencies.MssHandler.prototype = {
    constructor: Mss.dependencies.MssHandler
};
/*
 * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.
 * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2014, Orange
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
Mss.dependencies.MssFragmentController = function() {
    "use strict";

    var processTfrf = function(request, tfrf, tfdt, adaptation) {
            var manifest = this.manifestModel.getValue(),
                segments = adaptation.SegmentTemplate.SegmentTimeline.S_asArray,
                timescale = adaptation.SegmentTemplate.timescale,
                entries = tfrf.entry,
                entry,
                segment = null,
                segmentTime,
                t = 0,
                availabilityStartTime = null,
                type = adaptation.type,
                range;

            // Process tfrf only for live or start-over streams
            if (!this.manifestExt.getIsDynamic(manifest) && !this.manifestExt.getIsStartOver(manifest)) {
                return;
            }

            if (entries.length === 0) {
                return;
            }

            // Consider only first tfrf entry (to avoid pre-condition failure on fragment info requests)
            entry = entries[0];

            // !! For tfrf fragment_absolute_time and fragment_duration are returned as goog.math.Long values (see mp4lib)

            // Check if time is not greater than Number.MAX_SAFE_INTEGER (2^53-1), see MssParser
            // => fragment_absolute_timeManifest = original timestamp value as a string (for constructing the fragment request url, see DashHandler)
            // => fragment_absolute_time = number value of timestamp (maybe rounded value, but only for 0.1 microsecond)
            if (entry.fragment_absolute_time.greaterThan(goog.math.Long.fromNumber(Number.MAX_SAFE_INTEGER))) {
                entry.fragment_absolute_timeManifest = entry.fragment_absolute_time.toString();
            }

            // Convert goog.math.Long to Number values
            entry.fragment_absolute_time = entry.fragment_absolute_time.toNumber();
            entry.fragment_duration = entry.fragment_duration.toNumber();

            // In case of start-over streams, check if we have reached end of original manifest duration (set in timeShiftBufferDepth)
            // => then do not update anymore timeline
            if (this.manifestExt.getIsStartOver(manifest)) {
                // Get first segment time
                segmentTime = segments[0].tManifest ? parseFloat(segments[0].tManifest) : segments[0].t;
                if (entry.fragment_absolute_time > (segmentTime + (manifest.timeShiftBufferDepth * timescale))) {
                    return;
                }                    
            }

            // Get last segment time
            segmentTime = segments[segments.length - 1].tManifest ? parseFloat(segments[segments.length - 1].tManifest) : segments[segments.length - 1].t;

            // Check if we have to append new segment to timeline
            if (entry.fragment_absolute_time <= segmentTime) {
                return;
            }

            this.debug.log("[MssFragmentController][" + type + "] Add new segment - t = " + (entry.fragment_absolute_time / timescale));
            segment = {};
            segment.t = entry.fragment_absolute_time;
            segment.d = entry.fragment_duration;
            // If timestamps starts at 0 relative to 1st segment (dynamic to static) then update segment time
            if (segments[0].tManifest) {
                segment.t -= parseFloat(segments[0].tManifest) - segments[0].t;
            }
            // Set tManifest either in case of timestamps greater then 2^53 or in case of dynamic to static streams
            if (entry.fragment_absolute_timeManifest) {
                segment.tManifest = entry.fragment_absolute_timeManifest;
            } else if (segments[0].tManifest) {
                segment.tManifest = entry.fragment_absolute_time;
            }
            segments.push(segment);

            // In case of static start-over streams, update content duration
            if (this.manifestExt.getIsStartOver(manifest)) {
                if (type === 'video') {
                    segment = segments[segments.length - 1];
                    var end = (segment.t + segment.d) / timescale;
                    if (end > this.videoModel.getDuration()) {
                        this.system.notify("sourceDurationChanged", end);
                    }    
                }
                return;
            }
            // In case of live streams, update segment timeline according to DVR window
            else if (manifest.timeShiftBufferDepth && manifest.timeShiftBufferDepth > 0) {
                // Get timestamp of the last segment
                segment = segments[segments.length - 1];
                t = segment.t;

                // Determine the segments' availability start time
                availabilityStartTime = t - (manifest.timeShiftBufferDepth * timescale);

                // Remove segments prior to availability start time
                segment = segments[0];
                while (segment.t < availabilityStartTime) {
                    this.debug.log("[MssFragmentController][" + type + "] Remove segment  - t = " + (segment.t / timescale));
                    segments.splice(0, 1);
                    segment = segments[0];
                }

                // Update DVR window range => set range's end to end time of current segment
                range = {
                    start: segments[0].t / adaptation.SegmentTemplate.timescale,
                    end: (tfdt.baseMediaDecodeTime / adaptation.SegmentTemplate.timescale) + request.duration
                };
                var dvrInfos = this.metricsModel.getMetricsFor(adaptation.type).DVRInfo;
                if (dvrInfos && dvrInfos.length > 0 && range.end > dvrInfos[dvrInfos.length - 1].range.end) {
                    this.metricsModel.addDVRInfo(adaptation.type, new Date(), range);
                }
            }

            return;
        },

        updateSegmentsList = function(bytes, request, adaptation) {
            var fragment = null,
                moof = null,
                traf = null,
                tfdt = null,
                tfrf = null,
                pos;

            // Create new fragment
            fragment = mp4lib.deserialize(bytes);
            moof = fragment.getBoxByType("moof");
            traf = moof.getBoxByType("traf");
            // Create and add tfdt box
            tfdt = traf.getBoxByType("tfdt");
            if (tfdt === null) {
                tfdt = new mp4lib.boxes.TrackFragmentBaseMediaDecodeTimeBox();
                tfdt.version = 1;
                tfdt.flags = 0;
                tfdt.baseMediaDecodeTime = Math.floor(request.startTime * request.timescale);
                // Insert tfdt box just after the tfhd box (therefore before the trun box)
                pos = traf.getBoxIndexByType("tfhd");
                traf.boxes.splice(pos + 1, 0, tfdt);
            }
            // Process tfrf box
            tfrf = traf.getBoxesByType("tfrf");
            if (tfrf === null || tfrf.length === 0) {
                throw {
                    name: MediaPlayer.dependencies.ErrorHandler.prototype.MSS_NO_TFRF,
                    message: 'Missing tfrf in live FragmentInfo segment',
                    data: {
                        url: request.url
                    }
                };
            } else {
                processTfrf.call(this, request, tfrf[0], tfdt, adaptation);
            }
        },

        duplicateSample = function(fragment, segmentDuration) {
            var moof = null,
                mdat = null,
                traf = null,
                trun = null,
                tfhd,
                sepiff = null,
                saiz = null,
                i,
                trunEntries,
                trunDuration,
                mdatData;

            // This function duplicates the first sample (from KeyFrame request) to generate a full segment that lasts segmentDuration.

            // Get references on boxes
            moof = fragment.getBoxByType("moof");
            mdat = fragment.getBoxByType("mdat");
            traf = moof.getBoxByType("traf");
            trun = traf.getBoxByType("trun");
            tfhd = traf.getBoxByType("tfhd");

            // Set first sample duration (if not set)
            // (sample duration has to be set for each sample in case we have to modify last sample duration to complete the segment)
            if (!trun.samples_table[0].sample_duration) {
                trun.samples_table[0].sample_duration = tfhd.default_sample_duration;
            }

            // Update trun flags to indicate sample-duration-present flag is set (since we do set sample_duration for each sample)
            trun.flags |= 0x000100;

            // Update tfhd flags to indicate default-sample-duration-present flag is not set (since we do set sample_duration for each sample)
            tfhd.flags &= 0xFFFFF7;

            // Determine number of samples according to the segment duration
            trunEntries = Math.floor(segmentDuration / trun.samples_table[0].sample_duration);

            // Duplicate 1st sample in trun box to complete fragment
            for (i = 0; i < (trunEntries - 1); i++) {
                trun.samples_table.push(trun.samples_table[0]);
            }
            trun.sample_count = trun.samples_table.length;

            // Patch/lengthen the last sample duration if segment not complete
            trunDuration = trunEntries * trun.samples_table[0].sample_duration;
            if (trunDuration < segmentDuration) {
                trun.samples_table[trun.samples_table.length - 1].sample_duration += segmentDuration - trunDuration;
            }

            // Update PIFF Sample Encryption box
            sepiff = traf.getBoxByType("sepiff");
            if (sepiff !== null) {
                // sepiff box may have already all original samples encryption data definition
                // => we keep only first sample entry
                if (sepiff.sample_count > 1) {
                    sepiff.entry = sepiff.entry.slice(0, 1);
                }
                // Then, we duplicate this first entry
                for (i = 0; i < (trunEntries - 1); i += 1) {
                    sepiff.entry.push(sepiff.entry[0]);
                }
                sepiff.sample_count = sepiff.entry.length;
            }

            // Update saiz box
            saiz = traf.getBoxByType("saiz");
            if (saiz !== null) {
                if (saiz.default_sample_info_size === 0) {
                    // Same process as for sepiff box....
                    if (saiz.sample_count > 1) {
                        saiz.sample_info_size = saiz.sample_info_size.slice(0, 1);
                    }
                    for (i = 0; i < (trunEntries - 1); i += 1) {
                        saiz.sample_info_size.push(saiz.sample_info_size[0]);
                    }
                }
                saiz.sample_count = sepiff.entry.length;
            }

            // Duplicate mdat data
            mdatData = mdat.data;
            mdat.data = new Uint8Array(mdatData.length * trun.sample_count);
            for (i = 0; i < trun.sample_count; i++) {
                mdat.data.set(mdatData, mdatData.length * i);
            }
        },

        convertFragment = function(data, request, adaptation) {
            var i = 0,
                // Get track id corresponding to adaptation set
                manifest = this.manifestModel.getValue(),
                trackId = manifest ? this.manifestExt.getIndex(adaptation, manifest) + 1 : -1, // +1 since track_id shall start from '1'
                // Create new fragment
                fragment = mp4lib.deserialize(data),
                moof = null,
                mdat = null,
                traf = null,
                trun = null,
                tfhd = null,
                saio = null,
                sepiff = null,
                saiz = null,
                tfdt = null,
                tfrf = null,
                fragmentDuration,
                sampleDuration,
                pos = -1,
                fragment_size = 0,
                moofPosInFragment = 0,
                trafPosInMoof = 0,
                sencPosInTraf = 0,
                new_data = null;

            if (!fragment) {
                return null;
            }

            // Get references on boxes
            moof = fragment.getBoxByType("moof");
            mdat = fragment.getBoxByType("mdat");
            traf = moof.getBoxByType("traf");
            trun = traf.getBoxByType("trun");
            tfhd = traf.getBoxByType("tfhd");

            // Patch trun and mdat boxes to duplicate first sample in order to have a complete fragment
            // => use case in trick mode where we do request only Key (I) frames, while the <video> element
            // requires continuous stream to enable playback
            sampleDuration = trun.samples_table[0].sample_duration !== undefined ? trun.samples_table[0].sample_duration : tfhd.default_sample_duration;
            fragmentDuration = request.duration * request.timescale;
            if (trun.samples_table.length === 1 && sampleDuration < fragmentDuration) {
                duplicateSample(fragment, fragmentDuration);
            }

            // if (tfhd.default_sample_duration) {
            //     for (i = 0; i < trun.samples_table.length; i++) {
            //         trun.samples_table[i].sample_duration = tfhd.default_sample_duration;
            //     }
            //     trun.flags |= 0x000100;
            //     tfhd.flags &= 0xFFFFF7;
            // }

            // Update tfhd.track_ID field
            tfhd.track_ID = trackId;

            // Process tfxd boxes
            // This box provide absolute timestamp but we take the segment start time for tfdt
            traf.removeBoxByType("tfxd");

            // Create and add tfdt box
            tfdt = traf.getBoxByType("tfdt");
            if (tfdt === null) {
                tfdt = new mp4lib.boxes.TrackFragmentBaseMediaDecodeTimeBox();
                tfdt.version = 1;
                tfdt.flags = 0;
                tfdt.baseMediaDecodeTime = Math.floor(request.startTime * request.timescale);
                // Insert tfdt box just after the tfhd box (therefore before the trun box)
                pos = traf.getBoxIndexByType("tfhd");
                traf.boxes.splice(pos + 1, 0, tfdt);
            }

            if (manifest.type === 'dynamic')  {
                // Process tfrf box
                tfrf = traf.getBoxesByType("tfrf");
                if (tfrf === null || tfrf.length === 0) {
                    throw {
                        name: MediaPlayer.dependencies.ErrorHandler.prototype.MSS_NO_TFRF,
                        message: 'Missing tfrf in live media segment',
                        data: {
                            url: request.url
                        }
                    };
                } else {
                    processTfrf.call(this, request, tfrf[0], tfdt, adaptation);
                    traf.removeBoxByType("tfrf");
                }
            }

            // If protected content in PIFF1.1 format (sepiff box = Sample Encryption PIFF)
            // => convert sepiff box it into a senc box
            // => create saio and saiz boxes (if not already present)
            sepiff = traf.getBoxByType("sepiff");
            if (sepiff !== null) {
                sepiff.boxtype = "senc";
                sepiff.extended_type = undefined;

                saio = traf.getBoxByType("saio");
                if (saio === null) {
                    // Create Sample Auxiliary Information Offsets Box box (saio)
                    saio = new mp4lib.boxes.SampleAuxiliaryInformationOffsetsBox();
                    saio.version = 0;
                    saio.flags = 0;
                    saio.entry_count = 1;
                    saio.offset = [];

                    saiz = new mp4lib.boxes.SampleAuxiliaryInformationSizesBox();
                    saiz.version = 0;
                    saiz.flags = 0;
                    saiz.sample_count = sepiff.sample_count;
                    saiz.default_sample_info_size = 0;
                    saiz.sample_info_size = [];

                    if (sepiff.flags & 0x02) {
                        // Sub-sample encryption => set sample_info_size for each sample
                        for (i = 0; i < sepiff.sample_count; i += 1) {
                            // 10 = 8 (InitializationVector field size) + 2 (subsample_count field size)
                            // 6 = 2 (BytesOfClearData field size) + 4 (BytesOfEncryptedData field size)
                            saiz.sample_info_size[i] = 10 + (6 * sepiff.entry[i].NumberOfEntries);
                        }
                    } else {
                        // No sub-sample encryption => set default sample_info_size = InitializationVector field size (8)
                        saiz.default_sample_info_size = 8;
                    }

                    //add saio and saiz box
                    traf.boxes.push(saiz);
                    traf.boxes.push(saio);
                }
            }

            // Before determining new size of the converted fragment we update some box flags related to data offset
            tfhd.flags &= 0xFFFFFE; // set tfhd.base-data-offset-present to false
            tfhd.flags |= 0x020000; // set tfhd.default-base-is-moof to true
            trun.flags |= 0x000001; // set trun.data-offset-present to true
            trun.data_offset = 0; // Set a default value for trun.data_offset

            // Determine new size of the converted fragment and allocate new data buffer
            fragment_size = fragment.getLength();

            // Update trun.data_offset field = offset of first data byte (inside mdat box)
            trun.data_offset = fragment_size - mdat.size + 8; // 8 = 'size' + 'type' mdat fields length

            // Update saio box offset field according to new senc box offset
            saio = traf.getBoxByType("saio");
            if (saio !== null) {
                moofPosInFragment = fragment.getBoxOffsetByType("moof");
                trafPosInMoof = moof.getBoxOffsetByType("traf");
                sencPosInTraf = traf.getBoxOffsetByType("senc");
                // Set offset from begin fragment to the first IV field in senc box
                saio.offset[0] = moofPosInFragment + trafPosInMoof + sencPosInTraf + 16; // 16 = box header (12) + sample_count field size (4)
            }

            new_data = mp4lib.serialize(fragment);

            return new_data;
        };

    var rslt = MediaPlayer.utils.copyMethods(MediaPlayer.dependencies.FragmentController);

    rslt.manifestModel = undefined;
    rslt.manifestExt = undefined;
    rslt.metricsModel = undefined;
    rslt.videoModel = undefined;
    rslt.mediaSourceExt = undefined;

    rslt.process = function(bytes, request, representation) {
        var deferred = Q.defer(),
            result = null,
            manifest = this.manifestModel.getValue(),
            adaptation = null;

        if (bytes !== null && bytes !== undefined && bytes.byteLength > 0) {
            result = new Uint8Array(bytes);
        } else {
            deferred.resolve(null);
            return deferred.promise;
        }

        if (manifest && representation) {
            try {
                // Get adaptation containing provided representations
                // (Note: here representations is of type Dash.vo.Representation)
                adaptation = manifest.Period_asArray[representation.adaptation.period.index].AdaptationSet_asArray[representation.adaptation.index];
                if (request) {
                    if (request.type === "Media Segment") {
                        result = convertFragment.call(this, result, request, adaptation);
                        deferred.resolve(!result ? null : result);
                    } else if (request.type === "FragmentInfo Segment") {
                        updateSegmentsList.call(this, result, request, adaptation);
                        deferred.resolve(result);
                    } else {
                        deferred.resolve(result);
                    }
                }
            } catch (e) {
                deferred.reject(e);
            }
        } else {
            deferred.resolve(result);
        }

        return deferred.promise;
    };

    return rslt;
};

Mss.dependencies.MssFragmentController.prototype = {
    constructor: Mss.dependencies.MssFragmentController
};
/*
 * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.
 * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2014, Orange
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
Mss.dependencies.MssFragmentInfoController = function() {
    "use strict";
    var _ready = false,
        _started = false,
        _fragmentController = null,
        _fragmentModel = null,
        _type,
        _bufferController,
        _startTime = null,
        _startFragmentTime = null,
        _loadTimeout,
        
        initialize = function(type, fragmentController, bufferController) {
            
            this.debug.log("[MssFragmentInfoController][" + type + "] Initialize");

            _bufferController = bufferController;
            _type = type;

            _fragmentController = fragmentController;
            _fragmentModel = _fragmentController.attachBufferController(this);
            _fragmentModel.setType(type);
        
            _ready = true;
        },

        reset = function() {

            stop.call(this);

            if (_fragmentModel) {
                _fragmentController.abortRequestsForModel(_fragmentModel);
                _fragmentController.detachBufferController(_fragmentModel);
                _fragmentModel = null;
            }

            return Q.when(null);
        },

        start = function(delay) {
            if (!_ready || _started) {
                return;
            }

            this.debug.info("[MssFragmentInfoController][" + _type + "] START");
            _started = true;
            _startTime = new Date().getTime() + delay * 1000;

            delayLoadNextFragmentInfo.call(this, delay);
        },

        stop = function() {
            if (!_started) {
                return;
            }

            this.debug.info("[MssFragmentInfoController][" + _type + "] STOP");

            // Abort current segment download            
            _fragmentController.abortRequestsForModel(_fragmentModel);
            
            // Stop process
            clearTimeout(_loadTimeout);
            _started = false;
        },

        loadNextFragmentInfo = function() {
            if (!_started) {
                return;
            }

            var adaptation = _bufferController.getData(),
                segments = adaptation.SegmentTemplate.SegmentTimeline.S_asArray,
                segment = segments[segments.length - 1],
                representation = adaptation.Representation_asArray[0],
                request;

            this.debug.log("[MssFragmentInfoController][" + _type + "] Load next fragment for time: " + (segment.t / adaptation.SegmentTemplate.timescale));

            request = getSegmentRequest(adaptation, representation, segment);
            requestFragment.call(this, request);
        },

        getSegmentRequest = function(adaptation, representation, segment) {
            var timescale = adaptation.SegmentTemplate.timescale,
                request = new MediaPlayer.vo.SegmentRequest();

            request.action = "download";
            request.startTime = segment.t / timescale;
            request.streamType = _type;
            request.type = "FragmentInfo Segment";
            request.duration = segment.d / timescale;
            request.timescale = timescale;
            request.quality = representation.quality;
            request.url = adaptation.BaseURL + adaptation.SegmentTemplate.media;
            request.url = request.url.replace('$Bandwidth$', representation.bandwidth);
            request.url = request.url.replace('$Time$', segment.tManifest ? segment.tManifest : segment.t);
            request.url = request.url.replace('/Fragments(', '/FragmentInfo(');

            return request;
        },
        
        requestFragment = function(request) {

            if (_fragmentController.isFragmentLoadedOrPending(this, request)) {
                // We may have reached end of timeline in case of start-over streams
                this.debug.log("[MssFragmentInfoController][" + _type + "] No more fragments");
                return;
            }

            this.debug.log("[MssFragmentInfoController][" + _type + "] Request fragment info " + request.url);
            _fragmentController.prepareFragmentForLoading(this, request, onBytesLoadingStart, onBytesLoaded, onBytesError, null);
            _fragmentController.onBufferControllerStateChange();
        },

        onBytesLoadingStart = function(request) {
            this.debug.info("[MssFragmentInfoController][" + _type + "] Load request ", (request.url !== null) ? request.url : request.quality);
        },

        onBytesLoaded = function(request, response) {
            var self = this,
                representation = _bufferController.getAvailableRepresentations()[0],
                deltaTime,
                deltaTimestamp;

            this.debug.log("[MssFragmentInfoController][" + _type + "] FragmentInfo loaded ", request.url);

            if (!_startFragmentTime) {
                _startFragmentTime = request.startTime;
            }

            try {
                _fragmentController.process(response.data, request, representation).then(function(/*data*/) {
                    deltaTime = (new Date().getTime() - _startTime) / 1000;
                    deltaTimestamp = request.startTime + request.duration - _startFragmentTime;
                    delayLoadNextFragmentInfo.call(self, Math.max(0, (deltaTimestamp - deltaTime)));
                });
            } catch (e) {
                this.errHandler.sendError(MediaPlayer.dependencies.ErrorHandler.prototype.INTERNAL_ERROR, "Internal error while processing fragment info segment", e.message);
            }
        },

        onBytesError = function(e) {
            if (_started) {
                return;
            }

            this.errHandler.sendWarning(MediaPlayer.dependencies.ErrorHandler.prototype.DOWNLOAD_ERR_CONTENT,
                "Failed to download fragmentInfo segment", {
                    url: e.url,
                    status: e.status
                }
            );
        },

        delayLoadNextFragmentInfo = function(delay) {
            var self = this;

            this.debug.log("[MssFragmentInfoController][" + _type + "] Load next fragment in " + delay + " s.");

            clearTimeout(_loadTimeout);
            _loadTimeout = setTimeout(function() {
                _loadTimeout = null;
                loadNextFragmentInfo.call(self);
            }, delay * 1000);
        };

    return {
        debug: undefined,
        system: undefined,
        errHandler: undefined,

        initialize: initialize,
        reset: reset,
        start: start,
        stop: stop,

        isReady: function() {
            return _ready;
        },
    };
};

Mss.dependencies.MssFragmentInfoController.prototype = {
    constructor: Mss.dependencies.MssFragmentInfoController
};
/* $Date: 2007-06-12 18:02:31 $ */

// from: http://bannister.us/weblog/2007/06/09/simple-base64-encodedecode-javascript/
// Handles encode/decode of ASCII and Unicode strings.

var UTF8 = {};
UTF8.encode = function(s) {
    var u = [];
    for (var i = 0; i < s.length; ++i) {
        var c = s.charCodeAt(i);
        if (c < 0x80) {
            u.push(c);
        } else if (c < 0x800) {
            u.push(0xC0 | (c >> 6));
            u.push(0x80 | (63 & c));
        } else if (c < 0x10000) {
            u.push(0xE0 | (c >> 12));
            u.push(0x80 | (63 & (c >> 6)));
            u.push(0x80 | (63 & c));
        } else {
            u.push(0xF0 | (c >> 18));
            u.push(0x80 | (63 & (c >> 12)));
            u.push(0x80 | (63 & (c >> 6)));
            u.push(0x80 | (63 & c));
        }
    }
    return u;
};
UTF8.decode = function(u) {
    var a = [];
    var i = 0;
    while (i < u.length) {
        var v = u[i++];
        if (v < 0x80) {
            // no need to mask byte
        } else if (v < 0xE0) {
            v = (31 & v) << 6;
            v |= (63 & u[i++]);
        } else if (v < 0xF0) {
            v = (15 & v) << 12;
            v |= (63 & u[i++]) << 6;
            v |= (63 & u[i++]);
        } else {
            v = (7 & v) << 18;
            v |= (63 & u[i++]) << 12;
            v |= (63 & u[i++]) << 6;
            v |= (63 & u[i++]);
        }
        a.push(String.fromCharCode(v));
    }
    return a.join('');
};

var BASE64 = {};
(function(T){
    var encodeArray = function(u) {
        var i = 0;
        var a = [];
        var n = 0 | (u.length / 3);
        while (0 < n--) {
            var v = (u[i] << 16) + (u[i+1] << 8) + u[i+2];
            i += 3;
            a.push(T.charAt(63 & (v >> 18)));
            a.push(T.charAt(63 & (v >> 12)));
            a.push(T.charAt(63 & (v >> 6)));
            a.push(T.charAt(63 & v));
        }
        if (2 == (u.length - i)) {
            var v = (u[i] << 16) + (u[i+1] << 8);
            a.push(T.charAt(63 & (v >> 18)));
            a.push(T.charAt(63 & (v >> 12)));
            a.push(T.charAt(63 & (v >> 6)));
            a.push('=');
        } else if (1 == (u.length - i)) {
            var v = (u[i] << 16);
            a.push(T.charAt(63 & (v >> 18)));
            a.push(T.charAt(63 & (v >> 12)));
            a.push('==');
        }
        return a.join('');
    }
    var R = (function(){
        var a = [];
        for (var i=0; i<T.length; ++i) {
            a[T.charCodeAt(i)] = i;
        }
        a['='.charCodeAt(0)] = 0;
        return a;
    })();
    var decodeArray = function(s) {
        var i = 0;
        var u = [];
        var n = 0 | (s.length / 4);
        while (0 < n--) {
            var v = (R[s.charCodeAt(i)] << 18) + (R[s.charCodeAt(i+1)] << 12) + (R[s.charCodeAt(i+2)] << 6) + R[s.charCodeAt(i+3)];
            u.push(255 & (v >> 16));
            u.push(255 & (v >> 8));
            u.push(255 & v);
            i += 4;
        }
        if (u) {
            if ('=' == s.charAt(i-2)) {
                u.pop();
                u.pop();
            } else if ('=' == s.charAt(i-1)) {
                u.pop();
            }
        }
        return u;
    }
    var ASCII = {};
    ASCII.encode = function(s) {
        var u = [];
        for (var i = 0; i<s.length; ++i) {
            u.push(s.charCodeAt(i));
        }
        return u;
    };
    ASCII.decode = function(u) {
        for (var i = 0; i<s.length; ++i) {
            a[i] = String.fromCharCode(a[i]);
        }
        return a.join('');
    };
    BASE64.decodeArray = function(s) {
        var u = decodeArray(s);
        return new Uint8Array(u);
    };
    BASE64.encodeASCII = function(s) {
        var u = ASCII.encode(s);
        return encodeArray(u);
    };
    BASE64.decodeASCII = function(s) {
        var a = decodeArray(s);
        return ASCII.decode(a);
    };
    BASE64.encode = function(s) {
        var u = UTF8.encode(s);
        return encodeArray(u);
    };
    BASE64.decode = function(s) {
        var u = decodeArray(s);
        return UTF8.decode(u);
    };
})("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");

if (undefined === btoa) {
    var btoa = BASE64.encode;
}
if (undefined === atob) {
    var atob = BASE64.decode;
}

/**
 * @author <a href="http://www.creynders.be">Camille Reynders</a>
 */
( function ( scope ) {

    "use strict";

    /**
     * @namespace
     */
    var dijon = {
        /**
         * framework version number
         * @constant
         * @type String
         */
        VERSION:'0.5.3'
    };//dijon


    //======================================//
    // dijon.System
    //======================================//

    /**
     * @class dijon.System
     * @constructor
     */
    dijon.System = function () {
        /** @private */
        this._mappings = {};

        /** @private */
        this._outlets = {};

        /** @private */
        this._handlers = {};

        /**
         * When <code>true</code> injections are made only if an object has a property with the mapped outlet name.<br/>
         * <strong>Set to <code>false</code> at own risk</strong>, may have quite undesired side effects.
         * @example
         * system.strictInjections = true
         * var o = {};
         * system.mapSingleton( 'userModel', UserModel );
         * system.mapOutlet( 'userModel' );
         * system.injectInto( o );
         *
         * //o is unchanged
         *
         * system.strictInjections = false;
         * system.injectInto( o );
         *
         * //o now has a member 'userModel' which holds a reference to the singleton instance
         * //of UserModel
         * @type Boolean
         * @default true
         */
        this.strictInjections = true;

        /**
         * Enables the automatic mapping of outlets for mapped values, singletons and classes
         * When this is true any value, singleton or class that is mapped will automatically be mapped as a global outlet
         * using the value of <code>key</code> as outlet name
         *
         * @example
         * var o = {
         *     userModel : undefined; //inject
         * }
         * system.mapSingleton( 'userModel', UserModel );
         * system.injectInto( o ):
         * //o.userModel now holds a reference to the singleton instance of UserModel
         * @type Boolean
         * @default false
         */
        this.autoMapOutlets = false;

        /**
         * The name of the method that will be called for all instances, right after injection has occured.
         * @type String
         * @default 'setup'
         */
        this.postInjectionHook = 'setup';

    };//dijon.System

    dijon.System.prototype = {

        /**
         * @private
         * @param {Class} clazz
         */
        _createAndSetupInstance:function ( key, Clazz ) {
            var instance = new Clazz();
            this.injectInto( instance, key );
            return instance;
        },

        /**
         * @private
         * @param {String} key
         * @param {Boolean} overrideRules
         * @return {Object}
         */
        _retrieveFromCacheOrCreate:function ( key, overrideRules ) {
            if ( typeof overrideRules === 'undefined' ) {
                overrideRules = false;
            }
            var output;
            if ( this._mappings.hasOwnProperty( key ) ) {
                var config = this._mappings[ key ];
                if ( !overrideRules && config.isSingleton ) {
                    if ( config.object == null ) {
                        config.object = this._createAndSetupInstance( key, config.clazz );
                    }
                    output = config.object;
                } else {
                    if ( config.clazz ) {
                        output = this._createAndSetupInstance( key, config.clazz );
                    } else {
                        //TODO shouldn't this be null
                        output = config.object;
                    }
                }
            } else {
                throw new Error( 1000 );
            }
            return output;
        },


        /**
         * defines <code>outletName</code> as an injection point in <code>targetKey</code>for the object mapped to <code>sourceKey</code>
         * @example
         system.mapSingleton( 'userModel', TestClassA );
         var o = {
         user : undefined //inject
         }
         system.mapOutlet( 'userModel', 'o', 'user' );
         system.mapValue( 'o', o );

         var obj = system.getObject( 'o' );
         * //obj.user holds a reference to the singleton instance of UserModel
         *
         * @example
         system.mapSingleton( 'userModel', TestClassA );
         var o = {
         userModel : undefined //inject
         }
         system.mapOutlet( 'userModel', 'o' );
         system.mapValue( 'o', o );

         var obj = system.getObject( 'o' );
         * //obj.userModel holds a reference to the singleton instance of UserModel
         *
         * @example
         system.mapSingleton( 'userModel', TestClassA );
         system.mapOutlet( 'userModel' );
         var o = {
         userModel : undefined //inject
         }
         system.mapValue( 'o', o );

         var obj = system.getObject( 'o' );
         * //o.userModel holds a reference to the singleton instance of userModel
         *
         * @param {String} sourceKey the key mapped to the object that will be injected
         * @param {String} [targetKey='global'] the key the outlet is assigned to.
         * @param {String} [outletName=sourceKey] the name of the property used as an outlet.<br/>
         * @return {dijon.System}
         * @see dijon.System#unmapOutlet
         */
        mapOutlet:function ( sourceKey, targetKey, outletName ) {
            if ( typeof sourceKey === 'undefined' ) {
                throw new Error( 1010 );
            }
            targetKey = targetKey || "global";
            outletName = outletName || sourceKey;

            if ( !this._outlets.hasOwnProperty( targetKey ) ) {
                this._outlets[ targetKey ] = {};
            }
            this._outlets[ targetKey ][ outletName ] = sourceKey;

            return this;
        },

        /**
         * Retrieve (or create) the object mapped to <code>key</code>
         * @example
         * system.mapValue( 'foo', 'bar' );
         * var b = system.getObject( 'foo' ); //now contains 'bar'
         * @param {Object} key
         * @return {Object}
         */
        getObject:function ( key ) {
            if ( typeof key === 'undefined' ) {
                throw new Error( 1020 );
            }
            return this._retrieveFromCacheOrCreate( key );
        },

        /**
         * Maps <code>useValue</code> to <code>key</code>
         * @example
         * system.mapValue( 'foo', 'bar' );
         * var b = system.getObject( 'foo' ); //now contains 'bar'
         * @param {String} key
         * @param {Object} useValue
         * @return {dijon.System}
         */
        mapValue:function ( key, useValue ) {
            if ( typeof key === 'undefined' ) {
                throw new Error( 1030 );
            }
            this._mappings[ key ] = {
                clazz:null,
                object:useValue,
                isSingleton:true
            };
            if ( this.autoMapOutlets ) {
                this.mapOutlet( key );
            }
            if ( this.hasMapping( key )) {
                this.injectInto( useValue, key );
            }
            return this;
        },

        /**
         * Returns whether the key is mapped to an object
         * @example
         * system.mapValue( 'foo', 'bar' );
         * var isMapped = system.hasMapping( 'foo' );
         * @param {String} key
         * @return {Boolean}
         */
        hasMapping:function ( key ) {
            if ( typeof key === 'undefined' ) {
                throw new Error( 1040 );
            }
            return this._mappings.hasOwnProperty( key );
        },

        /**
         * Maps <code>clazz</code> as a factory to <code>key</code>
         * @example
         * var SomeClass = function(){
         * }
         * system.mapClass( 'o', SomeClass );
         *
         * var s1 = system.getObject( 'o' );
         * var s2 = system.getObject( 'o' );
         *
         * //s1 and s2 reference two different instances of SomeClass
         *
         * @param {String} key
         * @param {Function} clazz
         * @return {dijon.System}
         */
        mapClass:function ( key, clazz ) {
            if ( typeof key === 'undefined' ) {
                throw new Error( 1050 );
            }
            if ( typeof clazz === 'undefined' ) {
                throw new Error( 1051 );
            }
            this._mappings[ key ] = {
                clazz:clazz,
                object:null,
                isSingleton:false
            };
            if ( this.autoMapOutlets ) {
                this.mapOutlet( key );
            }
            return this;
        },

        /**
         * Maps <code>clazz</code> as a singleton factory to <code>key</code>
         * @example
         * var SomeClass = function(){
         * }
         * system.mapSingleton( 'o', SomeClass );
         *
         * var s1 = system.getObject( 'o' );
         * var s2 = system.getObject( 'o' );
         *
         * //s1 and s2 reference the same instance of SomeClass
         *
         * @param {String} key
         * @param {Function} clazz
         * @return {dijon.System}
         */
        mapSingleton:function ( key, clazz ) {
            if ( typeof key === 'undefined' ) {
                throw new Error( 1060 );
            }
            if ( typeof clazz === 'undefined' ) {
                throw new Error( 1061 );
            }
            this._mappings[ key ] = {
                clazz:clazz,
                object:null,
                isSingleton:true
            };
            if ( this.autoMapOutlets ) {
                this.mapOutlet( key );
            }
            return this;
        },

        /**
         * Force instantiation of the class mapped to <code>key</code>, whether it was mapped as a singleton or not.
         * When a value was mapped, the value will be returned.
         * TODO: should this last rule be changed?
         * @example
         var SomeClass = function(){
         }
         system.mapClass( 'o', SomeClass );

         var s1 = system.getObject( 'o' );
         var s2 = system.getObject( 'o' );
         * //s1 and s2 reference different instances of SomeClass
         *
         * @param {String} key
         * @return {Object}
         */
        instantiate:function ( key ) {
            if ( typeof key === 'undefined' ) {
                throw new Error( 1070 );
            }
            return this._retrieveFromCacheOrCreate( key, true );
        },

        /**
         * Perform an injection into an object's mapped outlets, satisfying all it's dependencies
         * @example
         * var UserModel = function(){
         * }
         * system.mapSingleton( 'userModel', UserModel );
         * var SomeClass = function(){
         *      user = undefined; //inject
         * }
         * system.mapSingleton( 'o', SomeClass );
         * system.mapOutlet( 'userModel', 'o', 'user' );
         *
         * var foo = {
         *      user : undefined //inject
         * }
         *
         * system.injectInto( foo, 'o' );
         *
         * //foo.user now holds a reference to the singleton instance of UserModel
         * @param {Object} instance
         * @param {String} [key] use the outlet mappings as defined for <code>key</code>, otherwise only the globally
         * mapped outlets will be used.
         * @return {dijon.System}
         */
        injectInto:function ( instance, key ) {
            if ( typeof instance === 'undefined' ) {
                throw new Error( 1080 );
            }
			if( ( typeof instance === 'object' ) ){
				var o = [];
				if ( this._outlets.hasOwnProperty( 'global' ) ) {
					o.push( this._outlets[ 'global' ] );
				}
				if ( typeof key !== 'undefined' && this._outlets.hasOwnProperty( key ) ) {
					o.push( this._outlets[ key ] );
				}
				for ( var i in o ) {
					var l = o [ i ];
					for ( var outlet in l ) {
						var source = l[ outlet ];
						//must be "in" [!]
						if ( !this.strictInjections || outlet in instance ) {
							instance[ outlet ] = this.getObject( source );
						}
					}
				}
				if ( "setup" in instance ) {
					instance.setup.call( instance );
				}
			}
            return this;
        },

        /**
         * Remove the mapping of <code>key</code> from the system
         * @param {String} key
         * @return {dijon.System}
         */
        unmap:function ( key ) {
            if ( typeof key === 'undefined' ) {
                throw new Error( 1090 );
            }
            delete this._mappings[ key ];

            return this;
        },

        /**
         * removes an injection point mapping for a given object mapped to <code>key</code>
         * @param {String} target
         * @param {String} outlet
         * @return {dijon.System}
         * @see dijon.System#addOutlet
         */
        unmapOutlet:function ( target, outlet ) {
            if ( typeof target === 'undefined' ) {
                throw new Error( 1100 );
            }
            if ( typeof outlet === 'undefined' ) {
                throw new Error( 1101 );
            }
            delete this._outlets[ target ][ outlet ];

            return this;
        },

        /**
         * maps a handler for an event/route.<br/>
         * @example
         var hasExecuted = false;
         var userView = {
         showUserProfile : function(){
         hasExecuted = true;
         }
         }
         system.mapValue( 'userView', userView );
         system.mapHandler( 'user/profile', 'userView', 'showUserProfile' );
         system.notify( 'user/profile' );
         //hasExecuted is true
         * @example
         * var userView = {
         *      showUserProfile : function(){
         *          //do stuff
         *      }
         * }
         * system.mapValue( 'userView', userView );
         * <strong>system.mapHandler( 'showUserProfile', 'userView' );</strong>
         * system.notify( 'showUserProfile' );
         *
         * //userView.showUserProfile is called
         * @example
         * var showUserProfile = function(){
         *          //do stuff
         * }
         * <strong>system.mapHandler( 'user/profile', undefined, showUserProfile );</strong>
         * system.notify( 'user/profile' );
         *
         * //showUserProfile is called
         * @example
         * var userView = {};
         * var showUserProfile = function(){
         *          //do stuff
         * }
         * system.mapValue( 'userView', userView );
         * <strong>system.mapHandler( 'user/profile', 'userView', showUserProfile );</strong>
         * system.notify( 'user/profile' );
         *
         * //showUserProfile is called within the scope of the userView object
         * @example
         * var userView = {
         *      showUserProfile : function(){
         *          //do stuff
         *      }
         * }
         * system.mapValue( 'userView', userView );
         * <strong>system.mapHandler( 'user/profile', 'userView', 'showUserProfile', true );</strong>
         * system.notify( 'user/profile' );
         * system.notify( 'user/profile' );
         * system.notify( 'user/profile' );
         *
         * //userView.showUserProfile is called exactly once [!]
         * @example
         * var userView = {
         *      showUserProfile : function( route ){
         *          //do stuff
         *      }
         * }
         * system.mapValue( 'userView', userView );
         * <strong>system.mapHandler( 'user/profile', 'userView', 'showUserProfile', false, true );</strong>
         * system.notify( 'user/profile' );
         *
         * //userView.showUserProfile is called and the route/eventName is passed to the handler
         * @param {String} eventName/route
         * @param {String} [key=undefined] If <code>key</code> is <code>undefined</code> the handler will be called without
         * scope.
         * @param {String|Function} [handler=eventName] If <code>handler</code> is <code>undefined</code> the value of
         * <code>eventName</code> will be used as the name of the member holding the reference to the to-be-called function.
         * <code>handler</code> accepts either a string, which will be used as the name of the member holding the reference
         * to the to-be-called function, or a direct function reference.
         * @param {Boolean} [oneShot=false] Defines whether the handler should be called exactly once and then automatically
         * unmapped
         * @param {Boolean} [passEvent=false] Defines whether the event object should be passed to the handler or not.
         * @return {dijon.System}
         * @see dijon.System#notify
         * @see dijon.System#unmapHandler
         */
        mapHandler:function ( eventName, key, handler, oneShot, passEvent ) {
            if ( typeof eventName === 'undefined' ) {
                throw new Error( 1110 );
            }
            key = key || 'global';
            handler = handler || eventName;

            if ( typeof oneShot === 'undefined' ) {
                oneShot = false;
            }
            if ( typeof passEvent === 'undefined' ) {
                passEvent = false;
            }
            if ( !this._handlers.hasOwnProperty( eventName ) ) {
                this._handlers[ eventName ] = {};
            }
            if ( !this._handlers[eventName].hasOwnProperty( key ) ) {
                this._handlers[eventName][key] = [];
            }
            this._handlers[ eventName ][ key ].push( {
                handler:handler,
                oneShot:oneShot,
                passEvent:passEvent
            } );

            return this;
        },

        /**
         * Unmaps the handler for a specific event/route.
         * @param {String} eventName Name of the event/route
         * @param {String} [key=undefined] If <code>key</code> is <code>undefined</code> the handler is removed from the
         * global mapping space. (If the same event is mapped globally and specifically for an object, then
         * only the globally mapped one will be removed)
         * @param {String | Function} [handler=eventName]
         * @return {dijon.System}
         * @see dijon.System#mapHandler
         */
        unmapHandler:function ( eventName, key, handler ) {
            if ( typeof eventName === 'undefined' ) {
                throw new Error( 1120 );
            }
            key = key || 'global';
            //handler = handler || eventName;

            if ( this._handlers.hasOwnProperty( eventName ) && this._handlers[ eventName ].hasOwnProperty( key ) ) {
                var handlers = this._handlers[ eventName ][ key ];
                for ( var i in handlers ) {
                    var config = handlers[ i ];
                    if ( (!handler) || (config.handler === handler) ) {
                        handlers.splice( i, 1 );
                        break;
                    }
                }
            }
            return this;
        },

        /**
         * calls all handlers mapped to <code>eventName/route</code>
         * @param {String} eventName/route
         * @return {dijon.System}
         * @see dijon.System#mapHandler
         */
        notify:function ( eventName ) {
            if ( typeof eventName === 'undefined' ) {
                throw new Error( 1130 );
            }
            var argsWithEvent = Array.prototype.slice.call( arguments );
            var argsClean = argsWithEvent.slice( 1 );
            if ( this._handlers.hasOwnProperty( eventName ) ) {
                var handlers = this._handlers[ eventName ];
                for ( var key in handlers ) {
                    var configs = handlers[ key ];
                    var instance;
                    if ( key !== 'global' ) {
                        instance = this.getObject( key );
                    }
                    var toBeDeleted = [];
                    var i, n;
                    for ( i = 0, n = configs.length ; i < n ; i++ ) {
                        var handler;
                        var config = configs[ i ];
                        if ( instance && typeof config.handler === "string" ) {
                            handler = instance[ config.handler ];
                        } else {
                            handler = config.handler;
                        }

                        //see deletion below
                        if ( config.oneShot ) {
                            toBeDeleted.unshift( i );
                        }

                        if ( config.passEvent ) {
                            handler.apply( instance, argsWithEvent );
                        } else {
                            handler.apply( instance, argsClean );
                        }
                    }

                    //items should be deleted in reverse order
                    //either use push above and decrement here
                    //or use unshift above and increment here
                    for ( i = 0, n = toBeDeleted.length ; i < n ; i++ ) {
                        configs.splice( toBeDeleted[ i ], 1 );
                    }
                }
            }

            return this;
        }

    };//dijon.System.prototype

    scope.dijon = dijon;
}( this ));



// Copyright 2009 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

goog = {};
goog.math = {};



/**
 * @fileoverview Defines a Long class for representing a 64-bit two's-complement
 * integer value, which faithfully simulates the behavior of a Java "long". This
 * implementation is derived from LongLib in GWT.
 *
 */

//goog.provide('goog.math.Long');



/**
 * Constructs a 64-bit two's-complement integer, given its low and high 32-bit
 * values as *signed* integers.  See the from* functions below for more
 * convenient ways of constructing Longs.
 *
 * The internal representation of a long is the two given signed, 32-bit values.
 * We use 32-bit pieces because these are the size of integers on which
 * Javascript performs bit-operations.  For operations like addition and
 * multiplication, we split each number into 16-bit pieces, which can easily be
 * multiplied within Javascript's floating-point representation without overflow
 * or change in sign.
 *
 * In the algorithms below, we frequently reduce the negative case to the
 * positive case by negating the input(s) and then post-processing the result.
 * Note that we must ALWAYS check specially whether those values are MIN_VALUE
 * (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
 * a positive number, it overflows back into a negative).  Not handling this
 * case would often result in infinite recursion.
 *
 * @param {number} low  The low (signed) 32 bits of the long.
 * @param {number} high  The high (signed) 32 bits of the long.
 * @constructor
 */
goog.math.Long = function(low, high) {
  /**
   * @type {number}
   * @private
   */
  this.low_ = low | 0;  // force into 32 signed bits.

  /**
   * @type {number}
   * @private
   */
  this.high_ = high | 0;  // force into 32 signed bits.
};


// NOTE: Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the
// from* methods on which they depend.


/**
 * A cache of the Long representations of small integer values.
 * @type {!Object}
 * @private
 */
goog.math.Long.IntCache_ = {};


/**
 * Returns a Long representing the given (32-bit) integer value.
 * @param {number} value The 32-bit integer in question.
 * @return {!goog.math.Long} The corresponding Long value.
 */
goog.math.Long.fromInt = function(value) {
  if (-128 <= value && value < 128) {
    var cachedObj = goog.math.Long.IntCache_[value];
    if (cachedObj) {
      return cachedObj;
    }
  }

  var obj = new goog.math.Long(value | 0, value < 0 ? -1 : 0);
  if (-128 <= value && value < 128) {
    goog.math.Long.IntCache_[value] = obj;
  }
  return obj;
};


/**
 * Returns a Long representing the given value, provided that it is a finite
 * number.  Otherwise, zero is returned.
 * @param {number} value The number in question.
 * @return {!goog.math.Long} The corresponding Long value.
 */
goog.math.Long.fromNumber = function(value) {
  if (isNaN(value) || !isFinite(value)) {
    return goog.math.Long.ZERO;
  } else if (value <= -goog.math.Long.TWO_PWR_63_DBL_) {
    return goog.math.Long.MIN_VALUE;
  } else if (value + 1 >= goog.math.Long.TWO_PWR_63_DBL_) {
    return goog.math.Long.MAX_VALUE;
  } else if (value < 0) {
    return goog.math.Long.fromNumber(-value).negate();
  } else {
    return new goog.math.Long(
        (value % goog.math.Long.TWO_PWR_32_DBL_) | 0,
        (value / goog.math.Long.TWO_PWR_32_DBL_) | 0);
  }
};


/**
 * Returns a Long representing the 64-bit integer that comes by concatenating
 * the given high and low bits.  Each is assumed to use 32 bits.
 * @param {number} lowBits The low 32-bits.
 * @param {number} highBits The high 32-bits.
 * @return {!goog.math.Long} The corresponding Long value.
 */
goog.math.Long.fromBits = function(lowBits, highBits) {
  return new goog.math.Long(lowBits, highBits);
};


/**
 * Returns a Long representation of the given string, written using the given
 * radix.
 * @param {string} str The textual representation of the Long.
 * @param {number=} opt_radix The radix in which the text is written.
 * @return {!goog.math.Long} The corresponding Long value.
 */
goog.math.Long.fromString = function(str, opt_radix) {
  if (str.length == 0) {
    throw Error('number format error: empty string');
  }

  var radix = opt_radix || 10;
  if (radix < 2 || 36 < radix) {
    throw Error('radix out of range: ' + radix);
  }

  if (str.charAt(0) == '-') {
    return goog.math.Long.fromString(str.substring(1), radix).negate();
  } else if (str.indexOf('-') >= 0) {
    throw Error('number format error: interior "-" character: ' + str);
  }

  // Do several (8) digits each time through the loop, so as to
  // minimize the calls to the very expensive emulated div.
  var radixToPower = goog.math.Long.fromNumber(Math.pow(radix, 8));

  var result = goog.math.Long.ZERO;
  for (var i = 0; i < str.length; i += 8) {
    var size = Math.min(8, str.length - i);
    var value = parseInt(str.substring(i, i + size), radix);
    if (size < 8) {
      var power = goog.math.Long.fromNumber(Math.pow(radix, size));
      result = result.multiply(power).add(goog.math.Long.fromNumber(value));
    } else {
      result = result.multiply(radixToPower);
      result = result.add(goog.math.Long.fromNumber(value));
    }
  }
  return result;
};


// NOTE: the compiler should inline these constant values below and then remove
// these variables, so there should be no runtime penalty for these.


/**
 * Number used repeated below in calculations.  This must appear before the
 * first call to any from* function below.
 * @type {number}
 * @private
 */
goog.math.Long.TWO_PWR_16_DBL_ = 1 << 16;


/**
 * @type {number}
 * @private
 */
goog.math.Long.TWO_PWR_24_DBL_ = 1 << 24;


/**
 * @type {number}
 * @private
 */
goog.math.Long.TWO_PWR_32_DBL_ =
    goog.math.Long.TWO_PWR_16_DBL_ * goog.math.Long.TWO_PWR_16_DBL_;


/**
 * @type {number}
 * @private
 */
goog.math.Long.TWO_PWR_31_DBL_ =
    goog.math.Long.TWO_PWR_32_DBL_ / 2;


/**
 * @type {number}
 * @private
 */
goog.math.Long.TWO_PWR_48_DBL_ =
    goog.math.Long.TWO_PWR_32_DBL_ * goog.math.Long.TWO_PWR_16_DBL_;


/**
 * @type {number}
 * @private
 */
goog.math.Long.TWO_PWR_64_DBL_ =
    goog.math.Long.TWO_PWR_32_DBL_ * goog.math.Long.TWO_PWR_32_DBL_;


/**
 * @type {number}
 * @private
 */
goog.math.Long.TWO_PWR_63_DBL_ =
    goog.math.Long.TWO_PWR_64_DBL_ / 2;


/** @type {!goog.math.Long} */
goog.math.Long.ZERO = goog.math.Long.fromInt(0);


/** @type {!goog.math.Long} */
goog.math.Long.ONE = goog.math.Long.fromInt(1);


/** @type {!goog.math.Long} */
goog.math.Long.NEG_ONE = goog.math.Long.fromInt(-1);


/** @type {!goog.math.Long} */
goog.math.Long.MAX_VALUE =
    goog.math.Long.fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0);


/** @type {!goog.math.Long} */
goog.math.Long.MIN_VALUE = goog.math.Long.fromBits(0, 0x80000000 | 0);


/**
 * @type {!goog.math.Long}
 * @private
 */
goog.math.Long.TWO_PWR_24_ = goog.math.Long.fromInt(1 << 24);


/** @return {number} The value, assuming it is a 32-bit integer. */
goog.math.Long.prototype.toInt = function() {
  return this.low_;
};


/** @return {number} The closest floating-point representation to this value. */
goog.math.Long.prototype.toNumber = function() {
  return this.high_ * goog.math.Long.TWO_PWR_32_DBL_ +
         this.getLowBitsUnsigned();
};


/**
 * @param {number=} opt_radix The radix in which the text should be written.
 * @return {string} The textual representation of this value.
 * @override
 */
goog.math.Long.prototype.toString = function(opt_radix) {
  var radix = opt_radix || 10;
  if (radix < 2 || 36 < radix) {
    throw Error('radix out of range: ' + radix);
  }

  if (this.isZero()) {
    return '0';
  }

  if (this.isNegative()) {
    if (this.equals(goog.math.Long.MIN_VALUE)) {
      // We need to change the Long value before it can be negated, so we remove
      // the bottom-most digit in this base and then recurse to do the rest.
      var radixLong = goog.math.Long.fromNumber(radix);
      var div = this.div(radixLong);
      var rem = div.multiply(radixLong).subtract(this);
      return div.toString(radix) + rem.toInt().toString(radix);
    } else {
      return '-' + this.negate().toString(radix);
    }
  }

  // Do several (6) digits each time through the loop, so as to
  // minimize the calls to the very expensive emulated div.
  var radixToPower = goog.math.Long.fromNumber(Math.pow(radix, 6));

  var rem = this;
  var result = '';
  while (true) {
    var remDiv = rem.div(radixToPower);
    var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();
    var digits = intval.toString(radix);

    rem = remDiv;
    if (rem.isZero()) {
      return digits + result;
    } else {
      while (digits.length < 6) {
        digits = '0' + digits;
      }
      result = '' + digits + result;
    }
  }
};


/** @return {number} The high 32-bits as a signed value. */
goog.math.Long.prototype.getHighBits = function() {
  return this.high_;
};


/** @return {number} The low 32-bits as a signed value. */
goog.math.Long.prototype.getLowBits = function() {
  return this.low_;
};


/** @return {number} The low 32-bits as an unsigned value. */
goog.math.Long.prototype.getLowBitsUnsigned = function() {
  return (this.low_ >= 0) ?
      this.low_ : goog.math.Long.TWO_PWR_32_DBL_ + this.low_;
};


/**
 * @return {number} Returns the number of bits needed to represent the absolute
 *     value of this Long.
 */
goog.math.Long.prototype.getNumBitsAbs = function() {
  if (this.isNegative()) {
    if (this.equals(goog.math.Long.MIN_VALUE)) {
      return 64;
    } else {
      return this.negate().getNumBitsAbs();
    }
  } else {
    var val = this.high_ != 0 ? this.high_ : this.low_;
    for (var bit = 31; bit > 0; bit--) {
      if ((val & (1 << bit)) != 0) {
        break;
      }
    }
    return this.high_ != 0 ? bit + 33 : bit + 1;
  }
};


/** @return {boolean} Whether this value is zero. */
goog.math.Long.prototype.isZero = function() {
  return this.high_ == 0 && this.low_ == 0;
};


/** @return {boolean} Whether this value is negative. */
goog.math.Long.prototype.isNegative = function() {
  return this.high_ < 0;
};


/** @return {boolean} Whether this value is odd. */
goog.math.Long.prototype.isOdd = function() {
  return (this.low_ & 1) == 1;
};


/**
 * @param {goog.math.Long} other Long to compare against.
 * @return {boolean} Whether this Long equals the other.
 */
goog.math.Long.prototype.equals = function(other) {
  return (this.high_ == other.high_) && (this.low_ == other.low_);
};


/**
 * @param {goog.math.Long} other Long to compare against.
 * @return {boolean} Whether this Long does not equal the other.
 */
goog.math.Long.prototype.notEquals = function(other) {
  return (this.high_ != other.high_) || (this.low_ != other.low_);
};


/**
 * @param {goog.math.Long} other Long to compare against.
 * @return {boolean} Whether this Long is less than the other.
 */
goog.math.Long.prototype.lessThan = function(other) {
  return this.compare(other) < 0;
};


/**
 * @param {goog.math.Long} other Long to compare against.
 * @return {boolean} Whether this Long is less than or equal to the other.
 */
goog.math.Long.prototype.lessThanOrEqual = function(other) {
  return this.compare(other) <= 0;
};


/**
 * @param {goog.math.Long} other Long to compare against.
 * @return {boolean} Whether this Long is greater than the other.
 */
goog.math.Long.prototype.greaterThan = function(other) {
  return this.compare(other) > 0;
};


/**
 * @param {goog.math.Long} other Long to compare against.
 * @return {boolean} Whether this Long is greater than or equal to the other.
 */
goog.math.Long.prototype.greaterThanOrEqual = function(other) {
  return this.compare(other) >= 0;
};


/**
 * Compares this Long with the given one.
 * @param {goog.math.Long} other Long to compare against.
 * @return {number} 0 if they are the same, 1 if the this is greater, and -1
 *     if the given one is greater.
 */
goog.math.Long.prototype.compare = function(other) {
  if (this.equals(other)) {
    return 0;
  }

  var thisNeg = this.isNegative();
  var otherNeg = other.isNegative();
  if (thisNeg && !otherNeg) {
    return -1;
  }
  if (!thisNeg && otherNeg) {
    return 1;
  }

  // at this point, the signs are the same, so subtraction will not overflow
  if (this.subtract(other).isNegative()) {
    return -1;
  } else {
    return 1;
  }
};


/** @return {!goog.math.Long} The negation of this value. */
goog.math.Long.prototype.negate = function() {
  if (this.equals(goog.math.Long.MIN_VALUE)) {
    return goog.math.Long.MIN_VALUE;
  } else {
    return this.not().add(goog.math.Long.ONE);
  }
};


/**
 * Returns the sum of this and the given Long.
 * @param {goog.math.Long} other Long to add to this one.
 * @return {!goog.math.Long} The sum of this and the given Long.
 */
goog.math.Long.prototype.add = function(other) {
  // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

  var a48 = this.high_ >>> 16;
  var a32 = this.high_ & 0xFFFF;
  var a16 = this.low_ >>> 16;
  var a00 = this.low_ & 0xFFFF;

  var b48 = other.high_ >>> 16;
  var b32 = other.high_ & 0xFFFF;
  var b16 = other.low_ >>> 16;
  var b00 = other.low_ & 0xFFFF;

  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
  c00 += a00 + b00;
  c16 += c00 >>> 16;
  c00 &= 0xFFFF;
  c16 += a16 + b16;
  c32 += c16 >>> 16;
  c16 &= 0xFFFF;
  c32 += a32 + b32;
  c48 += c32 >>> 16;
  c32 &= 0xFFFF;
  c48 += a48 + b48;
  c48 &= 0xFFFF;
  return goog.math.Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);
};


/**
 * Returns the difference of this and the given Long.
 * @param {goog.math.Long} other Long to subtract from this.
 * @return {!goog.math.Long} The difference of this and the given Long.
 */
goog.math.Long.prototype.subtract = function(other) {
  return this.add(other.negate());
};


/**
 * Returns the product of this and the given long.
 * @param {goog.math.Long} other Long to multiply with this.
 * @return {!goog.math.Long} The product of this and the other.
 */
goog.math.Long.prototype.multiply = function(other) {
  if (this.isZero()) {
    return goog.math.Long.ZERO;
  } else if (other.isZero()) {
    return goog.math.Long.ZERO;
  }

  if (this.equals(goog.math.Long.MIN_VALUE)) {
    return other.isOdd() ? goog.math.Long.MIN_VALUE : goog.math.Long.ZERO;
  } else if (other.equals(goog.math.Long.MIN_VALUE)) {
    return this.isOdd() ? goog.math.Long.MIN_VALUE : goog.math.Long.ZERO;
  }

  if (this.isNegative()) {
    if (other.isNegative()) {
      return this.negate().multiply(other.negate());
    } else {
      return this.negate().multiply(other).negate();
    }
  } else if (other.isNegative()) {
    return this.multiply(other.negate()).negate();
  }

  // If both longs are small, use float multiplication
  if (this.lessThan(goog.math.Long.TWO_PWR_24_) &&
      other.lessThan(goog.math.Long.TWO_PWR_24_)) {
    return goog.math.Long.fromNumber(this.toNumber() * other.toNumber());
  }

  // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
  // We can skip products that would overflow.

  var a48 = this.high_ >>> 16;
  var a32 = this.high_ & 0xFFFF;
  var a16 = this.low_ >>> 16;
  var a00 = this.low_ & 0xFFFF;

  var b48 = other.high_ >>> 16;
  var b32 = other.high_ & 0xFFFF;
  var b16 = other.low_ >>> 16;
  var b00 = other.low_ & 0xFFFF;

  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
  c00 += a00 * b00;
  c16 += c00 >>> 16;
  c00 &= 0xFFFF;
  c16 += a16 * b00;
  c32 += c16 >>> 16;
  c16 &= 0xFFFF;
  c16 += a00 * b16;
  c32 += c16 >>> 16;
  c16 &= 0xFFFF;
  c32 += a32 * b00;
  c48 += c32 >>> 16;
  c32 &= 0xFFFF;
  c32 += a16 * b16;
  c48 += c32 >>> 16;
  c32 &= 0xFFFF;
  c32 += a00 * b32;
  c48 += c32 >>> 16;
  c32 &= 0xFFFF;
  c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
  c48 &= 0xFFFF;
  return goog.math.Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);
};


/**
 * Returns this Long divided by the given one.
 * @param {goog.math.Long} other Long by which to divide.
 * @return {!goog.math.Long} This Long divided by the given one.
 */
goog.math.Long.prototype.div = function(other) {
  if (other.isZero()) {
    throw Error('division by zero');
  } else if (this.isZero()) {
    return goog.math.Long.ZERO;
  }

  if (this.equals(goog.math.Long.MIN_VALUE)) {
    if (other.equals(goog.math.Long.ONE) ||
        other.equals(goog.math.Long.NEG_ONE)) {
      return goog.math.Long.MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
    } else if (other.equals(goog.math.Long.MIN_VALUE)) {
      return goog.math.Long.ONE;
    } else {
      // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
      var halfThis = this.shiftRight(1);
      var approx = halfThis.div(other).shiftLeft(1);
      if (approx.equals(goog.math.Long.ZERO)) {
        return other.isNegative() ? goog.math.Long.ONE : goog.math.Long.NEG_ONE;
      } else {
        var rem = this.subtract(other.multiply(approx));
        var result = approx.add(rem.div(other));
        return result;
      }
    }
  } else if (other.equals(goog.math.Long.MIN_VALUE)) {
    return goog.math.Long.ZERO;
  }

  if (this.isNegative()) {
    if (other.isNegative()) {
      return this.negate().div(other.negate());
    } else {
      return this.negate().div(other).negate();
    }
  } else if (other.isNegative()) {
    return this.div(other.negate()).negate();
  }

  // Repeat the following until the remainder is less than other:  find a
  // floating-point that approximates remainder / other *from below*, add this
  // into the result, and subtract it from the remainder.  It is critical that
  // the approximate value is less than or equal to the real value so that the
  // remainder never becomes negative.
  var res = goog.math.Long.ZERO;
  var rem = this;
  while (rem.greaterThanOrEqual(other)) {
    // Approximate the result of division. This may be a little greater or
    // smaller than the actual value.
    var approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));

    // We will tweak the approximate result by changing it in the 48-th digit or
    // the smallest non-fractional digit, whichever is larger.
    var log2 = Math.ceil(Math.log(approx) / Math.LN2);
    var delta = (log2 <= 48) ? 1 : Math.pow(2, log2 - 48);

    // Decrease the approximation until it is smaller than the remainder.  Note
    // that if it is too large, the product overflows and is negative.
    var approxRes = goog.math.Long.fromNumber(approx);
    var approxRem = approxRes.multiply(other);
    while (approxRem.isNegative() || approxRem.greaterThan(rem)) {
      approx -= delta;
      approxRes = goog.math.Long.fromNumber(approx);
      approxRem = approxRes.multiply(other);
    }

    // We know the answer can't be zero... and actually, zero would cause
    // infinite recursion since we would make no progress.
    if (approxRes.isZero()) {
      approxRes = goog.math.Long.ONE;
    }

    res = res.add(approxRes);
    rem = rem.subtract(approxRem);
  }
  return res;
};


/**
 * Returns this Long modulo the given one.
 * @param {goog.math.Long} other Long by which to mod.
 * @return {!goog.math.Long} This Long modulo the given one.
 */
goog.math.Long.prototype.modulo = function(other) {
  return this.subtract(this.div(other).multiply(other));
};


/** @return {!goog.math.Long} The bitwise-NOT of this value. */
goog.math.Long.prototype.not = function() {
  return goog.math.Long.fromBits(~this.low_, ~this.high_);
};


/**
 * Returns the bitwise-AND of this Long and the given one.
 * @param {goog.math.Long} other The Long with which to AND.
 * @return {!goog.math.Long} The bitwise-AND of this and the other.
 */
goog.math.Long.prototype.and = function(other) {
  return goog.math.Long.fromBits(this.low_ & other.low_,
                                 this.high_ & other.high_);
};


/**
 * Returns the bitwise-OR of this Long and the given one.
 * @param {goog.math.Long} other The Long with which to OR.
 * @return {!goog.math.Long} The bitwise-OR of this and the other.
 */
goog.math.Long.prototype.or = function(other) {
  return goog.math.Long.fromBits(this.low_ | other.low_,
                                 this.high_ | other.high_);
};


/**
 * Returns the bitwise-XOR of this Long and the given one.
 * @param {goog.math.Long} other The Long with which to XOR.
 * @return {!goog.math.Long} The bitwise-XOR of this and the other.
 */
goog.math.Long.prototype.xor = function(other) {
  return goog.math.Long.fromBits(this.low_ ^ other.low_,
                                 this.high_ ^ other.high_);
};


/**
 * Returns this Long with bits shifted to the left by the given amount.
 * @param {number} numBits The number of bits by which to shift.
 * @return {!goog.math.Long} This shifted to the left by the given amount.
 */
goog.math.Long.prototype.shiftLeft = function(numBits) {
  numBits &= 63;
  if (numBits == 0) {
    return this;
  } else {
    var low = this.low_;
    if (numBits < 32) {
      var high = this.high_;
      return goog.math.Long.fromBits(
          low << numBits,
          (high << numBits) | (low >>> (32 - numBits)));
    } else {
      return goog.math.Long.fromBits(0, low << (numBits - 32));
    }
  }
};


/**
 * Returns this Long with bits shifted to the right by the given amount.
 * @param {number} numBits The number of bits by which to shift.
 * @return {!goog.math.Long} This shifted to the right by the given amount.
 */
goog.math.Long.prototype.shiftRight = function(numBits) {
  numBits &= 63;
  if (numBits == 0) {
    return this;
  } else {
    var high = this.high_;
    if (numBits < 32) {
      var low = this.low_;
      return goog.math.Long.fromBits(
          (low >>> numBits) | (high << (32 - numBits)),
          high >> numBits);
    } else {
      return goog.math.Long.fromBits(
          high >> (numBits - 32),
          high >= 0 ? 0 : -1);
    }
  }
};


/**
 * Returns this Long with bits shifted to the right by the given amount, with
 * the new top bits matching the current sign bit.
 * @param {number} numBits The number of bits by which to shift.
 * @return {!goog.math.Long} This shifted to the right by the given amount, with
 *     zeros placed into the new leading bits.
 */
goog.math.Long.prototype.shiftRightUnsigned = function(numBits) {
  numBits &= 63;
  if (numBits == 0) {
    return this;
  } else {
    var high = this.high_;
    if (numBits < 32) {
      var low = this.low_;
      return goog.math.Long.fromBits(
          (low >>> numBits) | (high << (32 - numBits)),
          high >>> numBits);
    } else if (numBits == 32) {
      return goog.math.Long.fromBits(high, 0);
    } else {
      return goog.math.Long.fromBits(high >>> (numBits - 32), 0);
    }
  }
};

/*
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * author Digital Primates
 * copyright dash-if 2012
 */ 
 if(typeof(utils) == "undefined"){
 	var utils = {};
 }
 
 if(typeof(utils.Math) == "undefined"){
 	utils.Math = {};
 }
 
 utils.Math.to64BitNumber = function(low, high) {
	var highNum, lowNum, expected;

	highNum = new goog.math.Long(0, high);
	lowNum = new goog.math.Long(low, 0);
	expected = highNum.add(lowNum);

	return expected.toNumber();
}
/*
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * author Digital Primates
 * copyright dash-if 2012
 */

/*
 * var parent,
 *     child,
 *     properties = [
                    {
                        name: 'profiles',
                        merge: false
                    }
                ];
 *
 * parent = {};
 * parent.name = "ParentNode";
 * parent.isRoor = false;
 * parent.isArray = false;
 * parent.parent = null;
 * parent.children = [];
 * parent.properties = properties;
 *
 * child = {};
 * child.name = "ChildNode";
 * child.isRoor = false;
 * child.isArray = true;
 * child.parent = parent;
 * child.children = null;
 * child.properties = properties;
 * parent.children.push(child);
 *
 */

function ObjectIron(map) {

    var lookup;

    // create a list of top level items to search for
    lookup = [];
    for (i = 0, len = map.length; i < len; i += 1) {
        if (map[i].isRoot) {
            lookup.push("root");
        } else {
            lookup.push(map[i].name);
        }
    }

    var mergeValues = function (parentItem, childItem) {
            var name,
                parentValue,
                childValue;

            if (parentItem === null || childItem === null) {
                return;
            }

            for (name in parentItem) {
                if (parentItem.hasOwnProperty(name)) {
                    if (!childItem.hasOwnProperty(name)) {
                        childItem[name] = parentItem[name];
                    }
                }
            }
        },

        mapProperties = function (properties, parent, child) {
            var i,
                len,
                property,
                parentValue,
                childValue;

            if (properties === null || properties.length === 0) {
                return;
            }

            for (i = 0, len = properties.length; i < len; i += 1) {
                property = properties[i];

                if (parent.hasOwnProperty(property.name)) {
                    if (child.hasOwnProperty(property.name)) {
                        // check to see if we should merge
                        if (property.merge) {
                           parentValue = parent[property.name];
                           childValue = child[property.name];

                            // complex objects; merge properties
                            if (typeof parentValue === 'object' && typeof childValue === 'object') {
                                mergeValues(parentValue, childValue);
                            }
                            // simple objects; merge them together
                            else {
                                if (property.mergeFunction != null) {
                                    child[property.name] = property.mergeFunction(parentValue, childValue);
                                } else {
                                    child[property.name] = parentValue + childValue;
                                }
                            }
                        }
                    } else {
                        // just add the property
                        child[property.name] = parent[property.name];
                    }
                }
            }
        },

        mapItem = function (obj, node) {
            var item = obj,
                i,
                len,
                v,
                len2,
                array,
                childItem,
                childNode,
                property;

            if (item.children === null || item.children.length === 0) {
                return;
            }

            for (i = 0, len = item.children.length; i < len; i += 1) {
                childItem = item.children[i];

                if (node.hasOwnProperty(childItem.name)) {
                    if (childItem.isArray) {
                        array = node[childItem.name + "_asArray"];
                        for (v = 0, len2 = array.length; v < len2; v += 1) {
                            childNode = array[v];
                            mapProperties(item.properties, node, childNode);
                            mapItem(childItem, childNode);
                        }
                    } else {
                        childNode = node[childItem.name];
                        mapProperties(item.properties, node, childNode);
                        mapItem(childItem, childNode);
                    }
                }
            }
        },

        performMapping = function (source) {
            var i,
                len,
                pi,
                pp,
                item,
                node,
                array;

            if (source === null) {
                return source;
            }

            if (typeof source !== 'object') {
                return source;
            }

            // first look to see if anything cares about the root node
            for (i = 0, len = lookup.length; i < len; i += 1) {
                if (lookup[i] === "root") {
                    item = map[i];
                    node = source;
                    mapItem(item, node);
                }
            }

            // iterate over the objects and look for any of the items we care about
            for (pp in source) {
                if (source.hasOwnProperty(pp)) {
                    pi = lookup.indexOf(pp);
                    if (pi !== -1) {
                        item = map[pi];

                        if (item.isArray) {
                            array = source[pp + "_asArray"];
                            for (i = 0, len = array.length; i < len; i += 1) {
                                node = array[i];
                                mapItem(item, node);
                            }
                        } else {
                            node = source[pp];
                            mapItem(item, node);
                        }
                    }
                    // now check this to see if he has any of the properties we care about
                    performMapping(source[pp]);
                }
            }

            return source;
        };

    return {
        run: performMapping
    };
}
// vim:ts=4:sts=4:sw=4:
/*!
 *
 * Copyright 2009-2012 Kris Kowal under the terms of the MIT
 * license found at http://github.com/kriskowal/q/raw/master/LICENSE
 *
 * With parts by Tyler Close
 * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
 * at http://www.opensource.org/licenses/mit-license.html
 * Forked at ref_send.js version: 2009-05-11
 *
 * With parts by Mark Miller
 * Copyright (C) 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

(function (definition) {
    // Turn off strict mode for this function so we can assign to global.Q
    /*jshint strict: false*/
    Q = definition();
})(function () {
"use strict";

// All code after this point will be filtered from stack traces reported
// by Q.
var qStartingLine = captureLine();
var qFileName;

// shims

// used for fallback in "allResolved"
var noop = function () {};

// use the fastest possible means to execute a task in a future turn
// of the event loop.
var nextTick;
if (typeof process !== "undefined") {
    // node
    nextTick = process.nextTick;
} else if (typeof setImmediate === "function") {
    // In IE10, or use https://github.com/NobleJS/setImmediate
    if (typeof window !== "undefined") {
        nextTick = setImmediate.bind(window);
    } else {
        nextTick = setImmediate;
    }
} else {
    (function () {
        // linked list of tasks (single, with head node)
        var head = {task: void 0, next: null}, tail = head,
            maxPendingTicks = 2, pendingTicks = 0, queuedTasks = 0, usedTicks = 0,
            requestTick;

        function onTick() {
            // In case of multiple tasks ensure at least one subsequent tick
            // to handle remaining tasks in case one throws.
            --pendingTicks;

            if (++usedTicks >= maxPendingTicks) {
                // Amortize latency after thrown exceptions.
                usedTicks = 0;
                maxPendingTicks *= 4; // fast grow!
                var expectedTicks = queuedTasks && Math.min(queuedTasks - 1, maxPendingTicks);
                while (pendingTicks < expectedTicks) {
                    ++pendingTicks;
                    requestTick();
                }
            }

            while (queuedTasks) {
                --queuedTasks; // decrement here to ensure it's never negative
                head = head.next;
                var task = head.task;
                head.task = void 0;
                task();
            }

            usedTicks = 0;
        }

        nextTick = function (task) {
            tail = tail.next = {task: task, next: null};
            if (pendingTicks < ++queuedTasks && pendingTicks < maxPendingTicks) {
                ++pendingTicks;
                requestTick();
            }
        };

        if (typeof MessageChannel !== "undefined") {
            // modern browsers
            // http://www.nonblocking.io/2011/06/windownexttick.html
            var channel = new MessageChannel();
            channel.port1.onmessage = onTick;
            requestTick = function () {
                channel.port2.postMessage(0);
            };

        } else {
            // old browsers
            requestTick = function () {
                setTimeout(onTick, 0);
            };
        }
    })();
}

// Attempt to make generics safe in the face of downstream
// modifications.
// There is no situation where this is necessary.
// If you need a security guarantee, these primordials need to be
// deeply frozen anyway, and if you don’t need a security guarantee,
// this is just plain paranoid.
// However, this does have the nice side-effect of reducing the size
// of the code by reducing x.call() to merely x(), eliminating many
// hard-to-minify characters.
// See Mark Miller’s explanation of what this does.
// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
function uncurryThis(f) {
    var call = Function.call;
    return function () {
        return call.apply(f, arguments);
    };
}
// This is equivalent, but slower:
// uncurryThis = Function_bind.bind(Function_bind.call);
// http://jsperf.com/uncurrythis

var array_slice = uncurryThis(Array.prototype.slice);

var array_reduce = uncurryThis(
    Array.prototype.reduce || function (callback, basis) {
        var index = 0,
            length = this.length;
        // concerning the initial value, if one is not provided
        if (arguments.length === 1) {
            // seek to the first value in the array, accounting
            // for the possibility that is is a sparse array
            do {
                if (index in this) {
                    basis = this[index++];
                    break;
                }
                if (++index >= length) {
                    throw new TypeError();
                }
            } while (1);
        }
        // reduce
        for (; index < length; index++) {
            // account for the possibility that the array is sparse
            if (index in this) {
                basis = callback(basis, this[index], index);
            }
        }
        return basis;
    }
);

var array_indexOf = uncurryThis(
    Array.prototype.indexOf || function (value) {
        // not a very good shim, but good enough for our one use of it
        for (var i = 0; i < this.length; i++) {
            if (this[i] === value) {
                return i;
            }
        }
        return -1;
    }
);

var array_map = uncurryThis(
    Array.prototype.map || function (callback, thisp) {
        var self = this;
        var collect = [];
        array_reduce(self, function (undefined, value, index) {
            collect.push(callback.call(thisp, value, index, self));
        }, void 0);
        return collect;
    }
);

var object_create = Object.create || function (prototype) {
    function Type() { }
    Type.prototype = prototype;
    return new Type();
};

var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);

var object_keys = Object.keys || function (object) {
    var keys = [];
    for (var key in object) {
        if (object_hasOwnProperty(object, key)) {
            keys.push(key);
        }
    }
    return keys;
};

var object_toString = uncurryThis(Object.prototype.toString);

// generator related shims

function isStopIteration(exception) {
    return (
        object_toString(exception) === "[object StopIteration]" ||
        exception instanceof QReturnValue
    );
}

var QReturnValue;
if (typeof ReturnValue !== "undefined") {
    QReturnValue = ReturnValue;
} else {
    QReturnValue = function (value) {
        this.value = value;
    };
}

// long stack traces

Q.longStackJumpLimit = 1;

var STACK_JUMP_SEPARATOR = "From previous event:";

function makeStackTraceLong(error, promise) {
    // If possible (that is, if in V8), transform the error stack
    // trace by removing Node and Q cruft, then concatenating with
    // the stack trace of the promise we are ``done``ing. See #57.
    if (promise.stack &&
        typeof error === "object" &&
        error !== null &&
        error.stack &&
        error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1
    ) {
        error.stack = filterStackString(error.stack) +
            "\n" + STACK_JUMP_SEPARATOR + "\n" +
            filterStackString(promise.stack);
    }
}

function filterStackString(stackString) {
    var lines = stackString.split("\n");
    var desiredLines = [];
    for (var i = 0; i < lines.length; ++i) {
        var line = lines[i];

        if (!isInternalFrame(line) && !isNodeFrame(line)) {
            desiredLines.push(line);
        }
    }
    return desiredLines.join("\n");
}

function isNodeFrame(stackLine) {
    return stackLine.indexOf("(module.js:") !== -1 ||
           stackLine.indexOf("(node.js:") !== -1;
}

function isInternalFrame(stackLine) {
    var pieces = /at .+ \((.*):(\d+):\d+\)/.exec(stackLine);

    if (!pieces) {
        return false;
    }

    var fileName = pieces[1];
    var lineNumber = pieces[2];

    return fileName === qFileName &&
        lineNumber >= qStartingLine &&
        lineNumber <= qEndingLine;
}

// discover own file name and line number range for filtering stack
// traces
function captureLine() {
    if (Error.captureStackTrace) {
        var fileName, lineNumber;

        var oldPrepareStackTrace = Error.prepareStackTrace;

        Error.prepareStackTrace = function (error, frames) {
            fileName = frames[1].getFileName();
            lineNumber = frames[1].getLineNumber();
        };

        // teases call of temporary prepareStackTrace
        // JSHint and Closure Compiler generate known warnings here
        /*jshint expr: true */
        new Error().stack;

        Error.prepareStackTrace = oldPrepareStackTrace;
        qFileName = fileName;
        return lineNumber;
    }
}

function deprecate(callback, name, alternative) {
    return function () {
        if (typeof console !== "undefined" && typeof console.warn === "function") {
            console.warn(name + " is deprecated, use " + alternative + " instead.", new Error("").stack);
        }
        return callback.apply(callback, arguments);
    };
}

// end of shims
// beginning of real work

/**
 * Creates fulfilled promises from non-promises,
 * Passes Q promises through,
 * Coerces CommonJS/Promises/A+ promises to Q promises.
 */
function Q(value) {
    return resolve(value);
}

/**
 * Performs a task in a future turn of the event loop.
 * @param {Function} task
 */
Q.nextTick = nextTick;

/**
 * Constructs a {promise, resolve} object.
 *
 * The resolver is a callback to invoke with a more resolved value for the
 * promise. To fulfill the promise, invoke the resolver with any value that is
 * not a function. To reject the promise, invoke the resolver with a rejection
 * object. To put the promise in the same state as another promise, invoke the
 * resolver with that other promise.
 */
Q.defer = defer;
function defer() {
    // if "pending" is an "Array", that indicates that the promise has not yet
    // been resolved.  If it is "undefined", it has been resolved.  Each
    // element of the pending array is itself an array of complete arguments to
    // forward to the resolved promise.  We coerce the resolution value to a
    // promise using the ref promise because it handles both fully
    // resolved values and other promises gracefully.
    var pending = [], progressListeners = [], value;

    var deferred = object_create(defer.prototype);
    var promise = object_create(makePromise.prototype);

    promise.promiseDispatch = function (resolve, op, operands) {
        var args = array_slice(arguments);
        if (pending) {
            pending.push(args);
            if (op === "when" && operands[1]) { // progress operand
                progressListeners.push(operands[1]);
            }
        } else {
            nextTick(function () {
                value.promiseDispatch.apply(value, args);
            });
        }
    };

    promise.valueOf = function () {
        if (pending) {
            return promise;
        }
        value = valueOf(value); // shorten chain
        return value;
    };

    if (Error.captureStackTrace && Q.longStackJumpLimit > 0) {
        Error.captureStackTrace(promise, defer);

        // Reify the stack into a string by using the accessor; this prevents
        // memory leaks as per GH-111. At the same time, cut off the first line;
        // it's always just "[object Promise]\n", as per the `toString`.
        promise.stack = promise.stack.substring(promise.stack.indexOf("\n") + 1);
    }

    function become(resolvedValue) {
        if (!pending) {
            return;
        }
        value = resolve(resolvedValue);
        array_reduce(pending, function (undefined, pending) {
            nextTick(function () {
                value.promiseDispatch.apply(value, pending);
            });
        }, void 0);
        pending = void 0;
        progressListeners = void 0;
    }

    deferred.promise = promise;
    deferred.resolve = become;
    deferred.fulfill = function (value) {
        become(fulfill(value));
    };
    deferred.reject = function (exception) {
        become(reject(exception));
    };
    deferred.notify = function (progress) {
        if (pending) {
            array_reduce(progressListeners, function (undefined, progressListener) {
                nextTick(function () {
                    progressListener(progress);
                });
            }, void 0);
        }
    };

    return deferred;
}

/**
 * Creates a Node-style callback that will resolve or reject the deferred
 * promise.
 * @returns a nodeback
 */
defer.prototype.makeNodeResolver = function () {
    var self = this;
    return function (error, value) {
        if (error) {
            self.reject(error);
        } else if (arguments.length > 2) {
            self.resolve(array_slice(arguments, 1));
        } else {
            self.resolve(value);
        }
    };
};

/**
 * @param makePromise {Function} a function that returns nothing and accepts
 * the resolve, reject, and notify functions for a deferred.
 * @returns a promise that may be resolved with the given resolve and reject
 * functions, or rejected by a thrown exception in makePromise
 */
Q.promise = promise;
function promise(makePromise) {
    var deferred = defer();
    fcall(
        makePromise,
        deferred.resolve,
        deferred.reject,
        deferred.notify
    ).fail(deferred.reject);
    return deferred.promise;
}

/**
 * Constructs a Promise with a promise descriptor object and optional fallback
 * function.  The descriptor contains methods like when(rejected), get(name),
 * put(name, value), post(name, args), and delete(name), which all
 * return either a value, a promise for a value, or a rejection.  The fallback
 * accepts the operation name, a resolver, and any further arguments that would
 * have been forwarded to the appropriate method above had a method been
 * provided with the proper name.  The API makes no guarantees about the nature
 * of the returned object, apart from that it is usable whereever promises are
 * bought and sold.
 */
Q.makePromise = makePromise;
function makePromise(descriptor, fallback, valueOf, exception, isException) {
    if (fallback === void 0) {
        fallback = function (op) {
            return reject(new Error("Promise does not support operation: " + op));
        };
    }

    var promise = object_create(makePromise.prototype);

    promise.promiseDispatch = function (resolve, op, args) {
        var result;
        try {
            if (descriptor[op]) {
                result = descriptor[op].apply(promise, args);
            } else {
                result = fallback.call(promise, op, args);
            }
        } catch (exception) {
            result = reject(exception);
        }
        if (resolve) {
            resolve(result);
        }
    };

    if (valueOf) {
        promise.valueOf = valueOf;
    }

    if (isException) {
        promise.exception = exception;
    }

    return promise;
}

// provide thenables, CommonJS/Promises/A
makePromise.prototype.then = function (fulfilled, rejected, progressed) {
    return when(this, fulfilled, rejected, progressed);
};

makePromise.prototype.thenResolve = function (value) {
    return when(this, function () { return value; });
};

// Chainable methods
array_reduce(
    [
        "isFulfilled", "isRejected", "isPending",
        "dispatch",
        "when", "spread",
        "get", "put", "set", "del", "delete",
        "post", "send", "invoke",
        "keys",
        "fapply", "fcall", "fbind",
        "all", "allResolved",
        "timeout", "delay",
        "catch", "finally", "fail", "fin", "progress", "done",
        "nfcall", "nfapply", "nfbind", "denodeify", "nbind",
        "ncall", "napply", "nbind",
        "npost", "nsend", "ninvoke",
        "nodeify"
    ],
    function (undefined, name) {
        makePromise.prototype[name] = function () {
            return Q[name].apply(
                Q,
                [this].concat(array_slice(arguments))
            );
        };
    },
    void 0
);

makePromise.prototype.toSource = function () {
    return this.toString();
};

makePromise.prototype.toString = function () {
    return "[object Promise]";
};

/**
 * If an object is not a promise, it is as "near" as possible.
 * If a promise is rejected, it is as "near" as possible too.
 * If it’s a fulfilled promise, the fulfillment value is nearer.
 * If it’s a deferred promise and the deferred has been resolved, the
 * resolution is "nearer".
 * @param object
 * @returns most resolved (nearest) form of the object
 */
Q.nearer = valueOf;
function valueOf(value) {
    if (isPromise(value)) {
        return value.valueOf();
    }
    return value;
}

/**
 * @returns whether the given object is a promise.
 * Otherwise it is a fulfilled value.
 */
Q.isPromise = isPromise;
function isPromise(object) {
    return object && typeof object.promiseDispatch === "function";
}

Q.isPromiseAlike = isPromiseAlike;
function isPromiseAlike(object) {
    return object && typeof object.then === "function";
}

/**
 * @returns whether the given object is a pending promise, meaning not
 * fulfilled or rejected.
 */
Q.isPending = isPending;
function isPending(object) {
    return !isFulfilled(object) && !isRejected(object);
}

/**
 * @returns whether the given object is a value or fulfilled
 * promise.
 */
Q.isFulfilled = isFulfilled;
function isFulfilled(object) {
    return !isPromiseAlike(valueOf(object));
}

/**
 * @returns whether the given object is a rejected promise.
 */
Q.isRejected = isRejected;
function isRejected(object) {
    object = valueOf(object);
    return isPromise(object) && 'exception' in object;
}

var rejections = [];
var errors = [];
var errorsDisplayed;
function displayErrors() {
    
    /* 
      HACK MGA :  remove !window.Touch in the condition
      because window.Touch is defined in Chrome, so errors are never displayed... 
    */

    if (
        !errorsDisplayed &&
        typeof window !== "undefined" &&
        window.console
    ) {
        // This promise library consumes exceptions thrown in handlers so
        // they can be handled by a subsequent promise.  The rejected
        // promises get added to this array when they are created, and
        // removed when they are handled.

        //HACK MGA : change log level (log to error)
        console.error("Should be empty:", errors);
    }
    // HACK MGA : remove this affectation to display ALL errors
    // errorsDisplayed = true;
}

// Show unhandled rejection if Node exits without handling an outstanding
// rejection.  (Note that Browserify presently produces a process global
// without the Emitter on interface)
if (typeof process !== "undefined" && process.on) {
    process.on("exit", function () {
        for (var i = 0; i < errors.length; i++) {
            var error = errors[i];
            if (error && typeof error.stack !== "undefined") {
                console.warn("Unhandled rejected promise:", error.stack);
            } else {
                console.warn("Unhandled rejected promise (no stack):", error);
            }
        }
    });
}

/**
 * Constructs a rejected promise.
 * @param exception value describing the failure
 */
Q.reject = reject;
function reject(exception) {
    var rejection = makePromise({
        "when": function (rejected) {
            // note that the error has been handled
            if (rejected) {
                var at = array_indexOf(rejections, this);
                if (at !== -1) {
                    errors.splice(at, 1);
                    rejections.splice(at, 1);
                }
            }
            return rejected ? rejected(exception) : this;
        }
    }, function fallback() {
        return reject(exception);
    }, function valueOf() {
        return this;
    }, exception, true);
    rejections.push(rejection);
    errors.push(exception);
    // note that the error has not been handled
    // HACK MGA : change call order because in disaplyErrors, we use errors...
    //displayErrors();
    return rejection;
}

/**
 * Constructs a fulfilled promise for an immediate reference.
 * @param value immediate reference
 */
Q.fulfill = fulfill;
function fulfill(object) {
    return makePromise({
        "when": function () {
            return object;
        },
        "get": function (name) {
            return object[name];
        },
        "set": function (name, value) {
            object[name] = value;
        },
        "delete": function (name) {
            delete object[name];
        },
        "post": function (name, args) {
            // Mark Miller proposes that post with no name should apply a
            // promised function.
            if (name == null) { // iff name is null or undefined
                return object.apply(void 0, args);
            } else {
                return object[name].apply(object, args);
            }
        },
        "apply": function (thisP, args) {
            return object.apply(thisP, args);
        },
        "keys": function () {
            return object_keys(object);
        }
    }, void 0, function valueOf() {
        return object;
    });
}

/**
 * Constructs a promise for an immediate reference, passes promises through, or
 * coerces promises from different systems.
 * @param value immediate reference or promise
 */
Q.resolve = resolve;
function resolve(value) {
    // If the object is already a Promise, return it directly.  This enables
    // the resolve function to both be used to created references from objects,
    // but to tolerably coerce non-promises to promises.
    if (isPromise(value)) {
        return value;
    }
    // In order to break infinite recursion or loops between `then` and
    // `resolve`, it is necessary to attempt to extract fulfilled values
    // out of foreign promise implementations before attempting to wrap
    // them as unresolved promises.  It is my hope that other
    // implementations will implement `valueOf` to synchronously extract
    // the fulfillment value from their fulfilled promises.  If the
    // other promise library does not implement `valueOf`, the
    // implementations on primordial prototypes are harmless.
    value = valueOf(value);
    // assimilate thenables, CommonJS/Promises/A+
    if (isPromiseAlike(value)) {
        return coerce(value);
    } else {
        return fulfill(value);
    }
}

/**
 * Converts thenables to Q promises.
 * @param promise thenable promise
 * @returns a Q promise
 */
function coerce(promise) {
    var deferred = defer();
    nextTick(function () {
        try {
            promise.then(deferred.resolve, deferred.reject, deferred.notify);
        } catch (exception) {
            deferred.reject(exception);
        }
    });
    return deferred.promise;
}

/**
 * Annotates an object such that it will never be
 * transferred away from this process over any promise
 * communication channel.
 * @param object
 * @returns promise a wrapping of that object that
 * additionally responds to the "isDef" message
 * without a rejection.
 */
Q.master = master;
function master(object) {
    return makePromise({
        "isDef": function () {}
    }, function fallback(op, args) {
        return dispatch(object, op, args);
    }, function () {
        return valueOf(object);
    });
}

/**
 * Registers an observer on a promise.
 *
 * Guarantees:
 *
 * 1. that fulfilled and rejected will be called only once.
 * 2. that either the fulfilled callback or the rejected callback will be
 *    called, but not both.
 * 3. that fulfilled and rejected will not be called in this turn.
 *
 * @param value      promise or immediate reference to observe
 * @param fulfilled  function to be called with the fulfilled value
 * @param rejected   function to be called with the rejection exception
 * @param progressed function to be called on any progress notifications
 * @return promise for the return value from the invoked callback
 */
Q.when = when;
function when(value, fulfilled, rejected, progressed) {
    var deferred = defer();
    var done = false;   // ensure the untrusted promise makes at most a
                        // single call to one of the callbacks

    function _fulfilled(value) {
        try {
            return typeof fulfilled === "function" ? fulfilled(value) : value;
        } catch (exception) {
            return reject(exception);
        }
    }

    function _rejected(exception) {
        if (typeof rejected === "function") {
            makeStackTraceLong(exception, resolvedValue);
            try {
                return rejected(exception);
            } catch (newException) {
                return reject(newException);
            }
        }
        return reject(exception);
    }

    function _progressed(value) {
        return typeof progressed === "function" ? progressed(value) : value;
    }

    var resolvedValue = resolve(value);
    nextTick(function () {
        resolvedValue.promiseDispatch(function (value) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_fulfilled(value));
        }, "when", [function (exception) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_rejected(exception));
        }]);
    });

    // Progress propagator need to be attached in the current tick.
    resolvedValue.promiseDispatch(void 0, "when", [void 0, function (value) {
        var newValue;
        var threw = false;
        try {
            newValue = _progressed(value);
        } catch (e) {
            threw = true;
            if (Q.onerror) {
                Q.onerror(e);
            } else {
                throw e;
            }
        }

        if (!threw) {
            deferred.notify(newValue);
        }
    }]);

    return deferred.promise;
}

/**
 * Spreads the values of a promised array of arguments into the
 * fulfillment callback.
 * @param fulfilled callback that receives variadic arguments from the
 * promised array
 * @param rejected callback that receives the exception if the promise
 * is rejected.
 * @returns a promise for the return value or thrown exception of
 * either callback.
 */
Q.spread = spread;
function spread(promise, fulfilled, rejected) {
    return when(promise, function (valuesOrPromises) {
        return all(valuesOrPromises).then(function (values) {
            return fulfilled.apply(void 0, values);
        }, rejected);
    }, rejected);
}

/**
 * The async function is a decorator for generator functions, turning
 * them into asynchronous generators.  This presently only works in
 * Firefox/Spidermonkey, however, this code does not cause syntax
 * errors in older engines.  This code should continue to work and
 * will in fact improve over time as the language improves.
 *
 * Decorates a generator function such that:
 *  - it may yield promises
 *  - execution will continue when that promise is fulfilled
 *  - the value of the yield expression will be the fulfilled value
 *  - it returns a promise for the return value (when the generator
 *    stops iterating)
 *  - the decorated function returns a promise for the return value
 *    of the generator or the first rejected promise among those
 *    yielded.
 *  - if an error is thrown in the generator, it propagates through
 *    every following yield until it is caught, or until it escapes
 *    the generator function altogether, and is translated into a
 *    rejection for the promise returned by the decorated generator.
 *  - in present implementations of generators, when a generator
 *    function is complete, it throws ``StopIteration``, ``return`` is
 *    a syntax error in the presence of ``yield``, so there is no
 *    observable return value. There is a proposal[1] to add support
 *    for ``return``, which would permit the value to be carried by a
 *    ``StopIteration`` instance, in which case it would fulfill the
 *    promise returned by the asynchronous generator.  This can be
 *    emulated today by throwing StopIteration explicitly with a value
 *    property.
 *
 *  [1]: http://wiki.ecmascript.org/doku.php?id=strawman:async_functions#reference_implementation
 *
 */
Q.async = async;
function async(makeGenerator) {
    return function () {
        // when verb is "send", arg is a value
        // when verb is "throw", arg is an exception
        function continuer(verb, arg) {
            var result;
            try {
                result = generator[verb](arg);
            } catch (exception) {
                if (isStopIteration(exception)) {
                    return exception.value;
                } else {
                    return reject(exception);
                }
            }
            return when(result, callback, errback);
        }
        var generator = makeGenerator.apply(this, arguments);
        var callback = continuer.bind(continuer, "send");
        var errback = continuer.bind(continuer, "throw");
        return callback();
    };
}

/**
 * Throws a ReturnValue exception to stop an asynchronous generator.
 * Only useful presently in Firefox/SpiderMonkey since generators are
 * implemented.
 * @param value the return value for the surrounding generator
 * @throws ReturnValue exception with the value.
 * @example
 * Q.async(function () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      Q.return(foo + bar);
 * })
 */
Q['return'] = _return;
function _return(value) {
    throw new QReturnValue(value);
}

/**
 * The promised function decorator ensures that any promise arguments
 * are resolved and passed as values (`this` is also resolved and passed
 * as a value).  It will also ensure that the result of a function is
 * always a promise.
 *
 * @example
 * var add = Q.promised(function (a, b) {
 *     return a + b;
 * });
 * add(Q.resolve(a), Q.resolve(B));
 *
 * @param {function} callback The function to decorate
 * @returns {function} a function that has been decorated.
 */
Q.promised = promised;
function promised(callback) {
    return function () {
        return spread([this, all(arguments)], function (self, args) {
            return callback.apply(self, args);
        });
    };
}

/**
 * sends a message to a value in a future turn
 * @param object* the recipient
 * @param op the name of the message operation, e.g., "when",
 * @param args further arguments to be forwarded to the operation
 * @returns result {Promise} a promise for the result of the operation
 */
Q.dispatch = dispatch;
function dispatch(object, op, args) {
    var deferred = defer();
    nextTick(function () {
        resolve(object).promiseDispatch(deferred.resolve, op, args);
    });
    return deferred.promise;
}

/**
 * Constructs a promise method that can be used to safely observe resolution of
 * a promise for an arbitrarily named method like "propfind" in a future turn.
 *
 * "dispatcher" constructs methods like "get(promise, name)" and "put(promise)".
 */
Q.dispatcher = dispatcher;
function dispatcher(op) {
    return function (object) {
        var args = array_slice(arguments, 1);
        return dispatch(object, op, args);
    };
}

/**
 * Gets the value of a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to get
 * @return promise for the property value
 */
Q.get = dispatcher("get");

/**
 * Sets the value of a property in a future turn.
 * @param object    promise or immediate reference for object object
 * @param name      name of property to set
 * @param value     new value of property
 * @return promise for the return value
 */
Q.set = dispatcher("set");

/**
 * Deletes a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to delete
 * @return promise for the return value
 */
Q["delete"] = // XXX experimental
Q.del = dispatcher("delete");

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param value     a value to post, typically an array of
 *                  invocation arguments for promises that
 *                  are ultimately backed with `resolve` values,
 *                  as opposed to those backed with URLs
 *                  wherein the posted value can be any
 *                  JSON serializable object.
 * @return promise for the return value
 */
// bound locally because it is used by other methods
var post = Q.post = dispatcher("post");

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param ...args   array of invocation arguments
 * @return promise for the return value
 */
Q.send = send;
Q.invoke = send; // synonyms
function send(value, name) {
    var args = array_slice(arguments, 2);
    return post(value, name, args);
}

/**
 * Applies the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param args      array of application arguments
 */
Q.fapply = fapply;
function fapply(value, args) {
    return dispatch(value, "apply", [void 0, args]);
}

/**
 * Calls the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q["try"] = fcall; // XXX experimental
Q.fcall = fcall;
function fcall(value) {
    var args = array_slice(arguments, 1);
    return fapply(value, args);
}

/**
 * Binds the promised function, transforming return values into a fulfilled
 * promise and thrown errors into a rejected one.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q.fbind = fbind;
function fbind(value) {
    var args = array_slice(arguments, 1);
    return function fbound() {
        var allArgs = args.concat(array_slice(arguments));
        return dispatch(value, "apply", [this, allArgs]);
    };
}

/**
 * Requests the names of the owned properties of a promised
 * object in a future turn.
 * @param object    promise or immediate reference for target object
 * @return promise for the keys of the eventually resolved object
 */
Q.keys = dispatcher("keys");

/**
 * Turns an array of promises into a promise for an array.  If any of
 * the promises gets rejected, the whole array is rejected immediately.
 * @param {Array*} an array (or promise for an array) of values (or
 * promises for values)
 * @returns a promise for an array of the corresponding values
 */
// By Mark Miller
// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled
Q.all = all;
function all(promises) {
    return when(promises, function (promises) {
        var countDown = promises.length;
        if (countDown === 0) {
            return resolve(promises);
        }
        var deferred = defer();
        array_reduce(promises, function (undefined, promise, index) {
            if (isFulfilled(promise)) {
                promises[index] = valueOf(promise);
                if (--countDown === 0) {
                    deferred.resolve(promises);
                }
            } else {
                when(promise, function (value) {
                    promises[index] = value;
                    if (--countDown === 0) {
                        deferred.resolve(promises);
                    }
                })
                .fail(deferred.reject);
            }
        }, void 0);
        return deferred.promise;
    });
}

/**
 * Waits for all promises to be resolved, either fulfilled or
 * rejected.  This is distinct from `all` since that would stop
 * waiting at the first rejection.  The promise returned by
 * `allResolved` will never be rejected.
 * @param promises a promise for an array (or an array) of promises
 * (or values)
 * @return a promise for an array of promises
 */
Q.allResolved = allResolved;
function allResolved(promises) {
    return when(promises, function (promises) {
        promises = array_map(promises, resolve);
        return when(all(array_map(promises, function (promise) {
            return when(promise, noop, noop);
        })), function () {
            return promises;
        });
    });
}

/**
 * Captures the failure of a promise, giving an oportunity to recover
 * with a callback.  If the given promise is fulfilled, the returned
 * promise is fulfilled.
 * @param {Any*} promise for something
 * @param {Function} callback to fulfill the returned promise if the
 * given promise is rejected
 * @returns a promise for the return value of the callback
 */
Q["catch"] = // XXX experimental
Q.fail = fail;
function fail(promise, rejected) {
    return when(promise, void 0, rejected);
}

/**
 * Attaches a listener that can respond to progress notifications from a
 * promise's originating deferred. This listener receives the exact arguments
 * passed to ``deferred.notify``.
 * @param {Any*} promise for something
 * @param {Function} callback to receive any progress notifications
 * @returns the given promise, unchanged
 */
Q.progress = progress;
function progress(promise, progressed) {
    return when(promise, void 0, void 0, progressed);
}

/**
 * Provides an opportunity to observe the rejection of a promise,
 * regardless of whether the promise is fulfilled or rejected.  Forwards
 * the resolution to the returned promise when the callback is done.
 * The callback can return a promise to defer completion.
 * @param {Any*} promise
 * @param {Function} callback to observe the resolution of the given
 * promise, takes no arguments.
 * @returns a promise for the resolution of the given promise when
 * ``fin`` is done.
 */
Q["finally"] = // XXX experimental
Q.fin = fin;
function fin(promise, callback) {
    return when(promise, function (value) {
        return when(callback(), function () {
            return value;
        });
    }, function (exception) {
        return when(callback(), function () {
            return reject(exception);
        });
    });
}

/**
 * Terminates a chain of promises, forcing rejections to be
 * thrown as exceptions.
 * @param {Any*} promise at the end of a chain of promises
 * @returns nothing
 */
Q.done = done;
function done(promise, fulfilled, rejected, progress) {
    var onUnhandledError = function (error) {
        // forward to a future turn so that ``when``
        // does not catch it and turn it into a rejection.
        nextTick(function () {
            makeStackTraceLong(error, promise);

            if (Q.onerror) {
                Q.onerror(error);
            } else {
                throw error;
            }
        });
    };

    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.
    var promiseToHandle = fulfilled || rejected || progress ?
        when(promise, fulfilled, rejected, progress) :
        promise;

    if (typeof process === "object" && process && process.domain) {
        onUnhandledError = process.domain.bind(onUnhandledError);
    }
    fail(promiseToHandle, onUnhandledError);
}

/**
 * Causes a promise to be rejected if it does not get fulfilled before
 * some milliseconds time out.
 * @param {Any*} promise
 * @param {Number} milliseconds timeout
 * @returns a promise for the resolution of the given promise if it is
 * fulfilled before the timeout, otherwise rejected.
 */
Q.timeout = timeout;
function timeout(promise, ms) {
    var deferred = defer();
    var timeoutId = setTimeout(function () {
        deferred.reject(new Error("Timed out after " + ms + " ms"));
    }, ms);

    when(promise, function (value) {
        clearTimeout(timeoutId);
        deferred.resolve(value);
    }, function (exception) {
        clearTimeout(timeoutId);
        deferred.reject(exception);
    });

    return deferred.promise;
}

/**
 * Returns a promise for the given value (or promised value) after some
 * milliseconds.
 * @param {Any*} promise
 * @param {Number} milliseconds
 * @returns a promise for the resolution of the given promise after some
 * time has elapsed.
 */
Q.delay = delay;
function delay(promise, timeout) {
    if (timeout === void 0) {
        timeout = promise;
        promise = void 0;
    }
    var deferred = defer();
    setTimeout(function () {
        deferred.resolve(promise);
    }, timeout);
    return deferred.promise;
}

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided as an array, and returns a promise.
 *
 *      Q.nfapply(FS.readFile, [__filename])
 *      .then(function (content) {
 *      })
 *
 */
Q.nfapply = nfapply;
function nfapply(callback, args) {
    var nodeArgs = array_slice(args);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());

    fapply(callback, nodeArgs).fail(deferred.reject);
    return deferred.promise;
}

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided individually, and returns a promise.
 *
 *      Q.nfcall(FS.readFile, __filename)
 *      .then(function (content) {
 *      })
 *
 */
Q.nfcall = nfcall;
function nfcall(callback/*, ...args */) {
    var nodeArgs = array_slice(arguments, 1);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());

    fapply(callback, nodeArgs).fail(deferred.reject);
    return deferred.promise;
}

/**
 * Wraps a NodeJS continuation passing function and returns an equivalent
 * version that returns a promise.
 *
 *      Q.nfbind(FS.readFile, __filename)("utf-8")
 *      .then(console.log)
 *      .done()
 *
 */
Q.nfbind = nfbind;
Q.denodeify = Q.nfbind; // synonyms
function nfbind(callback/*, ...args */) {
    var baseArgs = array_slice(arguments, 1);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());

        fapply(callback, nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
}

Q.nbind = nbind;
function nbind(callback/*, ... args*/) {
    var baseArgs = array_slice(arguments, 1);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());

        var thisArg = this;
        function bound() {
            return callback.apply(thisArg, arguments);
        }

        fapply(bound, nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
}

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback with a given array of arguments, plus a provided callback.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param {Array} args arguments to pass to the method; the callback
 * will be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.npost = npost;
function npost(object, name, args) {
    var nodeArgs = array_slice(args || []);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());

    post(object, name, nodeArgs).fail(deferred.reject);
    return deferred.promise;
}

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback, forwarding the given variadic arguments, plus a provided
 * callback argument.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param ...args arguments to pass to the method; the callback will
 * be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nsend = nsend;
Q.ninvoke = Q.nsend; // synonyms
function nsend(object, name /*, ...args*/) {
    var nodeArgs = array_slice(arguments, 2);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    post(object, name, nodeArgs).fail(deferred.reject);
    return deferred.promise;
}

Q.nodeify = nodeify;
function nodeify(promise, nodeback) {
    if (nodeback) {
        promise.then(function (value) {
            nextTick(function () {
                nodeback(null, value);
            });
        }, function (error) {
            nextTick(function () {
                nodeback(error);
            });
        });
    } else {
        return promise;
    }
}

// All code before this point will be filtered from stack traces.
var qEndingLine = captureLine();

return Q;

});

/*
 Copyright 2011 Abdulla Abdurakhmanov
 Original sources are available at https://code.google.com/p/x2js/

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

function X2JS(matchers, attrPrefix, ignoreRoot) {
    if (attrPrefix === null || attrPrefix === undefined) {
        attrPrefix = "_";
    }
    
    if (ignoreRoot === null || ignoreRoot === undefined) {
        ignoreRoot = false;
    }
    
	var VERSION = "1.0.11";
	var escapeMode = false;

	var DOMNodeTypes = {
		ELEMENT_NODE 	   : 1,
		TEXT_NODE    	   : 3,
		CDATA_SECTION_NODE : 4,
		COMMENT_NODE       : 8,
		DOCUMENT_NODE 	   : 9
	};
	
	function getNodeLocalName( node ) {
		var nodeLocalName = node.localName;			
		if(nodeLocalName == null) // Yeah, this is IE!! 
			nodeLocalName = node.baseName;
		if(nodeLocalName == null || nodeLocalName=="") // =="" is IE too
			nodeLocalName = node.nodeName;
		return nodeLocalName;
	}
	
	function getNodePrefix(node) {
		return node.prefix;
	}
		
	function escapeXmlChars(str) {
		if(typeof(str) == "string")
			return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#x27;').replace(/\//g, '&#x2F;');
		else
			return str;
	}

	function unescapeXmlChars(str) {
		return str.replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&quot;/g, '"').replace(/&#x27;/g, "'").replace(/&#x2F;/g, '\/')
	}	

	function parseDOMChildren( node ) {
		if(node.nodeType == DOMNodeTypes.DOCUMENT_NODE) {
			var result,
			    child = node.firstChild,
			    i,
			    len; 
			
			// get the first node that isn't a comment
			for(i = 0, len = node.childNodes.length; i < len; i += 1) {
			   if (node.childNodes[i].nodeType !== DOMNodeTypes.COMMENT_NODE) {
			       child = node.childNodes[i];
			       break;
			   } 
			}
			
			if ( ignoreRoot ) {
			    result = parseDOMChildren(child);
			} else {
			    result = {};
			    var childName = getNodeLocalName(child);
                result[childName] = parseDOMChildren(child);
			}
			
			return result;
		}
		else
		if(node.nodeType == DOMNodeTypes.ELEMENT_NODE) {
			var result = new Object;
			result.__cnt=0;
			
			var nodeChildren = node.childNodes;
			
			// Children nodes
			for(var cidx=0; cidx <nodeChildren.length; cidx++) {
				var child = nodeChildren.item(cidx); // nodeChildren[cidx];
				var childName = getNodeLocalName(child);
				
				result.__cnt++;
				if(result[childName] == null) {
					result[childName] = parseDOMChildren(child);
					result[childName+"_asArray"] = new Array(1);
					result[childName+"_asArray"][0] = result[childName];
				}
				else {
					if(result[childName] != null) {
						if( !(result[childName] instanceof Array)) {
							var tmpObj = result[childName];
							result[childName] = new Array();
							result[childName][0] = tmpObj;
							
							result[childName+"_asArray"] = result[childName];
						}
					}
					var aridx = 0;
					while(result[childName][aridx]!=null) aridx++;
					(result[childName])[aridx] = parseDOMChildren(child);
				}			
			}
			
			// Attributes
			for(var aidx=0; aidx <node.attributes.length; aidx++) {
				var attr = node.attributes.item(aidx); // [aidx];
				result.__cnt++;
				
				var value2 = attr.value;
				for(var m=0, ml=matchers.length; m < ml; m++) {
				    var matchobj = matchers[m];
				    if (matchobj.test.call(this, attr.value))
				        value2 = matchobj.converter.call(this, attr.value);
				}
				
				result[attrPrefix+attr.name]=value2;
			}
			
			// Node namespace prefix
			var nodePrefix = getNodePrefix(node);
			if(nodePrefix!=null && nodePrefix!="") {
				result.__cnt++;
				result.__prefix=nodePrefix;
			}
			
			if( result.__cnt == 1 && result["#text"]!=null  ) {
				result = result["#text"];
			} 
			
			if(result["#text"]!=null) {
				result.__text = result["#text"];
				if(escapeMode)
					result.__text = unescapeXmlChars(result.__text)
				delete result["#text"];
				delete result["#text_asArray"];
			}
			if(result["#cdata-section"]!=null) {
				result.__cdata = result["#cdata-section"];
				delete result["#cdata-section"];
				delete result["#cdata-section_asArray"];
			}
			
			if(result.__text!=null || result.__cdata!=null) {
				result.toString = function() {
					return (this.__text!=null? this.__text:'')+( this.__cdata!=null ? this.__cdata:'');
				}
			}
			return result;
		}
		else
		if(node.nodeType == DOMNodeTypes.TEXT_NODE || node.nodeType == DOMNodeTypes.CDATA_SECTION_NODE) {
			return node.nodeValue;
		}	
		else
		if(node.nodeType == DOMNodeTypes.COMMENT_NODE) {
		    return null;
		}
	}
	
	function startTag(jsonObj, element, attrList, closed) {
		var resultStr = "<"+ ( (jsonObj!=null && jsonObj.__prefix!=null)? (jsonObj.__prefix+":"):"") + element;
		if(attrList!=null) {
			for(var aidx = 0; aidx < attrList.length; aidx++) {
				var attrName = attrList[aidx];
				var attrVal = jsonObj[attrName];
				resultStr+=" "+attrName.substr(1)+"='"+attrVal+"'";
			}
		}
		if(!closed)
			resultStr+=">";
		else
			resultStr+="/>";
		return resultStr;
	}
	
	function endTag(jsonObj,elementName) {
		return "</"+ (jsonObj.__prefix!=null? (jsonObj.__prefix+":"):"")+elementName+">";
	}
	
	function endsWith(str, suffix) {
	    return str.indexOf(suffix, str.length - suffix.length) !== -1;
	}
	
	function jsonXmlSpecialElem ( jsonObj, jsonObjField ) {
		if(endsWith(jsonObjField.toString(),("_asArray")) 
				|| jsonObjField.toString().indexOf("_")==0 
				|| (jsonObj[jsonObjField] instanceof Function) )
			return true;
		else
			return false;
	}
	
	function jsonXmlElemCount ( jsonObj ) {
		var elementsCnt = 0;
		if(jsonObj instanceof Object ) {
			for( var it in jsonObj  ) {
				if(jsonXmlSpecialElem ( jsonObj, it) )
					continue;			
				elementsCnt++;
			}
		}
		return elementsCnt;
	}
	
	function parseJSONAttributes ( jsonObj ) {
		var attrList = [];
		if(jsonObj instanceof Object ) {
			for( var ait in jsonObj  ) {
				if(ait.toString().indexOf("__")== -1 && ait.toString().indexOf("_")==0) {
					attrList.push(ait);
				}
			}
		}
		return attrList;
	}
	
	function parseJSONTextAttrs ( jsonTxtObj ) {
		var result ="";
		
		if(jsonTxtObj.__cdata!=null) {										
			result+="<![CDATA["+jsonTxtObj.__cdata+"]]>";					
		}
		
		if(jsonTxtObj.__text!=null) {			
			if(escapeMode)
				result+=escapeXmlChars(jsonTxtObj.__text);
			else
				result+=jsonTxtObj.__text;
		}
		return result
	}
	
	function parseJSONTextObject ( jsonTxtObj ) {
		var result ="";

		if( jsonTxtObj instanceof Object ) {
			result+=parseJSONTextAttrs ( jsonTxtObj )
		}
		else
			if(jsonTxtObj!=null) {
				if(escapeMode)
					result+=escapeXmlChars(jsonTxtObj);
				else
					result+=jsonTxtObj;
			}
		
		return result;
	}
	
	function parseJSONArray ( jsonArrRoot, jsonArrObj, attrList ) {
		var result = ""; 
		if(jsonArrRoot.length == 0) {
			result+=startTag(jsonArrRoot, jsonArrObj, attrList, true);
		}
		else {
			for(var arIdx = 0; arIdx < jsonArrRoot.length; arIdx++) {
				result+=startTag(jsonArrRoot[arIdx], jsonArrObj, parseJSONAttributes(jsonArrRoot[arIdx]), false);
				result+=parseJSONObject(jsonArrRoot[arIdx]);
				result+=endTag(jsonArrRoot[arIdx],jsonArrObj);						
			}
		}
		return result;
	}
	
	function parseJSONObject ( jsonObj ) {
		var result = "";	

		var elementsCnt = jsonXmlElemCount ( jsonObj );
		
		if(elementsCnt > 0) {
			for( var it in jsonObj ) {
				
				if(jsonXmlSpecialElem ( jsonObj, it) )
					continue;			
				
				var subObj = jsonObj[it];						
				
				var attrList = parseJSONAttributes( subObj )
				
				if(subObj == null || subObj == undefined) {
					result+=startTag(subObj, it, attrList, true)
				}
				else
				if(subObj instanceof Object) {
					
					if(subObj instanceof Array) {					
						result+=parseJSONArray( subObj, it, attrList )					
					}
					else {
						var subObjElementsCnt = jsonXmlElemCount ( subObj );
						if(subObjElementsCnt > 0 || subObj.__text!=null || subObj.__cdata!=null) {
							result+=startTag(subObj, it, attrList, false);
							result+=parseJSONObject(subObj);
							result+=endTag(subObj,it);
						}
						else {
							result+=startTag(subObj, it, attrList, true);
						}
					}
				}
				else {
					result+=startTag(subObj, it, attrList, false);
					result+=parseJSONTextObject(subObj);
					result+=endTag(subObj,it);
				}
			}
		}
		result+=parseJSONTextObject(jsonObj);
		
		return result;
	}
	
	this.parseXmlString = function(xmlDocStr) {
		var xmlDoc;
		if (window.DOMParser) {
			// ORANGE: XML parsing management
			try
			{
				var parser=new window.DOMParser();
				xmlDoc = parser.parseFromString( xmlDocStr, "text/xml" );
				if(xmlDoc.getElementsByTagName('parsererror').length > 0) {
					  throw new Error('Error parsing XML');
				}
				//var parsererrorNS = parser.parseFromString('INVALID', 'text/xml').childNodes[0].namespaceURI;
			    //if(xmlDoc.getElementsByTagNameNS(parsererrorNS, 'parsererror').length > 0) {
			    //    throw new Error('Error parsing XML');
			    //}		
			}
			catch (e)
			{
				return null;
			}
		}
		return xmlDoc;
	}

	this.xml2json = function (xmlDoc) {
		return parseDOMChildren ( xmlDoc );
	}
	
	this.xml_str2json = function (xmlDocStr) {
		var xmlDoc = this.parseXmlString(xmlDocStr);	
		return xmlDoc === null ? xmlDoc : this.xml2json(xmlDoc);
	}

	this.json2xml_str = function (jsonObj) {
		return parseJSONObject ( jsonObj );
	}

	this.json2xml = function (jsonObj) {
		var xmlDocStr = this.json2xml_str (jsonObj);
		return this.parseXmlString(xmlDocStr);
	}
	
	this.getVersion = function () {
		return VERSION;
	}		
	
	this.escapeMode = function(enabled) {
		escapeMode = enabled;
	}
}
/*
 * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.
 * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2014, Orange
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
var mp4lib = (function() {
    var mp4lib = {
        boxes:{},
        fields:{},

        // In debug mode, source data buffer is kept for each of deserialized box so any
        // structural deserialization problems can be traced by serializing each box
        // and comparing the resulting buffer with the source buffer.
        // This greatly increases memory consumption, so it is turned off by default.
        debug:false,

        // A handler function may be hooked up to display warnings.
        // A warning is typically non-critical issue, like unknown box in data buffer.
        warningHandler:function(message){
            //console.log(message);
        }
    };

    var boxTypeArray = {};

    mp4lib.registerTypeBoxes = function() {
        boxTypeArray["moov"] = mp4lib.boxes.MovieBox;
        boxTypeArray["moof"] = mp4lib.boxes.MovieFragmentBox;
        boxTypeArray["ftyp"] = mp4lib.boxes.FileTypeBox;
        boxTypeArray["mfhd"] = mp4lib.boxes.MovieFragmentHeaderBox;
        boxTypeArray["mfra"] = mp4lib.boxes.MovieFragmentRandomAccessBox;
        boxTypeArray["udta"] = mp4lib.boxes.UserDataBox;
        boxTypeArray["trak"] = mp4lib.boxes.TrackBox;
        boxTypeArray["edts"] = mp4lib.boxes.EditBox;
        boxTypeArray["mdia"] = mp4lib.boxes.MediaBox;
        boxTypeArray["minf"] = mp4lib.boxes.MediaInformationBox;
        boxTypeArray["dinf"] = mp4lib.boxes.DataInformationBox;
        boxTypeArray["stbl"] = mp4lib.boxes.SampleTableBox;
        boxTypeArray["mvex"] = mp4lib.boxes.MovieExtendsBox;
        boxTypeArray["traf"] = mp4lib.boxes.TrackFragmentBox;
        boxTypeArray["meta"] = mp4lib.boxes.MetaBox;
        boxTypeArray["mvhd"] = mp4lib.boxes.MovieHeaderBox;
        boxTypeArray["mdat"] = mp4lib.boxes.MediaDataBox;
        boxTypeArray["free"] = mp4lib.boxes.FreeSpaceBox;
        boxTypeArray["sidx"] = mp4lib.boxes.SegmentIndexBox;
        boxTypeArray["tkhd"] = mp4lib.boxes.TrackHeaderBox;
        boxTypeArray["mdhd"] = mp4lib.boxes.MediaHeaderBox;
        boxTypeArray["mehd"] = mp4lib.boxes.MovieExtendsHeaderBox;
        boxTypeArray["hdlr"] = mp4lib.boxes.HandlerBox;
        boxTypeArray["stts"] = mp4lib.boxes.TimeToSampleBox;
        boxTypeArray["stsc"] = mp4lib.boxes.SampleToChunkBox;
        boxTypeArray["stco"] = mp4lib.boxes.ChunkOffsetBox;
        boxTypeArray["trex"] = mp4lib.boxes.TrackExtendsBox;
        boxTypeArray["vmhd"] = mp4lib.boxes.VideoMediaHeaderBox;
        boxTypeArray["smhd"] = mp4lib.boxes.SoundMediaHeaderBox;
        boxTypeArray["dref"] = mp4lib.boxes.DataReferenceBox;
        boxTypeArray["url "] = mp4lib.boxes.DataEntryUrlBox;
        boxTypeArray["urn "] = mp4lib.boxes.DataEntryUrnBox;
        boxTypeArray["tfhd"] = mp4lib.boxes.TrackFragmentHeaderBox;
        boxTypeArray["tfdt"] = mp4lib.boxes.TrackFragmentBaseMediaDecodeTimeBox;
        boxTypeArray["trun"] = mp4lib.boxes.TrackFragmentRunBox;
        boxTypeArray["stsd"] = mp4lib.boxes.SampleDescriptionBox;
        boxTypeArray["sdtp"] = mp4lib.boxes.SampleDependencyTableBox;
        boxTypeArray["avc1"] = mp4lib.boxes.AVC1VisualSampleEntryBox;
        boxTypeArray["encv"] = mp4lib.boxes.EncryptedVideoBox;
        boxTypeArray["avcC"] = mp4lib.boxes.AVCConfigurationBox;
        boxTypeArray["pasp"] = mp4lib.boxes.PixelAspectRatioBox;
        boxTypeArray["mp4a"] = mp4lib.boxes.MP4AudioSampleEntryBox;
        boxTypeArray["enca"] = mp4lib.boxes.EncryptedAudioBox;
        boxTypeArray["esds"] = mp4lib.boxes.ESDBox;
        boxTypeArray["stsz"] = mp4lib.boxes.SampleSizeBox;
        boxTypeArray["pssh"] = mp4lib.boxes.ProtectionSystemSpecificHeaderBox;
        boxTypeArray["senc"] = mp4lib.boxes.SampleEncryptionBox;
        boxTypeArray["saiz"] = mp4lib.boxes.SampleAuxiliaryInformationSizesBox;
        boxTypeArray["saio"] = mp4lib.boxes.SampleAuxiliaryInformationOffsetsBox;
        boxTypeArray["sinf"] = mp4lib.boxes.ProtectionSchemeInformationBox;
        boxTypeArray["schi"] = mp4lib.boxes.SchemeInformationBox;
        boxTypeArray["tenc"] = mp4lib.boxes.TrackEncryptionBox;
        boxTypeArray["schm"] = mp4lib.boxes.SchemeTypeBox;
        boxTypeArray["elst"] = mp4lib.boxes.EditListBox;
        boxTypeArray["hmhd"] = mp4lib.boxes.HintMediaHeaderBox;
        boxTypeArray["nmhd"] = mp4lib.boxes.NullMediaHeaderBox;
        boxTypeArray["ctts"] = mp4lib.boxes.CompositionOffsetBox;
        boxTypeArray["cslg"] = mp4lib.boxes.CompositionToDecodeBox;
        boxTypeArray["stss"] = mp4lib.boxes.SyncSampleBox;
        boxTypeArray["tref"] = mp4lib.boxes.TrackReferenceBox;
        boxTypeArray["frma"] = mp4lib.boxes.OriginalFormatBox;
        boxTypeArray["subs"] = mp4lib.boxes.SubSampleInformationBox;
        //extended types
        boxTypeArray[JSON.stringify([0x6D, 0x1D, 0x9B, 0x05, 0x42, 0xD5, 0x44, 0xE6, 0x80, 0xE2, 0x14, 0x1D, 0xAF, 0xF7, 0x57, 0xB2])] = mp4lib.boxes.TfxdBox;
        boxTypeArray[JSON.stringify([0xD4, 0x80, 0x7E, 0xF2, 0xCA, 0x39, 0x46, 0x95, 0x8E, 0x54, 0x26, 0xCB, 0x9E, 0x46, 0xA7, 0x9F])] = mp4lib.boxes.TfrfBox;
        boxTypeArray[JSON.stringify([0xD0, 0x8A, 0x4F, 0x18, 0x10, 0xF3, 0x4A, 0x82, 0xB6, 0xC8, 0x32, 0xD8, 0xAB, 0xA1, 0x83, 0xD3])] = mp4lib.boxes.PiffProtectionSystemSpecificHeaderBox;
        boxTypeArray[JSON.stringify([0x89, 0x74, 0xDB, 0xCE, 0x7B, 0xE7, 0x4C, 0x51, 0x84, 0xF9, 0x71, 0x48, 0xF9, 0x88, 0x25, 0x54])] = mp4lib.boxes.PiffTrackEncryptionBox;
        boxTypeArray[JSON.stringify([0xA2, 0x39, 0x4F, 0x52, 0x5A, 0x9B, 0x4F, 0x14, 0xA2, 0x44, 0x6C, 0x42, 0x7C, 0x64, 0x8D, 0xF4])] = mp4lib.boxes.PiffSampleEncryptionBox;
    };


    mp4lib.constructorTypeBox = function (type) {
        var obj, args;
        obj = Object.create(type.prototype);
        args = Array.prototype.slice.call(arguments, 1);
        type.apply(obj, args);
        return obj;
    };

    mp4lib.searchBox = function ( boxtype, uuid ){
        var boxType;

        if (uuid) {
            boxType = boxTypeArray[uuid];
        }
        else {
            boxType = boxTypeArray[boxtype];
        }

        if (!boxType){
            boxType = mp4lib.boxes.UnknownBox;
        }

        return boxType;
    };

    mp4lib.createBox = function( boxtype,size, uuid) {
        return mp4lib.constructorTypeBox.apply(null, [mp4lib.searchBox(boxtype, uuid),size]);
    };

    /**
    deserialize binary data (uint8array) into mp4lib.File object
    */
    mp4lib.deserialize = function(uint8array) {
        var f = new mp4lib.boxes.File();
        try{
            f.read(uint8array);
        }catch(e){
            mp4lib.warningHandler(e.message);
            return null;
        }
        return f;
    };

    /**
    serialize box (or mp4lib.File) into binary data (uint8array)
    */
    mp4lib.serialize = function(f) {
        var file_size = f.getLength(),
            uint8array = new Uint8Array(file_size);
        f.write(uint8array);
        return uint8array;
    };

    /**
    exception thrown when binary data is malformed
    it is thrown typically during deserialization
    */
    mp4lib.ParseException = function(message) {
        this.message = message;
        this.name = "ParseException";
    };

    /**
    exception thrown when box objects contains invalid data,
    ex. flag field is are not coherent with fields etc.
    it is thrown typically during object manipulation or serialization
    */
    mp4lib.DataIntegrityException = function(message) {
        this.message = message;
        this.name = "DataIntegrityException";
    };

    return mp4lib;
})();

// This module is intended to work both on node.js and inside browser.
// Since these environments differ in a way modules are stored/accessed,
// we need to export the module in the environment-dependant way

if (typeof module !== 'undefined' && typeof module.exports !== 'undefined')
    module.exports = mp4lib; // node.js
else
    window.mp4lib = mp4lib;  // browser


/*
 * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.
 * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2014, Orange
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

mp4lib.fields.readBytes = function(buf, pos, nbBytes) {
    var value = 0,
        i = 0;
    for (i = 0; i < nbBytes; i++) {
        value = value << 8;
        value = value + buf[pos];
        pos++;
    }
    return value;
};

mp4lib.fields.writeBytes = function(buf, pos, nbBytes, value) {
    var i = 0;
    for (i = 0; i < nbBytes; i++) {
        buf[pos + nbBytes - i - 1] = value & 0xFF;
        value = value >> 8;
    }
};

mp4lib.fields.readString = function(buf, pos, count) {
    var res = "",
        i;
    for (i = pos; i < pos + count; i++) {
        res += String.fromCharCode(buf[i]);
    }
    return res;
};

//------------------------------- NumberField -------------------------------

mp4lib.fields.NumberField = function(bits, signed) {
    this.bits = bits;
    this.signed = signed;
};

mp4lib.fields.NumberField.prototype.read = function(buf, pos) {
    return mp4lib.fields.readBytes(buf, pos, this.bits / 8);
};

mp4lib.fields.NumberField.prototype.write = function(buf, pos, val) {
    mp4lib.fields.writeBytes(buf, pos, this.bits / 8, val);
};

mp4lib.fields.NumberField.prototype.getLength = function() {
    return this.bits / 8;
};

//------------------------------- 64BitsNumberField -------------------------------

mp4lib.fields.LongNumberField = function() {};

mp4lib.fields.LongNumberField.prototype.read = function(buf, pos) {
    var high = mp4lib.fields.readBytes(buf, pos, 4),
        low = mp4lib.fields.readBytes(buf, pos + 4, 4);
    return goog.math.Long.fromBits(low, high);
};

mp4lib.fields.LongNumberField.prototype.write = function(buf, pos, val) {
    var longNumber = (typeof val.getLowBits === 'function') ? val : goog.math.Long.fromNumber(val),
        low = longNumber.getLowBits(),
        high = longNumber.getHighBits();
    mp4lib.fields.writeBytes(buf, pos, 4, high);
    mp4lib.fields.writeBytes(buf, pos + 4, 4, low);
};

mp4lib.fields.LongNumberField.prototype.getLength = function() {
    return 8;
};

//------------------------------- FixedLenStringField -------------------------------

mp4lib.fields.FixedLenStringField = function(size) {
    this.size = size;
};

mp4lib.fields.FixedLenStringField.prototype.read = function(buf, pos) {
    var res = "",
        i = 0;
    for (i = 0; i < this.size; i++) {
        res = res + String.fromCharCode(buf[pos + i]);
    }
    return res;
};

mp4lib.fields.FixedLenStringField.prototype.write = function(buf, pos, val) {
    var i = 0;
    for (i = 0; i < this.size; i++) {
        buf[pos + i] = val.charCodeAt(i);
    }
};

mp4lib.fields.FixedLenStringField.prototype.getLength = function() {
    return this.size;
};

//------------------------------- BoxTypeField -------------------------------

mp4lib.fields.BoxTypeField = function() {};

mp4lib.fields.BoxTypeField.prototype.read = function(buf, pos) {
    var res = "",
        i = 0;
    for (i = 0; i < 4; i++) {
        res = res + String.fromCharCode(buf[pos + i]);
    }
    return res;
};

mp4lib.fields.BoxTypeField.prototype.write = function(buf, pos, val) {
    var i = 0;
    for (i = 0; i < 4; i++) {
        buf[pos + i] = val.charCodeAt(i);
    }
};

mp4lib.fields.BoxTypeField.prototype.getLength = function() {
    return 4;
};


//------------------------------- StringField -------------------------------

mp4lib.fields.StringField = function() {};


mp4lib.fields.StringField.prototype.read = function(buf, pos, end) {
    var res = "",
        i = 0;

    for (i = pos; i < end; i++) {
        res = res + String.fromCharCode(buf[i]);
        if (buf[i] === 0) {
            return res;
        }
    }

    if ((end - pos < 255) && (buf[0] == String.fromCharCode(end - pos))) {
        res = res.substr(1, end - pos);
        mp4lib.warningHandler('null-terminated string expected, ' +
            'but found a string "' + res + '", which seems to be ' +
            'length-prefixed instead. Conversion done.');
        return res;
    }

    throw new mp4lib.ParseException('expected null-terminated string, ' +
        'but end of field reached without termination. ' +
        'Read so far:"' + res + '"');
};

mp4lib.fields.StringField.prototype.write = function(buf, pos, val) {
    var i = 0;

    for (i = 0; i < val.length; i++) {
        buf[pos + i] = val.charCodeAt(i);
    }
    buf[pos + val.length] = 0;
};

mp4lib.fields.StringField.prototype.getLength = function(val) {
    return val.length;
};

//------------------------------- ArrayField -------------------------------

mp4lib.fields.ArrayField = function(innerField, size) {
    this.innerField = innerField;
    this.size = size;
};

mp4lib.fields.ArrayField.prototype.read = function(buf, pos) {
    var innerFieldLength = -1,
        res = [],
        i = 0;
    for (i = 0; i < this.size; i++) {

        res.push(this.innerField.read(buf, pos));

        if (innerFieldLength == -1) {
            innerFieldLength = this.innerField.getLength(res[i]);
        }
        // it may happen that the size of field depends on the box flags, 
        // we need to count is having box and first structure constructed

        pos += innerFieldLength;
    }
    return res;
};

// pre-defined shortcuts for common fields 
// ( it is recommended to use these shortcuts to avoid constructors 
//   being called for every field processing action )
mp4lib.fields.FIELD_INT8 = new mp4lib.fields.NumberField(8, true);
mp4lib.fields.FIELD_INT16 = new mp4lib.fields.NumberField(16, true);
mp4lib.fields.FIELD_INT32 = new mp4lib.fields.NumberField(32, true);
mp4lib.fields.FIELD_INT64 = new mp4lib.fields.LongNumberField();
mp4lib.fields.FIELD_UINT8 = new mp4lib.fields.NumberField(8, false);
mp4lib.fields.FIELD_UINT16 = new mp4lib.fields.NumberField(16, false);
mp4lib.fields.FIELD_UINT32 = new mp4lib.fields.NumberField(32, false);
mp4lib.fields.FIELD_UINT64 = new mp4lib.fields.LongNumberField();
mp4lib.fields.FIELD_BIT8 = new mp4lib.fields.NumberField(8, false);
mp4lib.fields.FIELD_BIT16 = new mp4lib.fields.NumberField(16, false);
mp4lib.fields.FIELD_BIT24 = new mp4lib.fields.NumberField(24, false);
mp4lib.fields.FIELD_BIT32 = new mp4lib.fields.NumberField(32, false);
mp4lib.fields.FIELD_ID = new mp4lib.fields.BoxTypeField(4);
mp4lib.fields.FIELD_STRING = new mp4lib.fields.StringField();
/*
 * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.
 * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2014, Orange
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

// ---------- File (treated similarly to box in terms of processing) ----------
mp4lib.boxes.File = function() {
    this.boxes = [];
};

mp4lib.boxes.File.prototype.getBoxByType = function(boxType) {
    var i = 0;

    for (i = 0; i < this.boxes.length; i++) {
        if (this.boxes[i].boxtype === boxType) {
            return this.boxes[i];
        }
    }
    return null;
};

mp4lib.boxes.File.prototype.getLength = function() {
    var length = 0,
        i = 0;

    for (i = 0; i < this.boxes.length; i++) {
        this.boxes[i].computeLength();
        length += this.boxes[i].size;
    }

    return length;
};

mp4lib.boxes.File.prototype.write = function(data) {
    var pos = 0,
        i = 0;

    for (i = 0; i < this.boxes.length; i++) {
        pos = this.boxes[i].write(data, pos);
    }
};

mp4lib.boxes.File.prototype.read = function(data) {
    var size = 0,
        boxtype = null,
        uuidFieldPos = 0,
        uuid = null,
        pos = 0,
        end = data.length,
        box;

    while (pos < end) {
        // Read box size
        size = mp4lib.fields.FIELD_UINT32.read(data, pos);

        // Read boxtype
        boxtype = mp4lib.fields.readString(data, pos + 4, 4);

        // Extented type?
        if (boxtype == "uuid") {
            uuidFieldPos = (size == 1) ? 16 : 8;
            uuid = new mp4lib.fields.ArrayField(mp4lib.fields.FIELD_INT8, 16).read(data, pos + uuidFieldPos, pos + uuidFieldPos + 16);
            uuid = JSON.stringify(uuid);
        }

        box = mp4lib.createBox(boxtype, size, uuid);
        if (boxtype === "uuid") {
            pos = box.read(data, pos + mp4lib.fields.FIELD_INT8.getLength() * 16 + 8, pos + size);
            uuid = null;
        } else {
            pos = box.read(data, pos + 8, pos + size);
        }

        // in debug mode, sourcebuffer is copied to each box,
        // so any invalid deserializations may be found by comparing
        // source buffer with serialized box
        if (mp4lib.debug) {
            box.__sourceBuffer = data.subarray(pos - box.size, pos);
        }

        //if boxtype is unknown, don't add it to the list box
        if (box.boxtype) {
            this.boxes.push(box);
        }

        if (box.size <= 0 || box.size === null) {
            throw new mp4lib.ParseException('Problem on size of box ' + box.boxtype +
                ', parsing stopped to avoid infinite loop');
        }
    }
};

/**
find child position
*/
mp4lib.boxes.File.prototype.getBoxOffsetByType = function(boxType) {
    var offset = 0,
        i = 0;

    for (i = 0; i < this.boxes.length; i++) {
        if (this.boxes[i].boxtype === boxType) {
            return offset;
        }
        offset += this.boxes[i].size;
    }
    return -1;
};

mp4lib.boxes.File.prototype.getBoxIndexByType = function(boxType) {
    var index = 0,
        i = 0;

    for (i = 0; i < this.boxes.length; i++) {
        if (this.boxes[i].boxtype === boxType) {
            return index;
        }
        index++;
    }
    return -1;
};


// ---------- Generic Box -------------------------------
mp4lib.boxes.Box = function(boxType, size, uuid, largesize) {
    this.size = size || null;
    this.boxtype = boxType;
    //large size management to do...
    if (this.size === 1 && largesize) {
        this.largesize = largesize;
    }

    if (uuid) {
        this.extended_type = uuid;
    }

    this.localPos = 0;
    this.localEnd = 0;
};

mp4lib.boxes.Box.prototype.write = function(data, pos) {
    this.localPos = pos;
    var i = 0;

    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.size);
    //if extended_type is not defined, boxtype must have this.boxtype value
    if (!this.extended_type) {
        this._writeData(data, mp4lib.fields.FIELD_ID, this.boxtype);
    } else { //if extended_type is defined, boxtype must have 'uuid' value
        this._writeData(data, mp4lib.fields.FIELD_ID, 'uuid');
    }

    if (this.size === 1) {
        this._writeData(data, mp4lib.fields.FIELD_INT64, this.largesize);
    }

    if (this.extended_type) {
        for (i = 0; i < 16; i++) {
            this._writeData(data, mp4lib.fields.FIELD_INT8, this.extended_type[i]);
        }
    }
};

mp4lib.boxes.Box.prototype.getBoxByType = function(boxType) {
    var i = 0;
    if (this.hasOwnProperty('boxes')) {
        for (i = 0; i < this.boxes.length; i++) {
            if (this.boxes[i].boxtype === boxType) {
                return this.boxes[i];
            }
        }
    }
    return null;
};


mp4lib.boxes.Box.prototype.getBoxesByType = function(boxType) {
    var resu = [],
        i = 0;
    if (this.hasOwnProperty('boxes')) {
        for (i = 0; i < this.boxes.length; i++) {
            if (this.boxes[i].boxtype === boxType) {
                resu.push(this.boxes[i]);
            }
        }
    }
    return resu;
};

/**
remove child from a box
*/
mp4lib.boxes.Box.prototype.removeBoxByType = function(boxType) {
    var i = 0;

    if (this.hasOwnProperty('boxes')) {
        for (i = 0; i < this.boxes.length; i++) {
            if (this.boxes[i].boxtype === boxType) {
                this.boxes.splice(i, 1);
            }
        }
    } else {
        mp4lib.warningHandler('' + this.boxtype + 'does not have ' + boxType + ' box, impossible to remove it');
    }
};

/**
find child position
*/
mp4lib.boxes.Box.prototype.getBoxOffsetByType = function(boxType) {
    var offset = 8,
        i = 0;

    if (this.hasOwnProperty('boxes')) {
        for (i = 0; i < this.boxes.length; i++) {
            if (this.boxes[i].boxtype === boxType) {
                return offset;
            }
            offset += this.boxes[i].size;
        }
    }
    return null;
};

mp4lib.boxes.Box.prototype.getBoxIndexByType = function(boxType) {
    var index = 0,
        i = 0;

    if (this.hasOwnProperty('boxes')) {
        for (i = 0; i < this.boxes.length; i++) {
            if (this.boxes[i].boxtype === boxType) {
                return index;
            }
            index++;
        }
    }
    return null;
};

mp4lib.boxes.Box.prototype.computeLength = function() {
    this.size = mp4lib.fields.FIELD_UINT32.getLength() + mp4lib.fields.FIELD_ID.getLength(); //size and boxtype length

    /*if (this.size === 1) {
        this.size += mp4lib.fields.FIELD_INT64.getLength(); //add large_size length
    }*/
    if (this.extended_type) {
        this.size += mp4lib.fields.FIELD_INT8.getLength() * 16; //add extended_type length.
    }
};

mp4lib.boxes.Box.prototype._readData = function(data, dataType) {
    var resu = dataType.read(data, this.localPos, this.localEnd);
    this.localPos += dataType.getLength(resu);
    return resu;
};

mp4lib.boxes.Box.prototype._writeData = function(data, dataType, dataField) {
    if (dataField === undefined || dataField === null) {
        throw new mp4lib.ParseException('a field to write is null or undefined for box : ' + this.boxtype);
    } else {
        dataType.write(data, this.localPos, dataField);
        this.localPos += dataType.getLength(dataField);
    }
};

mp4lib.boxes.Box.prototype._writeBuffer = function(data, dataField, size) {
    data.set(dataField, this.localPos);
    this.localPos += size;
};

mp4lib.boxes.Box.prototype._writeArrayData = function(data, dataArrayType, array) {
    var i = 0;

    if (array === undefined || array === null || array.length === 0) {
        throw new mp4lib.ParseException('an array to write is null, undefined or length = 0 for box : ' + this.boxtype);
    }

    for (i = 0; i < array.length; i++) {
        this._writeData(data, dataArrayType, array[i]);
    }
};

mp4lib.boxes.Box.prototype._readArrayData = function(data, dataArrayType) {
    var array = [],
        dataArrayTypeLength = dataArrayType.getLength(),
        size = (this.localEnd - this.localPos) / dataArrayTypeLength,
        i = 0;

    for (i = 0; i < size; i++) {
        array.push(dataArrayType.read(data, this.localPos));
        this.localPos += dataArrayTypeLength;
    }
    return array;
};

mp4lib.boxes.Box.prototype._readArrayFieldData = function(data, dataArrayType, arraySize) {
    var innerFieldLength = -1,
        array = [],
        i = 0;

    for (i = 0; i < arraySize; i++) {

        array.push(dataArrayType.read(data, this.localPos));

        if (innerFieldLength === -1) {
            innerFieldLength = dataArrayType.getLength(array[i]);
        }
        // it may happen that the size of field depends on the box flags,
        // we need to count is having box and first structure constructed

        this.localPos += innerFieldLength;
    }
    return array;
};

// ---------- Abstract Container Box -------------------------------
mp4lib.boxes.ContainerBox = function(boxType, size) {
    mp4lib.boxes.Box.call(this, boxType, size);
    this.boxes = [];
};

mp4lib.boxes.ContainerBox.prototype = Object.create(mp4lib.boxes.Box.prototype);
mp4lib.boxes.ContainerBox.prototype.constructor = mp4lib.boxes.ContainerBox;

mp4lib.boxes.ContainerBox.prototype.computeLength = function() {
    mp4lib.boxes.Box.prototype.computeLength.call(this);
    var i = 0;
    for (i = 0; i < this.boxes.length; i++) {
        this.boxes[i].computeLength();
        this.size += this.boxes[i].size;
    }
};

mp4lib.boxes.ContainerBox.prototype.write = function(data, pos) {
    mp4lib.boxes.Box.prototype.write.call(this, data, pos);
    var i = 0;

    for (i = 0; i < this.boxes.length; i++) {
        this.localPos = this.boxes[i].write(data, this.localPos);
    }

    return this.localPos;
};

mp4lib.boxes.ContainerBox.prototype.read = function(data, pos, end) {
    var size = 0,
        uuidFieldPos = 0,
        uuid = null,
        boxtype,
        box;

    while (pos < end) {
        // Read box size
        size = mp4lib.fields.FIELD_UINT32.read(data, pos);

        // Read boxtype
        boxtype = mp4lib.fields.readString(data, pos + 4, 4);

        // Extented type?
        if (boxtype === "uuid") {
            uuidFieldPos = (size == 1) ? 16 : 8;
            uuid = new mp4lib.fields.ArrayField(mp4lib.fields.FIELD_INT8, 16).read(data, pos + uuidFieldPos, pos + uuidFieldPos + 16);
            uuid = JSON.stringify(uuid);
        }

        box = mp4lib.createBox(boxtype, size, uuid);
        if (boxtype === "uuid") {
            pos = box.read(data, pos + mp4lib.fields.FIELD_INT8.getLength() * 16 + 8, pos + size);
            uuid = null;
        } else {
            pos = box.read(data, pos + 8, pos + size);
        }

        // in debug mode, sourcebuffer is copied to each box,
        // so any invalid deserializations may be found by comparing
        // source buffer with serialized box
        if (mp4lib.debug) {
            box.__sourceBuffer = data.subarray(pos - box.size, pos);
        }
        
        //if boxtype is unknown, don't add it to the list box
        if (box.boxtype) {
            this.boxes.push(box);
        }

        if (box.size <= 0 || box.size === null) {
            throw new mp4lib.ParseException('Problem on size of box ' + box.boxtype +
                ', parsing stopped to avoid infinite loop');
        }
    }

    return pos;
};

// ---------- Full Box -------------------------------
mp4lib.boxes.FullBox = function(boxType, size, uuid) {
    mp4lib.boxes.Box.call(this, boxType, size, uuid);
    this.version = null;
    this.flags = null;
};

mp4lib.boxes.FullBox.prototype = Object.create(mp4lib.boxes.Box.prototype);
mp4lib.boxes.FullBox.prototype.constructor = mp4lib.boxes.FullBox;

mp4lib.boxes.FullBox.prototype.read = function(data, pos, end) {
    this.localPos = pos;
    this.localEnd = end;
    this.version = this._readData(data, mp4lib.fields.FIELD_INT8);
    this.flags = this._readData(data, mp4lib.fields.FIELD_BIT24);
};

mp4lib.boxes.FullBox.prototype.write = function(data, pos) {
    mp4lib.boxes.Box.prototype.write.call(this, data, pos);

    this._writeData(data, mp4lib.fields.FIELD_INT8, this.version);
    this._writeData(data, mp4lib.fields.FIELD_BIT24, this.flags);
};

mp4lib.boxes.FullBox.prototype.getFullBoxAttributesLength = function() {
    this.size += mp4lib.fields.FIELD_INT8.getLength() + mp4lib.fields.FIELD_BIT24.getLength(); //version and flags size
};

mp4lib.boxes.FullBox.prototype.computeLength = function() {
    mp4lib.boxes.Box.prototype.computeLength.call(this);
    mp4lib.boxes.FullBox.prototype.getFullBoxAttributesLength.call(this);
};

// ---------- Abstract Container FullBox -------------------------------
mp4lib.boxes.ContainerFullBox = function(boxType, size) {
    mp4lib.boxes.FullBox.call(this, boxType, size);
    this.boxes = [];
};

mp4lib.boxes.ContainerFullBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);
mp4lib.boxes.ContainerFullBox.prototype.constructor = mp4lib.boxes.ContainerFullBox;

mp4lib.boxes.ContainerFullBox.prototype.computeLength = function(isEntryCount) {
    mp4lib.boxes.FullBox.prototype.computeLength.call(this);
    var i = 0;

    if (isEntryCount) {
        this.size += mp4lib.fields.FIELD_UINT32.getLength();
    }

    for (i = 0; i < this.boxes.length; i++) {
        this.boxes[i].computeLength();
        this.size += this.boxes[i].size;
    }
};

mp4lib.boxes.ContainerFullBox.prototype.read = function(data, pos, end, isEntryCount) {
    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);
    var size = 0,
        uuidFieldPos = 0,
        uuid = null,
        boxtype, box;

    if (isEntryCount) {
        this.entry_count = this._readData(data, mp4lib.fields.FIELD_UINT32);
    }

    while (this.localPos < this.localEnd) {
        // Read box size
        size = mp4lib.fields.FIELD_UINT32.read(data, this.localPos);

        // Read boxtype
        boxtype = mp4lib.fields.readString(data, this.localPos + 4, 4);

        // Extented type?
        if (boxtype == "uuid") {
            uuidFieldPos = (size == 1) ? 16 : 8;
            uuid = new mp4lib.fields.ArrayField(mp4lib.fields.FIELD_INT8, 16).read(data, this.localPos + uuidFieldPos, this.localPos + uuidFieldPos + 16);
            uuid = JSON.stringify(uuid);
        }

        box = mp4lib.createBox(boxtype, size, uuid);
        if (boxtype === "uuid") {
            this.localPos = box.read(data, this.localPos + mp4lib.fields.FIELD_INT8.getLength() * 16 + 8, this.localPos + size);
            uuid = null;
        } else {
            this.localPos = box.read(data, this.localPos + 8, this.localPos + size);
        }

        // in debug mode, sourcebuffer is copied to each box,
        // so any invalid deserializations may be found by comparing
        // source buffer with serialized box
        if (mp4lib.debug) {
            box.__sourceBuffer = data.subarray(this.localPos - box.size, this.localPos);
        }

        if (box.boxtype) {
            this.boxes.push(box);
        }

        if (box.size <= 0 || box.size === null) {
            throw new mp4lib.ParseException('Problem on size of box ' + box.boxtype +
                ', parsing stopped to avoid infinite loop');
        }
    }

    return this.localPos;
};

mp4lib.boxes.ContainerFullBox.prototype.write = function(data, pos, isEntryCount) {
    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);
    var i = 0;

    if (isEntryCount === true) {
        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.entry_count);
    }

    for (i = 0; i < this.boxes.length; i++) {
        this.localPos = this.boxes[i].write(data, this.localPos);
    }

    return this.localPos;
};

// ----------- Unknown Box -----------------------------

mp4lib.boxes.UnknownBox = function(size) {
    mp4lib.boxes.Box.call(this, null, size);
};

mp4lib.boxes.UnknownBox.prototype = Object.create(mp4lib.boxes.Box.prototype);
mp4lib.boxes.UnknownBox.prototype.constructor = mp4lib.boxes.UnknownBox;

mp4lib.boxes.UnknownBox.prototype.read = function(data, pos, end) {
    this.localPos = pos;
    this.localEnd = end;

    this.unrecognized_data = data.subarray(this.localPos, this.localEnd);

    return this.localEnd;
};

mp4lib.boxes.UnknownBox.prototype.write = function(data, pos) {
    mp4lib.boxes.Box.prototype.write.call(this, data, pos);

    this._writeBuffer(data, this.unrecognized_data, this.unrecognized_data.length);

    return this.localPos;
};

mp4lib.boxes.UnknownBox.prototype.computeLength = function() {
    mp4lib.boxes.Box.prototype.computeLength.call(this);
    this.size += this.unrecognized_data.length;
};

// --------------------------- ftyp ----------------------------------

mp4lib.boxes.FileTypeBox = function(size) {
    mp4lib.boxes.Box.call(this, 'ftyp', size);
};

mp4lib.boxes.FileTypeBox.prototype = Object.create(mp4lib.boxes.Box.prototype);
mp4lib.boxes.FileTypeBox.prototype.constructor = mp4lib.boxes.FileTypeBox;

mp4lib.boxes.FileTypeBox.prototype.computeLength = function() {
    mp4lib.boxes.Box.prototype.computeLength.call(this);
    this.size += mp4lib.fields.FIELD_INT32.getLength() * 2 + mp4lib.fields.FIELD_INT32.getLength() * this.compatible_brands.length;
};

mp4lib.boxes.FileTypeBox.prototype.read = function(data, pos, end) {
    this.localPos = pos;
    this.localEnd = end;

    this.major_brand = this._readData(data, mp4lib.fields.FIELD_INT32);
    this.minor_brand = this._readData(data, mp4lib.fields.FIELD_INT32);
    this.compatible_brands = this._readArrayData(data, mp4lib.fields.FIELD_INT32);

    return this.localPos;
};

mp4lib.boxes.FileTypeBox.prototype.write = function(data, pos) {
    mp4lib.boxes.Box.prototype.write.call(this, data, pos);

    this._writeData(data, mp4lib.fields.FIELD_INT32, this.major_brand);
    this._writeData(data, mp4lib.fields.FIELD_INT32, this.minor_brand);
    this._writeArrayData(data, mp4lib.fields.FIELD_INT32, this.compatible_brands);

    return this.localPos;
};
// --------------------------- moov ----------------------------------

mp4lib.boxes.MovieBox = function(size) {
    mp4lib.boxes.ContainerBox.call(this, 'moov', size);
};

mp4lib.boxes.MovieBox.prototype = Object.create(mp4lib.boxes.ContainerBox.prototype);
mp4lib.boxes.MovieBox.prototype.constructor = mp4lib.boxes.MovieBox;

// --------------------------- moof ----------------------------------
mp4lib.boxes.MovieFragmentBox = function(size) {
    mp4lib.boxes.ContainerBox.call(this, 'moof', size);
};

mp4lib.boxes.MovieFragmentBox.prototype = Object.create(mp4lib.boxes.ContainerBox.prototype);
mp4lib.boxes.MovieFragmentBox.prototype.constructor = mp4lib.boxes.MovieFragmentBox;

// --------------------------- mfra ----------------------------------
mp4lib.boxes.MovieFragmentRandomAccessBox = function(size) {
    mp4lib.boxes.ContainerBox.call(this, 'mfra', size);
};

mp4lib.boxes.MovieFragmentRandomAccessBox.prototype = Object.create(mp4lib.boxes.ContainerBox.prototype);
mp4lib.boxes.MovieFragmentRandomAccessBox.prototype.constructor = mp4lib.boxes.MovieFragmentRandomAccessBox;

// --------------------------- udta ----------------------------------
mp4lib.boxes.UserDataBox = function(size) {
    mp4lib.boxes.ContainerBox.call(this, 'udta', size);
};

mp4lib.boxes.UserDataBox.prototype = Object.create(mp4lib.boxes.ContainerBox.prototype);
mp4lib.boxes.UserDataBox.prototype.constructor = mp4lib.boxes.UserDataBox;

// --------------------------- trak ----------------------------------
mp4lib.boxes.TrackBox = function(size) {
    mp4lib.boxes.ContainerBox.call(this, 'trak', size);
};

mp4lib.boxes.TrackBox.prototype = Object.create(mp4lib.boxes.ContainerBox.prototype);
mp4lib.boxes.TrackBox.prototype.constructor = mp4lib.boxes.TrackBox;

// --------------------------- edts ----------------------------------
mp4lib.boxes.EditBox = function(size) {
    mp4lib.boxes.ContainerBox.call(this, 'edts', size);
};

mp4lib.boxes.EditBox.prototype = Object.create(mp4lib.boxes.ContainerBox.prototype);
mp4lib.boxes.EditBox.prototype.constructor = mp4lib.boxes.EditBox;

// --------------------------- mdia ----------------------------------
mp4lib.boxes.MediaBox = function(size) {
    mp4lib.boxes.ContainerBox.call(this, 'mdia', size);
};

mp4lib.boxes.MediaBox.prototype = Object.create(mp4lib.boxes.ContainerBox.prototype);
mp4lib.boxes.MediaBox.prototype.constructor = mp4lib.boxes.MediaBox;

// --------------------------- minf ----------------------------------
mp4lib.boxes.MediaInformationBox = function(size) {
    mp4lib.boxes.ContainerBox.call(this, 'minf', size);
};

mp4lib.boxes.MediaInformationBox.prototype = Object.create(mp4lib.boxes.ContainerBox.prototype);
mp4lib.boxes.MediaInformationBox.prototype.constructor = mp4lib.boxes.MediaInformationBox;

// --------------------------- dinf ----------------------------------
mp4lib.boxes.DataInformationBox = function(size) {
    mp4lib.boxes.ContainerBox.call(this, 'dinf', size);
};

mp4lib.boxes.DataInformationBox.prototype = Object.create(mp4lib.boxes.ContainerBox.prototype);
mp4lib.boxes.DataInformationBox.prototype.constructor = mp4lib.boxes.DataInformationBox;

// --------------------------- stbl ----------------------------------
mp4lib.boxes.SampleTableBox = function(size) {
    mp4lib.boxes.ContainerBox.call(this, 'stbl', size);
};

mp4lib.boxes.SampleTableBox.prototype = Object.create(mp4lib.boxes.ContainerBox.prototype);
mp4lib.boxes.SampleTableBox.prototype.constructor = mp4lib.boxes.SampleTableBox;

// --------------------------- mvex ----------------------------------
mp4lib.boxes.MovieExtendsBox = function(size) {
    mp4lib.boxes.ContainerBox.call(this, 'mvex', size);
};

mp4lib.boxes.MovieExtendsBox.prototype = Object.create(mp4lib.boxes.ContainerBox.prototype);
mp4lib.boxes.MovieExtendsBox.prototype.constructor = mp4lib.boxes.MovieExtendsBox;

// --------------------------- traf ----------------------------------
mp4lib.boxes.TrackFragmentBox = function(size) {
    mp4lib.boxes.ContainerBox.call(this, 'traf', size);
};

mp4lib.boxes.TrackFragmentBox.prototype = Object.create(mp4lib.boxes.ContainerBox.prototype);
mp4lib.boxes.TrackFragmentBox.prototype.constructor = mp4lib.boxes.TrackFragmentBox;

// --------------------------- meta -----------------------------
mp4lib.boxes.MetaBox = function(size) {
    mp4lib.boxes.ContainerFullBox.call(this, 'meta', size);
};

mp4lib.boxes.MetaBox.prototype = Object.create(mp4lib.boxes.ContainerFullBox.prototype);
mp4lib.boxes.MetaBox.prototype.constructor = mp4lib.boxes.MetaBox;

mp4lib.boxes.MetaBox.prototype.computeLength = function() {
    mp4lib.boxes.ContainerFullBox.prototype.computeLength.call(this, false);
};

mp4lib.boxes.MetaBox.prototype.read = function(data, pos, end) {
    return mp4lib.boxes.ContainerFullBox.prototype.read.call(this, data, pos, end, false);
};

mp4lib.boxes.MetaBox.prototype.write = function(data, pos) {
    return mp4lib.boxes.ContainerFullBox.prototype.write.call(this, data, pos, false);
};

// --------------------------- mvhd ----------------------------------
mp4lib.boxes.MovieHeaderBox = function(size) {
    mp4lib.boxes.FullBox.call(this, 'mvhd', size);
};

mp4lib.boxes.MovieHeaderBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);
mp4lib.boxes.MovieHeaderBox.prototype.constructor = mp4lib.boxes.MovieHeaderBox;

mp4lib.boxes.MovieHeaderBox.prototype.computeLength = function() {
    mp4lib.boxes.FullBox.prototype.computeLength.call(this);

    this.size += mp4lib.fields.FIELD_INT32.getLength() /*rate size*/ + mp4lib.fields.FIELD_INT16.getLength() * 2 /*volume size and reserved size*/ ;
    this.size += mp4lib.fields.FIELD_INT32.getLength() * 2 /*reserved_2 size*/ + mp4lib.fields.FIELD_INT32.getLength() * 9 /*matrix size*/ ;
    this.size += mp4lib.fields.FIELD_BIT32.getLength() * 6 /*pre_defined size*/ + mp4lib.fields.FIELD_UINT32.getLength() /*next_track_ID size*/ ;
    if (this.version === 1) {
        this.size += mp4lib.fields.FIELD_UINT64.getLength() * 3 + mp4lib.fields.FIELD_UINT32.getLength();
    } else {
        this.size += mp4lib.fields.FIELD_UINT32.getLength() * 4;
    }
};

mp4lib.boxes.MovieHeaderBox.prototype.write = function(data, pos) {
    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);

    if (this.version === 1) {
        this._writeData(data, mp4lib.fields.FIELD_UINT64, this.creation_time);
        this._writeData(data, mp4lib.fields.FIELD_UINT64, this.modification_time);
        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.timescale);
        this._writeData(data, mp4lib.fields.FIELD_UINT64, this.duration);
    } else {
        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.creation_time);
        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.modification_time);
        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.timescale);
        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.duration);
    }

    this._writeData(data, mp4lib.fields.FIELD_INT32, this.rate);
    this._writeData(data, mp4lib.fields.FIELD_INT16, this.volume);
    this._writeData(data, mp4lib.fields.FIELD_INT16, this.reserved);
    this._writeArrayData(data, mp4lib.fields.FIELD_INT32, this.reserved_2);
    this._writeArrayData(data, mp4lib.fields.FIELD_INT32, this.matrix);
    this._writeArrayData(data, mp4lib.fields.FIELD_BIT32, this.pre_defined);
    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.next_track_ID);

    return this.localPos;
};

mp4lib.boxes.MovieHeaderBox.prototype.read = function(data, pos, end) {
    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);

    if (this.version == 1) {
        this.creation_time = this._readData(data, mp4lib.fields.FIELD_UINT64);
        this.modification_time = this._readData(data, mp4lib.fields.FIELD_UINT64);
        this.timescale = this._readData(data, mp4lib.fields.FIELD_UINT32);
        this.duration = this._readData(data, mp4lib.fields.FIELD_UINT64);
    } else {
        this.creation_time = this._readData(data, mp4lib.fields.FIELD_UINT32);
        this.modification_time = this._readData(data, mp4lib.fields.FIELD_UINT32);
        this.timescale = this._readData(data, mp4lib.fields.FIELD_UINT32);
        this.duration = this._readData(data, mp4lib.fields.FIELD_UINT32);
    }

    this.rate = this._readData(data, mp4lib.fields.FIELD_INT32);
    this.volume = this._readData(data, mp4lib.fields.FIELD_INT16);
    this.reserved = this._readData(data, mp4lib.fields.FIELD_INT16);
    this.reserved_2 = this._readArrayFieldData(data, mp4lib.fields.FIELD_INT32, 2);
    this.matrix = this._readArrayFieldData(data, mp4lib.fields.FIELD_INT32, 9);
    this.pre_defined = this._readArrayFieldData(data, mp4lib.fields.FIELD_BIT32, 6);
    this.next_track_ID = this._readData(data, mp4lib.fields.FIELD_UINT32);

    return this.localPos;
};

// --------------------------- mdat ----------------------------------
mp4lib.boxes.MediaDataBox = function(size) {
    mp4lib.boxes.Box.call(this, 'mdat', size);
};

mp4lib.boxes.MediaDataBox.prototype = Object.create(mp4lib.boxes.Box.prototype);
mp4lib.boxes.MediaDataBox.prototype.constructor = mp4lib.boxes.MediaDataBox;

mp4lib.boxes.MediaDataBox.prototype.computeLength = function() {
    mp4lib.boxes.Box.prototype.computeLength.call(this);
    this.size += this.data.length;
};

mp4lib.boxes.MediaDataBox.prototype.read = function(data, pos, end) {
    this.data = data.subarray(pos, end);

    return end;
};

mp4lib.boxes.MediaDataBox.prototype.write = function(data, pos) {
    mp4lib.boxes.Box.prototype.write.call(this, data, pos);

    this._writeBuffer(data, this.data, this.data.length);

    return this.localPos;
};

// --------------------------- free ----------------------------------
mp4lib.boxes.FreeSpaceBox = function(size) {
    mp4lib.boxes.Box.call(this, 'free', size);
};

mp4lib.boxes.FreeSpaceBox.prototype = Object.create(mp4lib.boxes.Box.prototype);
mp4lib.boxes.FreeSpaceBox.prototype.constructor = mp4lib.boxes.FreeSpaceBox;

mp4lib.boxes.FreeSpaceBox.prototype.computeLength = function() {
    mp4lib.boxes.Box.prototype.computeLength.call(this);
    this.size += this.data.length;
};

mp4lib.boxes.FreeSpaceBox.prototype.read = function(data, pos, end) {
    this.localPos = pos;
    this.localEnd = end;
    this.data = data.subarray(this.localPos, this.localEnd);
    return this.localEnd;
};

mp4lib.boxes.FreeSpaceBox.prototype.write = function(data, pos) {
    mp4lib.boxes.Box.prototype.write.call(this, data, pos);

    this._writeBuffer(data, this.data, this.data.length);

    return this.localPos;
};

// --------------------------- sidx ----------------------------------
mp4lib.boxes.SegmentIndexBox = function(size) {
    mp4lib.boxes.FullBox.call(this, 'sidx', size);
};

mp4lib.boxes.SegmentIndexBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);
mp4lib.boxes.SegmentIndexBox.prototype.constructor = mp4lib.boxes.SegmentIndexBox;

mp4lib.boxes.SegmentIndexBox.prototype.computeLength = function() {
    mp4lib.boxes.FullBox.prototype.computeLength.call(this);

    this.size += mp4lib.fields.FIELD_UINT32.getLength() * 2; /* reference_ID and timescale size*/
    if (this.version === 1) {
        this.size += mp4lib.fields.FIELD_UINT64.getLength() * 2; /* earliest_presentation_time and first_offset size*/
    } else {
        this.size += mp4lib.fields.FIELD_UINT32.getLength() * 2; /* earliest_presentation_time and first_offset size*/
    }
    this.size += mp4lib.fields.FIELD_UINT16.getLength(); /* reserved size*/
    this.size += mp4lib.fields.FIELD_UINT16.getLength(); /* reference_count size*/
    this.size += (mp4lib.fields.FIELD_UINT64.getLength() /* reference_info size*/ + mp4lib.fields.FIELD_UINT32.getLength() /* SAP size*/ ) * this.reference_count;
};


mp4lib.boxes.SegmentIndexBox.prototype.read = function(data, pos, end) {
    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);

    var i = 0,
        struct = {};

    this.reference_ID = this._readData(data, mp4lib.fields.FIELD_UINT32);
    this.timescale = this._readData(data, mp4lib.fields.FIELD_UINT32);

    if (this.version === 1) {
        this.earliest_presentation_time = this._readData(data, mp4lib.fields.FIELD_UINT64);
        this.first_offset = this._readData(data, mp4lib.fields.FIELD_UINT64);
    } else {
        this.earliest_presentation_time = this._readData(data, mp4lib.fields.FIELD_UINT32);
        this.first_offset = this._readData(data, mp4lib.fields.FIELD_UINT32);
    }
    this.reserved = this._readData(data, mp4lib.fields.FIELD_UINT16);
    this.reference_count = this._readData(data, mp4lib.fields.FIELD_UINT16);

    this.references = [];

    for (i = 0; i < this.reference_count; i++) {
        struct = {};

        struct.reference_info = this._readData(data, mp4lib.fields.FIELD_UINT64);
        struct.SAP = this._readData(data, mp4lib.fields.FIELD_UINT32);

        this.references.push(struct);
    }

    return this.localPos;
};

mp4lib.boxes.SegmentIndexBox.prototype.write = function(data, pos) {
    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);
    var i = 0;

    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.reference_ID);
    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.timescale);

    if (this.version === 1) {
        this._writeData(data, mp4lib.fields.FIELD_UINT64, this.earliest_presentation_time);
        this._writeData(data, mp4lib.fields.FIELD_UINT64, this.first_offset);
    } else {
        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.earliest_presentation_time);
        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.first_offset);
    }

    this._writeData(data, mp4lib.fields.FIELD_UINT16, this.reserved);
    this._writeData(data, mp4lib.fields.FIELD_UINT16, this.reference_count);

    for (i = 0; i < this.reference_count; i++) {
        this._writeData(data, mp4lib.fields.FIELD_UINT64, this.references[i].reference_info);
        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.references[i].SAP);
    }
    return this.localPos;
};

// --------------------------- tkhd ----------------------------------
mp4lib.boxes.TrackHeaderBox = function(size) {
    mp4lib.boxes.FullBox.call(this, 'tkhd', size);
};

mp4lib.boxes.TrackHeaderBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);
mp4lib.boxes.TrackHeaderBox.prototype.constructor = mp4lib.boxes.TrackHeaderBox;

mp4lib.boxes.TrackHeaderBox.prototype.computeLength = function() {
    mp4lib.boxes.FullBox.prototype.computeLength.call(this);
    this.size += mp4lib.fields.FIELD_INT16.getLength() * 4 + mp4lib.fields.FIELD_INT32.getLength() * 2 + mp4lib.fields.FIELD_UINT32.getLength() * 2 + mp4lib.fields.FIELD_INT32.getLength() * 9;
    if (this.version == 1) {
        this.size += mp4lib.fields.FIELD_UINT64.getLength() * 3 + mp4lib.fields.FIELD_UINT32.getLength() * 2;
    } else {
        this.size += mp4lib.fields.FIELD_UINT32.getLength() * 5;
    }
};

mp4lib.boxes.TrackHeaderBox.prototype.read = function(data, pos, end) {
    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);

    if (this.version === 1) {
        this.creation_time = this._readData(data, mp4lib.fields.FIELD_UINT64);
        this.modification_time = this._readData(data, mp4lib.fields.FIELD_UINT64);
        this.track_id = this._readData(data, mp4lib.fields.FIELD_UINT32);
        this.reserved = this._readData(data, mp4lib.fields.FIELD_UINT32);
        this.duration = this._readData(data, mp4lib.fields.FIELD_UINT64);
    } else {
        this.creation_time = this._readData(data, mp4lib.fields.FIELD_UINT32);
        this.modification_time = this._readData(data, mp4lib.fields.FIELD_UINT32);
        this.track_id = this._readData(data, mp4lib.fields.FIELD_UINT32);
        this.reserved = this._readData(data, mp4lib.fields.FIELD_UINT32);
        this.duration = this._readData(data, mp4lib.fields.FIELD_UINT32);
    }

    this.reserved_2 = this._readArrayFieldData(data, mp4lib.fields.FIELD_UINT32, 2);
    this.layer = this._readData(data, mp4lib.fields.FIELD_INT16);
    this.alternate_group = this._readData(data, mp4lib.fields.FIELD_INT16);
    this.volume = this._readData(data, mp4lib.fields.FIELD_INT16);
    this.reserved_3 = this._readData(data, mp4lib.fields.FIELD_INT16);
    this.matrix = this._readArrayFieldData(data, mp4lib.fields.FIELD_INT32, 9);
    this.width = this._readData(data, mp4lib.fields.FIELD_INT32);
    this.height = this._readData(data, mp4lib.fields.FIELD_INT32);
    return this.localPos;
};

mp4lib.boxes.TrackHeaderBox.prototype.write = function(data, pos) {
    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);

    if (this.version === 1) {
        this._writeData(data, mp4lib.fields.FIELD_UINT64, this.creation_time);
        this._writeData(data, mp4lib.fields.FIELD_UINT64, this.modification_time);
        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.track_id);
        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.reserved);
        this._writeData(data, mp4lib.fields.FIELD_UINT64, this.duration);
    } else {
        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.creation_time);
        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.modification_time);
        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.track_id);
        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.reserved);
        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.duration);
    }

    this._writeArrayData(data, mp4lib.fields.FIELD_UINT32, this.reserved_2);
    this._writeData(data, mp4lib.fields.FIELD_INT16, this.layer);
    this._writeData(data, mp4lib.fields.FIELD_INT16, this.alternate_group);
    this._writeData(data, mp4lib.fields.FIELD_INT16, this.volume);
    this._writeData(data, mp4lib.fields.FIELD_INT16, this.reserved_3);
    this._writeArrayData(data, mp4lib.fields.FIELD_INT32, this.matrix);
    this._writeData(data, mp4lib.fields.FIELD_INT32, this.width);
    this._writeData(data, mp4lib.fields.FIELD_INT32, this.height);
    return this.localPos;
};

// --------------------------- mdhd ----------------------------------
mp4lib.boxes.MediaHeaderBox = function(size) {
    mp4lib.boxes.FullBox.call(this, 'mdhd', size);
};

mp4lib.boxes.MediaHeaderBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);
mp4lib.boxes.MediaHeaderBox.prototype.constructor = mp4lib.boxes.MediaHeaderBox;

mp4lib.boxes.MediaHeaderBox.prototype.computeLength = function() {
    mp4lib.boxes.FullBox.prototype.computeLength.call(this);
    this.size += mp4lib.fields.FIELD_UINT16.getLength() * 2;
    if (this.version == 1) {
        this.size += mp4lib.fields.FIELD_UINT64.getLength() * 3 + mp4lib.fields.FIELD_UINT32.getLength();
    } else {
        this.size += mp4lib.fields.FIELD_UINT32.getLength() * 4;
    }
};

mp4lib.boxes.MediaHeaderBox.prototype.read = function(data, pos, end) {
    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);

    if (this.version === 1) {
        this.creation_time = this._readData(data, mp4lib.fields.FIELD_UINT64);
        this.modification_time = this._readData(data, mp4lib.fields.FIELD_UINT64);
        this.timescale = this._readData(data, mp4lib.fields.FIELD_UINT32);
        this.duration = this._readData(data, mp4lib.fields.FIELD_UINT64);
    } else {
        this.creation_time = this._readData(data, mp4lib.fields.FIELD_UINT32);
        this.modification_time = this._readData(data, mp4lib.fields.FIELD_UINT32);
        this.timescale = this._readData(data, mp4lib.fields.FIELD_UINT32);
        this.duration = this._readData(data, mp4lib.fields.FIELD_UINT32);
    }

    this.language = this._readData(data, mp4lib.fields.FIELD_UINT16);
    this.pre_defined = this._readData(data, mp4lib.fields.FIELD_UINT16);
    return this.localPos;
};

mp4lib.boxes.MediaHeaderBox.prototype.write = function(data, pos) {
    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);

    if (this.version === 1) {
        this._writeData(data, mp4lib.fields.FIELD_UINT64, this.creation_time);
        this._writeData(data, mp4lib.fields.FIELD_UINT64, this.modification_time);
        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.timescale);
        this._writeData(data, mp4lib.fields.FIELD_UINT64, this.duration);
    } else {
        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.creation_time);
        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.modification_time);
        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.timescale);
        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.duration);
    }

    this._writeData(data, mp4lib.fields.FIELD_UINT16, this.language);
    this._writeData(data, mp4lib.fields.FIELD_UINT16, this.pre_defined);
    return this.localPos;
};

// --------------------------- mehd ----------------------------------
mp4lib.boxes.MovieExtendsHeaderBox = function(size) {
    mp4lib.boxes.FullBox.call(this, 'mehd', size);
};

mp4lib.boxes.MovieExtendsHeaderBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);
mp4lib.boxes.MovieExtendsHeaderBox.prototype.constructor = mp4lib.boxes.MovieExtendsHeaderBox;

mp4lib.boxes.MovieExtendsHeaderBox.prototype.computeLength = function() {
    mp4lib.boxes.FullBox.prototype.computeLength.call(this);
    if (this.version == 1) {
        this.size += mp4lib.fields.FIELD_UINT64.getLength();
    } else {
        this.size += mp4lib.fields.FIELD_UINT32.getLength();
    }
};

mp4lib.boxes.MovieExtendsHeaderBox.prototype.read = function(data, pos, end) {
    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);

    if (this.version === 1) {
        this.fragment_duration = this._readData(data, mp4lib.fields.FIELD_UINT64);
    } else {
        this.fragment_duration = this._readData(data, mp4lib.fields.FIELD_UINT32);
    }
    return this.localPos;
};

mp4lib.boxes.MovieExtendsHeaderBox.prototype.write = function(data, pos) {
    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);

    if (this.version === 1) {
        this._writeData(data, mp4lib.fields.FIELD_UINT64, this.fragment_duration);
    } else {
        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.fragment_duration);
    }
    return this.localPos;
};

// --------------------------- hdlr --------------------------------
mp4lib.boxes.HandlerBox = function(size) {
    mp4lib.boxes.FullBox.call(this, 'hdlr', size);
};

mp4lib.boxes.HandlerBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);
mp4lib.boxes.HandlerBox.prototype.constructor = mp4lib.boxes.HandlerBox;

//add NAN
mp4lib.boxes.HandlerBox.prototype.HANDLERTYPEVIDEO = "vide";
mp4lib.boxes.HandlerBox.prototype.HANDLERTYPEAUDIO = "soun";
mp4lib.boxes.HandlerBox.prototype.HANDLERTYPETEXT = "meta";
mp4lib.boxes.HandlerBox.prototype.HANDLERVIDEONAME = "Video Track";
mp4lib.boxes.HandlerBox.prototype.HANDLERAUDIONAME = "Audio Track";
mp4lib.boxes.HandlerBox.prototype.HANDLERTEXTNAME = "Text Track";

mp4lib.boxes.HandlerBox.prototype.computeLength = function() {
    mp4lib.boxes.FullBox.prototype.computeLength.call(this);
    this.size += mp4lib.fields.FIELD_UINT32.getLength() * 2 + mp4lib.fields.FIELD_UINT32.getLength() * 3 +
        mp4lib.fields.FIELD_STRING.getLength(this.name);
};

mp4lib.boxes.HandlerBox.prototype.read = function(data, pos, end) {
    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);

    this.pre_defined = this._readData(data, mp4lib.fields.FIELD_UINT32);
    this.handler_type = this._readData(data, mp4lib.fields.FIELD_UINT32);
    this.reserved = this._readArrayFieldData(data, mp4lib.fields.FIELD_UINT32, 3);
    this.name = this._readData(data, mp4lib.fields.FIELD_STRING);
    return this.localPos;
};

mp4lib.boxes.HandlerBox.prototype.write = function(data, pos) {
    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);

    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.pre_defined);
    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.handler_type);
    this._writeArrayData(data, mp4lib.fields.FIELD_UINT32, this.reserved);
    this._writeData(data, mp4lib.fields.FIELD_STRING, this.name);
    return this.localPos;
};

// --------------------------- stts ----------------------------------
mp4lib.boxes.TimeToSampleBox = function(size) {
    mp4lib.boxes.FullBox.call(this, 'stts', size);
};

mp4lib.boxes.TimeToSampleBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);
mp4lib.boxes.TimeToSampleBox.prototype.constructor = mp4lib.boxes.TimeToSampleBox;

mp4lib.boxes.TimeToSampleBox.prototype.computeLength = function() {
    mp4lib.boxes.FullBox.prototype.computeLength.call(this);
    this.size += mp4lib.fields.FIELD_UINT32.getLength();
    this.size += this.entry_count * (mp4lib.fields.FIELD_UINT32.getLength() * 2);
};

mp4lib.boxes.TimeToSampleBox.prototype.read = function(data, pos, end) {
    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);
    var i = 0,
        struct = {};

    this.entry_count = this._readData(data, mp4lib.fields.FIELD_UINT32);

    this.entry = [];

    for (i = 0; i < this.entry_count; i++) {
        struct = {};

        struct.sample_count = this._readData(data, mp4lib.fields.FIELD_UINT32);
        struct.sample_delta = this._readData(data, mp4lib.fields.FIELD_UINT32);

        this.entry.push(struct);
    }
    return this.localPos;
};

mp4lib.boxes.TimeToSampleBox.prototype.write = function(data, pos) {
    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);
    var i = 0;

    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.entry_count);

    for (i = 0; i < this.entry_count; i++) {
        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.entry[i].sample_count);
        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.entry[i].sample_delta);
    }
    return this.localPos;
};

// --------------------------- stsc ----------------------------------
mp4lib.boxes.SampleToChunkBox = function(size) {
    mp4lib.boxes.FullBox.call(this, 'stsc', size);
};

mp4lib.boxes.SampleToChunkBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);
mp4lib.boxes.SampleToChunkBox.prototype.constructor = mp4lib.boxes.SampleToChunkBox;

mp4lib.boxes.SampleToChunkBox.prototype.computeLength = function() {
    mp4lib.boxes.FullBox.prototype.computeLength.call(this);
    this.size += mp4lib.fields.FIELD_UINT32.getLength();
    this.size += this.entry_count * (mp4lib.fields.FIELD_UINT32.getLength() * 3);
};

mp4lib.boxes.SampleToChunkBox.prototype.read = function(data, pos, end) {
    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);
    var i = 0,
        struct = {};

    this.entry_count = this._readData(data, mp4lib.fields.FIELD_UINT32);

    this.entry = [];

    for (i = 0; i < this.entry_count; i++) {
        struct = {};

        struct.first_chunk = this._readData(data, mp4lib.fields.FIELD_UINT32);
        struct.samples_per_chunk = this._readData(data, mp4lib.fields.FIELD_UINT32);
        struct.samples_description_index = this._readData(data, mp4lib.fields.FIELD_UINT32);

        this.entry.push(struct);
    }
    return this.localPos;
};

mp4lib.boxes.SampleToChunkBox.prototype.write = function(data, pos) {
    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);
    var i = 0;

    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.entry_count);
    for (i = 0; i < this.entry_count; i++) {
        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.entry[i].first_chunk);
        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.entry[i].samples_per_chunk);
        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.entry[i].samples_description_index);
    }
    return this.localPos;
};

// --------------------------- stco ----------------------------------
mp4lib.boxes.ChunkOffsetBox = function(size) {
    mp4lib.boxes.FullBox.call(this, 'stco', size);
};

mp4lib.boxes.ChunkOffsetBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);
mp4lib.boxes.ChunkOffsetBox.prototype.constructor = mp4lib.boxes.ChunkOffsetBox;

mp4lib.boxes.ChunkOffsetBox.prototype.computeLength = function() {
    mp4lib.boxes.FullBox.prototype.computeLength.call(this);
    this.size += mp4lib.fields.FIELD_UINT32.getLength() + this.entry_count * mp4lib.fields.FIELD_UINT32.getLength();
};

mp4lib.boxes.ChunkOffsetBox.prototype.read = function(data, pos, end) {
    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);

    this.entry_count = this._readData(data, mp4lib.fields.FIELD_UINT32);
    this.chunk_offset = this._readArrayFieldData(data, mp4lib.fields.FIELD_UINT32, this.entry_count);
    return this.localPos;
};

mp4lib.boxes.ChunkOffsetBox.prototype.write = function(data, pos) {
    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);
    var i = 0;

    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.entry_count);

    for (i = 0; i < this.entry_count; i++) {
        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.chunk_offset[i]);
    }
    return this.localPos;
};

// --------------------------- trex ----------------------------------
mp4lib.boxes.TrackExtendsBox = function(size) {
    mp4lib.boxes.FullBox.call(this, 'trex', size);
};

mp4lib.boxes.TrackExtendsBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);
mp4lib.boxes.TrackExtendsBox.prototype.constructor = mp4lib.boxes.TrackExtendsBox;

mp4lib.boxes.TrackExtendsBox.prototype.computeLength = function() {
    mp4lib.boxes.FullBox.prototype.computeLength.call(this);
    this.size += mp4lib.fields.FIELD_UINT32.getLength() * 5;
};

mp4lib.boxes.TrackExtendsBox.prototype.read = function(data, pos, end) {
    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);

    this.track_ID = this._readData(data, mp4lib.fields.FIELD_UINT32);
    this.default_sample_description_index = this._readData(data, mp4lib.fields.FIELD_UINT32);
    this.default_sample_duration = this._readData(data, mp4lib.fields.FIELD_UINT32);
    this.default_sample_size = this._readData(data, mp4lib.fields.FIELD_UINT32);
    this.default_sample_flags = this._readData(data, mp4lib.fields.FIELD_UINT32);
    return this.localPos;
};

mp4lib.boxes.TrackExtendsBox.prototype.write = function(data, pos) {
    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);

    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.track_ID);
    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.default_sample_description_index);
    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.default_sample_duration);
    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.default_sample_size);
    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.default_sample_flags);
    return this.localPos;
};

// --------------------------- vmhd ----------------------------------
mp4lib.boxes.VideoMediaHeaderBox = function(size) {
    mp4lib.boxes.FullBox.call(this, 'vmhd', size);
};

mp4lib.boxes.VideoMediaHeaderBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);
mp4lib.boxes.VideoMediaHeaderBox.prototype.constructor = mp4lib.boxes.VideoMediaHeaderBox;

mp4lib.boxes.VideoMediaHeaderBox.prototype.computeLength = function() {
    mp4lib.boxes.FullBox.prototype.computeLength.call(this);
    this.size += mp4lib.fields.FIELD_INT16.getLength() + mp4lib.fields.FIELD_UINT16.getLength() * 3;
};

mp4lib.boxes.VideoMediaHeaderBox.prototype.read = function(data, pos, end) {
    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);

    this.graphicsmode = this._readData(data, mp4lib.fields.FIELD_INT16);
    this.opcolor = this._readArrayFieldData(data, mp4lib.fields.FIELD_UINT16, 3);
    return this.localPos;
};

mp4lib.boxes.VideoMediaHeaderBox.prototype.write = function(data, pos) {
    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);

    this._writeData(data, mp4lib.fields.FIELD_INT16, this.graphicsmode);
    this._writeArrayData(data, mp4lib.fields.FIELD_UINT16, this.opcolor);
    return this.localPos;
};

// --------------------------- smhd ----------------------------------
mp4lib.boxes.SoundMediaHeaderBox = function(size) {
    mp4lib.boxes.FullBox.call(this, 'smhd', size);
};

mp4lib.boxes.SoundMediaHeaderBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);
mp4lib.boxes.SoundMediaHeaderBox.prototype.constructor = mp4lib.boxes.SoundMediaHeaderBox;

mp4lib.boxes.SoundMediaHeaderBox.prototype.computeLength = function() {
    mp4lib.boxes.FullBox.prototype.computeLength.call(this);
    this.size += mp4lib.fields.FIELD_INT16.getLength() + mp4lib.fields.FIELD_UINT16.getLength();
};

mp4lib.boxes.SoundMediaHeaderBox.prototype.read = function(data, pos, end) {
    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);

    this.balance = this._readData(data, mp4lib.fields.FIELD_INT16);
    this.reserved = this._readData(data, mp4lib.fields.FIELD_UINT16);
    return this.localPos;
};

mp4lib.boxes.SoundMediaHeaderBox.prototype.write = function(data, pos) {
    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);

    this._writeData(data, mp4lib.fields.FIELD_INT16, this.balance);
    this._writeData(data, mp4lib.fields.FIELD_UINT16, this.reserved);
    return this.localPos;
};

// --------------------------- dref ----------------------------------
mp4lib.boxes.DataReferenceBox = function(size) {
    mp4lib.boxes.ContainerFullBox.call(this, 'dref', size);
};

mp4lib.boxes.DataReferenceBox.prototype = Object.create(mp4lib.boxes.ContainerFullBox.prototype);
mp4lib.boxes.DataReferenceBox.prototype.constructor = mp4lib.boxes.DataReferenceBox;

mp4lib.boxes.DataReferenceBox.prototype.computeLength = function() {
    mp4lib.boxes.ContainerFullBox.prototype.computeLength.call(this, true);
};

mp4lib.boxes.DataReferenceBox.prototype.read = function(data, pos, end) {
    return mp4lib.boxes.ContainerFullBox.prototype.read.call(this, data, pos, end, true);
};

mp4lib.boxes.DataReferenceBox.prototype.write = function(data, pos) {
    if (!this.entry_count) {
        //if entry_count has not been set, set it to boxes array length
        this.entry_count = this.boxes.length;
    }
    return mp4lib.boxes.ContainerFullBox.prototype.write.call(this, data, pos, true);
};

// --------------------------- url  ----------------------------------
mp4lib.boxes.DataEntryUrlBox = function(size) {
    mp4lib.boxes.FullBox.call(this, 'url ', size);
};

mp4lib.boxes.DataEntryUrlBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);
mp4lib.boxes.DataEntryUrlBox.prototype.constructor = mp4lib.boxes.DataEntryUrlBox;

mp4lib.boxes.DataEntryUrlBox.prototype.computeLength = function() {
    mp4lib.boxes.FullBox.prototype.computeLength.call(this);
    //NAN : test on location value, not definition, probleme in IE
    if (this.location !== undefined /*&& this.location !==""*/ ) {
        //this.flags = this.flags | 1;
        this.size += mp4lib.fields.FIELD_STRING.getLength(this.location);
    }
};

mp4lib.boxes.DataEntryUrlBox.prototype.read = function(data, pos, end) {
    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);

    if (this.flags & '0x000001' === 0) {
        this.location = this._readData(data, mp4lib.fields.FIELD_STRING);
    }

    return this.localPos;
};

mp4lib.boxes.DataEntryUrlBox.prototype.write = function(data, pos) {
    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);

    if (this.location !== undefined /* && this.location !== ""*/ ) {
        this._writeData(data, mp4lib.fields.FIELD_STRING, this.location);
    }
    return this.localPos;
};

// --------------------------- urn  ----------------------------------
mp4lib.boxes.DataEntryUrnBox = function(size) {
    mp4lib.boxes.FullBox.call(this, 'urn ', size);
};

mp4lib.boxes.DataEntryUrnBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);
mp4lib.boxes.DataEntryUrnBox.prototype.constructor = mp4lib.boxes.DataEntryUrnBox;

mp4lib.boxes.DataEntryUrnBox.prototype.computeLength = function() {
    mp4lib.boxes.FullBox.prototype.computeLength.call(this);
    if (this.flags & '0x000001' === 0) {
        this.size += mp4lib.fields.FIELD_STRING.getLength(this.name) + mp4lib.fields.FIELD_STRING.getLength(this.location);
    }
};

mp4lib.boxes.DataEntryUrnBox.prototype.read = function(data, pos, end) {
    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);

    if (this.flags & '0x000001' === 0) {
        this.name = this._readData(data, mp4lib.fields.FIELD_STRING);
        this.location = this._readData(data, mp4lib.fields.FIELD_STRING);
    }
    return this.localPos;
};

mp4lib.boxes.DataEntryUrnBox.prototype.write = function(data, pos) {
    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);

    if (this.flags & '0x000001' === 0) {
        this._writeData(data, mp4lib.fields.FIELD_STRING, this.name);
        this._writeData(data, mp4lib.fields.FIELD_STRING, this.location);
    }
    return this.localPos;
};

// --------------------------- mfhd ----------------------------------
mp4lib.boxes.MovieFragmentHeaderBox = function(size) {
    mp4lib.boxes.FullBox.call(this, 'mfhd', size);
};

mp4lib.boxes.MovieFragmentHeaderBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);
mp4lib.boxes.MovieFragmentHeaderBox.prototype.constructor = mp4lib.boxes.MovieFragmentHeaderBox;

mp4lib.boxes.MovieFragmentHeaderBox.prototype.computeLength = function() {
    mp4lib.boxes.FullBox.prototype.computeLength.call(this);
    this.size += mp4lib.fields.FIELD_UINT32.getLength();
};

mp4lib.boxes.MovieFragmentHeaderBox.prototype.read = function(data, pos, end) {
    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);
    this.sequence_number = this._readData(data, mp4lib.fields.FIELD_UINT32);
    return this.localPos;
};

mp4lib.boxes.MovieFragmentHeaderBox.prototype.write = function(data, pos) {
    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);
    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.sequence_number);
    return this.localPos;
};

// --------------------------- tfhd ----------------------------------
mp4lib.boxes.TrackFragmentHeaderBox = function(size) {
    mp4lib.boxes.FullBox.call(this, 'tfhd', size);
};

mp4lib.boxes.TrackFragmentHeaderBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);
mp4lib.boxes.TrackFragmentHeaderBox.prototype.constructor = mp4lib.boxes.TrackFragmentHeaderBox;

mp4lib.boxes.TrackFragmentHeaderBox.prototype.computeLength = function() {
    mp4lib.boxes.FullBox.prototype.computeLength.call(this);
    this.size += mp4lib.fields.FIELD_UINT32.getLength();
    //even if, for example base_data_offset is defined, test the flags value
    //to know if base_data_offset size should be added to global size.
    if ((this.flags & 0x000001) !== 0 && this.base_data_offset !== undefined) {
        this.size += mp4lib.fields.FIELD_UINT64.getLength();
    }
    if ((this.flags & 0x000002) !== 0 && this.sample_description_index !== undefined) {
        this.size += mp4lib.fields.FIELD_UINT32.getLength();
    }
    if ((this.flags & 0x000008) !== 0 && this.default_sample_duration !== undefined) {
        this.size += mp4lib.fields.FIELD_UINT32.getLength();
    }
    if ((this.flags & 0x000010) !== 0 && this.default_sample_size !== undefined) {
        this.size += mp4lib.fields.FIELD_UINT32.getLength();
    }
    if ((this.flags & 0x000020) !== 0 && this.default_sample_flags !== undefined) {
        this.size += mp4lib.fields.FIELD_UINT32.getLength();
    }
};

mp4lib.boxes.TrackFragmentHeaderBox.prototype.read = function(data, pos, end) {
    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);

    this.track_ID = this._readData(data, mp4lib.fields.FIELD_UINT32);
    if ((this.flags & 0x000001) !== 0) {
        this.base_data_offset = this._readData(data, mp4lib.fields.FIELD_UINT64);
    }
    if ((this.flags & 0x000002) !== 0) {
        this.sample_description_index = this._readData(data, mp4lib.fields.FIELD_UINT32);
    }
    if ((this.flags & 0x000008) !== 0) {
        this.default_sample_duration = this._readData(data, mp4lib.fields.FIELD_UINT32);
    }
    if ((this.flags & 0x000010) !== 0) {
        this.default_sample_size = this._readData(data, mp4lib.fields.FIELD_UINT32);
    }
    if ((this.flags & 0x000020) !== 0) {
        this.default_sample_flags = this._readData(data, mp4lib.fields.FIELD_UINT32);
    }
    return this.localPos;
};

mp4lib.boxes.TrackFragmentHeaderBox.prototype.write = function(data, pos) {
    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);

    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.track_ID);

    if ((this.flags & 0x000001) !== 0) {
        this._writeData(data, mp4lib.fields.FIELD_UINT64, this.base_data_offset);
    }
    if ((this.flags & 0x000002) !== 0) {
        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.sample_description_index);
    }
    if ((this.flags & 0x000008) !== 0) {
        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.default_sample_duration);
    }
    if ((this.flags & 0x000010) !== 0) {
        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.default_sample_size);
    }
    if ((this.flags & 0x000020) !== 0) {
        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.default_sample_flags);
    }
    return this.localPos;
};

// --------------------------- tfdt ----------------------------------
mp4lib.boxes.TrackFragmentBaseMediaDecodeTimeBox = function(size) {
    mp4lib.boxes.FullBox.call(this, 'tfdt', size);
};

mp4lib.boxes.TrackFragmentBaseMediaDecodeTimeBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);
mp4lib.boxes.TrackFragmentBaseMediaDecodeTimeBox.prototype.constructor = mp4lib.boxes.TrackFragmentBaseMediaDecodeTimeBox;

mp4lib.boxes.TrackFragmentBaseMediaDecodeTimeBox.prototype.computeLength = function() {
    mp4lib.boxes.FullBox.prototype.computeLength.call(this);
    if (this.version === 1) {
        this.size += mp4lib.fields.FIELD_UINT64.getLength();
    } else {
        this.size += mp4lib.fields.FIELD_UINT32.getLength();
    }
};

mp4lib.boxes.TrackFragmentBaseMediaDecodeTimeBox.prototype.read = function(data, pos, end) {
    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);

    if (this.version === 1) {
        this.baseMediaDecodeTime = this._readData(data, mp4lib.fields.FIELD_UINT64);
    } else {
        this.baseMediaDecodeTime = this._readData(data, mp4lib.fields.FIELD_UINT32);
    }
    return this.localPos;
};

mp4lib.boxes.TrackFragmentBaseMediaDecodeTimeBox.prototype.write = function(data, pos) {
    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);

    if (this.version === 1) {
        this._writeData(data, mp4lib.fields.FIELD_UINT64, this.baseMediaDecodeTime);
    } else {
        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.baseMediaDecodeTime);
    }
    return this.localPos;
};

// --------------------------- trun ----------------------------------
mp4lib.boxes.TrackFragmentRunBox = function(size) {
    mp4lib.boxes.FullBox.call(this, 'trun', size);
};

mp4lib.boxes.TrackFragmentRunBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);
mp4lib.boxes.TrackFragmentRunBox.prototype.constructor = mp4lib.boxes.TrackFragmentRunBox;

mp4lib.boxes.TrackFragmentRunBox.prototype.computeLength = function() {
    mp4lib.boxes.FullBox.prototype.computeLength.call(this);
    var i = 0;
    this.size += mp4lib.fields.FIELD_UINT32.getLength(); //sample_count size
    if ((this.flags & 0x000001) !== 0 && this.data_offset !== undefined) {
        this.size += mp4lib.fields.FIELD_INT32.getLength();
    }
    if ((this.flags & 0x000004) !== 0 && this.first_sample_flags !== undefined) {
        this.size += mp4lib.fields.FIELD_UINT32.getLength();
    }

    for (i = 0; i < this.sample_count; i++) {
        if ((this.flags & 0x000100) !== 0 && this.samples_table[i].sample_duration !== undefined) {
            this.size += mp4lib.fields.FIELD_UINT32.getLength();
        }
        if ((this.flags & 0x000200) !== 0 && this.samples_table[i].sample_size !== undefined) {
            this.size += mp4lib.fields.FIELD_UINT32.getLength();
        }
        if ((this.flags & 0x000400) !== 0 && this.samples_table[i].sample_flags !== undefined) {
            this.size += mp4lib.fields.FIELD_UINT32.getLength();
        }

        if (this.version === 1) {
            if ((this.flags & 0x000800) !== 0 && this.samples_table[i].sample_composition_time_offset !== undefined) {
                this.size += mp4lib.fields.FIELD_INT32.getLength();
            }
        } else {
            if ((this.flags & 0x000800) !== 0 && this.samples_table[i].sample_composition_time_offset !== undefined) {
                this.size += mp4lib.fields.FIELD_UINT32.getLength();
            }
        }
    }
};

mp4lib.boxes.TrackFragmentRunBox.prototype.read = function(data, pos, end) {
    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);
    var i = 0,
        struct = {};

    this.sample_count = this._readData(data, mp4lib.fields.FIELD_UINT32);

    if ((this.flags & 0x000001) !== 0) {
        this.data_offset = this._readData(data, mp4lib.fields.FIELD_INT32);
    }
    if ((this.flags & 0x000004) !== 0) {
        this.first_sample_flags = this._readData(data, mp4lib.fields.FIELD_UINT32);
    }

    this.samples_table = [];

    for (i = 0; i < this.sample_count; i++) {
        struct = {};
        if ((this.flags & 0x000100) !== 0) {
            struct.sample_duration = this._readData(data, mp4lib.fields.FIELD_UINT32);
        }
        if ((this.flags & 0x000200) !== 0) {
            struct.sample_size = this._readData(data, mp4lib.fields.FIELD_UINT32);
        }
        if ((this.flags & 0x000400) !== 0) {
            struct.sample_flags = this._readData(data, mp4lib.fields.FIELD_UINT32);
        }

        if (this.version === 1) {
            if ((this.flags & 0x000800) !== 0) {
                struct.sample_composition_time_offset = this._readData(data, mp4lib.fields.FIELD_INT32);
            }
        } else {
            if ((this.flags & 0x000800) !== 0) {
                struct.sample_composition_time_offset = this._readData(data, mp4lib.fields.FIELD_UINT32);
            }
        }
        this.samples_table.push(struct);
    }
    return this.localPos;
};

mp4lib.boxes.TrackFragmentRunBox.prototype.write = function(data, pos) {
    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);
    var i = 0;

    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.sample_count);

    if ((this.flags & 0x000001) !== 0) {
        this._writeData(data, mp4lib.fields.FIELD_INT32, this.data_offset);
    }
    if ((this.flags & 0x000004) !== 0) {
        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.first_sample_flags);
    }

    for (i = 0; i < this.sample_count; i++) {

        if ((this.flags & 0x000100) !== 0) {
            this._writeData(data, mp4lib.fields.FIELD_UINT32, this.samples_table[i].sample_duration);
        }
        if ((this.flags & 0x000200) !== 0) {
            this._writeData(data, mp4lib.fields.FIELD_UINT32, this.samples_table[i].sample_size);
        }
        if ((this.flags & 0x000400) !== 0) {
            this._writeData(data, mp4lib.fields.FIELD_UINT32, this.samples_table[i].sample_flags);
        }

        if (this.version === 1) {
            if ((this.flags & 0x000800) !== 0) {
                this._writeData(data, mp4lib.fields.FIELD_INT32, this.samples_table[i].sample_composition_time_offset);
            }
        } else {
            if ((this.flags & 0x000800) !== 0) {
                this._writeData(data, mp4lib.fields.FIELD_UINT32, this.samples_table[i].sample_composition_time_offset);
            }
        }
    }
    return this.localPos;
};

// --------------------------- stsd ----------------------------------
mp4lib.boxes.SampleDescriptionBox = function(size) {
    mp4lib.boxes.ContainerFullBox.call(this, 'stsd', size);
};

mp4lib.boxes.SampleDescriptionBox.prototype = Object.create(mp4lib.boxes.ContainerFullBox.prototype);
mp4lib.boxes.SampleDescriptionBox.prototype.constructor = mp4lib.boxes.SampleDescriptionBox;

mp4lib.boxes.SampleDescriptionBox.prototype.computeLength = function() {
    mp4lib.boxes.ContainerFullBox.prototype.computeLength.call(this, true);
};

mp4lib.boxes.SampleDescriptionBox.prototype.read = function(data, pos, end) {
    return mp4lib.boxes.ContainerFullBox.prototype.read.call(this, data, pos, end, true);
};

mp4lib.boxes.SampleDescriptionBox.prototype.write = function(data, pos) {
    this.entry_count = this.boxes.length;
    return mp4lib.boxes.ContainerFullBox.prototype.write.call(this, data, pos, true);
};

// --------------------------- sdtp ----------------------------------
mp4lib.boxes.SampleDependencyTableBox = function(size) {
    mp4lib.boxes.FullBox.call(this, 'sdtp', size);
};

mp4lib.boxes.SampleDependencyTableBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);
mp4lib.boxes.SampleDependencyTableBox.prototype.constructor = mp4lib.boxes.SampleDependencyTableBox;

mp4lib.boxes.SampleDependencyTableBox.prototype.computeLength = function() {
    mp4lib.boxes.FullBox.prototype.computeLength.call(this);
    this.size += mp4lib.fields.FIELD_UINT8.getLength() * this.sample_dependency_table.length;
};

mp4lib.boxes.SampleDependencyTableBox.prototype.read = function(data, pos, end) {
    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);
    this.sample_dependency_table = this._readArrayData(data, mp4lib.fields.FIELD_UINT8);
    return this.localPos;
};

mp4lib.boxes.SampleDependencyTableBox.prototype.write = function(data, pos) {
    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);

    this._writeArrayData(data, mp4lib.fields.FIELD_UINT8, this.sample_dependency_table);
    return this.localPos;
};

// --------------------------- abstract SampleEntry ----------------------------------
mp4lib.boxes.SampleEntryBox = function(boxType, size) {
    mp4lib.boxes.Box.call(this, boxType, size);
};

mp4lib.boxes.SampleEntryBox.prototype = Object.create(mp4lib.boxes.Box.prototype);
mp4lib.boxes.SampleEntryBox.prototype.constructor = mp4lib.boxes.SampleEntryBox;

mp4lib.boxes.SampleEntryBox.prototype.computeLength = function() {
    mp4lib.boxes.Box.prototype.computeLength.call(this);
    this.size += mp4lib.fields.FIELD_UINT16.getLength() + mp4lib.fields.FIELD_UINT8.getLength() * 6;
};

mp4lib.boxes.SampleEntryBox.prototype.read = function(data, pos, end) {
    this.localPos = pos;
    this.localEnd = end;

    this.reserved = this._readArrayFieldData(data, mp4lib.fields.FIELD_UINT8, 6);
    this.data_reference_index = this._readData(data, mp4lib.fields.FIELD_UINT16);
    return this.localPos;
};

mp4lib.boxes.SampleEntryBox.prototype.write = function(data, pos) {
    mp4lib.boxes.Box.prototype.write.call(this, data, pos);

    this._writeArrayData(data, mp4lib.fields.FIELD_UINT8, this.reserved);
    this._writeData(data, mp4lib.fields.FIELD_UINT16, this.data_reference_index);
    return this.localPos;
};

// --------------------------- abstract VisualSampleEntry ----------------------------------
mp4lib.boxes.VisualSampleEntryBox = function(boxType, size) {
    mp4lib.boxes.SampleEntryBox.call(this, boxType, size);
};

mp4lib.boxes.VisualSampleEntryBox.prototype = Object.create(mp4lib.boxes.SampleEntryBox.prototype);
mp4lib.boxes.VisualSampleEntryBox.prototype.constructor = mp4lib.boxes.VisualSampleEntryBox;

mp4lib.boxes.VisualSampleEntryBox.prototype.computeLength = function() {
    mp4lib.boxes.SampleEntryBox.prototype.computeLength.call(this);
    this.size += mp4lib.fields.FIELD_UINT16.getLength() * 7 + mp4lib.fields.FIELD_UINT32.getLength() * 3;
    this.size += mp4lib.fields.FIELD_UINT32.getLength() * 3;
    this.size += 32; //compressorname size
};

mp4lib.boxes.VisualSampleEntryBox.prototype.read = function(data, pos, end) {
    mp4lib.boxes.SampleEntryBox.prototype.read.call(this, data, pos, end);
    this.pre_defined = this._readData(data, mp4lib.fields.FIELD_UINT16);
    this.reserved_2 = this._readData(data, mp4lib.fields.FIELD_UINT16);
    // there is already field called reserved from SampleEntry, so we need to call it reserved_2
    this.pre_defined_2 = this._readArrayFieldData(data, mp4lib.fields.FIELD_UINT32, 3);
    this.width = this._readData(data, mp4lib.fields.FIELD_UINT16);
    this.height = this._readData(data, mp4lib.fields.FIELD_UINT16);
    this.horizresolution = this._readData(data, mp4lib.fields.FIELD_UINT32);
    this.vertresolution = this._readData(data, mp4lib.fields.FIELD_UINT32);
    this.reserved_3 = this._readData(data, mp4lib.fields.FIELD_UINT32);
    this.frame_count = this._readData(data, mp4lib.fields.FIELD_UINT16);
    this.compressorname = this._readArrayFieldData(data, mp4lib.fields.FIELD_UINT8, 32);
    this.depth = this._readData(data, mp4lib.fields.FIELD_UINT16);
    this.pre_defined_3 = this._readData(data, mp4lib.fields.FIELD_INT16);
    return this.localPos;
};

mp4lib.boxes.VisualSampleEntryBox.prototype.write = function(data, pos) {
    mp4lib.boxes.SampleEntryBox.prototype.write.call(this, data, pos);

    this._writeData(data, mp4lib.fields.FIELD_UINT16, this.pre_defined);
    this._writeData(data, mp4lib.fields.FIELD_UINT16, this.reserved_2);
    // there is already field called reserved from SampleEntry, so we need to call it reserved_2
    this._writeArrayData(data, mp4lib.fields.FIELD_UINT32, this.pre_defined_2);
    this._writeData(data, mp4lib.fields.FIELD_UINT16, this.width);
    this._writeData(data, mp4lib.fields.FIELD_UINT16, this.height);
    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.horizresolution);
    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.vertresolution);
    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.reserved_3);
    this._writeData(data, mp4lib.fields.FIELD_UINT16, this.frame_count);
    this._writeArrayData(data, mp4lib.fields.FIELD_UINT8, this.compressorname);
    this._writeData(data, mp4lib.fields.FIELD_UINT16, this.depth);
    this._writeData(data, mp4lib.fields.FIELD_INT16, this.pre_defined_3);
    return this.localPos;
};

// --------------------------- abstract VisualSampleEntryContainer ----------------------------------
mp4lib.boxes.VisualSampleEntryContainerBox = function(boxType, size) {
    mp4lib.boxes.VisualSampleEntryBox.call(this, boxType, size);
    this.boxes = [];
};

mp4lib.boxes.VisualSampleEntryContainerBox.prototype = Object.create(mp4lib.boxes.VisualSampleEntryBox.prototype);
mp4lib.boxes.VisualSampleEntryContainerBox.prototype.constructor = mp4lib.boxes.VisualSampleEntryContainerBox;

mp4lib.boxes.VisualSampleEntryContainerBox.prototype.computeLength = function() {
    mp4lib.boxes.VisualSampleEntryBox.prototype.computeLength.call(this);
    var i = 0;
    for (i = 0; i < this.boxes.length; i++) {
        this.boxes[i].computeLength();
        this.size += this.boxes[i].size;
    }
};

mp4lib.boxes.VisualSampleEntryContainerBox.prototype.read = function(data, pos, end) {
    mp4lib.boxes.VisualSampleEntryBox.prototype.read.call(this, data, pos, end);

    var size = 0,
        uuidFieldPos = 0,
        uuid = null,
        boxtype,
        box;

    while (this.localPos < this.localEnd) {
        // Read box size
        size = mp4lib.fields.FIELD_UINT32.read(data, this.localPos);

        // Read boxtype
        boxtype = mp4lib.fields.readString(data, this.localPos + 4, 4);

        // Extented type?
        if (boxtype == "uuid") {
            uuidFieldPos = (size == 1) ? 16 : 8;
            uuid = new mp4lib.fields.ArrayField(mp4lib.fields.FIELD_INT8, 16).read(data, this.localPos + uuidFieldPos, this.localPos + uuidFieldPos + 16);
            uuid = JSON.stringify(uuid);
        }

        box = mp4lib.createBox(boxtype, size, uuid);
        if (boxtype === "uuid") {
            this.localPos = box.read(data, this.localPos + mp4lib.fields.FIELD_INT8.getLength() * 16 + 8, this.localPos + size);
        } else {
            this.localPos = box.read(data, this.localPos + 8, this.localPos + size);
        }

        // in debug mode, sourcebuffer is copied to each box,
        // so any invalid deserializations may be found by comparing
        // source buffer with serialized box
        if (mp4lib.debug) {
            box.__sourceBuffer = data.subarray(this.localPos - box.size, this.localPos);
        }

        this.boxes.push(box);

        if (box.size <= 0 || box.size === null) {
            throw new mp4lib.ParseException('Problem on size of box ' + box.boxtype +
                ', parsing stopped to avoid infinite loop');
        }

        if (!box.boxtype) {
            throw new mp4lib.ParseException('Problem on unknown box, parsing stopped to avoid infinite loop');
        }
    }
    return this.localPos;
};

mp4lib.boxes.VisualSampleEntryContainerBox.prototype.write = function(data, pos) {
    mp4lib.boxes.VisualSampleEntryBox.prototype.write.call(this, data, pos);
    var i = 0;

    for (i = 0; i < this.boxes.length; i++) {
        this.localPos = this.boxes[i].write(data, this.localPos);
    }
    return this.localPos;
};

// --------------------------- avc1 ----------------------------------
mp4lib.boxes.AVC1VisualSampleEntryBox = function(size) {
    mp4lib.boxes.VisualSampleEntryContainerBox.call(this, 'avc1', size);
};

mp4lib.boxes.AVC1VisualSampleEntryBox.prototype = Object.create(mp4lib.boxes.VisualSampleEntryContainerBox.prototype);
mp4lib.boxes.AVC1VisualSampleEntryBox.prototype.constructor = mp4lib.boxes.AVC1VisualSampleEntryBox;

//-------------------------- encv ------------------------------------
mp4lib.boxes.EncryptedVideoBox = function(size) {
    mp4lib.boxes.VisualSampleEntryContainerBox.call(this, 'encv', size);
};

mp4lib.boxes.EncryptedVideoBox.prototype = Object.create(mp4lib.boxes.VisualSampleEntryContainerBox.prototype);
mp4lib.boxes.EncryptedVideoBox.prototype.constructor = mp4lib.boxes.EncryptedVideoBox;

// --------------------------- avcc ----------------------------------
mp4lib.boxes.AVCConfigurationBox = function(size) {
    mp4lib.boxes.Box.call(this, 'avcC', size);
};

mp4lib.boxes.AVCConfigurationBox.prototype = Object.create(mp4lib.boxes.Box.prototype);
mp4lib.boxes.AVCConfigurationBox.prototype.constructor = mp4lib.boxes.AVCConfigurationBox;

mp4lib.boxes.AVCConfigurationBox.prototype.computeLength = function() {
    mp4lib.boxes.Box.prototype.computeLength.call(this);
    this.size += mp4lib.fields.FIELD_UINT8.getLength() * 4 + mp4lib.fields.FIELD_UINT8.getLength() * 3;
    this.size += this._getNALLength(this.numOfSequenceParameterSets, this.SPS_NAL);
    this.size += this._getNALLength(this.numOfPictureParameterSets, this.PPS_NAL);
};

mp4lib.boxes.AVCConfigurationBox.prototype._getNALLength = function(nbElements, nalArray) {
    var size_NAL = 0,
        i = 0;

    for (i = 0; i < nbElements; i++) {
        size_NAL += mp4lib.fields.FIELD_UINT16.getLength() + nalArray[i].NAL_length;
    }

    return size_NAL;
};

mp4lib.boxes.AVCConfigurationBox.prototype.read = function(data, pos, end) {
    this.localPos = pos;
    this.localEnd = end;
    this.configurationVersion = this._readData(data, mp4lib.fields.FIELD_UINT8);
    this.AVCProfileIndication = this._readData(data, mp4lib.fields.FIELD_UINT8);
    this.profile_compatibility = this._readData(data, mp4lib.fields.FIELD_UINT8);
    this.AVCLevelIndication = this._readData(data, mp4lib.fields.FIELD_UINT8);

    this.temp = this._readData(data, mp4lib.fields.FIELD_UINT8);
    // 6 bits for reserved =63 and two bits for NAL length = 2-bit length byte size type
    this.lengthSizeMinusOne = this.temp & 3;
    this.numOfSequenceParameterSets_tmp = this._readData(data, mp4lib.fields.FIELD_UINT8);
    this.numOfSequenceParameterSets = this.numOfSequenceParameterSets_tmp & 31;

    this.SPS_NAL = this._readNAL(data, this.numOfSequenceParameterSets);

    this.numOfPictureParameterSets = this._readData(data, mp4lib.fields.FIELD_UINT8);

    this.PPS_NAL = this._readNAL(data, this.numOfPictureParameterSets);
    return this.localPos;
};

mp4lib.boxes.AVCConfigurationBox.prototype._readNAL = function(data, nbElements) {
    var nalArray = [],
        i = 0,
        struct = {};

    for (i = 0; i < nbElements; i++) {
        struct = {};

        struct.NAL_length = this._readData(data, mp4lib.fields.FIELD_UINT16);
        struct.NAL = data.subarray(this.localPos, this.localPos + struct.NAL_length);
        this.localPos += struct.NAL_length;
        nalArray.push(struct);
    }
    return nalArray;
};

mp4lib.boxes.AVCConfigurationBox.prototype.write = function(data, pos) {
    mp4lib.boxes.Box.prototype.write.call(this, data, pos);

    this._writeData(data, mp4lib.fields.FIELD_UINT8, this.configurationVersion);
    this._writeData(data, mp4lib.fields.FIELD_UINT8, this.AVCProfileIndication);
    this._writeData(data, mp4lib.fields.FIELD_UINT8, this.profile_compatibility);
    this._writeData(data, mp4lib.fields.FIELD_UINT8, this.AVCLevelIndication);

    this.temp = this.lengthSizeMinusOne | 252;
    this._writeData(data, mp4lib.fields.FIELD_UINT8, this.temp);
    this.numOfSequenceParameterSets = this.SPS_NAL.length;
    this.numOfSequenceParameterSets_tmp = this.numOfSequenceParameterSets | 224;
    this._writeData(data, mp4lib.fields.FIELD_UINT8, this.numOfSequenceParameterSets_tmp);
    this._writeNAL(data, this.numOfSequenceParameterSets, this.SPS_NAL);
    this._writeData(data, mp4lib.fields.FIELD_UINT8, this.numOfPictureParameterSets);
    this._writeNAL(data, this.numOfPictureParameterSets, this.PPS_NAL);
    return this.localPos;
};

mp4lib.boxes.AVCConfigurationBox.prototype._writeNAL = function(data, nbElements, nalArray) {
    var i = 0;

    for (i = 0; i < nbElements; i++) {
        this._writeData(data, mp4lib.fields.FIELD_UINT16, nalArray[i].NAL_length);
        this._writeBuffer(data, nalArray[i].NAL, nalArray[i].NAL_length);
    }
};

// --------------------------- pasp ----------------------------------
mp4lib.boxes.PixelAspectRatioBox = function(size) {
    mp4lib.boxes.Box.call(this, 'pasp', size);
};

mp4lib.boxes.PixelAspectRatioBox.prototype = Object.create(mp4lib.boxes.Box.prototype);
mp4lib.boxes.PixelAspectRatioBox.prototype.constructor = mp4lib.boxes.PixelAspectRatioBox;

mp4lib.boxes.PixelAspectRatioBox.prototype.computeLength = function() {
    mp4lib.boxes.Box.prototype.computeLength.call(this);
    this.size += mp4lib.fields.FIELD_INT32.getLength() * 2;
};

mp4lib.boxes.PixelAspectRatioBox.prototype.read = function(data, pos, end) {
    this.localPos = pos;
    this.localEnd = end;

    this.hSpacing = this._readData(data, mp4lib.fields.FIELD_INT32);
    this.vSpacing = this._readData(data, mp4lib.fields.FIELD_INT32);
    return this.localPos;
};

mp4lib.boxes.PixelAspectRatioBox.prototype.write = function(data, pos) {
    mp4lib.boxes.Box.prototype.write.call(this, data, pos);

    this._writeData(data, mp4lib.fields.FIELD_INT32, this.hSpacing);
    this._writeData(data, mp4lib.fields.FIELD_INT32, this.vSpacing);
    return this.localPos;
};

// --------------------------- abstract VisualSampleEntry ----------------------------------
mp4lib.boxes.AudioSampleEntryBox = function(boxType, size) {
    mp4lib.boxes.SampleEntryBox.call(this, boxType, size);
};

mp4lib.boxes.AudioSampleEntryBox.prototype = Object.create(mp4lib.boxes.SampleEntryBox.prototype);
mp4lib.boxes.AudioSampleEntryBox.prototype.constructor = mp4lib.boxes.AudioSampleEntryBox;

mp4lib.boxes.AudioSampleEntryBox.prototype.computeLength = function() {
    mp4lib.boxes.SampleEntryBox.prototype.computeLength.call(this);
    this.size += mp4lib.fields.FIELD_UINT16.getLength() * 4 + mp4lib.fields.FIELD_UINT32.getLength() * 3;
};

mp4lib.boxes.AudioSampleEntryBox.prototype.read = function(data, pos, end) {
    mp4lib.boxes.SampleEntryBox.prototype.read.call(this, data, pos, end);

    this.reserved_2 = this._readArrayFieldData(data, mp4lib.fields.FIELD_UINT32, 2);
    this.channelcount = this._readData(data, mp4lib.fields.FIELD_UINT16);
    this.samplesize = this._readData(data, mp4lib.fields.FIELD_UINT16);
    this.pre_defined = this._readData(data, mp4lib.fields.FIELD_UINT16);
    this.reserved_3 = this._readData(data, mp4lib.fields.FIELD_UINT16);
    this.samplerate = this._readData(data, mp4lib.fields.FIELD_UINT32);
    return this.localPos;
};

mp4lib.boxes.AudioSampleEntryBox.prototype.write = function(data, pos) {
    mp4lib.boxes.SampleEntryBox.prototype.write.call(this, data, pos);

    this._writeArrayData(data, mp4lib.fields.FIELD_UINT32, this.reserved_2);
    this._writeData(data, mp4lib.fields.FIELD_UINT16, this.channelcount);
    this._writeData(data, mp4lib.fields.FIELD_UINT16, this.samplesize);
    this._writeData(data, mp4lib.fields.FIELD_UINT16, this.pre_defined);
    this._writeData(data, mp4lib.fields.FIELD_UINT16, this.reserved_3);
    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.samplerate);
    return this.localPos;
};

// --------------------------- abstract AudioSampleEntryContainer ----------------------------------
mp4lib.boxes.AudioSampleEntryContainerBox = function(boxType, size) {
    mp4lib.boxes.AudioSampleEntryBox.call(this, boxType, size);
    this.boxes = [];
};

mp4lib.boxes.AudioSampleEntryContainerBox.prototype = Object.create(mp4lib.boxes.AudioSampleEntryBox.prototype);
mp4lib.boxes.AudioSampleEntryContainerBox.prototype.constructor = mp4lib.boxes.AudioSampleEntryContainerBox;

mp4lib.boxes.AudioSampleEntryContainerBox.prototype.computeLength = function() {
    mp4lib.boxes.AudioSampleEntryBox.prototype.computeLength.call(this);
    var i = 0;
    for (i = 0; i < this.boxes.length; i++) {
        this.boxes[i].computeLength();
        this.size += this.boxes[i].size;
    }
};

mp4lib.boxes.AudioSampleEntryContainerBox.prototype.read = function(data, pos, end) {
    mp4lib.boxes.AudioSampleEntryBox.prototype.read.call(this, data, pos, end);

    var size = 0,
        uuidFieldPos = 0,
        uuid = null,
        boxtype,
        box;

    while (this.localPos < this.localEnd) {
        // Read box size
        size = mp4lib.fields.FIELD_UINT32.read(data, this.localPos);

        // Read boxtype
        boxtype = mp4lib.fields.readString(data, this.localPos + 4, 4);

        // Extented type?
        if (boxtype == "uuid") {
            uuidFieldPos = (size == 1) ? 16 : 8;
            uuid = new mp4lib.fields.ArrayField(mp4lib.fields.FIELD_INT8, 16).read(data, this.localPos + uuidFieldPos, this.localPos + uuidFieldPos + 16);
            uuid = JSON.stringify(uuid);
        }

        box = mp4lib.createBox(boxtype, size, uuid);
        if (boxtype === "uuid") {
            this.localPos = box.read(data, this.localPos + mp4lib.fields.FIELD_INT8.getLength() * 16 + 8, this.localPos + size);
        } else {
            this.localPos = box.read(data, this.localPos + 8, this.localPos + size);
        }

        // in debug mode, sourcebuffer is copied to each box,
        // so any invalid deserializations may be found by comparing
        // source buffer with serialized box
        if (mp4lib.debug) {
            box.__sourceBuffer = data.subarray(this.localPos - box.size, this.localPos);
        }

        this.boxes.push(box);

        if (box.size <= 0 || box.size === null) {
            throw new mp4lib.ParseException('Problem on size of box ' + box.boxtype +
                ', parsing stopped to avoid infinite loop');
        }

        if (!box.boxtype) {
            throw new mp4lib.ParseException('Problem on unknown box, parsing stopped to avoid infinite loop');
        }
    }
    return this.localPos;
};

mp4lib.boxes.AudioSampleEntryContainerBox.prototype.write = function(data, pos) {
    mp4lib.boxes.AudioSampleEntryBox.prototype.write.call(this, data, pos);
    var i = 0;

    for (i = 0; i < this.boxes.length; i++) {
        this.localPos = this.boxes[i].write(data, this.localPos);
    }
    return this.localPos;
};

// --------------------------- mp4a ----------------------------------
mp4lib.boxes.MP4AudioSampleEntryBox = function(size) {
    mp4lib.boxes.AudioSampleEntryContainerBox.call(this, 'mp4a', size);
};

mp4lib.boxes.MP4AudioSampleEntryBox.prototype = Object.create(mp4lib.boxes.AudioSampleEntryContainerBox.prototype);
mp4lib.boxes.MP4AudioSampleEntryBox.prototype.constructor = mp4lib.boxes.MP4AudioSampleEntryBox;

//-------------------------- enca ------------------------------------
mp4lib.boxes.EncryptedAudioBox = function(size) {
    mp4lib.boxes.AudioSampleEntryContainerBox.call(this, 'enca', size);
};

mp4lib.boxes.EncryptedAudioBox.prototype = Object.create(mp4lib.boxes.AudioSampleEntryContainerBox.prototype);
mp4lib.boxes.EncryptedAudioBox.prototype.constructor = mp4lib.boxes.EncryptedAudioBox;

// --------------------------- esds ----------------------------
mp4lib.boxes.ESDBox = function(size) {
    mp4lib.boxes.FullBox.call(this, 'esds', size);
};

mp4lib.boxes.ESDBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);
mp4lib.boxes.ESDBox.prototype.constructor = mp4lib.boxes.ESDBox;

mp4lib.boxes.ESDBox.prototype.computeLength = function() {
    mp4lib.boxes.FullBox.prototype.computeLength.call(this);
    this.size += mp4lib.fields.FIELD_UINT8.getLength() * 2 + this.ES_length;
};

mp4lib.boxes.ESDBox.prototype.read = function(data, pos, end) {
    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);

    this.ES_tag = this._readData(data, mp4lib.fields.FIELD_UINT8);
    this.ES_length = this._readData(data, mp4lib.fields.FIELD_UINT8);
    this.ES_data = data.subarray(this.localPos, this.localPos + this.ES_length);
    this.localPos += this.ES_length;
    return this.localPos;
};

mp4lib.boxes.ESDBox.prototype.write = function(data, pos) {
    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);

    this._writeData(data, mp4lib.fields.FIELD_UINT8, this.ES_tag);
    this._writeData(data, mp4lib.fields.FIELD_UINT8, this.ES_length);
    this._writeBuffer(data, this.ES_data, this.ES_length);
    return this.localPos;
};

// --------------------------- stsz ----------------------------------
mp4lib.boxes.SampleSizeBox = function(size) {
    mp4lib.boxes.FullBox.call(this, 'stsz', size);
};

mp4lib.boxes.SampleSizeBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);
mp4lib.boxes.SampleSizeBox.prototype.constructor = mp4lib.boxes.SampleSizeBox;

mp4lib.boxes.SampleSizeBox.prototype.computeLength = function() {
    mp4lib.boxes.FullBox.prototype.computeLength.call(this);
    this.size += mp4lib.fields.FIELD_UINT32.getLength() * 2 + mp4lib.fields.FIELD_UINT32.getLength() * this.sample_count;
};

mp4lib.boxes.SampleSizeBox.prototype.read = function(data, pos, end) {
    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);

    this.sample_size = this._readData(data, mp4lib.fields.FIELD_UINT32);
    this.sample_count = this._readData(data, mp4lib.fields.FIELD_UINT32);
    this.entries = this._readArrayFieldData(data, mp4lib.fields.FIELD_UINT32, this.sample_count);
    return this.localPos;
};

mp4lib.boxes.SampleSizeBox.prototype.write = function(data, pos) {
    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);
    var i = 0;
    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.sample_size);
    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.sample_count);
    for (i = 0; i < this.sample_count; i++) {
        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.entries[i]);
    }
    return this.localPos;
};

// ------------------------- pssh ------------------------------------
mp4lib.boxes.ProtectionSystemSpecificHeaderBox = function(size) {
    mp4lib.boxes.FullBox.call(this, 'pssh', size);
};

mp4lib.boxes.ProtectionSystemSpecificHeaderBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);
mp4lib.boxes.ProtectionSystemSpecificHeaderBox.prototype.constructor = mp4lib.boxes.ProtectionSystemSpecificHeaderBox;

mp4lib.boxes.ProtectionSystemSpecificHeaderBox.prototype.computeLength = function() {
    mp4lib.boxes.FullBox.prototype.computeLength.call(this);

    this.size += mp4lib.fields.FIELD_UINT8.getLength() * 16;
    this.size += mp4lib.fields.FIELD_UINT32.getLength();
    this.size += mp4lib.fields.FIELD_UINT8.getLength() * this.DataSize;
};

mp4lib.boxes.ProtectionSystemSpecificHeaderBox.prototype.read = function(data, pos, end) {
    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);

    this.SystemID = this._readArrayFieldData(data, mp4lib.fields.FIELD_UINT8, 16);
    this.DataSize = this._readData(data, mp4lib.fields.FIELD_UINT32);
    this.Data = this._readArrayFieldData(data, mp4lib.fields.FIELD_UINT8, this.DataSize);
    return this.localPos;
};

mp4lib.boxes.ProtectionSystemSpecificHeaderBox.prototype.write = function(data, pos) {
    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);
    var i = 0;

    for (i = 0; i < 16; i++) {
        this._writeData(data, mp4lib.fields.FIELD_UINT8, this.SystemID[i]);
    }
    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.DataSize);
    for (i = 0; i < this.DataSize; i++) {
        this._writeData(data, mp4lib.fields.FIELD_UINT8, this.Data[i]);
    }
    return this.localPos;
};


// --------------------------- senc ----------------------------------
mp4lib.boxes.SampleEncryptionBox = function(size) {
    mp4lib.boxes.FullBox.call(this, 'senc', size);
};

mp4lib.boxes.SampleEncryptionBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);
mp4lib.boxes.SampleEncryptionBox.prototype.constructor = mp4lib.boxes.SampleEncryptionBox;

mp4lib.boxes.SampleEncryptionBox.prototype.computeLength = function() {
    mp4lib.boxes.FullBox.prototype.computeLength.call(this);
    var i = 0,
        j = 0;

    this.size += mp4lib.fields.FIELD_UINT32.getLength(); //sample_count size
    if (this.flags & 1) {
        this.size += mp4lib.fields.FIELD_UINT8.getLength(); //IV_size size
    }
    for (i = 0; i < this.sample_count; i++) {
        this.size += 8; // InitializationVector size
        if (this.flags & 2) {
            this.size += mp4lib.fields.FIELD_UINT16.getLength(); // NumberOfEntries size
            for (j = 0; j < this.entry[i].NumberOfEntries; j++) {
                this.size += mp4lib.fields.FIELD_UINT16.getLength(); //BytesOfClearData size
                this.size += mp4lib.fields.FIELD_UINT32.getLength(); //BytesOfEncryptedData size
            }
        }
    }
};

mp4lib.boxes.SampleEncryptionBox.prototype.write = function(data, pos) {
    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);
    var i = 0,
        j = 0;
    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.sample_count);
    if (this.flags & 1) {
        this._writeData(data, mp4lib.fields.FIELD_UINT8, this.IV_size);
    }
    for (i = 0; i < this.sample_count; i++) {
        this._writeBuffer(data, this.entry[i].InitializationVector, 8);

        if (this.flags & 2) {
            this._writeData(data, mp4lib.fields.FIELD_UINT16, this.entry[i].NumberOfEntries); // NumberOfEntries

            for (j = 0; j < this.entry[i].NumberOfEntries; j++) {
                this._writeData(data, mp4lib.fields.FIELD_UINT16, this.entry[i].clearAndCryptedData[j].BytesOfClearData); //BytesOfClearData
                this._writeData(data, mp4lib.fields.FIELD_UINT32, this.entry[i].clearAndCryptedData[j].BytesOfEncryptedData); //BytesOfEncryptedData size
            }
        }
    }
    return this.localPos;
};

mp4lib.boxes.SampleEncryptionBox.prototype.read = function(data, pos, end) {
    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);
    var i = 0,
        j = 0,
        clearAndCryptedStruct = {},
        struct = {};
    this.sample_count = this._readData(data, mp4lib.fields.FIELD_UINT32);
    if (this.flags & 1) {
        this.IV_size = this._readData(data, mp4lib.fields.FIELD_UINT8);
    }
    this.entry = [];
    for (i = 0; i < this.sample_count; i++) {
        struct = {};
        struct.InitializationVector = data.subarray(this.localPos, this.localPos + 8);
        this.localPos += 8; //InitializationVector size

        if (this.flags & 2) {
            struct.NumberOfEntries = this._readData(data, mp4lib.fields.FIELD_UINT16); // NumberOfEntries
            struct.clearAndCryptedData = [];
            for (j = 0; j < struct.NumberOfEntries; j++) {
                clearAndCryptedStruct = {};
                clearAndCryptedStruct.BytesOfClearData = this._readData(data, mp4lib.fields.FIELD_UINT16); //BytesOfClearData
                clearAndCryptedStruct.BytesOfEncryptedData = this._readData(data, mp4lib.fields.FIELD_UINT32); //BytesOfEncryptedData size
                struct.clearAndCryptedData.push(clearAndCryptedStruct);
            }
        }
        this.entry.push(struct);
    }
    return this.localPos;
};

// ------------------------- saiz ------------------------------------
mp4lib.boxes.SampleAuxiliaryInformationSizesBox = function(size) {
    mp4lib.boxes.FullBox.call(this, 'saiz', size);
};

mp4lib.boxes.SampleAuxiliaryInformationSizesBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);
mp4lib.boxes.SampleAuxiliaryInformationSizesBox.prototype.constructor = mp4lib.boxes.SampleAuxiliaryInformationSizesBox;

mp4lib.boxes.SampleAuxiliaryInformationSizesBox.prototype.computeLength = function() {
    mp4lib.boxes.FullBox.prototype.computeLength.call(this);

    if (this.flags & 1) {
        this.size += mp4lib.fields.FIELD_UINT32.getLength() * 2;
    }

    this.size += mp4lib.fields.FIELD_UINT8.getLength() + mp4lib.fields.FIELD_UINT32.getLength();

    if (this.default_sample_info_size === 0) {
        this.size += mp4lib.fields.FIELD_UINT8.getLength() * this.sample_count;
    }
};

mp4lib.boxes.SampleAuxiliaryInformationSizesBox.prototype.read = function(data, pos, end) {
    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);

    if (this.flags & 1) {
        this.aux_info_type = this._readData(data, mp4lib.fields.FIELD_UINT32);
        this.aux_info_type_parameter = this._readData(data, mp4lib.fields.FIELD_UINT32);
    }
    this.default_sample_info_size = this._readData(data, mp4lib.fields.FIELD_UINT8);
    this.sample_count = this._readData(data, mp4lib.fields.FIELD_UINT32);

    if (this.default_sample_info_size === 0) {
        this.sample_info_size = this._readArrayFieldData(data, mp4lib.fields.FIELD_UINT8, this.sample_count);
    }
    return this.localPos;
};

mp4lib.boxes.SampleAuxiliaryInformationSizesBox.prototype.write = function(data, pos) {
    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);
    var i = 0;
    if (this.flags & 1) {
        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.aux_info_type);
        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.aux_info_type_parameter);
    }
    this._writeData(data, mp4lib.fields.FIELD_UINT8, this.default_sample_info_size);
    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.sample_count);
    if (this.default_sample_info_size === 0) {
        for (i = 0; i < this.sample_count; i++) {
            this._writeData(data, mp4lib.fields.FIELD_UINT8, this.sample_info_size[i]);
        }
    }
    return this.localPos;
};

//------------------------- saio ------------------------------------
mp4lib.boxes.SampleAuxiliaryInformationOffsetsBox = function(size) {
    mp4lib.boxes.FullBox.call(this, 'saio', size);
};

mp4lib.boxes.SampleAuxiliaryInformationOffsetsBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);
mp4lib.boxes.SampleAuxiliaryInformationOffsetsBox.prototype.constructor = mp4lib.boxes.SampleAuxiliaryInformationOffsetsBox;

mp4lib.boxes.SampleAuxiliaryInformationOffsetsBox.prototype.computeLength = function() {
    mp4lib.boxes.FullBox.prototype.computeLength.call(this);
    if (this.flags & 1) {
        this.size += mp4lib.fields.FIELD_UINT32.getLength() * 2;
    }
    this.size += mp4lib.fields.FIELD_UINT32.getLength(); /*entry_count size */
    if (this.version === 0) {
        this.size += mp4lib.fields.FIELD_UINT32.getLength() * this.entry_count;
    } else {
        this.size += mp4lib.fields.FIELD_UINT64.getLength() * this.entry_count;
    }
};

mp4lib.boxes.SampleAuxiliaryInformationOffsetsBox.prototype.read = function(data, pos, end) {
    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);

    if (this.flags & 1) {
        this.aux_info_type = this._readData(data, mp4lib.fields.FIELD_UINT32);
        this.aux_info_type_parameter = this._readData(data, mp4lib.fields.FIELD_UINT32);
    }

    this.entry_count = this._readData(data, mp4lib.fields.FIELD_UINT32);

    if (this.version === 0) {
        this.offset = this._readArrayFieldData(data, mp4lib.fields.FIELD_UINT32, this.entry_count);
    } else {
        this.offset = this._readArrayFieldData(data, mp4lib.fields.FIELD_UINT64, this.entry_count);
    }
    return this.localPos;
};

mp4lib.boxes.SampleAuxiliaryInformationOffsetsBox.prototype.write = function(data, pos) {
    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);

    var i = 0;
    if (this.flags & 1) {
        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.aux_info_type);
        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.aux_info_type_parameter);
    }
    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.entry_count);
    if (this.version === 0) {
        for (i = 0; i < this.entry_count; i++) {
            this._writeData(data, mp4lib.fields.FIELD_UINT32, this.offset[i]);
        }
    } else {
        for (i = 0; i < this.entry_count; i++) {
            this._writeData(data, mp4lib.fields.FIELD_UINT64, this.offset[i]);
        }
    }
    return this.localPos;
};

//------------------------- sinf ------------------------------------
mp4lib.boxes.ProtectionSchemeInformationBox = function(size) {
    mp4lib.boxes.ContainerBox.call(this, 'sinf', size);
};

mp4lib.boxes.ProtectionSchemeInformationBox.prototype = Object.create(mp4lib.boxes.ContainerBox.prototype);
mp4lib.boxes.ProtectionSchemeInformationBox.prototype.constructor = mp4lib.boxes.ProtectionSchemeInformationBox;

//------------------------ schi --------------------------------------
mp4lib.boxes.SchemeInformationBox = function(size) {
    mp4lib.boxes.ContainerBox.call(this, 'schi', size);
};

mp4lib.boxes.SchemeInformationBox.prototype = Object.create(mp4lib.boxes.ContainerBox.prototype);
mp4lib.boxes.SchemeInformationBox.prototype.constructor = mp4lib.boxes.SchemeInformationBox;

//------------------------ tenc --------------------------------------
mp4lib.boxes.TrackEncryptionBox = function(size) {
    mp4lib.boxes.FullBox.call(this, 'tenc', size);
};

mp4lib.boxes.TrackEncryptionBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);
mp4lib.boxes.TrackEncryptionBox.prototype.constructor = mp4lib.boxes.TrackEncryptionBox;

mp4lib.boxes.TrackEncryptionBox.prototype.computeLength = function() {
    mp4lib.boxes.FullBox.prototype.computeLength.call(this);

    this.size += mp4lib.fields.FIELD_BIT24.getLength();
    this.size += mp4lib.fields.FIELD_UINT8.getLength();
    this.size += mp4lib.fields.FIELD_UINT8.getLength() * 16;
};

mp4lib.boxes.TrackEncryptionBox.prototype.read = function(data, pos, end) {
    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);

    this.default_IsEncrypted = this._readData(data, mp4lib.fields.FIELD_BIT24);
    this.default_IV_size = this._readData(data, mp4lib.fields.FIELD_UINT8);
    this.default_KID = this._readArrayFieldData(data, mp4lib.fields.FIELD_UINT8, 16);
    return this.localPos;
};

mp4lib.boxes.TrackEncryptionBox.prototype.write = function(data, pos) {
    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);

    this._writeData(data, mp4lib.fields.FIELD_BIT24, this.default_IsEncrypted);
    this._writeData(data, mp4lib.fields.FIELD_UINT8, this.default_IV_size);
    this._writeArrayData(data, mp4lib.fields.FIELD_UINT8, this.default_KID);
    return this.localPos;
};

//------------------------- schm -------------------------------------
mp4lib.boxes.SchemeTypeBox = function(size) {
    mp4lib.boxes.FullBox.call(this, 'schm', size);
};

mp4lib.boxes.SchemeTypeBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);
mp4lib.boxes.SchemeTypeBox.prototype.constructor = mp4lib.boxes.SchemeTypeBox;

mp4lib.boxes.SchemeTypeBox.prototype.computeLength = function() {
    mp4lib.boxes.FullBox.prototype.computeLength.call(this);

    this.size += mp4lib.fields.FIELD_UINT32.getLength() * 2;
    if (this.flags & 0x000001) {
        this.size += mp4lib.fields.FIELD_STRING.getLength(this.scheme_uri);
    }
};

mp4lib.boxes.SchemeTypeBox.prototype.read = function(data, pos, end) {
    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);

    this.scheme_type = this._readData(data, mp4lib.fields.FIELD_UINT32);
    this.scheme_version = this._readData(data, mp4lib.fields.FIELD_UINT32);
    if (this.flags & 0x000001) {
        this.scheme_uri = this._readData(data, mp4lib.fields.FIELD_STRING);
    }
    return this.localPos;
};

mp4lib.boxes.SchemeTypeBox.prototype.write = function(data, pos) {
    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);

    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.scheme_type);
    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.scheme_version);
    if (this.flags & 0x000001) {
        this._writeData(data, mp4lib.fields.FIELD_STRING, this.scheme_uri);
    }
    return this.localPos;
};

// --------------------------- elst ----------------------------------
mp4lib.boxes.EditListBox = function(size) {
    mp4lib.boxes.FullBox.call(this, 'elst', size);
    this.entries = [];
};

mp4lib.boxes.EditListBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);
mp4lib.boxes.EditListBox.prototype.constructor = mp4lib.boxes.EditListBox;

mp4lib.boxes.EditListBox.prototype.computeLength = function() {
    mp4lib.boxes.FullBox.prototype.computeLength.call(this);

    this.size += mp4lib.fields.FIELD_UINT32.getLength(); //entry_count size

    if (this.version === 1) {
        this.size += (mp4lib.fields.FIELD_UINT64.getLength() * 2 /*segment_duration and media_time size*/ +
            mp4lib.fields.FIELD_UINT16.getLength() * 2 /*media_rate_integer and media_rate_fraction size)*/ ) * this.entry_count;
    } else { // version==0
        this.size += (mp4lib.fields.FIELD_UINT32.getLength() * 2 /*segment_duration and media_time size*/ +
            mp4lib.fields.FIELD_UINT16.getLength() * 2 /*media_rate_integer and media_rate_fraction size)*/ ) * this.entry_count;
    }
};

mp4lib.boxes.EditListBox.prototype.read = function(data, pos, end) {
    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);
    var i = 0,
        struct = {};
    this.entry_count = this._readData(data, mp4lib.fields.FIELD_UINT32);

    for (i = 0; i < this.entry_count; i++) {
        struct = {};
        if (this.version === 1) {
            struct.segment_duration = this._readData(data, mp4lib.fields.FIELD_UINT64);
            struct.media_time = this._readData(data, mp4lib.fields.FIELD_UINT64);
        } else { // version==0
            struct.segment_duration = this._readData(data, mp4lib.fields.FIELD_UINT32);
            struct.media_time = this._readData(data, mp4lib.fields.FIELD_UINT32);
        }
        struct.media_rate_integer = this._readData(data, mp4lib.fields.FIELD_UINT16);
        struct.media_rate_fraction = this._readData(data, mp4lib.fields.FIELD_UINT16);
        this.entries.push(struct);
    }
    return this.localPos;
};

mp4lib.boxes.EditListBox.prototype.write = function(data, pos) {
    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);
    var i = 0;
    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.entry_count);
    for (i = 0; i < this.entry_count; i++) {

        if (this.version === 1) {
            this._writeData(data, mp4lib.fields.FIELD_UINT64, this.entries[i].segment_duration);
            this._writeData(data, mp4lib.fields.FIELD_UINT64, this.entries[i].media_time);
        } else { // version==0
            this._writeData(data, mp4lib.fields.FIELD_UINT32, this.entries[i].segment_duration);
            this._writeData(data, mp4lib.fields.FIELD_UINT32, this.entries[i].media_time);
        }
        this._writeData(data, mp4lib.fields.FIELD_UINT16, this.entries[i].media_rate_integer);
        this._writeData(data, mp4lib.fields.FIELD_UINT16, this.entries[i].media_rate_fraction);
    }
    return this.localPos;
};

// --------------------------- hmhd ----------------------------------
mp4lib.boxes.HintMediaHeaderBox = function(size) {
    mp4lib.boxes.FullBox.call(this, 'hmhd', size);
};

mp4lib.boxes.HintMediaHeaderBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);
mp4lib.boxes.HintMediaHeaderBox.prototype.constructor = mp4lib.boxes.HintMediaHeaderBox;

mp4lib.boxes.HintMediaHeaderBox.prototype.computeLength = function() {
    mp4lib.boxes.FullBox.prototype.computeLength.call(this);

    this.size += mp4lib.fields.FIELD_UINT16.getLength() * 2; //maxPDUsize and avgPDUsize size
    this.size += mp4lib.fields.FIELD_UINT32.getLength() * 3; //maxbitrate, avgbitrate and reserved size
};

mp4lib.boxes.HintMediaHeaderBox.prototype.read = function(data, pos, end) {
    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);

    this.maxPDUsize = this._readData(data, mp4lib.fields.FIELD_UINT16);
    this.avgPDUsize = this._readData(data, mp4lib.fields.FIELD_UINT16);
    this.maxbitrate = this._readData(data, mp4lib.fields.FIELD_UINT32);
    this.avgbitrate = this._readData(data, mp4lib.fields.FIELD_UINT32);
    this.reserved = this._readData(data, mp4lib.fields.FIELD_UINT32);
    return this.localPos;
};

mp4lib.boxes.HintMediaHeaderBox.prototype.write = function(data, pos) {
    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);

    this._writeData(data, mp4lib.fields.FIELD_UINT16, this.maxPDUsize);
    this._writeData(data, mp4lib.fields.FIELD_UINT16, this.avgPDUsize);
    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.maxbitrate);
    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.avgbitrate);
    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.reserved);
    return this.localPos;
};

// --------------------------- nmhd ----------------------------------
mp4lib.boxes.NullMediaHeaderBox = function(size) {
    mp4lib.boxes.FullBox.call(this, 'nmhd', size);
};

mp4lib.boxes.NullMediaHeaderBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);
mp4lib.boxes.NullMediaHeaderBox.prototype.constructor = mp4lib.boxes.NullMediaHeaderBox;

// --------------------------- ctts ----------------------------------
mp4lib.boxes.CompositionOffsetBox = function(size) {
    mp4lib.boxes.FullBox.call(this, 'ctts', size);
    this.entries = [];
};

mp4lib.boxes.CompositionOffsetBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);
mp4lib.boxes.CompositionOffsetBox.prototype.constructor = mp4lib.boxes.CompositionOffsetBox;

mp4lib.boxes.CompositionOffsetBox.prototype.computeLength = function() {
    mp4lib.boxes.FullBox.prototype.computeLength.call(this);

    this.size += mp4lib.fields.FIELD_UINT32.getLength(); //entry_count size

    if (this.version === 0) {
        this.size += (mp4lib.fields.FIELD_UINT32.getLength() * 2 /*sample_count and sample_offset size*/ ) * this.entry_count;
    } else { // version===1
        this.size += (mp4lib.fields.FIELD_UINT32.getLength() /*sample_count size*/ + mp4lib.fields.FIELD_INT32.getLength()
            /*sample_offset size*/
        ) * this.entry_count;
    }
};

mp4lib.boxes.CompositionOffsetBox.prototype.read = function(data, pos, end) {
    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);
    var i = 0,
        struct = {};
    this.entry_count = this._readData(data, mp4lib.fields.FIELD_UINT32);
    for (i = 0; i < this.entry_count; i++) {
        struct = {};

        if (this.version === 0) {
            struct.sample_count = this._readData(data, mp4lib.fields.FIELD_UINT32);
            struct.sample_offset = this._readData(data, mp4lib.fields.FIELD_UINT32);
        } else { // version==1
            struct.sample_count = this._readData(data, mp4lib.fields.FIELD_UINT32);
            struct.sample_offset = this._readData(data, mp4lib.fields.FIELD_INT32);
        }
        this.entries.push(struct);
    }
    return this.localPos;
};

mp4lib.boxes.CompositionOffsetBox.prototype.write = function(data, pos) {
    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);
    var i = 0;
    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.entry_count);
    for (i = 0; i < this.entry_count; i++) {
        if (this.version === 0) {
            this._writeData(data, mp4lib.fields.FIELD_UINT32, this.entries[i].sample_count);
            this._writeData(data, mp4lib.fields.FIELD_UINT32, this.entries[i].sample_offset);
        } else { // version==1
            this._writeData(data, mp4lib.fields.FIELD_UINT32, this.entries[i].sample_count);
            this._writeData(data, mp4lib.fields.FIELD_INT32, this.entries[i].sample_offset);
        }
    }
    return this.localPos;
};

// --------------------------- cslg ----------------------------------
mp4lib.boxes.CompositionToDecodeBox = function(size) {
    mp4lib.boxes.FullBox.call(this, 'cslg', size);
};

mp4lib.boxes.CompositionToDecodeBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);
mp4lib.boxes.CompositionToDecodeBox.prototype.constructor = mp4lib.boxes.CompositionToDecodeBox;

mp4lib.boxes.CompositionToDecodeBox.prototype.computeLength = function() {
    mp4lib.boxes.FullBox.prototype.computeLength.call(this);
    this.size += mp4lib.fields.FIELD_INT32.getLength() * 5;
};

mp4lib.boxes.CompositionToDecodeBox.prototype.read = function(data, pos, end) {
    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);

    this.compositionToDTSShift = this._readData(data, mp4lib.fields.FIELD_INT32);
    this.leastDecodeToDisplayDelta = this._readData(data, mp4lib.fields.FIELD_INT32);
    this.greatestDecodeToDisplayDelta = this._readData(data, mp4lib.fields.FIELD_INT32);
    this.compositionStartTime = this._readData(data, mp4lib.fields.FIELD_INT32);
    this.compositionEndTime = this._readData(data, mp4lib.fields.FIELD_INT32);
    return this.localPos;
};

mp4lib.boxes.CompositionToDecodeBox.prototype.write = function(data, pos) {
    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);

    this._writeData(data, mp4lib.fields.FIELD_INT32, this.compositionToDTSShift);
    this._writeData(data, mp4lib.fields.FIELD_INT32, this.leastDecodeToDisplayDelta);
    this._writeData(data, mp4lib.fields.FIELD_INT32, this.greatestDecodeToDisplayDelta);
    this._writeData(data, mp4lib.fields.FIELD_INT32, this.compositionStartTime);
    this._writeData(data, mp4lib.fields.FIELD_INT32, this.compositionEndTime);
    return this.localPos;
};

// --------------------------- stss ----------------------------------
mp4lib.boxes.SyncSampleBox = function(size) {
    mp4lib.boxes.FullBox.call(this, 'stss', size);
    this.entries = [];
};

mp4lib.boxes.SyncSampleBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);
mp4lib.boxes.SyncSampleBox.prototype.constructor = mp4lib.boxes.SyncSampleBox;

mp4lib.boxes.SyncSampleBox.prototype.computeLength = function() {
    mp4lib.boxes.FullBox.prototype.computeLength.call(this);
    this.size += mp4lib.fields.FIELD_UINT32.getLength(); //entry_count size
    this.size += mp4lib.fields.FIELD_UINT32.getLength() * this.entry_count; //entries size
};

mp4lib.boxes.SyncSampleBox.prototype.read = function(data, pos, end) {
    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);
    var i = 0,
        struct = {};

    this.entry_count = this._readData(data, mp4lib.fields.FIELD_UINT32);
    for (i = 0; i < this.entry_count; i++) {
        struct = {};
        struct.sample_number = this._readData(data, mp4lib.fields.FIELD_UINT32);
        this.entries.push(struct);
    }
    return this.localPos;
};

mp4lib.boxes.SyncSampleBox.prototype.write = function(data, pos) {
    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);
    var i = 0;
    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.entry_count);
    for (i = 0; i < this.entry_count; i++) {
        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.entries[i].sample_number);
    }
    return this.localPos;
};

// --------------------------- tref ----------------------------------
mp4lib.boxes.TrackReferenceBox = function(size) {
    mp4lib.boxes.FullBox.call(this, 'tref', size);
};

mp4lib.boxes.TrackReferenceBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);
mp4lib.boxes.TrackReferenceBox.prototype.constructor = mp4lib.boxes.TrackReferenceBox;

mp4lib.boxes.TrackReferenceBox.prototype.computeLength = function() {
    mp4lib.boxes.FullBox.prototype.computeLength.call(this);
    this.size += mp4lib.fields.FIELD_UINT32.getLength() * this.track_IDs.length;
};

mp4lib.boxes.TrackReferenceBox.prototype.read = function(data, pos, end) {
    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);
    this.track_IDs = this._readArrayData(data, mp4lib.fields.FIELD_UINT32);
    return this.localPos;
};

mp4lib.boxes.TrackReferenceBox.prototype.write = function(data, pos) {
    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);
    this._writeArrayData(data, mp4lib.fields.FIELD_UINT32, this.track_IDs);
    return this.localPos;
};

//---------------------------- frma ----------------------------------
mp4lib.boxes.OriginalFormatBox = function(size) {
    mp4lib.boxes.Box.call(this, 'frma', size);
};

mp4lib.boxes.OriginalFormatBox.prototype = Object.create(mp4lib.boxes.Box.prototype);
mp4lib.boxes.OriginalFormatBox.prototype.constructor = mp4lib.boxes.OriginalFormatBox;

mp4lib.boxes.OriginalFormatBox.prototype.computeLength = function() {
    mp4lib.boxes.Box.prototype.computeLength.call(this);
    this.size += mp4lib.fields.FIELD_UINT32.getLength();
};

mp4lib.boxes.OriginalFormatBox.prototype.read = function(data, pos, end) {
    this.localPos = pos;
    this.localEnd = end;
    this.data_format = this._readData(data, mp4lib.fields.FIELD_UINT32);
    return this.localPos;
};

mp4lib.boxes.OriginalFormatBox.prototype.write = function(data, pos) {
    mp4lib.boxes.Box.prototype.write.call(this, data, pos);
    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.data_format);
    return this.localPos;
};

// -------------------------------------------------------------------
// Microsoft Smooth Streaming specific boxes
// -------------------------------------------------------------------

// --------------------------- piff ----------------------------------
//PIFF Sample Encryption box
mp4lib.boxes.PiffSampleEncryptionBox = function(size) {
    mp4lib.boxes.FullBox.call(this, 'sepiff', size, [0xA2, 0x39, 0x4F, 0x52, 0x5A, 0x9B, 0x4F, 0x14, 0xA2, 0x44, 0x6C, 0x42, 0x7C, 0x64, 0x8D, 0xF4]);
};

mp4lib.boxes.PiffSampleEncryptionBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);
mp4lib.boxes.PiffSampleEncryptionBox.prototype.constructor = mp4lib.boxes.PiffSampleEncryptionBox;

mp4lib.boxes.PiffSampleEncryptionBox.prototype.computeLength = function() {
    mp4lib.boxes.FullBox.prototype.computeLength.call(this);
    var i = 0,
        j = 0;

    this.size += mp4lib.fields.FIELD_UINT32.getLength(); //sample_count size
    if (this.flags & 1) {
        this.size += mp4lib.fields.FIELD_UINT8.getLength(); //IV_size size
    }
    for (i = 0; i < this.sample_count; i++) {
        this.size += 8; // InitializationVector size
        if (this.flags & 2) {
            this.size += mp4lib.fields.FIELD_UINT16.getLength(); // NumberOfEntries size
            for (j = 0; j < this.entry[i].NumberOfEntries; j++) {
                this.size += mp4lib.fields.FIELD_UINT16.getLength(); //BytesOfClearData size
                this.size += mp4lib.fields.FIELD_UINT32.getLength(); //BytesOfEncryptedData size
            }
        }
    }
};

mp4lib.boxes.PiffSampleEncryptionBox.prototype.write = function(data, pos) {
    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);
    var i = 0,
        j = 0;
    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.sample_count);
    if (this.flags & 1) {
        this._writeData(data, mp4lib.fields.FIELD_UINT8, this.IV_size);
    }
    for (i = 0; i < this.sample_count; i++) {
        this._writeBuffer(data, this.entry[i].InitializationVector, 8);

        if (this.flags & 2) {
            this._writeData(data, mp4lib.fields.FIELD_UINT16, this.entry[i].NumberOfEntries); // NumberOfEntries

            for (j = 0; j < this.entry[i].NumberOfEntries; j++) {
                this._writeData(data, mp4lib.fields.FIELD_UINT16, this.entry[i].clearAndCryptedData[j].BytesOfClearData); //BytesOfClearData
                this._writeData(data, mp4lib.fields.FIELD_UINT32, this.entry[i].clearAndCryptedData[j].BytesOfEncryptedData); //BytesOfEncryptedData size
            }
        }
    }
    return this.localPos;
};

mp4lib.boxes.PiffSampleEncryptionBox.prototype.read = function(data, pos, end) {
    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);
    var i = 0,
        j = 0,
        clearAndCryptedStruct = {},
        struct = {};
    this.sample_count = this._readData(data, mp4lib.fields.FIELD_UINT32);
    if (this.flags & 1) {
        this.IV_size = this._readData(data, mp4lib.fields.FIELD_UINT8);
    }
    this.entry = [];
    for (i = 0; i < this.sample_count; i++) {
        struct = {};
        struct.InitializationVector = data.subarray(this.localPos, this.localPos + 8);
        this.localPos += 8; //InitializationVector size

        if (this.flags & 2) {
            struct.NumberOfEntries = this._readData(data, mp4lib.fields.FIELD_UINT16); // NumberOfEntries
            struct.clearAndCryptedData = [];
            for (j = 0; j < struct.NumberOfEntries; j++) {
                clearAndCryptedStruct = {};
                clearAndCryptedStruct.BytesOfClearData = this._readData(data, mp4lib.fields.FIELD_UINT16); //BytesOfClearData
                clearAndCryptedStruct.BytesOfEncryptedData = this._readData(data, mp4lib.fields.FIELD_UINT32); //BytesOfEncryptedData size
                struct.clearAndCryptedData.push(clearAndCryptedStruct);
            }
        }
        this.entry.push(struct);
    }
    return this.localPos;
};

//PIFF Track Encryption Box
mp4lib.boxes.PiffTrackEncryptionBox = function(size) {
    mp4lib.boxes.FullBox.call(this, 'tepiff', size, [0x89, 0x74, 0xDB, 0xCE, 0x7B, 0xE7, 0x4C, 0x51, 0x84, 0xF9, 0x71, 0x48, 0xF9, 0x88, 0x25, 0x54]);
};

mp4lib.boxes.PiffTrackEncryptionBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);
mp4lib.boxes.PiffTrackEncryptionBox.prototype.constructor = mp4lib.boxes.PiffTrackEncryptionBox;

//PIFF Protection System Specific Header Box
mp4lib.boxes.PiffProtectionSystemSpecificHeaderBox = function(size) {
    mp4lib.boxes.FullBox.call(this, 'psshpiff', size, [0xD0, 0x8A, 0x4F, 0x18, 0x10, 0xF3, 0x4A, 0x82, 0xB6, 0xC8, 0x32, 0xD8, 0xAB, 0xA1, 0x83, 0xD3]);
};

mp4lib.boxes.PiffProtectionSystemSpecificHeaderBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);
mp4lib.boxes.PiffProtectionSystemSpecificHeaderBox.prototype.constructor = mp4lib.boxes.PiffProtectionSystemSpecificHeaderBox;

// --------------------------- tfdx -----------------------------
mp4lib.boxes.TfxdBox = function(size) {
    mp4lib.boxes.FullBox.call(this, 'tfxd', size, [0x6D, 0x1D, 0x9B, 0x05, 0x42, 0xD5, 0x44, 0xE6, 0x80, 0xE2, 0x14, 0x1D, 0xAF, 0xF7, 0x57, 0xB2]);
};

mp4lib.boxes.TfxdBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);
mp4lib.boxes.TfxdBox.prototype.constructor = mp4lib.boxes.TfxdBox;

mp4lib.boxes.TfxdBox.prototype.computeLength = function() {
    mp4lib.boxes.FullBox.prototype.computeLength.call(this);
    if (this.version === 1) {
        this.size += mp4lib.fields.FIELD_UINT64.getLength() * 2;
    } else {
        this.size += mp4lib.fields.FIELD_UINT32.getLength() * 2;
    }
};

mp4lib.boxes.TfxdBox.prototype.write = function(data, pos) {
    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);

    if (this.version === 1) {
        this._writeData(data, mp4lib.fields.FIELD_UINT64, this.fragment_absolute_time);
        this._writeData(data, mp4lib.fields.FIELD_UINT64, this.fragment_duration);
    } else {
        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.fragment_absolute_time);
        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.fragment_duration);
    }
    return this.localPos;
};

mp4lib.boxes.TfxdBox.prototype.read = function(data, pos, end) {
    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);

    if (this.version === 1) {
        this.fragment_absolute_time = this._readData(data, mp4lib.fields.FIELD_UINT64);
        this.fragment_duration = this._readData(data, mp4lib.fields.FIELD_UINT64);
    } else {
        this.fragment_absolute_time = this._readData(data, mp4lib.fields.FIELD_UINT32);
        this.fragment_duration = this._readData(data, mp4lib.fields.FIELD_UINT32);
    }
    return this.localPos;
};

// --------------------------- tfrf -----------------------------
mp4lib.boxes.TfrfBox = function(size) {
    mp4lib.boxes.FullBox.call(this, 'tfrf', size, [0xD4, 0x80, 0x7E, 0xF2, 0xCA, 0x39, 0x46, 0x95, 0x8E, 0x54, 0x26, 0xCB, 0x9E, 0x46, 0xA7, 0x9F]);
};

mp4lib.boxes.TfrfBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);
mp4lib.boxes.TfrfBox.prototype.constructor = mp4lib.boxes.TfrfBox;

mp4lib.boxes.TfrfBox.prototype.computeLength = function() {
    mp4lib.boxes.FullBox.prototype.computeLength.call(this);

    this.size += mp4lib.fields.FIELD_UINT8.getLength(); //fragment_count size
    if (this.version === 1) {
        this.size += (mp4lib.fields.FIELD_UINT64.getLength() * 2 /*fragment_absolute_time and fragment_duration size*/ ) * this.fragment_count;
    } else {
        this.size += (mp4lib.fields.FIELD_UINT32.getLength() * 2 /*fragment_absolute_time and fragment_duration size*/ ) * this.fragment_count;
    }
};

mp4lib.boxes.TfrfBox.prototype.write = function(data, pos) {
    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);
    var i = 0;
    this._writeData(data, mp4lib.fields.FIELD_UINT8, this.fragment_count);
    for (i = 0; i < this.fragment_count; i++) {
        if (this.version === 1) {
            this._writeData(data, mp4lib.fields.FIELD_UINT64, this.entry[i].fragment_absolute_time);
            this._writeData(data, mp4lib.fields.FIELD_UINT64, this.entry[i].fragment_duration);
        } else {
            this._writeData(data, mp4lib.fields.FIELD_UINT32, this.entry[i].fragment_absolute_time);
            this._writeData(data, mp4lib.fields.FIELD_UINT32, this.entry[i].fragment_duration);
        }
    }
    return this.localPos;
};

mp4lib.boxes.TfrfBox.prototype.read = function(data, pos, end) {
    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);
    var i = 0,
        struct = {};
    this.fragment_count = this._readData(data, mp4lib.fields.FIELD_UINT8);
    this.entry = [];
    for (i = 0; i < this.fragment_count; i++) {
        struct = {};
        if (this.version === 1) {
            struct.fragment_absolute_time = this._readData(data, mp4lib.fields.FIELD_UINT64);
            struct.fragment_duration = this._readData(data, mp4lib.fields.FIELD_UINT64);
        } else {
            struct.fragment_absolute_time = this._readData(data, mp4lib.fields.FIELD_UINT32);
            struct.fragment_duration = this._readData(data, mp4lib.fields.FIELD_UINT32);
        }
        this.entry.push(struct);
    }
    return this.localPos;
};

// --------------------------- subs -----------------------------
mp4lib.boxes.SubSampleInformationBox = function(size) {
    mp4lib.boxes.FullBox.call(this, 'subs', size);
};

mp4lib.boxes.SubSampleInformationBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);
mp4lib.boxes.SubSampleInformationBox.prototype.constructor = mp4lib.boxes.SubSampleInformationBox;

mp4lib.boxes.SubSampleInformationBox.prototype.computeLength = function() {
    mp4lib.boxes.FullBox.prototype.computeLength.call(this);

    this.size += mp4lib.fields.FIELD_UINT32.getLength(); //entry_count size
    for (i = 0; i < this.entry_count; i++) {
        this.size += mp4lib.fields.FIELD_UINT32.getLength(); //sample_delta size
        this.size += mp4lib.fields.FIELD_UINT16.getLength(); //subsample_count size

        if (this.entry[i].subsample_count > 0) {
            for (j=0; j < this.entry[i].subsample_count; j++) {                
                if (this.version === 1) {
                    this.size += mp4lib.fields.FIELD_UINT32.getLength(); //subsample_size size
                } else {
                    this.size += mp4lib.fields.FIELD_UINT16.getLength(); //subsample_size size
                }

                this.size += mp4lib.fields.FIELD_UINT8.getLength(); //subsample_priority size
                this.size += mp4lib.fields.FIELD_UINT8.getLength(); //discardable size
                this.size += mp4lib.fields.FIELD_UINT32.getLength(); //reserved size
            }
        }
    }
};

mp4lib.boxes.SubSampleInformationBox.prototype.read = function(data, pos, end) {
    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);
    var i = 0,
        j = 0,
        struct = {},
        subSampleStruct = {};

    this.entry_count = this._readData(data, mp4lib.fields.FIELD_UINT32);
    this.entry = [];
    for (i = 0; i < this.entry_count; i++) {
        struct = {};
        struct.sample_delta = this._readData(data, mp4lib.fields.FIELD_UINT32);
        struct.subsample_count = this._readData(data, mp4lib.fields.FIELD_UINT16);
        if (struct.subsample_count > 0) {
            struct.subSampleEntries = [];
            for (j=0; j < struct.subsample_count; j++) {
                subSampleStruct = {};
                if (this.version === 1) {
                    subSampleStruct.subsample_size = this._readData(data, mp4lib.fields.FIELD_UINT32);
                } else {
                    subSampleStruct.subsample_size = this._readData(data, mp4lib.fields.FIELD_UINT16);
                }
                subSampleStruct.subsample_priority = this._readData(data, mp4lib.fields.FIELD_UINT8);
                subSampleStruct.discardable = this._readData(data, mp4lib.fields.FIELD_UINT8);
                subSampleStruct.reserved = this._readData(data, mp4lib.fields.FIELD_UINT32);
                struct.subSampleEntries.push(subSampleStruct);
            }
        }
        this.entry.push(struct);
    }

    return this.localPos;
};

mp4lib.boxes.SubSampleInformationBox.prototype.write = function(data, pos) {
    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);
    var i = 0,
        j = 0;

    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.entry_count);

    for (i = 0; i < this.entry_count; i++) {
        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.entry[i].sample_delta);
        this._writeData(data, mp4lib.fields.FIELD_UINT16, this.entry[i].subsample_count);
        if (this.entry[i].subsample_count > 0) {

            for (j = 0; j < this.entry[i].subsample_count; j++) {
                if (this.version === 1) {
                    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.entry[i].subSampleEntries[j].subsample_size);
                } else {
                    this._writeData(data, mp4lib.fields.FIELD_UINT16, this.entry[i].subSampleEntries[j].subsample_size);
                }
                this._writeData(data, mp4lib.fields.FIELD_UINT8, this.entry[i].subSampleEntries[j].subsample_priority);
                this._writeData(data, mp4lib.fields.FIELD_UINT8, this.entry[i].subSampleEntries[j].discardable);
                this._writeData(data, mp4lib.fields.FIELD_UINT32, this.entry[i].subSampleEntries[j].reserved);
            }
        }
    }

    return this.localPos;
};

mp4lib.registerTypeBoxes();
/*
 * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.
 * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2014, Orange
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
var mpegts = (function() {
    return {
        pes: {},
        si: {},
        binary: {},
        ts: {},
        Pts: {},
        aac: {},
        h264: {}
    };
}());

// This module is intended to work both on node.js and inside browser.
// Since these environments differ in a way modules are stored/accessed,
// we need to export the module in the environment-dependant way

if (typeof module !== 'undefined' && typeof module.exports !== 'undefined')
    module.exports = mpegts; // node.js
else
    window.mpegts = mpegts; // browser
/*
 * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.
 * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2014, Orange
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
mpegts.si.PSISection = function(table_id) {
    this.m_table_id = table_id;
    this.m_section_syntax_indicator = 1;
    this.m_section_length = mpegts.si.PSISection.prototype.SECTION_LENGTH;
    this.m_transport_stream_id = 0;
    this.m_version_number = 0;
    this.m_current_next_indicator = true;
    this.m_section_number = 0;
    this.m_last_section_number = 0;
    this.m_bValid = null;
};

mpegts.si.PSISection.prototype.parse = function(data) {
    this.m_bValid = false;

    var id = 0;

    var pointerField = data[id];

    //if pointerField = 0 payload data start immediately otherwise, shift pointerField value
    id = pointerField === 0 ? id + 1 : id + pointerField;

    this.m_table_id = data[id];
    id++;
    this.m_section_syntax_indicator = mpegts.binary.getBitFromByte(data[id], 0);
    this.m_section_length = mpegts.binary.getValueFrom2Bytes(data.subarray(id, id + 2), 4);
    id += 2;
    this.m_transport_stream_id = mpegts.binary.getValueFrom2Bytes(data.subarray(id, id + 2));
    id += 2;
    this.m_version_number = mpegts.binary.getValueFromByte(data[id], 2, 5);
    this.m_current_next_indicator = mpegts.binary.getBitFromByte(data[id], 7);
    id++;
    this.m_section_number = data[id];
    id++;
    this.m_last_section_number = data[id];

    /*if (nLength < (m_section_length + 3))
	{
		m_bComplete = false;
		SAFE_DELETE(m_pBytestream);
		m_pBytestream = new unsigned char[m_section_length + 3];
		memcpy(m_pBytestream, pBytestream, nLength);
		m_nSectionIndex = nLength;
		return;
	}

	m_nSectionIndex = 0;
	m_bComplete = true;*/
    this.m_bValid = true;

    return id;
};

mpegts.si.PSISection.prototype.getSectionLength = function() {
    return this.m_section_length;
};

mpegts.si.PSISection.prototype.SECTION_LENGTH = 9;
mpegts.si.PSISection.prototype.HEADER_LENGTH = 8;
/*
 * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.
 * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2014, Orange
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

// Sampling frequency dependent on sampling_frequency_index
mpegts.aac.SAMPLING_FREQUENCY = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];

mpegts.aac.getAudioSpecificConfig = function(data) { // data as Uint8Array

    // We need to parse the beginning of the adts_frame in order to get
    // object type, sampling frequency and channel configuration
    var profile = mpegts.binary.getValueFromByte(data[2], 0, 2);
    var sampling_frequency_index = mpegts.binary.getValueFromByte(data[2], 2, 4);
    var channel_configuration = mpegts.binary.getValueFrom2Bytes(data.subarray(2, 5), 7, 3);

    var audioSpecificConfig = new Uint8Array(2);

    // audioObjectType = profile = MPEG-4 Audio Object Type minus 1
    audioSpecificConfig[0] = (profile + 1) << 3;

    // samplingFrequencyIndex
    audioSpecificConfig[0] |= (sampling_frequency_index & 0x0E) >> 1;
    audioSpecificConfig[1] |= (sampling_frequency_index & 0x01) << 7;

    // channelConfiguration
    audioSpecificConfig[1] |= channel_configuration << 3;

    /*  code for HE AAC v2 to be tested

    var audioSpecificConfig = new Uint8Array(4);

    // audioObjectType = profile => profile, the MPEG-4 Audio Object Type minus 1
    audioSpecificConfig[0] = 29 << 3;

    // samplingFrequencyIndex
    audioSpecificConfig[0] |= (sampling_frequency_index & 0x0E) >> 1;
    audioSpecificConfig[1] |= (sampling_frequency_index & 0x01) << 7;

    // channelConfiguration
    audioSpecificConfig[1] |= channel_configuration << 3;
    
    var extensionSamplingFrequencyIndex = 5;// in HE AAC Extension Sampling frequence

    audioSpecificConfig[1] |= extensionSamplingFrequencyIndex >> 1;
       
    audioSpecificConfig[2] = (extensionSamplingFrequencyIndex << 7) | ((profile+1) << 2);// origin object type equals to 2 => AAC Main Low Complexity
    audioSpecificConfig[3] = 0x0; //alignment bits

   */

    return audioSpecificConfig;
};

mpegts.aac.parseADTS = function(data, cts) { // data as Uint8Array, cts as an array of cts for each frame index

    var aacFrames = [],
        adtsHeader = {},
        aacFrame,
        adtsFrameIndex,
        i = 0;

    while (i < data.length) {
        // = adts_frame
        adtsFrameIndex = i;

        // == adts_fixed_header
        adtsHeader.syncword = (data[i] << 4) + ((data[i + 1] & 0xF0) >> 4);
        // adtsHeader.ID
        // adtsHeader.layer
        adtsHeader.protection_absent = data[i + 1] & 0x01;
        // adtsHeader.profile
        adtsHeader.sampling_frequency_index = (data[i + 2] & 0x3C) >> 2;
        // adtsHeader.private_bit
        adtsHeader.channel_configuration = ((data[i + 2] & 0x01) << 1) + ((data[i + 3] & 0xC0) >> 6);
        // adtsHeader.original_copy
        // adtsHeader.home

        // == adts_variable_header
        // adtsHeader.copyright_identification_bit
        // adtsHeader.copyright_identification_start
        adtsHeader.aac_frame_length = ((data[i + 3] & 0x03) << 11) + (data[i + 4] << 3) + ((data[i + 5] & 0xE0) >> 5);
        // adtsHeader.adts_buffer_fullness
        adtsHeader.number_of_raw_data_blocks_in_frame = (data[i + 6] & 0x03) >> 2;

        i += 7;

        if (adtsHeader.number_of_raw_data_blocks_in_frame === 0) {
            // == adts_error_check()
            if (adtsHeader.protection_absent === 0) {
                i += 2;
            }

            // == raw_data_block() => create AAC frame
            aacFrame = {};
            aacFrame.offset = i;
            aacFrame.length = adtsHeader.aac_frame_length - (i - adtsFrameIndex);

            if (cts && cts[adtsFrameIndex]) {
                aacFrame.cts = cts[adtsFrameIndex];
            }

            aacFrames.push(aacFrame);

            i += aacFrame.length;
        } else {
            // == adts_header_error_check
        }
    }

    return aacFrames;
};
/*
 * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.
 * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2014, Orange
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
mpegts.ts.AdaptationField = function() {
    /** adaptation field fields */
    this.m_cAFLength = null;
    this.m_bDiscontinuityInd = null;
    this.m_bRAI = null;
    this.m_bESPriority = null;

    /** Optional fields flags */
    this.m_bPCRFlag = null;
    this.m_bOPCRFlag = null;
    this.m_bSplicingPointFlag = null;
    this.m_bPrivateDataFlag = null;
    this.m_bAdaptationFieldExtFlag = null;
};

mpegts.ts.AdaptationField.prototype.getLength = function() {
    return (this.m_cAFLength + 1);
};

mpegts.ts.AdaptationField.prototype.parse = function(data) {
    this.m_cAFLength = data[0];

    if (this.m_cAFLength === 0) {
        // = exactly 1 stuffing byte
        return;
    }

    var index = 1;

    this.m_bDiscontinuityInd = mpegts.binary.getBitFromByte(data[index], 0);
    this.m_bRAI = mpegts.binary.getBitFromByte(data[index], 1);
    this.m_bESPriority = mpegts.binary.getBitFromByte(data[index], 2);
    this.m_bPCRFlag = mpegts.binary.getBitFromByte(data[index], 3);
    this.m_bOPCRFlag = mpegts.binary.getBitFromByte(data[index], 4);
    this.m_bSplicingPointFlag = mpegts.binary.getBitFromByte(data[index], 5);
    this.m_bPrivateDataFlag = mpegts.binary.getBitFromByte(data[index], 6);
    this.m_bAdaptationFieldExtFlag = mpegts.binary.getBitFromByte(data[index], 7);

    //other flags are not useful for the conversion HLS => MP4
};
/*
 * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.
 * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2014, Orange
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
mpegts.binary.readBytes = function(buf, pos, nbBytes) {
    var value = 0;
    for (var i = 0; i < nbBytes; i++) {
        value = value << 8;
        value = value + buf[pos];
        pos++;
    }
    return value;
};

/**
 * Returns a bit value from the given byte
 * @param data the input byte
 * @param bitIndex the bit index inside the byte (0=msb to 7=lsb)
 * @return the bit value as a boolean (0 => false, 1 => true)
 */
mpegts.binary.getBitFromByte = function(data, bitIndex) {
    var cMask = 0x00;
    cMask += (1 << (7 - bitIndex));

    return ((data & cMask) !== 0);
};

/**
 * Returns the value extracted from three consecutive bytes
 * @param pBytes the input bytes
 * @param msbIndex the index of the first bit to extract ( 0=msb to 15=lsb )
 * @param nbBits the number of bits to extract (if '-1' then extract up to the last bit)
 * @return the value of the extracted bits as an unsigned short, or 0xFFFFFFFF if a problem has occured
 */
mpegts.binary.getValueFrom3Bytes = function(pBytes, msbIndex /* = 0*/ , nbBits /* = -1*/ ) {
    if (typeof nbBits === "undefined") {
        nbBits = -1;
    }
    if (typeof msbIndex === "undefined") {
        msbIndex = 0;
    }
    var nbBits2 = nbBits == -1 ? -1 : (nbBits - (16 - msbIndex));
    var nbLsbShift = nbBits == -1 ? 0 : (8 - nbBits2);
    var cValue0 = mpegts.binary.getValueFromByte(pBytes[0], msbIndex);
    var cValue1 = mpegts.binary.getValueFromByte(pBytes[1]);
    var cValue2 = mpegts.binary.getValueFromByte(pBytes[2], 0, nbBits2, false);

    return ((((cValue0 << 16) & 0x00FF0000) | ((cValue1 << 8) & 0x0000FF00) | (cValue2 & 0x000000FF)) >> nbLsbShift);
};

/**
 * Returns the value extracted from two consecutive bytes
 * @param data the input bytes
 * @param msbIndex the index of the first bit to extract ( 0=msb to 15=lsb )
 * @param nbBits the number of bits to extract (if '-1' then extract up to the last bit)
 * @return the value of the extracted bits as an unsigned short, or 0xFFFF if a problem has occured
 */
mpegts.binary.getValueFrom2Bytes = function(data, msbIndex /* = 0*/ , nbBits /* = -1*/ ) {
    if (typeof nbBits === "undefined") {
        nbBits = -1;
    }
    if (typeof msbIndex === "undefined") {
        msbIndex = 0;
    }

    var nbBits1 = nbBits == -1 ? -1 : (nbBits - (8 - msbIndex));
    var nbLsbShift = nbBits == -1 ? 0 : (8 - nbBits1);
    var cValue0 = mpegts.binary.getValueFromByte(data[0], msbIndex);
    var cValue1 = mpegts.binary.getValueFromByte(data[1], 0, nbBits1, false);

    return ((((cValue0 << 8) & 0xFF00) | (cValue1 & 0x00FF)) >> nbLsbShift);
};

/**
 * Returns the value extracted from the given byte
 * @param data the input byte
 * @param msbIndex the index of the first bit to extract ( 0=msb to 7=lsb )
 * @param nbBits the number of bits to extract (if '-1' then extract up to the last bit)
 * @param bShift true if the bits have to be shifted to the right
 * @return the value of the extracted bits as an unsigned char, or 0xFF if a problem has occurred
 */
mpegts.binary.getValueFromByte = function(data, msbIndex /* = 0*/ , nbBits /* = -1*/ , bShift /* = true*/ ) {
    var cMask = 0x00;
    var i = 0;

    if (typeof nbBits === "undefined") {
        nbBits = -1;
    }
    if (typeof msbIndex === "undefined") {
        msbIndex = 0;
    }

    var lsbIndex = (nbBits == -1) ? 7 : (msbIndex + nbBits - 1);
    for (i = msbIndex; i <= lsbIndex; i++) {
        cMask += (1 << (7 - i));
    }

    var cValue = data & cMask;
    if (bShift || typeof bShift === "undefined") {
        cValue >>= (7 - lsbIndex);
    }
    return cValue;
};
/*
 * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.
 * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2014, Orange
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
mpegts.h264.getSequenceHeader = function(data) { // data as Uint8Array

    var pos = -1,
        length = -1,
        i = 0,
        naluType,
        sequenceHeader = null,
        width = 0,
        height = 0;

    while (i < data.length) {
        if ((data[i] === 0x00) && (data[i + 1] === 0x00) && (data[i + 2] === 0x00) && (data[i + 3] === 0x01)) {

            naluType = data[i + 4] & 0x1F;

            // Start of SPS or PPS
            if ((naluType >= mpegts.h264.NALUTYPE_SPS) && (naluType <= mpegts.h264.NALUTYPE_PPS)) {
                // First NALU of this type => we start storing the sequence header
                if (pos === -1) {
                    pos = i;
                }

                // SPS => parse to get width and height
                if (naluType === mpegts.h264.NALUTYPE_SPS) {
                    var sps = mpegts.h264.parseSPS(data.subarray(i + 5)); // +5 => after nal_unit_type byte
                    width = (sps.pic_width_in_mbs_minus1 + 1) << 4;
                    height = (sps.pic_height_in_map_units_minus1 + 1) << 4;
                }
            } else if (pos > 0) {
                length = i - pos;
            }

            // Start of coded picture NALU
            if ((naluType === mpegts.h264.NALUTYPE_IDR) || (naluType === mpegts.h264.NALUTYPE_NONIDR)) {
                break;
            }

            i += 4;
        } else if ((data[i] === 0x00) && (data[i + 1] === 0x00) && (data[i + 2] === 0x01)) {
            if (pos > 0) {
                length = i - pos;
            }
            break;
        } else {
            i++;
        }
    }

    if ((pos === -1) || (length === -1)) {
        return null;
    }

    sequenceHeader = new Uint8Array(length);
    sequenceHeader.set(data.subarray(pos, pos + length));

    return {
        bytes: sequenceHeader,
        width: width,
        height: height
    };
};

mpegts.h264.read_ue = function(data, ctx) {

    var value = 1,
        temp = 0,
        numZeros = 0;

    ctx._bit = (ctx._byte >> ctx._bitPos) & 0x01;
    ctx._bitPos--;
    if (ctx._bitPos < 0) {
        ctx._byte = data[ctx._bytePos];
        ctx._bytePos++;
        ctx._bitPos = 7;
    }

    while (ctx._bit === 0) {
        numZeros++;
        value = value << 1;
        ctx._bit = (ctx._byte >> ctx._bitPos) & 0x01;
        ctx._bitPos--;
        if (ctx._bitPos < 0) {
            ctx._byte = data[ctx._bytePos];
            ctx._bytePos++;
            ctx._bitPos = 7;
        }
    }

    value -= 1;
    temp = 0;
    if (numZeros) {
        while (numZeros > 0) {
            ctx._bit = (ctx._byte >> ctx._bitPos) & 0x01;
            ctx._bitPos--;
            temp = (temp << 1) + ctx._bit;
            numZeros--;
            if (ctx._bitPos < 0) {
                ctx._byte = data[ctx._bytePos];
                ctx._bytePos++;
                ctx._bitPos = 7;
            }
        }
    }
    value += temp;

    return value;
};

mpegts.h264.read_flag = function(data, ctx) {

    var value = 0;

    ctx._bit = (ctx._byte >> ctx._bitPos) & 0x01;
    ctx._bitPos--;
    if (ctx._bitPos < 0) {
        ctx._byte = data[ctx._bytePos];
        ctx._bytePos++;
        ctx._bitPos = 7;
    }
    value = ctx._bit;

    return value;
};


mpegts.h264.parseSPS = function(data) {

    var sps = {
            profile_idc: 0,
            constraint_set0_flag: 0,
            constraint_set1_flag: 0,
            constraint_set2_flag: 0,
            constraint_set3_flag: 0,
            level_idc: 0,
            seq_parameter_set_id: 0,
            chroma_format_idc: 0,
            separate_colour_plane_flag: 0,
            bit_depth_luma_minus8: 0,
            bit_depth_chroma_minus8: 0,
            qpprime_y_zero_transform_bypass_flag: 0,
            seq_scaling_matrix_present_flag: 0,
            log2_max_frame_num_minus4: 0,
            pic_order_cnt_type: 0,
            log2_max_pic_order_cnt_lsb_minus4: 0,
            num_ref_frames: 0,
            gaps_in_frame_num_value_allowed_flag: 0,
            pic_width_in_mbs_minus1: 0,
            pic_height_in_map_units_minus1: 0
        },

        ctx = {
            _byte: 0,
            _bit: 0,
            _bytePos: 0,
            _bitPos: 0
        };


    ctx._bytePos = ctx._bitPos = 0;

    // profile_idc - u(8)
    ctx._byte = data[ctx._bytePos];
    ctx._bytePos++;
    sps.profile_idc = ctx._byte;

    // constraint_set_flag (0/1/2/3 + reserved bits) - u(8)
    ctx._byte = data[ctx._bytePos];
    ctx._bytePos++;
    sps.constraint_set0_flag = (ctx._byte & 0x80) >> 7;
    sps.constraint_set1_flag = (ctx._byte & 0x40) >> 6;
    sps.constraint_set2_flag = (ctx._byte & 0x20) >> 5;
    sps.constraint_set3_flag = (ctx._byte & 0x10) >> 4;

    // level_idc - u(8)
    ctx._byte = data[ctx._bytePos];
    ctx._bytePos++;
    sps.level_idc = ctx._byte;

    // seq_parameter_set_id - ue(v)
    ctx._byte = data[ctx._bytePos];
    ctx._bytePos++;
    ctx._bitPos = 7;
    sps.seq_parameter_set_id = mpegts.h264.read_ue(data, ctx);

    if ((sps.profile_idc === 100) ||
        (sps.profile_idc === 110) ||
        (sps.profile_idc === 122) ||
        (sps.profile_idc === 244) ||
        (sps.profile_idc === 44) ||
        (sps.profile_idc === 83) ||
        (sps.profile_idc === 86)) {

        // chroma_format_idc - ue(v)
        sps.chroma_format_idc = mpegts.h264.read_ue(data, ctx);

        if (sps.chroma_format_idc === 3) {
            // separate_colour_plane_flag - u(1)
            sps.separate_colour_plane_flag = mpegts.h264.read_flag(data, ctx);
        }

        // bit_depth_luma_minus8 - ue(v)
        sps.bit_depth_luma_minus8 = mpegts.h264.read_ue(data, ctx);

        // bit_depth_chroma_minus8 - ue(v)
        sps.bit_depth_chroma_minus8 = mpegts.h264.read_ue(data, ctx);

        // qpprime_y_zero_transform_bypass_flag - u(1)
        sps.qpprime_y_zero_transform_bypass_flag = mpegts.h264.read_flag(data, ctx);

        // seq_scaling_matrix - u(1)
        sps.seq_scaling_matrix_present_flag = mpegts.h264.read_flag(data, ctx);

        if (sps.seq_scaling_matrix_present_flag === 1) {
            // NOT IMPLEMENTED
            //console.log("H.264 SPS parsing: (seq_scaling_matrix_present_flag = 1) not implemented");
        }
    }

    // log2_max_frame_num_minus4 - ue(v)
    sps.log2_max_frame_num_minus4 = mpegts.h264.read_ue(data, ctx);

    // pic_order_cnt_type - ue(v)
    sps.pic_order_cnt_type = mpegts.h264.read_ue(data, ctx);

    if (sps.pic_order_cnt_type === 0) {
        // log2_max_pic_order_cnt_lsb_minus4 - ue(v)
        sps.log2_max_pic_order_cnt_lsb_minus4 = mpegts.h264.read_ue(data, ctx);
    } else if (sps.pic_order_cnt_type === 1) {
        // NOT IMPLEMENTED
        //console.log("H.264 SPS parsing: (log2_max_pic_order_cnt_lsb_minus4 = 1) not implemented");
    }

    // num_ref_frames - ue(v)
    sps.num_ref_frames = mpegts.h264.read_ue(data, ctx);

    // gaps_in_frame_num_value_allowed_flag - u(1)
    sps.gaps_in_frame_num_value_allowed_flag = mpegts.h264.read_flag(data, ctx);

    // pic_width_in_mbs_minus1 - ue(v)
    sps.pic_width_in_mbs_minus1 = mpegts.h264.read_ue(data, ctx);

    // pic_height_in_map_units_minus1 - ue(v)
    sps.pic_height_in_map_units_minus1 = mpegts.h264.read_ue(data, ctx);

    return sps;
};

mpegts.h264.parseNALUs = function(data) { // data as Uint8Array

    var i = 0,
        length = data.length,
        numZeroBytes = 0,
        nalus = [],
        nalu;

    // console.log("[H264] PARSE NALUs ------------------------------------------");
    while (i < length) {
        if (data[i] === 0) {
            numZeroBytes++;
        }
        if ((data[i] === 1) && (numZeroBytes >= 2)) {
            i++;
            // Update previous NALU size
            if (nalus.length > 0) {
                nalus[nalus.length - 1].size = i - (numZeroBytes + 1) - nalus[nalus.length - 1].offset;
            }

            nalu = {};
            nalu.type = data[i] & 0x1F;
            nalu.offset = i;
            nalus.push(nalu);

            // console.log("[H264] NALU: SC = " + (numZeroBytes + 1) + ", type = " + nalu.type);
            numZeroBytes = 0;
        }
        if (data[i]) {
            numZeroBytes = 0;
        }
        i++;
    }

    // Update last NALU size
    if (nalus.length > 0) {
        nalus[nalus.length - 1].size = i - nalus[nalus.length - 1].offset;
    }

    return nalus;
};


mpegts.h264.bytestreamToMp4 = function(data) { // data as Uint8Array

    var i = 0,
        length = data.length,
        startCodeIndex = -1,
        naluSize = 0;

    while (i < length) {
        if ((data[i] === 0x00) && (data[i + 1] === 0x00) && (data[i + 2] === 0x00) && (data[i + 3] === 0x01)) {

            if (startCodeIndex >= 0) {
                naluSize = (i - startCodeIndex - 4); // 4 = start code length or NALU-size field length
                data[startCodeIndex] = (naluSize & 0xFF000000) >> 24;
                data[startCodeIndex + 1] = (naluSize & 0x00FF0000) >> 16;
                data[startCodeIndex + 2] = (naluSize & 0x0000FF00) >> 8;
                data[startCodeIndex + 3] = (naluSize & 0x000000FF);
                // console.log("[H264] NALU: type = " + (data[i + 4] & 0x1F) + ", size = " + naluSize);
            }

            startCodeIndex = i;
            i += 4;
        } else {
            i++;
        }
    }

    // Last NAL unit
    naluSize = (i - startCodeIndex - 4); // 4 = start code length or NALU-size field length
    data[startCodeIndex] = (naluSize & 0xFF000000) >> 24;
    data[startCodeIndex + 1] = (naluSize & 0x00FF0000) >> 16;
    data[startCodeIndex + 2] = (naluSize & 0x0000FF00) >> 8;
    data[startCodeIndex + 3] = (naluSize & 0x000000FF);
    // console.log("[H264] NALU: type = " + (data[i + 4] & 0x1F) + ", size = " + naluSize);

};

mpegts.h264.isIDR = function(data) { // data as Uint8Array
    var i = 0,
        naluType;

    while (i < data.length) {
        if ((data[i] === 0x00) && (data[i + 1] === 0x00) && (data[i + 2] === 0x01)) {
            naluType = data[i + 3] & 0x1F;
            if (naluType === mpegts.h264.NALUTYPE_IDR) {
                return true;
            }
            i += 3;
        } else {
            i++;
        }
    }
    return false;
};

mpegts.h264.NALUTYPE_NONIDR = 1;
mpegts.h264.NALUTYPE_IDR = 5;
mpegts.h264.NALUTYPE_SEI = 6;
mpegts.h264.NALUTYPE_SPS = 7;
mpegts.h264.NALUTYPE_PPS = 8;
mpegts.h264.NALUTYPE_AU_DELIMITER = 9;
/*
 * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.
 * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2014, Orange
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
mpegts.si.PAT = function() {
    mpegts.si.PSISection.call(this, mpegts.si.PAT.prototype.TABLE_ID);
    this.m_listOfProgramAssociation = [];
    this.m_network_pid = null;
};

mpegts.si.PAT.prototype = Object.create(mpegts.si.PSISection.prototype);
mpegts.si.PAT.prototype.constructor = mpegts.si.PAT;

mpegts.si.PAT.prototype.parse = function(data) {
    var id = mpegts.si.PSISection.prototype.parse.call(this, data);
    id++;

    if (!this.m_bValid) {
        //console.log("PSI Parsing Problem during PAT parsing!");
        return;
    }
    this.m_bValid = false;

    if (this.m_table_id !== this.TABLE_ID) {
        return;
    }

    var remainingBytes = this.getSectionLength() - this.SECTION_LENGTH;

    while (remainingBytes >= 4) {
        var prog = new mpegts.si.ProgramAssociation(data.subarray(id, id + 4));

        if (prog.getProgramNumber() === 0) {
            // Network PID
            this.m_network_pid = prog.getProgramMapPid();
        } else {
            this.m_listOfProgramAssociation.push(prog);
        }
        remainingBytes -= 4;
        id += 4;
    }

    this.m_bValid = true;
};

/**
 * returns the PID of the PMT associated to the first program
 *
 * @return the PID of the PMT associated to the first program
 */
mpegts.si.PAT.prototype.getPmtPid = function() {
    var pid = mpegts.ts.TsPacket.prototype.UNDEFINED_PID;

    if (this.m_listOfProgramAssociation.length >= 1) {
        var prog = this.m_listOfProgramAssociation[0];
        pid = prog.getProgramMapPid();
    }

    return pid;
};

mpegts.si.PAT.prototype.TABLE_ID = 0x00;
mpegts.si.PAT.prototype.PID = 0x00;


mpegts.si.ProgramAssociation = function(data) {
    this.m_program_number = 0;
    this.m_program_map_pid = 0;
    this.parse(data);
};

mpegts.si.ProgramAssociation.prototype.getProgramNumber = function() {
    return this.m_program_number;
};

mpegts.si.ProgramAssociation.prototype.getProgramMapPid = function() {
    return this.m_program_map_pid;
};

mpegts.si.ProgramAssociation.prototype.getLength = function() {
    return 4;
};

/**
 * Parse the ProgramAssociation from given stream
 */
mpegts.si.ProgramAssociation.prototype.parse = function(data) {
    this.m_program_number = mpegts.binary.getValueFrom2Bytes(data.subarray(0, 2));
    this.m_program_map_pid = mpegts.binary.getValueFrom2Bytes(data.subarray(2, 4), 3, 13);
};
/*
 * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.
 * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2014, Orange
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
mpegts.pes.PesPacket = function() {
    this.m_cStreamID = null;
    this.m_nPESPacketLength = null;
    this.m_cPESScramblingCtrl = null;
    this.m_bPESpriority = null;
    this.m_bDataAlignement = null;
    this.m_bCopyright = null;
    this.m_bOriginalOrCopy = null;
    this.m_cPES_header_data_length = null;
    this.m_cPTS_DTS_flags = null;
    this.m_bESCR_flag = null;
    this.m_bES_rate_flag = null;
    this.m_bDSM_trick_mode_flag = null;
    this.m_bAdditional_copy_info_flag = null;
    this.m_bPES_CRC_flag = null;
    this.m_bPES_extension_flag = null;
    this.m_pPTS = null;
    this.m_pDTS = null;
    this.m_pESCR = null;
    this.m_ES_rate = null;
    this.m_DSM_trick_mode = null;
    this.m_Additional_copy_info = null;
    this.m_PES_CRC = null;
    this.m_cNbStuffingBytes = null;
    this.m_pPESExtension = null;
    this.m_pPrivateData = null;
    this.m_payloadArray = null;
    this.m_nPayloadLength = null;
    this.m_bDirty = null;
    this.m_bValid = false;
};

mpegts.pes.PesPacket.prototype.parse = function(data) {
    var index = 0;
    this.m_nLength = data.length;
    // packet_start_code_prefix
    var nStartCode = mpegts.binary.getValueFrom3Bytes(data.subarray(index, index + 3));
    if (nStartCode !== this.START_CODE_PREFIX) {
        //console.log("PES Packet start code not define!");
        return;
    }

    index = 3; // 3 = packet_start_code_prefix length

    // stream_id
    this.m_cStreamID = data[index];
    index++;

    // PES_packet_length
    this.m_nPESPacketLength = mpegts.binary.getValueFrom2Bytes(data.subarray(index, index + 2));
    index += 2;

    // Padding bytes
    if (this.m_cStreamID === mpegts.ts.TsPacket.prototype.STREAM_ID_PADDING_STREAM) {
        // Padding bytes => no more field, no payload
        this.m_bValid = true;
        return;
    }

    // PES_packet_data_byte (no optional header)
    if (!this.hasOptionalPESHeader()) {
        //NAN => to Validate!!!!
        // no more header field, only payload
        this.m_payloadArray = data.subarray(index + mpegts.pes.PesPacket.prototype.FIXED_HEADER_LENGTH);
        this.m_nPayloadLength = this.m_nLength - mpegts.pes.PesPacket.prototype.FIXED_HEADER_LENGTH;
        this.m_bValid = true;
        return;
    }

    // Optional PES header
    var reserved = mpegts.binary.getValueFromByte(data[index], 0, 2);
    if (reserved !== 0x02) {
        return;
    }
    this.m_cPESScramblingCtrl = mpegts.binary.getValueFromByte(data[index], 2, 2);
    this.m_bPESpriority = mpegts.binary.getBitFromByte(data[index], 4);
    this.m_bDataAlignement = mpegts.binary.getBitFromByte(data[index], 5);
    this.m_bCopyright = mpegts.binary.getBitFromByte(data[index], 6);
    this.m_bOriginalOrCopy = mpegts.binary.getBitFromByte(data[index], 7);
    index++;

    // 7 flags
    this.m_cPTS_DTS_flags = mpegts.binary.getValueFromByte(data[index], 0, 2);
    this.m_bESCR_flag = mpegts.binary.getBitFromByte(data[index], 2);
    this.m_bES_rate_flag = mpegts.binary.getBitFromByte(data[index], 3);
    this.m_bDSM_trick_mode_flag = mpegts.binary.getBitFromByte(data[index], 4);
    this.m_bAdditional_copy_info_flag = mpegts.binary.getBitFromByte(data[index], 5);
    this.m_bPES_CRC_flag = mpegts.binary.getBitFromByte(data[index], 6);
    this.m_bPES_extension_flag = mpegts.binary.getBitFromByte(data[index], 7);
    index++;

    // PES_header_data_length
    this.m_cPES_header_data_length = (data[index] & 0xFF);
    index++;

    // PTS
    if ((this.m_cPTS_DTS_flags & mpegts.pes.PesPacket.prototype.FLAG_PTS) == mpegts.pes.PesPacket.prototype.FLAG_PTS) {
        this.m_pPTS = new mpegts.Pts(data.subarray(index, index + 5));
        index += 5;
    }

    // DTS
    if ((this.m_cPTS_DTS_flags & mpegts.pes.PesPacket.prototype.FLAG_DTS) == mpegts.pes.PesPacket.prototype.FLAG_DTS) {
        this.m_pDTS = new mpegts.Pts(data.subarray(index, index + 5));
        index += 5;
    }

    // ESCR
    if (this.m_bESCR_flag) {
        //NAN => to Complete
        //this.m_pESCR = new PCR(m_pBytestream + index);
        index += 6;
    }

    // ES_rate	
    if (this.m_bES_rate_flag) {
        this.m_ES_rate = mpegts.binary.getValueFrom3Bytes(data.subarray(index, index + 3), 1, 22);
        index += 3;
    }

    // DSM_trick_mode
    if (this.m_bDSM_trick_mode_flag) {
        this.m_DSM_trick_mode = data[index];
        index++;
    }

    // Additional_copy_info
    if (this.m_bAdditional_copy_info_flag) {
        this.m_Additional_copy_info = data[index];
        index++;
    }

    // PES_CRC
    if (this.m_bPES_CRC_flag) {
        this.m_PES_CRC = mpegts.binary.getValueFrom2Bytes(data.subarray(index, index + 2));
        index += 2;
    }

    // PES_extension
    if (this.m_bPES_extension_flag) {
        //NAN => to Complete
        //this.m_pPESExtension = new PESExtension(m_pBytestream + index, m_cPES_header_data_length);
        //index += m_pPESExtension->getLength();
    }

    // Stuffing bytes
    var uiHeaderLength = mpegts.pes.PesPacket.prototype.FIXED_HEADER_LENGTH + mpegts.pes.PesPacket.prototype.FIXED_OPTIONAL_HEADER_LENGTH + this.m_cPES_header_data_length;
    this.m_cNbStuffingBytes = uiHeaderLength - index;
    index += this.m_cNbStuffingBytes;

    // Payload
    this.m_nPayloadLength = this.m_nLength - uiHeaderLength;
    this.m_payloadArray = data.subarray(uiHeaderLength, uiHeaderLength + this.m_nPayloadLength);

    this.m_bValid = true;
};


/**
 * Returns true if header contains optional PES header.
 * @return true if header contains optional PES header
 */
mpegts.pes.PesPacket.prototype.hasOptionalPESHeader = function() {

    if ((this.m_cStreamID === mpegts.ts.TsPacket.prototype.STREAM_ID_PROGRAM_STREAM_MAP) ||
        (this.m_cStreamID === mpegts.ts.TsPacket.prototype.STREAM_ID_PADDING_STREAM) ||
        (this.m_cStreamID === mpegts.ts.TsPacket.prototype.STREAM_ID_PRIVATE_STREAM_2) ||
        (this.m_cStreamID === mpegts.ts.TsPacket.prototype.STREAM_ID_ECM_STREAM) ||
        (this.m_cStreamID === mpegts.ts.TsPacket.prototype.STREAM_ID_EMM_STREAM) ||
        (this.m_cStreamID === mpegts.ts.TsPacket.prototype.STREAM_ID_PROGRAM_STREAM_DIRECTORY) ||
        (this.m_cStreamID === mpegts.ts.TsPacket.prototype.STREAM_ID_DSMCC_STREAM) ||
        (this.m_cStreamID === mpegts.ts.TsPacket.prototype.STREAM_ID_H2221_TYPE_E_STREAM)) {
        return false;
    }

    return true;
};

mpegts.pes.PesPacket.prototype.getHeaderLength = function() {
    return mpegts.pes.PesPacket.prototype.FIXED_HEADER_LENGTH +
        mpegts.pes.PesPacket.prototype.FIXED_OPTIONAL_HEADER_LENGTH +
        this.m_cPES_header_data_length;
};

mpegts.pes.PesPacket.prototype.getPayload = function() {
    return this.m_payloadArray;
};

mpegts.pes.PesPacket.prototype.getPts = function() {
    return this.m_pPTS;
};

mpegts.pes.PesPacket.prototype.getDts = function() {
    return this.m_pDTS;
};

/** The start code prefix */
mpegts.pes.PesPacket.prototype.START_CODE_PREFIX = 0x000001;
/** The first fixed header fields length (start_code + stream_id + PES_packet_length fields) **/
mpegts.pes.PesPacket.prototype.FIXED_HEADER_LENGTH = 6;
/** The first optional fixed header fields length **/
mpegts.pes.PesPacket.prototype.FIXED_OPTIONAL_HEADER_LENGTH = 3;
/** PTS_DTS_flags possible values */
mpegts.pes.PesPacket.prototype.FLAG_DTS = 0x01;
mpegts.pes.PesPacket.prototype.FLAG_PTS = 0x02;
/*
 * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.
 * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2014, Orange
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
mpegts.si.PMT = function() {
    mpegts.si.PSISection.call(this, mpegts.si.PMT.prototype.TABLE_ID);
    this.m_listOfComponents = [];
    this.m_PCR_PID = null;
    this.m_program_info_length = null;
};

mpegts.si.PMT.prototype = Object.create(mpegts.si.PSISection.prototype);
mpegts.si.PMT.prototype.constructor = mpegts.si.PMT;

mpegts.si.PMT.prototype.parse = function(data) {
    var id = mpegts.si.PSISection.prototype.parse.call(this, data);
    id++;

    if (!this.m_bValid) {
        //console.log("PSI Parsing Problem during PMT parsing!");
        return;
    }
    this.m_bValid = false;

    // Check table_id field value
    if (this.m_table_id !== this.TABLE_ID) {
        return;
    }

    var remainingBytes = this.getSectionLength() - this.SECTION_LENGTH;

    // check if we have almost PCR_PID and program_info_length fields
    if (remainingBytes < 4) {
        return;
    }

    this.m_PCR_PID = mpegts.binary.getValueFrom2Bytes(data.subarray(id, id + 2), 3);
    id += 2;
    this.m_program_info_length = mpegts.binary.getValueFrom2Bytes(data.subarray(id, id + 2), 4);
    id += 2;

    // Parse program descriptors
    id += this.m_program_info_length;

    // Parse ES descriptions
    remainingBytes = (this.m_section_length - this.SECTION_LENGTH - 4 - this.m_program_info_length);
    var pESDescription = null;
    while (remainingBytes > 0) {
        pESDescription = new mpegts.si.ESDescription(data.subarray(id, id + remainingBytes));
        this.m_listOfComponents.push(pESDescription);
        remainingBytes -= pESDescription.getLength();
        id += pESDescription.getLength();
    }

    this.m_bValid = true;
};

mpegts.si.PMT.prototype.TABLE_ID = 0x02;

mpegts.si.PMT.prototype.gStreamTypes = [
    /*  0 - 0x00 */
    {
        name: "Reserved",
        value: 0x00,
        desc: "ITU-T | ISO/IEC Reserved"
    },
    /*  1 - 0x01 */
    {
        name: "MPEG1-Video",
        value: 0xE0,
        desc: "ISO/IEC 11172-2 Video"
    },
    /*  2 - 0x02 */
    {
        name: "MPEG2-Video",
        value: 0xE0,
        desc: "ITU-T Rec. H.262 | ISO/IEC 13818-2 Video or ISO/IEC 11172-2 constrained parameter video stream"
    },
    /*  3 - 0x03 */
    {
        name: "MPEG1-Audio",
        value: 0xC0,
        desc: "ISO/IEC 11172-3 Audio"
    },
    /*  4 - 0x04 */
    {
        name: "MPEG2-Audio",
        value: 0xC0,
        desc: "ISO/IEC 13818-3 Audio"
    },
    /*  5 - 0x05 */
    {
        name: "PRIVATE_SECTIONS",
        value: 0xBD,
        desc: "ITU-T Rec. H.222.0 | ISO/IEC 13818-1 private_sections"
    },
    /*  6 - 0x06 */
    {
        name: "PRIVATE",
        value: 0xBD,
        desc: "ITU-T Rec. H.222.0 | ISO/IEC 13818-1 PES packets containing private data"
    },
    /*  7 - 0x07 */
    {
        name: "MHEG",
        value: 0xF3,
        desc: "ISO/IEC 13522 MHEG"
    },
    /*  8 - 0x08 */
    {
        name: "MPEG1-DSM-CC",
        value: 0xF2,
        desc: "ITU-T Rec. H.222.0 | ISO/IEC 13818-1 Annex A DSM-CC"
    },
    /*  9 - 0x09 */
    {
        name: "H.222.1",
        value: 0xF4,
        desc: "ITU-T Rec. H.222.1"
    },
    /* 10 - 0x0A */
    {
        name: "DSM-CC_A",
        value: 0xF4,
        desc: "ISO/IEC 13818-6 type A"
    },
    /* 11 - 0x0B */
    {
        name: "DSM-CC_B",
        value: 0xF5,
        desc: "ISO/IEC 13818-6 type B"
    },
    /* 12 - 0x0C */
    {
        name: "DSM-CC_C",
        value: 0xF6,
        desc: "ISO/IEC 13818-6 type C"
    },
    /* 13 - 0x0D */
    {
        name: "DSM-CC_D",
        value: 0xF7,
        desc: "ISO/IEC 13818-6 type D"
    },
    /* 14 - 0x0E */
    {
        name: "Auxiliary",
        value: 0x00,
        desc: "ITU-T Rec. H.222.0 | ISO/IEC 13818-1 auxiliary"
    },
    /* 15 - 0x0F */
    {
        name: "MPEG2-AAC-ADTS",
        value: 0xC0,
        desc: "ISO/IEC 13818-7 Audio with ADTS transport syntax"
    },
    /* 16 - 0x10 */
    {
        name: "MPEG4-Video",
        value: 0xE0,
        desc: "ISO/IEC 14496-2 Visual"
    },
    /* 17 - 0x11 */
    {
        name: "MPEG4-AAC-LATM",
        value: 0xC0,
        desc: "ISO/IEC 14496-3 Audio with the LATM transport syntax as defined in ISO/IEC 14496-3/AMD-1"
    },
    /* 18 - 0x12 */
    {
        name: "MPEG4-SL",
        value: 0xFA,
        desc: "ISO/IEC 14496-1 SL-packetized stream or FlexMux stream carried in PES packets"
    },
    /* 19 - 0x13 */
    {
        name: "MPEG4-SL",
        value: 0xFA,
        desc: "ISO/IEC 14496-1 SL-packetized stream or FlexMux stream carried in ISO/IEC14496_sections"
    },
    /* 20 - 0x14 */
    {
        name: "DSM-CC_SDP",
        value: 0x00,
        desc: "ISO/IEC 13818-6 Synchronized Download Protocol"
    },
    /* 21 - 0x15 */
    {
        name: "META_PES",
        value: 0xFC,
        desc: "Metadata carried in PES packets"
    },
    /* 22 - 0x16 */
    {
        name: "META_SECTIONS",
        value: 0xFC,
        desc: "Metadata carried in metadata_sections"
    },
    /* 23 - 0x17 */
    {
        name: "META_DSM-CC",
        value: 0xFC,
        desc: "Metadata carried in ISO/IEC 13818-6 Data Carousel"
    },
    /* 24 - 0x18 */
    {
        name: "META_DSM-CC",
        value: 0xFC,
        desc: "Metadata carried in ISO/IEC 13818-6 Object Carousel"
    },
    /* 25 - 0x19 */
    {
        name: "META_DSM-CC",
        value: 0xFC,
        desc: "Metadata carried in ISO/IEC 13818-6 Synchronized Download Protocol"
    },
    /* 26 - 0x1A */
    {
        name: "MPEG2-IPMP",
        value: 0x00,
        desc: "IPMP stream (defined in ISO/IEC 13818-11, MPEG-2 IPMP)"
    },
    /* 27 - 0x1B */
    {
        name: "H.264",
        value: 0xE0,
        desc: "AVC video stream as defined in ITU-T Rec. H.264 | ISO/IEC 14496-10 Video"
    },
    /* 28 - 0x1C */
    {
        name: "MPEG4AAC",
        value: 0xC0,
        desc: "ISO/IEC 14496-3 Audio, without using any additional transport syntax, such as DST, ALS and SLS"
    },
    /* 29 - 0x1D */
    {
        name: "MPEG4Text",
        value: 0x00,
        desc: "ISO/IEC 14496-17 Text"
    },
    /* 30 - 0x1E */
    {
        name: "Aux. Video (23002-3)",
        value: 0x1E,
        desc: "Auxiliary video stream as defined in ISO/IEC 23002-3"
    },
    /* 31 - 0x1F */
    {
        name: "H.264-SVC",
        value: 0xE0,
        desc: "SVC video sub-bitstream of a video stream as defined in the Annex G of ITU-T Rec. H.264 | ISO/IEC 14496-10 Video"
    },
    /* 32 - 0x20 */
    {
        name: "H.264-MVC",
        value: 0xE0,
        desc: "MVC video sub-bitstream of a video stream as defined in the Annex H of ITU-T Rec. H.264 | ISO/IEC 14496-10 Video"
    },
    /* 33 - 0x21 */
    {
        name: "Reserved1",
        value: 0x00,
        desc: "TBC Reserved"
    },
    /* 34 - 0x22 */
    {
        name: "Reserved2",
        value: 0x00,
        desc: "TBC Reserved"
    },
    /* 35 - 0x23 */
    {
        name: "Reserved3",
        value: 0x00,
        desc: "TBC Reserved"
    },
    /* 36 - 0x24 */
    {
        name: "HEVC",
        value: 0xE0,
        desc: "ITU.-T Rec H.26x | ISO/IEC 23008-2 video stream"
    }
];

mpegts.si.PMT.prototype.MPEG2_VIDEO_STREAM_TYPE = 0x02;
mpegts.si.PMT.prototype.AVC_VIDEO_STREAM_TYPE = 0x1B;
mpegts.si.PMT.prototype.MPEG1_AUDIO_STREAM_TYPE = 0x03;
mpegts.si.PMT.prototype.MPEG2_AUDIO_STREAM_TYPE = 0x04;
mpegts.si.PMT.prototype.AAC_AUDIO_STREAM_TYPE = 0x11;
mpegts.si.PMT.prototype.AC3_AUDIO_STREAM_TYPE = 0x06;
mpegts.si.PMT.prototype.SUB_STREAM_TYPE = 0x06;

mpegts.si.PMT.prototype.STREAM_TYPE_MP1V = 0x01;
mpegts.si.PMT.prototype.STREAM_TYPE_MP2V = 0x02;
mpegts.si.PMT.prototype.STREAM_TYPE_MP1A = 0x03;
mpegts.si.PMT.prototype.STREAM_TYPE_MP2A = 0x04;
mpegts.si.PMT.prototype.STREAM_TYPE_PRIVATE = 0x06;
mpegts.si.PMT.prototype.STREAM_TYPE_TELETEXT = 0x06;
mpegts.si.PMT.prototype.STREAM_TYPE_DVBSUBTITLE = 0x06;
mpegts.si.PMT.prototype.STREAM_TYPE_AC3 = 0x06;
mpegts.si.PMT.prototype.STREAM_TYPE_MP2AAC_ADTS = 0x0F;
mpegts.si.PMT.prototype.STREAM_TYPE_MP4AAC_LATM = 0x11;
mpegts.si.PMT.prototype.STREAM_TYPE_H264 = 0x1B;
mpegts.si.PMT.prototype.STREAM_TYPE_MP4AAC = 0x1C;
mpegts.si.PMT.prototype.STREAM_TYPE_AUX_23002_3 = 0x1E;
mpegts.si.PMT.prototype.STREAM_TYPE_SVC = 0x1F;
mpegts.si.PMT.prototype.STREAM_TYPE_MVC = 0x20;
mpegts.si.PMT.prototype.STREAM_TYPE_HEVC = 0x24;


mpegts.si.ESDescription = function(data) {
    /** ES description fields */
    this.m_stream_type = null;
    this.m_elementary_PID = null;
    this.m_ES_info_length = null;
    this.parse(data);
};

/**
 * Gets the stream type associated to this ES
 * @return the stream type associated to this ES
 */
mpegts.si.ESDescription.prototype.getStreamType = function() {
    return this.m_stream_type;
};

/**
 * Gets the pid on which this ES may be found
 * @return the pid on which this ES may be found
 */
mpegts.si.ESDescription.prototype.getPID = function() {
    return this.m_elementary_PID;
};

/**
 * Returns the elementary stream description length
 * @return the elementary stream description length
 */
mpegts.si.ESDescription.prototype.getLength = function() {
    return 5 + this.m_ES_info_length;
};

/**
 * Parse the ESDescription from given bytestream
 * @param the bytestream to parse
 * @return the bytestream length
 */
mpegts.si.ESDescription.prototype.parse = function(data) {
    this.m_stream_type = data[0];
    this.m_elementary_PID = mpegts.binary.getValueFrom2Bytes(data.subarray(1, 3), 3);
    this.m_ES_info_length = mpegts.binary.getValueFrom2Bytes(data.subarray(3, 5), 4);
};
/*
 * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.
 * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2014, Orange
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

mpegts.Pts = function(data) {

    var low,
        high;

    //initialize an unsigned 64 bits long number
    //this.m_lPTS = goog.math.Long.fromNumber(0);

    //=> PTS is defined on 33 bits
    //=> In the first byte, bit number 2 to 4 is useful
    var bits3230 = data[0] >> 1 & 0x7;

    //thirty-third bit in the high member
    high = bits3230 >> 2;
    //32 and 31 bits in th low member, shift by 30 bits
    low = ((bits3230 & 0x3) << 30) >>> 0; //=> http://www.codeonastick.com/2013/06/javascript-convert-signed-integer-to.html unsigned int!!!!!!

    //=> In the second byte, all the bits are useful
    var bits2922 = data[1];
    low = (low | (bits2922 << 22)) >>> 0; //=> http://www.codeonastick.com/2013/06/javascript-convert-signed-integer-to.html unsigned int!!!!!!

    //=> In the third byte, bit number 2 to 8 is useful
    var bits2115 = data[2] >> 1;
    low = (low | (bits2115 << 15)) >>> 0; //=> http://www.codeonastick.com/2013/06/javascript-convert-signed-integer-to.html unsigned int!!!!!!

    //=> In the fourth byte, all the bits are useful
    var bits1407 = data[3];
    low = (low | (bits1407 << 7)) >>> 0; //=> http://www.codeonastick.com/2013/06/javascript-convert-signed-integer-to.html unsigned int!!!!!!

    //=> In the fifth byte, bit number 2 to 8 is useful
    var bits0701 = data[4] >> 1;
    low = (low | bits0701) >>> 0; //=> http://www.codeonastick.com/2013/06/javascript-convert-signed-integer-to.html unsigned int!!!!!!

    this.m_lPTS = goog.math.Long.fromBits(low, high).toNumber();
    this.m_fPTS = this.m_lPTS / mpegts.Pts.prototype.SYSTEM_CLOCK_FREQUENCY;
};

/**
 * Returns the PTS value in units of system clock frequency.
 * @return the PTS value in units of system clock frequency
 */
mpegts.Pts.prototype.getValue = function() {
    return this.m_lPTS;
};

/**
 * Returns the PTS value in seconds.
 * @return the PTS value in seconds
 */
mpegts.Pts.prototype.getValueInSeconds = function() {
    return this.m_fPTS;
};

mpegts.Pts.prototype.SYSTEM_CLOCK_FREQUENCY = 90000;
/*
 * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.
 * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2014, Orange
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * •  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * •  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * •  Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
mpegts.ts.TsPacket = function() {
    this.m_cSync = null;
    this.m_bTransportError = null;
    this.m_bPUSI = null;
    this.m_bTransportPriority = null;
    this.m_nPID = null;
    this.m_cTransportScramblingCtrl = null;
    this.m_cAdaptationFieldCtrl = null;
    this.m_cContinuityCounter = null;
    this.m_pAdaptationField = null;
    this.m_payloadArray = null;
    this.m_cPayloadLength = null;
    this.m_bDirty = null;
    this.m_time = null;
    this.m_arrivalTime = null;
    this.m_bIgnored = null;
};

mpegts.ts.TsPacket.prototype.parse = function(data) {
    var byteId = 0;
    this.m_cSync = data[byteId];
    if (this.m_cSync !== this.SYNC_WORD) {
        //console.log("TS Packet Malformed!");
        return;
    }

    byteId++;

    this.m_bTransportError = mpegts.binary.getBitFromByte(data[byteId], 0);
    this.m_bPUSI = mpegts.binary.getBitFromByte(data[byteId], 1);
    this.m_bTransportPriority = mpegts.binary.getBitFromByte(data[byteId], 2);
    this.m_nPID = mpegts.binary.getValueFrom2Bytes(data.subarray(byteId, byteId + 2), 3, 13);

    byteId += 2;

    this.m_cTransportScramblingCtrl = mpegts.binary.getValueFromByte(data[byteId], 0, 2);
    this.m_cAdaptationFieldCtrl = mpegts.binary.getValueFromByte(data[byteId], 2, 2);
    this.m_cContinuityCounter = mpegts.binary.getValueFromByte(data[byteId], 4, 4);

    byteId++;

    // Adaptation field
    // NAN => to Validate
    if (this.m_cAdaptationFieldCtrl & 0x02) {
        // Check adaptation field length before parsing
        var cAFLength = data[byteId];
        if ((cAFLength + byteId) >= this.TS_PACKET_SIZE) {
            //console.log("TS Packet Size Problem!");
            return;
        }
        this.m_pAdaptationField = new mpegts.ts.AdaptationField();
        this.m_pAdaptationField.parse(data.subarray(byteId));
        byteId += this.m_pAdaptationField.getLength();
    }

    // Check packet validity
    if (this.m_cAdaptationFieldCtrl === 0x00) {
        //console.log("TS Packet is invalid!");
        return;
    }

    // Payload
    if (this.m_cAdaptationFieldCtrl & 0x01) {
        this.m_cPayloadLength = this.TS_PACKET_SIZE - byteId;
        this.m_payloadArray = data.subarray(byteId, byteId + this.m_cPayloadLength);
    }
};

mpegts.ts.TsPacket.prototype.checkSyncWord = function(data) {
    var byteId = 0;
    var sync = data[byteId];

    return (sync === this.SYNC_WORD);
};

mpegts.ts.TsPacket.prototype.getPid = function() {
    return this.m_nPID;
};

mpegts.ts.TsPacket.prototype.getPayload = function() {
    return this.m_payloadArray;
};

mpegts.ts.TsPacket.prototype.getPayloadLength = function() {
    return this.m_cPayloadLength;
};

mpegts.ts.TsPacket.prototype.getPusi = function() {
    return this.m_bPUSI;
};

mpegts.ts.TsPacket.prototype.hasAdaptationFieldOnly = function() {
    return (this.m_cAdaptationFieldCtrl === 0x02);
};

mpegts.ts.TsPacket.prototype.SYNC_WORD = 0x47;
mpegts.ts.TsPacket.prototype.TS_PACKET_SIZE = 188;
mpegts.ts.TsPacket.prototype.UNDEFINED_PID = 0xFFFF;
mpegts.ts.TsPacket.prototype.PAT_PID = 0;
mpegts.ts.TsPacket.prototype.STREAM_ID_PROGRAM_STREAM_MAP = 0xBC;
mpegts.ts.TsPacket.prototype.STREAM_ID_PADDING_STREAM = 0xBE;
mpegts.ts.TsPacket.prototype.STREAM_ID_PADDING_STREAM = 0xBE;
mpegts.ts.TsPacket.prototype.STREAM_ID_PRIVATE_STREAM_2 = 0xBF;
mpegts.ts.TsPacket.prototype.STREAM_ID_ECM_STREAM = 0xF0;
mpegts.ts.TsPacket.prototype.STREAM_ID_EMM_STREAM = 0xF1;
mpegts.ts.TsPacket.prototype.STREAM_ID_DSMCC_STREAM = 0xF2;
mpegts.ts.TsPacket.prototype.STREAM_ID_H2221_TYPE_E_STREAM = 0xF8;
mpegts.ts.TsPacket.prototype.STREAM_ID_PROGRAM_STREAM_DIRECTORY = 0xFF;

/*   Copyright (C) 2011,2012,2013,2014 John Kula */

/*
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

    All trademarks and service marks contained within this document are
    property of their respective owners.

    Version 2014.07.23

    Updates may be found at: http:\\www.darkwavetech.com

*/

/*jslint browser:true */

/* This function returns the browser and version number by using the navigator.useragent object */

function fingerprint_browser() {
    "use strict";
    var userAgent,
        name,
        version;

    try {

        userAgent = navigator.userAgent.toLowerCase();

        if (/msie (\d+\.\d+);/.test(userAgent)) { //test for MSIE x.x;
            version = Number(RegExp.$1); // capture x.x portion and store as a number
            if (userAgent.indexOf("trident/6") > -1) {
                version = 10;
            }
            if (userAgent.indexOf("trident/5") > -1) {
                version = 9;
            }
            if (userAgent.indexOf("trident/4") > -1) {
                version = 8;
            }
            name = "Internet Explorer";
        } else if (userAgent.indexOf("trident/7") > -1) { //IE 11+ gets rid of the legacy 'MSIE' in the user-agent string;
            version = 11;
            name = "Internet Explorer";
        }  else if (/edge[\/\s](\d+\.\d+)/.test(userAgent)) { //test for Firefox/x.x or Firefox x.x (ignoring remaining digits);
            version = Number(RegExp.$1); // capture x.x portion and store as a number
            name = "Edge";
        }  else if (/firefox[\/\s](\d+\.\d+)/.test(userAgent)) { //test for Firefox/x.x or Firefox x.x (ignoring remaining digits);
            version = Number(RegExp.$1); // capture x.x portion and store as a number
            name = "Firefox";
        } else if (/opera[\/\s](\d+\.\d+)/.test(userAgent)) { //test for Opera/x.x or Opera x.x (ignoring remaining decimal places);
            version = Number(RegExp.$1); // capture x.x portion and store as a number
            name = "Opera";
        } else if (/chrome[\/\s](\d+\.\d+)/.test(userAgent)) { //test for Chrome/x.x or Chrome x.x (ignoring remaining digits);
            version = Number(RegExp.$1); // capture x.x portion and store as a number
            name = "Chrome";
        } else if (/version[\/\s](\d+\.\d+)/.test(userAgent)) { //test for Version/x.x or Version x.x (ignoring remaining digits);
            version = Number(RegExp.$1); // capture x.x portion and store as a number
            name = "Safari";
        } else if (/rv[\/\s](\d+\.\d+)/.test(userAgent)) { //test for rv/x.x or rv x.x (ignoring remaining digits);
            version = Number(RegExp.$1); // capture x.x portion and store as a number
            name = "Mozilla";
        } else if (/mozilla[\/\s](\d+\.\d+)/.test(userAgent)) { //test for Mozilla/x.x or Mozilla x.x (ignoring remaining digits);
            version = Number(RegExp.$1); // capture x.x portion and store as a number
            name = "Mozilla";
        } else if (/binget[\/\s](\d+\.\d+)/.test(userAgent)) { //test for BinGet/x.x or BinGet x.x (ignoring remaining digits);
            version = Number(RegExp.$1); // capture x.x portion and store as a number
            name = "Library (BinGet)";
        } else if (/curl[\/\s](\d+\.\d+)/.test(userAgent)) { //test for Curl/x.x or Curl x.x (ignoring remaining digits);
            version = Number(RegExp.$1); // capture x.x portion and store as a number
            name = "Library (cURL)";
        } else if (/java[\/\s](\d+\.\d+)/.test(userAgent)) { //test for Java/x.x or Java x.x (ignoring remaining digits);
            version = Number(RegExp.$1); // capture x.x portion and store as a number
            name = "Library (Java)";
        } else if (/libwww-perl[\/\s](\d+\.\d+)/.test(userAgent)) { //test for libwww-perl/x.x or libwww-perl x.x (ignoring remaining digits);
            version = Number(RegExp.$1); // capture x.x portion and store as a number
            name = "Library (libwww-perl)";
        } else if (/microsoft url control -[\s](\d+\.\d+)/.test(userAgent)) { //test for Microsoft URL Control - x.x (ignoring remaining digits);
            version = Number(RegExp.$1); // capture x.x portion and store as a number
            name = "Library (Microsoft URL Control)";
        } else if (/peach[\/\s](\d+\.\d+)/.test(userAgent)) { //test for Peach/x.x or Peach x.x (ignoring remaining digits);
            version = Number(RegExp.$1); // capture x.x portion and store as a number
            name = "Library (Peach)";
        } else if (/php[\/\s](\d+\.\d+)/.test(userAgent)) { //test for PHP/x.x or PHP x.x (ignoring remaining digits);
            version = Number(RegExp.$1); // capture x.x portion and store as a number
            name = "Library (PHP)";
        } else if (/pxyscand[\/\s](\d+\.\d+)/.test(userAgent)) { //test for pxyscand/x.x or pxyscand x.x (ignoring remaining digits);
            version = Number(RegExp.$1); // capture x.x portion and store as a number
            name = "Library (pxyscand)";
        } else if (/pycurl[\/\s](\d+\.\d+)/.test(userAgent)) { //test for pycurl/x.x or pycurl x.x (ignoring remaining digits);
            version = Number(RegExp.$1); // capture x.x portion and store as a number
            name = "Library (PycURL)";
        } else if (/python-urllib[\/\s](\d+\.\d+)/.test(userAgent)) { //test for python-urllib/x.x or python-urllib x.x (ignoring remaining digits);
            version = Number(RegExp.$1); // capture x.x portion and store as a number
            name = "Library (Python URLlib)";
        } else if (/appengine-google/.test(userAgent)) { //test for AppEngine-Google;
            version = Number(RegExp.$1); // capture x.x portion and store as a number
            name = "Cloud (Google AppEngine)";
        } else if (/trident/.test(userAgent)) { //test for Trident;
            version = Number(RegExp.$1); // capture x.x portion and store as a number
            name = "Trident";
        } else if (/adventurer/.test(userAgent)) { //test for Orange Adventurer;
            version = Number(RegExp.$1); // capture x.x portion and store as a number
            name = "Adventurer";
        } else if (/webkit[\/\s](\d+\.\d+)/.test(userAgent)) { //test for generic webkit port;
            version = Number(RegExp.$1); // capture x.x portion and store as a number
            name = "WebKit";
        } else {
            version = "unknown";
            name = "unknown";
        }
    } catch (err) {
        name = "error";
        version = "error";
    }

    return {
        name: name.replace(/\s+/g, ''),
        version: version
    };
}

/*   Copyright (C) 2011,2012,2013,2014 John Kula */

/*
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

    All trademarks and service marks contained within this document are
    property of their respective owners.

    Version 2014.07.23

    Updates may be found at: http:\\www.darkwavetech.com

*/

/*jslint browser:true */

/* This function returns the operating system and number of bits by looking at the navigator.useragent and navigator.platform objects */

function fingerprint_os() {
    "use strict";

    var userAgent,
        platform,
        name,
        bits,
        os = {
            name: "",
            bits: ""
        };

    try {
        /* navigator.userAgent is supported by all major browsers */
        userAgent = navigator.userAgent.toLowerCase();

        if (userAgent.indexOf("windows nt 10.0") !== -1) {
            name = "Windows 10";
        } else if (userAgent.indexOf("windows nt 6.3") !== -1) {
            name = "Windows 8.1";
        } else if (userAgent.indexOf("windows nt 6.2") !== -1) {
            name = "Windows 8";
        } else if (userAgent.indexOf("windows nt 6.1") !== -1) {
            name = "Windows 7";
        } else if (userAgent.indexOf("windows nt 6.0") !== -1) {
            name = "Windows Vista/Windows Server 2008";
        } else if (userAgent.indexOf("windows nt 5.2") !== -1) {
            name = "Windows XP x64/Windows Server 2003";
        } else if (userAgent.indexOf("windows nt 5.1") !== -1) {
            name = "Windows XP";
        } else if (userAgent.indexOf("windows nt 5.01") !== -1) {
            name = "Windows 2000, Service Pack 1 (SP1)";
        } else if (userAgent.indexOf("windows xp") !== -1) {
            name = "Windows XP";
        } else if (userAgent.indexOf("windows 2000") !== -1) {
            name = "Windows 2000";
        } else if (userAgent.indexOf("windows nt 5.0") !== -1) {
            name = "Windows 2000";
        } else if (userAgent.indexOf("windows nt 4.0") !== -1) {
            name = "Windows NT 4.0";
        } else if (userAgent.indexOf("windows nt") !== -1) {
            name = "Windows NT 4.0";
        } else if (userAgent.indexOf("winnt4.0") !== -1) {
            name = "Windows NT 4.0";
        } else if (userAgent.indexOf("winnt") !== -1) {
            name = "Windows NT 4.0";
        } else if (userAgent.indexOf("windows me") !== -1) {
            name = "Windows ME";
        } else if (userAgent.indexOf("win 9x 4.90") !== -1) {
            name = "Windows ME";
        } else if (userAgent.indexOf("windows 98") !== -1) {
            name = "Windows 98";
        } else if (userAgent.indexOf("win98") !== -1) {
            name = "Windows 98";
        } else if (userAgent.indexOf("windows 95") !== -1) {
            name = "Windows 95";
        } else if (userAgent.indexOf("windows_95") !== -1) {
            name = "Windows 95";
        } else if (userAgent.indexOf("win95") !== -1) {
            name = "Windows 95";
        } else if (userAgent.indexOf("ce") !== -1) {
            name = "Windows CE";
        } else if (userAgent.indexOf("win16") !== -1) {
            name = "Windows 3.11";
        } else if (userAgent.indexOf("iemobile") !== -1) {
            name = "Windows Mobile";
        } else if (userAgent.indexOf("wm5 pie") !== -1) {
            name = "Windows Mobile";
        } else if (userAgent.indexOf("windows phone 10.0") !== -1) {
            name = "Windows Phone 10";
        } else if (userAgent.indexOf("windows") !== -1) {
            name = "Windows (Unknown Version)";
        } else if (userAgent.indexOf("openbsd") !== -1) {
            name = "Open BSD";
        } else if (userAgent.indexOf("sunos") !== -1) {
            name = "Sun OS";
        } else if (userAgent.indexOf("ubuntu") !== -1) {
            name = "Ubuntu";
        } else if (userAgent.indexOf("ipad") !== -1) {
            name = "iOS (iPad)";
        } else if (userAgent.indexOf("ipod") !== -1) {
            name = "iOS (iTouch)";
        } else if (userAgent.indexOf("iphone") !== -1) {
            name = "iOS (iPhone)";
        } else if (userAgent.indexOf("mac os x beta") !== -1) {
            name = "Mac O SX Beta";
        } else if (userAgent.indexOf("mac os x 10") !== -1) {
            if (/mac os x 10_(\d+)\_(\d+)/.test(userAgent)) {
                name = "Mac OS X 10." + RegExp.$1;
            } else {
                name = "Mac OS X 10";
            }
        } else if (userAgent.indexOf("mac os x") !== -1) {
            name = "Mac OS X";
        } else if (userAgent.indexOf("mac_68000") !== -1) {
            name = "Mac OS Classic (68000)";
        } else if (userAgent.indexOf("68K") !== -1) {
            name = "Mac OS Classic (68000)";
        } else if (userAgent.indexOf("mac_powerpc") !== -1) {
            name = "Mac OS Classic (PowerPC)";
        } else if (userAgent.indexOf("ppc mac") !== -1) {
            name = "Mac OS Classic (PowerPC)";
        } else if (userAgent.indexOf("macintosh") !== -1) {
            name = "Mac OS Classic";
        } else if (userAgent.indexOf("googletv") !== -1) {
            name = "Android (GoogleTV)";
        } else if (userAgent.indexOf("xoom") !== -1) {
            name = "Android (Xoom)";
        } else if (userAgent.indexOf("htc_flyer") !== -1) {
            name = "Android (HTC Flyer)";
        } else if (userAgent.indexOf("android") !== -1) {
            name = "Android";
        } else if (userAgent.indexOf("symbian") !== -1) {
            name = "Symbian";
        } else if (userAgent.indexOf("series60") !== -1) {
            name = "Symbian (Series 60)";
        } else if (userAgent.indexOf("series70") !== -1) {
            name = "Symbian (Series 70)";
        } else if (userAgent.indexOf("series80") !== -1) {
            name = "Symbian (Series 80)";
        } else if (userAgent.indexOf("series90") !== -1) {
            name = "Symbian (Series 90)";
        } else if (userAgent.indexOf("x11") !== -1) {
            name = "UNIX";
        } else if (userAgent.indexOf("nix") !== -1) {
            name = "UNIX";
        } else if (userAgent.indexOf("linux") !== -1) {
            name = "Linux";
        } else if (userAgent.indexOf("qnx") !== -1) {
            name = "QNX";
        } else if (userAgent.indexOf("os/2") !== -1) {
            name = "IBM OS/2";
        } else if (userAgent.indexOf("beos") !== -1) {
            name = "BeOS";
        } else if (userAgent.indexOf("blackberry95") !== -1) {
            name = "Blackberry (Storm 1/2)";
        } else if (userAgent.indexOf("blackberry97") !== -1) {
            name = "Blackberry (Bold)";
        } else if (userAgent.indexOf("blackberry96") !== -1) {
            name = "Blackberry (Tour)";
        } else if (userAgent.indexOf("blackberry89") !== -1) {
            name = "Blackberry (Curve 2)";
        } else if (userAgent.indexOf("blackberry98") !== -1) {
            name = "Blackberry (Torch)";
        } else if (userAgent.indexOf("playbook") !== -1) {
            name = "Blackberry (Playbook)";
        } else if (userAgent.indexOf("wnd.rim") !== -1) {
            name = "Blackberry (IE/FF Emulator)";
        } else if (userAgent.indexOf("blackberry") !== -1) {
            name = "Blackberry";
        } else if (userAgent.indexOf("palm") !== -1) {
            name = "Palm OS";
        } else if (userAgent.indexOf("webos") !== -1) {
            name = "WebOS";
        } else if (userAgent.indexOf("hpwos") !== -1) {
            name = "WebOS (HP)";
        } else if (userAgent.indexOf("blazer") !== -1) {
            name = "Palm OS (Blazer)";
        } else if (userAgent.indexOf("xiino") !== -1) {
            name = "Palm OS (Xiino)";
        } else if (userAgent.indexOf("kindle") !== -1) {
            name = "Kindle";
        } else if (userAgent.indexOf("wii") !== -1) {
            name = "Nintendo (Wii)";
        } else if (userAgent.indexOf("nintendo ds") !== -1) {
            name = "Nintendo (DS)";
        } else if (userAgent.indexOf("playstation 3") !== -1) {
            name = "Sony (Playstation Console)";
        } else if (userAgent.indexOf("playstation portable") !== -1) {
            name = "Sony (Playstation Portable)";
        } else if (userAgent.indexOf("webtv") !== -1) {
            name = "MSN TV (WebTV)";
        } else if (userAgent.indexOf("inferno") !== -1) {
            name = "Inferno";
        } else {
            name = "Unknown";
        }

        /* navigator.platform is supported by all major browsers */
        platform = navigator.platform.toLowerCase();

        if (platform.indexOf("x64") !== -1) {
            bits = "64";
        } else if (userAgent.indexOf("x86_64") !== -1) {
            bits = "64";
        } else if (userAgent.indexOf("x86-64") !== -1) {
            bits = "64";
        } else if (userAgent.indexOf("win64") !== -1) {
            bits = "64";
        } else if (userAgent.indexOf("x64;") !== -1) {
            bits = "64";
        } else if (userAgent.indexOf("amd64") !== -1) {
            bits = "64";
        } else if (userAgent.indexOf("wow64") !== -1) {
            bits = "64";
        } else if (userAgent.indexOf("x64_64") !== -1) {
            bits = "64";
        } else if (userAgent.indexOf("ia65") !== -1) {
            bits = "64";
        } else if (userAgent.indexOf("sparc64") !== -1) {
            bits = "64";
        } else if (userAgent.indexOf("ppc64") !== -1) {
            bits = "64";
        } else if (userAgent.indexOf("irix64") !== -1) {
            bits = "64";
        } else if (userAgent.indexOf("irix64") !== -1) {
            bits = "64";
        } else {
            bits = "32";
        }
    } catch (err) {
        name = "error";
        bits = "error";
    }

    return {
        name: name.replace(/\s+/g, ''),
        bits: "x" + bits
    };
}

dijon = this.dijon;
return MediaPlayer;
}));
//# sourceMappingURL=hasplayer.js.map
