{"version":3,"names":[],"mappings":"","sources":["field-kit.js"],"sourcesContent":["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.FieldKit = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\n// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}],2:[function(_dereq_,module,exports){\n(function (process){\n(function (global, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define('InputSim', ['exports'], factory);\n  } else if (typeof exports !== 'undefined') {\n    factory(exports);\n  } else {\n    var mod = {\n      exports: {}\n    };\n    factory(mod.exports);\n    global.InputSim = mod.exports;\n  }\n})(this, function (exports) {\n  /*! jshint esnext:true, undef:true, unused:true */\n\n  /** @private */\n  'use strict';\n\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  var A = 65;\n  /** @private */\n  var Y = 89;\n  /** @private */\n  var Z = 90;\n  /** @private */\n  var ZERO = 48;\n  /** @private */\n  var NINE = 57;\n  /** @private */\n  var LEFT = 37;\n  /** @private */\n  var RIGHT = 39;\n  /** @private */\n  var UP = 38;\n  /** @private */\n  var DOWN = 40;\n  /** @private */\n  var BACKSPACE = 8;\n  /** @private */\n  var DELETE = 46;\n  /** @private */\n  var TAB = 9;\n  /** @private */\n  var ENTER = 13;\n\n  /**\n   * @namespace KEYS\n   */\n  var KEYS = {\n    A: A,\n    Y: Y,\n    Z: Z,\n    ZERO: ZERO,\n    NINE: NINE,\n    LEFT: LEFT,\n    RIGHT: RIGHT,\n    UP: UP,\n    DOWN: DOWN,\n    BACKSPACE: BACKSPACE,\n    DELETE: DELETE,\n    TAB: TAB,\n    ENTER: ENTER,\n\n    /**\n     * @param {number} keyCode\n     * @returns {boolean}\n     */\n    isDigit: function isDigit(keyCode) {\n      return ZERO <= keyCode && keyCode <= NINE;\n    },\n\n    /**\n     * Is an arrow keyCode.\n     *\n     * @param {number} keyCode\n     * @returns {boolean}\n     */\n    isDirectional: function isDirectional(keyCode) {\n      return keyCode === LEFT || keyCode === RIGHT || keyCode === UP || keyCode === DOWN;\n    }\n  };\n\n  var CTRL = 1 << 0;\n  var META = 1 << 1;\n  var ALT = 1 << 2;\n  var SHIFT = 1 << 3;\n\n  var cache = {};\n\n  /**\n   * Builds a BindingSet based on the current platform.\n   *\n   * @param {string} platform A string name of a platform (e.g. \"OSX\").\n   * @returns {BindingSet} keybindings appropriate for the given platform.\n   */\n  function keyBindingsForPlatform(platform) {\n    var osx = platform === 'OSX';\n    var ctrl = osx ? META : CTRL;\n\n    if (!cache[platform]) {\n      cache[platform] = build(function (bind) {\n        bind(A, ctrl, 'selectAll');\n        bind(LEFT, null, 'moveLeft');\n        bind(LEFT, ALT, 'moveWordLeft');\n        bind(LEFT, SHIFT, 'moveLeftAndModifySelection');\n        bind(LEFT, ALT | SHIFT, 'moveWordLeftAndModifySelection');\n        bind(RIGHT, null, 'moveRight');\n        bind(RIGHT, ALT, 'moveWordRight');\n        bind(RIGHT, SHIFT, 'moveRightAndModifySelection');\n        bind(RIGHT, ALT | SHIFT, 'moveWordRightAndModifySelection');\n        bind(UP, null, 'moveUp');\n        bind(UP, ALT, 'moveToBeginningOfParagraph');\n        bind(UP, SHIFT, 'moveUpAndModifySelection');\n        bind(UP, ALT | SHIFT, 'moveParagraphBackwardAndModifySelection');\n        bind(DOWN, null, 'moveDown');\n        bind(DOWN, ALT, 'moveToEndOfParagraph');\n        bind(DOWN, SHIFT, 'moveDownAndModifySelection');\n        bind(DOWN, ALT | SHIFT, 'moveParagraphForwardAndModifySelection');\n        bind(BACKSPACE, null, 'deleteBackward');\n        bind(BACKSPACE, SHIFT, 'deleteBackward');\n        bind(BACKSPACE, ALT, 'deleteWordBackward');\n        bind(BACKSPACE, ALT | SHIFT, 'deleteWordBackward');\n        bind(BACKSPACE, ctrl, 'deleteBackwardToBeginningOfLine');\n        bind(BACKSPACE, ctrl | SHIFT, 'deleteBackwardToBeginningOfLine');\n        bind(DELETE, null, 'deleteForward');\n        bind(DELETE, ALT, 'deleteWordForward');\n        bind(TAB, null, 'insertTab');\n        bind(TAB, SHIFT, 'insertBackTab');\n        bind(ENTER, null, 'insertNewline');\n        bind(Z, ctrl, 'undo');\n\n        if (osx) {\n          bind(LEFT, META, 'moveToBeginningOfLine');\n          bind(LEFT, META | SHIFT, 'moveToBeginningOfLineAndModifySelection');\n          bind(RIGHT, META, 'moveToEndOfLine');\n          bind(RIGHT, META | SHIFT, 'moveToEndOfLineAndModifySelection');\n          bind(UP, META, 'moveToBeginningOfDocument');\n          bind(UP, META | SHIFT, 'moveToBeginningOfDocumentAndModifySelection');\n          bind(DOWN, META, 'moveToEndOfDocument');\n          bind(DOWN, META | SHIFT, 'moveToEndOfDocumentAndModifySelection');\n          bind(BACKSPACE, CTRL, 'deleteBackwardByDecomposingPreviousCharacter');\n          bind(BACKSPACE, CTRL | SHIFT, 'deleteBackwardByDecomposingPreviousCharacter');\n          bind(Z, META | SHIFT, 'redo');\n        } else {\n          bind(Y, CTRL, 'redo');\n        }\n      });\n    }\n\n    return cache[platform];\n  }\n\n  function build(callback) {\n    var result = new BindingSet();\n    callback(function () {\n      return result.bind.apply(result, arguments);\n    });\n    return result;\n  }\n\n  /**\n   * @private\n   */\n\n  var BindingSet = (function () {\n    function BindingSet() {\n      _classCallCheck(this, BindingSet);\n\n      this.bindings = {};\n    }\n\n    /**\n     * Enum for text direction affinity.\n     *\n     * @const\n     * @enum {number}\n     * @private\n     */\n\n    /**\n     * @param {number} keyCode\n     * @param {number} modifiers\n     * @param {string} action\n     */\n\n    _createClass(BindingSet, [{\n      key: 'bind',\n      value: function bind(keyCode, modifiers, action) {\n        if (!this.bindings[keyCode]) {\n          this.bindings[keyCode] = {};\n        }\n        this.bindings[keyCode][modifiers || 0] = action;\n      }\n\n      /**\n       * @param {Event} event\n       * @returns {?string}\n       */\n    }, {\n      key: 'actionForEvent',\n      value: function actionForEvent(event) {\n        var bindingsForKeyCode = this.bindings[event.keyCode];\n        if (bindingsForKeyCode) {\n          var modifiers = 0;\n          if (event.altKey) {\n            modifiers |= ALT;\n          }\n          if (event.ctrlKey) {\n            modifiers |= CTRL;\n          }\n          if (event.metaKey) {\n            modifiers |= META;\n          }\n          if (event.shiftKey) {\n            modifiers |= SHIFT;\n          }\n          return bindingsForKeyCode[modifiers];\n        }\n      }\n    }]);\n\n    return BindingSet;\n  })();\n\n  var Affinity = {\n    UPSTREAM: 0,\n    DOWNSTREAM: 1,\n    NONE: null\n  };\n\n  /**\n   * Tests is string passed in is a single word.\n   *\n   * @param {string} chr\n   * @returns {boolean}\n   * @private\n   */\n  function isWordChar(chr) {\n    return chr && /^\\w$/.test(chr);\n  }\n\n  /**\n   * Checks if char to the left of {index} in {string}\n   * is a break (non-char).\n   *\n   * @param {string} text\n   * @param {number} index\n   * @returns {boolean}\n   * @private\n   */\n  function hasLeftWordBreakAtIndex(text, index) {\n    if (index === 0) {\n      return true;\n    } else {\n      return !isWordChar(text[index - 1]) && isWordChar(text[index]);\n    }\n  }\n\n  /**\n   * Checks if char to the right of {index} in {string}\n   * is a break (non-char).\n   *\n   * @param {string} text\n   * @param {number} index\n   * @returns {boolean}\n   * @private\n   */\n  function hasRightWordBreakAtIndex(text, index) {\n    if (index === text.length - 1) {\n      return true;\n    } else {\n      return isWordChar(text[index]) && !isWordChar(text[index + 1]);\n    }\n  }\n\n  var Input = (function () {\n    /**\n      * Sets up the initial properties of the TextField and\n      * sets  up the event listeners\n      *\n      * @param {string} value\n      * @param {Object} range ({start: 0, length: 0})\n      */\n\n    function Input(value, range) {\n      _classCallCheck(this, Input);\n\n      this._value = '';\n      this._selectedRange = {\n        start: 0,\n        length: 0\n      };\n      this.shouldCancelEvents = true;\n      this.selectionAffinity = Affinity.NONE;\n\n      if (value) {\n        this.setText(value);\n      }\n      if (range) {\n        this.setSelectedRange(range);\n      }\n      this._buildKeybindings();\n    }\n\n    /**\n     * Clears all characters in the existing selection.\n     *\n     * @example\n     *     // 12|34567|8\n     *     clearSelection();\n     *     // 12|8\n     *\n     */\n\n    _createClass(Input, [{\n      key: 'clearSelection',\n      value: function clearSelection() {\n        this.replaceSelection('');\n      }\n\n      /**\n       * Deletes backward one character or clears a non-empty selection.\n       *\n       * @example\n       *\n       *     // |What's up, doc?\n       *     deleteBackward(event);\n       *     // |What's up, doc?\n       *\n       *     // What'|s up, doc?\n       *     deleteBackward(event);\n       *     // What|s up, doc?\n       *\n       *     // |What's| up, doc?\n       *     deleteBackward(event);\n       *     // | up, doc?\n       */\n    }, {\n      key: 'deleteBackward',\n      value: function deleteBackward(event) {\n        this._handleEvent(event);\n        var range = this.selectedRange();\n        if (range.length === 0) {\n          range.start--;\n          range.length++;\n          this.setSelectedRange(range);\n        }\n        this.clearSelection();\n      }\n\n      /**\n       * Deletes backward one word or clears a non-empty selection.\n       *\n       * @example\n       *     // |What's up, doc?\n       *     deleteWordBackward(event);\n       *     // |What's up, doc?\n       *\n       *     // What'|s up, doc?\n       *     deleteWordBackward(event);\n       *     // |s up, doc?\n       *\n       *     // |What's| up, doc?\n       *     deleteWordBackward(event);\n       *     // | up, doc?\n       */\n    }, {\n      key: 'deleteWordBackward',\n      value: function deleteWordBackward(event) {\n        if (this.hasSelection()) {\n          this.deleteBackward(event);\n        } else {\n          this._handleEvent(event);\n          var range = this.selectedRange();\n          var start = this._lastWordBreakBeforeIndex(range.start);\n          range.length += range.start - start;\n          range.start = start;\n          this.setSelectedRange(range);\n          this.clearSelection();\n        }\n      }\n\n      /**\n       * Deletes backward one character, clears a non-empty selection, or decomposes\n       * an accented character to its simple form.\n       *\n       * @TODO Make this work as described.\n       *\n       * @example\n       *     // |fiancée\n       *     deleteBackwardByDecomposingPreviousCharacter(event);\n       *     // |What's up, doc?\n       *\n       *     // fianc|é|e\n       *     deleteBackwardByDecomposingPreviousCharacter(event);\n       *     // fianc|e\n       *\n       *     // fiancé|e\n       *     deleteBackwardByDecomposingPreviousCharacter(event);\n       *     // fiance|e\n       *\n       */\n    }, {\n      key: 'deleteBackwardByDecomposingPreviousCharacter',\n      value: function deleteBackwardByDecomposingPreviousCharacter(event) {\n        this.deleteBackward(event);\n      }\n\n      /**\n       * Deletes all characters before the cursor or clears a non-empty selection.\n       *\n       * @example\n       *     // The quick |brown fox.\n       *     deleteBackwardToBeginningOfLine(event);\n       *     // |brown fox.\n       *\n       *     // The |quick |brown fox.\n       *     deleteBackwardToBeginningOfLine(event);\n       *     // The brown fox.\n       *\n       */\n    }, {\n      key: 'deleteBackwardToBeginningOfLine',\n      value: function deleteBackwardToBeginningOfLine(event) {\n        if (this.hasSelection()) {\n          this.deleteBackward(event);\n        } else {\n          this._handleEvent(event);\n          var range = this.selectedRange();\n          range.length = range.start;\n          range.start = 0;\n          this.setSelectedRange(range);\n          this.clearSelection();\n        }\n      }\n\n      /**\n       * Deletes forward one character or clears a non-empty selection.\n       *\n       * @example\n       *     // What's up, doc?|\n       *     deleteForward(event);\n       *     // What's up, doc?|\n       *\n       *     // What'|s up, doc?\n       *     deleteForward(event);\n       *     // What'| up, doc?\n       *\n       *     // |What's| up, doc?\n       *     deleteForward(event);\n       *     // | up, doc?\n       *\n       */\n    }, {\n      key: 'deleteForward',\n      value: function deleteForward(event) {\n        this._handleEvent(event);\n        var range = this.selectedRange();\n        if (range.length === 0) {\n          range.length++;\n          this.setSelectedRange(range);\n        }\n        this.clearSelection();\n      }\n\n      /**\n       * Deletes forward one word or clears a non-empty selection.\n       *\n       * @example\n       *     // What's up, doc?|\n       *     deleteWordForward(event);\n       *     // What's up, doc?|\n       *\n       *     // What's |up, doc?\n       *     deleteWordForward(event);\n       *     // What's |, doc?\n       *\n       *     // |What's| up, doc?\n       *     deleteWordForward(event);\n       *     // | up, doc?\n       */\n    }, {\n      key: 'deleteWordForward',\n      value: function deleteWordForward(event) {\n        if (this.hasSelection()) {\n          return this.deleteForward(event);\n        } else {\n          this._handleEvent(event);\n          var range = this.selectedRange();\n          var end = this._nextWordBreakAfterIndex(range.start + range.length);\n          this.setSelectedRange({\n            start: range.start,\n            length: end - range.start\n          });\n          this.clearSelection();\n        }\n      }\n    }, {\n      key: 'handleEvent',\n      value: function handleEvent(event) {\n        if (typeof event === 'undefined') {\n          throw new Error('cannot handle and event that isn\\'t passed');\n        }\n        var action = this._bindings.actionForEvent(event);\n        if (action) this[action](event);\n        return action;\n      }\n\n      /**\n       * Determines whether this field has any selection.\n       *\n       * @returns {boolean} true if there is at least one character selected\n       */\n    }, {\n      key: 'hasSelection',\n      value: function hasSelection() {\n        return this.selectedRange().length !== 0;\n      }\n\n      /**\n       * Handles the back tab key.\n       *\n       */\n    }, {\n      key: 'insertBackTab',\n      value: function insertBackTab() {}\n\n      /**\n       * Handles a key event could be trying to end editing.\n       *\n       */\n    }, {\n      key: 'insertNewline',\n      value: function insertNewline() {}\n\n      /**\n       * Handles the tab key.\n       *\n       */\n    }, {\n      key: 'insertTab',\n      value: function insertTab() {}\n\n      /**\n       * Handles a event that is trying to insert a character.\n       *\n       * @param {string} text\n       */\n    }, {\n      key: 'insertText',\n      value: function insertText(text) {\n        var range;\n        if (this.hasSelection()) {\n          this.clearSelection();\n        }\n\n        this.replaceSelection(text);\n        range = this.selectedRange();\n        range.start += range.length;\n        range.length = 0;\n        this.setSelectedRange(range);\n      }\n\n      /**\n       * Moves the cursor up, which because this is a single-line text field, means\n       * moving to the beginning of the value.\n       *\n       * @example\n       *     // Hey guys|\n       *     moveUp(event);\n       *     // |Hey guys\n       *\n       *     // Hey |guys|\n       *     moveUp(event);\n       *     // |Hey guys\n       *\n       * @param {Event} event\n       */\n    }, {\n      key: 'moveUp',\n      value: function moveUp(event) {\n        this._handleEvent(event);\n        this.setSelectedRange({\n          start: 0,\n          length: 0\n        });\n      }\n\n      /**\n       * Moves the cursor up to the beginning of the current paragraph, which because\n       * this is a single-line text field, means moving to the beginning of the\n       * value.\n       *\n       * @example\n       *     // Hey guys|\n       *     moveToBeginningOfParagraph(event)\n       *     // |Hey guys\n       *\n       *     // Hey |guys|\n       *     moveToBeginningOfParagraph(event)\n       *     // |Hey guys\n       *\n       * @param {Event} event\n       */\n    }, {\n      key: 'moveToBeginningOfParagraph',\n      value: function moveToBeginningOfParagraph(event) {\n        this.moveUp(event);\n      }\n\n      /**\n       * Moves the cursor up, keeping the current anchor point and extending the\n       * selection to the beginning as moveUp would.\n       *\n       * @example\n       *     // rightward selections are shrunk\n       *     // Hey guys, |where> are you?\n       *     moveUpAndModifySelection(event);\n       *     // <Hey guys, |where are you?\n       *\n       *     // leftward selections are extended\n       *     // Hey guys, <where| are you?\n       *     moveUpAndModifySelection(event);\n       *     // <Hey guys, where| are you?\n       *\n       *     // neutral selections are extended\n       *     // Hey guys, |where| are you?\n       *     moveUpAndModifySelection(event);\n       *     // <Hey guys, where| are you?\n       *\n       * @param {Event} event\n       */\n    }, {\n      key: 'moveUpAndModifySelection',\n      value: function moveUpAndModifySelection(event) {\n        this._handleEvent(event);\n        var range = this.selectedRange();\n        switch (this.selectionAffinity) {\n          case Affinity.UPSTREAM:\n          case Affinity.NONE:\n            // 12<34 56|78  =>  <1234 56|78\n            range.length += range.start;\n            range.start = 0;\n            break;\n          case Affinity.DOWNSTREAM:\n            // 12|34 56>78   =>   <12|34 5678\n            range.length = range.start;\n            range.start = 0;\n            break;\n        }\n        this.setSelectedRangeWithAffinity(range, Affinity.UPSTREAM);\n      }\n\n      /**\n       * Moves the free end of the selection to the beginning of the paragraph, or\n       * since this is a single-line text field to the beginning of the line.\n       *\n       * @param {Event} event\n       */\n    }, {\n      key: 'moveParagraphBackwardAndModifySelection',\n      value: function moveParagraphBackwardAndModifySelection(event) {\n        this._handleEvent(event);\n        var range = this.selectedRange();\n        switch (this.selectionAffinity) {\n          case Affinity.UPSTREAM:\n          case Affinity.NONE:\n            // 12<34 56|78  =>  <1234 56|78\n            range.length += range.start;\n            range.start = 0;\n            break;\n          case Affinity.DOWNSTREAM:\n            // 12|34 56>78  =>  12|34 5678\n            range.length = 0;\n            break;\n        }\n        this.setSelectedRangeWithAffinity(range, Affinity.UPSTREAM);\n      }\n\n      /**\n       * Moves the cursor to the beginning of the document.\n       *\n       * @param {Event} event\n       */\n    }, {\n      key: 'moveToBeginningOfDocument',\n      value: function moveToBeginningOfDocument(event) {\n        // Since we only support a single line this is just an alias.\n        this.moveToBeginningOfLine(event);\n      }\n\n      /**\n       * Moves the selection start to the beginning of the document.\n       * @param {Event} event\n       */\n    }, {\n      key: 'moveToBeginningOfDocumentAndModifySelection',\n      value: function moveToBeginningOfDocumentAndModifySelection(event) {\n        this._handleEvent(event);\n        var range = this.selectedRange();\n        range.length += range.start;\n        range.start = 0;\n        this.setSelectedRangeWithAffinity(range, Affinity.UPSTREAM);\n      }\n\n      /**\n       * Moves the cursor down, which because this is a single-line text field, means\n       * moving to the end of the value.\n       *\n       * @example\n       *     // Hey |guys\n       *     moveDown(event)\n       *     // Hey guys|\n       *\n       *     // |Hey| guys\n       *     moveDown(event)\n       *     // Hey guys|\n       *\n       * @param {Event} event\n       */\n    }, {\n      key: 'moveDown',\n      value: function moveDown(event) {\n        this._handleEvent(event);\n        // 12|34 56|78  =>  1234 5678|\n        var range = {\n          start: this.text().length,\n          length: 0\n        };\n        this.setSelectedRangeWithAffinity(range, Affinity.NONE);\n      }\n\n      /**\n       * Moves the cursor up to the end of the current paragraph, which because this\n       * is a single-line text field, means moving to the end of the value.\n       *\n       * @example\n       *     // |Hey guys\n       *     moveToEndOfParagraph(event)\n       *     // Hey guys|\n       *\n       *     // Hey |guys|\n       *     moveToEndOfParagraph(event)\n       *     // Hey guys|\n       *\n       * @param {Event} event\n       */\n    }, {\n      key: 'moveToEndOfParagraph',\n      value: function moveToEndOfParagraph(event) {\n        this.moveDown(event);\n      }\n\n      /**\n       * Moves the cursor down, keeping the current anchor point and extending the\n       * selection to the end as moveDown would.\n       *\n       * @example\n       *     // leftward selections are shrunk\n       *     // Hey guys, <where| are you?\n       *     moveDownAndModifySelection(event)\n       *     // Hey guys, where| are you?>\n       *\n       *     // rightward selections are extended\n       *     // Hey guys, |where> are you?\n       *     moveDownAndModifySelection(event)\n       *     // Hey guys, |where are you?>\n       *\n       *     // neutral selections are extended\n       *     // Hey guys, |where| are you?\n       *     moveDownAndModifySelection(event)\n       *     // Hey guys, |where are you?>\n       *\n       * @param {Event} event\n       */\n    }, {\n      key: 'moveDownAndModifySelection',\n      value: function moveDownAndModifySelection(event) {\n        this._handleEvent(event);\n        var range = this.selectedRange();\n        var end = this.text().length;\n        if (this.selectionAffinity === Affinity.UPSTREAM) {\n          range.start += range.length;\n        }\n        range.length = end - range.start;\n        this.setSelectedRangeWithAffinity(range, Affinity.DOWNSTREAM);\n      }\n\n      /**\n       * Moves the free end of the selection to the end of the paragraph, or since\n       * this is a single-line text field to the end of the line.\n       *\n       * @param {Event} event\n       */\n    }, {\n      key: 'moveParagraphForwardAndModifySelection',\n      value: function moveParagraphForwardAndModifySelection(event) {\n        this._handleEvent(event);\n        var range = this.selectedRange();\n        switch (this.selectionAffinity) {\n          case Affinity.DOWNSTREAM:\n          case Affinity.NONE:\n            // 12|34 56>78  =>  12|34 5678>\n            range.length = this.text().length - range.start;\n            break;\n          case Affinity.UPSTREAM:\n            // 12<34 56|78  =>  12|34 5678\n            range.start += range.length;\n            range.length = 0;\n            break;\n        }\n        this.setSelectedRangeWithAffinity(range, Affinity.DOWNSTREAM);\n      }\n\n      /**\n       * Moves the cursor to the end of the document.\n       *\n       * @param {Event} event\n       */\n    }, {\n      key: 'moveToEndOfDocument',\n      value: function moveToEndOfDocument(event) {\n        // Since we only support a single line this is just an alias.\n        this.moveToEndOfLine(event);\n      }\n\n      /**\n       * Moves the selection end to the end of the document.\n       * @param {Event} event\n       */\n    }, {\n      key: 'moveToEndOfDocumentAndModifySelection',\n      value: function moveToEndOfDocumentAndModifySelection(event) {\n        this._handleEvent(event);\n        var range = this.selectedRange();\n        range.length = this.text().length - range.start;\n        this.setSelectedRangeWithAffinity(range, Affinity.DOWNSTREAM);\n      }\n\n      /**\n       * Moves the cursor to the left, counting selections as a thing to move past.\n       *\n       * @example\n       *     // no selection just moves the cursor left\n       *     // Hey guys|\n       *     moveLeft(event)\n       *     // Hey guy|s\n       *\n       *     // selections are removed\n       *     // Hey |guys|\n       *     moveLeft(event)\n       *     // Hey |guys\n       *\n       * @param {Event} event\n       */\n    }, {\n      key: 'moveLeft',\n      value: function moveLeft(event) {\n        this._handleEvent(event);\n        var range = this.selectedRange();\n        if (range.length !== 0) {\n          range.length = 0;\n        } else {\n          range.start--;\n        }\n        this.setSelectedRangeWithAffinity(range, Affinity.NONE);\n      }\n\n      /**\n       * Moves the free end of the selection one to the left.\n       *\n       * @example\n       *     // no selection just selects to the left\n       *     // Hey guys|\n       *     moveLeftAndModifySelection(event)\n       *     // Hey guy<s|\n       *\n       *     // left selections are extended\n       *     // Hey <guys|\n       *     moveLeftAndModifySelection(event)\n       *     // Hey< guys|\n       *\n       *     // right selections are shrunk\n       *     // Hey |guys>\n       *     moveLeftAndModifySelection(event)\n       *     // Hey |guy>s\n       *\n       *     // neutral selections are extended\n       *     // Hey |guys|\n       *     moveLeftAndModifySelection(event)\n       *     //Hey< guys|\n       *\n       * @param {Event} event\n       */\n    }, {\n      key: 'moveLeftAndModifySelection',\n      value: function moveLeftAndModifySelection(event) {\n        this._handleEvent(event);\n        var range = this.selectedRange();\n        switch (this.selectionAffinity) {\n          case Affinity.UPSTREAM:\n          case Affinity.NONE:\n            this.selectionAffinity = Affinity.UPSTREAM;\n            range.start--;\n            range.length++;\n            break;\n          case Affinity.DOWNSTREAM:\n            range.length--;\n            break;\n        }\n        this.setSelectedRange(range);\n      }\n\n      /**\n       * Moves the cursor left until the start of a word is found.\n       *\n       * @example\n       *     // no selection just moves the cursor left\n       *     // Hey guys|\n       *     moveWordLeft(event)\n       *     // Hey |guys\n       *\n       *     // selections are removed\n       *     // Hey |guys|\n       *     moveWordLeft(event)\n       *     // |Hey guys\n       *\n       * @param {Event} event\n       */\n    }, {\n      key: 'moveWordLeft',\n      value: function moveWordLeft(event) {\n        this._handleEvent(event);\n        var index = this._lastWordBreakBeforeIndex(this.selectedRange().start - 1);\n        this.setSelectedRange({ start: index, length: 0 });\n      }\n\n      /**\n       * Moves the free end of the current selection to the beginning of the previous\n       * word.\n       *\n       * @example\n       *     // no selection just selects to the left\n       *     // Hey guys|\n       *     moveWordLeftAndModifySelection(event)\n       *     // Hey <guys|\n       *\n       *     // left selections are extended\n       *     // Hey <guys|\n       *     moveWordLeftAndModifySelection(event)\n       *     // <Hey guys|\n       *\n       *     // right selections are shrunk\n       *     // |Hey guys>\n       *     moveWordLeftAndModifySelection(event)\n       *     // |Hey >guys\n       *\n       *     // neutral selections are extended\n       *     // Hey |guys|\n       *     moveWordLeftAndModifySelection(event)\n       *     // <Hey guys|\n       *\n       * @param {Event} event\n       */\n    }, {\n      key: 'moveWordLeftAndModifySelection',\n      value: function moveWordLeftAndModifySelection(event) {\n        this._handleEvent(event);\n        var range = this.selectedRange();\n        switch (this.selectionAffinity) {\n          case Affinity.UPSTREAM:\n          case Affinity.NONE:\n            this.selectionAffinity = Affinity.UPSTREAM;\n            var start = this._lastWordBreakBeforeIndex(range.start - 1);\n            range.length += range.start - start;\n            range.start = start;\n            break;\n          case Affinity.DOWNSTREAM:\n            var end = this._lastWordBreakBeforeIndex(range.start + range.length);\n            if (end < range.start) {\n              end = range.start;\n            }\n            range.length -= range.start + range.length - end;\n            break;\n        }\n        this.setSelectedRange(range);\n      }\n\n      /**\n       * Moves the cursor to the beginning of the current line.\n       *\n       * @example\n       *     // Hey guys, where| are ya?\n       *     moveToBeginningOfLine(event)\n       *     // |Hey guys, where are ya?\n       *\n       * @param {Event} event\n       */\n    }, {\n      key: 'moveToBeginningOfLine',\n      value: function moveToBeginningOfLine(event) {\n        this._handleEvent(event);\n        this.setSelectedRange({ start: 0, length: 0 });\n      }\n\n      /**\n       * Select from the free end of the selection to the beginning of line.\n       *\n       * @example\n       *     // Hey guys, where| are ya?\n       *     moveToBeginningOfLineAndModifySelection(event)\n       *     // <Hey guys, where| are ya?\n       *\n       *     // Hey guys, where| are> ya?\n       *     moveToBeginningOfLineAndModifySelection(event)\n       *     // <Hey guys, where are| ya?\n       *\n       * @param {Event} event\n       */\n    }, {\n      key: 'moveToBeginningOfLineAndModifySelection',\n      value: function moveToBeginningOfLineAndModifySelection(event) {\n        this._handleEvent(event);\n        var range = this.selectedRange();\n        range.length += range.start;\n        range.start = 0;\n        this.setSelectedRangeWithAffinity(range, Affinity.UPSTREAM);\n      }\n\n      /**\n       * Moves the cursor to the right, counting selections as a thing to move past.\n       *\n       * @example\n       *     // no selection just moves the cursor right\n       *     // Hey guy|s\n       *     moveRight(event)\n       *     // Hey guys|\n       *\n       *     // selections are removed\n       *     // Hey |guys|\n       *     moveRight(event)\n       *     // Hey guys|\n       *\n       * @param {Event} event\n       */\n    }, {\n      key: 'moveRight',\n      value: function moveRight(event) {\n        this._handleEvent(event);\n        var range = this.selectedRange();\n        if (range.length !== 0) {\n          range.start += range.length;\n          range.length = 0;\n        } else {\n          range.start++;\n        }\n        this.setSelectedRangeWithAffinity(range, Affinity.NONE);\n      }\n\n      /**\n       * Moves the free end of the selection one to the right.\n       *\n       * @example\n       *     // no selection just selects to the right\n       *     // Hey |guys\n       *     moveRightAndModifySelection(event)\n       *     // Hey |g>uys\n       *\n       *     // right selections are extended\n       *     // Hey |gu>ys\n       *     moveRightAndModifySelection(event)\n       *     // Hey |guy>s\n       *\n       *     // left selections are shrunk\n       *     // <Hey |guys\n       *     moveRightAndModifySelection(event)\n       *     // H<ey |guys\n       *\n       *     // neutral selections are extended\n       *     // |Hey| guys\n       *     moveRightAndModifySelection(event)\n       *     // |Hey >guys\n       *\n       * @param {Event} event\n       */\n    }, {\n      key: 'moveRightAndModifySelection',\n      value: function moveRightAndModifySelection(event) {\n        this._handleEvent(event);\n        var range = this.selectedRange();\n        switch (this.selectionAffinity) {\n          case Affinity.UPSTREAM:\n            range.start++;\n            range.length--;\n            break;\n          case Affinity.DOWNSTREAM:\n          case Affinity.NONE:\n            this.selectionAffinity = Affinity.DOWNSTREAM;\n            range.length++;\n            break;\n        }\n        this.setSelectedRange(range);\n      }\n\n      /**\n       * Moves the cursor right until the end of a word is found.\n       *\n       * @example\n       *     // no selection just moves the cursor right\n       *     // Hey| guys\n       *     moveWordRight(event)\n       *     // Hey guys|\n       *\n       *     // selections are removed\n       *     // |Hey| guys\n       *     moveWordRight(event)\n       *     // Hey guys|\n       *\n       * @param {Event} event\n       */\n    }, {\n      key: 'moveWordRight',\n      value: function moveWordRight(event) {\n        this._handleEvent(event);\n        var range = this.selectedRange();\n        var index = this._nextWordBreakAfterIndex(range.start + range.length);\n        this.setSelectedRange({ start: index, length: 0 });\n      }\n\n      /**\n       * Moves the free end of the current selection to the next end of word.\n       *\n       * @example\n       *     // no selection just selects to the right\n       *     // Hey |guys\n       *     moveWordRightAndModifySelection(event)\n       *     // Hey |guys|\n       *\n       *     // right selections are extended\n       *     // Hey |g>uys\n       *     moveWordRightAndModifySelection(event)\n       *     // Hey |guys>\n       *\n       *     // left selections are shrunk\n       *     // He<y |guys\n       *     moveWordRightAndModifySelection(event)\n       *     // Hey< |guys\n       *\n       *     // neutral selections are extended\n       *     // He|y |guys\n       *     moveWordRightAndModifySelection(event)\n       *     // He|y guys>\n       *\n       * @param {Event} event\n       */\n    }, {\n      key: 'moveWordRightAndModifySelection',\n      value: function moveWordRightAndModifySelection(event) {\n        this._handleEvent(event);\n        var range = this.selectedRange();\n        var start = range.start;\n        var end = range.start + range.length;\n        switch (this.selectionAffinity) {\n          case Affinity.UPSTREAM:\n            start = Math.min(this._nextWordBreakAfterIndex(start), end);\n            break;\n          case Affinity.DOWNSTREAM:\n          case Affinity.NONE:\n            this.selectionAffinity = Affinity.DOWNSTREAM;\n            end = this._nextWordBreakAfterIndex(range.start + range.length);\n            break;\n        }\n        this.setSelectedRange({ start: start, length: end - start });\n      }\n\n      /**\n       * Moves the cursor to the end of the current line.\n       *\n       * @example\n       *     // Hey guys, where| are ya?\n       *     moveToEndOfLine(event)\n       *     // |Hey guys, where are ya?\n       *\n       * @param {Event} event\n       */\n    }, {\n      key: 'moveToEndOfLine',\n      value: function moveToEndOfLine(event) {\n        this._handleEvent(event);\n        this.setSelectedRange({ start: this.text().length, length: 0 });\n      }\n\n      /**\n       * Moves the free end of the selection to the end of the current line.\n       *\n       * @example\n       *     // Hey guys, where| are ya?\n       *     moveToEndOfLineAndModifySelection(event)\n       *     // Hey guys, where| are ya?>\n       *\n       *     // Hey guys, <where| are ya?\n       *     moveToEndOfLineAndModifySelection(event)\n       *     // Hey guys, |where are ya?>\n       *\n       * @param {Event} event\n       */\n    }, {\n      key: 'moveToEndOfLineAndModifySelection',\n      value: function moveToEndOfLineAndModifySelection(event) {\n        this._handleEvent(event);\n        var range = this.selectedRange();\n        range.length = this.text().length - range.start;\n        this.setSelectedRangeWithAffinity(range, Affinity.DOWNSTREAM);\n      }\n\n      /**\n       * Replaces the characters within the selection with given text.\n       *\n       * @example\n       *     // 12|34567|8\n       *     replaceSelection('00')\n       *     // 12|00|8\n       *\n       * @param {string} replacement\n       */\n    }, {\n      key: 'replaceSelection',\n      value: function replaceSelection(replacement) {\n        var range = this.selectedRange();\n        var end = range.start + range.length;\n        var text = this.text();\n        text = text.substring(0, range.start) + replacement + text.substring(end);\n        range.length = replacement.length;\n        this.setText(text);\n        this.setSelectedRangeWithAffinity(range, Affinity.NONE);\n      }\n\n      /**\n       * Find ends of 'words' for navigational purposes.\n       *\n       * @example\n       *     // given value of '123456789' and text of '123-45-6789'\n       *     rightWordBreakIndexes()\n       *     //=> [3, 5, 9]\n       *\n       * @returns {number[]}\n       */\n    }, {\n      key: 'rightWordBreakIndexes',\n      value: function rightWordBreakIndexes() {\n        var result = [];\n        var text = this.text();\n        for (var i = 0, l = text.length; i < l; i++) {\n          if (hasRightWordBreakAtIndex(text, i)) {\n            result.push(i + 1);\n          }\n        }\n        return result;\n      }\n\n      /**\n       * Expands the selection to contain all the characters in the content.\n       *\n       * @example\n       *     // 123|45678\n       *     selectAll(event)\n       *     // |12345678|\n       *\n       * @param {Event} event\n       */\n    }, {\n      key: 'selectAll',\n      value: function selectAll(event) {\n        this._handleEvent(event);\n        this.setSelectedRangeWithAffinity({\n          start: 0,\n          length: this.text().length\n        }, Affinity.NONE);\n      }\n\n      /**\n       * Gets the object value. This is the value that should be considered the\n       * 'real' value of the field.\n       *\n       * @returns {String}\n       */\n    }, {\n      key: 'text',\n      value: function text() {\n        return this._value;\n      }\n\n      /**\n       * Sets the object value of the field.\n       *\n       * @param {string} value\n       */\n    }, {\n      key: 'setText',\n      value: function setText(value) {\n        this._value = '' + value;\n        this.setSelectedRange({\n          start: this._value.length,\n          length: 0\n        });\n      }\n\n      /**\n       * Gets the range of the current selection.\n       *\n       * @returns {Object} {start: number, length: number}\n       */\n    }, {\n      key: 'selectedRange',\n      value: function selectedRange() {\n        return this._selectedRange;\n      }\n\n      /**\n       * Sets the range of the current selection without changing the affinity.\n       * @param {Object} range ({start: 0, length: 0})\n       */\n    }, {\n      key: 'setSelectedRange',\n      value: function setSelectedRange(range) {\n        this.setSelectedRangeWithAffinity(range, this.selectionAffinity);\n      }\n\n      /**\n       * Sets the range of the current selection and the selection affinity.\n       *\n       * @param {Object} range {start: number, length: number}\n       * @param {Affinity} affinity\n       * @returns {Object} {start: 0, length: 0}\n       */\n    }, {\n      key: 'setSelectedRangeWithAffinity',\n      value: function setSelectedRangeWithAffinity(range, affinity) {\n        var min = 0;\n        var max = this.text().length;\n        var caret = {\n          start: Math.max(min, Math.min(max, range.start)),\n          end: Math.max(min, Math.min(max, range.start + range.length))\n        };\n        this._selectedRange = {\n          start: caret.start,\n          length: caret.end - caret.start\n        };\n        this.selectionAffinity = range.length === 0 ? Affinity.NONE : affinity;\n        return this._selectedRange;\n      }\n\n      /**\n       * Gets the position of the current selection's anchor point, i.e. the point\n       * that the selection extends from, if any.\n       *\n       * @returns {number}\n       */\n    }, {\n      key: 'selectionAnchor',\n      value: function selectionAnchor() {\n        var range = this.selectedRange();\n        switch (this.selectionAffinity) {\n          case Affinity.UPSTREAM:\n            return range.start + range.length;\n          case Affinity.DOWNSTREAM:\n            return range.start;\n          default:\n            return Affinity.NONE;\n        }\n      }\n\n      /**\n       * Builds the key bindings for platform\n       *\n       * @TODO: Make this better\n       * @private\n       */\n    }, {\n      key: '_buildKeybindings',\n      value: function _buildKeybindings() {\n        var osx;\n\n        if (typeof navigator !== 'undefined') {\n          osx = /^Mozilla\\/[\\d\\.]+ \\(Macintosh/.test(navigator.userAgent);\n        } else if (typeof process !== 'undefined') {\n          osx = /darwin/.test(process.platform);\n        }\n        this._bindings = keyBindingsForPlatform(osx ? 'OSX' : 'Default');\n      }\n\n      /**\n       * Handles the event based on the `shouldCancelEvents` prop.\n       *\n       * @param {Event} event\n       * @private\n       */\n    }, {\n      key: '_handleEvent',\n      value: function _handleEvent(event) {\n        if (event && this.shouldCancelEvents) {\n          event.preventDefault();\n        }\n      }\n\n      /**\n       * Finds the start of the 'word' before index.\n       *\n       * @param {number} index position at which to start looking\n       * @returns {number} index in value less than or equal to the given index\n       * @private\n       */\n    }, {\n      key: '_lastWordBreakBeforeIndex',\n      value: function _lastWordBreakBeforeIndex(index) {\n        var indexes = this._leftWordBreakIndexes();\n        var result = indexes[0];\n        for (var i = 0, l = indexes.length; i < l; i++) {\n          var wordBreakIndex = indexes[i];\n          if (index > wordBreakIndex) {\n            result = wordBreakIndex;\n          } else {\n            break;\n          }\n        }\n        return result;\n      }\n\n      /**\n       * Find starts of 'words' for navigational purposes.\n       *\n       * @example\n       *     // given value of '123456789' and text of '123-45-6789'\n       *     leftWordBreakIndexes()\n       *     // => [0, 3, 5]\n       *\n       * @returns {number[]} indexes in value of word starts.\n       * @private\n       */\n    }, {\n      key: '_leftWordBreakIndexes',\n      value: function _leftWordBreakIndexes() {\n        var result = [];\n        var text = this.text();\n        for (var i = 0, l = text.length; i < l; i++) {\n          if (hasLeftWordBreakAtIndex(text, i)) {\n            result.push(i);\n          }\n        }\n        return result;\n      }\n\n      /**\n       * Finds the end of the 'word' after index.\n       *\n       * @param {number} index position in value at which to start looking.\n       * @returns {number}\n       * @private\n       */\n    }, {\n      key: '_nextWordBreakAfterIndex',\n      value: function _nextWordBreakAfterIndex(index) {\n        var indexes = this.rightWordBreakIndexes().reverse();\n        var result = indexes[0];\n        for (var i = 0, l = indexes.length; i < l; i++) {\n          var wordBreakIndex = indexes[i];\n          if (index < wordBreakIndex) {\n            result = wordBreakIndex;\n          } else {\n            break;\n          }\n        }\n        return result;\n      }\n    }]);\n\n    return Input;\n  })();\n\n  exports.Input = Input;\n  exports.KEYS = KEYS;\n  exports.keyBindingsForPlatform = keyBindingsForPlatform;\n});\n\n\n}).call(this,_dereq_('_process'))\n},{\"_process\":1}],3:[function(_dereq_,module,exports){\n(function (global, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define('stround', ['exports'], factory);\n  } else if (typeof exports !== 'undefined') {\n    factory(exports);\n  } else {\n    var mod = {\n      exports: {}\n    };\n    factory(mod.exports);\n    global.stround = mod.exports;\n  }\n})(this, function (exports) {\n  /* jshint sub:true, esnext:true, undef:true, unused:true */\n\n  /**\n   * Enum for the available rounding modes.\n   *\n   * @enum {number}\n   */\n  'use strict';\n\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n\n  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();\n\n  exports.parse = parse;\n  exports.format = format;\n  exports.shiftParts = shiftParts;\n  exports.shift = shift;\n  exports.round = round;\n  var modes = {\n    CEILING: 0,\n    FLOOR: 1,\n    DOWN: 2,\n    UP: 3,\n    HALF_EVEN: 4,\n    HALF_DOWN: 5,\n    HALF_UP: 6\n  };\n\n  exports.modes = modes;\n  /**\n   * @const\n   * @private\n   */\n  var NEG = '-';\n\n  /**\n   * @const\n   * @private\n   */\n  var SEP = '.';\n\n  /**\n   * @const\n   * @private\n   */\n  var NEG_PATTERN = '-';\n\n  /**\n   * @const\n   * @private\n   */\n  var SEP_PATTERN = '\\\\.';\n\n  /**\n   * @const\n   * @private\n   */\n  var NUMBER_PATTERN = new RegExp('^(' + NEG_PATTERN + ')?(\\\\d*)(?:' + SEP_PATTERN + '(\\\\d*))?$');\n\n  /**\n   * Increments the given integer represented by a string by one.\n   *\n   * @example\n   *\n   *   increment('1');  // '2'\n   *   increment('99'); // '100'\n   *   increment('');   // '1'\n   *\n   * @param {string} strint\n   * @return {string}\n   * @private\n   */\n  function increment(strint) {\n    var length = strint.length;\n\n    if (length === 0) {\n      return '1';\n    }\n\n    var last = parseInt(strint[length - 1], 10);\n\n    if (last === 9) {\n      return increment(strint.slice(0, length - 1)) + '0';\n    } else {\n      return strint.slice(0, length - 1) + (last + 1);\n    }\n  }\n\n  /**\n   * Parses the given decimal string into its component parts.\n   *\n   * @example\n   *\n   *   stround.parse('3.14');  // [false, '3', '14']\n   *   stround.parse('-3.45'); // [true, '3', '45']\n   *\n   * @param {string} strnum\n   * @return {?Array}\n   */\n\n  function parse(strnum) {\n    switch (strnum) {\n      case 'NaN':case 'Infinity':case '-Infinity':\n        return null;\n    }\n\n    var match = strnum.match(NUMBER_PATTERN);\n\n    if (!match) {\n      throw new Error('cannot round malformed number: ' + strnum);\n    }\n\n    return [match[1] !== undefined, match[2], match[3] || ''];\n  }\n\n  /**\n   * Format the given number configuration as a number string.\n   *\n   * @example\n   *\n   *   stround.format([false, '12', '34']); // '12.34'\n   *   stround.format([true, '8', '']);     // '-8'\n   *   stround.format([true, '', '7']);     // '-0.7'\n   *\n   * @param {Array} parts\n   * @return {string}\n   */\n\n  function format(_ref) {\n    var _ref2 = _slicedToArray(_ref, 3);\n\n    var negative = _ref2[0];\n    var intPart = _ref2[1];\n    var fracPart = _ref2[2];\n\n    if (intPart.length === 0) {\n      intPart = '0';\n    } else {\n      var firstNonZeroIndex = undefined;\n      for (firstNonZeroIndex = 0; firstNonZeroIndex < intPart.length; firstNonZeroIndex++) {\n        if (intPart[firstNonZeroIndex] !== '0') {\n          break;\n        }\n      }\n\n      if (firstNonZeroIndex !== intPart.length) {\n        intPart = intPart.slice(firstNonZeroIndex);\n      }\n    }\n\n    return (negative ? NEG + intPart : intPart) + (fracPart.length ? SEP + fracPart : '');\n  }\n\n  /**\n   * Shift the exponent of the given number (in parts) by the given amount.\n   *\n   * @example\n   *\n   *   stround.shiftParts([false, '12', ''], 2);  // [false, '1200', '']\n   *   stround.shiftParts([false, '12', ''], -2); // [false, '', '12']\n   *\n   * @param {Array} parts\n   * @param {number} exponent\n   * @return {Array}\n   */\n\n  function shiftParts(_ref3, exponent) {\n    var _ref32 = _slicedToArray(_ref3, 3);\n\n    var negative = _ref32[0];\n    var intPart = _ref32[1];\n    var fracPart = _ref32[2];\n\n    var partToMove = undefined;\n\n    if (exponent > 0) {\n      partToMove = fracPart.slice(0, exponent);\n      while (partToMove.length < exponent) {\n        partToMove += '0';\n      }\n      intPart += partToMove;\n      fracPart = fracPart.slice(exponent);\n    } else if (exponent < 0) {\n      while (intPart.length < -exponent) {\n        intPart = '0' + intPart;\n      }\n      partToMove = intPart.slice(intPart.length + exponent);\n      fracPart = partToMove + fracPart;\n      intPart = intPart.slice(0, intPart.length - partToMove.length);\n    }\n\n    return [negative, intPart, fracPart];\n  }\n\n  /**\n   * Shift the exponent of the given number (as a string) by the given amount.\n   *\n   *   shift('12', 2);  // '1200'\n   *   shift('12', -2); // '0.12'\n   *\n   * @param {string|number} strnum\n   * @param {number} exponent\n   * @return {string}\n   */\n\n  function shift(strnum, exponent) {\n    if (typeof strnum === 'number') {\n      strnum = '' + strnum;\n    }\n\n    var parsed = parse(strnum);\n    if (parsed === null) {\n      return strnum;\n    } else {\n      return format(shiftParts(parsed, exponent));\n    }\n  }\n\n  /**\n   * Round the given number represented by a string according to the given\n   * precision and mode.\n   *\n   * @param {string|number} strnum\n   * @param {number|null|undefined=} precision\n   * @param {modes=} mode\n   * @return {string}\n   */\n\n  function round(strnum, precision, mode) {\n    if (typeof strnum === 'number') {\n      strnum = '' + strnum;\n    }\n\n    if (typeof strnum !== 'string') {\n      throw new Error('expected a string or number, got: ' + strnum);\n    }\n\n    if (strnum.length === 0) {\n      return strnum;\n    }\n\n    if (precision === null || precision === undefined) {\n      precision = 0;\n    }\n\n    if (mode === undefined) {\n      mode = modes.HALF_EVEN;\n    }\n\n    var parsed = parse(strnum);\n\n    if (parsed === null) {\n      return strnum;\n    }\n\n    if (precision > 0) {\n      parsed = shiftParts(parsed, precision);\n    }\n\n    var _parsed = parsed;\n\n    var _parsed2 = _slicedToArray(_parsed, 3);\n\n    var negative = _parsed2[0];\n    var intPart = _parsed2[1];\n    var fracPart = _parsed2[2];\n\n    switch (mode) {\n      case modes.CEILING:case modes.FLOOR:case modes.UP:\n        var foundNonZeroDigit = false;\n        for (var i = 0, _length = fracPart.length; i < _length; i++) {\n          if (fracPart[i] !== '0') {\n            foundNonZeroDigit = true;\n            break;\n          }\n        }\n        if (foundNonZeroDigit) {\n          if (mode === modes.UP || negative !== (mode === modes.CEILING)) {\n            intPart = increment(intPart);\n          }\n        }\n        break;\n\n      case modes.HALF_EVEN:case modes.HALF_DOWN:case modes.HALF_UP:\n        var shouldRoundUp = false;\n        var firstFracPartDigit = parseInt(fracPart[0], 10);\n\n        if (firstFracPartDigit > 5) {\n          shouldRoundUp = true;\n        } else if (firstFracPartDigit === 5) {\n          if (mode === modes.HALF_UP) {\n            shouldRoundUp = true;\n          }\n\n          if (!shouldRoundUp) {\n            for (var i = 1, _length2 = fracPart.length; i < _length2; i++) {\n              if (fracPart[i] !== '0') {\n                shouldRoundUp = true;\n                break;\n              }\n            }\n          }\n\n          if (!shouldRoundUp && mode === modes.HALF_EVEN) {\n            var lastIntPartDigit = parseInt(intPart[intPart.length - 1], 10);\n            shouldRoundUp = lastIntPartDigit % 2 !== 0;\n          }\n        }\n\n        if (shouldRoundUp) {\n          intPart = increment(intPart);\n        }\n        break;\n    }\n\n    return format(shiftParts([negative, intPart, ''], -precision));\n  }\n});\n\n},{}],4:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar _amex_card_formatter = _dereq_('./amex_card_formatter');\n\nvar _amex_card_formatter2 = _interopRequireDefault(_amex_card_formatter);\n\nvar _default_card_formatter = _dereq_('./default_card_formatter');\n\nvar _default_card_formatter2 = _interopRequireDefault(_default_card_formatter);\n\nvar _card_utils = _dereq_('./card_utils');\n\n/**\n * AdaptiveCardFormatter will decide if it needs to use\n * {@link AmexCardFormatter} or {@link DefaultCardFormatter}.\n */\n\nvar AdaptiveCardFormatter = (function () {\n  function AdaptiveCardFormatter() {\n    _classCallCheck(this, AdaptiveCardFormatter);\n\n    /** @private */\n    this.amexCardFormatter = new _amex_card_formatter2['default']();\n    /** @private */\n    this.defaultCardFormatter = new _default_card_formatter2['default']();\n    /** @private */\n    this.formatter = this.defaultCardFormatter;\n  }\n\n  /**\n   * Will pick the right formatter based on the `pan` and will return the\n   * formatted string.\n   *\n   * @param {string} pan\n   * @returns {string} formatted string\n   */\n\n  _createClass(AdaptiveCardFormatter, [{\n    key: 'format',\n    value: function format(pan) {\n      return this._formatterForPan(pan).format(pan);\n    }\n\n    /**\n     * Will call parse on the formatter.\n     *\n     * @param {string} text\n     * @param {function(string)} error\n     * @returns {string} returns value with delimiters removed\n     */\n  }, {\n    key: 'parse',\n    value: function parse(text, error) {\n      return this.formatter.parse(text, error);\n    }\n\n    /**\n     * Determines whether the given change should be allowed and, if so, whether\n     * it should be altered.\n     *\n     * @param {TextFieldStateChange} change\n     * @param {function(!string)} error\n     * @returns {boolean}\n     */\n  }, {\n    key: 'isChangeValid',\n    value: function isChangeValid(change, error) {\n      this.formatter = this._formatterForPan(change.proposed.text);\n      return this.formatter.isChangeValid(change, error);\n    }\n\n    /**\n     * Decides which formatter to use.\n     *\n     * @param {string} pan\n     * @returns {Formatter}\n     * @private\n     */\n  }, {\n    key: '_formatterForPan',\n    value: function _formatterForPan(pan) {\n      if ((0, _card_utils.determineCardType)(pan.replace(/[^\\d]+/g, '')) === _card_utils.AMEX) {\n        return this.amexCardFormatter;\n      } else {\n        return this.defaultCardFormatter;\n      }\n    }\n  }]);\n\n  return AdaptiveCardFormatter;\n})();\n\nexports['default'] = AdaptiveCardFormatter;\nmodule.exports = exports['default'];\n\n},{\"./amex_card_formatter\":5,\"./card_utils\":7,\"./default_card_formatter\":9}],5:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _default_card_formatter = _dereq_('./default_card_formatter');\n\nvar _default_card_formatter2 = _interopRequireDefault(_default_card_formatter);\n\n/**\n * Amex credit card formatter.\n *\n * @extends DefaultCardFormatter\n */\n\nvar AmexCardFormatter = (function (_DefaultCardFormatter) {\n  _inherits(AmexCardFormatter, _DefaultCardFormatter);\n\n  function AmexCardFormatter() {\n    _classCallCheck(this, AmexCardFormatter);\n\n    _get(Object.getPrototypeOf(AmexCardFormatter.prototype), 'constructor', this).apply(this, arguments);\n  }\n\n  _createClass(AmexCardFormatter, [{\n    key: 'hasDelimiterAtIndex',\n\n    /**\n     * @override\n     */\n    value: function hasDelimiterAtIndex(index) {\n      return index === 4 || index === 11;\n    }\n\n    /**\n     * @override\n     */\n  }, {\n    key: 'maximumLength',\n    get: function get() {\n      return 15 + 2;\n    }\n  }]);\n\n  return AmexCardFormatter;\n})(_default_card_formatter2['default']);\n\nexports['default'] = AmexCardFormatter;\nmodule.exports = exports['default'];\n\n},{\"./default_card_formatter\":9}],6:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _text_field = _dereq_('./text_field');\n\nvar _text_field2 = _interopRequireDefault(_text_field);\n\nvar _adaptive_card_formatter = _dereq_('./adaptive_card_formatter');\n\nvar _adaptive_card_formatter2 = _interopRequireDefault(_adaptive_card_formatter);\n\nvar _card_utils = _dereq_('./card_utils');\n\n/**\n * Enum for card mask strategies.\n *\n * @readonly\n * @enum {number}\n * @private\n */\nvar CardMaskStrategy = {\n  None: 'None',\n  DoneEditing: 'DoneEditing'\n};\n\n/**\n * CardTextField add some functionality for credit card inputs\n *\n * @extends TextField\n */\n\nvar CardTextField = (function (_TextField) {\n  _inherits(CardTextField, _TextField);\n\n  /**\n   * @param {HTMLElement} element\n   */\n\n  function CardTextField(element) {\n    _classCallCheck(this, CardTextField);\n\n    _get(Object.getPrototypeOf(CardTextField.prototype), 'constructor', this).call(this, element, new _adaptive_card_formatter2['default']());\n    this.setCardMaskStrategy(CardMaskStrategy.None);\n\n    /**\n     * Whether we are currently masking the displayed text.\n     *\n     * @private\n     */\n    this._masked = false;\n\n    /**\n     * Whether we are currently editing.\n     *\n     * @private\n     */\n    this._editing = false;\n  }\n\n  /**\n   * Gets the card type for the current value.\n   *\n   * @returns {string} Returns one of 'visa', 'mastercard', 'amex' and 'discover'.\n   */\n\n  _createClass(CardTextField, [{\n    key: 'cardType',\n    value: function cardType() {\n      return (0, _card_utils.determineCardType)(this.value());\n    }\n\n    /**\n     * Gets the type of masking this field uses.\n     *\n     * @returns {CardMaskStrategy}\n     */\n  }, {\n    key: 'cardMaskStrategy',\n    value: function cardMaskStrategy() {\n      return this._cardMaskStrategy;\n    }\n\n    /**\n     * Sets the type of masking this field uses.\n     *\n     * @param {CardMaskStrategy} cardMaskStrategy One of CardMaskStrategy.\n     */\n  }, {\n    key: 'setCardMaskStrategy',\n    value: function setCardMaskStrategy(cardMaskStrategy) {\n      if (cardMaskStrategy !== this._cardMaskStrategy) {\n        this._cardMaskStrategy = cardMaskStrategy;\n        this._syncMask();\n      }\n    }\n\n    /**\n     * Returns a masked version of the current formatted PAN. Example:\n     *\n     * @example\n     *     field.setText('4111 1111 1111 1111');\n     *     field.cardMask(); // \"•••• •••• •••• 1111\"\n     *\n     * @returns {string} Returns a masked card string.\n     */\n  }, {\n    key: 'cardMask',\n    value: function cardMask() {\n      var text = this.text();\n      var last4 = text.slice(-4);\n      var toMask = text.slice(0, -4);\n\n      return toMask.replace(/\\d/g, '•') + last4;\n    }\n\n    /**\n     * Gets the formatted PAN for this field.\n     *\n     * @returns {string}\n     */\n  }, {\n    key: 'text',\n    value: function text() {\n      if (this._masked) {\n        return this._unmaskedText;\n      } else {\n        return _get(Object.getPrototypeOf(CardTextField.prototype), 'text', this).call(this);\n      }\n    }\n\n    /**\n     * Sets the formatted PAN for this field.\n     *\n     * @param {string} text A formatted PAN.\n     */\n  }, {\n    key: 'setText',\n    value: function setText(text) {\n      if (this._masked) {\n        this._unmaskedText = text;\n        text = this.cardMask();\n      }\n      _get(Object.getPrototypeOf(CardTextField.prototype), 'setText', this).call(this, text);\n    }\n\n    /**\n     * Called by our superclass, used to implement card masking.\n     *\n     * @private\n     */\n  }, {\n    key: 'textFieldDidEndEditing',\n    value: function textFieldDidEndEditing() {\n      this._editing = false;\n      this._syncMask();\n    }\n\n    /**\n     * Called by our superclass, used to implement card masking.\n     *\n     * @private\n     */\n  }, {\n    key: 'textFieldDidBeginEditing',\n    value: function textFieldDidBeginEditing() {\n      this._editing = true;\n      this._syncMask();\n    }\n\n    /**\n     * Enables masking if it is not already enabled.\n     *\n     * @private\n     */\n  }, {\n    key: '_enableMasking',\n    value: function _enableMasking() {\n      if (!this._masked) {\n        this._unmaskedText = this.text();\n        this._masked = true;\n        this.setText(this._unmaskedText);\n      }\n    }\n\n    /**\n     * Disables masking if it is currently enabled.\n     *\n     * @private\n     */\n  }, {\n    key: '_disableMasking',\n    value: function _disableMasking() {\n      if (this._masked) {\n        this._masked = false;\n        this.setText(this._unmaskedText);\n        this._unmaskedText = null;\n      }\n    }\n\n    /**\n     * Enables or disables masking based on the mask settings.\n     *\n     * @private\n     */\n  }, {\n    key: '_syncMask',\n    value: function _syncMask() {\n      if (this.cardMaskStrategy() === CardMaskStrategy.DoneEditing) {\n        if (this._editing) {\n          this._disableMasking();\n        } else {\n          this._enableMasking();\n        }\n      }\n    }\n\n    /**\n     * Enum for card mask strategies.\n     *\n     * @readonly\n     * @enum {number}\n     */\n  }], [{\n    key: 'CardMaskStrategy',\n    get: function get() {\n      return CardMaskStrategy;\n    }\n  }]);\n\n  return CardTextField;\n})(_text_field2['default']);\n\nexports['default'] = CardTextField;\nmodule.exports = exports['default'];\n\n},{\"./adaptive_card_formatter\":4,\"./card_utils\":7,\"./text_field\":20}],7:[function(_dereq_,module,exports){\n/**\n * @TODO Make this an enum\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.determineCardType = determineCardType;\nexports.luhnCheck = luhnCheck;\nexports.validCardLength = validCardLength;\nvar AMEX = 'amex';\nexports.AMEX = AMEX;\nvar DISCOVER = 'discover';\nexports.DISCOVER = DISCOVER;\nvar JCB = 'jcb';\nexports.JCB = JCB;\nvar MASTERCARD = 'mastercard';\nexports.MASTERCARD = MASTERCARD;\nvar VISA = 'visa';\n\nexports.VISA = VISA;\n/**\n * Pass in a credit card number and it'll return the\n * type of card it is.\n *\n * @param {string} pan\n * @returns {?string} returns the type of card based in the digits\n */\n\nfunction determineCardType(pan) {\n  if (pan === null || pan === undefined) {\n    return null;\n  }\n\n  pan = pan.toString();\n  var firsttwo = parseInt(pan.slice(0, 2), 10);\n  var iin = parseInt(pan.slice(0, 6), 10);\n  var halfiin = parseInt(pan.slice(0, 3), 10);\n\n  if (pan[0] === '4') {\n    return VISA;\n  } else if (pan.slice(0, 4) === '6011' || firsttwo === 65 || halfiin >= 664 && halfiin <= 649 || iin >= 622126 && iin <= 622925) {\n    return DISCOVER;\n  } else if (pan.slice(0, 4) === '2131' || pan.slice(0, 4) === '1800' || firsttwo === 35) {\n    return JCB;\n  } else if (firsttwo >= 51 && firsttwo <= 55) {\n    return MASTERCARD;\n  } else if (firsttwo === 34 || firsttwo === 37) {\n    return AMEX;\n  }\n}\n\n/**\n * Pass in a credit card number and it'll return if it\n * passes the [luhn algorithm](http://en.wikipedia.org/wiki/Luhn_algorithm)\n *\n * @param {string} pan\n * @returns {boolean}\n */\n\nfunction luhnCheck(pan) {\n  var sum = 0;\n  var flip = true;\n  for (var i = pan.length - 1; i >= 0; i--) {\n    var digit = parseInt(pan.charAt(i), 10);\n    sum += (flip = !flip) ? Math.floor(digit * 2 / 10) + Math.floor(digit * 2 % 10) : digit;\n  }\n\n  return sum % 10 === 0;\n}\n\n/**\n * Pass in a credit card number and it'll return if it\n * is a valid length for that type. If it doesn't know the\n * type it'll return false\n *\n * @param {string} pan\n * @returns {boolean}\n */\n\nfunction validCardLength(pan) {\n  switch (determineCardType(pan)) {\n    case VISA:\n      return pan.length === 13 || pan.length === 16;\n    case DISCOVER:case MASTERCARD:\n      return pan.length === 16;\n    case JCB:\n      return pan.length === 15 || pan.length === 16;\n    case AMEX:\n      return pan.length === 15;\n    default:\n      return false;\n  }\n}\n\n},{}],8:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports['default'] = installCaret;\n\nfunction installCaret() {\n  var _document = arguments.length <= 0 || arguments[0] === undefined ? document : arguments[0];\n\n  var getCaret = undefined;\n  var setCaret = undefined;\n\n  if (!_document) {\n    throw new Error('Caret does not have access to document');\n  } else if ('selectionStart' in _document.createElement('input')) {\n    getCaret = function (element) {\n      return {\n        start: element.selectionStart,\n        end: element.selectionEnd\n      };\n    };\n    setCaret = function (element, start, end) {\n      element.selectionStart = start;\n      element.selectionEnd = end;\n    };\n  } else if (_document.selection) {\n    getCaret = function (element) {\n      var selection = _document.selection;\n      var value = element.value;\n      var range = selection.createRange().duplicate();\n\n      range.moveEnd('character', value.length);\n\n      var start = range.text === '' ? value.length : value.lastIndexOf(range.text);\n      range = selection.createRange().duplicate();\n\n      range.moveStart('character', -value.length);\n\n      var end = range.text.length;\n      return { start: start, end: end };\n    };\n    setCaret = function (element, start, end) {\n      var range = element.createTextRange();\n      range.collapse(true);\n      range.moveStart('character', start);\n      range.moveEnd('character', end - start);\n      range.select();\n    };\n  } else {\n    throw new Error('Caret unknown input selection capabilities');\n  }\n\n  return { getCaret: getCaret, setCaret: setCaret };\n}\n\n;\nmodule.exports = exports['default'];\n\n},{}],9:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _delimited_text_formatter = _dereq_('./delimited_text_formatter');\n\nvar _delimited_text_formatter2 = _interopRequireDefault(_delimited_text_formatter);\n\nvar _card_utils = _dereq_('./card_utils');\n\n/**\n * A generic credit card formatter.\n *\n * @extends DelimitedTextFormatter\n */\n\nvar DefaultCardFormatter = (function (_DelimitedTextFormatter) {\n  _inherits(DefaultCardFormatter, _DelimitedTextFormatter);\n\n  function DefaultCardFormatter() {\n    _classCallCheck(this, DefaultCardFormatter);\n\n    _get(Object.getPrototypeOf(DefaultCardFormatter.prototype), 'constructor', this).call(this, ' ');\n  }\n\n  /**\n   * @param {number} index\n   * @returns {boolean}\n   */\n\n  _createClass(DefaultCardFormatter, [{\n    key: 'hasDelimiterAtIndex',\n    value: function hasDelimiterAtIndex(index) {\n      return index === 4 || index === 9 || index === 14;\n    }\n\n    /**\n     * Will call parse on the formatter.\n     *\n     * @param {string} text\n     * @param {function(string)} error\n     * @returns {string} returns value with delimiters removed\n     */\n  }, {\n    key: 'parse',\n    value: function parse(text, error) {\n      var value = this._valueFromText(text);\n      if (typeof error === 'function') {\n        if (!(0, _card_utils.validCardLength)(value)) {\n          error('card-formatter.number-too-short');\n        }\n        if (!(0, _card_utils.luhnCheck)(value)) {\n          error('card-formatter.invalid-number');\n        }\n      }\n      return _get(Object.getPrototypeOf(DefaultCardFormatter.prototype), 'parse', this).call(this, text, error);\n    }\n\n    /**\n     * Parses the given text by removing delimiters.\n     *\n     * @param {?string} text\n     * @returns {string}\n     * @private\n     */\n  }, {\n    key: '_valueFromText',\n    value: function _valueFromText(text) {\n      return _get(Object.getPrototypeOf(DefaultCardFormatter.prototype), '_valueFromText', this).call(this, (text || '').replace(/[^\\d]/g, ''));\n    }\n\n    /**\n     * Gets the maximum length of a formatted default card number.\n     *\n     * @returns {number}\n     */\n  }, {\n    key: 'maximumLength',\n    get: function get() {\n      return 16 + 3;\n    }\n  }]);\n\n  return DefaultCardFormatter;\n})(_delimited_text_formatter2['default']);\n\nexports['default'] = DefaultCardFormatter;\nmodule.exports = exports['default'];\n\n},{\"./card_utils\":7,\"./delimited_text_formatter\":10}],10:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _formatter = _dereq_('./formatter');\n\nvar _formatter2 = _interopRequireDefault(_formatter);\n\n/**\n * A generic delimited formatter.\n *\n * @extends Formatter\n */\n\nvar DelimitedTextFormatter = (function (_Formatter) {\n  _inherits(DelimitedTextFormatter, _Formatter);\n\n  /**\n   * @param {string=} delimiter\n   * @param {boolean=} isLazy\n   * @throws {Error} delimiter must have just one character\n   */\n\n  function DelimitedTextFormatter(delimiter) {\n    var isLazy = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];\n\n    _classCallCheck(this, DelimitedTextFormatter);\n\n    _get(Object.getPrototypeOf(DelimitedTextFormatter.prototype), 'constructor', this).call(this);\n\n    if (arguments.length === 0) {\n      return;\n    }\n\n    if (delimiter === null || delimiter === undefined || delimiter.length !== 1) {\n      throw new Error('delimiter must have just one character');\n    }\n    this.delimiter = delimiter;\n\n    // If the formatter is lazy, delimiter will not be added until input has gone\n    // past the delimiter index. Useful for 'optional' extension, like zip codes.\n    // 94103  ->  type '1'  ->  94103-1\n    this.isLazy = isLazy;\n  }\n\n  /**\n   * Determines the delimiter character at the given index.\n   *\n   * @param {number} index\n   * @returns {?string}\n   */\n\n  _createClass(DelimitedTextFormatter, [{\n    key: 'delimiterAt',\n    value: function delimiterAt(index) {\n      if (!this.hasDelimiterAtIndex(index)) {\n        return null;\n      }\n      return this.delimiter;\n    }\n\n    /**\n     * Determines whether the given character is a delimiter.\n     *\n     * @param {string} chr\n     * @returns {boolean}\n     */\n  }, {\n    key: 'isDelimiter',\n    value: function isDelimiter(chr) {\n      return chr === this.delimiter;\n    }\n\n    /**\n     * Formats the given value by adding delimiters where needed.\n     *\n     * @param {?string} value\n     * @returns {string}\n     */\n  }, {\n    key: 'format',\n    value: function format(value) {\n      return this._textFromValue(value);\n    }\n\n    /**\n     * Formats the given value by adding delimiters where needed.\n     *\n     * @param {?string} value\n     * @returns {string}\n     * @private\n     */\n  }, {\n    key: '_textFromValue',\n    value: function _textFromValue(value) {\n      if (!value) {\n        return '';\n      }\n\n      var result = '';\n      var delimiter = undefined;\n      var maximumLength = this.maximumLength;\n\n      for (var i = 0, l = value.length; i < l; i++) {\n        while (delimiter = this.delimiterAt(result.length)) {\n          result += delimiter;\n        }\n        result += value[i];\n        if (!this.isLazy) {\n          while (delimiter = this.delimiterAt(result.length)) {\n            result += delimiter;\n          }\n        }\n      }\n\n      if (maximumLength !== undefined && maximumLength !== null) {\n        return result.slice(0, maximumLength);\n      } else {\n        return result;\n      }\n    }\n\n    /**\n     * Parses the given text by removing delimiters.\n     *\n     * @param {?string} text\n     * @returns {string}\n     */\n  }, {\n    key: 'parse',\n    value: function parse(text) {\n      return this._valueFromText(text);\n    }\n\n    /**\n     * Parses the given text by removing delimiters.\n     *\n     * @param {?string} text\n     * @returns {string}\n     * @private\n     */\n  }, {\n    key: '_valueFromText',\n    value: function _valueFromText(text) {\n      if (!text) {\n        return '';\n      }\n      var result = '';\n      for (var i = 0, l = text.length; i < l; i++) {\n        if (!this.isDelimiter(text[i])) {\n          result += text[i];\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Determines whether the given change should be allowed and, if so, whether\n     * it should be altered.\n     *\n     * @param {TextFieldStateChange} change\n     * @param {function(string)} error\n     * @returns {boolean}\n     */\n  }, {\n    key: 'isChangeValid',\n    value: function isChangeValid(change, error) {\n      if (!_get(Object.getPrototypeOf(DelimitedTextFormatter.prototype), 'isChangeValid', this).call(this, change, error)) {\n        return false;\n      }\n\n      var newText = change.proposed.text;\n      var range = change.proposed.selectedRange;\n      var hasSelection = range.length !== 0;\n\n      var startMovedLeft = range.start < change.current.selectedRange.start;\n      var startMovedRight = range.start > change.current.selectedRange.start;\n      var endMovedLeft = range.start + range.length < change.current.selectedRange.start + change.current.selectedRange.length;\n      var endMovedRight = range.start + range.length > change.current.selectedRange.start + change.current.selectedRange.length;\n\n      var startMovedOverADelimiter = startMovedLeft && this.hasDelimiterAtIndex(range.start) || startMovedRight && this.hasDelimiterAtIndex(range.start - 1);\n      var endMovedOverADelimiter = endMovedLeft && this.hasDelimiterAtIndex(range.start + range.length) || endMovedRight && this.hasDelimiterAtIndex(range.start + range.length - 1);\n\n      if (this.isDelimiter(change.deleted.text)) {\n        var newCursorPosition = change.deleted.start - 1;\n        // delete any immediately preceding delimiters\n        while (this.isDelimiter(newText.charAt(newCursorPosition))) {\n          newText = newText.substring(0, newCursorPosition) + newText.substring(newCursorPosition + 1);\n          newCursorPosition--;\n        }\n        // finally delete the real character that was intended\n        newText = newText.substring(0, newCursorPosition) + newText.substring(newCursorPosition + 1);\n      }\n\n      // adjust the cursor / selection\n      if (startMovedLeft && startMovedOverADelimiter) {\n        // move left over any immediately preceding delimiters\n        while (this.delimiterAt(range.start - 1)) {\n          range.start--;\n          range.length++;\n        }\n        // finally move left over the real intended character\n        range.start--;\n        range.length++;\n      }\n\n      if (startMovedRight) {\n        // move right over any delimiters found on the way, including any leading delimiters\n        for (var i = change.current.selectedRange.start; i < range.start + range.length; i++) {\n          if (this.delimiterAt(i)) {\n            range.start++;\n            if (range.length > 0) {\n              range.length--;\n            }\n          }\n        }\n\n        while (this.delimiterAt(range.start)) {\n          range.start++;\n          range.length--;\n        }\n      }\n\n      if (hasSelection) {\n        // Otherwise, the logic for the range start takes care of everything.\n        if (endMovedOverADelimiter) {\n          if (endMovedLeft) {\n            // move left over any immediately preceding delimiters\n            while (this.delimiterAt(range.start + range.length - 1)) {\n              range.length--;\n            }\n            // finally move left over the real intended character\n            range.length--;\n          }\n\n          if (endMovedRight) {\n            // move right over any immediately following delimiters\n            while (this.delimiterAt(range.start + range.length)) {\n              range.length++;\n            }\n            // finally move right over the real intended character\n            range.length++;\n          }\n        }\n\n        // trailing delimiters in the selection\n        while (this.hasDelimiterAtIndex(range.start + range.length - 1)) {\n          if (startMovedLeft || endMovedLeft) {\n            range.length--;\n          } else {\n            range.length++;\n          }\n        }\n\n        while (this.hasDelimiterAtIndex(range.start)) {\n          if (startMovedRight || endMovedRight) {\n            range.start++;\n            range.length--;\n          } else {\n            range.start--;\n            range.length++;\n          }\n        }\n      } else {\n        range.length = 0;\n      }\n\n      var result = true;\n\n      var value = this._valueFromText(newText, function () {\n        result = false;\n        error.apply(undefined, arguments);\n      });\n\n      if (result) {\n        change.proposed.text = this._textFromValue(value);\n      }\n\n      return result;\n    }\n  }]);\n\n  return DelimitedTextFormatter;\n})(_formatter2['default']);\n\nexports['default'] = DelimitedTextFormatter;\nmodule.exports = exports['default'];\n\n},{\"./formatter\":14}],11:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _delimited_text_formatter = _dereq_('./delimited_text_formatter');\n\nvar _delimited_text_formatter2 = _interopRequireDefault(_delimited_text_formatter);\n\n/**\n * @const\n * @private\n */\nvar DIGITS_PATTERN = /^\\d*$/;\n\n/**\n * @extends DelimitedTextFormatter\n */\n\nvar EmployerIdentificationNumberFormatter = (function (_DelimitedTextFormatter) {\n  _inherits(EmployerIdentificationNumberFormatter, _DelimitedTextFormatter);\n\n  function EmployerIdentificationNumberFormatter() {\n    _classCallCheck(this, EmployerIdentificationNumberFormatter);\n\n    _get(Object.getPrototypeOf(EmployerIdentificationNumberFormatter.prototype), 'constructor', this).call(this, '-');\n    this.maximumLength = 9 + 1;\n  }\n\n  /**\n   * @param {number} index\n   * @returns {boolean}\n   */\n\n  _createClass(EmployerIdentificationNumberFormatter, [{\n    key: 'hasDelimiterAtIndex',\n    value: function hasDelimiterAtIndex(index) {\n      return index === 2;\n    }\n\n    /**\n     * Determines whether the given change should be allowed and, if so, whether\n     * it should be altered.\n     *\n     * @param {TextFieldStateChange} change\n     * @param {function(string)} error\n     * @returns {boolean}\n     */\n  }, {\n    key: 'isChangeValid',\n    value: function isChangeValid(change, error) {\n      if (DIGITS_PATTERN.test(change.inserted.text)) {\n        return _get(Object.getPrototypeOf(EmployerIdentificationNumberFormatter.prototype), 'isChangeValid', this).call(this, change, error);\n      } else {\n        return false;\n      }\n    }\n  }]);\n\n  return EmployerIdentificationNumberFormatter;\n})(_delimited_text_formatter2['default']);\n\nexports['default'] = EmployerIdentificationNumberFormatter;\nmodule.exports = exports['default'];\n\n},{\"./delimited_text_formatter\":10}],12:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _text_field = _dereq_('./text_field');\n\nvar _text_field2 = _interopRequireDefault(_text_field);\n\nvar _expiry_date_formatter = _dereq_('./expiry_date_formatter');\n\nvar _expiry_date_formatter2 = _interopRequireDefault(_expiry_date_formatter);\n\n/**\n * Adds a default formatter for expiration dates.\n *\n * @extends TextField\n */\n\nvar ExpiryDateField = (function (_TextField) {\n  _inherits(ExpiryDateField, _TextField);\n\n  /**\n   * @param {HTMLElement} element\n   */\n\n  function ExpiryDateField(element) {\n    _classCallCheck(this, ExpiryDateField);\n\n    _get(Object.getPrototypeOf(ExpiryDateField.prototype), 'constructor', this).call(this, element, new _expiry_date_formatter2['default']());\n  }\n\n  /**\n   * Called by our superclass, used to post-process the text.\n   *\n   * @private\n   */\n\n  _createClass(ExpiryDateField, [{\n    key: 'textFieldDidEndEditing',\n    value: function textFieldDidEndEditing() {\n      var value = this.value();\n      if (value) {\n        this.setText(this.formatter().format(value));\n      }\n    }\n  }]);\n\n  return ExpiryDateField;\n})(_text_field2['default']);\n\nexports['default'] = ExpiryDateField;\nmodule.exports = exports['default'];\n\n},{\"./expiry_date_formatter\":13,\"./text_field\":20}],13:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _delimited_text_formatter = _dereq_('./delimited_text_formatter');\n\nvar _delimited_text_formatter2 = _interopRequireDefault(_delimited_text_formatter);\n\nvar _utils = _dereq_('./utils');\n\n/**\n * Give this function a 2 digit year it'll return with 4.\n *\n * @example\n *     interpretTwoDigitYear(15);\n *     // => 2015\n *     interpretTwoDigitYear(97);\n *     // => 1997\n * @param {number} year\n * @returns {number}\n * @private\n */\nfunction interpretTwoDigitYear(year) {\n  var thisYear = new Date().getFullYear();\n  var thisCentury = thisYear - thisYear % 100;\n  var centuries = [thisCentury, thisCentury - 100, thisCentury + 100].sort(function (a, b) {\n    return Math.abs(thisYear - (year + a)) - Math.abs(thisYear - (year + b));\n  });\n  return year + centuries[0];\n}\n\n/**\n * @extends DelimitedTextFormatter\n */\n\nvar ExpiryDateFormatter = (function (_DelimitedTextFormatter) {\n  _inherits(ExpiryDateFormatter, _DelimitedTextFormatter);\n\n  function ExpiryDateFormatter() {\n    _classCallCheck(this, ExpiryDateFormatter);\n\n    _get(Object.getPrototypeOf(ExpiryDateFormatter.prototype), 'constructor', this).call(this, '/');\n    this.maximumLength = 5;\n  }\n\n  /**\n   * @param {number} index\n   * @returns {boolean}\n   */\n\n  _createClass(ExpiryDateFormatter, [{\n    key: 'hasDelimiterAtIndex',\n    value: function hasDelimiterAtIndex(index) {\n      return index === 2;\n    }\n\n    /**\n     * Formats the given value by adding delimiters where needed.\n     *\n     * @param {?string} value\n     * @returns {string}\n     */\n  }, {\n    key: 'format',\n    value: function format(value) {\n      if (!value) {\n        return '';\n      }\n\n      var month = value.month;\n      var year = value.year;\n\n      year = year % 100;\n\n      return _get(Object.getPrototypeOf(ExpiryDateFormatter.prototype), 'format', this).call(this, (0, _utils.zpad2)(month) + (0, _utils.zpad2)(year));\n    }\n\n    /**\n     * Parses the given text\n     *\n     * @param {string} text\n     * @param {Function(string)} error\n     * @returns {?Object} { month: month, year: year }\n     */\n  }, {\n    key: 'parse',\n    value: function parse(text, error) {\n      var monthAndYear = text.split(this.delimiter);\n      var month = monthAndYear[0];\n      var year = monthAndYear[1];\n      if (month && month.match(/^(0?[1-9]|1\\d)$/) && year && year.match(/^\\d\\d?$/)) {\n        month = Number(month);\n        year = interpretTwoDigitYear(Number(year));\n        return { month: month, year: year };\n      } else {\n        if (typeof error === 'function') {\n          error('expiry-date-formatter.invalid-date');\n        }\n        return null;\n      }\n    }\n\n    /**\n     * Determines whether the given change should be allowed and, if so, whether\n     * it should be altered.\n     *\n     * @param {TextFieldStateChange} change\n     * @param {function(string)} error\n     * @returns {boolean}\n     */\n  }, {\n    key: 'isChangeValid',\n    value: function isChangeValid(change, error) {\n      if (!error) {\n        error = function () {};\n      }\n\n      var isBackspace = change.proposed.text.length < change.current.text.length;\n      var newText = change.proposed.text;\n\n      if (change.inserted.text === this.delimiter && change.current.text === '1') {\n        newText = '01' + this.delimiter;\n      } else if (change.inserted.text.length > 0 && !/^\\d$/.test(change.inserted.text)) {\n        error('expiry-date-formatter.only-digits-allowed');\n        return false;\n      } else {\n        if (isBackspace) {\n          if (change.deleted.text === this.delimiter) {\n            newText = newText[0];\n          }\n          if (newText === '0') {\n            newText = '';\n          }\n          if (change.inserted.text.length > 0 && !/^\\d$/.test(change.inserted.text)) {\n            error('expiry-date-formatter.only-digits-allowed');\n            return false;\n          }\n        }\n\n        // 4| -> 04|\n        if (/^[2-9]$/.test(newText)) {\n          newText = '0' + newText;\n        }\n\n        // 1|1|/5 -> 11|/5\n        if (/^1[3-9].+$/.test(newText)) {\n          error('expiry-date-formatter.invalid-month');\n          return false;\n        }\n\n        // 15| -> 01/5|\n        if (/^1[3-9]$/.test(newText)) {\n          newText = '01' + this.delimiter + newText.slice(-1);\n        }\n\n        // Don't allow 00\n        if (newText === '00') {\n          error('expiry-date-formatter.invalid-month');\n          return false;\n        }\n\n        // 11| -> 11/\n        if (/^(0[1-9]|1[0-2])$/.test(newText)) {\n          newText += this.delimiter;\n        }\n\n        var match = newText.match(/^(\\d\\d)(.)(\\d\\d?).*$/);\n        if (match && match[2] === this.delimiter) {\n          newText = match[1] + this.delimiter + match[3];\n        }\n      }\n\n      change.proposed.text = newText;\n      change.proposed.selectedRange = { start: newText.length, length: 0 };\n\n      return true;\n    }\n  }]);\n\n  return ExpiryDateFormatter;\n})(_delimited_text_formatter2['default']);\n\nexports['default'] = ExpiryDateFormatter;\nmodule.exports = exports['default'];\n\n},{\"./delimited_text_formatter\":10,\"./utils\":22}],14:[function(_dereq_,module,exports){\n/**\n * Base class providing basic formatting, parsing, and change validation to be\n * customized in subclasses.\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar Formatter = (function () {\n  function Formatter() {\n    _classCallCheck(this, Formatter);\n  }\n\n  _createClass(Formatter, [{\n    key: 'format',\n\n    /**\n     * @param {string} text\n     * @returns {string}\n     */\n    value: function format(text) {\n      if (text === undefined || text === null) {\n        text = '';\n      }\n      if (this.maximumLength !== undefined && this.maximumLength !== null) {\n        text = text.substring(0, this.maximumLength);\n      }\n      return text;\n    }\n\n    /**\n     * @param {string} text\n     * @returns {string}\n     */\n  }, {\n    key: 'parse',\n    value: function parse(text) {\n      if (text === undefined || text === null) {\n        text = '';\n      }\n      if (this.maximumLength !== undefined && this.maximumLength !== null) {\n        text = text.substring(0, this.maximumLength);\n      }\n      return text;\n    }\n\n    /**\n     * Determines whether the given change should be allowed and, if so, whether\n     * it should be altered.\n     *\n     * @param {TextFieldStateChange} change\n     * @returns {boolean}\n     */\n  }, {\n    key: 'isChangeValid',\n    value: function isChangeValid(change) {\n      var selectedRange = change.proposed.selectedRange;\n      var text = change.proposed.text;\n      if (this.maximumLength !== undefined && this.maximumLength !== null && text.length > this.maximumLength) {\n        var available = this.maximumLength - (text.length - change.inserted.text.length);\n        var newText = change.current.text.substring(0, change.current.selectedRange.start);\n        if (available > 0) {\n          newText += change.inserted.text.substring(0, available);\n        }\n        newText += change.current.text.substring(change.current.selectedRange.start + change.current.selectedRange.length);\n        var truncatedLength = text.length - newText.length;\n        change.proposed.text = newText;\n        selectedRange.start -= truncatedLength;\n      }\n      return true;\n    }\n  }]);\n\n  return Formatter;\n})();\n\nexports['default'] = Formatter;\nmodule.exports = exports['default'];\n\n},{}],15:[function(_dereq_,module,exports){\n'use strict';\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _adaptive_card_formatter = _dereq_('./adaptive_card_formatter');\n\nvar _adaptive_card_formatter2 = _interopRequireDefault(_adaptive_card_formatter);\n\nvar _amex_card_formatter = _dereq_('./amex_card_formatter');\n\nvar _amex_card_formatter2 = _interopRequireDefault(_amex_card_formatter);\n\nvar _card_text_field = _dereq_('./card_text_field');\n\nvar _card_text_field2 = _interopRequireDefault(_card_text_field);\n\nvar _card_utils = _dereq_('./card_utils');\n\nvar _default_card_formatter = _dereq_('./default_card_formatter');\n\nvar _default_card_formatter2 = _interopRequireDefault(_default_card_formatter);\n\nvar _delimited_text_formatter = _dereq_('./delimited_text_formatter');\n\nvar _delimited_text_formatter2 = _interopRequireDefault(_delimited_text_formatter);\n\nvar _employer_identification_number_formatter = _dereq_('./employer_identification_number_formatter');\n\nvar _employer_identification_number_formatter2 = _interopRequireDefault(_employer_identification_number_formatter);\n\nvar _expiry_date_field = _dereq_('./expiry_date_field');\n\nvar _expiry_date_field2 = _interopRequireDefault(_expiry_date_field);\n\nvar _expiry_date_formatter = _dereq_('./expiry_date_formatter');\n\nvar _expiry_date_formatter2 = _interopRequireDefault(_expiry_date_formatter);\n\nvar _formatter = _dereq_('./formatter');\n\nvar _formatter2 = _interopRequireDefault(_formatter);\n\nvar _number_formatter = _dereq_('./number_formatter');\n\nvar _number_formatter2 = _interopRequireDefault(_number_formatter);\n\nvar _number_formatter_settings_formatter = _dereq_('./number_formatter_settings_formatter');\n\nvar _number_formatter_settings_formatter2 = _interopRequireDefault(_number_formatter_settings_formatter);\n\nvar _phone_formatter = _dereq_('./phone_formatter');\n\nvar _phone_formatter2 = _interopRequireDefault(_phone_formatter);\n\nvar _social_security_number_formatter = _dereq_('./social_security_number_formatter');\n\nvar _social_security_number_formatter2 = _interopRequireDefault(_social_security_number_formatter);\n\nvar _text_field = _dereq_('./text_field');\n\nvar _text_field2 = _interopRequireDefault(_text_field);\n\nvar _undo_manager = _dereq_('./undo_manager');\n\nvar _undo_manager2 = _interopRequireDefault(_undo_manager);\n\n/**\n * @namespace FieldKit\n * @readonly\n */\nmodule.exports = {\n  AdaptiveCardFormatter: _adaptive_card_formatter2['default'],\n  AmexCardFormatter: _amex_card_formatter2['default'],\n  CardTextField: _card_text_field2['default'],\n  CardUtils: {\n    AMEX: _card_utils.AMEX,\n    DISCOVER: _card_utils.DISCOVER,\n    VISA: _card_utils.VISA,\n    MASTERCARD: _card_utils.MASTERCARD,\n    determineCardType: _card_utils.determineCardType,\n    luhnCheck: _card_utils.luhnCheck,\n    validCardLength: _card_utils.validCardLength\n  },\n  DefaultCardFormatter: _default_card_formatter2['default'],\n  DelimitedTextFormatter: _delimited_text_formatter2['default'],\n  EmployerIdentificationNumberFormatter: _employer_identification_number_formatter2['default'],\n  ExpiryDateField: _expiry_date_field2['default'],\n  ExpiryDateFormatter: _expiry_date_formatter2['default'],\n  Formatter: _formatter2['default'],\n  NumberFormatter: _number_formatter2['default'],\n  NumberFormatterSettingsFormatter: _number_formatter_settings_formatter2['default'],\n  PhoneFormatter: _phone_formatter2['default'],\n  SocialSecurityNumberFormatter: _social_security_number_formatter2['default'],\n  TextField: _text_field2['default'],\n  UndoManager: _undo_manager2['default']\n};\n\n},{\"./adaptive_card_formatter\":4,\"./amex_card_formatter\":5,\"./card_text_field\":6,\"./card_utils\":7,\"./default_card_formatter\":9,\"./delimited_text_formatter\":10,\"./employer_identification_number_formatter\":11,\"./expiry_date_field\":12,\"./expiry_date_formatter\":13,\"./formatter\":14,\"./number_formatter\":16,\"./number_formatter_settings_formatter\":17,\"./phone_formatter\":18,\"./social_security_number_formatter\":19,\"./text_field\":20,\"./undo_manager\":21}],16:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _formatter = _dereq_('./formatter');\n\nvar _formatter2 = _interopRequireDefault(_formatter);\n\nvar _number_formatter_settings_formatter = _dereq_('./number_formatter_settings_formatter');\n\nvar _number_formatter_settings_formatter2 = _interopRequireDefault(_number_formatter_settings_formatter);\n\nvar _utils = _dereq_('./utils');\n\nvar _stround = _dereq_('stround');\n\n// Style\nvar NONE = 0;\nvar CURRENCY = 1;\nvar PERCENT = 2;\n\nvar DEFAULT_LOCALE = 'en-US';\nvar DEFAULT_COUNTRY = 'US';\n\n/**\n * @param {string} locale\n * @returns {Object} {lang: lang, country: country}\n * @private\n */\nfunction splitLocaleComponents(locale) {\n  var match = locale.match(/^([a-z][a-z])(?:[-_]([a-z][a-z]))?$/i);\n  if (match) {\n    var lang = match[1] && match[1].toLowerCase();\n    var country = match[2] && match[2].toLowerCase();\n    return { lang: lang, country: country };\n  }\n}\n\n/**\n * This simple property getter assumes that properties will never be functions\n * and so attempts to run those functions using the given args.\n *\n * @private\n */\nfunction get(object, key) {\n  if (object) {\n    var value = object[key];\n    if (typeof value === 'function') {\n      for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        args[_key - 2] = arguments[_key];\n      }\n\n      return value.apply(undefined, args);\n    } else {\n      return value;\n    }\n  }\n}\n\n/**\n * @param {string} string\n * @param {string} currencySymbol\n * @return {string}\n * @private\n */\nfunction replaceCurrencySymbol(string, currencySymbol) {\n  return string.replace(/¤/g, currencySymbol);\n}\n\n/**\n * @param {string} string\n * @param {string} plusSign\n * @returns {string}\n * @private\n */\nfunction replacePlusSign(string, plusSign) {\n  return string.replace(/\\+/g, plusSign);\n}\n/**\n * @param {string} string\n * @param {string} minusSign\n * @returns {string}\n * @private\n */\nfunction replaceMinusSign(string, minusSign) {\n  return string.replace(/-/g, minusSign);\n}\n\n/**\n * Formats and parses numbers. There are many configuration options for how to\n * format numbers as strings, but for many users simply adjusting the\n * {@link NumberFormatter#numberStyle}, {@link NumberFormatter#locale},\n * {@link NumberFormatter#currencyCode}, and {@link NumberFormatter#countryCode}\n * values will be sufficient. NumberFormatter natively understands how to\n * format numbers, currencies, and percentages for a variety of locales.\n *\n * @example\n *\n *   // Configure a NumberFormatter to display currencies.\n *   var f = new FieldKit.NumberFormatter();\n *   f.setNumberStyle(FieldKit.NumberFormatter.Style.CURRENCY);\n *\n *   // Configure the current locale info.\n *   f.setLocale('en-US');\n *   f.setCountryCode('US');\n *   f.setCurrencyCode('USD');\n *\n *   // Showing USD in US uses abbreviated currency.\n *   f.format(6.17);  // '$6.17'\n *\n *   // Showing CAD in US uses fully-qualified currency.\n *   f.setCurrencyCode('CAD');\n *   f.format(6.17);  // 'CA$6.17'\n *\n *   // Showing CAD in CA again uses abbreviated currency.\n *   f.setLocale('en-CA');\n *   f.setCountryCode('CA');\n *   f.format(6.17);  // '$6.17'\n *\n *   // Showing CAD in CA to a French speaker uses correct formatting.\n *   f.setLocale('fr-CA');\n *   f.format(6.17);  // '6,17 $'\n *\n *   // You may customize the behavior of NumberFormatter to achieve whatever\n *   // number formatting you need using the setter methods for the various\n *   // settings, or you can use the {@link NumberFormatter#positiveFormat} and\n *   // {@link NumberFormatter#negativeFormat} shorthand templates.\n *\n *   var f = new FieldKit.NumberFormatter();\n *\n *   // Using this template string…\n *   f.setPositiveFormat('¤#0.00');\n *\n *   // …is equivalent to this:\n *   f.setPositivePrefix('¤');\n *   f.setPositiveSuffix('');\n *   f.setMinimumIntegerDigits(1);\n *   f.setMinimumFractionDigits(2);\n *   f.setMaximumFractionDigits(2);\n *\n *   // And you can determine what the template string is for however you've\n *   // configured the NumberFormatter:\n *   f.setUsesGroupingSeparator(true);\n *   f.setGroupingSize(2);\n *   f.positiveFormat(); // '¤#,#0.00'\n *\n * @extends Formatter\n */\n\nvar NumberFormatter = (function (_Formatter) {\n  _inherits(NumberFormatter, _Formatter);\n\n  function NumberFormatter() {\n    _classCallCheck(this, NumberFormatter);\n\n    _get(Object.getPrototypeOf(NumberFormatter.prototype), 'constructor', this).call(this);\n    this.setNumberStyle(NONE);\n  }\n\n  /**\n   * Defaults\n   */\n\n  /** @private */\n\n  /**\n   * Gets whether this formatter will parse float number values. This value does\n   * not apply to formatting. To prevent formatting floats, set\n   * maximumFractionDigits to 0.\n   *\n   * @returns {boolean}\n   */\n\n  _createClass(NumberFormatter, [{\n    key: 'allowsFloats',\n    value: function allowsFloats() {\n      return this._get('allowsFloats');\n    }\n\n    /**\n     * Sets whether this formatter will parse float number values.\n     *\n     * @param {boolean} allowsFloats\n     * @returns {NumberFormatter}\n     */\n  }, {\n    key: 'setAllowsFloats',\n    value: function setAllowsFloats(allowsFloats) {\n      this._allowsFloats = allowsFloats;\n      return this;\n    }\n\n    /**\n     * Gets whether this formatter should show the decimal separator.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: 'alwaysShowsDecimalSeparator',\n    value: function alwaysShowsDecimalSeparator() {\n      return this._get('alwaysShowsDecimalSeparator');\n    }\n\n    /**\n     * Sets whether this formatter will show the decimal separator.\n     *\n     * @param {boolean} alwaysShowsDecimalSeparator\n     * @returns {NumberFormatter}\n     */\n  }, {\n    key: 'setAlwaysShowsDecimalSeparator',\n    value: function setAlwaysShowsDecimalSeparator(alwaysShowsDecimalSeparator) {\n      this._alwaysShowsDecimalSeparator = alwaysShowsDecimalSeparator;\n      return this;\n    }\n\n    /**\n     * Gets the country code for formatter.\n     *\n     * @returns {string}\n     */\n  }, {\n    key: 'countryCode',\n    value: function countryCode() {\n      return this._countryCode || DEFAULT_COUNTRY;\n    }\n\n    /**\n     * Sets the country code for formatter.\n     *\n     * @param {string} countryCode\n     * @returns {NumberFormatter}\n     */\n  }, {\n    key: 'setCountryCode',\n    value: function setCountryCode(countryCode) {\n      this._countryCode = countryCode;\n      return this;\n    }\n\n    /**\n     * Gets the currency code for formatter.\n     *\n     * @returns {string}\n     */\n  }, {\n    key: 'currencyCode',\n    value: function currencyCode() {\n      return this._get('currencyCode');\n    }\n\n    /**\n     * Sets the currency code for formatter.\n     *\n     * @param {string} currencyCode\n     * @returns {NumberFormatter}\n     */\n  }, {\n    key: 'setCurrencyCode',\n    value: function setCurrencyCode(currencyCode) {\n      this._currencyCode = currencyCode;\n      return this;\n    }\n\n    /**\n     * Gets the currency symbol for formatter.\n     *\n     * @returns {string}\n     */\n  }, {\n    key: 'currencySymbol',\n    value: function currencySymbol() {\n      if (this._shouldShowNativeCurrencySymbol()) {\n        return this._get('currencySymbol');\n      } else {\n        return this._get('internationalCurrencySymbol');\n      }\n    }\n\n    /**\n     * Sets the currency symbol for formatter.\n     *\n     * @param {string} currencySymbol\n     * @returns {NumberFormatter}\n     */\n  }, {\n    key: 'setCurrencySymbol',\n    value: function setCurrencySymbol(currencySymbol) {\n      this._currencySymbol = currencySymbol;\n      return this;\n    }\n\n    /**\n     * @returns {boolean}\n     * @private\n     */\n  }, {\n    key: '_shouldShowNativeCurrencySymbol',\n    value: function _shouldShowNativeCurrencySymbol() {\n      var regionDefaultCurrencyCode = this._regionDefaults().currencyCode;\n      if (typeof regionDefaultCurrencyCode === 'function') {\n        regionDefaultCurrencyCode = regionDefaultCurrencyCode();\n      }\n      return this.currencyCode() === regionDefaultCurrencyCode;\n    }\n\n    /**\n     * Gets the decimal separator for formatter.\n     *\n     * @returns {string}\n     */\n  }, {\n    key: 'decimalSeparator',\n    value: function decimalSeparator() {\n      return this._get('decimalSeparator');\n    }\n\n    /**\n     * Sets the decimal separator for formatter.\n     *\n     * @param {string} decimalSeparator\n     * @returns {NumberFormatter}\n     */\n  }, {\n    key: 'setDecimalSeparator',\n    value: function setDecimalSeparator(decimalSeparator) {\n      this._decimalSeparator = decimalSeparator;\n      return this;\n    }\n\n    /**\n     * Gets the number of decimal places to shift numbers before formatting.\n     *\n     * @returns {string}\n     */\n  }, {\n    key: 'exponent',\n    value: function exponent() {\n      return this._get('exponent');\n    }\n\n    /**\n     * Sets the number of decimal places to shift numbers before formatting.\n     *\n     * @param exponent\n     * @returns {NumberFormatter}\n     */\n  }, {\n    key: 'setExponent',\n    value: function setExponent(exponent) {\n      this._exponent = exponent;\n      return this;\n    }\n  }, {\n    key: 'groupingSeparator',\n    value: function groupingSeparator() {\n      return this._get('groupingSeparator');\n    }\n\n    /**\n     * @param {string} groupingSeparator\n     * @returns {NumberFormatter}\n     */\n  }, {\n    key: 'setGroupingSeparator',\n    value: function setGroupingSeparator(groupingSeparator) {\n      this._groupingSeparator = groupingSeparator;\n      return this;\n    }\n\n    /**\n     * Gets the grouping size for formatter.\n     *\n     * @returns {number}\n     */\n  }, {\n    key: 'groupingSize',\n    value: function groupingSize() {\n      return this._get('groupingSize');\n    }\n\n    /**\n     * @param {number} groupingSize\n     * @returns {NumberFormatter}\n     */\n  }, {\n    key: 'setGroupingSize',\n    value: function setGroupingSize(groupingSize) {\n      this._groupingSize = groupingSize;\n      return this;\n    }\n\n    /**\n     * @returns {string}\n     */\n  }, {\n    key: 'internationalCurrencySymbol',\n    value: function internationalCurrencySymbol() {\n      return this._get('internationalCurrencySymbol');\n    }\n\n    /**\n     * @param {string} internationalCurrencySymbol\n     * @returns {NumberFormatter}\n     */\n  }, {\n    key: 'setInternationalCurrencySymbol',\n    value: function setInternationalCurrencySymbol(internationalCurrencySymbol) {\n      this._internationalCurrencySymbol = internationalCurrencySymbol;\n      return this;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n  }, {\n    key: 'isLenient',\n    value: function isLenient() {\n      return this._lenient;\n    }\n\n    /**\n     * @param {boolean} lenient\n     * @returns {NumberFormatter}\n     */\n  }, {\n    key: 'setLenient',\n    value: function setLenient(lenient) {\n      this._lenient = lenient;\n      return this;\n    }\n\n    /**\n     * Gets the locale identifier for which this formatter is currently\n     * configured to format strings. This setting controls default settings such\n     * as the grouping separator character, decimal separator character, placement\n     * of currency and percent symbols, etc.\n     *\n     * @returns {string}\n     */\n  }, {\n    key: 'locale',\n    value: function locale() {\n      return this._locale || DEFAULT_LOCALE;\n    }\n\n    /**\n     * Sets the locale identifier used for default settings values.\n     *\n     * @see {@link NumberFormatter#locale}\n     * @param {string} locale\n     * @returns {NumberFormatter}\n     */\n  }, {\n    key: 'setLocale',\n    value: function setLocale(locale) {\n      this._locale = locale;\n      return this;\n    }\n\n    /**\n     * @returns {number}\n     */\n  }, {\n    key: 'maximum',\n    value: function maximum() {\n      return this._maximum;\n    }\n\n    /**\n     * @param {number} max\n     * @returns {NumberFormatter}\n     */\n  }, {\n    key: 'setMaximum',\n    value: function setMaximum(max) {\n      this._maximum = max;\n      return this;\n    }\n\n    /**\n     * @returns {number}\n     */\n  }, {\n    key: 'minimum',\n    value: function minimum() {\n      return this._minimum;\n    }\n\n    /**\n     * @param {number} min\n     * @returns {NumberFormatter}\n     */\n  }, {\n    key: 'setMinimum',\n    value: function setMinimum(min) {\n      this._minimum = min;\n      return this;\n    }\n\n    /**\n     * @returns {number}\n     */\n  }, {\n    key: 'maximumFractionDigits',\n    value: function maximumFractionDigits() {\n      var result = this._get('maximumFractionDigits');\n      var minimumFractionDigits = this._minimumFractionDigits;\n      if (result !== null && result !== undefined && minimumFractionDigits !== null && minimumFractionDigits !== undefined && minimumFractionDigits > result) {\n        result = minimumFractionDigits;\n      }\n      return result;\n    }\n\n    /**\n     * @param {number} maximumFractionDigits\n     * @returns {NumberFormatter}\n     */\n  }, {\n    key: 'setMaximumFractionDigits',\n    value: function setMaximumFractionDigits(maximumFractionDigits) {\n      this._maximumFractionDigits = maximumFractionDigits;\n      return this;\n    }\n\n    /**\n     * @returns {number}\n     */\n  }, {\n    key: 'minimumFractionDigits',\n    value: function minimumFractionDigits() {\n      var result = this._get('minimumFractionDigits');\n      var maximumFractionDigits = this._maximumFractionDigits;\n      if (result !== null && result !== undefined && maximumFractionDigits !== null && maximumFractionDigits !== undefined && maximumFractionDigits < result) {\n        result = maximumFractionDigits;\n      }\n      return result;\n    }\n\n    /**\n     * @param {number} minimumFractionDigits\n     * @returns {NumberFormatter}\n     */\n  }, {\n    key: 'setMinimumFractionDigits',\n    value: function setMinimumFractionDigits(minimumFractionDigits) {\n      this._minimumFractionDigits = minimumFractionDigits;\n      return this;\n    }\n\n    /**\n     * @returns {number}\n     */\n  }, {\n    key: 'maximumIntegerDigits',\n    value: function maximumIntegerDigits() {\n      var result = this._get('maximumIntegerDigits');\n      var minimumIntegerDigits = this._minimumIntegerDigits;\n      if (result !== null && result !== undefined && minimumIntegerDigits !== null && minimumIntegerDigits !== undefined && minimumIntegerDigits > result) {\n        result = minimumIntegerDigits;\n      }\n      return result;\n    }\n\n    /**\n     * @param {number} maximumIntegerDigits\n     * @returns {NumberFormatter}\n     */\n  }, {\n    key: 'setMaximumIntegerDigits',\n    value: function setMaximumIntegerDigits(maximumIntegerDigits) {\n      this._maximumIntegerDigits = maximumIntegerDigits;\n      return this;\n    }\n\n    /**\n     * @returns {number}\n     */\n  }, {\n    key: 'minimumIntegerDigits',\n    value: function minimumIntegerDigits() {\n      var result = this._get('minimumIntegerDigits');\n      var maximumIntegerDigits = this._maximumIntegerDigits;\n      if (result !== null && result !== undefined && maximumIntegerDigits !== null && maximumIntegerDigits !== undefined && maximumIntegerDigits < result) {\n        result = maximumIntegerDigits;\n      }\n      return result;\n    }\n\n    /**\n     * @param {number} minimumIntegerDigits\n     * @returns {NumberFormatter}\n     */\n  }, {\n    key: 'setMinimumIntegerDigits',\n    value: function setMinimumIntegerDigits(minimumIntegerDigits) {\n      this._minimumIntegerDigits = minimumIntegerDigits;\n      return this;\n    }\n\n    /**\n     * Gets the minus sign used for negative numbers in some locales.\n     *\n     * @returns {?string}\n     */\n  }, {\n    key: 'minusSign',\n    value: function minusSign() {\n      return this._get('minusSign');\n    }\n\n    /**\n     * Sets the minus sign used for negative numbers in some locales.\n     *\n     * @param {?string} minusSign\n     * @returns {NumberFormatter}\n     */\n  }, {\n    key: 'setMinusSign',\n    value: function setMinusSign(minusSign) {\n      this._minusSign = minusSign;\n      return this;\n    }\n\n    /**\n     * Gets the negative number format string for the current settings. For\n     * example, changing `minimumFractionDigits` from 0 to 3 would change this\n     * value from \"-#\" to \"-#.000\".\n     *\n     * @return {string}\n     */\n  }, {\n    key: 'negativeFormat',\n    value: function negativeFormat() {\n      return this.numberFormatFormatter().format({\n        alwaysShowsDecimalSeparator: this.alwaysShowsDecimalSeparator(),\n        groupingSize: this.groupingSize(),\n        maximumFractionDigits: this.maximumFractionDigits(),\n        minimumFractionDigits: this.minimumFractionDigits(),\n        minimumIntegerDigits: this.minimumIntegerDigits(),\n        prefix: this._get('negativePrefix'),\n        suffix: this._get('negativeSuffix'),\n        usesGroupingSeparator: this.usesGroupingSeparator()\n      });\n    }\n\n    /**\n     * Configures this number formatter according to the given format string.\n     * For most usages you should simply use\n     * {@link NumberFormatter#setPositiveFormat} and configure the negative\n     * prefix and suffix separately.\n     *\n     * @param negativeFormat\n     */\n  }, {\n    key: 'setNegativeFormat',\n    value: function setNegativeFormat(negativeFormat) {\n      var settings = this.numberFormatFormatter().parse(negativeFormat);\n      this.setNegativePrefix(settings.prefix);\n      this.setNegativeSuffix(settings.suffix);\n      this.setGroupingSize(settings.groupingSize);\n      this.setMaximumFractionDigits(settings.maximumFractionDigits);\n      this.setMinimumFractionDigits(settings.minimumFractionDigits);\n      this.setMinimumIntegerDigits(settings.minimumIntegerDigits);\n      this.setUsesGroupingSeparator(settings.usesGroupingSeparator);\n    }\n\n    /**\n     * @returns {string}\n     */\n  }, {\n    key: 'negativeInfinitySymbol',\n    value: function negativeInfinitySymbol() {\n      return this._get('negativeInfinitySymbol');\n    }\n\n    /**\n     * @param {string} negativeInfinitySymbol\n     * @returns {NumberFormatter}\n     */\n  }, {\n    key: 'setNegativeInfinitySymbol',\n    value: function setNegativeInfinitySymbol(negativeInfinitySymbol) {\n      this._negativeInfinitySymbol = negativeInfinitySymbol;\n      return this;\n    }\n\n    /**\n     * @returns {string}\n     */\n  }, {\n    key: 'negativePrefix',\n    value: function negativePrefix() {\n      return replaceCurrencySymbol(replaceMinusSign(this._get('negativePrefix'), this._get('minusSign')), this.currencySymbol());\n    }\n\n    /**\n     * @param {string} prefix\n     * @returns {NumberFormatter}\n     */\n  }, {\n    key: 'setNegativePrefix',\n    value: function setNegativePrefix(prefix) {\n      this._negativePrefix = prefix;\n      return this;\n    }\n\n    /**\n     * @returns {string}\n     */\n  }, {\n    key: 'negativeSuffix',\n    value: function negativeSuffix() {\n      return replaceCurrencySymbol(replaceMinusSign(this._get('negativeSuffix'), this._get('minusSign')), this.currencySymbol());\n    }\n\n    /**\n     * @param {string} prefix\n     * @returns {NumberFormatter}\n     */\n  }, {\n    key: 'setNegativeSuffix',\n    value: function setNegativeSuffix(prefix) {\n      this._negativeSuffix = prefix;\n      return this;\n    }\n\n    /**\n     * @returns {string}\n     */\n  }, {\n    key: 'notANumberSymbol',\n    value: function notANumberSymbol() {\n      return this._get('notANumberSymbol');\n    }\n\n    /**\n     * @param {string} notANumberSymbol\n     * @returns {NumberFormatter}\n     */\n  }, {\n    key: 'setNotANumberSymbol',\n    value: function setNotANumberSymbol(notANumberSymbol) {\n      this._notANumberSymbol = notANumberSymbol;\n      return this;\n    }\n\n    /**\n     * @returns {string}\n     */\n  }, {\n    key: 'nullSymbol',\n    value: function nullSymbol() {\n      return this._get('nullSymbol');\n    }\n\n    /**\n     * @param {string} nullSymbol\n     * @returns {NumberFormatter}\n     */\n  }, {\n    key: 'setNullSymbol',\n    value: function setNullSymbol(nullSymbol) {\n      this._nullSymbol = nullSymbol;\n      return this;\n    }\n\n    /**\n     * @return {NumberFormatterSettingsFormatter}\n     * @private\n     */\n  }, {\n    key: 'numberFormatFormatter',\n    value: function numberFormatFormatter() {\n      if (!this._numberFormatFormatter) {\n        this._numberFormatFormatter = new _number_formatter_settings_formatter2['default']();\n      }\n      return this._numberFormatFormatter;\n    }\n\n    /**\n     * Gets the number style used to configure various default setting values.\n     *\n     * @returns {NumberFormatter.Style}\n     */\n  }, {\n    key: 'numberStyle',\n    value: function numberStyle() {\n      return this._numberStyle;\n    }\n\n    /**\n     * Sets the number style used to configure various default setting values.\n     *\n     * @param {string} numberStyle\n     * @returns {NumberFormatter}\n     */\n  }, {\n    key: 'setNumberStyle',\n    value: function setNumberStyle(numberStyle) {\n      this._numberStyle = numberStyle;\n      switch (this._numberStyle) {\n        case NONE:\n          this._styleDefaults = StyleDefaults.NONE;\n          break;\n        case PERCENT:\n          this._styleDefaults = StyleDefaults.PERCENT;\n          break;\n        case CURRENCY:\n          this._styleDefaults = StyleDefaults.CURRENCY;\n          break;\n        default:\n          this._styleDefaults = null;\n      }\n      return this;\n    }\n\n    /**\n     * @returns {string}\n     */\n  }, {\n    key: 'percentSymbol',\n    value: function percentSymbol() {\n      return this._get('percentSymbol');\n    }\n\n    /**\n     * @param {string} percentSymbol\n     * @returns {NumberFormatter}\n     */\n  }, {\n    key: 'setPercentSymbol',\n    value: function setPercentSymbol(percentSymbol) {\n      this._percentSymbol = percentSymbol;\n      return this;\n    }\n\n    /**\n     * Gets the plus sign used in positive numbers in some locales.\n     *\n     * @returns {string}\n     */\n  }, {\n    key: 'plusSign',\n    value: function plusSign() {\n      return this._get('plusSign');\n    }\n\n    /**\n     * Sets the plus sign used in positive numbers in some locales.\n     *\n     * @param {?string} plusSign\n     * @returns {NumberFormatter}\n     */\n  }, {\n    key: 'setPlusSign',\n    value: function setPlusSign(plusSign) {\n      this._plusSign = plusSign;\n      return this;\n    }\n\n    /**\n     * Gets the positive number format string for the current settings. For\n     * example, changing `minimumFractionDigits` from 0 to 3 would change this\n     * value from \"#\" to \"#.000\".\n     *\n     * @return {string}\n     */\n  }, {\n    key: 'positiveFormat',\n    value: function positiveFormat() {\n      return this.numberFormatFormatter().format({\n        alwaysShowsDecimalSeparator: this.alwaysShowsDecimalSeparator(),\n        groupingSize: this.groupingSize(),\n        maximumFractionDigits: this.maximumFractionDigits(),\n        minimumFractionDigits: this.minimumFractionDigits(),\n        minimumIntegerDigits: this.minimumIntegerDigits(),\n        prefix: this._get('positivePrefix'),\n        suffix: this._get('positiveSuffix'),\n        usesGroupingSeparator: this.usesGroupingSeparator()\n      });\n    }\n\n    /**\n     * Configures this number formatter according to the given format string.\n     *\n     * @example\n     *\n     *   // Use '0' for padding, '.' for decimal separator.\n     *   formatter.setPositiveFormat('00.000');\n     *   formatter.format(2);     // '02.000'\n     *   formatter.format(-5.03); // '-05.030'\n     *   formatter.setLocale('fr-FR');\n     *   formatter.format(2);     // '02,000'\n     *\n     *   // Use '#' for maximum fraction digits.\n     *   formatter.setPositiveFormat('#.##');\n     *   formatter.format(3.456); // '3.46'\n     *\n     *   // Use '¤' as the currency placeholder.\n     *   formatter.setPositiveFormat('¤#0.00');\n     *   formatter.format(1.23); // '$1.23'\n     *   formatter.setCurrencyCode('JPY');\n     *   formatter.format(81);   // 'JP¥81.00'\n     *   formatter.setLocale('jp-JP');\n     *   formatter.format(7);   // '¥7.00'\n     *\n     *   // Use ',' for grouping separator placement.\n     *   formatter.setPositiveFormat('#,##');\n     *   formatter.format(123); // '1,23'\n     *\n     * @param positiveFormat\n     */\n  }, {\n    key: 'setPositiveFormat',\n    value: function setPositiveFormat(positiveFormat) {\n      var settings = this.numberFormatFormatter().parse(positiveFormat);\n      this.setPositivePrefix(settings.prefix);\n      this.setPositiveSuffix(settings.suffix);\n      this.setGroupingSize(settings.groupingSize);\n      this.setMaximumFractionDigits(settings.maximumFractionDigits);\n      this.setMinimumFractionDigits(settings.minimumFractionDigits);\n      this.setMinimumIntegerDigits(settings.minimumIntegerDigits);\n      this.setUsesGroupingSeparator(settings.usesGroupingSeparator);\n    }\n\n    /**\n     * @returns {string}\n     */\n  }, {\n    key: 'positiveInfinitySymbol',\n    value: function positiveInfinitySymbol() {\n      return this._get('positiveInfinitySymbol');\n    }\n\n    /**\n     * @param {string} positiveInfinitySymbol\n     * @returns {NumberFormatter}\n     */\n  }, {\n    key: 'setPositiveInfinitySymbol',\n    value: function setPositiveInfinitySymbol(positiveInfinitySymbol) {\n      this._positiveInfinitySymbol = positiveInfinitySymbol;\n      return this;\n    }\n\n    /**\n     * @returns {string}\n     */\n  }, {\n    key: 'positivePrefix',\n    value: function positivePrefix() {\n      return replaceCurrencySymbol(replacePlusSign(this._get('positivePrefix'), this._get('plusSign')), this.currencySymbol());\n    }\n\n    /**\n     * @param {string} prefix\n     * @returns {NumberFormatter}\n     */\n  }, {\n    key: 'setPositivePrefix',\n    value: function setPositivePrefix(prefix) {\n      this._positivePrefix = prefix;\n      return this;\n    }\n\n    /**\n     * @returns {string}\n     */\n  }, {\n    key: 'positiveSuffix',\n    value: function positiveSuffix() {\n      return replaceCurrencySymbol(replacePlusSign(this._get('positiveSuffix'), this._get('plusSign')), this.currencySymbol());\n    }\n\n    /**\n     * @param {string} prefix\n     * @returns {NumberFormatter}\n     */\n  }, {\n    key: 'setPositiveSuffix',\n    value: function setPositiveSuffix(prefix) {\n      this._positiveSuffix = prefix;\n      return this;\n    }\n\n    /**\n     * @returns {Function}\n     */\n  }, {\n    key: 'roundingMode',\n    value: function roundingMode() {\n      return this._get('roundingMode');\n    }\n\n    /**\n     * @param {Function} roundingMode\n     * @returns {NumberFormatter}\n     */\n  }, {\n    key: 'setRoundingMode',\n    value: function setRoundingMode(roundingMode) {\n      this._roundingMode = roundingMode;\n      return this;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n  }, {\n    key: 'usesGroupingSeparator',\n    value: function usesGroupingSeparator() {\n      return this._get('usesGroupingSeparator');\n    }\n\n    /**\n     * @param {boolean} usesGroupingSeparator\n     * @returns {NumberFormatter}\n     */\n  }, {\n    key: 'setUsesGroupingSeparator',\n    value: function setUsesGroupingSeparator(usesGroupingSeparator) {\n      this._usesGroupingSeparator = usesGroupingSeparator;\n      return this;\n    }\n\n    /**\n     * @returns {string}\n     */\n  }, {\n    key: 'zeroSymbol',\n    value: function zeroSymbol() {\n      return this._get('zeroSymbol');\n    }\n\n    /**\n     * @param {string} zeroSymbol\n     * @returns {NumberFormatter}\n     */\n  }, {\n    key: 'setZeroSymbol',\n    value: function setZeroSymbol(zeroSymbol) {\n      this._zeroSymbol = zeroSymbol;\n      return this;\n    }\n\n    /**\n     * @param {string} attr\n     * @returns {*}\n     * @private\n     */\n  }, {\n    key: '_get',\n    value: function _get(attr) {\n      var value = this['_' + attr];\n      if (value !== null && value !== undefined) {\n        return value;\n      }\n      var styleDefaults = this._styleDefaults;\n      var localeDefaults = this._localeDefaults();\n      var regionDefaults = this._regionDefaults();\n      value = get(styleDefaults, attr, this, localeDefaults);\n      if (value !== null && value !== undefined) {\n        return value;\n      }\n      value = get(localeDefaults, attr, this, styleDefaults);\n      if (value !== null && value !== undefined) {\n        return value;\n      }\n      value = get(regionDefaults, attr, this, styleDefaults);\n      if (value !== null && value !== undefined) {\n        return value;\n      }\n      value = get(this._currencyDefaults(), attr, this, localeDefaults);\n      if (value !== null && value !== undefined) {\n        return value;\n      }\n      return null;\n    }\n\n    /**\n     * Formats the given number as a string according to the settings applied to\n     * this formatter. This may cause the number to be truncated, rounded, or\n     * otherwise differ from what you might expect.\n     *\n     * @example\n     *\n     *   // By default no fraction digits are shown.\n     *   var f = new FieldKit.NumberFormatter();\n     *   f.format(Math.PI);  // '3'\n     *\n     *   // Let's format as a currency.\n     *   f.setNumberStyle(FieldKit.NumberFormatter.Style.CURRENCY);\n     *   f.format(Math.PI);  // '$3.14'\n     *\n     *   // Or as a percentage, which illustrates usage of {@link NumberFormatter#exponent}.\n     *   f.setNumberStyle(FieldKit.NumberFormatter.Style.PERCENT);\n     *   f.format(Math.PI);  // '314%'\n     *\n     *   // For the rest of the examples we'll go back to normal.\n     *   f.setNumberStyle(FieldKit.NumberFormatter.Style.NONE);\n     *\n     *   // The default rounding mode is {@link NumberFormatter.Rounding.HALF_EVEN}.\n     *   f.setMaximumFractionDigits(4);\n     *   f.format(Math.PI);  // '3.1416'\n     *\n     *   // And we can change the rounding mode if we like.\n     *   f.setRoundingMode(FieldKit.NumberFormatter.Rounding.FLOOR);\n     *   f.format(Math.PI);  // '3.1415'\n     *\n     * @param {number} number\n     * @returns {string}\n     */\n  }, {\n    key: 'format',\n    value: function format(number) {\n      if (number === '') {\n        return '';\n      }\n\n      var zeroSymbol = this.zeroSymbol();\n      if (zeroSymbol !== undefined && zeroSymbol !== null && number === 0) {\n        return zeroSymbol;\n      }\n\n      var nullSymbol = this.nullSymbol();\n      if (nullSymbol !== undefined && nullSymbol !== null && number === null) {\n        return nullSymbol;\n      }\n\n      var notANumberSymbol = this.notANumberSymbol();\n      if (notANumberSymbol !== undefined && notANumberSymbol !== null && isNaN(number)) {\n        return notANumberSymbol;\n      }\n\n      var positiveInfinitySymbol = this.positiveInfinitySymbol();\n      if (positiveInfinitySymbol !== undefined && positiveInfinitySymbol !== null && number === Infinity) {\n        return positiveInfinitySymbol;\n      }\n\n      var negativeInfinitySymbol = this.negativeInfinitySymbol();\n      if (negativeInfinitySymbol !== undefined && negativeInfinitySymbol !== null && number === -Infinity) {\n        return negativeInfinitySymbol;\n      }\n\n      var negative = number < 0;\n\n      var parts = ('' + Math.abs(number)).split('.');\n      var integerPart = parts[0];\n      var fractionPart = parts[1] || '';\n\n      var exponent = this.exponent();\n      if (exponent !== undefined && exponent !== null) {\n        var shifted = (0, _stround.shiftParts)([negative, integerPart, fractionPart], exponent);\n        negative = shifted[0];\n        integerPart = shifted[1];\n        fractionPart = shifted[2];\n        while (integerPart[0] === '0') {\n          integerPart = integerPart.slice(1);\n        }\n      }\n\n      // round fraction part to the maximum length\n      var maximumFractionDigits = this.maximumFractionDigits();\n      if (fractionPart.length > maximumFractionDigits) {\n        var unrounded = integerPart + '.' + fractionPart;\n        var rounded = this._round(negative ? '-' + unrounded : unrounded);\n        if (rounded[0] === '-') {\n          rounded = rounded.slice(1);\n        }\n        parts = rounded.split('.');\n        integerPart = parts[0];\n        fractionPart = parts[1] || '';\n      }\n\n      // right-pad fraction zeros up to the minimum length\n      var minimumFractionDigits = this.minimumFractionDigits();\n      while (fractionPart.length < minimumFractionDigits) {\n        fractionPart += '0';\n      }\n\n      // left-pad integer zeros up to the minimum length\n      var minimumIntegerDigits = this.minimumIntegerDigits();\n      while (integerPart.length < minimumIntegerDigits) {\n        integerPart = '0' + integerPart;\n      }\n\n      // eat any unneeded trailing zeros\n      while (fractionPart.length > minimumFractionDigits && fractionPart.slice(-1) === '0') {\n        fractionPart = fractionPart.slice(0, -1);\n      }\n\n      // left-truncate any integer digits over the maximum length\n      var maximumIntegerDigits = this.maximumIntegerDigits();\n      if (maximumIntegerDigits !== undefined && maximumIntegerDigits !== null && integerPart.length > maximumIntegerDigits) {\n        integerPart = integerPart.slice(-maximumIntegerDigits);\n      }\n\n      // add the decimal separator\n      if (fractionPart.length > 0 || this.alwaysShowsDecimalSeparator()) {\n        fractionPart = this.decimalSeparator() + fractionPart;\n      }\n\n      if (this.usesGroupingSeparator()) {\n        var integerPartWithGroupingSeparators = '';\n        var copiedCharacterCount = 0;\n\n        for (var i = integerPart.length - 1; i >= 0; i--) {\n          if (copiedCharacterCount > 0 && copiedCharacterCount % this.groupingSize() === 0) {\n            integerPartWithGroupingSeparators = this.groupingSeparator() + integerPartWithGroupingSeparators;\n          }\n          integerPartWithGroupingSeparators = integerPart[i] + integerPartWithGroupingSeparators;\n          copiedCharacterCount++;\n        }\n        integerPart = integerPartWithGroupingSeparators;\n      }\n\n      var result = integerPart + fractionPart;\n\n      // surround with the appropriate prefix and suffix\n      if (negative) {\n        result = this.negativePrefix() + result + this.negativeSuffix();\n      } else {\n        result = this.positivePrefix() + result + this.positiveSuffix();\n      }\n      return result;\n    }\n\n    /**\n     * @param {number} number\n     * @returns {number}\n     * @private\n     */\n  }, {\n    key: '_round',\n    value: function _round(number) {\n      return (0, _stround.round)(number, this.maximumFractionDigits(), this.roundingMode());\n    }\n\n    /**\n     * Parses the given string according to the current formatting settings.\n     * When parsing values with a guaranteed regular format you can simply\n     * configure the formatter correctly and call this method. However, when\n     * dealing with human input it is often useful to configure\n     * {@link NumberFormatter#isLenient} to be true, allowing more leeway in what\n     * may be parsed as a valid number.\n     *\n     * @example\n     *\n     *   var f = new FieldKit.NumberFormatter();\n     *   f.parse('89'); // 89\n     *\n     * @param {string} string\n     * @param {function(string)} error\n     * @returns {?number}\n     */\n  }, {\n    key: 'parse',\n    value: function parse(string, error) {\n      var result = undefined;\n      var positivePrefix = this.positivePrefix();\n      var negativePrefix = this.negativePrefix();\n      var positiveSuffix = this.positiveSuffix();\n      var negativeSuffix = this.negativeSuffix();\n\n      if (this.isLenient()) {\n        string = string.replace(/\\s/g, '');\n        positivePrefix = (0, _utils.trim)(positivePrefix);\n        negativePrefix = (0, _utils.trim)(negativePrefix);\n        positiveSuffix = (0, _utils.trim)(positiveSuffix);\n        negativeSuffix = (0, _utils.trim)(negativeSuffix);\n      }\n\n      var zeroSymbol = undefined;\n      var nullSymbol = undefined;\n      var notANumberSymbol = undefined;\n      var positiveInfinitySymbol = undefined;\n      var negativeInfinitySymbol = undefined;\n      var innerString = undefined;\n\n      if ((zeroSymbol = this.zeroSymbol()) !== undefined && zeroSymbol !== null && string === zeroSymbol) {\n        result = 0;\n      } else if ((nullSymbol = this.nullSymbol()) !== undefined && nullSymbol !== null && string === nullSymbol) {\n        result = null;\n      } else if ((notANumberSymbol = this.notANumberSymbol()) !== undefined && notANumberSymbol !== null && string === notANumberSymbol) {\n        result = NaN;\n      } else if ((positiveInfinitySymbol = this.positiveInfinitySymbol()) !== undefined && positiveInfinitySymbol !== null && string === positiveInfinitySymbol) {\n        result = Infinity;\n      } else if ((negativeInfinitySymbol = this.negativeInfinitySymbol()) !== undefined && negativeInfinitySymbol !== null && string === negativeInfinitySymbol) {\n        result = -Infinity;\n      } else {\n        var hasNegativePrefix = (0, _utils.startsWith)(negativePrefix, string);\n        var hasNegativeSuffix = (0, _utils.endsWith)(negativeSuffix, string);\n        if (hasNegativePrefix && (this.isLenient() || hasNegativeSuffix)) {\n          innerString = string.slice(negativePrefix.length);\n          if (hasNegativeSuffix) {\n            innerString = innerString.slice(0, innerString.length - negativeSuffix.length);\n          }\n          result = this._parseAbsoluteValue(innerString, error);\n          if (result !== undefined && result !== null) {\n            result *= -1;\n          }\n        } else {\n          var hasPositivePrefix = (0, _utils.startsWith)(positivePrefix, string);\n          var hasPositiveSuffix = (0, _utils.endsWith)(positiveSuffix, string);\n          if (this.isLenient() || hasPositivePrefix && hasPositiveSuffix) {\n            innerString = string;\n            if (hasPositivePrefix) {\n              innerString = innerString.slice(positivePrefix.length);\n            }\n            if (hasPositiveSuffix) {\n              innerString = innerString.slice(0, innerString.length - positiveSuffix.length);\n            }\n            result = this._parseAbsoluteValue(innerString, error);\n          } else {\n            if (typeof error === 'function') {\n              error('number-formatter.invalid-format');\n            }\n            return null;\n          }\n        }\n      }\n\n      if (result !== undefined && result !== null) {\n        var minimum = this.minimum();\n        if (minimum !== undefined && minimum !== null && result < minimum) {\n          if (typeof error === 'function') {\n            error('number-formatter.out-of-bounds.below-minimum');\n          }\n          return null;\n        }\n\n        var maximum = this.maximum();\n        if (maximum !== undefined && maximum !== null && result > maximum) {\n          if (typeof error === 'function') {\n            error('number-formatter.out-of-bounds.above-maximum');\n          }\n          return null;\n        }\n      }\n\n      return result;\n    }\n\n    /**\n     * @param {string} string\n     * @param {function(string)} error\n     * @returns {?number} returns value with delimiters removed\n     * @private\n     */\n  }, {\n    key: '_parseAbsoluteValue',\n    value: function _parseAbsoluteValue(string, error) {\n      var number = undefined;\n      if (string.length === 0) {\n        if (typeof error === 'function') {\n          error('number-formatter.invalid-format');\n        }\n        return null;\n      }\n\n      var parts = string.split(this.decimalSeparator());\n      if (parts.length > 2) {\n        if (typeof error === 'function') {\n          error('number-formatter.invalid-format');\n        }\n        return null;\n      }\n\n      var integerPart = parts[0];\n      var fractionPart = parts[1] || '';\n\n      if (this.usesGroupingSeparator()) {\n        var groupingSize = this.groupingSize();\n        var groupParts = integerPart.split(this.groupingSeparator());\n\n        if (!this.isLenient()) {\n          if (groupParts.length > 1) {\n            // disallow 1000,000\n            if (groupParts[0].length > groupingSize) {\n              if (typeof error === 'function') {\n                error('number-formatter.invalid-format.grouping-size');\n              }\n              return null;\n            }\n\n            // disallow 1,00\n            var groupPartsTail = groupParts.slice(1);\n            for (var i = 0, l = groupPartsTail.length; i < l; i++) {\n              if (groupPartsTail[i].length !== groupingSize) {\n                if (typeof error === 'function') {\n                  error('number-formatter.invalid-format.grouping-size');\n                }\n                return null;\n              }\n            }\n          }\n        }\n\n        // remove grouping separators\n        integerPart = groupParts.join('');\n      }\n\n      if (!(0, _utils.isDigits)(integerPart) || !(0, _utils.isDigits)(fractionPart)) {\n        if (typeof error === 'function') {\n          error('number-formatter.invalid-format');\n        }\n        return null;\n      }\n\n      var exponent = this.exponent();\n      if (exponent !== undefined && exponent !== null) {\n        var shifted = (0, _stround.shiftParts)([false, integerPart, fractionPart], -exponent);\n        integerPart = shifted[1];\n        fractionPart = shifted[2];\n      }\n\n      number = Number(integerPart) + Number('.' + (fractionPart || '0'));\n\n      if (!this.allowsFloats() && number !== ~ ~number) {\n        if (typeof error === 'function') {\n          error('number-formatter.floats-not-allowed');\n        }\n        return null;\n      }\n\n      return number;\n    }\n\n    /**\n     * Gets defaults.\n     *\n     * @returns {Array}\n     * @private\n     */\n  }, {\n    key: '_currencyDefaults',\n    value: function _currencyDefaults() {\n      var result = {};\n\n      (0, _utils.forEach)(CurrencyDefaults['default'], function (value, key) {\n        result[key] = value;\n      });\n\n      (0, _utils.forEach)(CurrencyDefaults[this.currencyCode()], function (value, key) {\n        result[key] = value;\n      });\n\n      return result;\n    }\n\n    /**\n     * Gets defaults.\n     *\n     * @returns {Array}\n     * @private\n     */\n  }, {\n    key: '_regionDefaults',\n    value: function _regionDefaults() {\n      var result = {};\n\n      (0, _utils.forEach)(RegionDefaults['default'], function (value, key) {\n        result[key] = value;\n      });\n\n      (0, _utils.forEach)(RegionDefaults[this.countryCode()], function (value, key) {\n        result[key] = value;\n      });\n\n      return result;\n    }\n\n    /**\n     * Gets defaults.\n     *\n     * @returns {Array}\n     * @private\n     */\n  }, {\n    key: '_localeDefaults',\n    value: function _localeDefaults() {\n      var locale = this.locale();\n      var countryCode = this.countryCode();\n      var lang = splitLocaleComponents(locale).lang;\n      var result = {};\n\n      var defaultFallbacks = [RegionDefaults['default'], LocaleDefaults['default'], RegionDefaults[countryCode], // CA\n      LocaleDefaults[lang], // fr\n      LocaleDefaults[locale] // fr-CA\n      ];\n\n      (0, _utils.forEach)(defaultFallbacks, function (defaults) {\n        (0, _utils.forEach)(defaults, function (value, key) {\n          result[key] = value;\n        });\n      });\n\n      return result;\n    }\n  }]);\n\n  return NumberFormatter;\n})(_formatter2['default']);\n\nNumberFormatter.prototype._allowsFloats = null;\n/** @private */\nNumberFormatter.prototype._alwaysShowsDecimalSeparator = null;\n/** @private */\nNumberFormatter.prototype._countryCode = null;\n/** @private */\nNumberFormatter.prototype._currencyCode = null;\n/** @private */\nNumberFormatter.prototype._exponent = null;\n/** @private */\nNumberFormatter.prototype._groupingSeparator = null;\n/** @private */\nNumberFormatter.prototype._groupingSize = null;\n/** @private */\nNumberFormatter.prototype._lenient = false;\n/** @private */\nNumberFormatter.prototype._locale = null;\n/** @private */\nNumberFormatter.prototype._internationalCurrencySymbol = null;\n/** @private */\nNumberFormatter.prototype._maximumFractionDigits = null;\n/** @private */\nNumberFormatter.prototype._minimumFractionDigits = null;\n/** @private */\nNumberFormatter.prototype._maximumIntegerDigits = null;\n/** @private */\nNumberFormatter.prototype._minimumIntegerDigits = null;\n/** @private */\nNumberFormatter.prototype._maximum = null;\n/** @private */\nNumberFormatter.prototype._minimum = null;\n/** @private */\nNumberFormatter.prototype._notANumberSymbol = null;\n/** @private */\nNumberFormatter.prototype._nullSymbol = null;\n/** @private */\nNumberFormatter.prototype._numberStyle = null;\n/** @private */\nNumberFormatter.prototype._roundingMode = null;\n/** @private */\nNumberFormatter.prototype._usesGroupingSeparator = null;\n/** @private */\nNumberFormatter.prototype._zeroSymbol = null;\n\n/**\n * Aliases\n */\n\nNumberFormatter.prototype.stringFromNumber = NumberFormatter.prototype.format;\nNumberFormatter.prototype.numberFromString = NumberFormatter.prototype.parse;\n\nNumberFormatter.Rounding = _stround.modes;\n\n/**\n * @enum {number}\n * @readonly\n */\nNumberFormatter.Style = {\n  NONE: NONE,\n  CURRENCY: CURRENCY,\n  PERCENT: PERCENT\n};\n\n/**\n * @namespace StyleDefaults\n */\nvar StyleDefaults = {\n  NONE: {\n    usesGroupingSeparator: false,\n    minimumFractionDigits: 0,\n    maximumFractionDigits: 0,\n    minimumIntegerDigits: 0\n  },\n  PERCENT: {\n    usesGroupingSeparator: false,\n    exponent: 2,\n    minimumFractionDigits: 0,\n    maximumFractionDigits: 0,\n    minimumIntegerDigits: 1,\n    positiveSuffix: function positiveSuffix(formatter) {\n      return formatter.percentSymbol();\n    },\n    negativeSuffix: function negativeSuffix(formatter) {\n      return formatter.percentSymbol();\n    }\n  },\n  CURRENCY: {\n    positivePrefix: function positivePrefix(formatter, locale) {\n      return get(locale, 'positiveCurrencyPrefix', formatter, this);\n    },\n    positiveSuffix: function positiveSuffix(formatter, locale) {\n      return get(locale, 'positiveCurrencySuffix', formatter, this);\n    },\n    negativePrefix: function negativePrefix(formatter, locale) {\n      return get(locale, 'negativeCurrencyPrefix', formatter, this);\n    },\n    negativeSuffix: function negativeSuffix(formatter, locale) {\n      return get(locale, 'negativeCurrencySuffix', formatter, this);\n    }\n  }\n};\n\n/**\n * Contains the default values for various number formatter settings, including\n * per-locale overrides. Some of these characters will not be used as-is and\n * instead serve as placeholders:\n *\n *   \"¤\"  placeholder for `currencySymbol()`.\n *   \"-\"  placeholder for `minusSign()`.\n *   \"+\"  placeholder for `plusSign()`.\n *\n * @namespace LocaleDefaults\n */\nvar LocaleDefaults = {\n  'default': {\n    allowsFloats: true,\n    alwaysShowsDecimalSeparator: false,\n    decimalSeparator: '.',\n    groupingSeparator: ',',\n    groupingSize: 3,\n    minusSign: '-',\n    negativeInfinitySymbol: '-∞',\n    negativePrefix: '-',\n    negativeSuffix: '',\n    notANumberSymbol: 'NaN',\n    nullSymbol: '',\n    percentSymbol: '%',\n    positiveInfinitySymbol: '+∞',\n    positivePrefix: '',\n    positiveSuffix: '',\n    plusSign: '+',\n    roundingMode: NumberFormatter.Rounding.HALF_EVEN,\n    positiveCurrencyPrefix: '¤',\n    positiveCurrencySuffix: '',\n    negativeCurrencyPrefix: '(¤',\n    negativeCurrencySuffix: ')'\n  },\n  fr: {\n    decimalSeparator: ',',\n    groupingSeparator: ' ',\n    percentSymbol: ' %',\n    positiveCurrencyPrefix: '',\n    positiveCurrencySuffix: ' ¤',\n    negativeCurrencyPrefix: '(',\n    negativeCurrencySuffix: ' ¤)'\n  },\n  ja: {\n    negativeCurrencyPrefix: '-¤',\n    negativeCurrencySuffix: ''\n  },\n  'en-GB': {\n    negativeCurrencyPrefix: '-¤',\n    negativeCurrencySuffix: ''\n  }\n};\n\n/**\n * @namespace RegionDefaults\n */\nvar RegionDefaults = {\n  AE: {\n    currencyCode: 'AED'\n  },\n  AG: {\n    currencyCode: 'XCD'\n  },\n  AI: {\n    currencyCode: 'XCD'\n  },\n  AL: {\n    currencyCode: 'ALL'\n  },\n  AM: {\n    currencyCode: 'AMD'\n  },\n  AO: {\n    currencyCode: 'AOA'\n  },\n  AR: {\n    currencyCode: 'ARS'\n  },\n  AT: {\n    currencyCode: 'EUR'\n  },\n  AU: {\n    currencyCode: 'AUD'\n  },\n  AW: {\n    currencyCode: 'AWG'\n  },\n  AZ: {\n    currencyCode: 'AZN'\n  },\n  BA: {\n    currencyCode: 'BAM'\n  },\n  BB: {\n    currencyCode: 'BBD'\n  },\n  BD: {\n    currencyCode: 'BDT'\n  },\n  BE: {\n    currencyCode: 'EUR'\n  },\n  BF: {\n    currencyCode: 'XOF'\n  },\n  BG: {\n    currencyCode: 'BGN'\n  },\n  BH: {\n    currencyCode: 'BHD'\n  },\n  BJ: {\n    currencyCode: 'XOF'\n  },\n  BM: {\n    currencyCode: 'BMD'\n  },\n  BN: {\n    currencyCode: 'BND'\n  },\n  BO: {\n    currencyCode: 'BOB'\n  },\n  BR: {\n    currencyCode: 'BRL'\n  },\n  BS: {\n    currencyCode: 'BSD'\n  },\n  BT: {\n    currencyCode: 'BTN'\n  },\n  BW: {\n    currencyCode: 'BWP'\n  },\n  BY: {\n    currencyCode: 'BYR'\n  },\n  BZ: {\n    currencyCode: 'BZD'\n  },\n  CA: {\n    currencyCode: 'CAD'\n  },\n  CG: {\n    currencyCode: 'CDF'\n  },\n  CH: {\n    currencyCode: 'CHF'\n  },\n  CI: {\n    currencyCode: 'XOF'\n  },\n  CL: {\n    currencyCode: 'CLP'\n  },\n  CM: {\n    currencyCode: 'XAF'\n  },\n  CN: {\n    currencyCode: 'CNY'\n  },\n  CO: {\n    currencyCode: 'COP'\n  },\n  CR: {\n    currencyCode: 'CRC'\n  },\n  CV: {\n    currencyCode: 'CVE'\n  },\n  CY: {\n    currencyCode: 'EUR'\n  },\n  CZ: {\n    currencyCode: 'CZK'\n  },\n  DE: {\n    currencyCode: 'EUR'\n  },\n  DK: {\n    currencyCode: 'DKK'\n  },\n  DM: {\n    currencyCode: 'XCD'\n  },\n  DO: {\n    currencyCode: 'DOP'\n  },\n  DZ: {\n    currencyCode: 'DZD'\n  },\n  EC: {\n    currencyCode: 'USD'\n  },\n  EE: {\n    currencyCode: 'EUR'\n  },\n  EG: {\n    currencyCode: 'EGP'\n  },\n  ES: {\n    currencyCode: 'EUR'\n  },\n  ET: {\n    currencyCode: 'ETB'\n  },\n  FI: {\n    currencyCode: 'EUR'\n  },\n  FJ: {\n    currencyCode: 'FJD'\n  },\n  FM: {\n    currencyCode: 'USD'\n  },\n  FR: {\n    currencyCode: 'EUR'\n  },\n  GA: {\n    currencyCode: 'XAF'\n  },\n  GB: {\n    currencyCode: 'GBP'\n  },\n  GD: {\n    currencyCode: 'XCD'\n  },\n  GE: {\n    currencyCode: 'GEL'\n  },\n  GH: {\n    currencyCode: 'GHS'\n  },\n  GI: {\n    currencyCode: 'GIP'\n  },\n  GM: {\n    currencyCode: 'GMD'\n  },\n  GR: {\n    currencyCode: 'EUR'\n  },\n  GT: {\n    currencyCode: 'GTQ'\n  },\n  GU: {\n    currencyCode: 'USD'\n  },\n  GW: {\n    currencyCode: 'XOF'\n  },\n  GY: {\n    currencyCode: 'GYD'\n  },\n  HK: {\n    currencyCode: 'HKD'\n  },\n  HN: {\n    currencyCode: 'HNL'\n  },\n  HR: {\n    currencyCode: 'HRK'\n  },\n  HT: {\n    currencyCode: 'HTG'\n  },\n  HU: {\n    currencyCode: 'HUF'\n  },\n  ID: {\n    currencyCode: 'IDR'\n  },\n  IE: {\n    currencyCode: 'EUR'\n  },\n  IL: {\n    currencyCode: 'ILS'\n  },\n  IN: {\n    currencyCode: 'INR'\n  },\n  IS: {\n    currencyCode: 'ISK'\n  },\n  IT: {\n    currencyCode: 'EUR'\n  },\n  JM: {\n    currencyCode: 'JMD'\n  },\n  JO: {\n    currencyCode: 'JOD'\n  },\n  JP: {\n    currencyCode: 'JPY'\n  },\n  KE: {\n    currencyCode: 'KES'\n  },\n  KG: {\n    currencyCode: 'KGS'\n  },\n  KH: {\n    currencyCode: 'KHR'\n  },\n  KN: {\n    currencyCode: 'XCD'\n  },\n  KR: {\n    currencyCode: 'KRW'\n  },\n  KW: {\n    currencyCode: 'KWD'\n  },\n  KY: {\n    currencyCode: 'KYD'\n  },\n  KZ: {\n    currencyCode: 'KZT'\n  },\n  LA: {\n    currencyCode: 'LAK'\n  },\n  LB: {\n    currencyCode: 'LBP'\n  },\n  LC: {\n    currencyCode: 'XCD'\n  },\n  LI: {\n    currencyCode: 'CHF'\n  },\n  LK: {\n    currencyCode: 'LKR'\n  },\n  LR: {\n    currencyCode: 'LRD'\n  },\n  LT: {\n    currencyCode: 'LTL'\n  },\n  LU: {\n    currencyCode: 'EUR'\n  },\n  LV: {\n    currencyCode: 'EUR'\n  },\n  MA: {\n    currencyCode: 'MAD'\n  },\n  MD: {\n    currencyCode: 'MDL'\n  },\n  MG: {\n    currencyCode: 'MGA'\n  },\n  MK: {\n    currencyCode: 'MKD'\n  },\n  ML: {\n    currencyCode: 'XOF'\n  },\n  MM: {\n    currencyCode: 'MMK'\n  },\n  MN: {\n    currencyCode: 'MNT'\n  },\n  MO: {\n    currencyCode: 'MOP'\n  },\n  MP: {\n    currencyCode: 'USD'\n  },\n  MR: {\n    currencyCode: 'MRO'\n  },\n  MS: {\n    currencyCode: 'XCD'\n  },\n  MT: {\n    currencyCode: 'EUR'\n  },\n  MU: {\n    currencyCode: 'MUR'\n  },\n  MW: {\n    currencyCode: 'MWK'\n  },\n  MX: {\n    currencyCode: 'MXN'\n  },\n  MY: {\n    currencyCode: 'MYR'\n  },\n  MZ: {\n    currencyCode: 'MZN'\n  },\n  NA: {\n    currencyCode: 'NAD'\n  },\n  NE: {\n    currencyCode: 'XOF'\n  },\n  NG: {\n    currencyCode: 'NGN'\n  },\n  NI: {\n    currencyCode: 'NIO'\n  },\n  NL: {\n    currencyCode: 'EUR'\n  },\n  NO: {\n    currencyCode: 'NOK'\n  },\n  NP: {\n    currencyCode: 'NPR'\n  },\n  NZ: {\n    currencyCode: 'NZD'\n  },\n  OM: {\n    currencyCode: 'OMR'\n  },\n  PA: {\n    currencyCode: 'PAB'\n  },\n  PE: {\n    currencyCode: 'PEN'\n  },\n  PG: {\n    currencyCode: 'PGK'\n  },\n  PH: {\n    currencyCode: 'PHP'\n  },\n  PK: {\n    currencyCode: 'PKR'\n  },\n  PL: {\n    currencyCode: 'PLN'\n  },\n  PR: {\n    currencyCode: 'USD'\n  },\n  PT: {\n    currencyCode: 'EUR'\n  },\n  PW: {\n    currencyCode: 'USD'\n  },\n  PY: {\n    currencyCode: 'PYG'\n  },\n  QA: {\n    currencyCode: 'QAR'\n  },\n  RO: {\n    currencyCode: 'RON'\n  },\n  RS: {\n    currencyCode: 'RSD'\n  },\n  RU: {\n    currencyCode: 'RUB'\n  },\n  RW: {\n    currencyCode: 'RWF'\n  },\n  SA: {\n    currencyCode: 'SAR'\n  },\n  SB: {\n    currencyCode: 'SBD'\n  },\n  SC: {\n    currencyCode: 'SCR'\n  },\n  SE: {\n    currencyCode: 'SEK'\n  },\n  SG: {\n    currencyCode: 'SGD'\n  },\n  SI: {\n    currencyCode: 'EUR'\n  },\n  SK: {\n    currencyCode: 'EUR'\n  },\n  SL: {\n    currencyCode: 'SLL'\n  },\n  SN: {\n    currencyCode: 'XOF'\n  },\n  SR: {\n    currencyCode: 'SRD'\n  },\n  ST: {\n    currencyCode: 'STD'\n  },\n  SV: {\n    currencyCode: 'SVC'\n  },\n  SZ: {\n    currencyCode: 'SZL'\n  },\n  TC: {\n    currencyCode: 'USD'\n  },\n  TD: {\n    currencyCode: 'XAF'\n  },\n  TG: {\n    currencyCode: 'XOF'\n  },\n  TH: {\n    currencyCode: 'THB'\n  },\n  TJ: {\n    currencyCode: 'TJS'\n  },\n  TM: {\n    currencyCode: 'TMT'\n  },\n  TN: {\n    currencyCode: 'TND'\n  },\n  TR: {\n    currencyCode: 'TRY'\n  },\n  TT: {\n    currencyCode: 'TTD'\n  },\n  TW: {\n    currencyCode: 'TWD'\n  },\n  TZ: {\n    currencyCode: 'TZS'\n  },\n  UA: {\n    currencyCode: 'UAH'\n  },\n  UG: {\n    currencyCode: 'UGX'\n  },\n  US: {\n    currencyCode: 'USD'\n  },\n  UY: {\n    currencyCode: 'UYU'\n  },\n  UZ: {\n    currencyCode: 'UZS'\n  },\n  VC: {\n    currencyCode: 'XCD'\n  },\n  VE: {\n    currencyCode: 'VEF'\n  },\n  VG: {\n    currencyCode: 'USD'\n  },\n  VI: {\n    currencyCode: 'USD'\n  },\n  VN: {\n    currencyCode: 'VND'\n  },\n  YE: {\n    currencyCode: 'YER'\n  },\n  ZA: {\n    currencyCode: 'ZAR'\n  },\n  ZM: {\n    currencyCode: 'ZMW'\n  },\n  ZW: {\n    currencyCode: 'USD'\n  }\n};\n\n/**\n * @namespace CurrencyDefaults\n */\nvar CurrencyDefaults = {\n  'default': {\n    currencySymbol: function currencySymbol(formatter) {\n      return formatter.currencyCode();\n    },\n    internationalCurrencySymbol: function internationalCurrencySymbol(formatter) {\n      return formatter.currencyCode();\n    },\n    minimumFractionDigits: 2,\n    maximumFractionDigits: 2,\n    minimumIntegerDigits: 1,\n    usesGroupingSeparator: true\n  },\n  AED: {\n    currencySymbol: 'د.إ',\n    internationalCurrencySymbol: 'د.إ'\n  },\n  ALL: {\n    currencySymbol: 'L',\n    internationalCurrencySymbol: 'L'\n  },\n  AMD: {\n    currencySymbol: 'դր.',\n    internationalCurrencySymbol: 'դր.'\n  },\n  AOA: {\n    currencySymbol: 'Kz',\n    internationalCurrencySymbol: 'Kz'\n  },\n  ARS: {\n    currencySymbol: '$',\n    internationalCurrencySymbol: '$'\n  },\n  AUD: {\n    currencySymbol: '$',\n    internationalCurrencySymbol: '$'\n  },\n  AWG: {\n    currencySymbol: 'ƒ',\n    internationalCurrencySymbol: 'ƒ'\n  },\n  AZN: {\n    currencySymbol: '₼',\n    internationalCurrencySymbol: '₼'\n  },\n  BAM: {\n    currencySymbol: 'КМ',\n    internationalCurrencySymbol: 'КМ'\n  },\n  BBD: {\n    currencySymbol: '$',\n    internationalCurrencySymbol: '$'\n  },\n  BDT: {\n    currencySymbol: '৳',\n    internationalCurrencySymbol: '৳'\n  },\n  BGN: {\n    currencySymbol: 'лв',\n    internationalCurrencySymbol: 'лв'\n  },\n  BHD: {\n    currencySymbol: 'ب.د',\n    internationalCurrencySymbol: 'ب.د',\n    minimumFractionDigits: 3,\n    maximumFractionDigits: 3\n  },\n  BMD: {\n    currencySymbol: '$',\n    internationalCurrencySymbol: '$'\n  },\n  BND: {\n    currencySymbol: '$',\n    internationalCurrencySymbol: '$'\n  },\n  BOB: {\n    currencySymbol: 'Bs.',\n    internationalCurrencySymbol: 'Bs.'\n  },\n  BRL: {\n    currencySymbol: 'R$',\n    internationalCurrencySymbol: 'R$'\n  },\n  BSD: {\n    currencySymbol: '$',\n    internationalCurrencySymbol: '$'\n  },\n  BTN: {\n    currencySymbol: 'Nu.',\n    internationalCurrencySymbol: 'Nu.'\n  },\n  BWP: {\n    currencySymbol: 'P',\n    internationalCurrencySymbol: 'P'\n  },\n  BYR: {\n    currencySymbol: 'Br',\n    internationalCurrencySymbol: 'Br'\n  },\n  BZD: {\n    currencySymbol: '$',\n    internationalCurrencySymbol: '$'\n  },\n  CAD: {\n    currencySymbol: '$',\n    internationalCurrencySymbol: '$'\n  },\n  CDF: {\n    currencySymbol: 'Fr',\n    internationalCurrencySymbol: 'Fr'\n  },\n  CHF: {\n    currencySymbol: 'Fr',\n    internationalCurrencySymbol: 'Fr'\n  },\n  CLP: {\n    currencySymbol: '$',\n    internationalCurrencySymbol: '$',\n    minimumFractionDigits: 0,\n    maximumFractionDigits: 0\n  },\n  CNY: {\n    currencySymbol: '¥',\n    internationalCurrencySymbol: '¥'\n  },\n  COP: {\n    currencySymbol: '$',\n    internationalCurrencySymbol: '$'\n  },\n  CRC: {\n    currencySymbol: '₡',\n    internationalCurrencySymbol: '₡'\n  },\n  CVE: {\n    currencySymbol: '$',\n    internationalCurrencySymbol: '$'\n  },\n  CZK: {\n    currencySymbol: 'Kč',\n    internationalCurrencySymbol: 'Kč'\n  },\n  DKK: {\n    currencySymbol: 'kr',\n    internationalCurrencySymbol: 'kr'\n  },\n  DOP: {\n    currencySymbol: '$',\n    internationalCurrencySymbol: '$'\n  },\n  DZD: {\n    currencySymbol: 'د.ج',\n    internationalCurrencySymbol: 'د.ج'\n  },\n  EGP: {\n    currencySymbol: 'E£',\n    internationalCurrencySymbol: 'E£'\n  },\n  ETB: {\n    currencySymbol: 'ብር',\n    internationalCurrencySymbol: 'ብር'\n  },\n  EUR: {\n    currencySymbol: '€',\n    internationalCurrencySymbol: '€'\n  },\n  FJD: {\n    currencySymbol: '$',\n    internationalCurrencySymbol: '$'\n  },\n  GBP: {\n    currencySymbol: '£',\n    internationalCurrencySymbol: '£'\n  },\n  GEL: {\n    currencySymbol: 'ლ,',\n    internationalCurrencySymbol: 'ლ,'\n  },\n  GHS: {\n    currencySymbol: '₵',\n    internationalCurrencySymbol: '₵'\n  },\n  GIP: {\n    currencySymbol: '£',\n    internationalCurrencySymbol: '£'\n  },\n  GMD: {\n    currencySymbol: 'D',\n    internationalCurrencySymbol: 'D'\n  },\n  GTQ: {\n    currencySymbol: 'Q',\n    internationalCurrencySymbol: 'Q'\n  },\n  GYD: {\n    currencySymbol: '$',\n    internationalCurrencySymbol: '$'\n  },\n  HKD: {\n    currencySymbol: '$',\n    internationalCurrencySymbol: '$'\n  },\n  HNL: {\n    currencySymbol: 'L',\n    internationalCurrencySymbol: 'L'\n  },\n  HRK: {\n    currencySymbol: 'kn',\n    internationalCurrencySymbol: 'kn'\n  },\n  HTG: {\n    currencySymbol: 'G',\n    internationalCurrencySymbol: 'G'\n  },\n  HUF: {\n    currencySymbol: 'Ft',\n    internationalCurrencySymbol: 'Ft'\n  },\n  IDR: {\n    currencySymbol: 'Rp',\n    internationalCurrencySymbol: 'Rp'\n  },\n  ILS: {\n    currencySymbol: '₪',\n    internationalCurrencySymbol: '₪'\n  },\n  INR: {\n    currencySymbol: '₹',\n    internationalCurrencySymbol: '₹'\n  },\n  ISK: {\n    currencySymbol: 'kr',\n    internationalCurrencySymbol: 'kr'\n  },\n  JMD: {\n    currencySymbol: '$',\n    internationalCurrencySymbol: '$'\n  },\n  JOD: {\n    currencySymbol: 'د.ا',\n    internationalCurrencySymbol: 'د.ا',\n    minimumFractionDigits: 3,\n    maximumFractionDigits: 3\n  },\n  JPY: {\n    currencySymbol: '¥',\n    internationalCurrencySymbol: '¥',\n    minimumFractionDigits: 0,\n    maximumFractionDigits: 0\n  },\n  KES: {\n    currencySymbol: 'KSh',\n    internationalCurrencySymbol: 'KSh'\n  },\n  KGS: {\n    currencySymbol: 'som',\n    internationalCurrencySymbol: 'som'\n  },\n  KHR: {\n    currencySymbol: '៛',\n    internationalCurrencySymbol: '៛'\n  },\n  KRW: {\n    currencySymbol: '₩',\n    internationalCurrencySymbol: '₩',\n    minimumFractionDigits: 0,\n    maximumFractionDigits: 0\n  },\n  KWD: {\n    currencySymbol: 'د.ك',\n    internationalCurrencySymbol: 'د.ك',\n    minimumFractionDigits: 3,\n    maximumFractionDigits: 3\n  },\n  KYD: {\n    currencySymbol: '$',\n    internationalCurrencySymbol: '$'\n  },\n  KZT: {\n    currencySymbol: '〒',\n    internationalCurrencySymbol: '〒'\n  },\n  LAK: {\n    currencySymbol: '₭',\n    internationalCurrencySymbol: '₭'\n  },\n  LBP: {\n    currencySymbol: 'ل.ل',\n    internationalCurrencySymbol: 'ل.ل'\n  },\n  LKR: {\n    currencySymbol: '₨',\n    internationalCurrencySymbol: '₨'\n  },\n  LRD: {\n    currencySymbol: '$',\n    internationalCurrencySymbol: '$'\n  },\n  LTL: {\n    currencySymbol: 'Lt',\n    internationalCurrencySymbol: 'Lt'\n  },\n  MAD: {\n    currencySymbol: 'د.م.',\n    internationalCurrencySymbol: 'د.م.'\n  },\n  MDL: {\n    currencySymbol: 'L',\n    internationalCurrencySymbol: 'L'\n  },\n  MGA: {\n    currencySymbol: 'Ar',\n    internationalCurrencySymbol: 'Ar',\n    minimumFractionDigits: 0,\n    maximumFractionDigits: 0\n  },\n  MKD: {\n    currencySymbol: 'ден',\n    internationalCurrencySymbol: 'ден'\n  },\n  MMK: {\n    currencySymbol: 'K',\n    internationalCurrencySymbol: 'K'\n  },\n  MNT: {\n    currencySymbol: '₮',\n    internationalCurrencySymbol: '₮'\n  },\n  MOP: {\n    currencySymbol: 'P',\n    internationalCurrencySymbol: 'P'\n  },\n  MRO: {\n    currencySymbol: 'UM',\n    internationalCurrencySymbol: 'UM',\n    minimumFractionDigits: 0,\n    maximumFractionDigits: 0\n  },\n  MUR: {\n    currencySymbol: '₨',\n    internationalCurrencySymbol: '₨'\n  },\n  MWK: {\n    currencySymbol: 'MK',\n    internationalCurrencySymbol: 'MK'\n  },\n  MXN: {\n    currencySymbol: '$',\n    internationalCurrencySymbol: '$'\n  },\n  MYR: {\n    currencySymbol: 'RM',\n    internationalCurrencySymbol: 'RM'\n  },\n  MZN: {\n    currencySymbol: 'MTn',\n    internationalCurrencySymbol: 'MTn'\n  },\n  NAD: {\n    currencySymbol: '$',\n    internationalCurrencySymbol: '$'\n  },\n  NGN: {\n    currencySymbol: '₦',\n    internationalCurrencySymbol: '₦'\n  },\n  NIO: {\n    currencySymbol: 'C$',\n    internationalCurrencySymbol: 'C$'\n  },\n  NOK: {\n    currencySymbol: 'kr',\n    internationalCurrencySymbol: 'kr'\n  },\n  NPR: {\n    currencySymbol: '₨',\n    internationalCurrencySymbol: '₨'\n  },\n  NZD: {\n    currencySymbol: '$',\n    internationalCurrencySymbol: '$'\n  },\n  OMR: {\n    currencySymbol: 'ر.ع.',\n    internationalCurrencySymbol: 'ر.ع.',\n    minimumFractionDigits: 3,\n    maximumFractionDigits: 3\n  },\n  PAB: {\n    currencySymbol: 'B/.',\n    internationalCurrencySymbol: 'B/.'\n  },\n  PEN: {\n    currencySymbol: 'S/.',\n    internationalCurrencySymbol: 'S/.'\n  },\n  PGK: {\n    currencySymbol: 'K',\n    internationalCurrencySymbol: 'K'\n  },\n  PHP: {\n    currencySymbol: '₱',\n    internationalCurrencySymbol: '₱'\n  },\n  PKR: {\n    currencySymbol: '₨',\n    internationalCurrencySymbol: '₨'\n  },\n  PLN: {\n    currencySymbol: 'zł',\n    internationalCurrencySymbol: 'zł'\n  },\n  PYG: {\n    currencySymbol: '₲',\n    internationalCurrencySymbol: '₲'\n  },\n  QAR: {\n    currencySymbol: 'ر.ق',\n    internationalCurrencySymbol: 'ر.ق'\n  },\n  RON: {\n    currencySymbol: 'Lei',\n    internationalCurrencySymbol: 'Lei'\n  },\n  RSD: {\n    currencySymbol: 'РСД',\n    internationalCurrencySymbol: 'РСД'\n  },\n  RUB: {\n    currencySymbol: '₽',\n    internationalCurrencySymbol: '₽'\n  },\n  RWF: {\n    currencySymbol: 'FRw',\n    internationalCurrencySymbol: 'FRw'\n  },\n  SAR: {\n    currencySymbol: 'ر.س',\n    internationalCurrencySymbol: 'ر.س'\n  },\n  SBD: {\n    currencySymbol: '$',\n    internationalCurrencySymbol: '$'\n  },\n  SCR: {\n    currencySymbol: '₨',\n    internationalCurrencySymbol: '₨'\n  },\n  SEK: {\n    currencySymbol: 'kr',\n    internationalCurrencySymbol: 'kr'\n  },\n  SGD: {\n    currencySymbol: 'S$',\n    internationalCurrencySymbol: 'S$'\n  },\n  SLL: {\n    currencySymbol: 'Le',\n    internationalCurrencySymbol: 'Le'\n  },\n  SRD: {\n    currencySymbol: '$',\n    internationalCurrencySymbol: '$'\n  },\n  STD: {\n    currencySymbol: 'Db',\n    internationalCurrencySymbol: 'Db'\n  },\n  SVC: {\n    currencySymbol: '₡',\n    internationalCurrencySymbol: '₡'\n  },\n  SZL: {\n    currencySymbol: 'E',\n    internationalCurrencySymbol: 'E'\n  },\n  THB: {\n    currencySymbol: '฿',\n    internationalCurrencySymbol: '฿'\n  },\n  TJS: {\n    currencySymbol: 'ЅМ',\n    internationalCurrencySymbol: 'ЅМ'\n  },\n  TMT: {\n    currencySymbol: 'm',\n    internationalCurrencySymbol: 'm'\n  },\n  TND: {\n    currencySymbol: 'د.ت',\n    internationalCurrencySymbol: 'د.ت',\n    minimumFractionDigits: 3,\n    maximumFractionDigits: 3\n  },\n  TRY: {\n    currencySymbol: '₺',\n    internationalCurrencySymbol: '₺'\n  },\n  TTD: {\n    currencySymbol: '$',\n    internationalCurrencySymbol: '$'\n  },\n  TWD: {\n    currencySymbol: '$',\n    internationalCurrencySymbol: '$'\n  },\n  TZS: {\n    currencySymbol: 'Sh',\n    internationalCurrencySymbol: 'Sh'\n  },\n  UAH: {\n    currencySymbol: '₴',\n    internationalCurrencySymbol: '₴'\n  },\n  UGX: {\n    currencySymbol: 'USh',\n    internationalCurrencySymbol: 'USh'\n  },\n  USD: {\n    currencySymbol: '$',\n    internationalCurrencySymbol: 'US$'\n  },\n  UYU: {\n    currencySymbol: '$',\n    internationalCurrencySymbol: '$'\n  },\n  UZS: {\n    currencySymbol: 'лв',\n    internationalCurrencySymbol: 'лв'\n  },\n  VEF: {\n    currencySymbol: 'Bs F',\n    internationalCurrencySymbol: 'Bs F'\n  },\n  VND: {\n    currencySymbol: '₫',\n    internationalCurrencySymbol: '₫',\n    minimumFractionDigits: 0,\n    maximumFractionDigits: 0\n  },\n  XAF: {\n    currencySymbol: 'Fr',\n    internationalCurrencySymbol: 'Fr'\n  },\n  XCD: {\n    currencySymbol: '$',\n    internationalCurrencySymbol: '$'\n  },\n  XOF: {\n    currencySymbol: 'Fr',\n    internationalCurrencySymbol: 'Fr'\n  },\n  YER: {\n    currencySymbol: '﷼',\n    internationalCurrencySymbol: '﷼'\n  },\n  ZAR: {\n    currencySymbol: 'R',\n    internationalCurrencySymbol: 'R'\n  },\n  ZMW: {\n    currencySymbol: 'ZMK',\n    internationalCurrencySymbol: 'ZMK'\n  }\n};\n\nexports['default'] = NumberFormatter;\nmodule.exports = exports['default'];\n\n},{\"./formatter\":14,\"./number_formatter_settings_formatter\":17,\"./utils\":22,\"stround\":3}],17:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar _formatter = _dereq_('./formatter');\n\nvar _formatter2 = _interopRequireDefault(_formatter);\n\nvar NumberFormatterSettings = function NumberFormatterSettings() {\n  _classCallCheck(this, NumberFormatterSettings);\n\n  /** @type boolean */\n  this.alwaysShowsDecimalSeparator = false;\n\n  /** @type number */\n  this.groupingSize = 0;\n\n  /** @type number */\n  this.maximumFractionDigits = 0;\n\n  /** @type number */\n  this.minimumFractionDigits = 0;\n\n  /** @type number */\n  this.minimumIntegerDigits = 0;\n\n  /** @type string */\n  this.prefix = '';\n\n  /** @type string */\n  this.suffix = '';\n\n  /** @type boolean */\n  this.usesGroupingSeparator = false;\n}\n\n/**\n * Returns a string composed of the given character repeated `length` times.\n *\n * @param {string} character\n * @param {number} length\n * @returns {string}\n * @private\n */\n;\n\nfunction chars(character, length) {\n  return new Array(length + 1).join(character);\n}\n\n/**\n * @const\n * @private\n */\nvar DIGIT = '#';\n\n/**\n * @const\n * @private\n */\nvar PADDING = '0';\n\n/**\n * @const\n * @private\n */\nvar DECIMAL_SEPARATOR = '.';\n\n/**\n * @const\n * @private\n */\nvar GROUPING_SEPARATOR = ',';\n\nvar NumberFormatterSettingsFormatter = (function (_Formatter) {\n  _inherits(NumberFormatterSettingsFormatter, _Formatter);\n\n  function NumberFormatterSettingsFormatter() {\n    _classCallCheck(this, NumberFormatterSettingsFormatter);\n\n    _get(Object.getPrototypeOf(NumberFormatterSettingsFormatter.prototype), 'constructor', this).apply(this, arguments);\n  }\n\n  _createClass(NumberFormatterSettingsFormatter, [{\n    key: 'format',\n\n    /**\n     * @param {NumberFormatterSettings} settings\n     * @returns {string}\n     */\n    value: function format(settings) {\n      var result = '';\n\n      var minimumIntegerDigits = settings.minimumIntegerDigits;\n      if (minimumIntegerDigits !== 0) {\n        result += chars(PADDING, minimumIntegerDigits);\n      }\n\n      result = DIGIT + result;\n\n      if (settings.usesGroupingSeparator) {\n        while (result.length <= settings.groupingSize) {\n          result = DIGIT + result;\n        }\n\n        result = result.slice(0, -settings.groupingSize) + GROUPING_SEPARATOR + result.slice(-settings.groupingSize);\n      }\n\n      var minimumFractionDigits = settings.minimumFractionDigits;\n      var maximumFractionDigits = settings.maximumFractionDigits;\n      var hasFractionalPart = settings.alwaysShowsDecimalSeparator || minimumFractionDigits > 0 || maximumFractionDigits > 0;\n\n      if (hasFractionalPart) {\n        result += DECIMAL_SEPARATOR;\n        for (var i = 0, _length = maximumFractionDigits; i < _length; i++) {\n          result += i < minimumFractionDigits ? PADDING : DIGIT;\n        }\n      }\n\n      return settings.prefix + result + settings.suffix;\n    }\n\n    /**\n     * @param {string} string\n     * @returns {?NumberFormatterSettings}\n     */\n  }, {\n    key: 'parse',\n    value: function parse(string) {\n      var result = new NumberFormatterSettings();\n\n      var hasPassedPrefix = false;\n      var hasStartedSuffix = false;\n      var decimalSeparatorIndex = null;\n      var groupingSeparatorIndex = null;\n      var lastIntegerDigitIndex = null;\n\n      for (var i = 0, length = string.length; i < length; i++) {\n        var c = string[i];\n\n        switch (c) {\n          case DIGIT:\n            if (hasStartedSuffix) {\n              return null;\n            }\n            hasPassedPrefix = true;\n            if (decimalSeparatorIndex !== null) {\n              result.maximumFractionDigits++;\n            }\n            break;\n\n          case PADDING:\n            if (hasStartedSuffix) {\n              return null;\n            }\n            hasPassedPrefix = true;\n            if (decimalSeparatorIndex === null) {\n              result.minimumIntegerDigits++;\n            } else {\n              result.minimumFractionDigits++;\n              result.maximumFractionDigits++;\n            }\n            break;\n\n          case DECIMAL_SEPARATOR:\n            if (hasStartedSuffix) {\n              return null;\n            }\n            hasPassedPrefix = true;\n            decimalSeparatorIndex = i;\n            lastIntegerDigitIndex = i - 1;\n            break;\n\n          case GROUPING_SEPARATOR:\n            if (hasStartedSuffix) {\n              return null;\n            }\n            hasPassedPrefix = true;\n            groupingSeparatorIndex = i;\n            break;\n\n          default:\n            if (hasPassedPrefix) {\n              hasStartedSuffix = true;\n              result.suffix += c;\n            } else {\n              result.prefix += c;\n            }\n        }\n      }\n\n      if (decimalSeparatorIndex === null) {\n        lastIntegerDigitIndex = length - 1;\n      }\n\n      if (decimalSeparatorIndex === length - 1) {\n        result.alwaysShowsDecimalSeparator = true;\n      }\n\n      if (groupingSeparatorIndex !== null) {\n        result.groupingSize = lastIntegerDigitIndex - groupingSeparatorIndex;\n        result.usesGroupingSeparator = true;\n      }\n\n      return result;\n    }\n  }]);\n\n  return NumberFormatterSettingsFormatter;\n})(_formatter2['default']);\n\nexports['default'] = NumberFormatterSettingsFormatter;\nmodule.exports = exports['default'];\n\n},{\"./formatter\":14}],18:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _delimited_text_formatter = _dereq_('./delimited_text_formatter');\n\nvar _delimited_text_formatter2 = _interopRequireDefault(_delimited_text_formatter);\n\n/**\n * @const\n * @private\n */\nvar NANPPhoneDelimiters = {\n  name: 'NANPPhoneDelimiters',\n  0: '(',\n  4: ')',\n  5: ' ',\n  9: '-'\n};\n\n/**\n * @const\n * @private\n */\nvar NANPPhoneDelimitersWithOne = {\n  name: 'NANPPhoneDelimitersWithOne',\n  1: ' ',\n  2: '(',\n  6: ')',\n  7: ' ',\n  11: '-'\n};\n\n/**\n * @const\n * @private\n */\nvar E164PhoneDelimitersWithOneDigit = {\n  name: 'E164PhoneDelimitersWithOneDigit',\n  2: ' ',\n  3: '(',\n  7: ')',\n  8: ' ',\n  12: '-'\n};\n\n/**\n * @const\n * @private\n */\nvar E164PhoneDelimitersWithTwoDigit = {\n  name: 'E164PhoneDelimitersWithTwoDigit',\n  3: ' ',\n  4: '(',\n  8: ')',\n  9: ' ',\n  13: '-'\n};\n\n/**\n * @const\n * @private\n */\nvar E164PhoneDelimitersWithThreeDigit = {\n  name: 'E164PhoneDelimitersWithThreeDigit',\n  4: ' ',\n  5: '(',\n  9: ')',\n  10: ' ',\n  14: '-'\n};\n\n/**\n * This should match any characters in the maps above.\n *\n * @const\n * @private\n */\nvar DELIMITER_PATTERN = /[-\\(\\) ]/g;\n\n/**\n * @const\n * @private\n */\nvar DEFAULT_COUNTRY_CODE = {\n  \"E164\": \"1\",\n  \"country\": [\"American Samoa\", \"Anguilla\", \"Antigua and Barbuda\", \"Bahamas\", \"Barbados\", \"Bermuda\", \"British Virgin Islands\", \"Canada\", \"Cayman Islands\", \"Dominica\", \"Dominican Republic\", \"Grenada\", \"Guam\", \"Jamaica\", \"Montserrat\", \"Northern Mariana Islands\", \"Puerto Rico\", \"Saint Kitts and Nevis\", \"Saint Lucia\", \"Saint Martin\", \"Saint Vincent and the Grenadines\", \"Sint Maarten\", \"Trinidad and Tobago\", \"Turks and Caicos Islands\", \"U.S. Virgin Islands\", \"United States\"]\n};\n\n/**\n * This is an internal store for the current country\n *\n * @private\n */\nvar currentCountryCode = DEFAULT_COUNTRY_CODE;\n\n/**\n * @extends DelimitedTextFormatter\n */\n\nvar PhoneFormatter = (function (_DelimitedTextFormatter) {\n  _inherits(PhoneFormatter, _DelimitedTextFormatter);\n\n  /**\n   * @throws {Error} if anything is passed in\n   * @param {Array} args\n   */\n\n  function PhoneFormatter() {\n    _classCallCheck(this, PhoneFormatter);\n\n    _get(Object.getPrototypeOf(PhoneFormatter.prototype), 'constructor', this).call(this);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    if (args.length !== 0) {\n      throw new Error('were you trying to set a delimiter (' + args[0] + ')?');\n    }\n  }\n\n  /**\n   * @param {string} chr\n   * @returns {boolean}\n   */\n\n  _createClass(PhoneFormatter, [{\n    key: 'isDelimiter',\n    value: function isDelimiter(chr) {\n      var map = this.delimiterMap;\n      for (var index in map) {\n        if (map.hasOwnProperty(index)) {\n          if (map[index] === chr) {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n\n    /**\n     * @param {number} index\n     * @returns {?string}\n     */\n  }, {\n    key: 'delimiterAt',\n    value: function delimiterAt(index) {\n      return this.delimiterMap[index];\n    }\n\n    /**\n     * @param {number} index\n     * @returns {boolean}\n     */\n  }, {\n    key: 'hasDelimiterAtIndex',\n    value: function hasDelimiterAtIndex(index) {\n      var delimiter = this.delimiterAt(index);\n      return delimiter !== undefined && delimiter !== null;\n    }\n\n    /**\n     * Will call parse on the formatter.\n     *\n     * @param {string} text\n     * @param {function(string)} error\n     * @returns {string} returns value with delimiters removed\n     */\n  }, {\n    key: 'parse',\n    value: function parse(text, error) {\n      if (!error) {\n        error = function () {};\n      }\n      var digits = this.digitsWithoutCountryCode(text);\n      // Source: http://en.wikipedia.org/wiki/North_American_Numbering_Plan\n      //\n      // Area Code\n      if (text.length < 10) {\n        error('phone-formatter.number-too-short');\n      }\n      if (digits[0] === '0') {\n        error('phone-formatter.area-code-zero');\n      }\n      if (digits[0] === '1') {\n        error('phone-formatter.area-code-one');\n      }\n      if (digits[1] === '9') {\n        error('phone-formatter.area-code-n9n');\n      }\n      // Central Office Code\n      if (digits[3] === '1') {\n        error('phone-formatter.central-office-one');\n      }\n      if (digits.slice(4, 6) === '11') {\n        error('phone-formatter.central-office-n11');\n      }\n      return _get(Object.getPrototypeOf(PhoneFormatter.prototype), 'parse', this).call(this, text, error);\n    }\n\n    /**\n     * @param {string} value\n     * @returns {string}\n     */\n  }, {\n    key: 'format',\n    value: function format(value) {\n      this.guessFormatFromText(value);\n      return _get(Object.getPrototypeOf(PhoneFormatter.prototype), 'format', this).call(this, this.removeDelimiterMapChars(value));\n    }\n\n    /**\n     * Determines whether the given change should be allowed and, if so, whether\n     * it should be altered.\n     *\n     * @param {TextFieldStateChange} change\n     * @param {function(string)} error\n     * @returns {boolean}\n     */\n  }, {\n    key: 'isChangeValid',\n    value: function isChangeValid(change, error) {\n      this.guessFormatFromText(change.proposed.text);\n\n      if (change.inserted.text.length > 1) {\n        // handle pastes\n        var text = change.current.text;\n        var selectedRange = change.current.selectedRange;\n        var toInsert = change.inserted.text;\n\n        // Replace the selection with the new text, remove non-digits, then format.\n        var formatted = this.format((text.slice(0, selectedRange.start) + toInsert + text.slice(selectedRange.start + selectedRange.length)).replace(/[^\\d]/g, ''));\n\n        change.proposed = {\n          text: formatted,\n          selectedRange: {\n            start: formatted.length - (text.length - (selectedRange.start + selectedRange.length)),\n            length: 0\n          }\n        };\n\n        return _get(Object.getPrototypeOf(PhoneFormatter.prototype), 'isChangeValid', this).call(this, change, error);\n      }\n\n      if (/^\\d*$/.test(change.inserted.text) || change.proposed.text.indexOf('+') === 0) {\n        var formatName = this.delimiterMap.name;\n\n        // First guess at the localized format\n        if (currentCountryCode.localizedFormat) {\n          this.delimiterMap = currentCountryCode.localizedFormat;\n          this.maximumLength = currentCountryCode.localizedFormat.maximumLength;\n          formatName = 'localized-' + currentCountryCode.E164;\n        }\n\n        // We need to store the change and current format guess so that if the isChangeValid\n        // call to super changes the proposed text such that the format we thought is no longer\n        // valid. If that does happen we actually just rerun it through with the correct format\n        var originalProposed = change.proposed.text;\n        var _isChangeValid = _get(Object.getPrototypeOf(PhoneFormatter.prototype), 'isChangeValid', this).call(this, change, error);\n\n        this.guessFormatFromText(change.proposed.text);\n\n        // Make sure if the localizedFormat changed, respect that\n        if (currentCountryCode.localizedFormat) {\n          this.delimiterMap = currentCountryCode.localizedFormat;\n          this.maximumLength = currentCountryCode.localizedFormat.maximumLength;\n          this.delimiterMap.name = 'localized-' + currentCountryCode.E164;\n        }\n\n        if (formatName === this.delimiterMap.name) {\n          return _isChangeValid;\n        } else {\n          var originalChange = change;\n          originalChange.proposed.text = originalProposed;\n          return _get(Object.getPrototypeOf(PhoneFormatter.prototype), 'isChangeValid', this).call(this, originalChange, error);\n        }\n      } else {\n        return false;\n      }\n    }\n\n    /**\n     * Re-configures this formatter to use the delimiters appropriate\n     * for the given text.\n     *\n     * @param {string} text A potentially formatted string containing a phone number.\n     * @private\n     */\n  }, {\n    key: 'guessFormatFromText',\n    value: function guessFormatFromText(text) {\n      currentCountryCode = DEFAULT_COUNTRY_CODE;\n      if (text && text[0] === '+') {\n        if (text.length > 1) {\n          var isValidCountryCode = function isValidCountryCode(countryCode) {\n            var matchingCodes = COUNTRY_CODES.filter(function (country) {\n              return country.E164 === countryCode;\n            });\n\n            return matchingCodes.length > 0;\n          };\n\n          var rawText = this.removeDelimiterMapChars(text);\n          if (currentCountryCode = isValidCountryCode(rawText[1])) {\n            this.delimiterMap = E164PhoneDelimitersWithOneDigit;\n            this.maximumLength = 1 + 1 + 10 + 5;\n          } else if (text.length > 2 && (currentCountryCode = isValidCountryCode(rawText.slice(1, 3)))) {\n            this.delimiterMap = E164PhoneDelimitersWithTwoDigit;\n            this.maximumLength = 1 + 2 + 10 + 5;\n          } else {\n            currentCountryCode = isValidCountryCode(rawText.slice(1, 4)) || DEFAULT_COUNTRY_CODE;\n            this.delimiterMap = E164PhoneDelimitersWithThreeDigit;\n            this.maximumLength = 1 + 3 + 10 + 5;\n          }\n        } else {\n\n          this.delimiterMap = E164PhoneDelimitersWithThreeDigit;\n          this.maximumLength = 1 + 3 + 10 + 5;\n        }\n      } else if (text && text[0] === '1') {\n        this.delimiterMap = NANPPhoneDelimitersWithOne;\n        this.maximumLength = 1 + 10 + 5;\n      } else if (text && text[0] === ' ') {\n        this.delimiterMap = NANPPhoneDelimiters;\n        this.maximumLength = 10 + 5;\n      } else {\n        this.delimiterMap = NANPPhoneDelimiters;\n        this.maximumLength = 10 + 4;\n      }\n    }\n\n    /**\n     * Gives back just the phone number digits as a string without the\n     * country code. Future-proofing internationalization where the country code\n     * isn't just +1.\n     *\n     * @param {string} text\n     * @private\n     */\n  }, {\n    key: 'digitsWithoutCountryCode',\n    value: function digitsWithoutCountryCode(text) {\n      var digits = (text || '').replace(/[^\\d]/g, '');\n      var extraDigits = digits.length - 10;\n      if (extraDigits > 0) {\n        digits = digits.substr(extraDigits);\n      }\n      return digits;\n    }\n\n    /**\n     * Removes characters from the phone number that will be added\n     * by the formatter.\n     *\n     * @param {string} text\n     * @private\n     */\n  }, {\n    key: 'removeDelimiterMapChars',\n    value: function removeDelimiterMapChars(text) {\n      return (text || '').replace(DELIMITER_PATTERN, '');\n    }\n  }]);\n\n  return PhoneFormatter;\n})(_delimited_text_formatter2['default']);\n\nvar COUNTRY_CODES = [{\n  \"E164\": \"93\",\n  \"country\": \"Afghanistan\"\n}, {\n  \"E164\": \"355\",\n  \"country\": \"Albania\"\n}, {\n  \"E164\": \"213\",\n  \"country\": \"Algeria\"\n}, {\n  \"E164\": \"1\",\n  \"country\": [\"American Samoa\", \"Anguilla\", \"Antigua and Barbuda\", \"Bahamas\", \"Barbados\", \"Bermuda\", \"British Virgin Islands\", \"Canada\", \"Cayman Islands\", \"Dominica\", \"Dominican Republic\", \"Grenada\", \"Guam\", \"Jamaica\", \"Montserrat\", \"Northern Mariana Islands\", \"Puerto Rico\", \"Saint Kitts and Nevis\", \"Saint Lucia\", \"Saint Martin\", \"Saint Vincent and the Grenadines\", \"Sint Maarten\", \"Trinidad and Tobago\", \"Turks and Caicos Islands\", \"U.S. Virgin Islands\", \"United States\"]\n}, {\n  \"E164\": \"376\",\n  \"country\": \"Andorra\"\n}, {\n  \"E164\": \"244\",\n  \"country\": \"Angola\"\n}, {\n  \"E164\": \"672\",\n  \"country\": \"Antarctica\"\n}, {\n  \"E164\": \"54\",\n  \"country\": \"Argentina\"\n}, {\n  \"E164\": \"374\",\n  \"country\": \"Armenia\"\n}, {\n  \"E164\": \"297\",\n  \"country\": \"Aruba\"\n}, {\n  \"E164\": \"43\",\n  \"country\": \"Austria\"\n}, {\n  \"E164\": \"994\",\n  \"country\": \"Azerbaijan\"\n}, {\n  \"E164\": \"973\",\n  \"country\": \"Bahrain\"\n}, {\n  \"E164\": \"880\",\n  \"country\": \"Bangladesh\"\n}, {\n  \"E164\": \"375\",\n  \"country\": \"Belarus\"\n}, {\n  \"E164\": \"32\",\n  \"country\": \"Belgium\"\n}, {\n  \"E164\": \"501\",\n  \"country\": \"Belize\"\n}, {\n  \"E164\": \"229\",\n  \"country\": \"Benin\"\n}, {\n  \"E164\": \"975\",\n  \"country\": \"Bhutan\"\n}, {\n  \"E164\": \"591\",\n  \"country\": \"Bolivia\"\n}, {\n  \"E164\": \"387\",\n  \"country\": \"Bosnia and Herzegovina\"\n}, {\n  \"E164\": \"267\",\n  \"country\": \"Botswana\"\n}, {\n  \"E164\": \"55\",\n  \"country\": \"Brazil\"\n}, {\n  \"E164\": \"246\",\n  \"country\": \"British Indian Ocean Territory\"\n}, {\n  \"E164\": \"673\",\n  \"country\": \"Brunei\"\n}, {\n  \"E164\": \"359\",\n  \"country\": \"Bulgaria\"\n}, {\n  \"E164\": \"226\",\n  \"country\": \"Burkina Faso\"\n}, {\n  \"E164\": \"257\",\n  \"country\": \"Burundi\"\n}, {\n  \"E164\": \"855\",\n  \"country\": \"Cambodia\"\n}, {\n  \"E164\": \"237\",\n  \"country\": \"Cameroon\"\n}, {\n  \"E164\": \"238\",\n  \"country\": \"Cape Verde\"\n}, {\n  \"E164\": \"236\",\n  \"country\": \"Central African Republic\"\n}, {\n  \"E164\": \"235\",\n  \"country\": \"Chad\"\n}, {\n  \"E164\": \"56\",\n  \"country\": \"Chile\"\n}, {\n  \"E164\": \"86\",\n  \"country\": \"China\"\n}, {\n  \"E164\": \"61\",\n  \"country\": [\"Australia\", \"Christmas Island\", \"Cocos Islands\"]\n}, {\n  \"E164\": \"57\",\n  \"country\": \"Colombia\"\n}, {\n  \"E164\": \"269\",\n  \"country\": \"Comoros\"\n}, {\n  \"E164\": \"682\",\n  \"country\": \"Cook Islands\"\n}, {\n  \"E164\": \"506\",\n  \"country\": \"Costa Rica\"\n}, {\n  \"E164\": \"385\",\n  \"country\": \"Croatia\"\n}, {\n  \"E164\": \"53\",\n  \"country\": \"Cuba\"\n}, {\n  \"E164\": \"599\",\n  \"country\": [\"Curacao\", \"Netherlands Antilles\"]\n}, {\n  \"E164\": \"357\",\n  \"country\": \"Cyprus\"\n}, {\n  \"E164\": \"420\",\n  \"country\": \"Czech Republic\"\n}, {\n  \"E164\": \"243\",\n  \"country\": \"Democratic Republic of the Congo\"\n}, {\n  \"E164\": \"45\",\n  \"country\": \"Denmark\"\n}, {\n  \"E164\": \"253\",\n  \"country\": \"Djibouti\"\n}, {\n  \"E164\": \"670\",\n  \"country\": \"East Timor\"\n}, {\n  \"E164\": \"593\",\n  \"country\": \"Ecuador\"\n}, {\n  \"E164\": \"20\",\n  \"country\": \"Egypt\"\n}, {\n  \"E164\": \"503\",\n  \"country\": \"El Salvador\"\n}, {\n  \"E164\": \"240\",\n  \"country\": \"Equatorial Guinea\"\n}, {\n  \"E164\": \"291\",\n  \"country\": \"Eritrea\"\n}, {\n  \"E164\": \"372\",\n  \"country\": \"Estonia\"\n}, {\n  \"E164\": \"251\",\n  \"country\": \"Ethiopia\"\n}, {\n  \"E164\": \"500\",\n  \"country\": \"Falkland Islands\"\n}, {\n  \"E164\": \"298\",\n  \"country\": \"Faroe Islands\"\n}, {\n  \"E164\": \"679\",\n  \"country\": \"Fiji\"\n}, {\n  \"E164\": \"358\",\n  \"country\": \"Finland\"\n}, {\n  \"E164\": \"33\",\n  \"country\": \"France\"\n}, {\n  \"E164\": \"689\",\n  \"country\": \"French Polynesia\"\n}, {\n  \"E164\": \"241\",\n  \"country\": \"Gabon\"\n}, {\n  \"E164\": \"220\",\n  \"country\": \"Gambia\"\n}, {\n  \"E164\": \"995\",\n  \"country\": \"Georgia\"\n}, {\n  \"E164\": \"49\",\n  \"country\": \"Germany\"\n}, {\n  \"E164\": \"233\",\n  \"country\": \"Ghana\"\n}, {\n  \"E164\": \"350\",\n  \"country\": \"Gibraltar\"\n}, {\n  \"E164\": \"30\",\n  \"country\": \"Greece\"\n}, {\n  \"E164\": \"299\",\n  \"country\": \"Greenland\"\n}, {\n  \"E164\": \"502\",\n  \"country\": \"Guatemala\"\n}, {\n  \"E164\": \"44\",\n  \"country\": [\"Guernsey\", \"Isle of Man\", \"Jersey\", \"United Kingdom\"]\n}, {\n  \"E164\": \"224\",\n  \"country\": \"Guinea\"\n}, {\n  \"E164\": \"245\",\n  \"country\": \"Guinea-Bissau\"\n}, {\n  \"E164\": \"592\",\n  \"country\": \"Guyana\"\n}, {\n  \"E164\": \"509\",\n  \"country\": \"Haiti\"\n}, {\n  \"E164\": \"504\",\n  \"country\": \"Honduras\"\n}, {\n  \"E164\": \"852\",\n  \"country\": \"Hong Kong\"\n}, {\n  \"E164\": \"36\",\n  \"country\": \"Hungary\"\n}, {\n  \"E164\": \"354\",\n  \"country\": \"Iceland\"\n}, {\n  \"E164\": \"91\",\n  \"country\": \"India\"\n}, {\n  \"E164\": \"62\",\n  \"country\": \"Indonesia\"\n}, {\n  \"E164\": \"98\",\n  \"country\": \"Iran\"\n}, {\n  \"E164\": \"964\",\n  \"country\": \"Iraq\"\n}, {\n  \"E164\": \"353\",\n  \"country\": \"Ireland\"\n}, {\n  \"E164\": \"972\",\n  \"country\": \"Israel\"\n}, {\n  \"E164\": \"39\",\n  \"country\": [\"Italy\", \"Vatican\"]\n}, {\n  \"E164\": \"225\",\n  \"country\": \"Ivory Coast\"\n}, {\n  \"E164\": \"81\",\n  \"country\": \"Japan\"\n}, {\n  \"E164\": \"962\",\n  \"country\": \"Jordan\"\n}, {\n  \"E164\": \"7\",\n  \"country\": [\"Kazakhstan\", \"Russia\"],\n  \"localizedFormat\": {\n    \"maximumLength\": 1 + 1 + 10 + 6,\n    2: ' ',\n    3: '(',\n    7: ')',\n    8: ' ',\n    12: '-',\n    15: '-'\n  }\n}, {\n  \"E164\": \"254\",\n  \"country\": \"Kenya\"\n}, {\n  \"E164\": \"686\",\n  \"country\": \"Kiribati\"\n}, {\n  \"E164\": \"383\",\n  \"country\": \"Kosovo\"\n}, {\n  \"E164\": \"965\",\n  \"country\": \"Kuwait\"\n}, {\n  \"E164\": \"996\",\n  \"country\": \"Kyrgyzstan\"\n}, {\n  \"E164\": \"856\",\n  \"country\": \"Laos\"\n}, {\n  \"E164\": \"371\",\n  \"country\": \"Latvia\"\n}, {\n  \"E164\": \"961\",\n  \"country\": \"Lebanon\"\n}, {\n  \"E164\": \"266\",\n  \"country\": \"Lesotho\"\n}, {\n  \"E164\": \"231\",\n  \"country\": \"Liberia\"\n}, {\n  \"E164\": \"218\",\n  \"country\": \"Libya\"\n}, {\n  \"E164\": \"423\",\n  \"country\": \"Liechtenstein\"\n}, {\n  \"E164\": \"370\",\n  \"country\": \"Lithuania\"\n}, {\n  \"E164\": \"352\",\n  \"country\": \"Luxembourg\"\n}, {\n  \"E164\": \"853\",\n  \"country\": \"Macao\"\n}, {\n  \"E164\": \"389\",\n  \"country\": \"Macedonia\"\n}, {\n  \"E164\": \"261\",\n  \"country\": \"Madagascar\"\n}, {\n  \"E164\": \"265\",\n  \"country\": \"Malawi\"\n}, {\n  \"E164\": \"60\",\n  \"country\": \"Malaysia\"\n}, {\n  \"E164\": \"960\",\n  \"country\": \"Maldives\"\n}, {\n  \"E164\": \"223\",\n  \"country\": \"Mali\"\n}, {\n  \"E164\": \"356\",\n  \"country\": \"Malta\"\n}, {\n  \"E164\": \"692\",\n  \"country\": \"Marshall Islands\"\n}, {\n  \"E164\": \"222\",\n  \"country\": \"Mauritania\"\n}, {\n  \"E164\": \"230\",\n  \"country\": \"Mauritius\"\n}, {\n  \"E164\": \"262\",\n  \"country\": [\"Mayotte\", \"Reunion\"]\n}, {\n  \"E164\": \"52\",\n  \"country\": \"Mexico\"\n}, {\n  \"E164\": \"691\",\n  \"country\": \"Micronesia\"\n}, {\n  \"E164\": \"373\",\n  \"country\": \"Moldova\"\n}, {\n  \"E164\": \"377\",\n  \"country\": \"Monaco\"\n}, {\n  \"E164\": \"976\",\n  \"country\": \"Mongolia\"\n}, {\n  \"E164\": \"382\",\n  \"country\": \"Montenegro\"\n}, {\n  \"E164\": \"212\",\n  \"country\": [\"Morocco\", \"Western Sahara\"]\n}, {\n  \"E164\": \"258\",\n  \"country\": \"Mozambique\"\n}, {\n  \"E164\": \"95\",\n  \"country\": \"Myanmar\"\n}, {\n  \"E164\": \"264\",\n  \"country\": \"Namibia\"\n}, {\n  \"E164\": \"674\",\n  \"country\": \"Nauru\"\n}, {\n  \"E164\": \"977\",\n  \"country\": \"Nepal\"\n}, {\n  \"E164\": \"31\",\n  \"country\": \"Netherlands\"\n}, {\n  \"E164\": \"687\",\n  \"country\": \"New Caledonia\"\n}, {\n  \"E164\": \"64\",\n  \"country\": \"New Zealand\"\n}, {\n  \"E164\": \"64\",\n  \"country\": \"Pitcairn\"\n}, {\n  \"E164\": \"505\",\n  \"country\": \"Nicaragua\"\n}, {\n  \"E164\": \"227\",\n  \"country\": \"Niger\"\n}, {\n  \"E164\": \"234\",\n  \"country\": \"Nigeria\"\n}, {\n  \"E164\": \"683\",\n  \"country\": \"Niue\"\n}, {\n  \"E164\": \"850\",\n  \"country\": \"North Korea\"\n}, {\n  \"E164\": \"47\",\n  \"country\": [\"Norway\", \"Svalbard and Jan Mayen\"]\n}, {\n  \"E164\": \"968\",\n  \"country\": \"Oman\"\n}, {\n  \"E164\": \"92\",\n  \"country\": \"Pakistan\"\n}, {\n  \"E164\": \"680\",\n  \"country\": \"Palau\"\n}, {\n  \"E164\": \"970\",\n  \"country\": \"Palestine\"\n}, {\n  \"E164\": \"507\",\n  \"country\": \"Panama\"\n}, {\n  \"E164\": \"675\",\n  \"country\": \"Papua New Guinea\"\n}, {\n  \"E164\": \"595\",\n  \"country\": \"Paraguay\"\n}, {\n  \"E164\": \"51\",\n  \"country\": \"Peru\"\n}, {\n  \"E164\": \"63\",\n  \"country\": \"Philippines\"\n}, {\n  \"E164\": \"48\",\n  \"country\": \"Poland\"\n}, {\n  \"E164\": \"351\",\n  \"country\": \"Portugal\"\n}, {\n  \"E164\": \"974\",\n  \"country\": \"Qatar\"\n}, {\n  \"E164\": \"242\",\n  \"country\": \"Republic of the Congo\"\n}, {\n  \"E164\": \"40\",\n  \"country\": \"Romania\"\n}, {\n  \"E164\": \"250\",\n  \"country\": \"Rwanda\"\n}, {\n  \"E164\": \"590\",\n  \"country\": \"Saint Barthelemy\"\n}, {\n  \"E164\": \"290\",\n  \"country\": \"Saint Helena\"\n}, {\n  \"E164\": \"508\",\n  \"country\": \"Saint Pierre and Miquelon\"\n}, {\n  \"E164\": \"685\",\n  \"country\": \"Samoa\"\n}, {\n  \"E164\": \"378\",\n  \"country\": \"San Marino\"\n}, {\n  \"E164\": \"239\",\n  \"country\": \"Sao Tome and Principe\"\n}, {\n  \"E164\": \"966\",\n  \"country\": \"Saudi Arabia\"\n}, {\n  \"E164\": \"221\",\n  \"country\": \"Senegal\"\n}, {\n  \"E164\": \"381\",\n  \"country\": \"Serbia\"\n}, {\n  \"E164\": \"248\",\n  \"country\": \"Seychelles\"\n}, {\n  \"E164\": \"232\",\n  \"country\": \"Sierra Leone\"\n}, {\n  \"E164\": \"65\",\n  \"country\": \"Singapore\"\n}, {\n  \"E164\": \"421\",\n  \"country\": \"Slovakia\"\n}, {\n  \"E164\": \"386\",\n  \"country\": \"Slovenia\"\n}, {\n  \"E164\": \"677\",\n  \"country\": \"Solomon Islands\"\n}, {\n  \"E164\": \"252\",\n  \"country\": \"Somalia\"\n}, {\n  \"E164\": \"27\",\n  \"country\": \"South Africa\"\n}, {\n  \"E164\": \"82\",\n  \"country\": \"South Korea\"\n}, {\n  \"E164\": \"211\",\n  \"country\": \"South Sudan\"\n}, {\n  \"E164\": \"34\",\n  \"country\": \"Spain\"\n}, {\n  \"E164\": \"94\",\n  \"country\": \"Sri Lanka\"\n}, {\n  \"E164\": \"249\",\n  \"country\": \"Sudan\"\n}, {\n  \"E164\": \"597\",\n  \"country\": \"Suriname\"\n}, {\n  \"E164\": \"268\",\n  \"country\": \"Swaziland\"\n}, {\n  \"E164\": \"46\",\n  \"country\": \"Sweden\"\n}, {\n  \"E164\": \"41\",\n  \"country\": \"Switzerland\"\n}, {\n  \"E164\": \"963\",\n  \"country\": \"Syria\"\n}, {\n  \"E164\": \"886\",\n  \"country\": \"Taiwan\"\n}, {\n  \"E164\": \"992\",\n  \"country\": \"Tajikistan\"\n}, {\n  \"E164\": \"255\",\n  \"country\": \"Tanzania\"\n}, {\n  \"E164\": \"66\",\n  \"country\": \"Thailand\"\n}, {\n  \"E164\": \"228\",\n  \"country\": \"Togo\"\n}, {\n  \"E164\": \"690\",\n  \"country\": \"Tokelau\"\n}, {\n  \"E164\": \"676\",\n  \"country\": \"Tonga\"\n}, {\n  \"E164\": \"216\",\n  \"country\": \"Tunisia\"\n}, {\n  \"E164\": \"90\",\n  \"country\": \"Turkey\"\n}, {\n  \"E164\": \"993\",\n  \"country\": \"Turkmenistan\"\n}, {\n  \"E164\": \"688\",\n  \"country\": \"Tuvalu\"\n}, {\n  \"E164\": \"256\",\n  \"country\": \"Uganda\"\n}, {\n  \"E164\": \"380\",\n  \"country\": \"Ukraine\"\n}, {\n  \"E164\": \"971\",\n  \"country\": \"United Arab Emirates\"\n}, {\n  \"E164\": \"598\",\n  \"country\": \"Uruguay\"\n}, {\n  \"E164\": \"998\",\n  \"country\": \"Uzbekistan\"\n}, {\n  \"E164\": \"678\",\n  \"country\": \"Vanuatu\"\n}, {\n  \"E164\": \"58\",\n  \"country\": \"Venezuela\"\n}, {\n  \"E164\": \"84\",\n  \"country\": \"Vietnam\"\n}, {\n  \"E164\": \"681\",\n  \"country\": \"Wallis and Futuna\"\n}, {\n  \"E164\": \"967\",\n  \"country\": \"Yemen\"\n}, {\n  \"E164\": \"260\",\n  \"country\": \"Zambia\"\n}, {\n  \"E164\": \"263\",\n  \"country\": \"Zimbabwe\"\n}];\nexports['default'] = PhoneFormatter;\nmodule.exports = exports['default'];\n\n},{\"./delimited_text_formatter\":10}],19:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _delimited_text_formatter = _dereq_('./delimited_text_formatter');\n\nvar _delimited_text_formatter2 = _interopRequireDefault(_delimited_text_formatter);\n\n/**\n * @const\n * @private\n */\nvar DIGITS_PATTERN = /^\\d*$/;\n\n/**\n * @extends DelimitedTextFormatter\n */\n\nvar SocialSecurityNumberFormatter = (function (_DelimitedTextFormatter) {\n  _inherits(SocialSecurityNumberFormatter, _DelimitedTextFormatter);\n\n  function SocialSecurityNumberFormatter() {\n    _classCallCheck(this, SocialSecurityNumberFormatter);\n\n    _get(Object.getPrototypeOf(SocialSecurityNumberFormatter.prototype), 'constructor', this).call(this, '-');\n    this.maximumLength = 9 + 2;\n  }\n\n  /**\n   * @param {number} index\n   * @returns {boolean}\n   */\n\n  _createClass(SocialSecurityNumberFormatter, [{\n    key: 'hasDelimiterAtIndex',\n    value: function hasDelimiterAtIndex(index) {\n      return index === 3 || index === 6;\n    }\n\n    /**\n     * Determines whether the given change should be allowed and, if so, whether\n     * it should be altered.\n     *\n     * @param {TextFieldStateChange} change\n     * @param {function(string)} error\n     * @returns {boolean}\n     */\n  }, {\n    key: 'isChangeValid',\n    value: function isChangeValid(change, error) {\n      if (DIGITS_PATTERN.test(change.inserted.text)) {\n        return _get(Object.getPrototypeOf(SocialSecurityNumberFormatter.prototype), 'isChangeValid', this).call(this, change, error);\n      } else {\n        return false;\n      }\n    }\n  }]);\n\n  return SocialSecurityNumberFormatter;\n})(_delimited_text_formatter2['default']);\n\nexports['default'] = SocialSecurityNumberFormatter;\nmodule.exports = exports['default'];\n\n},{\"./delimited_text_formatter\":10}],20:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _formatter = _dereq_('./formatter');\n\nvar _formatter2 = _interopRequireDefault(_formatter);\n\nvar _undo_manager = _dereq_('./undo_manager');\n\nvar _undo_manager2 = _interopRequireDefault(_undo_manager);\n\nvar _utils = _dereq_('./utils');\n\nvar _caret = _dereq_('./caret');\n\nvar _caret2 = _interopRequireDefault(_caret);\n\n/**\n * Simulates input behavior.\n *\n * @external InputSim\n * @see https://github.com/iamJoeTaylor/input-sim\n */\n\nvar _inputSim = _dereq_('input-sim');\n\n/**\n * TextField is the simplest input and the base for more complex\n * types to inherit.\n *\n * @extends external:InputSim.Input\n */\n\nvar _installCaret = (0, _caret2['default'])();\n\nvar getCaret = _installCaret.getCaret;\nvar setCaret = _installCaret.setCaret;\n\nvar TextField = (function (_Input) {\n  _inherits(TextField, _Input);\n\n  /**\n   * Sets up the initial properties of the TextField and\n   * sets  up the event listeners\n   *\n   * @param {HTMLElement} element\n   * @param {Formatter} formatter\n   */\n\n  function TextField(element, formatter) {\n    _classCallCheck(this, TextField);\n\n    _get(Object.getPrototypeOf(TextField.prototype), 'constructor', this).call(this);\n\n    var caret = getCaret(element);\n    if (typeof element.get === 'function') {\n      console.warn('DEPRECATION: FieldKit.TextField instances should no longer be ' + 'created with a jQuery-wrapped element.');\n      element = element.get(0);\n    }\n    this.element = element;\n    this._formatter = formatter;\n    this._enabled = true;\n    this._manualCaret = { start: 0, end: 0 };\n    this._placeholder = null;\n    this._disabledPlaceholder = null;\n    this._focusedPlaceholder = null;\n    this._unfocusedPlaceholder = null;\n    this._isDirty = false;\n    this._valueOnFocus = '';\n    this._currentValue = '';\n    // Make sure textDidChange fires while the value is correct\n    this._needsKeyUpTextDidChangeTrigger = false;\n    this._blur = (0, _utils.bind)(this._blur, this);\n    this._focus = (0, _utils.bind)(this._focus, this);\n    this._click = (0, _utils.bind)(this._click, this);\n    this._paste = (0, _utils.bind)(this._paste, this);\n    this._keyUp = (0, _utils.bind)(this._keyUp, this);\n    this._keyPress = (0, _utils.bind)(this._keyPress, this);\n    this._keyDown = (0, _utils.bind)(this._keyDown, this);\n    if (element['field-kit-text-field']) {\n      throw new Error('already attached a TextField to this element');\n    } else {\n      element['field-kit-text-field'] = this;\n    }\n    element.addEventListener('keydown', this._keyDown);\n    element.addEventListener('keypress', this._keyPress);\n    element.addEventListener('keyup', this._keyUp);\n    element.addEventListener('click', this._click);\n    element.addEventListener('paste', this._paste);\n    element.addEventListener('focus', this._focus);\n    element.addEventListener('blur', this._blur);\n\n    if (!element.getAttribute('autocapitalize')) {\n      element.setAttribute('autocapitalize', 'off');\n    }\n\n    var window = element.ownerDocument.defaultView;\n\n    /**\n     * Fixes caret bug (Android) that caused the input\n     * to place inserted characters in the wrong place\n     * Expected: 1234 5678|  =>  1234 5678 9|\n     * Bug: 1234 5678|  =>  1234 5679| 8\n     *\n     * @private\n     */\n    this._needsManualCaret = window.navigator.userAgent.toLowerCase().indexOf('android') > -1;\n\n    this.setText(element.value);\n\n    this.setSelectedRange({\n      start: caret.start,\n      length: caret.end - caret.start\n    });\n  }\n\n  /**\n   * Helps calculate the changes after an event on a FieldKit.TextField.\n   *\n   * @private\n   */\n\n  /**\n   * **** Public Events ****\n   */\n\n  /**\n   * Called when the user has changed the text of the field. Can be used in\n   * subclasses to perform actions suitable for this event.\n   *\n   * @private\n   */\n\n  _createClass(TextField, [{\n    key: 'textDidChange',\n    value: function textDidChange() {}\n\n    /**\n     * Called when the user has in some way declared that they are done editing,\n     * such as leaving the field or perhaps pressing enter. Can be used in\n     * subclasses to perform actions suitable for this event.\n     *\n     * @private\n     */\n  }, {\n    key: 'textFieldDidEndEditing',\n    value: function textFieldDidEndEditing() {}\n\n    /**\n     * Performs actions necessary for beginning editing.\n     *\n     * @private\n     */\n  }, {\n    key: 'textFieldDidBeginEditing',\n    value: function textFieldDidBeginEditing() {}\n\n    /**\n     * **** Private Events ****\n     */\n\n    /**\n     * Performs actions necessary for text change.\n     *\n     * @private\n     */\n  }, {\n    key: '_textDidChange',\n    value: function _textDidChange() {\n      var delegate = this._delegate;\n      this.textDidChange();\n      if (delegate && typeof delegate.textDidChange === 'function') {\n        delegate.textDidChange(this);\n      }\n\n      // manually fire the HTML5 input event\n      this._fireEvent('input');\n    }\n\n    /**\n     * Performs actions necessary for ending editing.\n     *\n     * @private\n     */\n  }, {\n    key: '_textFieldDidEndEditing',\n    value: function _textFieldDidEndEditing() {\n      var delegate = this._delegate;\n      this.textFieldDidEndEditing();\n      if (delegate && typeof delegate.textFieldDidEndEditing === 'function') {\n        delegate.textFieldDidEndEditing(this);\n      }\n\n      // manually fire the HTML5 change event, only when a change has been made since focus\n      if (this._isDirty && this._valueOnFocus !== this.element.value) {\n        this._fireEvent('change');\n      }\n\n      // reset the dirty property\n      this._isDirty = false;\n      this._valueOnFocus = '';\n    }\n\n    /**\n     * Performs actions necessary for beginning editing.\n     *\n     * @private\n     */\n  }, {\n    key: '_textFieldDidBeginEditing',\n    value: function _textFieldDidBeginEditing() {\n      var delegate = this._delegate;\n      this.textFieldDidBeginEditing();\n      if (delegate && typeof delegate.textFieldDidBeginEditing === 'function') {\n        delegate.textFieldDidBeginEditing(this);\n      }\n    }\n\n    /**\n     * **** Public Methods ****\n     */\n\n    /**\n     * Gets the current delegate for this text field.\n     *\n     * @returns {TextFieldDelegate}\n     */\n  }, {\n    key: 'delegate',\n    value: function delegate() {\n      return this._delegate;\n    }\n\n    /**\n     * Sets the current delegate for this text field.\n     *\n     * @param {TextFieldDelegate} delegate\n     */\n  }, {\n    key: 'setDelegate',\n    value: function setDelegate(delegate) {\n      this._delegate = delegate;\n    }\n\n    /**\n     * Tears down FieldKit\n     */\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      var element = this.element;\n      element.removeEventListener('keydown', this._keyDown);\n      element.removeEventListener('keypress', this._keyPress);\n      element.removeEventListener('keyup', this._keyUp);\n      element.removeEventListener('click', this._click);\n      element.removeEventListener('paste', this._paste);\n      element.removeEventListener('focus', this._focus);\n      element.removeEventListener('blur', this._blur);\n      delete element['field-kit-text-field'];\n    }\n\n    /**\n     * Gets the current formatter. Formatters are used to translate between text\n     * and value properties of the field.\n     *\n     * @returns {Formatter}\n     */\n  }, {\n    key: 'formatter',\n    value: function formatter() {\n      if (!this._formatter) {\n        this._formatter = new _formatter2['default']();\n        var maximumLengthString = this.element.getAttribute('maxlength');\n        if (maximumLengthString !== undefined && maximumLengthString !== null) {\n          this._formatter.maximumLength = parseInt(maximumLengthString, 10);\n        }\n      }\n\n      return this._formatter;\n    }\n\n    /**\n     * Sets the current formatter.\n     *\n     * @param {Formatter} formatter\n     */\n  }, {\n    key: 'setFormatter',\n    value: function setFormatter(formatter) {\n      var value = this.value();\n      this._formatter = formatter;\n      this.setValue(value);\n    }\n\n    /**\n     * Builds a change instance and formats the change to see if it's valid\n     *\n     * @param   {object} current\n     * @param   {object} proposed\n     * @returns {?object} false if change doesn't have changes or change isn't valid. Change object if it is.\n     */\n  }, {\n    key: 'hasChangesAndIsValid',\n    value: function hasChangesAndIsValid(current, proposed) {\n      var _this = this;\n\n      var change = new TextFieldStateChange(this);\n      var error = function error(errorType) {\n        var delegate = _this.delegate();\n        if (delegate) {\n          if (typeof delegate.textFieldDidFailToValidateChange === 'function') {\n            delegate.textFieldDidFailToValidateChange(_this, change, errorType);\n          }\n        }\n      };\n      change.current = { text: current.text, selectedRange: current.selectedRange };\n      change.proposed = { text: proposed.text, selectedRange: proposed.selectedRange };\n      if (change.hasChanges() && this.formatter().isChangeValid(change, error)) {\n        return change;\n      }\n      return null;\n    }\n\n    /**\n     * Handles a key event could be trying to end editing.\n     *\n     */\n  }, {\n    key: 'insertNewline',\n    value: function insertNewline() {\n      this._textFieldDidEndEditing();\n      this._didEndEditingButKeptFocus = true;\n    }\n\n    /**\n     * Debug support\n     *\n     * @returns {string}\n     */\n  }, {\n    key: 'inspect',\n    value: function inspect() {\n      return '#<TextField text=\"' + this.text() + '\">';\n    }\n\n    /**\n     * Replaces the current selection with text from the given pasteboard.\n     *\n     * @param {DataTransfer} pasteboard\n     */\n  }, {\n    key: 'readSelectionFromPasteboard',\n    value: function readSelectionFromPasteboard(pasteboard) {\n      var range = undefined,\n          text = undefined;\n      text = pasteboard.getData('Text');\n      this.replaceSelection(text);\n      range = this.selectedRange();\n      range.start += range.length;\n      range.length = 0;\n      this.setSelectedRange(range);\n    }\n\n    /**\n     * Checks changes after invoking the passed function for validity and rolls\n     * them back if the changes turned out to be invalid.\n     *\n     * @returns {Object} whatever object `callback` returns\n     */\n  }, {\n    key: 'rollbackInvalidChanges',\n    value: function rollbackInvalidChanges(callback) {\n      var result = null;\n      var errorType = null;\n      var change = TextFieldStateChange.build(this, function () {\n        return result = callback();\n      });\n      var error = function error(type) {\n        errorType = type;\n      };\n      if (change.hasChanges()) {\n        var formatter = this.formatter();\n        if (formatter && typeof formatter.isChangeValid === 'function') {\n          if (!this._isDirty) {\n            this._valueOnFocus = change.current.text || '';\n            this._isDirty = true;\n          }\n          if (formatter.isChangeValid(change, error)) {\n            change.recomputeDiff();\n            this.setText(change.proposed.text);\n            this.setSelectedRange(change.proposed.selectedRange);\n          } else {\n            var delegate = this.delegate();\n            if (delegate) {\n              if (typeof delegate.textFieldDidFailToValidateChange === 'function') {\n                delegate.textFieldDidFailToValidateChange(this, change, errorType);\n              }\n            }\n            this.setText(change.current.text);\n            this.setSelectedRange(change.current.selectedRange);\n            return result;\n          }\n        }\n        if (change.inserted.text.length || change.deleted.text.length) {\n          this.undoManager().proxyFor(this)._applyChangeFromUndoManager(change);\n          this._textDidChange();\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Gets the object value. This is the value that should be considered the\n     * 'real' value of the field.\n     *\n     * @returns {Object}\n     */\n  }, {\n    key: 'value',\n    value: function value() {\n      var _this2 = this;\n\n      var text = this.text();\n      var delegate = this.delegate();\n      var formatter = this.formatter();\n      if (!formatter) {\n        return text;\n      }\n\n      return formatter.parse(text, function (errorType) {\n        if (delegate) {\n          if (typeof delegate.textFieldDidFailToParseString === 'function') {\n            delegate.textFieldDidFailToParseString(_this2, text, errorType);\n          }\n        }\n      });\n    }\n\n    /**\n     * Sets the object value of the field.\n     *\n     * @param {string} value\n     */\n  }, {\n    key: 'setValue',\n    value: function setValue(value) {\n      if (this._formatter) {\n        value = this._formatter.format(value);\n      }\n      this.setText('' + value);\n    }\n\n    /**\n     * **** InputSim Overrides ****\n     */\n\n    /**\n     * Gets the formatted text value. This is the same as the value of the\n     * underlying input element.\n     *\n     * @augments external:InputSim.Input#text\n     * @returns {string}\n     */\n  }, {\n    key: 'text',\n    value: function text() {\n      return this.element.value;\n    }\n\n    /**\n     * Sets the formatted text value. This generally should not be used. Instead,\n     * use the value setter.\n     *\n     * @augments external:InputSim.Input#setText\n     * @param {string} text\n     */\n  }, {\n    key: 'setText',\n    value: function setText(text) {\n      this.element.value = text;\n      this._currentValue = text;\n    }\n\n    /**\n     * Gets the range of the current selection.\n     *\n     * @augments external:InputSim.Input#selectedRange\n     * @returns {Object} {start: number, length: number}\n     */\n  }, {\n    key: 'selectedRange',\n    value: function selectedRange() {\n      var caret = this._needsManualCaret ? this._manualCaret : getCaret(this.element);\n\n      return {\n        start: caret.start,\n        length: caret.end - caret.start\n      };\n    }\n\n    /**\n     * Sets the range of the current selection and the selection affinity.\n     *\n     * @augments external:InputSim.Input#setSelectedRangeWithAffinity\n     * @param {{start: number, length: number}} range\n     * @param {Affinity} affinity\n     */\n  }, {\n    key: 'setSelectedRangeWithAffinity',\n    value: function setSelectedRangeWithAffinity(range, affinity) {\n      var newRange = _get(Object.getPrototypeOf(TextField.prototype), 'setSelectedRangeWithAffinity', this).call(this, range, affinity);\n      var caret = {\n        start: newRange.start,\n        end: newRange.start + newRange.length\n      };\n      this._manualCaret = caret;\n      setCaret(this.element, caret.start, caret.end);\n      this.selectionAffinity = range.length === 0 ? null : affinity;\n    }\n\n    /**\n     * **** Undo Support ****\n     */\n\n    /**\n     * Gets whether this text field records undo actions with its undo manager.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: 'allowsUndo',\n    value: function allowsUndo() {\n      return this._allowsUndo;\n    }\n\n    /**\n     * Sets whether this text field records undo actions with its undo manager.\n     *\n     * @param {boolean} allowsUndo\n     */\n  }, {\n    key: 'setAllowsUndo',\n    value: function setAllowsUndo(allowsUndo) {\n      this._allowsUndo = allowsUndo;\n    }\n\n    /**\n     * Triggers a redo in the underlying UndoManager, if applicable.\n     *\n     * @param {Event} event\n     */\n  }, {\n    key: 'redo',\n    value: function redo(event) {\n      if (this.undoManager().canRedo()) {\n        this.undoManager().redo();\n      }\n      event.preventDefault();\n    }\n\n    /**\n     * Triggers an undo in the underlying UndoManager, if applicable.\n     *\n     * @param {Event} event\n     */\n  }, {\n    key: 'undo',\n    value: function undo(event) {\n      if (this.undoManager().canUndo()) {\n        this.undoManager().undo();\n      }\n      event.preventDefault();\n    }\n\n    /**\n     * Gets the UndoManager for this text field.\n     *\n     * @returns {UndoManager}\n     */\n  }, {\n    key: 'undoManager',\n    value: function undoManager() {\n      return this._undoManager || (this._undoManager = new _undo_manager2['default']());\n    }\n\n    /**\n     * **** Enabled/disabled support *****\n     */\n\n    /**\n     * Removes focus from this field if it has focus.\n     */\n  }, {\n    key: 'becomeFirstResponder',\n    value: function becomeFirstResponder() {\n      var _this3 = this;\n\n      this.element.focus();\n      this.rollbackInvalidChanges(function () {\n        _this3.element.select();\n        _this3._syncPlaceholder();\n      });\n    }\n\n    /**\n     * Determines whether this field has focus.\n     *\n     * @returns {boolean} true if this field has focus\n     */\n  }, {\n    key: 'hasFocus',\n    value: function hasFocus() {\n      return this.element.ownerDocument.activeElement === this.element;\n    }\n\n    /**\n     * Determines whether this field is enabled or disabled.\n     *\n     * @returns {boolean} true if this field is enabled\n     */\n  }, {\n    key: 'isEnabled',\n    value: function isEnabled() {\n      return this._enabled;\n    }\n\n    /**\n     * Sets whether this text field is enabled\n     * and syncs the placeholder to match\n     *\n     * @param {boolean} enabled\n     */\n  }, {\n    key: 'setEnabled',\n    value: function setEnabled(enabled) {\n      this._enabled = enabled;\n      this._syncPlaceholder();\n    }\n\n    /**\n     * Removes focus from this field if it has focus.\n     *\n     * @param {Event} event\n     */\n  }, {\n    key: 'resignFirstResponder',\n    value: function resignFirstResponder(event) {\n      if (event !== undefined && event !== null) {\n        event.preventDefault();\n      }\n      this.element.blur();\n      this._syncPlaceholder();\n    }\n\n    /*\n     * **** Placeholder support ****\n     */\n\n    /**\n     * Gets the disabled placeholder if one\n     * has been set.\n     *\n     * @returns {string}\n     */\n  }, {\n    key: 'disabledPlaceholder',\n    value: function disabledPlaceholder() {\n      return this._disabledPlaceholder;\n    }\n\n    /**\n     * Sets the disabled placeholder.\n     *\n     * @param {string} disabledPlaceholder\n     */\n  }, {\n    key: 'setDisabledPlaceholder',\n    value: function setDisabledPlaceholder(disabledPlaceholder) {\n      this._disabledPlaceholder = disabledPlaceholder;\n      this._syncPlaceholder();\n    }\n\n    /**\n     * Gets the focused placeholder if one\n     * has been set.\n     *\n     * @returns {string}\n     */\n  }, {\n    key: 'focusedPlaceholder',\n    value: function focusedPlaceholder() {\n      return this._focusedPlaceholder;\n    }\n\n    /**\n     * Sets the focused placeholder.\n     *\n     * @param {string} focusedPlaceholder\n     */\n  }, {\n    key: 'setFocusedPlaceholder',\n    value: function setFocusedPlaceholder(focusedPlaceholder) {\n      this._focusedPlaceholder = focusedPlaceholder;\n      this._syncPlaceholder();\n    }\n\n    /**\n     * Gets the placeholder if one has\n     * been set.\n     *\n     * @TODO Does this do anything?\n     *\n     * @returns {string}\n     */\n  }, {\n    key: 'placeholder',\n    value: function placeholder() {\n      return this._placeholder;\n    }\n\n    /**\n     * Sets the placeholder.\n     *\n     * @param {string} placeholder\n     */\n  }, {\n    key: 'setPlaceholder',\n    value: function setPlaceholder(placeholder) {\n      this._placeholder = placeholder;\n      this.element.setAttribute('placeholder', this._placeholder);\n    }\n\n    /**\n     * Gets the unfocused placeholder if one\n     * has been set.\n     *\n     * @returns {string}\n     */\n  }, {\n    key: 'unfocusedPlaceholder',\n    value: function unfocusedPlaceholder() {\n      return this._unfocusedPlaceholder;\n    }\n\n    /**\n     * Sets the unfocused placeholder.\n     *\n     * @param {string} unfocusedPlaceholder\n     */\n  }, {\n    key: 'setUnfocusedPlaceholder',\n    value: function setUnfocusedPlaceholder(unfocusedPlaceholder) {\n      this._unfocusedPlaceholder = unfocusedPlaceholder;\n      this._syncPlaceholder();\n    }\n\n    /**\n     * **** Private Methods ****\n     */\n\n    /**\n     * Applies the given change as an undo/redo.\n     *\n     * @param {Object} change object with current and proposed properties\n     * @private\n     */\n  }, {\n    key: '_applyChangeFromUndoManager',\n    value: function _applyChangeFromUndoManager(change) {\n      this.undoManager().proxyFor(this)._applyChangeFromUndoManager(change);\n\n      if (this.undoManager().isUndoing()) {\n        this.setText(change.current.text);\n        this.setSelectedRange(change.current.selectedRange);\n      } else {\n        this.setText(change.proposed.text);\n        this.setSelectedRange(change.proposed.selectedRange);\n      }\n\n      this._textDidChange();\n    }\n\n    /**\n     * Handles clicks by resetting the selection affinity.\n     *\n     * @private\n     */\n  }, {\n    key: '_click',\n    value: function _click() {\n      this._manualCaret = getCaret(this.element);\n      this._selectedRange = {\n        start: this._manualCaret.start,\n        length: this._manualCaret.end - this._manualCaret.start\n      };\n      this.selectionAffinity = null;\n    }\n\n    /**\n     * Fires event on the element\n     *\n     * @param {string} eventType\n     * @private\n     */\n  }, {\n    key: '_fireEvent',\n    value: function _fireEvent(eventType) {\n      var document = this.element.ownerDocument;\n      var window = document.defaultView;\n      if (typeof window.CustomEvent === 'function') {\n        this.element.dispatchEvent(new window.CustomEvent(eventType, {}));\n      } else {\n        var _event = document.createEvent('Event');\n        _event.initEvent(eventType, false, false);\n        this.element.dispatchEvent(_event);\n      }\n    }\n\n    /**\n     * Handles gaining focus. This method delegates to other methods, and syncs\n     * the placeholder appropriately.\n     *\n     * @private\n     */\n  }, {\n    key: '_focus',\n    value: function _focus() {\n      this._textFieldDidBeginEditing();\n      this._syncPlaceholder();\n    }\n\n    /**\n     * Handles losing focus. This method delegates to other methods, and syncs the\n     * placeholder appropriately.\n     *\n     * @private\n     */\n  }, {\n    key: '_blur',\n    value: function _blur() {\n      this._textFieldDidEndEditing();\n      this._syncPlaceholder();\n    }\n\n    /**\n     * Handles keyDown events. This method essentially just delegates to other,\n     * more semantic, methods based on the modifier keys and the pressed key of the\n     * event.\n     *\n     * @param {Event} event\n     * @private\n     */\n  }, {\n    key: '_keyDown',\n    value: function _keyDown(event) {\n      var _this4 = this;\n\n      if (this._didEndEditingButKeptFocus) {\n        this._textFieldDidBeginEditing();\n        this._didEndEditingButKeptFocus = false;\n      }\n\n      var action = this._bindings.actionForEvent(event);\n      if (action) {\n        switch (action) {\n          case 'undo':\n          case 'redo':\n            this[action](event);\n            break;\n\n          default:\n            this.rollbackInvalidChanges(function () {\n              return _this4[action](event);\n            });\n            break;\n        }\n      }\n    }\n\n    /**\n     * Handles inserting characters based on the typed key for normal keyboards.\n     *\n     * NOTE: Does not fire on some versions of Android, in which case we handle\n     * changes in _keyUp instead.\n     *\n     * @param {Event} event\n     * @private\n     */\n  }, {\n    key: '_keyPress',\n    value: function _keyPress(event) {\n      var _this5 = this;\n\n      var keyCode = event.keyCode;\n      if (!event.metaKey && !event.ctrlKey && keyCode !== _inputSim.KEYS.ENTER && keyCode !== _inputSim.KEYS.TAB && keyCode !== _inputSim.KEYS.BACKSPACE) {\n        if (event.charCode !== 0) {\n          (function () {\n            var newText = String.fromCharCode(event.charCode || event.keyCode);\n\n            _this5._processChange({\n              currentText: _this5.text(),\n              proposedText: (0, _utils.replaceStringSelection)(newText, _this5.text(), _this5.selectedRange()),\n              onSuccess: function onSuccess(change, changeTriggeredFormatting) {\n                if (!changeTriggeredFormatting && event instanceof KeyboardEvent) {\n                  // HACK(JoeTaylor) Use Browser's native input when using the formatter\n                  // would not make a difference https://code.google.com/p/chromium/issues/detail?id=32865\n                  if (!_this5._isDirty) {\n                    _this5._valueOnFocus = change.current.text || '';\n                    _this5._isDirty = true;\n                  }\n                  _this5.undoManager().proxyFor(_this5)._applyChangeFromUndoManager(change);\n                  _this5._manualCaret = {\n                    start: change.proposed.selectedRange.start,\n                    end: change.proposed.selectedRange.start + change.proposed.selectedRange.length\n                  };\n                  _this5._needsKeyUpTextDidChangeTrigger = true;\n                } else {\n                  event.preventDefault();\n                  _this5.rollbackInvalidChanges(function () {\n                    return _this5.insertText(newText);\n                  });\n                }\n                _this5._currentValue = change.proposed.text;\n              },\n              onFail: function onFail() {\n                event.preventDefault();\n                _this5.rollbackInvalidChanges(function () {\n                  return _this5.insertText(newText);\n                });\n              }\n            });\n          })();\n        } else {\n          event.preventDefault();\n        }\n      }\n    }\n\n    /**\n     * Handles keyup events. On Some Android we need to do all input processing\n     * here because no other information comes in.\n     *\n     * @param {Event} event\n     * @private\n     */\n  }, {\n    key: '_keyUp',\n    value: function _keyUp(event) {\n      var _this6 = this;\n\n      if (this._needsKeyUpTextDidChangeTrigger) {\n        this._textDidChange();\n        this._needsKeyUpTextDidChangeTrigger = false;\n      }\n      var keyCode = event.keyCode;\n      // NOTE: Certain Androids on Chrome always return 229\n      // https://code.google.com/p/chromium/issues/detail?id=118639\n      if (keyCode === 229) {\n        (function () {\n          // Text has already been changed at this point, so we check the previous text\n          // to determine whether we need to undo the change.\n          var previousText = _this6._currentValue || '';\n          _this6._processChange({\n            currentText: previousText,\n            proposedText: _this6.text(),\n            onSuccess: function onSuccess(change, changeTriggeredFormatting) {\n              if (changeTriggeredFormatting) {\n                var newText = change.proposed.text;\n                _this6.setSelectedRange(change.proposed.selectedRange);\n                _this6.setText(newText);\n              }\n              if (!_this6._isDirty) {\n                _this6._valueOnFocus = change.current.text || '';\n                _this6._isDirty = true;\n              }\n              _this6.undoManager().proxyFor(_this6)._applyChangeFromUndoManager(change);\n              _this6._textDidChange();\n              _this6._currentValue = change.proposed.text;\n            },\n            onFail: function onFail() {\n              // Need to rollback the letter input in the Keyup event because it is not valid,\n              // so we set text to the previous state (as collected from the UndoManager).\n              _this6.setText(previousText);\n            }\n          });\n        })();\n      } else {\n        this.rollbackInvalidChanges(function () {\n          if (event.keyCode === _inputSim.KEYS.TAB) {\n            _this6.selectAll(event);\n          }\n        });\n      }\n    }\n\n    /**\n     * Checks if a change is valid and calls `onSuccess` if so,\n     * and `onFail` if not.\n     *\n     * @param {object} options\n     * @param {string} options.currentText\n     * @param {string} options.proposedText\n     * @param {function} options.onSuccess\n     * @param {function=} options.onFail\n     * @private\n     */\n  }, {\n    key: '_processChange',\n    value: function _processChange(_ref) {\n      var currentText = _ref.currentText;\n      var proposedText = _ref.proposedText;\n      var onSuccess = _ref.onSuccess;\n      var _ref$onFail = _ref.onFail;\n      var onFail = _ref$onFail === undefined ? function () {} : _ref$onFail;\n\n      var current = {\n        text: currentText,\n        selectedRange: this.selectedRange()\n      };\n      var proposed = {\n        text: proposedText,\n        selectedRange: { start: current.selectedRange.start + 1, length: 0 }\n      };\n      var change = this.hasChangesAndIsValid(current, proposed);\n      var changeTriggeredFormatting = change && (change.proposed.text !== proposed.text || change.proposed.selectedRange.start !== proposed.selectedRange.start || change.proposed.selectedRange.length !== proposed.selectedRange.length);\n\n      if (change) {\n        onSuccess(change, changeTriggeredFormatting);\n      } else {\n        onFail();\n      }\n    }\n\n    /**\n     * Handles paste events.\n     *\n     * @param {Event} event\n     * @private\n     */\n  }, {\n    key: '_paste',\n    value: function _paste(event) {\n      var _this7 = this;\n\n      event.preventDefault();\n      this.rollbackInvalidChanges(function () {\n        _this7.readSelectionFromPasteboard(event.clipboardData);\n      });\n    }\n\n    /**\n     * @private\n     */\n  }, {\n    key: '_syncPlaceholder',\n    value: function _syncPlaceholder() {\n      if (!this._enabled) {\n        var disabledPlaceholder = this._disabledPlaceholder;\n        if (disabledPlaceholder !== undefined && disabledPlaceholder !== null) {\n          this.setPlaceholder(disabledPlaceholder);\n        }\n      } else if (this.hasFocus()) {\n        var focusedPlaceholder = this._focusedPlaceholder;\n        if (focusedPlaceholder !== undefined && focusedPlaceholder !== null) {\n          this.setPlaceholder(focusedPlaceholder);\n        }\n      } else {\n        var unfocusedPlaceholder = this._unfocusedPlaceholder;\n        if (unfocusedPlaceholder !== undefined && unfocusedPlaceholder !== null) {\n          this.setPlaceholder(unfocusedPlaceholder);\n        }\n      }\n    }\n  }]);\n\n  return TextField;\n})(_inputSim.Input);\n\nvar TextFieldStateChange = (function () {\n  /**\n   * @param {TextField} field\n   */\n\n  function TextFieldStateChange(field) {\n    _classCallCheck(this, TextFieldStateChange);\n\n    this.field = field;\n  }\n\n  /**\n   * Builds a new {TextFieldStateChange} that will allow you to\n   * compute differences, and see the current vs proposed changes.\n   *\n   * @param {TextField} field\n   * @param {Function} callback called when you want changes to the field\n   *    take place. Current will be calculated before this callback.\n   *    Proposed will be calculated after this callback.\n   *\n   * @returns {Object} change object with current and proposed properties\n   */\n\n  /**\n   * Determines whether this field has changes.\n   *\n   * @returns {boolean} true if either the current text doesn't match the proposed text\n   *    or the current selection range doesn't match the proposed selection range\n   */\n\n  _createClass(TextFieldStateChange, [{\n    key: 'hasChanges',\n    value: function hasChanges() {\n      this.recomputeDiff();\n      return this.current.text !== this.proposed.text || this.current.selectedRange.start !== this.proposed.selectedRange.start || this.current.selectedRange.length !== this.proposed.selectedRange.length;\n    }\n\n    /**\n     * Updates {TextFieldStateChange} inserted and {TextFieldStateChange} deleted\n     * based on proposed and current\n     */\n  }, {\n    key: 'recomputeDiff',\n    value: function recomputeDiff() {\n      if (this.proposed.text !== this.current.text) {\n        var ctext = this.current.text;\n        var ptext = this.proposed.text;\n        var sharedPrefixLength = 0;\n        var sharedSuffixLength = 0;\n        var minTextLength = Math.min(ctext.length, ptext.length);\n        var i = undefined;\n\n        for (i = 0; i < minTextLength; i++) {\n          if (ptext[i] === ctext[i]) {\n            sharedPrefixLength = i + 1;\n          } else {\n            break;\n          }\n        }\n\n        for (i = 0; i < minTextLength - sharedPrefixLength; i++) {\n          if (ptext[ptext.length - 1 - i] === ctext[ctext.length - 1 - i]) {\n            sharedSuffixLength = i + 1;\n          } else {\n            break;\n          }\n        }\n\n        var inserted = {\n          start: sharedPrefixLength,\n          end: ptext.length - sharedSuffixLength\n        };\n        var deleted = {\n          start: sharedPrefixLength,\n          end: ctext.length - sharedSuffixLength\n        };\n        inserted.text = ptext.substring(inserted.start, inserted.end);\n        deleted.text = ctext.substring(deleted.start, deleted.end);\n        this.inserted = inserted;\n        this.deleted = deleted;\n      } else {\n        this.inserted = {\n          start: this.proposed.selectedRange.start,\n          end: this.proposed.selectedRange.start + this.proposed.selectedRange.length,\n          text: ''\n        };\n        this.deleted = {\n          start: this.current.selectedRange.start,\n          end: this.current.selectedRange.start + this.current.selectedRange.length,\n          text: ''\n        };\n      }\n    }\n  }]);\n\n  return TextFieldStateChange;\n})();\n\nTextFieldStateChange.build = function (field, callback) {\n  var change = new this(field);\n  change.current = {\n    text: field.text(),\n    selectedRange: field.selectedRange()\n  };\n  callback();\n  change.proposed = {\n    text: field.text(),\n    selectedRange: field.selectedRange()\n  };\n  change.recomputeDiff();\n  return change;\n};\n\nexports['default'] = TextField;\nmodule.exports = exports['default'];\n\n},{\"./caret\":8,\"./formatter\":14,\"./undo_manager\":21,\"./utils\":22,\"input-sim\":2}],21:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar _utils = _dereq_('./utils');\n\n/**\n * UndoManager is a general-purpose recorder of operations for undo and redo.\n *\n * Registering an undo action is done by specifying the changed object, along\n * with a method to invoke to revert its state and the arguments for that\n * method. When performing undo an UndoManager saves the operations reverted so\n * that you can redo the undos.\n */\n\nvar UndoManager = (function () {\n  function UndoManager() {\n    _classCallCheck(this, UndoManager);\n\n    /** @private */\n    this._undos = [];\n    /** @private */\n    this._redos = [];\n    /** @private */\n    this._isUndoing = false;\n    /** @private */\n    this._isRedoing = false;\n  }\n\n  /**\n   * Determines whether there are any undo actions on the stack.\n   *\n   * @returns {boolean}\n   */\n\n  _createClass(UndoManager, [{\n    key: 'canUndo',\n    value: function canUndo() {\n      return this._undos.length !== 0;\n    }\n\n    /**\n     * Determines whether there are any redo actions on the stack.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: 'canRedo',\n    value: function canRedo() {\n      return this._redos.length !== 0;\n    }\n\n    /**\n     * Indicates whether or not this manager is currently processing an undo.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: 'isUndoing',\n    value: function isUndoing() {\n      return this._isUndoing;\n    }\n\n    /**\n     * Indicates whether or not this manager is currently processing a redo.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: 'isRedoing',\n    value: function isRedoing() {\n      return this._isRedoing;\n    }\n\n    /**\n     * Manually registers an simple undo action with the given args.\n     *\n     * If this undo manager is currently undoing then this will register a redo\n     * action instead. If this undo manager is neither undoing or redoing then the\n     * redo stack will be cleared.\n     *\n     * @param {Object} target call `selector` on this object\n     * @param {string} selector the method name to call on `target`\n     * @param {...Object} args arguments to pass when calling `selector` on `target`\n     */\n  }, {\n    key: 'registerUndo',\n    value: function registerUndo(target, selector) {\n      for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        args[_key - 2] = arguments[_key];\n      }\n\n      if (this._isUndoing) {\n        this._appendRedo.apply(this, [target, selector].concat(args));\n      } else {\n        if (!this._isRedoing) {\n          this._redos.length = 0;\n        }\n        this._appendUndo.apply(this, [target, selector].concat(args));\n      }\n    }\n\n    /**\n     * Appends an undo action to the internal stack.\n     *\n     * @param {Object} target call `selector` on this object\n     * @param {string} selector the method name to call on `target`\n     * @param {...Object} args arguments to pass when calling `selector` on `target`\n     * @private\n     */\n  }, {\n    key: '_appendUndo',\n    value: function _appendUndo(target, selector) {\n      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        args[_key2 - 2] = arguments[_key2];\n      }\n\n      this._undos.push({\n        target: target,\n        selector: selector,\n        args: args\n      });\n    }\n\n    /**\n     * Appends a redo action to the internal stack.\n     *\n     * @param {Object} target call `selector` on this object\n     * @param {string} selector the method name to call on `target`\n     * @param {...Object} args arguments to pass when calling `selector` on `target`\n     * @private\n     */\n  }, {\n    key: '_appendRedo',\n    value: function _appendRedo(target, selector) {\n      for (var _len3 = arguments.length, args = Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n        args[_key3 - 2] = arguments[_key3];\n      }\n\n      this._redos.push({\n        target: target,\n        selector: selector,\n        args: args\n      });\n    }\n\n    /**\n     * Performs the top-most undo action on the stack.\n     *\n     * @throws {Error} Raises an error if there are no available undo actions.\n     */\n  }, {\n    key: 'undo',\n    value: function undo() {\n      if (!this.canUndo()) {\n        throw new Error('there are no registered undos');\n      }\n      var data = this._undos.pop();\n      var target = data.target;\n      var selector = data.selector;\n      var args = data.args;\n      this._isUndoing = true;\n      target[selector].apply(target, args);\n      this._isUndoing = false;\n    }\n\n    /**\n     * Performs the top-most redo action on the stack.\n     *\n     * @throws {Error} Raises an error if there are no available redo actions.\n     */\n  }, {\n    key: 'redo',\n    value: function redo() {\n      if (!this.canRedo()) {\n        throw new Error('there are no registered redos');\n      }\n      var data = this._redos.pop();\n      var target = data.target;\n      var selector = data.selector;\n      var args = data.args;\n      this._isRedoing = true;\n      target[selector].apply(target, args);\n      this._isRedoing = false;\n    }\n\n    /**\n     * Returns a proxy object based on target that will register undo/redo actions\n     * by calling methods on the proxy.\n     *\n     * @example\n     *     setSize(size) {\n     *       this.undoManager.proxyFor(this).setSize(this._size);\n     *       this._size = size;\n     *     }\n     *\n     * @param {Object} target call `selector` on this object\n     * @returns {Object}\n     */\n  }, {\n    key: 'proxyFor',\n    value: function proxyFor(target) {\n      var proxy = {};\n      var self = this;\n\n      function proxyMethod(selector) {\n        return function () {\n          for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n            args[_key4] = arguments[_key4];\n          }\n\n          self.registerUndo.apply(self, [target, selector].concat(args));\n        };\n      }\n\n      (0, _utils.getAllPropertyNames)(target).forEach(function (selector) {\n        // don't trigger anything that has a getter\n        if ((0, _utils.hasGetter)(target, selector)) {\n          return;\n        }\n\n        // don't try to proxy properties that aren't functions\n        if (typeof target[selector] !== 'function') {\n          return;\n        }\n\n        // set up a proxy function to register an undo\n        proxy[selector] = proxyMethod(selector);\n      });\n\n      return proxy;\n    }\n  }]);\n\n  return UndoManager;\n})();\n\nexports['default'] = UndoManager;\nmodule.exports = exports['default'];\n\n},{\"./utils\":22}],22:[function(_dereq_,module,exports){\n/**\n * @const\n * @private\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.isDigits = isDigits;\nexports.startsWith = startsWith;\nexports.endsWith = endsWith;\nexports.zpad = zpad;\nexports.zpad2 = zpad2;\nexports.bind = bind;\nexports.replaceStringSelection = replaceStringSelection;\nexports.forEach = forEach;\nexports.hasGetter = hasGetter;\nexports.getAllPropertyNames = getAllPropertyNames;\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\nvar DIGITS_PATTERN = /^\\d*$/;\n\n/**\n * @const\n * @private\n */\nvar SURROUNDING_SPACE_PATTERN = /(^\\s+|\\s+$)/;\n\n/**\n * @param {string} string\n * @returns {boolean}\n */\n\nfunction isDigits(string) {\n  return DIGITS_PATTERN.test(string);\n}\n\n/**\n * @param {string} prefix\n * @param {string} string\n * @returns {boolean}\n */\n\nfunction startsWith(prefix, string) {\n  return string.slice(0, prefix.length) === prefix;\n}\n\n/**\n * @param {string} suffix\n * @param {string} string\n * @returns {boolean}\n */\n\nfunction endsWith(suffix, string) {\n  return string.slice(string.length - suffix.length) === suffix;\n}\n\n/**\n * @param {string} string\n * @returns {string}\n */\nvar trim = typeof ''.trim === 'function' ? function (string) {\n  return string.trim();\n} : function (string) {\n  return string.replace(SURROUNDING_SPACE_PATTERN, '');\n};\n\nexports.trim = trim;\n/**\n * Will pad n with `0` up until length.\n *\n * @example\n *     zpad(16, '1234');\n *     // => 0000000000001234\n *\n * @param {number} length\n * @param {(string|number)} n\n * @returns {string}\n */\n\nfunction zpad(length, n) {\n  var result = '' + n;\n  while (result.length < length) {\n    result = '0' + result;\n  }\n  return result;\n}\n\n/**\n * Will pad n with `0` up until length is 2.\n *\n * @example\n *     zpad2('2');\n *     // => 02\n *\n * @param {(string|number)} n\n * @returns {string}\n */\n\nfunction zpad2(n) {\n  return zpad(2, n);\n}\n\n/**\n * PhantomJS 1.9 does not have Function.bind.\n *\n * @param {Function} fn\n * @param {*} context\n * @returns {*}\n */\n\nfunction bind(fn, context) {\n  return fn.bind(context);\n}\n\nif (!Function.prototype.bind) {\n  Function.prototype.bind = function (context) {\n    for (var _len = arguments.length, prependedArgs = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      prependedArgs[_key - 1] = arguments[_key];\n    }\n\n    var self = this;\n    return function () {\n      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return self.apply(context, prependedArgs.concat(args));\n    };\n  };\n}\n\n/**\n * Replaces the characters within the selection with given text.\n *\n * @example\n *     // 12|34567|8\n *     replaceStringSelection('12345678', '00', { start: 2, length: 5 });\n *     // 12|00|8\n *\n * @param   {string} replacement\n * @param   {string} text\n * @param   {object} {start: number, length: number}\n * @returns {string}\n */\n\nfunction replaceStringSelection(replacement, text, range) {\n  var end = range.start + range.length;\n  return text.substring(0, range.start) + replacement + text.substring(end);\n}\n\nvar hasOwnProp = Object.prototype.hasOwnProperty;\n/**\n * @param {*} iterable\n * @param {Function} iterator\n */\n\nfunction forEach(iterable, iterator) {\n  if (iterable && typeof iterable.forEach === 'function') {\n    iterable.forEach(iterator);\n  } else if (({}).toString.call(iterable) === '[object Array]') {\n    for (var i = 0, l = iterable.length; i < l; i++) {\n      iterator.call(null, iterable[i], i, iterable);\n    }\n  } else {\n    for (var key in iterable) {\n      if (hasOwnProp.call(iterable, key)) {\n        iterator.call(null, iterable[key], key, iterable);\n      }\n    }\n  }\n}\n\nvar getOwnPropertyNames = (function () {\n  var getOwnPropertyNames = Object.getOwnPropertyNames;\n\n  try {\n    Object.getOwnPropertyNames({}, 'sq');\n  } catch (e) {\n    // IE 8\n    getOwnPropertyNames = function (object) {\n      var result = [];\n      for (var key in object) {\n        if (hasOwnProp.call(object, key)) {\n          result.push(key);\n        }\n      }\n      return result;\n    };\n  }\n\n  return getOwnPropertyNames;\n})();\n\nvar getPrototypeOf = Object.getPrototypeOf || function (object) {\n  return object.__proto__;\n};\n/**\n * @param {Object} object\n * @param {string} property\n * @returns {boolean}\n */\n\nfunction hasGetter(object, property) {\n  // Skip if getOwnPropertyDescriptor throws (IE8)\n  try {\n    Object.getOwnPropertyDescriptor({}, 'sq');\n  } catch (e) {\n    return false;\n  }\n\n  var descriptor = undefined;\n\n  if (object && object.constructor && object.constructor.prototype) {\n    descriptor = Object.getOwnPropertyDescriptor(object.constructor.prototype, property);\n  }\n\n  if (!descriptor) {\n    descriptor = Object.getOwnPropertyDescriptor(object, property);\n  }\n\n  if (descriptor && descriptor.get) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\n/**\n * @param {Object} object\n * @returns {?string[]}\n */\n\nfunction getAllPropertyNames(object) {\n  if (object === null || object === undefined) {\n    return [];\n  }\n\n  var result = getOwnPropertyNames(object);\n\n  var prototype = object.constructor && object.constructor.prototype;\n  while (prototype) {\n    result.push.apply(result, _toConsumableArray(getOwnPropertyNames(prototype)));\n    prototype = getPrototypeOf(prototype);\n  }\n\n  return result;\n}\n\n},{}]},{},[15])(15)\n});"],"file":"field-kit.js","sourceRoot":"/source/"}