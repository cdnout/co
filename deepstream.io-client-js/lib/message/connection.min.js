"use strict";var _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},BrowserWebSocket=global.WebSocket||global.MozWebSocket,NodeWebSocket=require("ws"),messageParser=require("./message-parser"),messageBuilder=require("./message-builder"),utils=require("../utils/utils"),C=require("../constants/constants"),Connection=function(t,e,n){this._client=t,this._options=n,this._authParams=null,this._authCallback=null,this._deliberateClose=!1,this._redirecting=!1,this._tooManyAuthAttempts=!1,this._connectionAuthenticationTimeout=!1,this._challengeDenied=!1,this._queuedMessages=[],this._reconnectTimeout=null,this._reconnectionAttempt=0,this._currentPacketMessageCount=0,this._sendNextPacketTimeout=null,this._currentMessageResetTimeout=null,this._endpoint=null,this._lastHeartBeat=null,this._heartbeatInterval=null,this._originalUrl=utils.parseUrl(e,this._options.path),this._url=this._originalUrl,this._state=C.CONNECTION_STATE.CLOSED,this._createEndpoint()};Connection.prototype.getState=function(){return this._state},Connection.prototype.authenticate=function(t,e){if("object"===(void 0===t?"undefined":_typeof(t))){if(this._authParams=t,this._authCallback=e,!(this._tooManyAuthAttempts||this._challengeDenied||this._connectionAuthenticationTimeout))return!0===this._deliberateClose&&this._state===C.CONNECTION_STATE.CLOSED?(this._createEndpoint(),void(this._deliberateClose=!1)):void(this._state===C.CONNECTION_STATE.AWAITING_AUTHENTICATION&&this._sendAuthParams());this._client._$onError(C.TOPIC.ERROR,C.EVENT.IS_CLOSED,"this client's connection was closed")}else this._client._$onError(C.TOPIC.ERROR,C.EVENT.INVALID_AUTH_MSG,"authParams is not an object")},Connection.prototype.sendMsg=function(t,e,n){this.send(messageBuilder.getMsg(t,e,n))},Connection.prototype.send=function(t){this._queuedMessages.push(t),this._currentPacketMessageCount++,null===this._currentMessageResetTimeout&&(this._currentMessageResetTimeout=utils.nextTick(this._resetCurrentMessageCount.bind(this))),this._state===C.CONNECTION_STATE.OPEN&&this._queuedMessages.length<this._options.maxMessagesPerPacket&&this._currentPacketMessageCount<this._options.maxMessagesPerPacket?this._sendQueuedMessages():null===this._sendNextPacketTimeout&&this._queueNextPacket()},Connection.prototype.close=function(){clearInterval(this._heartbeatInterval),this._deliberateClose=!0,this._endpoint.close(),this._setState(C.CONNECTION_STATE.CLOSED)},Connection.prototype._createEndpoint=function(){this._endpoint=BrowserWebSocket?new BrowserWebSocket(this._url):new NodeWebSocket(this._url,this._options.nodeSocketOptions),this._endpoint.onopen=this._onOpen.bind(this),this._endpoint.onerror=this._onError.bind(this),this._endpoint.onclose=this._onClose.bind(this),this._endpoint.onmessage=this._onMessage.bind(this)},Connection.prototype._resetCurrentMessageCount=function(){this._currentPacketMessageCount=0,this._currentMessageResetTimeout=null},Connection.prototype._sendQueuedMessages=function(){if(this._state===C.CONNECTION_STATE.OPEN&&this._endpoint.readyState===this._endpoint.OPEN)if(0!==this._queuedMessages.length){var t=this._queuedMessages.splice(0,this._options.maxMessagesPerPacket).join("");0!==this._queuedMessages.length?this._queueNextPacket():this._sendNextPacketTimeout=null,this._submit(t)}else this._sendNextPacketTimeout=null},Connection.prototype._submit=function(t){this._endpoint.readyState===this._endpoint.OPEN?this._endpoint.send(t):this._onError("Tried to send message on a closed websocket connection")},Connection.prototype._queueNextPacket=function(){var t=this._sendQueuedMessages.bind(this),e=this._options.timeBetweenSendingQueuedPackages;this._sendNextPacketTimeout=setTimeout(t,e)},Connection.prototype._sendAuthParams=function(){this._setState(C.CONNECTION_STATE.AUTHENTICATING);var t=messageBuilder.getMsg(C.TOPIC.AUTH,C.ACTIONS.REQUEST,[this._authParams]);this._submit(t)},Connection.prototype._checkHeartBeat=function(){var t=2*this._options.heartbeatInterval;Date.now()-this._lastHeartBeat>t&&(clearInterval(this._heartbeatInterval),this._endpoint.close(),this._client._$onError(C.TOPIC.CONNECTION,C.EVENT.CONNECTION_ERROR,"heartbeat not received in the last "+t+" milliseconds"))},Connection.prototype._onOpen=function(){this._clearReconnect(),this._lastHeartBeat=Date.now(),this._heartbeatInterval=utils.setInterval(this._checkHeartBeat.bind(this),this._options.heartbeatInterval),this._setState(C.CONNECTION_STATE.AWAITING_CONNECTION)},Connection.prototype._onError=function(n){var t=this;clearInterval(this._heartbeatInterval),this._setState(C.CONNECTION_STATE.ERROR),setTimeout(function(){var e=void 0;if("ECONNRESET"===n.code||"ECONNREFUSED"===n.code)e="Can't connect! Deepstream server unreachable on "+t._originalUrl;else try{e=JSON.stringify(n)}catch(t){e=n.toString()}t._client._$onError(C.TOPIC.CONNECTION,C.EVENT.CONNECTION_ERROR,e)},1)},Connection.prototype._onClose=function(){clearInterval(this._heartbeatInterval),!0===this._redirecting?(this._redirecting=!1,this._createEndpoint()):!0===this._deliberateClose?this._setState(C.CONNECTION_STATE.CLOSED):this._tryReconnect()},Connection.prototype._onMessage=function(t){for(var e=messageParser.parse(t.data,this._client),n=0;n<e.length;n++)null!==e[n]&&(e[n].topic===C.TOPIC.CONNECTION?this._handleConnectionResponse(e[n]):e[n].topic===C.TOPIC.AUTH?this._handleAuthResponse(e[n]):this._client._$onMessage(e[n]))},Connection.prototype._handleConnectionResponse=function(t){t.action===C.ACTIONS.PING?(this._lastHeartBeat=Date.now(),this._submit(messageBuilder.getMsg(C.TOPIC.CONNECTION,C.ACTIONS.PONG))):t.action===C.ACTIONS.ACK?(this._setState(C.CONNECTION_STATE.AWAITING_AUTHENTICATION),this._authParams&&this._sendAuthParams()):t.action===C.ACTIONS.CHALLENGE?(this._setState(C.CONNECTION_STATE.CHALLENGING),this._submit(messageBuilder.getMsg(C.TOPIC.CONNECTION,C.ACTIONS.CHALLENGE_RESPONSE,[this._originalUrl]))):t.action===C.ACTIONS.REJECTION?(this._challengeDenied=!0,this.close()):t.action===C.ACTIONS.REDIRECT?(this._url=t.data[0],this._redirecting=!0,this._endpoint.close()):t.action===C.ACTIONS.ERROR&&t.data[0]===C.EVENT.CONNECTION_AUTHENTICATION_TIMEOUT&&(this._deliberateClose=!0,this._connectionAuthenticationTimeout=!0,this._client._$onError(C.TOPIC.CONNECTION,t.data[0],t.data[1]))},Connection.prototype._handleAuthResponse=function(t){if(t.action===C.ACTIONS.ERROR){if(t.data[0]===C.EVENT.TOO_MANY_AUTH_ATTEMPTS)this._deliberateClose=!0,this._tooManyAuthAttempts=!0;else{if(t.data[0]===C.EVENT.INVALID_AUTH_MSG)return this._deliberateClose=!0,void(this._authCallback&&this._authCallback(!1,"invalid authentication message"));this._setState(C.CONNECTION_STATE.AWAITING_AUTHENTICATION)}this._authCallback&&this._authCallback(!1,this._getAuthData(t.data[1]))}else t.action===C.ACTIONS.ACK&&(this._setState(C.CONNECTION_STATE.OPEN),this._authCallback&&this._authCallback(!0,this._getAuthData(t.data[0])),this._sendQueuedMessages())},Connection.prototype._getAuthData=function(t){return void 0===t?null:messageParser.convertTyped(t,this._client)},Connection.prototype._setState=function(t){this._state=t,this._client.emit(C.EVENT.CONNECTION_STATE_CHANGED,t)},Connection.prototype._tryReconnect=function(){null===this._reconnectTimeout&&(this._reconnectionAttempt<this._options.maxReconnectAttempts?(this._setState(C.CONNECTION_STATE.RECONNECTING),this._reconnectTimeout=setTimeout(this._tryOpen.bind(this),Math.min(this._options.maxReconnectInterval,this._options.reconnectIntervalIncrement*this._reconnectionAttempt)),this._reconnectionAttempt++):(this._clearReconnect(),this.close(),this._client.emit(C.EVENT.MAX_RECONNECTION_ATTEMPTS_REACHED,this._reconnectionAttempt)))},Connection.prototype._tryOpen=function(){this._originalUrl!==this._url&&(this._url=this._originalUrl),this._createEndpoint(),this._reconnectTimeout=null},Connection.prototype._clearReconnect=function(){clearTimeout(this._reconnectTimeout),this._reconnectTimeout=null,this._reconnectionAttempt=0},module.exports=Connection;